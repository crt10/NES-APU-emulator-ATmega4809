
AVRASM ver. 2.2.8  C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm Sat Jan 23 22:42:53 2021

C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
                                 
                                 
                                 ; NES_APU_2a03.asm
                                 ;
                                 ; Created: 11/29/2020 1:44:10 AM
                                 ; Author : Tennyson Cheng
                                 ;
                                 
                                 .list
                                 
                                 .dseg
002800                           pulse1_param: .byte 1 //$4000 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002801                           pulse1_sweep_param: .byte 1 //$4001 EPPP.NSSS = Enable, Period, Negate, Shift
                                 //NOTE: In order to account for multiplier, we use 16 instead of 11 bits for the timer
002802                           pulse1_timerL: .byte 1 //$4002 LLLL.LLLL = Low 8 bits for timer
002803                           pulse1_timerH: .byte 1 //$4002 HHHH.HHHH = High 8 bits for timer
002804                           pulse1_length: .byte 1 //$4003 000l.llll = Length counter load
002805                           pulse1_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002806                           pulse1_output_volume: .byte 1 //this is the final output volume of pulse 1
002807                           pulse1_note: .byte 1 //the current note index in the note table
                                 
002808                           pulse2_param: .byte 1 //$4004 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002809                           pulse2_sweep_param: .byte 1 //$4005 EPPP.NSSS = Enable, Period, Negate, Shift
00280a                           pulse2_timerL: .byte 1 //$4006 LLLL.LLLL = Low 8 bits for timer
00280b                           pulse2_timerH: .byte 1 //$4006 HHHH.HHHH = High 8 bits for timer
00280c                           pulse2_length: .byte 1 //$4007 000l.llll = Length counter load
00280d                           pulse2_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
00280e                           pulse2_output_volume: .byte 1 //this is the final output volume of pulse 2
00280f                           pulse2_note: .byte 1 //the current note index in the note table
                                 
002810                           triangle_timerL: .byte 1 //$400A LLLL.LLLL = Low 8 bits for timer
002811                           triangle_timerH: .byte 1 //$400A HHHH.HHHH = High 8 bits for time
002812                           triangle_note: .byte 1 //the current note index in the note table
                                 
002813                           noise_param: .byte 1 //$400C 00lc.vvvv = Length counter halt/Loop flag, Constant volume flag, Volume
002814                           noise_period: .byte 1 //$400E M000.PPPP = Mode, Period
002815                           noise_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002816                           noise_output_volume: .byte 1 //this is the final output volume of pulse 2
002817                           noise_note: .byte 1 //the current note index in the period table
                                 
002818                           song_frames: .byte 2
00281a                           song_frame_offset: .byte 2
00281c                           song_size: .byte 2
00281e                           song_speed: .byte 1
                                 //song_channel_delay_reload: .byte 1 //bit 0-4 represents channels 0-4. a set bit means that there is a delay that needs to be calculated for that channel.
00281f                           song_fx_Bxx: .byte 1
002820                           song_fx_Cxx: .byte 1
002821                           song_fx_Dxx: .byte 1
                                 
                                 //PULSE 1
002822                           pulse1_pattern: .byte 2
002824                           pulse1_pattern_delay_rows: .byte 1
002825                           pulse1_pattern_delay_frames: .byte 1
002826                           pulse1_pattern_offset: .byte 2
                                 
002828                           pulse1_volume_macro: .byte 2
00282a                           pulse1_volume_macro_offset: .byte 1
00282b                           pulse1_volume_macro_loop: .byte 1
00282c                           pulse1_volume_macro_release: .byte 1
                                 
00282d                           pulse1_arpeggio_macro: .byte 2
00282f                           pulse1_arpeggio_macro_offset: .byte 1
002830                           pulse1_arpeggio_macro_loop: .byte 1
002831                           pulse1_arpeggio_macro_release: .byte 1
002832                           pulse1_arpeggio_macro_mode: .byte 1
                                 
002833                           pulse1_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002835                           pulse1_pitch_macro: .byte 2
002837                           pulse1_pitch_macro_offset: .byte 1
002838                           pulse1_pitch_macro_loop: .byte 1
002839                           pulse1_pitch_macro_release: .byte 1
                                 
00283a                           pulse1_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00283b                           pulse1_hi_pitch_macro: .byte 2
00283d                           pulse1_hi_pitch_macro_offset: .byte 1
00283e                           pulse1_hi_pitch_macro_loop: .byte 1
00283f                           pulse1_hi_pitch_macro_release: .byte 1
                                 
002840                           pulse1_duty_macro: .byte 2
002842                           pulse1_duty_macro_offset: .byte 1
002843                           pulse1_duty_macro_loop: .byte 1
002844                           pulse1_duty_macro_release: .byte 1
                                 
002845                           pulse1_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002847                           pulse1_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002849                           pulse1_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00284b                           pulse1_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
00284d                           pulse1_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
00284f                           pulse1_fx_3xx_start: .byte 2 //the starting note period
002851                           pulse1_fx_3xx_target: .byte 2 //target note period
002853                           pulse1_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
002855                           pulse1_fx_3xx_total_offset: .byte 2
002857                           pulse1_fx_4xy_speed: .byte 1
002858                           pulse1_fx_4xy_depth: .byte 1
002859                           pulse1_fx_4xy_phase: .byte 1
00285a                           pulse1_fx_7xy_speed: .byte 1
00285b                           pulse1_fx_7xy_depth: .byte 1
00285c                           pulse1_fx_7xy_phase: .byte 1
00285d                           pulse1_fx_7xy_value: .byte 1 //value to offset the volume
00285e                           pulse1_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
00285f                           pulse1_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002860                           pulse1_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002861                           pulse1_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
002863                           pulse1_fx_Qxy_target_note: .byte 1 //target note index
002864                           pulse1_fx_Qxy_target: .byte 2 //target note period
002866                           pulse1_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002868                           pulse1_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
00286a                           pulse1_fx_Rxy_target_note: .byte 1 //target note index
00286b                           pulse1_fx_Rxy_target: .byte 2 //target note period
00286d                           pulse1_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
00286f                           pulse1_fx_Rxy_total_offset: .byte 2
002871                           pulse1_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002872                           pulse1_fx_Sxx_post: .byte 1
                                 
                                 //PULSE 2
002873                           pulse2_pattern: .byte 2
002875                           pulse2_pattern_delay_rows: .byte 1
002876                           pulse2_pattern_delay_frames: .byte 1
002877                           pulse2_pattern_offset: .byte 2
                                 
002879                           pulse2_volume_macro: .byte 2
00287b                           pulse2_volume_macro_offset: .byte 1
00287c                           pulse2_volume_macro_loop: .byte 1
00287d                           pulse2_volume_macro_release: .byte 1
                                 
00287e                           pulse2_arpeggio_macro: .byte 2
002880                           pulse2_arpeggio_macro_offset: .byte 1
002881                           pulse2_arpeggio_macro_loop: .byte 1
002882                           pulse2_arpeggio_macro_release: .byte 1
002883                           pulse2_arpeggio_macro_mode: .byte 1
                                 
002884                           pulse2_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002886                           pulse2_pitch_macro: .byte 2
002888                           pulse2_pitch_macro_offset: .byte 1
002889                           pulse2_pitch_macro_loop: .byte 1
00288a                           pulse2_pitch_macro_release: .byte 1
                                 
00288b                           pulse2_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00288c                           pulse2_hi_pitch_macro: .byte 2
00288e                           pulse2_hi_pitch_macro_offset: .byte 1
00288f                           pulse2_hi_pitch_macro_loop: .byte 1
002890                           pulse2_hi_pitch_macro_release: .byte 1
                                 
002891                           pulse2_duty_macro: .byte 2
002893                           pulse2_duty_macro_offset: .byte 1
002894                           pulse2_duty_macro_loop: .byte 1
002895                           pulse2_duty_macro_release: .byte 1
                                 
002896                           pulse2_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002898                           pulse2_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
00289a                           pulse2_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00289c                           pulse2_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
00289e                           pulse2_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
0028a0                           pulse2_fx_3xx_start: .byte 2 //the starting note period
0028a2                           pulse2_fx_3xx_target: .byte 2 //target note period
0028a4                           pulse2_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028a6                           pulse2_fx_3xx_total_offset: .byte 2
0028a8                           pulse2_fx_4xy_speed: .byte 1
0028a9                           pulse2_fx_4xy_depth: .byte 1
0028aa                           pulse2_fx_4xy_phase: .byte 1
0028ab                           pulse2_fx_7xy_speed: .byte 1
0028ac                           pulse2_fx_7xy_depth: .byte 1
0028ad                           pulse2_fx_7xy_phase: .byte 1
0028ae                           pulse2_fx_7xy_value: .byte 1 //value to offset the volume
0028af                           pulse2_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
0028b0                           pulse2_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028b1                           pulse2_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028b2                           pulse2_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
0028b4                           pulse2_fx_Qxy_target_note: .byte 1 //target note index
0028b5                           pulse2_fx_Qxy_target: .byte 2 //target note period
0028b7                           pulse2_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
0028b9                           pulse2_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
0028bb                           pulse2_fx_Rxy_target_note: .byte 1 //target note index
0028bc                           pulse2_fx_Rxy_target: .byte 2 //target note period
0028be                           pulse2_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
0028c0                           pulse2_fx_Rxy_total_offset: .byte 2
0028c2                           pulse2_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
0028c3                           pulse2_fx_Sxx_post: .byte 1
                                 
                                 //TRIANGLE
0028c4                           triangle_pattern: .byte 2
0028c6                           triangle_pattern_delay_rows: .byte 1
0028c7                           triangle_pattern_delay_frames: .byte 1
0028c8                           triangle_pattern_offset: .byte 2
                                 
0028ca                           triangle_volume_macro: .byte 2
0028cc                           triangle_volume_macro_offset: .byte 1
0028cd                           triangle_volume_macro_loop: .byte 1
0028ce                           triangle_volume_macro_release: .byte 1
                                 
0028cf                           triangle_arpeggio_macro: .byte 2
0028d1                           triangle_arpeggio_macro_offset: .byte 1
0028d2                           triangle_arpeggio_macro_loop: .byte 1
0028d3                           triangle_arpeggio_macro_release: .byte 1
0028d4                           triangle_arpeggio_macro_mode: .byte 1
                                 
0028d5                           triangle_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
0028d7                           triangle_pitch_macro: .byte 2
0028d9                           triangle_pitch_macro_offset: .byte 1
0028da                           triangle_pitch_macro_loop: .byte 1
0028db                           triangle_pitch_macro_release: .byte 1
                                 
0028dc                           triangle_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
0028dd                           triangle_hi_pitch_macro: .byte 2
0028df                           triangle_hi_pitch_macro_offset: .byte 1
0028e0                           triangle_hi_pitch_macro_loop: .byte 1
0028e1                           triangle_hi_pitch_macro_release: .byte 1
                                 
0028e2                           triangle_duty_macro: .byte 2
0028e4                           triangle_duty_macro_offset: .byte 1
0028e5                           triangle_duty_macro_loop: .byte 1
0028e6                           triangle_duty_macro_release: .byte 1
                                 
0028e7                           triangle_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
0028e9                           triangle_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
0028eb                           triangle_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
0028ed                           triangle_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
0028ef                           triangle_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
0028f1                           triangle_fx_3xx_start: .byte 2 //the starting note period
0028f3                           triangle_fx_3xx_target: .byte 2 //target note period
0028f5                           triangle_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028f7                           triangle_fx_3xx_total_offset: .byte 2
0028f9                           triangle_fx_4xy_speed: .byte 1
0028fa                           triangle_fx_4xy_depth: .byte 1
0028fb                           triangle_fx_4xy_phase: .byte 1
0028fc                           triangle_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028fd                           triangle_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028fe                           triangle_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
002900                           triangle_fx_Qxy_target_note: .byte 1 //target note index
002901                           triangle_fx_Qxy_target: .byte 2 //target note period
002903                           triangle_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002905                           triangle_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002907                           triangle_fx_Rxy_target_note: .byte 1 //target note index
002908                           triangle_fx_Rxy_target: .byte 2 //target note period
00290a                           triangle_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
00290c                           triangle_fx_Rxy_total_offset: .byte 2
00290e                           triangle_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
00290f                           triangle_fx_Sxx_post: .byte 1
                                 
                                 //NOISE
002910                           noise_pattern: .byte 2
002912                           noise_pattern_delay_rows: .byte 1
002913                           noise_pattern_delay_frames: .byte 1
002914                           noise_pattern_offset: .byte 2
                                 
002916                           noise_volume_macro: .byte 2
002918                           noise_volume_macro_offset: .byte 1
002919                           noise_volume_macro_loop: .byte 1
00291a                           noise_volume_macro_release: .byte 1
                                 
00291b                           noise_arpeggio_macro: .byte 2
00291d                           noise_arpeggio_macro_offset: .byte 1
00291e                           noise_arpeggio_macro_loop: .byte 1
00291f                           noise_arpeggio_macro_release: .byte 1
002920                           noise_arpeggio_macro_mode: .byte 1
                                 
002921                           noise_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002923                           noise_pitch_macro: .byte 2
002925                           noise_pitch_macro_offset: .byte 1
002926                           noise_pitch_macro_loop: .byte 1
002927                           noise_pitch_macro_release: .byte 1
                                 
002928                           noise_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
002929                           noise_hi_pitch_macro: .byte 2
00292b                           noise_hi_pitch_macro_offset: .byte 1
00292c                           noise_hi_pitch_macro_loop: .byte 1
00292d                           noise_hi_pitch_macro_release: .byte 1
                                 
00292e                           noise_duty_macro: .byte 2
002930                           noise_duty_macro_offset: .byte 1
002931                           noise_duty_macro_loop: .byte 1
002932                           noise_duty_macro_release: .byte 1
                                 
002933                           noise_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002935                           noise_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002937                           noise_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
002939                           noise_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
00293b                           noise_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
00293d                           noise_fx_3xx_start: .byte 2 //the starting note period
00293f                           noise_fx_3xx_target: .byte 2 //target note period
002941                           noise_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
002943                           noise_fx_3xx_total_offset: .byte 2
002945                           noise_fx_4xy_speed: .byte 1
002946                           noise_fx_4xy_depth: .byte 1
002947                           noise_fx_4xy_phase: .byte 1
002948                           noise_fx_7xy_speed: .byte 1
002949                           noise_fx_7xy_depth: .byte 1
00294a                           noise_fx_7xy_phase: .byte 1
00294b                           noise_fx_7xy_value: .byte 1 //value to offset the volume
00294c                           noise_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
00294d                           noise_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
00294e                           noise_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
00294f                           noise_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
002951                           noise_fx_Qxy_target_note: .byte 1 //target note index
002952                           noise_fx_Qxy_target: .byte 2 //target note period
002954                           noise_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002956                           noise_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002958                           noise_fx_Rxy_target_note: .byte 1 //target note index
002959                           noise_fx_Rxy_target: .byte 2 //target note period
00295b                           noise_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
00295d                           noise_fx_Rxy_total_offset: .byte 2
00295f                           noise_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002960                           noise_fx_Sxx_post: .byte 1
                                 
                                 //DPCM
002961                           dcpm_pattern_delay: .byte 1
                                 
                                 .cseg
                                 
                                 //NOTE: zero is defined in order to use the cp instruction without the need to load 0x00 into a register beforehand
                                 .def zero = r2
                                 .def pulse_channel_flags = r25 //[pulse1.pulse2] RSlc.RSlc = Reload, Start, Length halt/Loop, Constant volume
                                 .def pulse1_sequence = r10
                                 .def pulse1_length_counter = r11
                                 .def pulse1_sweep = r12 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse1_volume_divider = r16 //0000.PPPP = Period divider
                                 .def pulse1_volume_decay = r17 //0000.dddd = Decay
                                 .def pulse2_sequence = r13
                                 .def pulse2_length_counter = r14
                                 .def pulse2_sweep = r15 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse2_volume_divider = r18 //0000.PPPP = Period divider
                                 .def pulse2_volume_decay = r19 //0000.dddd = Decay
                                 .def triangle_sequence = r20
                                 .def noise_sequence_LOW = r21
                                 .def noise_sequence_HIGH = r22
                                 
                                 reset:
000000 940c 0ec3                 	jmp init
                                 
                                 .org TCA0_OVF_vect
00000e 940c 137e                 	jmp sound_driver
                                 
                                 .org TCA0_CMP0_vect
000012 940c 1285                 	jmp sequence_0_2
                                 
                                 .org TCA0_CMP1_vect
000014 940c 1290                 	jmp sequence_1_3
                                 
                                 .org TCA0_CMP2_vect
000016 940c 1285                 	jmp sequence_0_2
                                 
                                 .org TCB0_INT_vect
000018 940c 12a7                 	jmp pulse1_sequence_routine
                                 
                                 .org TCB1_INT_vect
00001a 940c 12f4                 	jmp pulse2_sequence_routine
                                 
                                 .org TCB2_INT_vect
000032 940c 1341                 	jmp triangle_sequence_routine
                                 
                                 .org TCB3_INT_vect
000048 940c 134c                 	jmp noise_sequence_routine
                                 
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(33): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(48): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(74): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(77): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(79): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(80): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(81): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(84): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(85): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(88): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(89): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(93): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(95): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(96): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(97): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(101): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(102): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(104): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(106): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(108): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(109): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(110): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(113): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(116): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(119): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(124): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(125): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(127): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(128): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(131): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(138): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(216): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(218): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(219): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(220): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(221): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(223): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(225): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(226): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(227): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(231): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(233): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(234): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(235): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(237): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(240): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(246): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(247): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(249): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(250): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(251): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(258): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(259): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(269): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(270): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
                                 .list
                                 
                                 init:
                                 	//MAIN CLOCK
000ec3 edc8                      	ldi r28, CPU_CCP_IOREG_gc //protected write
000ec4 93c0 0034                 	sts CPU_CCP, r28
000ec6 e0c0                      	ldi r28, 0 << CLKCTRL_PEN_bp //disable prescaler for 20 MHz on main clock
000ec7 93c0 0061                 	sts CLKCTRL_MCLKCTRLB, r28
                                 
                                 	//ZERO
000ec9 2422                      	clr zero
                                 
                                 	//MEMORY
000eca e3c0                      	ldi r28, 0b00110000
000ecb 93c0 2800                 	sts pulse1_param, r28
000ecd e8c0                      	ldi r28, 0b10000000
000ece 93c0 2801                 	sts pulse1_sweep_param, r28
000ed0 efcf                      	ldi r28, 0xFF
000ed1 93c0 2802                 	sts pulse1_timerL, r28
000ed3 93c0 2803                 	sts pulse1_timerH, r28
000ed5 93c0 2804                 	sts pulse1_length, r28
                                 
000ed7 e3c0                      	ldi r28, 0b00110000
000ed8 93c0 2808                 	sts pulse2_param, r28
000eda e8c0                      	ldi r28, 0b10000000
000edb 93c0 2809                 	sts pulse2_sweep_param, r28
000edd efcf                      	ldi r28, 0xFF
000ede 93c0 280a                 	sts pulse2_timerL, r28
000ee0 93c0 280b                 	sts pulse2_timerH, r28
000ee2 93c0 280c                 	sts pulse2_length, r28
                                 
000ee4 efcf                      	ldi r28, 0xFF
000ee5 93c0 2810                 	sts triangle_timerL, r28
000ee7 93c0 2811                 	sts triangle_timerH, r28
                                 
000ee9 e3c0                      	ldi r28, 0b00110000
000eea 93c0 2813                 	sts noise_param, r28
000eec e0cf                      	ldi r28, 0b00001111
000eed 93c0 2814                 	sts noise_period, r28
                                 
000eef e0c2                      	ldi r28, 0x02
000ef0 93c0 281a                 	sts song_frame_offset, r28
000ef2 9220 281b                 	sts song_frame_offset+1, zero
000ef4 efcf                      	ldi r28, 0xFF
000ef5 93c0 281f                 	sts song_fx_Bxx, r28
000ef7 9220 2820                 	sts song_fx_Cxx, zero
000ef9 9220 2821                 	sts song_fx_Dxx, zero
000efb e4ee                      	ldi ZL, LOW(song0_frames << 1)
000efc e0f3                      	ldi ZH, HIGH(song0_frames << 1)
000efd 93e0 2818                 	sts song_frames, ZL
000eff 93f0 2819                 	sts song_frames+1, ZH
000f01 91c5                      	lpm r28, Z+ //load the song size
000f02 91d5                      	lpm r29, Z+
000f03 93c0 281c                 	sts song_size, r28
000f05 93d0 281d                 	sts song_size+1, r29
000f07 9220 281e                 	sts song_speed, zero
                                 
                                 	//CHANNEL 0
000f09 91c5                      	lpm r28, Z+
000f0a 91d5                      	lpm r29, Z+
000f0b 0fcc                      	lsl r28
000f0c 1fdd                      	rol r29
000f0d 93c0 2822                 	sts pulse1_pattern, r28
000f0f 93d0 2823                 	sts pulse1_pattern+1, r29
000f11 9220 2824                 	sts pulse1_pattern_delay_rows, zero
000f13 9220 2825                 	sts pulse1_pattern_delay_frames, zero
000f15 9220 2826                 	sts pulse1_pattern_offset, zero
000f17 9220 2827                 	sts pulse1_pattern_offset+1, zero
                                 
                                 	//CHANNEL 1
000f19 91c5                      	lpm r28, Z+
000f1a 91d5                      	lpm r29, Z+
000f1b 0fcc                      	lsl r28
000f1c 1fdd                      	rol r29
000f1d 93c0 2873                 	sts pulse2_pattern, r28
000f1f 93d0 2874                 	sts pulse2_pattern+1, r29
000f21 9220 2875                 	sts pulse2_pattern_delay_rows, zero
000f23 9220 2876                 	sts pulse2_pattern_delay_frames, zero
000f25 9220 2877                 	sts pulse2_pattern_offset, zero
000f27 9220 2878                 	sts pulse2_pattern_offset+1, zero
                                 
                                 	//CHANNEL 2
000f29 91c5                      	lpm r28, Z+
000f2a 91d5                      	lpm r29, Z+
000f2b 0fcc                      	lsl r28
000f2c 1fdd                      	rol r29
000f2d 93c0 28c4                 	sts triangle_pattern, r28
000f2f 93d0 28c5                 	sts triangle_pattern+1, r29
000f31 9220 28c6                 	sts triangle_pattern_delay_rows, zero
000f33 9220 28c7                 	sts triangle_pattern_delay_frames, zero
000f35 9220 28c8                 	sts triangle_pattern_offset, zero
000f37 9220 28c9                 	sts triangle_pattern_offset+1, zero
                                 
                                 	//CHANNEL 3
000f39 91c5                      	lpm r28, Z+
000f3a 91d5                      	lpm r29, Z+
000f3b 0fcc                      	lsl r28
000f3c 1fdd                      	rol r29
000f3d 93c0 2910                 	sts noise_pattern, r28
000f3f 93d0 2911                 	sts noise_pattern+1, r29
000f41 9220 2912                 	sts noise_pattern_delay_rows, zero
000f43 9220 2913                 	sts noise_pattern_delay_frames, zero
000f45 9220 2914                 	sts noise_pattern_offset, zero
000f47 9220 2915                 	sts noise_pattern_offset+1, zero
                                 
                                 	//CHANNEL 0 instrument macros
000f49 efcf                      	ldi r28, 0xFF
000f4a 9220 282a                 	sts pulse1_volume_macro_offset, zero
000f4c 93c0 282b                 	sts pulse1_volume_macro_loop, r28
000f4e 93c0 282c                 	sts pulse1_volume_macro_release, r28
000f50 9220 282f                 	sts pulse1_arpeggio_macro_offset, zero
000f52 93c0 2830                 	sts pulse1_arpeggio_macro_loop, r28
000f54 93c0 2831                 	sts pulse1_arpeggio_macro_release, r28
000f56 93c0 2832                 	sts pulse1_arpeggio_macro_mode, r28
000f58 9220 2837                 	sts pulse1_pitch_macro_offset, zero
000f5a 93c0 2838                 	sts pulse1_pitch_macro_loop, r28
000f5c 93c0 2839                 	sts pulse1_pitch_macro_release, r28
000f5e 9220 283d                 	sts pulse1_hi_pitch_macro_offset, zero
000f60 93c0 283e                 	sts pulse1_hi_pitch_macro_loop, r28
000f62 93c0 283f                 	sts pulse1_hi_pitch_macro_release, r28
000f64 9220 2842                 	sts pulse1_duty_macro_offset, zero
000f66 93c0 2843                 	sts pulse1_duty_macro_loop, r28
000f68 93c0 2844                 	sts pulse1_duty_macro_release, r28
                                 
000f6a 9220 2828                 	sts pulse1_volume_macro, zero
000f6c 9220 2829                 	sts pulse1_volume_macro+1, zero
000f6e 9220 282d                 	sts pulse1_arpeggio_macro, zero
000f70 9220 282e                 	sts pulse1_arpeggio_macro+1, zero
000f72 9220 2833                 	sts pulse1_total_pitch_offset, zero
000f74 9220 2834                 	sts pulse1_total_pitch_offset+1, zero
000f76 9220 2835                 	sts pulse1_pitch_macro, zero
000f78 9220 2836                 	sts pulse1_pitch_macro+1, zero
000f7a 9220 283a                 	sts pulse1_total_hi_pitch_offset, zero
000f7c 9220 283b                 	sts pulse1_hi_pitch_macro, zero
000f7e 9220 283c                 	sts pulse1_hi_pitch_macro+1, zero
000f80 9220 2840                 	sts pulse1_duty_macro, zero
000f82 9220 2841                 	sts pulse1_duty_macro+1, zero
                                 
                                 	//CHANNEL 0 ENVELOPE
000f84 e00f                      	ldi pulse1_volume_divider, 0x0F
000f85 9110 2800                 	lds pulse1_volume_decay, pulse1_param
000f87 701f                      	andi pulse1_volume_decay, 0x0F //mask for VVVV bits
000f88 9190 2800                 	lds pulse_channel_flags, pulse1_param
000f8a 7390                      	andi pulse_channel_flags, 0b00110000
000f8b 6490                      	sbr pulse_channel_flags, 0b01000000 //set start flag
000f8c 9220 2806                 	sts pulse1_output_volume, zero
000f8e 93c0 2805                 	sts pulse1_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 0 LENGTH
000f90 2ebc                      	mov pulse1_length_counter, r28
                                 
                                 	//CHANNEL 0 SEQUENCE
000f91 e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
000f92 2eac                      	mov pulse1_sequence, r28
                                 
                                 	//CHANNEL 0 SWEEP
000f93 90c0 2801                 	lds pulse1_sweep, pulse1_sweep_param
000f95 94c2                      	swap pulse1_sweep //swap data from high byte and low byte
000f96 6890                      	sbr pulse_channel_flags, 0b10000000 //set reload flag
                                 
                                 	//CHANNEL 0 FX
000f97 efcf                      	ldi r28, 0xFF
000f98 9220 2845                 	sts pulse1_fx_0xy_sequence, zero
000f9a 9220 2846                 	sts pulse1_fx_0xy_sequence+1, zero
000f9c 9220 2847                 	sts pulse1_fx_1xx, zero
000f9e 9220 2848                 	sts pulse1_fx_1xx+1, zero
000fa0 9220 2849                 	sts pulse1_fx_1xx_total, zero
000fa2 9220 284a                 	sts pulse1_fx_1xx_total+1, zero
000fa4 9220 284b                 	sts pulse1_fx_2xx, zero
000fa6 9220 284c                 	sts pulse1_fx_2xx+1, zero
000fa8 9220 284d                 	sts pulse1_fx_2xx_total, zero
000faa 9220 284e                 	sts pulse1_fx_2xx_total+1, zero
000fac 9220 284f                 	sts pulse1_fx_3xx_start, zero
000fae 9220 2850                 	sts pulse1_fx_3xx_start+1, zero
000fb0 9220 2851                 	sts pulse1_fx_3xx_target, zero
000fb2 9220 2852                 	sts pulse1_fx_3xx_target+1, zero
000fb4 9220 2853                 	sts pulse1_fx_3xx_speed, zero
000fb6 9220 2854                 	sts pulse1_fx_3xx_speed+1, zero
000fb8 9220 2855                 	sts pulse1_fx_3xx_total_offset, zero
000fba 9220 2856                 	sts pulse1_fx_3xx_total_offset+1, zero
000fbc 9220 2857                 	sts pulse1_fx_4xy_speed, zero
000fbe 9220 2858                 	sts pulse1_fx_4xy_depth, zero
000fc0 9220 2859                 	sts pulse1_fx_4xy_phase, zero
000fc2 9220 285a                 	sts pulse1_fx_7xy_speed, zero
000fc4 9220 285b                 	sts pulse1_fx_7xy_depth, zero
000fc6 9220 285c                 	sts pulse1_fx_7xy_phase, zero
000fc8 9220 285d                 	sts pulse1_fx_7xy_value, zero
000fca 9220 285e                 	sts pulse1_fx_Axy, zero
000fcc 93c0 285f                 	sts pulse1_fx_Gxx_pre, r28
000fce 93c0 2860                 	sts pulse1_fx_Gxx_post, r28
000fd0 9220 2861                 	sts pulse1_fx_Pxx_total, zero
000fd2 9220 2862                 	sts pulse1_fx_Pxx_total+1, zero
000fd4 9220 2863                 	sts pulse1_fx_Qxy_target_note, zero
000fd6 9220 2864                 	sts pulse1_fx_Qxy_target, zero
000fd8 9220 2865                 	sts pulse1_fx_Qxy_target+1, zero
000fda 9220 2866                 	sts pulse1_fx_Qxy_speed, zero
000fdc 9220 2867                 	sts pulse1_fx_Qxy_speed+1, zero
000fde 9220 2868                 	sts pulse1_fx_Qxy_total_offset, zero
000fe0 9220 2869                 	sts pulse1_fx_Qxy_total_offset+1, zero
000fe2 9220 286a                 	sts pulse1_fx_Rxy_target_note, zero
000fe4 9220 286b                 	sts pulse1_fx_Rxy_target, zero
000fe6 9220 286c                 	sts pulse1_fx_Rxy_target+1, zero
000fe8 9220 286d                 	sts pulse1_fx_Rxy_speed, zero
000fea 9220 286e                 	sts pulse1_fx_Rxy_speed+1, zero
000fec 9220 286f                 	sts pulse1_fx_Rxy_total_offset, zero
000fee 9220 2870                 	sts pulse1_fx_Rxy_total_offset+1, zero
000ff0 93c0 2871                 	sts pulse1_fx_Sxx_pre, r28
000ff2 93c0 2872                 	sts pulse1_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 1 instrument macros
000ff4 efcf                      	ldi r28, 0xFF
000ff5 9220 287b                 	sts pulse2_volume_macro_offset, zero
000ff7 93c0 287c                 	sts pulse2_volume_macro_loop, r28
000ff9 93c0 287d                 	sts pulse2_volume_macro_release, r28
000ffb 9220 2880                 	sts pulse2_arpeggio_macro_offset, zero
000ffd 93c0 2881                 	sts pulse2_arpeggio_macro_loop, r28
000fff 93c0 2882                 	sts pulse2_arpeggio_macro_release, r28
001001 93c0 2883                 	sts pulse2_arpeggio_macro_mode, r28
001003 9220 2888                 	sts pulse2_pitch_macro_offset, zero
001005 93c0 2889                 	sts pulse2_pitch_macro_loop, r28
001007 93c0 288a                 	sts pulse2_pitch_macro_release, r28
001009 9220 288e                 	sts pulse2_hi_pitch_macro_offset, zero
00100b 93c0 288f                 	sts pulse2_hi_pitch_macro_loop, r28
00100d 93c0 2890                 	sts pulse2_hi_pitch_macro_release, r28
00100f 9220 2893                 	sts pulse2_duty_macro_offset, zero
001011 93c0 2894                 	sts pulse2_duty_macro_loop, r28
001013 93c0 2895                 	sts pulse2_duty_macro_release, r28
                                 
001015 9220 2879                 	sts pulse2_volume_macro, zero
001017 9220 287a                 	sts pulse2_volume_macro+1, zero
001019 9220 287e                 	sts pulse2_arpeggio_macro, zero
00101b 9220 287f                 	sts pulse2_arpeggio_macro+1, zero
00101d 9220 2884                 	sts pulse2_total_pitch_offset, zero
00101f 9220 2885                 	sts pulse2_total_pitch_offset+1, zero
001021 9220 2886                 	sts pulse2_pitch_macro, zero
001023 9220 2887                 	sts pulse2_pitch_macro+1, zero
001025 9220 288b                 	sts pulse2_total_hi_pitch_offset, zero
001027 9220 288c                 	sts pulse2_hi_pitch_macro, zero
001029 9220 288d                 	sts pulse2_hi_pitch_macro+1, zero
00102b 9220 2891                 	sts pulse2_duty_macro, zero
00102d 9220 2892                 	sts pulse2_duty_macro+1, zero
                                 
                                 	//CHANNEL 1 ENVELOPE
00102f e02f                      	ldi pulse2_volume_divider, 0x0F
001030 9130 2808                 	lds pulse2_volume_decay, pulse2_param
001032 703f                      	andi pulse2_volume_decay, 0x0F //mask for VVVV bits
001033 91d0 2808                 	lds r29, pulse2_param
001035 73d0                      	andi r29, 0b00110000
001036 62d0                      	sbr r29, 0b0100000 //set start flag
001037 95d2                      	swap r29
001038 2b9d                      	or pulse_channel_flags, r29
001039 9220 280e                 	sts pulse2_output_volume, zero
00103b 93c0 280d                 	sts pulse2_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 1 LENGTH
00103d 2eec                      	mov pulse2_length_counter, r28
                                 
                                 	//CHANNEL 1 SEQUENCE
00103e e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
00103f 2edc                      	mov pulse2_sequence, r28
                                 
                                 	//CHANNEL 1 SWEEP
001040 90f0 2809                 	lds pulse2_sweep, pulse2_sweep_param
001042 94f2                      	swap pulse2_sweep //swap data from high byte and low byte
001043 6098                      	sbr pulse_channel_flags, 0b00001000 //set reload flag
                                 
                                 	//CHANNEL 1 FX
001044 efcf                      	ldi r28, 0xFF
001045 9220 2896                 	sts pulse2_fx_0xy_sequence, zero
001047 9220 2897                 	sts pulse2_fx_0xy_sequence+1, zero
001049 9220 2898                 	sts pulse2_fx_1xx, zero
00104b 9220 2899                 	sts pulse2_fx_1xx+1, zero
00104d 9220 289a                 	sts pulse2_fx_1xx_total, zero
00104f 9220 289b                 	sts pulse2_fx_1xx_total+1, zero
001051 9220 289c                 	sts pulse2_fx_2xx, zero
001053 9220 289d                 	sts pulse2_fx_2xx+1, zero
001055 9220 289e                 	sts pulse2_fx_2xx_total, zero
001057 9220 289f                 	sts pulse2_fx_2xx_total+1, zero
001059 9220 28a0                 	sts pulse2_fx_3xx_start, zero
00105b 9220 28a1                 	sts pulse2_fx_3xx_start+1, zero
00105d 9220 28a2                 	sts pulse2_fx_3xx_target, zero
00105f 9220 28a3                 	sts pulse2_fx_3xx_target+1, zero
001061 9220 28a4                 	sts pulse2_fx_3xx_speed, zero
001063 9220 28a5                 	sts pulse2_fx_3xx_speed+1, zero
001065 9220 28a6                 	sts pulse2_fx_3xx_total_offset, zero
001067 9220 28a7                 	sts pulse2_fx_3xx_total_offset+1, zero
001069 9220 28a8                 	sts pulse2_fx_4xy_speed, zero
00106b 9220 28a9                 	sts pulse2_fx_4xy_depth, zero
00106d 9220 28aa                 	sts pulse2_fx_4xy_phase, zero
00106f 9220 28ab                 	sts pulse2_fx_7xy_speed, zero
001071 9220 28ac                 	sts pulse2_fx_7xy_depth, zero
001073 9220 28ad                 	sts pulse2_fx_7xy_phase, zero
001075 9220 28ae                 	sts pulse2_fx_7xy_value, zero
001077 9220 28af                 	sts pulse2_fx_Axy, zero
001079 93c0 28b0                 	sts pulse2_fx_Gxx_pre, r28
00107b 93c0 28b1                 	sts pulse2_fx_Gxx_post, r28
00107d 9220 28b2                 	sts pulse2_fx_Pxx_total, zero
00107f 9220 28b3                 	sts pulse2_fx_Pxx_total+1, zero
001081 9220 28b4                 	sts pulse2_fx_Qxy_target_note, zero
001083 9220 28b5                 	sts pulse2_fx_Qxy_target, zero
001085 9220 28b6                 	sts pulse2_fx_Qxy_target+1, zero
001087 9220 28b7                 	sts pulse2_fx_Qxy_speed, zero
001089 9220 28b8                 	sts pulse2_fx_Qxy_speed+1, zero
00108b 9220 28b9                 	sts pulse2_fx_Qxy_total_offset, zero
00108d 9220 28ba                 	sts pulse2_fx_Qxy_total_offset+1, zero
00108f 9220 28bb                 	sts pulse2_fx_Rxy_target_note, zero
001091 9220 28bc                 	sts pulse2_fx_Rxy_target, zero
001093 9220 28bd                 	sts pulse2_fx_Rxy_target+1, zero
001095 9220 28be                 	sts pulse2_fx_Rxy_speed, zero
001097 9220 28bf                 	sts pulse2_fx_Rxy_speed+1, zero
001099 9220 28c0                 	sts pulse2_fx_Rxy_total_offset, zero
00109b 9220 28c1                 	sts pulse2_fx_Rxy_total_offset+1, zero
00109d 93c0 28c2                 	sts pulse2_fx_Sxx_pre, r28
00109f 93c0 28c3                 	sts pulse2_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 2 instrument macros
0010a1 efcf                      	ldi r28, 0xFF
0010a2 9220 28cc                 	sts triangle_volume_macro_offset, zero
0010a4 93c0 28cd                 	sts triangle_volume_macro_loop, r28
0010a6 93c0 28ce                 	sts triangle_volume_macro_release, r28
0010a8 9220 28d1                 	sts triangle_arpeggio_macro_offset, zero
0010aa 93c0 28d2                 	sts triangle_arpeggio_macro_loop, r28
0010ac 93c0 28d3                 	sts triangle_arpeggio_macro_release, r28
0010ae 93c0 28d4                 	sts triangle_arpeggio_macro_mode, r28
0010b0 9220 28d9                 	sts triangle_pitch_macro_offset, zero
0010b2 93c0 28da                 	sts triangle_pitch_macro_loop, r28
0010b4 93c0 28db                 	sts triangle_pitch_macro_release, r28
0010b6 9220 28df                 	sts triangle_hi_pitch_macro_offset, zero
0010b8 93c0 28e0                 	sts triangle_hi_pitch_macro_loop, r28
0010ba 93c0 28e1                 	sts triangle_hi_pitch_macro_release, r28
0010bc 9220 28e4                 	sts triangle_duty_macro_offset, zero
0010be 93c0 28e5                 	sts triangle_duty_macro_loop, r28
0010c0 93c0 28e6                 	sts triangle_duty_macro_release, r28
                                 
0010c2 9220 28ca                 	sts triangle_volume_macro, zero
0010c4 9220 28cb                 	sts triangle_volume_macro+1, zero
0010c6 9220 28cf                 	sts triangle_arpeggio_macro, zero
0010c8 9220 28d0                 	sts triangle_arpeggio_macro+1, zero
0010ca 9220 28d5                 	sts triangle_total_pitch_offset, zero
0010cc 9220 28d6                 	sts triangle_total_pitch_offset+1, zero
0010ce 9220 28d7                 	sts triangle_pitch_macro, zero
0010d0 9220 28d8                 	sts triangle_pitch_macro+1, zero
0010d2 9220 28dc                 	sts triangle_total_hi_pitch_offset, zero
0010d4 9220 28dd                 	sts triangle_hi_pitch_macro, zero
0010d6 9220 28de                 	sts triangle_hi_pitch_macro+1, zero
0010d8 9220 28e2                 	sts triangle_duty_macro, zero
0010da 9220 28e3                 	sts triangle_duty_macro+1, zero
                                 
                                 	//CHANNEL 2 SEQUENCE
0010dc e0c0                      	ldi r28, 0b00000000 //reset sequence to 0
0010dd 2f4c                      	mov triangle_sequence, r28
                                 
                                 	//CHANNEL 2 FX
0010de efcf                      	ldi r28, 0xFF
0010df 9220 28e7                 	sts triangle_fx_0xy_sequence, zero
0010e1 9220 28e8                 	sts triangle_fx_0xy_sequence+1, zero
0010e3 9220 28e9                 	sts triangle_fx_1xx, zero
0010e5 9220 28ea                 	sts triangle_fx_1xx+1, zero
0010e7 9220 28eb                 	sts triangle_fx_1xx_total, zero
0010e9 9220 28ec                 	sts triangle_fx_1xx_total+1, zero
0010eb 9220 28ed                 	sts triangle_fx_2xx, zero
0010ed 9220 28ee                 	sts triangle_fx_2xx+1, zero
0010ef 9220 28ef                 	sts triangle_fx_2xx_total, zero
0010f1 9220 28f0                 	sts triangle_fx_2xx_total+1, zero
0010f3 9220 28f1                 	sts triangle_fx_3xx_start, zero
0010f5 9220 28f2                 	sts triangle_fx_3xx_start+1, zero
0010f7 9220 28f3                 	sts triangle_fx_3xx_target, zero
0010f9 9220 28f4                 	sts triangle_fx_3xx_target+1, zero
0010fb 9220 28f5                 	sts triangle_fx_3xx_speed, zero
0010fd 9220 28f6                 	sts triangle_fx_3xx_speed+1, zero
0010ff 9220 28f7                 	sts triangle_fx_3xx_total_offset, zero
001101 9220 28f8                 	sts triangle_fx_3xx_total_offset+1, zero
001103 9220 28f9                 	sts triangle_fx_4xy_speed, zero
001105 9220 28fa                 	sts triangle_fx_4xy_depth, zero
001107 9220 28fb                 	sts triangle_fx_4xy_phase, zero
001109 93c0 28fc                 	sts triangle_fx_Gxx_pre, r28
00110b 93c0 28fd                 	sts triangle_fx_Gxx_post, r28
00110d 9220 28fe                 	sts triangle_fx_Pxx_total, zero
00110f 9220 28ff                 	sts triangle_fx_Pxx_total+1, zero
001111 9220 2900                 	sts triangle_fx_Qxy_target_note, zero
001113 9220 2901                 	sts triangle_fx_Qxy_target, zero
001115 9220 2902                 	sts triangle_fx_Qxy_target+1, zero
001117 9220 2903                 	sts triangle_fx_Qxy_speed, zero
001119 9220 2904                 	sts triangle_fx_Qxy_speed+1, zero
00111b 9220 2905                 	sts triangle_fx_Qxy_total_offset, zero
00111d 9220 2906                 	sts triangle_fx_Qxy_total_offset+1, zero
00111f 9220 2907                 	sts triangle_fx_Rxy_target_note, zero
001121 9220 2908                 	sts triangle_fx_Rxy_target, zero
001123 9220 2909                 	sts triangle_fx_Rxy_target+1, zero
001125 9220 290a                 	sts triangle_fx_Rxy_speed, zero
001127 9220 290b                 	sts triangle_fx_Rxy_speed+1, zero
001129 9220 290c                 	sts triangle_fx_Rxy_total_offset, zero
00112b 9220 290d                 	sts triangle_fx_Rxy_total_offset+1, zero
00112d 93c0 290e                 	sts triangle_fx_Sxx_pre, r28
00112f 93c0 290f                 	sts triangle_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 3 instrument macros
001131 efcf                      	ldi r28, 0xFF
001132 9220 2918                 	sts noise_volume_macro_offset, zero
001134 93c0 2919                 	sts noise_volume_macro_loop, r28
001136 93c0 291a                 	sts noise_volume_macro_release, r28
001138 9220 291d                 	sts noise_arpeggio_macro_offset, zero
00113a 93c0 291e                 	sts noise_arpeggio_macro_loop, r28
00113c 93c0 291f                 	sts noise_arpeggio_macro_release, r28
00113e 93c0 2920                 	sts noise_arpeggio_macro_mode, r28
001140 9220 2925                 	sts noise_pitch_macro_offset, zero
001142 93c0 2926                 	sts noise_pitch_macro_loop, r28
001144 93c0 2927                 	sts noise_pitch_macro_release, r28
001146 9220 292b                 	sts noise_hi_pitch_macro_offset, zero
001148 93c0 292c                 	sts noise_hi_pitch_macro_loop, r28
00114a 93c0 292d                 	sts noise_hi_pitch_macro_release, r28
00114c 9220 2930                 	sts noise_duty_macro_offset, zero
00114e 93c0 2931                 	sts noise_duty_macro_loop, r28
001150 93c0 2932                 	sts noise_duty_macro_release, r28
                                 
001152 9220 2916                 	sts noise_volume_macro, zero
001154 9220 2917                 	sts noise_volume_macro+1, zero
001156 9220 291b                 	sts noise_arpeggio_macro, zero
001158 9220 291c                 	sts noise_arpeggio_macro+1, zero
00115a 9220 2921                 	sts noise_total_pitch_offset, zero
00115c 9220 2922                 	sts noise_total_pitch_offset+1, zero
00115e 9220 2923                 	sts noise_pitch_macro, zero
001160 9220 2924                 	sts noise_pitch_macro+1, zero
001162 9220 2928                 	sts noise_total_hi_pitch_offset, zero
001164 9220 2929                 	sts noise_hi_pitch_macro, zero
001166 9220 292a                 	sts noise_hi_pitch_macro+1, zero
001168 9220 292e                 	sts noise_duty_macro, zero
00116a 9220 292f                 	sts noise_duty_macro+1, zero
                                 
                                 	//CHANNEL 3 VOLUME
00116c 9220 2816                 	sts noise_output_volume, zero
00116e 93c0 2815                 	sts noise_fractional_volume, r28 //initialize fractional volume to max value
                                 
                                 	//CHANNEL 3 SEQUENCE
001170 e0c1                      	ldi r28, 0b00000001 //noise sequence is reset to 0x0001
001171 2f5c                      	mov noise_sequence_LOW, r28
001172 2d62                      	mov noise_sequence_HIGH, zero
                                 
                                 	//CHANNEL 3 FX
001173 efcf                      	ldi r28, 0xFF
001174 9220 2933                 	sts noise_fx_0xy_sequence, zero
001176 9220 2934                 	sts noise_fx_0xy_sequence+1, zero
001178 9220 2935                 	sts noise_fx_1xx, zero
00117a 9220 2936                 	sts noise_fx_1xx+1, zero
00117c 9220 2937                 	sts noise_fx_1xx_total, zero
00117e 9220 2938                 	sts noise_fx_1xx_total+1, zero
001180 9220 2939                 	sts noise_fx_2xx, zero
001182 9220 293a                 	sts noise_fx_2xx+1, zero
001184 9220 293b                 	sts noise_fx_2xx_total, zero
001186 9220 293c                 	sts noise_fx_2xx_total+1, zero
001188 9220 293d                 	sts noise_fx_3xx_start, zero
00118a 9220 293e                 	sts noise_fx_3xx_start+1, zero
00118c 9220 293f                 	sts noise_fx_3xx_target, zero
00118e 9220 2940                 	sts noise_fx_3xx_target+1, zero
001190 9220 2941                 	sts noise_fx_3xx_speed, zero
001192 9220 2942                 	sts noise_fx_3xx_speed+1, zero
001194 9220 2943                 	sts noise_fx_3xx_total_offset, zero
001196 9220 2944                 	sts noise_fx_3xx_total_offset+1, zero
001198 9220 2945                 	sts noise_fx_4xy_speed, zero
00119a 9220 2946                 	sts noise_fx_4xy_depth, zero
00119c 9220 2947                 	sts noise_fx_4xy_phase, zero
00119e 9220 2948                 	sts noise_fx_7xy_speed, zero
0011a0 9220 2949                 	sts noise_fx_7xy_depth, zero
0011a2 9220 294a                 	sts noise_fx_7xy_phase, zero
0011a4 9220 294b                 	sts noise_fx_7xy_value, zero
0011a6 9220 294c                 	sts noise_fx_Axy, zero
0011a8 93c0 294d                 	sts noise_fx_Gxx_pre, r28
0011aa 93c0 294e                 	sts noise_fx_Gxx_post, r28
0011ac 9220 294f                 	sts noise_fx_Pxx_total, zero
0011ae 9220 2950                 	sts noise_fx_Pxx_total+1, zero
0011b0 9220 2951                 	sts noise_fx_Qxy_target_note, zero
0011b2 9220 2952                 	sts noise_fx_Qxy_target, zero
0011b4 9220 2953                 	sts noise_fx_Qxy_target+1, zero
0011b6 9220 2954                 	sts noise_fx_Qxy_speed, zero
0011b8 9220 2955                 	sts noise_fx_Qxy_speed+1, zero
0011ba 9220 2956                 	sts noise_fx_Qxy_total_offset, zero
0011bc 9220 2957                 	sts noise_fx_Qxy_total_offset+1, zero
0011be 9220 2958                 	sts noise_fx_Rxy_target_note, zero
0011c0 9220 2959                 	sts noise_fx_Rxy_target, zero
0011c2 9220 295a                 	sts noise_fx_Rxy_target+1, zero
0011c4 9220 295b                 	sts noise_fx_Rxy_speed, zero
0011c6 9220 295c                 	sts noise_fx_Rxy_speed+1, zero
0011c8 9220 295d                 	sts noise_fx_Rxy_total_offset, zero
0011ca 9220 295e                 	sts noise_fx_Rxy_total_offset+1, zero
0011cc 93c0 295f                 	sts noise_fx_Sxx_pre, r28
0011ce 93c0 2960                 	sts noise_fx_Sxx_post, r28
                                 
                                 	//PINS
0011d0 efcf                      	ldi r28, 0xFF
0011d1 b9c0                      	out VPORTA_DIR, r28 //set all pins in VPORTA to output
                                 
                                 	//TIMERS
                                 	//Frame Counter
                                 	//NOTE:The frame counter will be defaulted to NTSC mode (60 Hz, 120 Hz, 240 Hz)
                                 	//Each interrupt will be setup to interrupt every 240 Hz clock
                                 	//CMP0 = sequence 0, CMP1 = sequence 1, CMP2 = sequence 2, OVF = sequence 3/sound driver
                                 	//Sequence 3 will clock the sound driver every 60Hz, in which new audio data is read and written to the registers
                                 	//Timer period Calculation: (0.00416666666 * 20000000/64)-1 = 1301.08333125 = 0x0515
                                 	//The ATmega4809 is cofigured to run at 20000000 Hz
                                 	//0.00416666666 seconds is the period for 240 Hz
                                 	//The /64 comes from the prescaler divider used
0011d2 e7c0                      	ldi r28, TCA_SINGLE_CMP0EN_bm | TCA_SINGLE_CMP1EN_bm | TCA_SINGLE_CMP2EN_bm | TCA_SINGLE_WGMODE_NORMAL_gc //interrupt mode
0011d3 93c0 0a01                 	sts TCA0_SINGLE_CTRLB, r28
0011d5 e7c1                      	ldi r28, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP1_bm | TCA_SINGLE_CMP2_bm | TCA_SINGLE_OVF_bm //enable overflow and compare interrupts
0011d6 93c0 0a0a                 	sts TCA0_SINGLE_INTCTRL, r28
0011d8 e1c5                      	ldi r28, 0x15 //set the period for CMP0
0011d9 93c0 0a28                 	sts TCA0_SINGLE_CMP0, r28
0011db e0c5                      	ldi r28, 0x05
0011dc 93c0 0a29                 	sts TCA0_SINGLE_CMP0 + 1, r28
0011de e2cb                      	ldi r28, 0x2B //set the period for CMP1
0011df 93c0 0a2a                 	sts TCA0_SINGLE_CMP1, r28
0011e1 e0ca                      	ldi r28, 0x0A
0011e2 93c0 0a2b                 	sts TCA0_SINGLE_CMP1 + 1, r28
0011e4 e4c1                      	ldi r28, 0x41 //set the period for CMP2
0011e5 93c0 0a2c                 	sts TCA0_SINGLE_CMP2, r28
0011e7 e0cf                      	ldi r28, 0x0F
0011e8 93c0 0a2d                 	sts TCA0_SINGLE_CMP2 + 1, r28
0011ea e5c7                      	ldi r28, 0x57 //set the period for OVF
0011eb 93c0 0a26                 	sts TCA0_SINGLE_PER, r28
0011ed e1c4                      	ldi r28, 0x14
0011ee 93c0 0a27                 	sts TCA0_SINGLE_PER + 1, r28
0011f0 e0cb                      	ldi r28, TCA_SINGLE_CLKSEL_DIV64_gc | TCA_SINGLE_ENABLE_bm //use prescale divider of 64 and enable timer
0011f1 93c0 0a00                 	sts TCA0_SINGLE_CTRLA, r28
                                 
                                 	//NOTE: Channel Timers are clocked (20/2)/(0.8948865) = 11.1746014718 times faster than the NES APU
                                 	//Because of this, we multiply all the NES timer values by 11.1746014718 beforehand
                                 	//Since we rotate the sequence when the timer goes from t-(t-1) to 0, instead of 0 to t like the NES, we add 1 to the NES timers before multiplying
                                 	//The ATmega4809 is configured to run at 20 MHz
                                 	//The /2 comes from the prescaler divider used
                                 	//0.8948865 MHz is the speed of the NTSC NES APU
                                 	//NOTE: This means that any offset to the pitch for the NES timers would be multiplied by 11.1746014718 aswell.
                                 	//Pulse 1
0011f3 e0c0                      	ldi r28, TCB_CNTMODE_INT_gc //interrupt mode
0011f4 93c0 0a81                 	sts TCB0_CTRLB, r28
0011f6 e0c1                      	ldi r28, TCB_CAPT_bm //enable interrupts
0011f7 93c0 0a85                 	sts TCB0_INTCTRL, r28
0011f9 91c0 2802                 	lds r28, pulse1_timerL //load the LOW bits for timer
0011fb 93c0 0a8c                 	sts TCB0_CCMPL, r28
0011fd 91c0 2803                 	lds r28, pulse1_timerH //load the HIGH bits for timer
0011ff 93c0 0a8d                 	sts TCB0_CCMPH, r28
001201 e0c3                      	ldi r28, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
001202 93c0 0a80                 	sts TCB0_CTRLA, r28
                                 
                                 	//PULSE 2
001204 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
001205 93b0 0a91                 	sts TCB1_CTRLB, r27
001207 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001208 93b0 0a95                 	sts TCB1_INTCTRL, r27
00120a 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
00120c 93b0 0a9c                 	sts TCB1_CCMPL, r27
00120e 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
001210 93b0 0a9d                 	sts TCB1_CCMPH, r27
001212 e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
001213 93b0 0a90                 	sts TCB1_CTRLA, r27
                                 
                                 	//NOTE: The triangle timer is clocked at the same speed as the NES CPU, aka twice the NES APU.
                                 	//Therefore, we won't be using a /2 clock divider like we did with the pulse timers.
                                 	//TRIANGLE
001215 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
001216 93b0 0aa1                 	sts TCB2_CTRLB, r27
001218 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
                                 	//sts TCB2_INTCTRL, r27 //keep interrupts disabled to mute channel since triangle doesn't have volume bits
001219 91b0 2810                 	lds r27, triangle_timerL //load the LOW bits for timer
00121b 93b0 0aac                 	sts TCB2_CCMPL, r27
00121d 91b0 2811                 	lds r27, triangle_timerH //load the HIGH bits for timer
00121f 93b0 0aad                 	sts TCB2_CCMPH, r27
001221 e0b1                      	ldi r27, TCB_CLKSEL_CLKDIV1_gc | TCB_ENABLE_bm //use prescaler divider of 1 and enable timer
001222 93b0 0aa0                 	sts TCB2_CTRLA, r27
001224 9478                      	sei //global interrupt enable
                                 
                                 	//NOISE
001225 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
001226 93b0 0ab1                 	sts TCB3_CTRLB, r27
001228 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001229 93b0 0ab5                 	sts TCB3_INTCTRL, r27
00122b 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
00122d 93b0 0abc                 	sts TCB3_CCMPL, r27
00122f 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
001231 93b0 0abd                 	sts TCB3_CCMPH, r27
001233 e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
001234 93b0 0ab0                 	sts TCB3_CTRLA, r27
                                 
                                 
                                 
                                 //https://wiki.nesdev.com/w/index.php/APU_Mixer
                                 volume_mixer:
001236 91c0 2806                 	lds r28, pulse1_output_volume
001238 91d0 280e                 	lds r29, pulse2_output_volume
                                 
                                 volume_mixer_pulse1:
00123a fea0                      	sbrs pulse1_sequence, 0 //if the sequence output is zero, return
00123b c015                      	rjmp volume_mixer_pulse1_off
                                 
00123c 14b2                      	cp pulse1_length_counter, zero //if length is zero, return
00123d f099                      	breq volume_mixer_pulse1_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
00123e 91e0 0a8c                 	lds r30, TCB0_CCMPL
001240 e5f9                      	ldi r31, 0x059
001241 17ef                      	cp r30, r31
001242 91e0 0a8d                 	lds r30, TCB0_CCMPH
001244 e0f0                      	ldi r31, 0x00
001245 07ef                      	cpc r30, r31
001246 f050                      	brlo volume_mixer_pulse1_off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $5965
001247 91e0 0a8c                 	lds r30, TCB0_CCMPL
001249 e6f6                      	ldi r31, 0x66
00124a 17ef                      	cp r30, r31
00124b 91e0 0a8d                 	lds r30, TCB0_CCMPH
00124d e5f9                      	ldi r31, 0x59
00124e 07ef                      	cpc r30, r31
00124f f408                      	brsh volume_mixer_pulse1_off
001250 c001                      	rjmp volume_mixer_pulse2 //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse1_off:
001251 27cc                      	clr r28
                                 
                                 volume_mixer_pulse2:
001252 fed0                      	sbrs pulse2_sequence, 0 //if the sequence output is zero, return
001253 c015                      	rjmp volume_mixer_pulse2_off
                                 
001254 14e2                      	cp pulse2_length_counter, zero //if length is zero, return
001255 f099                      	breq volume_mixer_pulse2_off
                                 
001256 91e0 0a9c                 	lds r30, TCB1_CCMPL
001258 e5f9                      	ldi r31, 0x059
001259 17ef                      	cp r30, r31
00125a 91e0 0a9d                 	lds r30, TCB1_CCMPH
00125c e0f0                      	ldi r31, 0x00
00125d 07ef                      	cpc r30, r31
00125e f050                      	brlo volume_mixer_pulse2_off
                                 
00125f 91e0 0a9c                 	lds r30, TCB1_CCMPL
001261 e6f6                      	ldi r31, 0x66
001262 17ef                      	cp r30, r31
001263 91e0 0a9d                 	lds r30, TCB1_CCMPH
001265 e5f9                      	ldi r31, 0x59
001266 07ef                      	cpc r30, r31
001267 f408                      	brsh volume_mixer_pulse2_off
001268 c001                      	rjmp volume_mixer_pulse_out //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse2_off:
001269 27dd                      	clr r29
                                 
                                 volume_mixer_pulse_out:
00126a 0fcd                      	add r28, r29
00126b e6e2                      	ldi ZL, LOW(pulse_volume_table << 1)
00126c e0f2                      	ldi ZH, HIGH(pulse_volume_table << 1)
00126d 0fec                      	add ZL, r28
00126e 1df2                      	adc ZH, zero
00126f 91c4                      	lpm r28, Z
                                 
                                 volume_mixer_tnd_triangle:
001270 2fd4                      	mov r29, triangle_sequence
001271 fdd4                      	sbrc r29, 4 //check 5th bit
001272 95d0                      	com r29
001273 70df                      	andi r29, 0x0F
001274 2fed                      	mov r30, r29
001275 0fde                      	add r29, r30 //multiply the triangle volume by 3
001276 0fde                      	add r29, r30
                                 
                                 volume_mixer_tnd_noise:
001277 ff50                      	sbrs noise_sequence_LOW, 0 //check 0th bit, skip if set
001278 c004                      	rjmp volume_mixer_tnd_out
001279 91e0 2816                 	lds r30, noise_output_volume
00127b 0fee                      	lsl r30 //multiply noise volume by 2
00127c 0fde                      	add r29, r30
                                 
                                 volume_mixer_tnd_out:
00127d e8e2                      	ldi ZL, LOW(tnd_volume_table << 1)
00127e e0f2                      	ldi ZH, HIGH(tnd_volume_table << 1)
00127f 0fed                      	add ZL, r29
001280 1df2                      	adc ZH, zero
001281 91d4                      	lpm r29, Z
                                 
                                 volume_mixer_output:
001282 0fcd                      	add r28, r29
001283 b9c1                      	out VPORTA_OUT, r28
001284 cfb1                      	rjmp volume_mixer
                                 
                                 
                                 
                                 //FRAME COUNTER/AUDIO SAMPLE ISR
                                 sequence_0_2:
001285 b7bf                      	in r27, CPU_SREG
001286 93bf                      	push r27
001287 94f8                      	cli
                                 
                                 	//ENVELOPE
001288 d053                      	rcall pulse1_envelope_routine
001289 d09f                      	rcall pulse2_envelope_routine
                                 
00128a e5b0                      	ldi r27, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP2_bm //clear OVF flag
00128b 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
00128d 91bf                      	pop r27
00128e bfbf                      	out CPU_SREG, r27
00128f 9518                      	reti
                                 
                                 sequence_1_3:
001290 b7bf                      	in r27, CPU_SREG
001291 93bf                      	push r27
001292 94f8                      	cli
                                 
                                 	//ENVELOPE
001293 d048                      	rcall pulse1_envelope_routine
001294 d094                      	rcall pulse2_envelope_routine
                                 
                                 	//SWEEP
001295 fcc3                      	sbrc pulse1_sweep, 3 //check if the sweep enable bit is cleared
001296 d01b                      	rcall pulse1_sweep_routine
001297 fcf3                      	sbrc pulse2_sweep, 3
001298 d066                      	rcall pulse2_sweep_routine
                                 
                                 	//LENGTH
                                 	//NOTE: The length routine is relatively simple, so we will not be using clocks to rjmp and ret to a seperate lable
                                 sequence_1_3_pulse1_length:
001299 fd95                      	sbrc pulse_channel_flags, 5 //check if the length counter halt bit is cleared
00129a c002                      	rjmp sequence_1_3_pulse2_length
00129b 10b2                      	cpse pulse1_length_counter, zero //if length counter is already 0, don't decrement
00129c 94ba                      	dec pulse1_length_counter
                                 sequence_1_3_pulse2_length:
00129d fd91                      	sbrc pulse_channel_flags, 1 //check if the length counter halt bit is cleared
00129e c002                      	rjmp sequence_1_3_exit
00129f 10e2                      	cpse pulse2_length_counter, zero //if length counter is already 0, don't decrement
0012a0 94ea                      	dec pulse2_length_counter
                                 
                                 sequence_1_3_exit:
0012a1 e2b1                      	ldi r27, TCA_SINGLE_CMP1_bm | TCA_SINGLE_OVF_bm //clear OVF flag
0012a2 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
0012a4 91bf                      	pop r27
0012a5 bfbf                      	out CPU_SREG, r27
0012a6 9518                      	reti
                                 
                                 //PULSE 1 ROUTINES
                                 pulse1_sequence_routine:
0012a7 b7bf                      	in r27, CPU_SREG
0012a8 93bf                      	push r27
0012a9 94f8                      	cli
                                 
0012aa 0caa                      	lsl pulse1_sequence //shifts sequence to the left
0012ab 1ca2                      	adc pulse1_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
0012ac e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
0012ad 93b0 0a86                 	sts TCB0_INTFLAGS, r27
0012af 91bf                      	pop r27
0012b0 bfbf                      	out CPU_SREG, r27
0012b1 9518                      	reti
                                 
                                 pulse1_sweep_routine:
0012b2 2dbc                      	mov r27, pulse1_sweep
0012b3 70b7                      	andi r27, 0x07 //mask for period divider bits
0012b4 f4f9                      	brne pulse1_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse1_sweep_routine_action: //if the divider is == 0, update the pulse timer period
0012b5 93df                      	push r29
0012b6 2ddc                      	mov r29, pulse1_sweep
0012b7 95d2                      	swap r29
0012b8 70d7                      	andi r29, 0x07 //mask for shift bits
0012b9 f411                      	brne pulse1_sweep_routine_action_main //shift != 0
0012ba 91df                      	pop r29
0012bb c019                      	rjmp pulse1_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse1_sweep_routine_action_main:
0012bc 91a0 0a8c                 	lds r26, TCB0_CCMPL
0012be 91b0 0a8d                 	lds r27, TCB0_CCMPH
                                 pulse1_sweep_routine_action_main_loop:
0012c0 95b6                      	lsr r27
0012c1 95a7                      	ror r26
0012c2 95da                      	dec r29
0012c3 f7e1                      	brne pulse1_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
0012c4 fec7                      	sbrs pulse1_sweep, 7 //check the negate flag
0012c5 c002                      	rjmp pulse1_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
0012c6 95a0                      	com r26 //pulse1 uses one's complement if the negate flag is set
0012c7 95b0                      	com r27
                                 
                                 pulse1_sweep_routine_action_main_add:
0012c8 91d0 0a8c                 	lds r29, TCB0_CCMPL //perform addition to get new timer period
0012ca 0fad                      	add r26, r29
0012cb 91d0 0a8d                 	lds r29, TCB0_CCMPH
0012cd 1fbd                      	adc r27, r29
                                 
0012ce 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new LOW bits for timer
0012d0 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new HIGH bits for timer
                                 	
0012d2 91df                      	pop r29
0012d3 c001                      	rjmp pulse1_sweep_routine_check_reload
                                 
                                 pulse1_sweep_routine_decrement_divider:
0012d4 94ca                      	dec pulse1_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse1_sweep_routine_check_reload:
0012d5 ff97                      	sbrs pulse_channel_flags, 7 //if the reload flag is set, reload the sweep divider
0012d6 9508                      	ret
                                 
                                 pulse1_sweep_reload:
0012d7 90c0 2801                 	lds pulse1_sweep, pulse1_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
0012d9 94c2                      	swap pulse1_sweep //bring data from high byte to low byte
0012da 779f                      	cbr pulse_channel_flags, 0b10000000 //clear reload flag
0012db 9508                      	ret
                                 
                                 
                                 
                                 pulse1_envelope_routine:
0012dc fd96                      	sbrc pulse_channel_flags, 6 //check if start flag is cleared
0012dd c010                      	rjmp pulse1_envelope_routine_clear_start
                                 
0012de 3000                      	cpi pulse1_volume_divider, 0x00 //check if the divider is 0
0012df f011                      	breq PC+3 //if the divider == 0, check loop flag
0012e0 950a                      	dec pulse1_volume_divider //if the divider != 0, decrement and return
0012e1 9508                      	ret
                                 
0012e2 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the divider == 0, reset the divider period
0012e4 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
0012e5 ff95                      	sbrs pulse_channel_flags, 5 //check if the loop flag is set
0012e6 c002                      	rjmp pulse1_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
0012e7 e01f                      	ldi pulse1_volume_decay, 0x0F //if the loop flag is set, reset decay and return
0012e8 9508                      	ret
                                 
                                 pulse1_envelope_routine_decrement_decay:
0012e9 3010                      	cpi pulse1_volume_decay, 0x00 //check if the decay is 0
0012ea f409                      	brne PC+2 //if decay != 0, go decrement
0012eb 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
0012ec 951a                      	dec pulse1_volume_decay
0012ed 9508                      	ret
                                 
                                 pulse1_envelope_routine_clear_start:
0012ee 7b9f                      	cbr pulse_channel_flags, 0b01000000 //if the start flag is set, clear it
0012ef 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the start flag is set, reset the divider period
0012f1 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
0012f2 e01f                      	ldi pulse1_volume_decay, 0x0F //if the start flag is set, reset decay
0012f3 9508                      	ret
                                 
                                 //PULSE 2 ROUTINES
                                 pulse2_sequence_routine:
0012f4 b7bf                      	in r27, CPU_SREG
0012f5 93bf                      	push r27
0012f6 94f8                      	cli
                                 
0012f7 0cdd                      	lsl pulse2_sequence //shifts sequence to the left
0012f8 1cd2                      	adc pulse2_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
0012f9 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
0012fa 93b0 0a96                 	sts TCB1_INTFLAGS, r27
0012fc 91bf                      	pop r27
0012fd bfbf                      	out CPU_SREG, r27
0012fe 9518                      	reti
                                 
                                 pulse2_sweep_routine:
0012ff 2dbf                      	mov r27, pulse2_sweep
001300 70b7                      	andi r27, 0x07 //mask for period divider bits
001301 f4f9                      	brne pulse2_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse2_sweep_routine_action: //if the divider is == 0, update the pulse timer period
001302 93df                      	push r29
001303 2ddf                      	mov r29, pulse2_sweep
001304 95d2                      	swap r29
001305 70d7                      	andi r29, 0x07 //mask for shift bits
001306 f411                      	brne pulse2_sweep_routine_action_main //shift != 0
001307 91df                      	pop r29
001308 c019                      	rjmp pulse2_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse2_sweep_routine_action_main:
001309 91a0 0a9c                 	lds r26, TCB1_CCMPL
00130b 91b0 0a9d                 	lds r27, TCB1_CCMPH
                                 pulse2_sweep_routine_action_main_loop:
00130d 95b6                      	lsr r27
00130e 95a7                      	ror r26
00130f 95da                      	dec r29
001310 f7e1                      	brne pulse2_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
001311 fef7                      	sbrs pulse2_sweep, 7 //check the negate flag
001312 c002                      	rjmp pulse2_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
001313 95a0                      	com r26 //pulse2 uses one's complement if the negate flag is set
001314 95b0                      	com r27
                                 
                                 pulse2_sweep_routine_action_main_add:
001315 91d0 0a9c                 	lds r29, TCB1_CCMPL //perform addition to get new timer period
001317 0fad                      	add r26, r29
001318 91d0 0a9d                 	lds r29, TCB1_CCMPH
00131a 1fbd                      	adc r27, r29
                                 
00131b 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new LOW bits for timer
00131d 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new HIGH bits for timer
                                 	
00131f 91df                      	pop r29
001320 c001                      	rjmp pulse2_sweep_routine_check_reload
                                 
                                 pulse2_sweep_routine_decrement_divider:
001321 94fa                      	dec pulse2_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse2_sweep_routine_check_reload:
001322 ff93                      	sbrs pulse_channel_flags, 3 //if the reload flag is set, reload the sweep divider
001323 9508                      	ret
                                 
                                 pulse2_sweep_reload:
001324 90f0 2809                 	lds pulse2_sweep, pulse2_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
001326 94f2                      	swap pulse2_sweep //bring data from high byte to low byte
001327 7f97                      	cbr pulse_channel_flags, 0b00001000 //clear reload flag
001328 9508                      	ret
                                 
                                 
                                 
                                 pulse2_envelope_routine:
001329 fd92                      	sbrc pulse_channel_flags, 2 //check if start flag is cleared
00132a c010                      	rjmp pulse2_envelope_routine_clear_start
                                 
00132b 3020                      	cpi pulse2_volume_divider, 0x00 //check if the divider is 0
00132c f011                      	breq PC+3 //if the divider == 0, check loop flag
00132d 952a                      	dec pulse2_volume_divider //if the divider != 0, decrement and return
00132e 9508                      	ret
                                 
00132f 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the divider == 0, reset the divider period
001331 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
001332 ff91                      	sbrs pulse_channel_flags, 1 //check if the loop flag is set
001333 c002                      	rjmp pulse2_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
001334 e03f                      	ldi pulse2_volume_decay, 0x0F //if the loop flag is set, reset decay and return
001335 9508                      	ret
                                 
                                 pulse2_envelope_routine_decrement_decay:
001336 3030                      	cpi pulse2_volume_decay, 0x00 //check if the decay is 0
001337 f409                      	brne PC+2 //if decay != 0, go decrement
001338 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
001339 953a                      	dec pulse2_volume_decay
00133a 9508                      	ret
                                 
                                 pulse2_envelope_routine_clear_start:
00133b 7f9b                      	cbr pulse_channel_flags, 0b00000100 //if the start flag is set, clear it
00133c 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the start flag is set, reset the divider period
00133e 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
00133f e03f                      	ldi pulse2_volume_decay, 0x0F //if the start flag is set, reset decay
001340 9508                      	ret
                                 
                                 //TRIANGLE ROUTINES
                                 triangle_sequence_routine:
001341 b7bf                      	in r27, CPU_SREG
001342 93bf                      	push r27
001343 94f8                      	cli
                                 
001344 5f4f                      	subi triangle_sequence, -1 //increment sequence by 1
001345 714f                      	andi triangle_sequence, 0b00011111 //mask out bits 5, 6 and 7 NOTE: the sequence only needs bits 0-4.
                                 
001346 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
001347 93b0 0aa6                 	sts TCB2_INTFLAGS, r27
001349 91bf                      	pop r27
00134a bfbf                      	out CPU_SREG, r27
00134b 9518                      	reti
                                 
                                 //NOISE ROUTINES
                                 noise_sequence_routine:
00134c b7bf                      	in r27, CPU_SREG
00134d 93bf                      	push r27
00134e 94f8                      	cli
                                 
00134f 2fa5                      	mov r26, noise_sequence_LOW
001350 fd67                      	sbrc noise_sequence_HIGH, 7 //skip if MODE bit is clear
001351 c00b                      	rjmp noise_sequence_routine_mode_set
                                 
                                 noise_sequence_routine_mode_clear:
001352 95a6                      	lsr r26 //move the 1th bit to the 0th bit place
001353 27a5                      	eor r26, noise_sequence_LOW
001354 fda0                      	sbrc r26, 0 //skip if the EOR of bit 0 and 1 is clear
001355 c003                      	rjmp noise_sequence_routine_mode_clear_EOR_set
                                 
                                 noise_sequence_routine_mode_clear_EOR_clear:
001356 9566                      	lsr noise_sequence_HIGH
001357 9557                      	ror noise_sequence_LOW
001358 c013                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_clear_EOR_set:
001359 9566                      	lsr noise_sequence_HIGH
00135a 9557                      	ror noise_sequence_LOW
00135b 6460                      	ori noise_sequence_HIGH, 0b01000000 //set the 14th bit
00135c c00f                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_set:
00135d 0faa                      	lsl r26
00135e 1faa                      	rol r26
00135f 1faa                      	rol r26 //move the 6th bit to the 0th bit place
001360 27a5                      	eor r26, noise_sequence_LOW
001361 fda0                      	sbrc r26, 0 //skip if the EOR of bit 0 and 1 is clear
001362 c005                      	rjmp noise_sequence_routine_mode_set_EOR_set
                                 
                                 noise_sequence_routine_mode_set_EOR_clear:
001363 776f                      	cbr noise_sequence_HIGH, 0b10000000 //clear the MODE flag
001364 9566                      	lsr noise_sequence_HIGH
001365 9557                      	ror noise_sequence_LOW
001366 6860                      	sbr noise_sequence_HIGH, 0b10000000 //set the MODE flag
001367 c004                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_set_EOR_set:
001368 9566                      	lsr noise_sequence_HIGH
001369 9557                      	ror noise_sequence_LOW
00136a 6860                      	sbr noise_sequence_HIGH, 0b10000000 //set the MODE flag
00136b c000                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_exit:
00136c e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
00136d 93b0 0ab6                 	sts TCB3_INTFLAGS, r27
00136f 91bf                      	pop r27
001370 bfbf                      	out CPU_SREG, r27
001371 9518                      	reti
                                 
                                 //CONVERTERS
                                 //converts and loads 5 bit length to corresponding 8 bit length value into r29
                                 length_converter:
001372 e7e0                      	ldi ZL, LOW(length << 1)
001373 e5fb                      	ldi ZH, HIGH(length << 1)
001374 0fed                      	add ZL, r29
001375 1df2                      	adc ZH, zero
001376 91d4                      	lpm r29, Z
001377 9508                      	ret
                                 
                                 //loads pulse sequence into r29
                                 duty_cycle_sequences:
001378 e9e0                      	ldi ZL, LOW(sequences << 1)
001379 e5fb                      	ldi ZH, HIGH(sequences << 1)
00137a 0fed                      	add ZL, r29
00137b 1df2                      	adc ZH, zero
00137c 91d4                      	lpm r29, Z
00137d 9508                      	ret
                                 
                                 
                                 
                                 //SOUND DRIVER
                                 sound_driver:
00137e b7bf                      	in r27, CPU_SREG
00137f 93bf                      	push r27
001380 94f8                      	cli
001381 93cf                      	push r28
001382 93df                      	push r29
001383 93ef                      	push r30
001384 93ff                      	push r31
                                 
                                 	//SOUND DRIVER
001385 91a0 281f                 	lds r26, song_fx_Bxx
001387 3faf                      	cpi r26, 0xFF //0xFF means that the flag is disabled
001388 f4a9                      	brne sound_driver_fx_Bxx_routine
001389 91a0 2820                 	lds r26, song_fx_Cxx
00138b 11a2                      	cpse r26, zero
00138c c08b                      	rjmp sound_driver_fx_Cxx_routine
00138d 91a0 2821                 	lds r26, song_fx_Dxx
00138f 11a2                      	cpse r26, zero
001390 c096                      	rjmp sound_driver_fx_Dxx_routine
                                 
001391 91a0 281a                 	lds r26, song_frame_offset
001393 91b0 281b                 	lds r27, song_frame_offset+1
001395 91c0 281c                 	lds r28, song_size
001397 91d0 281d                 	lds r29, song_size+1
001399 17ac                      	cp r26, r28
00139a 07bd                      	cpc r27, r29
00139b f408                      	brsh sound_driver_fx_song_loop
00139c c101                      	rjmp sound_driver_channel0
                                 
                                 
                                 sound_driver_fx_song_loop:
00139d e0a0                      	ldi r26, 0x00
                                 sound_driver_fx_Bxx_routine:
00139e 91e0 2818                 	lds ZL, song_frames
0013a0 91f0 2819                 	lds ZH, song_frames+1
0013a2 27cc                      	clr r28 //initialize r29:r28 to 0
0013a3 27dd                      	clr r29
0013a4 95a3                      	inc r26 //increment xx parameter by 1
                                 sound_driver_fx_Bxx_routine_loop:
0013a5 95aa                      	dec r26
0013a6 f011                      	breq sound_driver_fx_Bxx_routine_loop_exit //once r26 == 0, r29:r28 will hold Bxx*(5*2).
0013a7 962a                      	adiw r29:r28, 10 //increment the offset by 10 because 5 channels, and each address takes 2 bytes (5*2 = 10)
0013a8 cffc                      	rjmp sound_driver_fx_Bxx_routine_loop
                                 
                                 sound_driver_fx_Bxx_routine_loop_exit:
0013a9 9622                      	adiw r29:r28, 2 //add 2 to skip the first 2 bytes (first 2 bytes is the song size)
0013aa 93c0 281a                 	sts song_frame_offset, r28
0013ac 93d0 281b                 	sts song_frame_offset+1, r29
0013ae 0fec                      	add ZL, r28
0013af 1ffd                      	adc ZH, r29
                                 
0013b0 91a5                      	lpm r26, Z+ //load the address of the frame(pattern)
0013b1 91b5                      	lpm r27, Z+
0013b2 0faa                      	lsl r26
0013b3 1fbb                      	rol r27
0013b4 93a0 2822                 	sts pulse1_pattern, r26
0013b6 93b0 2823                 	sts pulse1_pattern+1, r27
0013b8 91a5                      	lpm r26, Z+
0013b9 91b5                      	lpm r27, Z+
0013ba 0faa                      	lsl r26
0013bb 1fbb                      	rol r27
0013bc 93a0 2873                 	sts pulse2_pattern, r26
0013be 93b0 2874                 	sts pulse2_pattern+1, r27
0013c0 91a5                      	lpm r26, Z+
0013c1 91b5                      	lpm r27, Z+
0013c2 0faa                      	lsl r26
0013c3 1fbb                      	rol r27
0013c4 93a0 28c4                 	sts triangle_pattern, r26
0013c6 93b0 28c5                 	sts triangle_pattern+1, r27
0013c8 91a5                      	lpm r26, Z+
0013c9 91b5                      	lpm r27, Z+
0013ca 0faa                      	lsl r26
0013cb 1fbb                      	rol r27
0013cc 93a0 2910                 	sts noise_pattern, r26
0013ce 93b0 2911                 	sts noise_pattern+1, r27
                                 
0013d0 9220 2826                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
0013d2 9220 2827                 	sts pulse1_pattern_offset+1, zero
0013d4 9220 2824                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
0013d6 9220 2825                 	sts pulse1_pattern_delay_frames, zero
0013d8 9220 2877                 	sts pulse2_pattern_offset, zero
0013da 9220 2878                 	sts pulse2_pattern_offset+1, zero
0013dc 9220 2875                 	sts pulse2_pattern_delay_rows, zero
0013de 9220 2876                 	sts pulse2_pattern_delay_frames, zero
0013e0 9220 28c8                 	sts triangle_pattern_offset, zero
0013e2 9220 28c9                 	sts triangle_pattern_offset+1, zero
0013e4 9220 28c6                 	sts triangle_pattern_delay_rows, zero
0013e6 9220 28c7                 	sts triangle_pattern_delay_frames, zero
0013e8 9220 2914                 	sts noise_pattern_offset, zero
0013ea 9220 2915                 	sts noise_pattern_offset+1, zero
0013ec 9220 2912                 	sts noise_pattern_delay_rows, zero
0013ee 9220 2913                 	sts noise_pattern_delay_frames, zero
                                 
0013f0 efaf                      	ldi r26, 0xFF
0013f1 93a0 285f                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
0013f3 93a0 2860                 	sts pulse1_fx_Gxx_post, r26
0013f5 93a0 2871                 	sts pulse1_fx_Sxx_pre, r26
0013f7 93a0 2872                 	sts pulse1_fx_Sxx_post, r26
0013f9 93a0 28b0                 	sts pulse2_fx_Gxx_pre, r26
0013fb 93a0 28b1                 	sts pulse2_fx_Gxx_post, r26
0013fd 93a0 28c2                 	sts pulse2_fx_Sxx_pre, r26
0013ff 93a0 28c3                 	sts pulse2_fx_Sxx_post, r26
001401 93a0 28fc                 	sts triangle_fx_Gxx_pre, r26
001403 93a0 28fd                 	sts triangle_fx_Gxx_post, r26
001405 93a0 290e                 	sts triangle_fx_Sxx_pre, r26
001407 93a0 290f                 	sts triangle_fx_Sxx_post, r26
001409 93a0 294d                 	sts noise_fx_Gxx_pre, r26
00140b 93a0 294e                 	sts noise_fx_Gxx_post, r26
00140d 93a0 295f                 	sts noise_fx_Sxx_pre, r26
00140f 93a0 2960                 	sts noise_fx_Sxx_post, r26
                                 
001411 93a0 281f                 	sts song_fx_Bxx, r26 //reset all song effects
001413 9220 2820                 	sts song_fx_Cxx, zero
001415 9220 2821                 	sts song_fx_Dxx, zero
001417 c086                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_fx_Cxx_routine:
001418 91ff                      	pop r31
001419 91ef                      	pop r30
00141a 91df                      	pop r29
00141b 91cf                      	pop r28
00141c 91bf                      	pop r27
00141d bfbf                      	out CPU_SREG, r27
00141e 94f8                      	cli //disable global interrupts
                                 		
00141f efaf                      	ldi r26, 0xFF
001420 93a0 281f                 	sts song_fx_Bxx, r26 //reset all song effects
001422 9220 2820                 	sts song_fx_Cxx, zero
001424 9220 2821                 	sts song_fx_Dxx, zero
001426 9518                      	reti
                                 
                                 sound_driver_fx_Dxx_routine:
001427 91e0 2818                 	lds ZL, song_frames
001429 91f0 2819                 	lds ZH, song_frames+1
00142b 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
00142d 91b0 281b                 	lds r27, song_frame_offset+1
00142f 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
001430 93a0 281a                 	sts song_frame_offset, r26
001432 93b0 281b                 	sts song_frame_offset+1, r27
001434 0fea                      	add ZL, r26
001435 1ffb                      	adc ZH, r27
                                 
001436 91a5                      	lpm r26, Z+ //load the address of the next pattern
001437 91b5                      	lpm r27, Z+
001438 0faa                      	lsl r26
001439 1fbb                      	rol r27
00143a 93a0 2822                 	sts pulse1_pattern, r26
00143c 93b0 2823                 	sts pulse1_pattern+1, r27
00143e 91a5                      	lpm r26, Z+
00143f 91b5                      	lpm r27, Z+
001440 0faa                      	lsl r26
001441 1fbb                      	rol r27
001442 93a0 2873                 	sts pulse2_pattern, r26
001444 93b0 2874                 	sts pulse2_pattern+1, r27
001446 91a5                      	lpm r26, Z+
001447 91b5                      	lpm r27, Z+
001448 0faa                      	lsl r26
001449 1fbb                      	rol r27
00144a 93a0 28c4                 	sts triangle_pattern, r26
00144c 93b0 28c5                 	sts triangle_pattern+1, r27
00144e 91a5                      	lpm r26, Z+
00144f 91b5                      	lpm r27, Z+
001450 0faa                      	lsl r26
001451 1fbb                      	rol r27
001452 93a0 2910                 	sts noise_pattern, r26
001454 93b0 2911                 	sts noise_pattern+1, r27
                                 
001456 9220 2826                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001458 9220 2827                 	sts pulse1_pattern_offset+1, zero
00145a 9220 2824                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
00145c 9220 2825                 	sts pulse1_pattern_delay_frames, zero
00145e 9220 2877                 	sts pulse2_pattern_offset, zero
001460 9220 2878                 	sts pulse2_pattern_offset+1, zero
001462 9220 2875                 	sts pulse2_pattern_delay_rows, zero
001464 9220 2876                 	sts pulse2_pattern_delay_frames, zero
001466 9220 28c8                 	sts triangle_pattern_offset, zero
001468 9220 28c9                 	sts triangle_pattern_offset+1, zero
00146a 9220 28c6                 	sts triangle_pattern_delay_rows, zero
00146c 9220 28c7                 	sts triangle_pattern_delay_frames, zero
00146e 9220 2914                 	sts noise_pattern_offset, zero
001470 9220 2915                 	sts noise_pattern_offset+1, zero
001472 9220 2912                 	sts noise_pattern_delay_rows, zero
001474 9220 2913                 	sts noise_pattern_delay_frames, zero
                                 
001476 efaf                      	ldi r26, 0xFF
001477 93a0 285f                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
001479 93a0 2860                 	sts pulse1_fx_Gxx_post, r26
00147b 93a0 2871                 	sts pulse1_fx_Sxx_pre, r26
00147d 93a0 2872                 	sts pulse1_fx_Sxx_post, r26
00147f 93a0 28b0                 	sts pulse2_fx_Gxx_pre, r26
001481 93a0 28b1                 	sts pulse2_fx_Gxx_post, r26
001483 93a0 28c2                 	sts pulse2_fx_Sxx_pre, r26
001485 93a0 28c3                 	sts pulse2_fx_Sxx_post, r26
001487 93a0 28fc                 	sts triangle_fx_Gxx_pre, r26
001489 93a0 28fd                 	sts triangle_fx_Gxx_post, r26
00148b 93a0 290e                 	sts triangle_fx_Sxx_pre, r26
00148d 93a0 290f                 	sts triangle_fx_Sxx_post, r26
00148f 93a0 294d                 	sts noise_fx_Gxx_pre, r26
001491 93a0 294e                 	sts noise_fx_Gxx_post, r26
001493 93a0 295f                 	sts noise_fx_Sxx_pre, r26
001495 93a0 2960                 	sts noise_fx_Sxx_post, r26
                                 
001497 93a0 281f                 	sts song_fx_Bxx, r26 //reset all song effects
001499 9220 2820                 	sts song_fx_Cxx, zero
00149b 9220 2821                 	sts song_fx_Dxx, zero
00149d c000                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0:
00149e 91a0 2824                 	lds r26, pulse1_pattern_delay_rows
0014a0 91b0 2825                 	lds r27, pulse1_pattern_delay_frames
0014a2 9610                      	adiw r27:r26, 0
0014a3 f009                      	breq sound_driver_channel0_main //if the pattern delay is 0, proceed with sound driver procedures
0014a4 c2e4                      	rjmp sound_driver_channel0_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel0_main:
0014a5 91e0 2822                 	lds ZL, pulse1_pattern //current pattern for pulse 1
0014a7 91f0 2823                 	lds ZH, pulse1_pattern+1
0014a9 91a0 2826                 	lds r26, pulse1_pattern_offset //current offset in the pattern for pulse 1
0014ab 91b0 2827                 	lds r27, pulse1_pattern_offset+1
0014ad 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
0014ae 1ffb                      	adc ZH, r27
0014af 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel0_check_if_note: //check if data is a note (0x00 - 0x56)
0014b0 35b7                      	cpi r27, 0x57
0014b1 f408                      	brsh sound_driver_channel0_check_if_volume
0014b2 c17c                      	rjmp sound_driver_channel0_note
                                 sound_driver_channel0_check_if_volume: //check if data is volume (0x57-0x66)
0014b3 36b7                      	cpi r27, 0x67
0014b4 f408                      	brsh sound_driver_channel0_check_if_delay
0014b5 c1ba                      	rjmp sound_driver_channel0_volume
                                 sound_driver_channel0_check_if_delay: //check if data is a delay (0x67 - 0xE2)
0014b6 3eb3                      	cpi r27, 0xE3
0014b7 f408                      	brsh sound_driver_channel0_check_if_instrument
0014b8 c1c1                      	rjmp sound_driver_channel0_delay
                                 sound_driver_channel0_check_if_instrument: //check for instrument flag (0xE3)
0014b9 f409                      	brne sound_driver_channel0_check_if_release
0014ba c1c4                      	rjmp sound_driver_channel0_instrument_change 
                                 sound_driver_channel0_check_if_release: //check for note release flag (0xE4)
0014bb 3eb4                      	cpi r27, 0xE4
0014bc f409                      	brne sound_driver_channel0_check_if_end
0014bd c26d                      	rjmp sound_driver_channel0_release
                                 sound_driver_channel0_check_if_end:
0014be 3fbf                      	cpi r27, 0xFF
0014bf f409                      	brne sound_driver_channel0_check_if_fx
0014c0 c28f                      	rjmp sound_driver_channel0_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel0_check_if_fx: //fx flags (0xE5 - 0xFE)
0014c1 9631                      	adiw Z, 1 //point Z to the byte next to the flag
0014c2 91a4                      	lpm r26, Z //load the fx data into r26
0014c3 d2bb                      	rcall sound_driver_channel0_increment_offset_twice
                                 
0014c4 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
0014c5 e9e4                      	ldi ZL, LOW(channel0_fx << 1) //load in note table
0014c6 e5fb                      	ldi ZH, HIGH(channel0_fx << 1)
0014c7 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
0014c8 0feb                      	add ZL, r27 //add offset
0014c9 1df2                      	adc ZH, zero
0014ca 91c5                      	lpm r28, Z+ //load address bytes
0014cb 91d4                      	lpm r29, Z
0014cc 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
0014cd 2ffd                      	mov ZH, r29
0014ce 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel0_fx_0xy:
0014cf 93a0 2845                 	sts pulse1_fx_0xy_sequence, r26
0014d1 9220 2846                 	sts pulse1_fx_0xy_sequence+1, zero
0014d3 cfd1                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel0_fx_1xx:
0014d4 9220 284b                 	sts pulse1_fx_2xx, zero //turn off any 2xx pitch slide down
0014d6 9220 284c                 	sts pulse1_fx_2xx+1, zero
0014d8 9220 2845                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
0014da 9220 2846                 	sts pulse1_fx_0xy_sequence+1, zero
0014dc 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0014dd 937f                      	push r23
0014de 2f6a                      	mov r22, r26 //store the rate into r22
0014df eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0014e0 9f67                      	mul r22, r23
0014e1 917f                      	pop r23
0014e2 916f                      	pop r22
                                 
0014e3 9416                      	lsr r1 //shift out the fractional bits
0014e4 9407                      	ror r0
0014e5 9416                      	lsr r1
0014e6 9407                      	ror r0
0014e7 9416                      	lsr r1
0014e8 9407                      	ror r0
0014e9 9416                      	lsr r1
0014ea 9407                      	ror r0
0014eb 9200 2847                 	sts pulse1_fx_1xx, r0
0014ed 9210 2848                 	sts pulse1_fx_1xx+1, r1
0014ef cfb5                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel0_fx_2xx:
0014f0 9220 2847                 	sts pulse1_fx_1xx, zero //turn off any 1xx pitch slide down
0014f2 9220 2848                 	sts pulse1_fx_1xx+1, zero
0014f4 9220 2845                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
0014f6 9220 2846                 	sts pulse1_fx_0xy_sequence+1, zero
0014f8 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0014f9 937f                      	push r23
0014fa 2f6a                      	mov r22, r26 //store the rate into r22
0014fb eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0014fc 9f67                      	mul r22, r23
0014fd 917f                      	pop r23
0014fe 916f                      	pop r22
                                 
0014ff 9416                      	lsr r1 //shift out the fractional bits
001500 9407                      	ror r0
001501 9416                      	lsr r1
001502 9407                      	ror r0
001503 9416                      	lsr r1
001504 9407                      	ror r0
001505 9416                      	lsr r1
001506 9407                      	ror r0
001507 9200 284b                 	sts pulse1_fx_2xx, r0
001509 9210 284c                 	sts pulse1_fx_2xx+1, r1
00150b cf99                      	rjmp sound_driver_channel0_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel0_fx_3xx:
00150c 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00150d 937f                      	push r23
00150e 2f6a                      	mov r22, r26 //store the rate into r22
00150f eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001510 9f67                      	mul r22, r23
001511 917f                      	pop r23
001512 916f                      	pop r22
                                 
001513 9416                      	lsr r1 //shift out the fractional bits
001514 9407                      	ror r0
001515 9416                      	lsr r1
001516 9407                      	ror r0
001517 9416                      	lsr r1
001518 9407                      	ror r0
001519 9416                      	lsr r1
00151a 9407                      	ror r0
00151b 9200 2853                 	sts pulse1_fx_3xx_speed, r0
00151d 9210 2854                 	sts pulse1_fx_3xx_speed+1, r1
                                 
00151f 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001520 c001                      	rjmp sound_driver_channel0_fx_3xx_enabled
001521 cf83                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_3xx_enabled:
001522 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001524 91b0 0a8d                 	lds r27, TCB0_CCMPH
001526 93a0 284f                 	sts pulse1_fx_3xx_start, r26
001528 93b0 2850                 	sts pulse1_fx_3xx_start+1, r27
                                 
00152a 9220 2855                 	sts pulse1_fx_3xx_total_offset, zero
00152c 9220 2856                 	sts pulse1_fx_3xx_total_offset+1, zero
00152e cf76                      	rjmp sound_driver_channel0_main
                                 
                                 //VIBRATO
                                 sound_driver_channel0_fx_4xy:
00152f 2fba                      	mov r27, r26
001530 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001531 95a2                      	swap r26
001532 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001533 93a0 2857                 	sts pulse1_fx_4xy_speed, r26
001535 93b0 2858                 	sts pulse1_fx_4xy_depth, r27
001537 9220 2859                 	sts pulse1_fx_4xy_phase, zero //reset the phase to 0
001539 cf6b                      	rjmp sound_driver_channel0_main
                                 
                                 //TREMELO
                                 sound_driver_channel0_fx_7xy:
00153a 2fba                      	mov r27, r26
00153b 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
00153c 95a2                      	swap r26
00153d 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
00153e 93a0 285a                 	sts pulse1_fx_7xy_speed, r26
001540 93b0 285b                 	sts pulse1_fx_7xy_depth, r27
001542 9220 285c                 	sts pulse1_fx_7xy_phase, zero //reset the phase to 0
001544 9220 285d                 	sts pulse1_fx_7xy_value, zero //reset the tremelo value
001546 cf5e                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel0_fx_Axy:
001547 93a0 285e                 	sts pulse1_fx_Axy, r26
001549 cf5b                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel0_fx_Bxx:
00154a 93a0 281f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
00154c cf58                      	rjmp sound_driver_channel0_main
                                 
                                 //HALT
                                 sound_driver_channel0_fx_Cxx:
00154d 93b0 2820                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
00154f cf55                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel0_fx_Dxx:
001550 93b0 2821                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001552 cf52                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME
                                 sound_driver_channel0_fx_Exx:
001553 91b0 2800                 	lds r27, pulse1_param
001555 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
001556 2bba                      	or r27, r26 //move new VVVV bits into pulse1_param
001557 93b0 2800                 	sts pulse1_param, r27
001559 6096                      	sbr pulse_channel_flags, 6
00155a cf4a                      	rjmp sound_driver_channel0_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel0_fx_Fxx:
00155b 93a0 281e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
00155d cf47                      	rjmp sound_driver_channel0_main
                                 
                                 //DELAY
                                 sound_driver_channel0_fx_Gxx:
00155e 15a2                      	cp r26, zero
00155f f051                      	breq sound_driver_channel0_fx_Gxx_invalid
001560 91b0 281e                 	lds r27, song_speed
001562 17ab                      	cp r26, r27
001563 f430                      	brsh sound_driver_channel0_fx_Gxx_invalid
001564 93a0 285f                 	sts pulse1_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001566 e0b1                      	ldi r27, 0x01
001567 93b0 2824                 	sts pulse1_pattern_delay_rows, r27
001569 c222                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Gxx_invalid:
00156a cf3a                      	rjmp sound_driver_channel0_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel0_fx_Hxy: //hardware sweep up
00156b cf39                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixy: //hardware sweep down
00156c cf38                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Hxx: //FDS modulation depth
00156d cf37                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixx: //FDS modulation speed
00156e cf36                      	rjmp sound_driver_channel0_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel0_fx_Pxx:
00156f 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001570 937f                      	push r23
001571 2f6a                      	mov r22, r26
001572 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001573 0367                      	mulsu r22, r23
001574 917f                      	pop r23
001575 916f                      	pop r22
001576 9416                      	lsr r1 //shift out the fractional bits
001577 9407                      	ror r0
001578 9416                      	lsr r1
001579 9407                      	ror r0
00157a 9416                      	lsr r1
00157b 9407                      	ror r0
00157c 9416                      	lsr r1
00157d 9407                      	ror r0
00157e fe13                      	sbrs r1, 3 //check if result was a negative number
00157f c002                      	rjmp sound_driver_channel0_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel0_fx_Pxx_negative:
001580 efb0                      	ldi r27, 0xF0
001581 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel0_fx_Pxx_store:
001582 9200 2861                 	sts pulse1_fx_Pxx_total, r0
001584 9210 2862                 	sts pulse1_fx_Pxx_total+1, r1
001586 cf1e                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel0_fx_Qxy:
                                 sound_driver_channel0_fx_Qxy_check_arpeggio_macro:
001587 91e0 282d                 	lds ZL, pulse1_arpeggio_macro
001589 91f0 282e                 	lds ZH, pulse1_arpeggio_macro+1
00158b 9630                      	adiw Z, 0
00158c f009                      	breq sound_driver_channel0_fx_Qxy_check_pitch_macro
00158d cf17                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_pitch_macro:
00158e 91e0 2835                 	lds ZL, pulse1_pitch_macro
001590 91f0 2836                 	lds ZH, pulse1_pitch_macro+1
001592 9630                      	adiw Z, 0
001593 f009                      	breq sound_driver_channel0_fx_Qxy_check_hi_pitch_macro
001594 cf10                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_hi_pitch_macro:
001595 91e0 283b                 	lds ZL, pulse1_hi_pitch_macro
001597 91f0 283c                 	lds ZH, pulse1_hi_pitch_macro+1
001599 9630                      	adiw Z, 0
00159a f009                      	breq sound_driver_channel0_fx_Qxy_process
00159b cf09                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_process:
00159c 2fba                      	mov r27, r26 //copy fx parameters into r27
00159d 70bf                      	andi r27, 0x0F //mask note index offset
00159e 91c0 2863                 	lds r28, pulse1_fx_Qxy_target_note //load current note index
0015a0 0fbc                      	add r27, r28
0015a1 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
0015a2 f008                      	brlo sound_driver_channel0_fx_Qxy_process_continue
0015a3 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel0_fx_Qxy_process_continue:
0015a4 93b0 2863                 	sts pulse1_fx_Qxy_target_note, r27
0015a6 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0015a7 e0f0                      	ldi ZH, HIGH(note_table << 1)
0015a8 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
0015a9 0feb                      	add ZL, r27 //add offset
0015aa 1df2                      	adc ZH, zero
0015ab 91c5                      	lpm r28, Z+ //load bytes
0015ac 91d4                      	lpm r29, Z
0015ad 93c0 2864                 	sts pulse1_fx_Qxy_target, r28 //load the LOW bits for the target period
0015af 93d0 2865                 	sts pulse1_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel0_fx_Qxy_process_speed:
0015b1 95a2                      	swap r26
0015b2 70af                      	andi r26, 0x0F //mask effect speed
0015b3 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0015b4 95a3                      	inc r26 //increment the speed by 1
                                 
0015b5 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0015b6 937f                      	push r23
0015b7 2f6a                      	mov r22, r26 //store the speed data into r27
0015b8 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0015b9 9f67                      	mul r22, r23
0015ba 917f                      	pop r23
0015bb 916f                      	pop r22
                                 
0015bc 9416                      	lsr r1 //shift out the fractional bits
0015bd 9407                      	ror r0
0015be 9416                      	lsr r1
0015bf 9407                      	ror r0
0015c0 9416                      	lsr r1
0015c1 9407                      	ror r0
0015c2 9416                      	lsr r1
0015c3 9407                      	ror r0
                                 
0015c4 9200 2866                 	sts pulse1_fx_Qxy_speed, r0 //store the effect speed
0015c6 9210 2867                 	sts pulse1_fx_Qxy_speed+1, r1
0015c8 cedc                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel0_fx_Rxy:
                                 sound_driver_channel0_fx_Rxy_check_arpeggio_macro:
0015c9 91e0 282d                 	lds ZL, pulse1_arpeggio_macro
0015cb 91f0 282e                 	lds ZH, pulse1_arpeggio_macro+1
0015cd 9630                      	adiw Z, 0
0015ce f009                      	breq sound_driver_channel0_fx_Rxy_check_pitch_macro
0015cf ced5                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_pitch_macro:
0015d0 91e0 2835                 	lds ZL, pulse1_pitch_macro
0015d2 91f0 2836                 	lds ZH, pulse1_pitch_macro+1
0015d4 9630                      	adiw Z, 0
0015d5 f009                      	breq sound_driver_channel0_fx_Rxy_check_hi_pitch_macro
0015d6 cece                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_hi_pitch_macro:
0015d7 91e0 283b                 	lds ZL, pulse1_hi_pitch_macro
0015d9 91f0 283c                 	lds ZH, pulse1_hi_pitch_macro+1
0015db 9630                      	adiw Z, 0
0015dc f009                      	breq sound_driver_channel0_fx_Rxy_process
0015dd cec7                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_process:
0015de 2fba                      	mov r27, r26 //copy fx parameters into r27
0015df 70bf                      	andi r27, 0x0F //mask note index offset
0015e0 91c0 286a                 	lds r28, pulse1_fx_Rxy_target_note //load current note index
0015e2 1bcb                      	sub r28, r27
0015e3 f408                      	brcc sound_driver_channel0_fx_Rxy_process_continue
0015e4 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel0_fx_Rxy_process_continue:
0015e5 93c0 286a                 	sts pulse1_fx_Rxy_target_note, r28
0015e7 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0015e8 e0f0                      	ldi ZH, HIGH(note_table << 1)
0015e9 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
0015ea 0fec                      	add ZL, r28 //add offset
0015eb 1df2                      	adc ZH, zero
0015ec 91c5                      	lpm r28, Z+ //load bytes
0015ed 91d4                      	lpm r29, Z
0015ee 93c0 286b                 	sts pulse1_fx_Rxy_target, r28 //load the LOW bits for the target period
0015f0 93d0 286c                 	sts pulse1_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel0_fx_Rxy_process_speed:
0015f2 95a2                      	swap r26
0015f3 70af                      	andi r26, 0x0F //mask effect speed
0015f4 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0015f5 95a3                      	inc r26 //increment the speed by 1
                                 
0015f6 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0015f7 937f                      	push r23
0015f8 2f6a                      	mov r22, r26 //store the speed data into r27
0015f9 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0015fa 9f67                      	mul r22, r23
0015fb 917f                      	pop r23
0015fc 916f                      	pop r22
                                 
0015fd 9416                      	lsr r1 //shift out the fractional bits
0015fe 9407                      	ror r0
0015ff 9416                      	lsr r1
001600 9407                      	ror r0
001601 9416                      	lsr r1
001602 9407                      	ror r0
001603 9416                      	lsr r1
001604 9407                      	ror r0
                                 
001605 9200 286d                 	sts pulse1_fx_Rxy_speed, r0 //store the effect speed
001607 9210 286e                 	sts pulse1_fx_Rxy_speed+1, r1
001609 ce9b                      	rjmp sound_driver_channel0_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel0_fx_Sxx:
00160a 15a2                      	cp r26, zero
00160b f051                      	breq sound_driver_channel0_fx_Sxx_invalid
00160c 91b0 281e                 	lds r27, song_speed
00160e 17ab                      	cp r26, r27
00160f f430                      	brsh sound_driver_channel0_fx_Sxx_invalid
001610 93a0 2871                 	sts pulse1_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001612 e0b1                      	ldi r27, 0x01
001613 93b0 2824                 	sts pulse1_pattern_delay_rows, r27
001615 c176                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Sxx_invalid:
001616 ce8e                      	rjmp sound_driver_channel0_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel0_fx_Vxx:
001617 e9e0                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
001618 e5fb                      	ldi ZH, HIGH(sequences << 1)
001619 0fea                      	add ZL, r26 //offset the pointer
00161a 1df2                      	adc ZH, zero
                                 
00161b 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
00161c 95a7                      	ror r26
00161d 95a7                      	ror r26
00161e 91b0 2800                 	lds r27, pulse1_param //load r27 with pulse1_param (register $4000)
001620 2fcb                      	mov r28, r27 //store a copy of pulse1_param into r28
001621 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
001622 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
001623 c001                      	rjmp sound_driver_channel0_fx_Vxx_store
001624 ce80                      	rjmp sound_driver_channel0_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel0_fx_Vxx_store:
001625 90a4                      	lpm pulse1_sequence, Z //store the sequence
                                 
001626 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
001627 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
001628 93c0 2800                 	sts pulse1_param, r28
00162a ce7a                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_Wxx: //DPCM sample speed
00162b ce79                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Xxx: //DPCM sample retrigger
00162c ce78                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Yxx: //DPCM sample offset
00162d ce77                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Zxx: //DPCM sample delta counter
00162e ce76                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 sound_driver_channel0_note:
00162f 93b0 2807                 	sts pulse1_note, r27 //store the note index
001631 93b0 2863                 	sts pulse1_fx_Qxy_target_note, r27
001633 93b0 286a                 	sts pulse1_fx_Rxy_target_note, r27
001635 e0a3                      	ldi r26, 0x03
001636 e0b2                      	ldi r27, 0x02
001637 93b0 282a                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
001639 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26
00163b 93b0 2837                 	sts pulse1_pitch_macro_offset, r27
00163d 93b0 283d                 	sts pulse1_hi_pitch_macro_offset, r27
00163f 93b0 2842                 	sts pulse1_duty_macro_offset, r27
001641 9220 2833                 	sts pulse1_total_pitch_offset, zero //reset the pitch and hi pitch offset
001643 9220 2834                 	sts pulse1_total_pitch_offset+1, zero
001645 9220 283a                 	sts pulse1_total_hi_pitch_offset, zero
001647 9220 2849                 	sts pulse1_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001649 9220 284a                 	sts pulse1_fx_1xx_total+1, zero
00164b 9220 284d                 	sts pulse1_fx_2xx_total, zero
00164d 9220 284e                 	sts pulse1_fx_2xx_total+1, zero
00164f 9220 2855                 	sts pulse1_fx_3xx_total_offset, zero //reset 3xx offset
001651 9220 2856                 	sts pulse1_fx_3xx_total_offset+1, zero
001653 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001655 91b0 0a8d                 	lds r27, TCB0_CCMPH
001657 93a0 284f                 	sts pulse1_fx_3xx_start, r26
001659 93b0 2850                 	sts pulse1_fx_3xx_start+1, r27
00165b 9220 2801                 	sts pulse1_sweep_param, zero //reset any sweep effect
00165d 6097                      	sbr pulse_channel_flags, 7 //set reload flag
00165e 9220 2864                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001660 9220 2865                 	sts pulse1_fx_Qxy_target+1, zero
001662 9220 2868                 	sts pulse1_fx_Qxy_total_offset, zero
001664 9220 2869                 	sts pulse1_fx_Qxy_total_offset+1, zero
001666 9220 286b                 	sts pulse1_fx_Rxy_target, zero
001668 9220 286c                 	sts pulse1_fx_Rxy_target+1, zero
00166a 9220 286f                 	sts pulse1_fx_Rxy_total_offset, zero
00166c 9220 2870                 	sts pulse1_fx_Rxy_total_offset+1, zero
00166e d106                      	rcall sound_driver_channel0_increment_offset
00166f ce35                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_volume:
001670 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001671 91a0 2800                 	lds r26, pulse1_param
001673 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001674 2bab                      	or r26, r27 //move new VVVV bits into pulse1_param
001675 93a0 2800                 	sts pulse1_param, r26
001677 6096                      	sbr pulse_channel_flags, 6
001678 d0fc                      	rcall sound_driver_channel0_increment_offset
001679 ce2b                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_delay:
00167a 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
00167b 93b0 2824                 	sts pulse1_pattern_delay_rows, r27
00167d d0f7                      	rcall sound_driver_channel0_increment_offset
00167e c10d                      	rjmp sound_driver_channel1
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change:
00167f 9220 2828                 	sts pulse1_volume_macro, zero //reset all macro addresses
001681 9220 2829                 	sts pulse1_volume_macro+1, zero
001683 9220 282d                 	sts pulse1_arpeggio_macro, zero
001685 9220 282e                 	sts pulse1_arpeggio_macro+1, zero
001687 9220 2835                 	sts pulse1_pitch_macro, zero
001689 9220 2836                 	sts pulse1_pitch_macro+1, zero
00168b 9220 283b                 	sts pulse1_hi_pitch_macro, zero
00168d 9220 283c                 	sts pulse1_hi_pitch_macro+1, zero
00168f 9220 2840                 	sts pulse1_duty_macro, zero
001691 9220 2841                 	sts pulse1_duty_macro+1, zero
001693 9220 2833                 	sts pulse1_total_pitch_offset, zero //reset the pitch offset
001695 9220 2834                 	sts pulse1_total_pitch_offset+1, zero
001697 9220 283a                 	sts pulse1_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001699 9631                      	adiw Z, 1 //point to the byte next to the flag
00169a 91b4                      	lpm r27, Z //store the instrument offset into r27
00169b e2ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
00169c e0fd                      	ldi ZH, HIGH(instruments)
00169d 0feb                      	add ZL, r27 //point Z to offsetted instrument
00169e 1df2                      	adc ZH, zero
00169f 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
0016a0 1fff                      	rol ZH
0016a1 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
0016a2 91b4                      	lpm r27, Z
                                 
0016a3 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
0016a4 1fbb                      	rol r27
0016a5 2fea                      	mov ZL, r26
0016a6 2ffb                      	mov ZH, r27
0016a7 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
0016a8 9632                      	adiw Z, 2 //point Z to the address of the macro
0016a9 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel0_instrument_change_macro_loop:
0016aa 95aa                      	dec r26
0016ab f019                      	breq sound_driver_channel0_instrument_change_exit
0016ac 95b6                      	lsr r27
0016ad f078                      	brcs sound_driver_channel0_instrument_change_load_macro
0016ae cffb                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_exit:
0016af e0a3                      	ldi r26, 0x03
0016b0 e0b2                      	ldi r27, 0x02
0016b1 93b0 282a                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
0016b3 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26
0016b5 93b0 2837                 	sts pulse1_pitch_macro_offset, r27
0016b7 93b0 283d                 	sts pulse1_hi_pitch_macro_offset, r27
0016b9 93b0 2842                 	sts pulse1_duty_macro_offset, r27
0016bb d0c3                      	rcall sound_driver_channel0_increment_offset_twice
0016bc cde8                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_load_macro:
0016bd 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
0016be 91d5                      	lpm r29, Z+
                                 
0016bf 30a5                      	cpi r26, 5
0016c0 f039                      	breq sound_driver_channel0_instrument_change_load_macro_volume
0016c1 30a4                      	cpi r26, 4
0016c2 f079                      	breq sound_driver_channel0_instrument_change_load_macro_arpeggio
0016c3 30a3                      	cpi r26, 3
0016c4 f0d9                      	breq sound_driver_channel0_instrument_change_load_macro_pitch
0016c5 30a2                      	cpi r26, 2
0016c6 f159                      	breq sound_driver_channel0_instrument_change_load_macro_hi_pitch
0016c7 c03c                      	rjmp sound_driver_channel0_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel0_instrument_change_load_macro_volume:
0016c8 93c0 2828                 	sts pulse1_volume_macro, r28
0016ca 93d0 2829                 	sts pulse1_volume_macro+1, r29
0016cc d041                      	rcall sound_driver_channel0_instrument_change_read_header
0016cd 93c0 282c                 	sts pulse1_volume_macro_release, r28
0016cf 93d0 282b                 	sts pulse1_volume_macro_loop, r29
0016d1 cfd8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 	
                                 sound_driver_channel0_instrument_change_load_macro_arpeggio:
0016d2 93c0 282d                 	sts pulse1_arpeggio_macro, r28
0016d4 93d0 282e                 	sts pulse1_arpeggio_macro+1, r29
0016d6 9220 2864                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0016d8 9220 2865                 	sts pulse1_fx_Qxy_target+1, zero
0016da 9220 286b                 	sts pulse1_fx_Rxy_target, zero
0016dc 9220 286c                 	sts pulse1_fx_Rxy_target+1, zero
0016de d03a                      	rcall sound_driver_channel0_instrument_change_read_header_arpeggio
0016df cfca                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_pitch:
0016e0 93c0 2835                 	sts pulse1_pitch_macro, r28
0016e2 93d0 2836                 	sts pulse1_pitch_macro+1, r29
0016e4 9220 2864                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0016e6 9220 2865                 	sts pulse1_fx_Qxy_target+1, zero
0016e8 9220 286b                 	sts pulse1_fx_Rxy_target, zero
0016ea 9220 286c                 	sts pulse1_fx_Rxy_target+1, zero
0016ec d021                      	rcall sound_driver_channel0_instrument_change_read_header
0016ed 93c0 2839                 	sts pulse1_pitch_macro_release, r28
0016ef 93d0 2838                 	sts pulse1_pitch_macro_loop, r29
0016f1 cfb8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_hi_pitch:
0016f2 93c0 283b                 	sts pulse1_hi_pitch_macro, r28
0016f4 93d0 283c                 	sts pulse1_hi_pitch_macro+1, r29
0016f6 9220 2864                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0016f8 9220 2865                 	sts pulse1_fx_Qxy_target+1, zero
0016fa 9220 286b                 	sts pulse1_fx_Rxy_target, zero
0016fc 9220 286c                 	sts pulse1_fx_Rxy_target+1, zero
0016fe d00f                      	rcall sound_driver_channel0_instrument_change_read_header
0016ff 93c0 283f                 	sts pulse1_hi_pitch_macro_release, r28
001701 93d0 283e                 	sts pulse1_hi_pitch_macro_loop, r29
001703 cfa6                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_duty:
001704 93c0 2840                 	sts pulse1_duty_macro, r28
001706 93d0 2841                 	sts pulse1_duty_macro+1, r29
001708 d005                      	rcall sound_driver_channel0_instrument_change_read_header
001709 93c0 2844                 	sts pulse1_duty_macro_release, r28
00170b 93d0 2843                 	sts pulse1_duty_macro_loop, r29
00170d cf9c                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_read_header:
00170e 93ef                      	push ZL
00170f 93ff                      	push ZH
001710 2fec                      	mov ZL, r28
001711 2ffd                      	mov ZH, r29
001712 0fee                      	lsl ZL
001713 1fff                      	rol ZH
001714 91c5                      	lpm r28, Z+
001715 91d4                      	lpm r29, Z
001716 91ff                      	pop ZH
001717 91ef                      	pop ZL
001718 9508                      	ret
                                 
                                 sound_driver_channel0_instrument_change_read_header_arpeggio:
001719 93ef                      	push ZL
00171a 93ff                      	push ZH
00171b 2fec                      	mov ZL, r28
00171c 2ffd                      	mov ZH, r29
00171d 0fee                      	lsl ZL
00171e 1fff                      	rol ZH
00171f 91c5                      	lpm r28, Z+
001720 91d5                      	lpm r29, Z+
001721 93c0 2831                 	sts pulse1_arpeggio_macro_release, r28
001723 93d0 2830                 	sts pulse1_arpeggio_macro_loop, r29
001725 91c4                      	lpm r28, Z
001726 93c0 2832                 	sts pulse1_arpeggio_macro_mode, r28
001728 91ff                      	pop ZH
001729 91ef                      	pop ZL
00172a 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel0_release:
                                 sound_driver_channel0_release_volume:
00172b 91b0 282c                 	lds r27, pulse1_volume_macro_release
00172d 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
00172e f019                      	breq sound_driver_channel0_release_arpeggio //if the macro has no release flag, check the next macro
00172f 95b3                      	inc r27
001730 93b0 282a                 	sts pulse1_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel0_release_arpeggio:
001732 91b0 2831                 	lds r27, pulse1_arpeggio_macro_release
001734 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001735 f019                      	breq sound_driver_channel0_release_pitch
001736 95b3                      	inc r27
001737 93b0 282f                 	sts pulse1_arpeggio_macro_offset, r27
                                 sound_driver_channel0_release_pitch:
001739 91b0 2839                 	lds r27, pulse1_pitch_macro_release
00173b 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
00173c f019                      	breq sound_driver_channel0_release_hi_pitch
00173d 95b3                      	inc r27
00173e 93b0 2837                 	sts pulse1_pitch_macro_offset, r27
                                 sound_driver_channel0_release_hi_pitch:
001740 91b0 283f                 	lds r27, pulse1_hi_pitch_macro_release
001742 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001743 f019                      	breq sound_driver_channel0_release_duty
001744 95b3                      	inc r27
001745 93b0 283d                 	sts pulse1_hi_pitch_macro_offset, r27
                                 sound_driver_channel0_release_duty:
001747 91b0 2844                 	lds r27, pulse1_duty_macro_release
001749 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
00174a f019                      	breq sound_driver_channel0_release_exit
00174b 95b3                      	inc r27
00174c 93b0 2842                 	sts pulse1_duty_macro_offset, r27
                                 sound_driver_channel0_release_exit:
00174e d026                      	rcall sound_driver_channel0_increment_offset
00174f cd55                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_next_pattern:
001750 91e0 2818                 	lds ZL, song_frames
001752 91f0 2819                 	lds ZH, song_frames+1
001754 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001756 91b0 281b                 	lds r27, song_frame_offset+1
001758 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
001759 93a0 281a                 	sts song_frame_offset, r26
00175b 93b0 281b                 	sts song_frame_offset+1, r27
                                 
00175d 91c0 281c                 	lds r28, song_size
00175f 91d0 281d                 	lds r29, song_size+1
001761 17ac                      	cp r26, r28
001762 07bd                      	cpc r27, r29
001763 f010                      	brlo sound_driver_channel0_next_pattern_exists
001764 940c 2db2                 	jmp sound_driver_exit
                                 
                                 sound_driver_channel0_next_pattern_exists:
001766 0fea                      	add ZL, r26
001767 1ffb                      	adc ZH, r27
                                 
001768 91a5                      	lpm r26, Z+ //load the address of the next pattern
001769 91b4                      	lpm r27, Z
00176a 0faa                      	lsl r26
00176b 1fbb                      	rol r27
00176c 93a0 2822                 	sts pulse1_pattern, r26
00176e 93b0 2823                 	sts pulse1_pattern+1, r27
                                 
001770 9220 2826                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001772 9220 2827                 	sts pulse1_pattern_offset+1, zero
001774 cd30                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_increment_offset:
001775 91e0 2826                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
001777 91f0 2827                 	lds ZH, pulse1_pattern_offset+1
001779 9631                      	adiw Z, 1
00177a 93e0 2826                 	sts pulse1_pattern_offset, ZL
00177c 93f0 2827                 	sts pulse1_pattern_offset+1, ZH
00177e 9508                      	ret
                                 
                                 sound_driver_channel0_increment_offset_twice: //used for data that takes up 2 bytes worth of space
00177f 91e0 2826                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
001781 91f0 2827                 	lds ZH, pulse1_pattern_offset+1
001783 9632                      	adiw Z, 2 //increment the pointer twice
001784 93e0 2826                 	sts pulse1_pattern_offset, ZL
001786 93f0 2827                 	sts pulse1_pattern_offset+1, ZH
001788 9508                      	ret
                                 
                                 sound_driver_channel0_decrement_frame_delay:
001789 95ba                      	dec r27
00178a 93b0 2825                 	sts pulse1_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel1:
00178c 91a0 2875                 	lds r26, pulse2_pattern_delay_rows
00178e 91b0 2876                 	lds r27, pulse2_pattern_delay_frames
001790 9610                      	adiw r27:r26, 0
001791 f009                      	breq sound_driver_channel1_main //if the pattern delay is 0, proceed with sound driver procedures
001792 c2d7                      	rjmp sound_driver_channel1_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel1_main:
001793 91e0 2873                 	lds ZL, pulse2_pattern //current pattern for pulse 2
001795 91f0 2874                 	lds ZH, pulse2_pattern+1
001797 91a0 2877                 	lds r26, pulse2_pattern_offset //current offset in the pattern for pulse 2
001799 91b0 2878                 	lds r27, pulse2_pattern_offset+1
00179b 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
00179c 1ffb                      	adc ZH, r27
00179d 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel1_check_if_note: //check if data is a note (0x00 - 0x56)
00179e 35b7                      	cpi r27, 0x57
00179f f408                      	brsh sound_driver_channel1_check_if_volume
0017a0 c17c                      	rjmp sound_driver_channel1_note
                                 sound_driver_channel1_check_if_volume: //check if data is volume (0x57-0x66)
0017a1 36b7                      	cpi r27, 0x67
0017a2 f408                      	brsh sound_driver_channel1_check_if_delay
0017a3 c1ba                      	rjmp sound_driver_channel1_volume
                                 sound_driver_channel1_check_if_delay: //check if data is a delay (0x67 - 0xE2)
0017a4 3eb3                      	cpi r27, 0xE3
0017a5 f408                      	brsh sound_driver_channel1_check_if_instrument
0017a6 c1c1                      	rjmp sound_driver_channel1_delay
                                 sound_driver_channel1_check_if_instrument: //check for instrument flag (0xE3)
0017a7 f409                      	brne sound_driver_channel1_check_if_release
0017a8 c1c4                      	rjmp sound_driver_channel1_instrument_change 
                                 sound_driver_channel1_check_if_release: //check for note release flag (0xE4)
0017a9 3eb4                      	cpi r27, 0xE4
0017aa f409                      	brne sound_driver_channel1_check_if_end
0017ab c26d                      	rjmp sound_driver_channel1_release
                                 sound_driver_channel1_check_if_end:
0017ac 3fbf                      	cpi r27, 0xFF
0017ad f409                      	brne sound_driver_channel1_check_if_fx
0017ae c28f                      	rjmp sound_driver_channel1_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel1_check_if_fx: //fx flags (0xE5 - 0xFE)
0017af 9631                      	adiw Z, 1 //point Z to the byte next to the flag
0017b0 91a4                      	lpm r26, Z //load the fx data into r26
0017b1 d2ae                      	rcall sound_driver_channel1_increment_offset_twice
                                 
0017b2 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
0017b3 ece8                      	ldi ZL, LOW(channel1_fx << 1) //load in note table
0017b4 e5fb                      	ldi ZH, HIGH(channel1_fx << 1)
0017b5 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
0017b6 0feb                      	add ZL, r27 //add offset
0017b7 1df2                      	adc ZH, zero
0017b8 91c5                      	lpm r28, Z+ //load address bytes
0017b9 91d4                      	lpm r29, Z
0017ba 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
0017bb 2ffd                      	mov ZH, r29
0017bc 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel1_fx_0xy:
0017bd 93a0 2896                 	sts pulse2_fx_0xy_sequence, r26
0017bf 9220 2897                 	sts pulse2_fx_0xy_sequence+1, zero
0017c1 cfd1                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel1_fx_1xx:
0017c2 9220 289c                 	sts pulse2_fx_2xx, zero //turn off any 2xx pitch slide down
0017c4 9220 289d                 	sts pulse2_fx_2xx+1, zero
0017c6 9220 2896                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
0017c8 9220 2897                 	sts pulse2_fx_0xy_sequence+1, zero
0017ca 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0017cb 937f                      	push r23
0017cc 2f6a                      	mov r22, r26 //store the rate into r22
0017cd eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0017ce 9f67                      	mul r22, r23
0017cf 917f                      	pop r23
0017d0 916f                      	pop r22
                                 
0017d1 9416                      	lsr r1 //shift out the fractional bits
0017d2 9407                      	ror r0
0017d3 9416                      	lsr r1
0017d4 9407                      	ror r0
0017d5 9416                      	lsr r1
0017d6 9407                      	ror r0
0017d7 9416                      	lsr r1
0017d8 9407                      	ror r0
0017d9 9200 2898                 	sts pulse2_fx_1xx, r0
0017db 9210 2899                 	sts pulse2_fx_1xx+1, r1
0017dd cfb5                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel1_fx_2xx:
0017de 9220 2898                 	sts pulse2_fx_1xx, zero //turn off any 1xx pitch slide down
0017e0 9220 2899                 	sts pulse2_fx_1xx+1, zero
0017e2 9220 2896                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
0017e4 9220 2897                 	sts pulse2_fx_0xy_sequence+1, zero
0017e6 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0017e7 937f                      	push r23
0017e8 2f6a                      	mov r22, r26 //store the rate into r22
0017e9 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0017ea 9f67                      	mul r22, r23
0017eb 917f                      	pop r23
0017ec 916f                      	pop r22
                                 
0017ed 9416                      	lsr r1 //shift out the fractional bits
0017ee 9407                      	ror r0
0017ef 9416                      	lsr r1
0017f0 9407                      	ror r0
0017f1 9416                      	lsr r1
0017f2 9407                      	ror r0
0017f3 9416                      	lsr r1
0017f4 9407                      	ror r0
0017f5 9200 289c                 	sts pulse2_fx_2xx, r0
0017f7 9210 289d                 	sts pulse2_fx_2xx+1, r1
0017f9 cf99                      	rjmp sound_driver_channel1_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel1_fx_3xx:
0017fa 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0017fb 937f                      	push r23
0017fc 2f6a                      	mov r22, r26 //store the rate into r22
0017fd eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0017fe 9f67                      	mul r22, r23
0017ff 917f                      	pop r23
001800 916f                      	pop r22
                                 
001801 9416                      	lsr r1 //shift out the fractional bits
001802 9407                      	ror r0
001803 9416                      	lsr r1
001804 9407                      	ror r0
001805 9416                      	lsr r1
001806 9407                      	ror r0
001807 9416                      	lsr r1
001808 9407                      	ror r0
001809 9200 28a4                 	sts pulse2_fx_3xx_speed, r0
00180b 9210 28a5                 	sts pulse2_fx_3xx_speed+1, r1
                                 
00180d 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
00180e c001                      	rjmp sound_driver_channel1_fx_3xx_enabled
00180f cf83                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_3xx_enabled:
001810 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001812 91b0 0a9d                 	lds r27, TCB1_CCMPH
001814 93a0 28a0                 	sts pulse2_fx_3xx_start, r26
001816 93b0 28a1                 	sts pulse2_fx_3xx_start+1, r27
                                 
001818 9220 28a6                 	sts pulse2_fx_3xx_total_offset, zero
00181a 9220 28a7                 	sts pulse2_fx_3xx_total_offset+1, zero
00181c cf76                      	rjmp sound_driver_channel1_main
                                 
                                 //VIBRATO
                                 sound_driver_channel1_fx_4xy:
00181d 2fba                      	mov r27, r26
00181e 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
00181f 95a2                      	swap r26
001820 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001821 93a0 28a8                 	sts pulse2_fx_4xy_speed, r26
001823 93b0 28a9                 	sts pulse2_fx_4xy_depth, r27
001825 9220 28aa                 	sts pulse2_fx_4xy_phase, zero //reset the phase to 0
001827 cf6b                      	rjmp sound_driver_channel1_main
                                 
                                 //TREMELO
                                 sound_driver_channel1_fx_7xy:
001828 2fba                      	mov r27, r26
001829 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
00182a 95a2                      	swap r26
00182b 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
00182c 93a0 28ab                 	sts pulse2_fx_7xy_speed, r26
00182e 93b0 28ac                 	sts pulse2_fx_7xy_depth, r27
001830 9220 28ad                 	sts pulse2_fx_7xy_phase, zero //reset the phase to 0
001832 9220 28ae                 	sts pulse2_fx_7xy_value, zero //reset the tremelo value
001834 cf5e                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel1_fx_Axy:
001835 93a0 28af                 	sts pulse2_fx_Axy, r26
001837 cf5b                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel1_fx_Bxx:
001838 93a0 281f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
00183a cf58                      	rjmp sound_driver_channel1_main
                                 
                                 //HALT
                                 sound_driver_channel1_fx_Cxx:
00183b 93b0 2820                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
00183d cf55                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel1_fx_Dxx:
00183e 93b0 2821                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001840 cf52                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME
                                 sound_driver_channel1_fx_Exx:
001841 91b0 2808                 	lds r27, pulse2_param
001843 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
001844 2bba                      	or r27, r26 //move new VVVV bits into pulse2_param
001845 93b0 2808                 	sts pulse2_param, r27
001847 6092                      	sbr pulse_channel_flags, 2
001848 cf4a                      	rjmp sound_driver_channel1_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel1_fx_Fxx:
001849 93a0 281e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
00184b cf47                      	rjmp sound_driver_channel1_main
                                 
                                 //DELAY
                                 sound_driver_channel1_fx_Gxx:
00184c 15a2                      	cp r26, zero
00184d f051                      	breq sound_driver_channel1_fx_Gxx_invalid
00184e 91b0 281e                 	lds r27, song_speed
001850 17ab                      	cp r26, r27
001851 f430                      	brsh sound_driver_channel1_fx_Gxx_invalid
001852 93a0 28b0                 	sts pulse2_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001854 e0b1                      	ldi r27, 0x01
001855 93b0 2875                 	sts pulse2_pattern_delay_rows, r27
001857 c215                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Gxx_invalid:
001858 cf3a                      	rjmp sound_driver_channel1_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel1_fx_Hxy: //hardware sweep up
001859 cf39                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixy: //hardware sweep down
00185a cf38                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Hxx: //FDS modulation depth
00185b cf37                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixx: //FDS modulation speed
00185c cf36                      	rjmp sound_driver_channel1_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel1_fx_Pxx:
00185d 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00185e 937f                      	push r23
00185f 2f6a                      	mov r22, r26
001860 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001861 0367                      	mulsu r22, r23
001862 917f                      	pop r23
001863 916f                      	pop r22
001864 9416                      	lsr r1 //shift out the fractional bits
001865 9407                      	ror r0
001866 9416                      	lsr r1
001867 9407                      	ror r0
001868 9416                      	lsr r1
001869 9407                      	ror r0
00186a 9416                      	lsr r1
00186b 9407                      	ror r0
00186c fe13                      	sbrs r1, 3 //check if result was a negative number
00186d c002                      	rjmp sound_driver_channel1_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel1_fx_Pxx_negative:
00186e efb0                      	ldi r27, 0xF0
00186f 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel1_fx_Pxx_store:
001870 9200 28b2                 	sts pulse2_fx_Pxx_total, r0
001872 9210 28b3                 	sts pulse2_fx_Pxx_total+1, r1
001874 cf1e                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel1_fx_Qxy:
                                 sound_driver_channel1_fx_Qxy_check_arpeggio_macro:
001875 91e0 287e                 	lds ZL, pulse2_arpeggio_macro
001877 91f0 287f                 	lds ZH, pulse2_arpeggio_macro+1
001879 9630                      	adiw Z, 0
00187a f009                      	breq sound_driver_channel1_fx_Qxy_check_pitch_macro
00187b cf17                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_pitch_macro:
00187c 91e0 2886                 	lds ZL, pulse2_pitch_macro
00187e 91f0 2887                 	lds ZH, pulse2_pitch_macro+1
001880 9630                      	adiw Z, 0
001881 f009                      	breq sound_driver_channel1_fx_Qxy_check_hi_pitch_macro
001882 cf10                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_hi_pitch_macro:
001883 91e0 288c                 	lds ZL, pulse2_hi_pitch_macro
001885 91f0 288d                 	lds ZH, pulse2_hi_pitch_macro+1
001887 9630                      	adiw Z, 0
001888 f009                      	breq sound_driver_channel1_fx_Qxy_process
001889 cf09                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_process:
00188a 2fba                      	mov r27, r26 //copy fx parameters into r27
00188b 70bf                      	andi r27, 0x0F //mask note index offset
00188c 91c0 28b4                 	lds r28, pulse2_fx_Qxy_target_note //load current note index
00188e 0fbc                      	add r27, r28
00188f 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001890 f008                      	brlo sound_driver_channel1_fx_Qxy_process_continue
001891 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel1_fx_Qxy_process_continue:
001892 93b0 28b4                 	sts pulse2_fx_Qxy_target_note, r27
001894 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001895 e0f0                      	ldi ZH, HIGH(note_table << 1)
001896 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001897 0feb                      	add ZL, r27 //add offset
001898 1df2                      	adc ZH, zero
001899 91c5                      	lpm r28, Z+ //load bytes
00189a 91d4                      	lpm r29, Z
00189b 93c0 28b5                 	sts pulse2_fx_Qxy_target, r28 //load the LOW bits for the target period
00189d 93d0 28b6                 	sts pulse2_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel1_fx_Qxy_process_speed:
00189f 95a2                      	swap r26
0018a0 70af                      	andi r26, 0x0F //mask effect speed
0018a1 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0018a2 95a3                      	inc r26 //increment the speed by 1
                                 
0018a3 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0018a4 937f                      	push r23
0018a5 2f6a                      	mov r22, r26 //store the speed data into r27
0018a6 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0018a7 9f67                      	mul r22, r23
0018a8 917f                      	pop r23
0018a9 916f                      	pop r22
                                 
0018aa 9416                      	lsr r1 //shift out the fractional bits
0018ab 9407                      	ror r0
0018ac 9416                      	lsr r1
0018ad 9407                      	ror r0
0018ae 9416                      	lsr r1
0018af 9407                      	ror r0
0018b0 9416                      	lsr r1
0018b1 9407                      	ror r0
                                 
0018b2 9200 28b7                 	sts pulse2_fx_Qxy_speed, r0 //store the effect speed
0018b4 9210 28b8                 	sts pulse2_fx_Qxy_speed+1, r1
0018b6 cedc                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel1_fx_Rxy:
                                 sound_driver_channel1_fx_Rxy_check_arpeggio_macro:
0018b7 91e0 287e                 	lds ZL, pulse2_arpeggio_macro
0018b9 91f0 287f                 	lds ZH, pulse2_arpeggio_macro+1
0018bb 9630                      	adiw Z, 0
0018bc f009                      	breq sound_driver_channel1_fx_Rxy_check_pitch_macro
0018bd ced5                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_pitch_macro:
0018be 91e0 2886                 	lds ZL, pulse2_pitch_macro
0018c0 91f0 2887                 	lds ZH, pulse2_pitch_macro+1
0018c2 9630                      	adiw Z, 0
0018c3 f009                      	breq sound_driver_channel1_fx_Rxy_check_hi_pitch_macro
0018c4 cece                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_hi_pitch_macro:
0018c5 91e0 288c                 	lds ZL, pulse2_hi_pitch_macro
0018c7 91f0 288d                 	lds ZH, pulse2_hi_pitch_macro+1
0018c9 9630                      	adiw Z, 0
0018ca f009                      	breq sound_driver_channel1_fx_Rxy_process
0018cb cec7                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_process:
0018cc 2fba                      	mov r27, r26 //copy fx parameters into r27
0018cd 70bf                      	andi r27, 0x0F //mask note index offset
0018ce 91c0 28bb                 	lds r28, pulse2_fx_Rxy_target_note //load current note index
0018d0 1bcb                      	sub r28, r27
0018d1 f408                      	brcc sound_driver_channel1_fx_Rxy_process_continue
0018d2 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel1_fx_Rxy_process_continue:
0018d3 93c0 28bb                 	sts pulse2_fx_Rxy_target_note, r28
0018d5 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0018d6 e0f0                      	ldi ZH, HIGH(note_table << 1)
0018d7 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
0018d8 0fec                      	add ZL, r28 //add offset
0018d9 1df2                      	adc ZH, zero
0018da 91c5                      	lpm r28, Z+ //load bytes
0018db 91d4                      	lpm r29, Z
0018dc 93c0 28bc                 	sts pulse2_fx_Rxy_target, r28 //load the LOW bits for the target period
0018de 93d0 28bd                 	sts pulse2_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel1_fx_Rxy_process_speed:
0018e0 95a2                      	swap r26
0018e1 70af                      	andi r26, 0x0F //mask effect speed
0018e2 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0018e3 95a3                      	inc r26 //increment the speed by 1
                                 
0018e4 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0018e5 937f                      	push r23
0018e6 2f6a                      	mov r22, r26 //store the speed data into r27
0018e7 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0018e8 9f67                      	mul r22, r23
0018e9 917f                      	pop r23
0018ea 916f                      	pop r22
                                 
0018eb 9416                      	lsr r1 //shift out the fractional bits
0018ec 9407                      	ror r0
0018ed 9416                      	lsr r1
0018ee 9407                      	ror r0
0018ef 9416                      	lsr r1
0018f0 9407                      	ror r0
0018f1 9416                      	lsr r1
0018f2 9407                      	ror r0
                                 
0018f3 9200 28be                 	sts pulse2_fx_Rxy_speed, r0 //store the effect speed
0018f5 9210 28bf                 	sts pulse2_fx_Rxy_speed+1, r1
0018f7 ce9b                      	rjmp sound_driver_channel1_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel1_fx_Sxx:
0018f8 15a2                      	cp r26, zero
0018f9 f051                      	breq sound_driver_channel1_fx_Sxx_invalid
0018fa 91b0 281e                 	lds r27, song_speed
0018fc 17ab                      	cp r26, r27
0018fd f430                      	brsh sound_driver_channel1_fx_Sxx_invalid
0018fe 93a0 28c2                 	sts pulse2_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001900 e0b1                      	ldi r27, 0x01
001901 93b0 2875                 	sts pulse2_pattern_delay_rows, r27
001903 c169                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Sxx_invalid:
001904 ce8e                      	rjmp sound_driver_channel1_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel1_fx_Vxx:
001905 e9e0                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
001906 e5fb                      	ldi ZH, HIGH(sequences << 1)
001907 0fea                      	add ZL, r26 //offset the pointer
001908 1df2                      	adc ZH, zero
                                 
001909 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
00190a 95a7                      	ror r26
00190b 95a7                      	ror r26
00190c 91b0 2808                 	lds r27, pulse2_param //load r27 with pulse2_param (register $4000)
00190e 2fcb                      	mov r28, r27 //store a copy of pulse2_param into r28
00190f 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
001910 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
001911 c001                      	rjmp sound_driver_channel1_fx_Vxx_store
001912 ce80                      	rjmp sound_driver_channel1_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel1_fx_Vxx_store:
001913 90d4                      	lpm pulse2_sequence, Z //store the sequence
                                 
001914 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
001915 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
001916 93c0 2808                 	sts pulse2_param, r28
001918 ce7a                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_Wxx: //DPCM sample speed
001919 ce79                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Xxx: //DPCM sample retrigger
00191a ce78                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Yxx: //DPCM sample offset
00191b ce77                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Zxx: //DPCM sample delta counter
00191c ce76                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 sound_driver_channel1_note:
00191d 93b0 280f                 	sts pulse2_note, r27 //store the note index
00191f 93b0 28b4                 	sts pulse2_fx_Qxy_target_note, r27
001921 93b0 28bb                 	sts pulse2_fx_Rxy_target_note, r27
001923 e0a3                      	ldi r26, 0x03
001924 e0b2                      	ldi r27, 0x02
001925 93b0 287b                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
001927 93a0 2880                 	sts pulse2_arpeggio_macro_offset, r26
001929 93b0 2888                 	sts pulse2_pitch_macro_offset, r27
00192b 93b0 288e                 	sts pulse2_hi_pitch_macro_offset, r27
00192d 93b0 2893                 	sts pulse2_duty_macro_offset, r27
00192f 9220 2884                 	sts pulse2_total_pitch_offset, zero //reset the pitch and hi pitch offset
001931 9220 2885                 	sts pulse2_total_pitch_offset+1, zero
001933 9220 288b                 	sts pulse2_total_hi_pitch_offset, zero
001935 9220 289a                 	sts pulse2_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001937 9220 289b                 	sts pulse2_fx_1xx_total+1, zero
001939 9220 289e                 	sts pulse2_fx_2xx_total, zero
00193b 9220 289f                 	sts pulse2_fx_2xx_total+1, zero
00193d 9220 28a6                 	sts pulse2_fx_3xx_total_offset, zero //reset 3xx offset
00193f 9220 28a7                 	sts pulse2_fx_3xx_total_offset+1, zero
001941 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001943 91b0 0a9d                 	lds r27, TCB1_CCMPH
001945 93a0 28a0                 	sts pulse2_fx_3xx_start, r26
001947 93b0 28a1                 	sts pulse2_fx_3xx_start+1, r27
001949 9220 2809                 	sts pulse2_sweep_param, zero //reset any sweep effect
00194b 6093                      	sbr pulse_channel_flags, 3 //set reload flag
00194c 9220 28b5                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00194e 9220 28b6                 	sts pulse2_fx_Qxy_target+1, zero
001950 9220 28b9                 	sts pulse2_fx_Qxy_total_offset, zero
001952 9220 28ba                 	sts pulse2_fx_Qxy_total_offset+1, zero
001954 9220 28bc                 	sts pulse2_fx_Rxy_target, zero
001956 9220 28bd                 	sts pulse2_fx_Rxy_target+1, zero
001958 9220 28c0                 	sts pulse2_fx_Rxy_total_offset, zero
00195a 9220 28c1                 	sts pulse2_fx_Rxy_total_offset+1, zero
00195c d0f9                      	rcall sound_driver_channel1_increment_offset
00195d ce35                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_volume:
00195e 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
00195f 91a0 2808                 	lds r26, pulse2_param
001961 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001962 2bab                      	or r26, r27 //move new VVVV bits into pulse2_param
001963 93a0 2808                 	sts pulse2_param, r26
001965 6092                      	sbr pulse_channel_flags, 2
001966 d0ef                      	rcall sound_driver_channel1_increment_offset
001967 ce2b                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_delay:
001968 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001969 93b0 2875                 	sts pulse2_pattern_delay_rows, r27
00196b d0ea                      	rcall sound_driver_channel1_increment_offset
00196c c100                      	rjmp sound_driver_channel2
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change:
00196d 9220 2879                 	sts pulse2_volume_macro, zero //reset all macro addresses
00196f 9220 287a                 	sts pulse2_volume_macro+1, zero
001971 9220 287e                 	sts pulse2_arpeggio_macro, zero
001973 9220 287f                 	sts pulse2_arpeggio_macro+1, zero
001975 9220 2886                 	sts pulse2_pitch_macro, zero
001977 9220 2887                 	sts pulse2_pitch_macro+1, zero
001979 9220 288c                 	sts pulse2_hi_pitch_macro, zero
00197b 9220 288d                 	sts pulse2_hi_pitch_macro+1, zero
00197d 9220 2891                 	sts pulse2_duty_macro, zero
00197f 9220 2892                 	sts pulse2_duty_macro+1, zero
001981 9220 2884                 	sts pulse2_total_pitch_offset, zero //reset the pitch offset
001983 9220 2885                 	sts pulse2_total_pitch_offset+1, zero
001985 9220 288b                 	sts pulse2_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001987 9631                      	adiw Z, 1 //point to the byte next to the flag
001988 91b4                      	lpm r27, Z //store the instrument offset into r27
001989 e2ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
00198a e0fd                      	ldi ZH, HIGH(instruments)
00198b 0feb                      	add ZL, r27 //point Z to offsetted instrument
00198c 1df2                      	adc ZH, zero
00198d 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
00198e 1fff                      	rol ZH
00198f 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001990 91b4                      	lpm r27, Z
                                 
001991 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001992 1fbb                      	rol r27
001993 2fea                      	mov ZL, r26
001994 2ffb                      	mov ZH, r27
001995 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001996 9632                      	adiw Z, 2 //point Z to the address of the macro
001997 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel1_instrument_change_macro_loop:
001998 95aa                      	dec r26
001999 f019                      	breq sound_driver_channel1_instrument_change_exit
00199a 95b6                      	lsr r27
00199b f078                      	brcs sound_driver_channel1_instrument_change_load_macro
00199c cffb                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_exit:
00199d e0a3                      	ldi r26, 0x03
00199e e0b2                      	ldi r27, 0x02
00199f 93b0 287b                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
0019a1 93a0 2880                 	sts pulse2_arpeggio_macro_offset, r26
0019a3 93b0 2888                 	sts pulse2_pitch_macro_offset, r27
0019a5 93b0 288e                 	sts pulse2_hi_pitch_macro_offset, r27
0019a7 93b0 2893                 	sts pulse2_duty_macro_offset, r27
0019a9 d0b6                      	rcall sound_driver_channel1_increment_offset_twice
0019aa cde8                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_load_macro:
0019ab 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
0019ac 91d5                      	lpm r29, Z+
                                 
0019ad 30a5                      	cpi r26, 5
0019ae f039                      	breq sound_driver_channel1_instrument_change_load_macro_volume
0019af 30a4                      	cpi r26, 4
0019b0 f079                      	breq sound_driver_channel1_instrument_change_load_macro_arpeggio
0019b1 30a3                      	cpi r26, 3
0019b2 f0d9                      	breq sound_driver_channel1_instrument_change_load_macro_pitch
0019b3 30a2                      	cpi r26, 2
0019b4 f159                      	breq sound_driver_channel1_instrument_change_load_macro_hi_pitch
0019b5 c03c                      	rjmp sound_driver_channel1_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel1_instrument_change_load_macro_volume:
0019b6 93c0 2879                 	sts pulse2_volume_macro, r28
0019b8 93d0 287a                 	sts pulse2_volume_macro+1, r29
0019ba d041                      	rcall sound_driver_channel1_instrument_change_read_header
0019bb 93c0 287d                 	sts pulse2_volume_macro_release, r28
0019bd 93d0 287c                 	sts pulse2_volume_macro_loop, r29
0019bf cfd8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 	
                                 sound_driver_channel1_instrument_change_load_macro_arpeggio:
0019c0 93c0 287e                 	sts pulse2_arpeggio_macro, r28
0019c2 93d0 287f                 	sts pulse2_arpeggio_macro+1, r29
0019c4 9220 28b5                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0019c6 9220 28b6                 	sts pulse2_fx_Qxy_target+1, zero
0019c8 9220 28bc                 	sts pulse2_fx_Rxy_target, zero
0019ca 9220 28bd                 	sts pulse2_fx_Rxy_target+1, zero
0019cc d03a                      	rcall sound_driver_channel1_instrument_change_read_header_arpeggio
0019cd cfca                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_pitch:
0019ce 93c0 2886                 	sts pulse2_pitch_macro, r28
0019d0 93d0 2887                 	sts pulse2_pitch_macro+1, r29
0019d2 9220 28b5                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0019d4 9220 28b6                 	sts pulse2_fx_Qxy_target+1, zero
0019d6 9220 28bc                 	sts pulse2_fx_Rxy_target, zero
0019d8 9220 28bd                 	sts pulse2_fx_Rxy_target+1, zero
0019da d021                      	rcall sound_driver_channel1_instrument_change_read_header
0019db 93c0 288a                 	sts pulse2_pitch_macro_release, r28
0019dd 93d0 2889                 	sts pulse2_pitch_macro_loop, r29
0019df cfb8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_hi_pitch:
0019e0 93c0 288c                 	sts pulse2_hi_pitch_macro, r28
0019e2 93d0 288d                 	sts pulse2_hi_pitch_macro+1, r29
0019e4 9220 28b5                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0019e6 9220 28b6                 	sts pulse2_fx_Qxy_target+1, zero
0019e8 9220 28bc                 	sts pulse2_fx_Rxy_target, zero
0019ea 9220 28bd                 	sts pulse2_fx_Rxy_target+1, zero
0019ec d00f                      	rcall sound_driver_channel1_instrument_change_read_header
0019ed 93c0 2890                 	sts pulse2_hi_pitch_macro_release, r28
0019ef 93d0 288f                 	sts pulse2_hi_pitch_macro_loop, r29
0019f1 cfa6                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_duty:
0019f2 93c0 2891                 	sts pulse2_duty_macro, r28
0019f4 93d0 2892                 	sts pulse2_duty_macro+1, r29
0019f6 d005                      	rcall sound_driver_channel1_instrument_change_read_header
0019f7 93c0 2895                 	sts pulse2_duty_macro_release, r28
0019f9 93d0 2894                 	sts pulse2_duty_macro_loop, r29
0019fb cf9c                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_read_header:
0019fc 93ef                      	push ZL
0019fd 93ff                      	push ZH
0019fe 2fec                      	mov ZL, r28
0019ff 2ffd                      	mov ZH, r29
001a00 0fee                      	lsl ZL
001a01 1fff                      	rol ZH
001a02 91c5                      	lpm r28, Z+
001a03 91d4                      	lpm r29, Z
001a04 91ff                      	pop ZH
001a05 91ef                      	pop ZL
001a06 9508                      	ret
                                 
                                 sound_driver_channel1_instrument_change_read_header_arpeggio:
001a07 93ef                      	push ZL
001a08 93ff                      	push ZH
001a09 2fec                      	mov ZL, r28
001a0a 2ffd                      	mov ZH, r29
001a0b 0fee                      	lsl ZL
001a0c 1fff                      	rol ZH
001a0d 91c5                      	lpm r28, Z+
001a0e 91d5                      	lpm r29, Z+
001a0f 93c0 2882                 	sts pulse2_arpeggio_macro_release, r28
001a11 93d0 2881                 	sts pulse2_arpeggio_macro_loop, r29
001a13 91c4                      	lpm r28, Z
001a14 93c0 2883                 	sts pulse2_arpeggio_macro_mode, r28
001a16 91ff                      	pop ZH
001a17 91ef                      	pop ZL
001a18 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel1_release:
                                 sound_driver_channel1_release_volume:
001a19 91b0 287d                 	lds r27, pulse2_volume_macro_release
001a1b 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001a1c f019                      	breq sound_driver_channel1_release_arpeggio //if the macro has no release flag, check the next macro
001a1d 95b3                      	inc r27
001a1e 93b0 287b                 	sts pulse2_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel1_release_arpeggio:
001a20 91b0 2882                 	lds r27, pulse2_arpeggio_macro_release
001a22 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001a23 f019                      	breq sound_driver_channel1_release_pitch
001a24 95b3                      	inc r27
001a25 93b0 2880                 	sts pulse2_arpeggio_macro_offset, r27
                                 sound_driver_channel1_release_pitch:
001a27 91b0 288a                 	lds r27, pulse2_pitch_macro_release
001a29 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001a2a f019                      	breq sound_driver_channel1_release_hi_pitch
001a2b 95b3                      	inc r27
001a2c 93b0 2888                 	sts pulse2_pitch_macro_offset, r27
                                 sound_driver_channel1_release_hi_pitch:
001a2e 91b0 2890                 	lds r27, pulse2_hi_pitch_macro_release
001a30 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001a31 f019                      	breq sound_driver_channel1_release_duty
001a32 95b3                      	inc r27
001a33 93b0 288e                 	sts pulse2_hi_pitch_macro_offset, r27
                                 sound_driver_channel1_release_duty:
001a35 91b0 2895                 	lds r27, pulse2_duty_macro_release
001a37 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001a38 f019                      	breq sound_driver_channel1_release_exit
001a39 95b3                      	inc r27
001a3a 93b0 2893                 	sts pulse2_duty_macro_offset, r27
                                 sound_driver_channel1_release_exit:
001a3c d019                      	rcall sound_driver_channel1_increment_offset
001a3d cd55                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_next_pattern:
001a3e 91e0 2818                 	lds ZL, song_frames
001a40 91f0 2819                 	lds ZH, song_frames+1
001a42 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001a44 91b0 281b                 	lds r27, song_frame_offset+1
001a46 9612                      	adiw r27:r26, 2 //offset for channel 1
001a47 0fea                      	add ZL, r26
001a48 1ffb                      	adc ZH, r27
                                 
001a49 91a5                      	lpm r26, Z+ //load the address of the next pattern
001a4a 91b4                      	lpm r27, Z
001a4b 0faa                      	lsl r26
001a4c 1fbb                      	rol r27
001a4d 93a0 2873                 	sts pulse2_pattern, r26
001a4f 93b0 2874                 	sts pulse2_pattern+1, r27
                                 
001a51 9220 2877                 	sts pulse2_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001a53 9220 2878                 	sts pulse2_pattern_offset+1, zero
001a55 cd3d                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_increment_offset:
001a56 91e0 2877                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001a58 91f0 2878                 	lds ZH, pulse2_pattern_offset+1
001a5a 9631                      	adiw Z, 1
001a5b 93e0 2877                 	sts pulse2_pattern_offset, ZL
001a5d 93f0 2878                 	sts pulse2_pattern_offset+1, ZH
001a5f 9508                      	ret
                                 
                                 sound_driver_channel1_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001a60 91e0 2877                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001a62 91f0 2878                 	lds ZH, pulse2_pattern_offset+1
001a64 9632                      	adiw Z, 2 //increment the pointer twice
001a65 93e0 2877                 	sts pulse2_pattern_offset, ZL
001a67 93f0 2878                 	sts pulse2_pattern_offset+1, ZH
001a69 9508                      	ret
                                 
                                 sound_driver_channel1_decrement_frame_delay:
001a6a 95ba                      	dec r27
001a6b 93b0 2876                 	sts pulse2_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel2:
001a6d 91a0 28c6                 	lds r26, triangle_pattern_delay_rows
001a6f 91b0 28c7                 	lds r27, triangle_pattern_delay_frames
001a71 9610                      	adiw r27:r26, 0
001a72 f009                      	breq sound_driver_channel2_main //if the pattern delay is 0, proceed with sound driver procedures
001a73 c2bf                      	rjmp sound_driver_channel2_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel2_main:
001a74 91e0 28c4                 	lds ZL, triangle_pattern //current pattern for triangle
001a76 91f0 28c5                 	lds ZH, triangle_pattern+1
001a78 91a0 28c8                 	lds r26, triangle_pattern_offset //current offset in the pattern for triangle
001a7a 91b0 28c9                 	lds r27, triangle_pattern_offset+1
001a7c 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001a7d 1ffb                      	adc ZH, r27
001a7e 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel2_check_if_note: //check if data is a note (0x00 - 0x56)
001a7f 35b7                      	cpi r27, 0x57
001a80 f408                      	brsh sound_driver_channel2_check_if_volume
001a81 c160                      	rjmp sound_driver_channel2_note
                                 sound_driver_channel2_check_if_volume: //check if data is volume (0x57-0x66)
001a82 36b7                      	cpi r27, 0x67
001a83 f408                      	brsh sound_driver_channel2_check_if_delay
001a84 c19e                      	rjmp sound_driver_channel2_volume
                                 sound_driver_channel2_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001a85 3eb3                      	cpi r27, 0xE3
001a86 f408                      	brsh sound_driver_channel2_check_if_instrument
001a87 c1a9                      	rjmp sound_driver_channel2_delay
                                 sound_driver_channel2_check_if_instrument: //check for instrument flag (0xE3)
001a88 f409                      	brne sound_driver_channel2_check_if_release
001a89 c1ac                      	rjmp sound_driver_channel2_instrument_change 
                                 sound_driver_channel2_check_if_release: //check for note release flag (0xE4)
001a8a 3eb4                      	cpi r27, 0xE4
001a8b f409                      	brne sound_driver_channel2_check_if_end
001a8c c255                      	rjmp sound_driver_channel2_release
                                 sound_driver_channel2_check_if_end:
001a8d 3fbf                      	cpi r27, 0xFF
001a8e f409                      	brne sound_driver_channel2_check_if_fx
001a8f c277                      	rjmp sound_driver_channel2_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel2_check_if_fx: //fx flags (0xE5 - 0xFE)
001a90 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001a91 91a4                      	lpm r26, Z //load the fx data into r26
001a92 d296                      	rcall sound_driver_channel2_increment_offset_twice
                                 
001a93 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001a94 efec                      	ldi ZL, LOW(channel2_fx << 1) //load in note table
001a95 e5fb                      	ldi ZH, HIGH(channel2_fx << 1)
001a96 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001a97 0feb                      	add ZL, r27 //add offset
001a98 1df2                      	adc ZH, zero
001a99 91c5                      	lpm r28, Z+ //load address bytes
001a9a 91d4                      	lpm r29, Z
001a9b 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001a9c 2ffd                      	mov ZH, r29
001a9d 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel2_fx_0xy:
001a9e 93a0 28e7                 	sts triangle_fx_0xy_sequence, r26
001aa0 9220 28e8                 	sts triangle_fx_0xy_sequence+1, zero
001aa2 cfd1                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel2_fx_1xx:
001aa3 9220 28ed                 	sts triangle_fx_2xx, zero //turn off any 2xx pitch slide down
001aa5 9220 28ee                 	sts triangle_fx_2xx+1, zero
001aa7 9220 28e7                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001aa9 9220 28e8                 	sts triangle_fx_0xy_sequence+1, zero
001aab 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001aac 937f                      	push r23
001aad 2f6a                      	mov r22, r26 //store the rate into r22
001aae eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001aaf 9f67                      	mul r22, r23
001ab0 917f                      	pop r23
001ab1 916f                      	pop r22
                                 
001ab2 9416                      	lsr r1 //shift out the fractional bits
001ab3 9407                      	ror r0
001ab4 9416                      	lsr r1
001ab5 9407                      	ror r0
001ab6 9416                      	lsr r1
001ab7 9407                      	ror r0
001ab8 9416                      	lsr r1
001ab9 9407                      	ror r0
001aba 9200 28e9                 	sts triangle_fx_1xx, r0
001abc 9210 28ea                 	sts triangle_fx_1xx+1, r1
001abe cfb5                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel2_fx_2xx:
001abf 9220 28e9                 	sts triangle_fx_1xx, zero //turn off any 1xx pitch slide down
001ac1 9220 28ea                 	sts triangle_fx_1xx+1, zero
001ac3 9220 28e7                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001ac5 9220 28e8                 	sts triangle_fx_0xy_sequence+1, zero
001ac7 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001ac8 937f                      	push r23
001ac9 2f6a                      	mov r22, r26 //store the rate into r22
001aca eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001acb 9f67                      	mul r22, r23
001acc 917f                      	pop r23
001acd 916f                      	pop r22
                                 
001ace 9416                      	lsr r1 //shift out the fractional bits
001acf 9407                      	ror r0
001ad0 9416                      	lsr r1
001ad1 9407                      	ror r0
001ad2 9416                      	lsr r1
001ad3 9407                      	ror r0
001ad4 9416                      	lsr r1
001ad5 9407                      	ror r0
001ad6 9200 28ed                 	sts triangle_fx_2xx, r0
001ad8 9210 28ee                 	sts triangle_fx_2xx+1, r1
001ada cf99                      	rjmp sound_driver_channel2_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel2_fx_3xx:
001adb 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001adc 937f                      	push r23
001add 2f6a                      	mov r22, r26 //store the rate into r22
001ade eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001adf 9f67                      	mul r22, r23
001ae0 917f                      	pop r23
001ae1 916f                      	pop r22
                                 
001ae2 9416                      	lsr r1 //shift out the fractional bits
001ae3 9407                      	ror r0
001ae4 9416                      	lsr r1
001ae5 9407                      	ror r0
001ae6 9416                      	lsr r1
001ae7 9407                      	ror r0
001ae8 9416                      	lsr r1
001ae9 9407                      	ror r0
001aea 9200 28f5                 	sts triangle_fx_3xx_speed, r0
001aec 9210 28f6                 	sts triangle_fx_3xx_speed+1, r1
                                 
001aee 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001aef c001                      	rjmp sound_driver_channel2_fx_3xx_enabled
001af0 cf83                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_3xx_enabled:
001af1 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001af3 91b0 0aad                 	lds r27, TCB2_CCMPH
001af5 93a0 28f1                 	sts triangle_fx_3xx_start, r26
001af7 93b0 28f2                 	sts triangle_fx_3xx_start+1, r27
                                 
001af9 9220 28f7                 	sts triangle_fx_3xx_total_offset, zero
001afb 9220 28f8                 	sts triangle_fx_3xx_total_offset+1, zero
001afd cf76                      	rjmp sound_driver_channel2_main
                                 
                                 //VIBRATO
                                 sound_driver_channel2_fx_4xy:
001afe 2fba                      	mov r27, r26
001aff 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001b00 95a2                      	swap r26
001b01 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001b02 93a0 28f9                 	sts triangle_fx_4xy_speed, r26
001b04 93b0 28fa                 	sts triangle_fx_4xy_depth, r27
001b06 9220 28fb                 	sts triangle_fx_4xy_phase, zero //reset the phase to 0
001b08 cf6b                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_7xy: //tremelo
001b09 cf6a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Axy: //volume slide
001b0a cf69                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel2_fx_Bxx:
001b0b 93a0 281f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001b0d cf66                      	rjmp sound_driver_channel2_main
                                 
                                 //HALT
                                 sound_driver_channel2_fx_Cxx:
001b0e 93b0 2820                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001b10 cf63                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel2_fx_Dxx:
001b11 93b0 2821                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001b13 cf60                      	rjmp sound_driver_channel2_main
                                 
                                 //VOLUME
                                 sound_driver_channel2_fx_Exx:
001b14 15a2                      	cp r26, zero
001b15 f021                      	breq sound_driver_channel2_fx_Exx_disable
                                 sound_driver_channel2_fx_Exx_enable:
001b16 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001b17 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001b19 cf5a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Exx_disable:
001b1a 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
001b1c 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
001b1e 9220 0aad                 	sts TCB2_CCMPH, zero
001b20 cf53                      	rjmp sound_driver_channel2_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel2_fx_Fxx:
001b21 93a0 281e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001b23 cf50                      	rjmp sound_driver_channel2_main
                                 
                                 //DELAY
                                 sound_driver_channel2_fx_Gxx:
001b24 15a2                      	cp r26, zero
001b25 f051                      	breq sound_driver_channel2_fx_Gxx_invalid
001b26 91b0 281e                 	lds r27, song_speed
001b28 17ab                      	cp r26, r27
001b29 f430                      	brsh sound_driver_channel2_fx_Gxx_invalid
001b2a 93a0 28fc                 	sts triangle_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001b2c e0b1                      	ldi r27, 0x01
001b2d 93b0 28c6                 	sts triangle_pattern_delay_rows, r27
001b2f c206                      	rjmp sound_driver_channel3
                                 sound_driver_channel2_fx_Gxx_invalid:
001b30 cf43                      	rjmp sound_driver_channel2_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Hxy: //hardware sweep up
001b31 cf42                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixy: //hardware sweep down
001b32 cf41                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Hxx: //FDS modulation depth
001b33 cf40                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixx: //FDS modulation speed
001b34 cf3f                      	rjmp sound_driver_channel2_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel2_fx_Pxx:
001b35 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001b36 937f                      	push r23
001b37 2f6a                      	mov r22, r26
001b38 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001b39 0367                      	mulsu r22, r23
001b3a 917f                      	pop r23
001b3b 916f                      	pop r22
001b3c 9416                      	lsr r1 //shift out the fractional bits
001b3d 9407                      	ror r0
001b3e 9416                      	lsr r1
001b3f 9407                      	ror r0
001b40 9416                      	lsr r1
001b41 9407                      	ror r0
001b42 9416                      	lsr r1
001b43 9407                      	ror r0
001b44 fe13                      	sbrs r1, 3 //check if result was a negative number
001b45 c002                      	rjmp sound_driver_channel2_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel2_fx_Pxx_negative:
001b46 efb0                      	ldi r27, 0xF0
001b47 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel2_fx_Pxx_store:
001b48 9200 28fe                 	sts triangle_fx_Pxx_total, r0
001b4a 9210 28ff                 	sts triangle_fx_Pxx_total+1, r1
001b4c cf27                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel2_fx_Qxy:
                                 sound_driver_channel2_fx_Qxy_check_arpeggio_macro:
001b4d 91e0 28cf                 	lds ZL, triangle_arpeggio_macro
001b4f 91f0 28d0                 	lds ZH, triangle_arpeggio_macro+1
001b51 9630                      	adiw Z, 0
001b52 f009                      	breq sound_driver_channel2_fx_Qxy_check_pitch_macro
001b53 cf20                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_pitch_macro:
001b54 91e0 28d7                 	lds ZL, triangle_pitch_macro
001b56 91f0 28d8                 	lds ZH, triangle_pitch_macro+1
001b58 9630                      	adiw Z, 0
001b59 f009                      	breq sound_driver_channel2_fx_Qxy_check_hi_pitch_macro
001b5a cf19                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_hi_pitch_macro:
001b5b 91e0 28dd                 	lds ZL, triangle_hi_pitch_macro
001b5d 91f0 28de                 	lds ZH, triangle_hi_pitch_macro+1
001b5f 9630                      	adiw Z, 0
001b60 f009                      	breq sound_driver_channel2_fx_Qxy_process
001b61 cf12                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_process:
001b62 2fba                      	mov r27, r26 //copy fx parameters into r27
001b63 70bf                      	andi r27, 0x0F //mask note index offset
001b64 91c0 2900                 	lds r28, triangle_fx_Qxy_target_note //load current note index
001b66 0fbc                      	add r27, r28
001b67 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001b68 f008                      	brlo sound_driver_channel2_fx_Qxy_process_continue
001b69 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel2_fx_Qxy_process_continue:
001b6a 93b0 2900                 	sts triangle_fx_Qxy_target_note, r27
001b6c e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001b6d e0f0                      	ldi ZH, HIGH(note_table << 1)
001b6e 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001b6f 0feb                      	add ZL, r27 //add offset
001b70 1df2                      	adc ZH, zero
001b71 91c5                      	lpm r28, Z+ //load bytes
001b72 91d4                      	lpm r29, Z
001b73 93c0 2901                 	sts triangle_fx_Qxy_target, r28 //load the LOW bits for the target period
001b75 93d0 2902                 	sts triangle_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel2_fx_Qxy_process_speed:
001b77 95a2                      	swap r26
001b78 70af                      	andi r26, 0x0F //mask effect speed
001b79 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001b7a 95a3                      	inc r26 //increment the speed by 1
                                 
001b7b 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001b7c 937f                      	push r23
001b7d 2f6a                      	mov r22, r26 //store the speed data into r27
001b7e eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001b7f 9f67                      	mul r22, r23
001b80 917f                      	pop r23
001b81 916f                      	pop r22
                                 
001b82 9416                      	lsr r1 //shift out the fractional bits
001b83 9407                      	ror r0
001b84 9416                      	lsr r1
001b85 9407                      	ror r0
001b86 9416                      	lsr r1
001b87 9407                      	ror r0
001b88 9416                      	lsr r1
001b89 9407                      	ror r0
                                 
001b8a 9200 2903                 	sts triangle_fx_Qxy_speed, r0 //store the effect speed
001b8c 9210 2904                 	sts triangle_fx_Qxy_speed+1, r1
001b8e cee5                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel2_fx_Rxy:
                                 sound_driver_channel2_fx_Rxy_check_arpeggio_macro:
001b8f 91e0 28cf                 	lds ZL, triangle_arpeggio_macro
001b91 91f0 28d0                 	lds ZH, triangle_arpeggio_macro+1
001b93 9630                      	adiw Z, 0
001b94 f009                      	breq sound_driver_channel2_fx_Rxy_check_pitch_macro
001b95 cede                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_pitch_macro:
001b96 91e0 28d7                 	lds ZL, triangle_pitch_macro
001b98 91f0 28d8                 	lds ZH, triangle_pitch_macro+1
001b9a 9630                      	adiw Z, 0
001b9b f009                      	breq sound_driver_channel2_fx_Rxy_check_hi_pitch_macro
001b9c ced7                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_hi_pitch_macro:
001b9d 91e0 28dd                 	lds ZL, triangle_hi_pitch_macro
001b9f 91f0 28de                 	lds ZH, triangle_hi_pitch_macro+1
001ba1 9630                      	adiw Z, 0
001ba2 f009                      	breq sound_driver_channel2_fx_Rxy_process
001ba3 ced0                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_process:
001ba4 2fba                      	mov r27, r26 //copy fx parameters into r27
001ba5 70bf                      	andi r27, 0x0F //mask note index offset
001ba6 91c0 2907                 	lds r28, triangle_fx_Rxy_target_note //load current note index
001ba8 1bcb                      	sub r28, r27
001ba9 f408                      	brcc sound_driver_channel2_fx_Rxy_process_continue
001baa e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel2_fx_Rxy_process_continue:
001bab 93c0 2907                 	sts triangle_fx_Rxy_target_note, r28
001bad e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001bae e0f0                      	ldi ZH, HIGH(note_table << 1)
001baf 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001bb0 0fec                      	add ZL, r28 //add offset
001bb1 1df2                      	adc ZH, zero
001bb2 91c5                      	lpm r28, Z+ //load bytes
001bb3 91d4                      	lpm r29, Z
001bb4 93c0 2908                 	sts triangle_fx_Rxy_target, r28 //load the LOW bits for the target period
001bb6 93d0 2909                 	sts triangle_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel2_fx_Rxy_process_speed:
001bb8 95a2                      	swap r26
001bb9 70af                      	andi r26, 0x0F //mask effect speed
001bba 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001bbb 95a3                      	inc r26 //increment the speed by 1
                                 
001bbc 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001bbd 937f                      	push r23
001bbe 2f6a                      	mov r22, r26 //store the speed data into r27
001bbf eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001bc0 9f67                      	mul r22, r23
001bc1 917f                      	pop r23
001bc2 916f                      	pop r22
                                 
001bc3 9416                      	lsr r1 //shift out the fractional bits
001bc4 9407                      	ror r0
001bc5 9416                      	lsr r1
001bc6 9407                      	ror r0
001bc7 9416                      	lsr r1
001bc8 9407                      	ror r0
001bc9 9416                      	lsr r1
001bca 9407                      	ror r0
                                 
001bcb 9200 290a                 	sts triangle_fx_Rxy_speed, r0 //store the effect speed
001bcd 9210 290b                 	sts triangle_fx_Rxy_speed+1, r1
001bcf cea4                      	rjmp sound_driver_channel2_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel2_fx_Sxx:
001bd0 15a2                      	cp r26, zero
001bd1 f051                      	breq sound_driver_channel2_fx_Sxx_invalid
001bd2 91b0 281e                 	lds r27, song_speed
001bd4 17ab                      	cp r26, r27
001bd5 f430                      	brsh sound_driver_channel2_fx_Sxx_invalid
001bd6 93a0 290e                 	sts triangle_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001bd8 e0b1                      	ldi r27, 0x01
001bd9 93b0 28c6                 	sts triangle_pattern_delay_rows, r27
001bdb c15a                      	rjmp sound_driver_channel3
                                 sound_driver_channel2_fx_Sxx_invalid:
001bdc ce97                      	rjmp sound_driver_channel2_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Vxx: //duty
001bdd ce96                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Wxx: //DPCM sample speed
001bde ce95                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Xxx: //DPCM sample retrigger
001bdf ce94                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Yxx: //DPCM sample offset
001be0 ce93                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Zxx: //DPCM sample delta counter
001be1 ce92                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 sound_driver_channel2_note:
001be2 93b0 2812                 	sts triangle_note, r27 //store the note index
001be4 93b0 2900                 	sts triangle_fx_Qxy_target_note, r27
001be6 93b0 2907                 	sts triangle_fx_Rxy_target_note, r27
001be8 e0a3                      	ldi r26, 0x03
001be9 e0b2                      	ldi r27, 0x02
001bea 93b0 28cc                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
001bec 93a0 28d1                 	sts triangle_arpeggio_macro_offset, r26
001bee 93b0 28d9                 	sts triangle_pitch_macro_offset, r27
001bf0 93b0 28df                 	sts triangle_hi_pitch_macro_offset, r27
001bf2 93b0 28e4                 	sts triangle_duty_macro_offset, r27
001bf4 9220 28d5                 	sts triangle_total_pitch_offset, zero //reset the pitch and hi pitch offset
001bf6 9220 28d6                 	sts triangle_total_pitch_offset+1, zero
001bf8 9220 28dc                 	sts triangle_total_hi_pitch_offset, zero
001bfa 9220 28eb                 	sts triangle_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001bfc 9220 28ec                 	sts triangle_fx_1xx_total+1, zero
001bfe 9220 28ef                 	sts triangle_fx_2xx_total, zero
001c00 9220 28f0                 	sts triangle_fx_2xx_total+1, zero
001c02 9220 28f7                 	sts triangle_fx_3xx_total_offset, zero //reset 3xx offset
001c04 9220 28f8                 	sts triangle_fx_3xx_total_offset+1, zero
001c06 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001c08 91b0 0aad                 	lds r27, TCB2_CCMPH
001c0a 93a0 28f1                 	sts triangle_fx_3xx_start, r26
001c0c 93b0 28f2                 	sts triangle_fx_3xx_start+1, r27
001c0e 9220 2901                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001c10 9220 2902                 	sts triangle_fx_Qxy_target+1, zero
001c12 9220 2905                 	sts triangle_fx_Qxy_total_offset, zero
001c14 9220 2906                 	sts triangle_fx_Qxy_total_offset+1, zero
001c16 9220 2908                 	sts triangle_fx_Rxy_target, zero
001c18 9220 2909                 	sts triangle_fx_Rxy_target+1, zero
001c1a 9220 290c                 	sts triangle_fx_Rxy_total_offset, zero
001c1c 9220 290d                 	sts triangle_fx_Rxy_total_offset+1, zero
001c1e e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001c1f 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001c21 d0fd                      	rcall sound_driver_channel2_increment_offset
001c22 ce51                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_volume:
001c23 d0fb                      	rcall sound_driver_channel2_increment_offset
001c24 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001c25 f021                      	breq sound_driver_channel2_volume_disable
                                 sound_driver_channel2_volume_enable:
001c26 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001c27 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001c29 ce4a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_volume_disable:
001c2a 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
001c2c 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
001c2e 9220 0aad                 	sts TCB2_CCMPH, zero
001c30 ce43                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_delay:
001c31 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001c32 93b0 28c6                 	sts triangle_pattern_delay_rows, r27
001c34 d0ea                      	rcall sound_driver_channel2_increment_offset
001c35 c100                      	rjmp sound_driver_channel3
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change:
001c36 9220 28ca                 	sts triangle_volume_macro, zero //reset all macro addresses
001c38 9220 28cb                 	sts triangle_volume_macro+1, zero
001c3a 9220 28cf                 	sts triangle_arpeggio_macro, zero
001c3c 9220 28d0                 	sts triangle_arpeggio_macro+1, zero
001c3e 9220 28d7                 	sts triangle_pitch_macro, zero
001c40 9220 28d8                 	sts triangle_pitch_macro+1, zero
001c42 9220 28dd                 	sts triangle_hi_pitch_macro, zero
001c44 9220 28de                 	sts triangle_hi_pitch_macro+1, zero
001c46 9220 28e2                 	sts triangle_duty_macro, zero
001c48 9220 28e3                 	sts triangle_duty_macro+1, zero
001c4a 9220 28d5                 	sts triangle_total_pitch_offset, zero //reset the pitch offset
001c4c 9220 28d6                 	sts triangle_total_pitch_offset+1, zero
001c4e 9220 28dc                 	sts triangle_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001c50 9631                      	adiw Z, 1 //point to the byte next to the flag
001c51 91b4                      	lpm r27, Z //store the instrument offset into r27
001c52 e2ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
001c53 e0fd                      	ldi ZH, HIGH(instruments)
001c54 0feb                      	add ZL, r27 //point Z to offsetted instrument
001c55 1df2                      	adc ZH, zero
001c56 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001c57 1fff                      	rol ZH
001c58 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001c59 91b4                      	lpm r27, Z
                                 
001c5a 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001c5b 1fbb                      	rol r27
001c5c 2fea                      	mov ZL, r26
001c5d 2ffb                      	mov ZH, r27
001c5e 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001c5f 9632                      	adiw Z, 2 //point Z to the address of the macro
001c60 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel2_instrument_change_macro_loop:
001c61 95aa                      	dec r26
001c62 f019                      	breq sound_driver_channel2_instrument_change_exit
001c63 95b6                      	lsr r27
001c64 f078                      	brcs sound_driver_channel2_instrument_change_load_macro
001c65 cffb                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_exit:
001c66 e0a3                      	ldi r26, 0x03
001c67 e0b2                      	ldi r27, 0x02
001c68 93b0 28cc                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
001c6a 93a0 28d1                 	sts triangle_arpeggio_macro_offset, r26
001c6c 93b0 28d9                 	sts triangle_pitch_macro_offset, r27
001c6e 93b0 28df                 	sts triangle_hi_pitch_macro_offset, r27
001c70 93b0 28e4                 	sts triangle_duty_macro_offset, r27
001c72 d0b6                      	rcall sound_driver_channel2_increment_offset_twice
001c73 ce00                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_load_macro:
001c74 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001c75 91d5                      	lpm r29, Z+
                                 
001c76 30a5                      	cpi r26, 5
001c77 f039                      	breq sound_driver_channel2_instrument_change_load_macro_volume
001c78 30a4                      	cpi r26, 4
001c79 f079                      	breq sound_driver_channel2_instrument_change_load_macro_arpeggio
001c7a 30a3                      	cpi r26, 3
001c7b f0d9                      	breq sound_driver_channel2_instrument_change_load_macro_pitch
001c7c 30a2                      	cpi r26, 2
001c7d f159                      	breq sound_driver_channel2_instrument_change_load_macro_hi_pitch
001c7e c03c                      	rjmp sound_driver_channel2_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel2_instrument_change_load_macro_volume:
001c7f 93c0 28ca                 	sts triangle_volume_macro, r28
001c81 93d0 28cb                 	sts triangle_volume_macro+1, r29
001c83 d041                      	rcall sound_driver_channel2_instrument_change_read_header
001c84 93c0 28ce                 	sts triangle_volume_macro_release, r28
001c86 93d0 28cd                 	sts triangle_volume_macro_loop, r29
001c88 cfd8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 	
                                 sound_driver_channel2_instrument_change_load_macro_arpeggio:
001c89 93c0 28cf                 	sts triangle_arpeggio_macro, r28
001c8b 93d0 28d0                 	sts triangle_arpeggio_macro+1, r29
001c8d 9220 2901                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001c8f 9220 2902                 	sts triangle_fx_Qxy_target+1, zero
001c91 9220 2908                 	sts triangle_fx_Rxy_target, zero
001c93 9220 2909                 	sts triangle_fx_Rxy_target+1, zero
001c95 d03a                      	rcall sound_driver_channel2_instrument_change_read_header_arpeggio
001c96 cfca                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_pitch:
001c97 93c0 28d7                 	sts triangle_pitch_macro, r28
001c99 93d0 28d8                 	sts triangle_pitch_macro+1, r29
001c9b 9220 2901                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001c9d 9220 2902                 	sts triangle_fx_Qxy_target+1, zero
001c9f 9220 2908                 	sts triangle_fx_Rxy_target, zero
001ca1 9220 2909                 	sts triangle_fx_Rxy_target+1, zero
001ca3 d021                      	rcall sound_driver_channel2_instrument_change_read_header
001ca4 93c0 28db                 	sts triangle_pitch_macro_release, r28
001ca6 93d0 28da                 	sts triangle_pitch_macro_loop, r29
001ca8 cfb8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_hi_pitch:
001ca9 93c0 28dd                 	sts triangle_hi_pitch_macro, r28
001cab 93d0 28de                 	sts triangle_hi_pitch_macro+1, r29
001cad 9220 2901                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001caf 9220 2902                 	sts triangle_fx_Qxy_target+1, zero
001cb1 9220 2908                 	sts triangle_fx_Rxy_target, zero
001cb3 9220 2909                 	sts triangle_fx_Rxy_target+1, zero
001cb5 d00f                      	rcall sound_driver_channel2_instrument_change_read_header
001cb6 93c0 28e1                 	sts triangle_hi_pitch_macro_release, r28
001cb8 93d0 28e0                 	sts triangle_hi_pitch_macro_loop, r29
001cba cfa6                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_duty:
001cbb 93c0 28e2                 	sts triangle_duty_macro, r28
001cbd 93d0 28e3                 	sts triangle_duty_macro+1, r29
001cbf d005                      	rcall sound_driver_channel2_instrument_change_read_header
001cc0 93c0 28e6                 	sts triangle_duty_macro_release, r28
001cc2 93d0 28e5                 	sts triangle_duty_macro_loop, r29
001cc4 cf9c                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_read_header:
001cc5 93ef                      	push ZL
001cc6 93ff                      	push ZH
001cc7 2fec                      	mov ZL, r28
001cc8 2ffd                      	mov ZH, r29
001cc9 0fee                      	lsl ZL
001cca 1fff                      	rol ZH
001ccb 91c5                      	lpm r28, Z+
001ccc 91d4                      	lpm r29, Z
001ccd 91ff                      	pop ZH
001cce 91ef                      	pop ZL
001ccf 9508                      	ret
                                 
                                 sound_driver_channel2_instrument_change_read_header_arpeggio:
001cd0 93ef                      	push ZL
001cd1 93ff                      	push ZH
001cd2 2fec                      	mov ZL, r28
001cd3 2ffd                      	mov ZH, r29
001cd4 0fee                      	lsl ZL
001cd5 1fff                      	rol ZH
001cd6 91c5                      	lpm r28, Z+
001cd7 91d5                      	lpm r29, Z+
001cd8 93c0 28d3                 	sts triangle_arpeggio_macro_release, r28
001cda 93d0 28d2                 	sts triangle_arpeggio_macro_loop, r29
001cdc 91c4                      	lpm r28, Z
001cdd 93c0 28d4                 	sts triangle_arpeggio_macro_mode, r28
001cdf 91ff                      	pop ZH
001ce0 91ef                      	pop ZL
001ce1 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel2_release:
                                 sound_driver_channel2_release_volume:
001ce2 91b0 28ce                 	lds r27, triangle_volume_macro_release
001ce4 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001ce5 f019                      	breq sound_driver_channel2_release_arpeggio //if the macro has no release flag, check the next macro
001ce6 95b3                      	inc r27
001ce7 93b0 28cc                 	sts triangle_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel2_release_arpeggio:
001ce9 91b0 28d3                 	lds r27, triangle_arpeggio_macro_release
001ceb 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001cec f019                      	breq sound_driver_channel2_release_pitch
001ced 95b3                      	inc r27
001cee 93b0 28d1                 	sts triangle_arpeggio_macro_offset, r27
                                 sound_driver_channel2_release_pitch:
001cf0 91b0 28db                 	lds r27, triangle_pitch_macro_release
001cf2 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001cf3 f019                      	breq sound_driver_channel2_release_hi_pitch
001cf4 95b3                      	inc r27
001cf5 93b0 28d9                 	sts triangle_pitch_macro_offset, r27
                                 sound_driver_channel2_release_hi_pitch:
001cf7 91b0 28e1                 	lds r27, triangle_hi_pitch_macro_release
001cf9 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001cfa f019                      	breq sound_driver_channel2_release_duty
001cfb 95b3                      	inc r27
001cfc 93b0 28df                 	sts triangle_hi_pitch_macro_offset, r27
                                 sound_driver_channel2_release_duty:
001cfe 91b0 28e6                 	lds r27, triangle_duty_macro_release
001d00 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001d01 f019                      	breq sound_driver_channel2_release_exit
001d02 95b3                      	inc r27
001d03 93b0 28e4                 	sts triangle_duty_macro_offset, r27
                                 sound_driver_channel2_release_exit:
001d05 d019                      	rcall sound_driver_channel2_increment_offset
001d06 cd6d                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_next_pattern:
001d07 91e0 2818                 	lds ZL, song_frames
001d09 91f0 2819                 	lds ZH, song_frames+1
001d0b 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001d0d 91b0 281b                 	lds r27, song_frame_offset+1
001d0f 9614                      	adiw r27:r26, 4 //offset for channel 2
001d10 0fea                      	add ZL, r26
001d11 1ffb                      	adc ZH, r27
                                 
001d12 91a5                      	lpm r26, Z+ //load the address of the next pattern
001d13 91b4                      	lpm r27, Z
001d14 0faa                      	lsl r26
001d15 1fbb                      	rol r27
001d16 93a0 28c4                 	sts triangle_pattern, r26
001d18 93b0 28c5                 	sts triangle_pattern+1, r27
                                 
001d1a 9220 28c8                 	sts triangle_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001d1c 9220 28c9                 	sts triangle_pattern_offset+1, zero
001d1e cd55                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_increment_offset:
001d1f 91e0 28c8                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
001d21 91f0 28c9                 	lds ZH, triangle_pattern_offset+1
001d23 9631                      	adiw Z, 1
001d24 93e0 28c8                 	sts triangle_pattern_offset, ZL
001d26 93f0 28c9                 	sts triangle_pattern_offset+1, ZH
001d28 9508                      	ret
                                 
                                 sound_driver_channel2_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001d29 91e0 28c8                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
001d2b 91f0 28c9                 	lds ZH, triangle_pattern_offset+1
001d2d 9632                      	adiw Z, 2 //increment the pointer twice
001d2e 93e0 28c8                 	sts triangle_pattern_offset, ZL
001d30 93f0 28c9                 	sts triangle_pattern_offset+1, ZH
001d32 9508                      	ret
                                 
                                 sound_driver_channel2_decrement_frame_delay:
001d33 95ba                      	dec r27
001d34 93b0 28c7                 	sts triangle_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel3:
001d36 91a0 2912                 	lds r26, noise_pattern_delay_rows
001d38 91b0 2913                 	lds r27, noise_pattern_delay_frames
001d3a 9610                      	adiw r27:r26, 0
001d3b f009                      	breq sound_driver_channel3_main //if the pattern delay is 0, proceed with sound driver procedures
001d3c c2cd                      	rjmp sound_driver_channel3_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel3_main:
001d3d 91e0 2910                 	lds ZL, noise_pattern //current pattern for noise
001d3f 91f0 2911                 	lds ZH, noise_pattern+1
001d41 91a0 2914                 	lds r26, noise_pattern_offset //current offset in the pattern for noise
001d43 91b0 2915                 	lds r27, noise_pattern_offset+1
001d45 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001d46 1ffb                      	adc ZH, r27
001d47 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel3_check_if_note: //check if data is a note (0x00 - 0x56)
001d48 35b7                      	cpi r27, 0x57
001d49 f408                      	brsh sound_driver_channel3_check_if_volume
001d4a c172                      	rjmp sound_driver_channel3_note
                                 sound_driver_channel3_check_if_volume: //check if data is volume (0x57-0x66)
001d4b 36b7                      	cpi r27, 0x67
001d4c f408                      	brsh sound_driver_channel3_check_if_delay
001d4d c1ad                      	rjmp sound_driver_channel3_volume
                                 sound_driver_channel3_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001d4e 3eb3                      	cpi r27, 0xE3
001d4f f408                      	brsh sound_driver_channel3_check_if_instrument
001d50 c1b3                      	rjmp sound_driver_channel3_delay
                                 sound_driver_channel3_check_if_instrument: //check for instrument flag (0xE3)
001d51 f409                      	brne sound_driver_channel3_check_if_release
001d52 c1b6                      	rjmp sound_driver_channel3_instrument_change 
                                 sound_driver_channel3_check_if_release: //check for note release flag (0xE4)
001d53 3eb4                      	cpi r27, 0xE4
001d54 f409                      	brne sound_driver_channel3_check_if_end
001d55 c25f                      	rjmp sound_driver_channel3_release
                                 sound_driver_channel3_check_if_end:
001d56 3fbf                      	cpi r27, 0xFF
001d57 f409                      	brne sound_driver_channel3_check_if_fx
001d58 c281                      	rjmp sound_driver_channel3_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel3_check_if_fx: //fx flags (0xE5 - 0xFE)
001d59 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001d5a 91a4                      	lpm r26, Z //load the fx data into r26
001d5b d2a4                      	rcall sound_driver_channel3_increment_offset_twice
                                 
001d5c 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001d5d e3e0                      	ldi ZL, LOW(channel3_fx << 1) //load in note table
001d5e e5fc                      	ldi ZH, HIGH(channel3_fx << 1)
001d5f 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001d60 0feb                      	add ZL, r27 //add offset
001d61 1df2                      	adc ZH, zero
001d62 91c5                      	lpm r28, Z+ //load address bytes
001d63 91d4                      	lpm r29, Z
001d64 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001d65 2ffd                      	mov ZH, r29
001d66 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel3_fx_0xy:
001d67 93a0 2933                 	sts noise_fx_0xy_sequence, r26
001d69 9220 2934                 	sts noise_fx_0xy_sequence+1, zero
001d6b cfd1                      	rjmp sound_driver_channel3_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel3_fx_1xx:
001d6c 9220 2939                 	sts noise_fx_2xx, zero //turn off any 2xx pitch slide down
001d6e 9220 293a                 	sts noise_fx_2xx+1, zero
001d70 9220 2933                 	sts noise_fx_0xy_sequence, zero //disable any 0xy effect
001d72 9220 2934                 	sts noise_fx_0xy_sequence+1, zero
001d74 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001d75 937f                      	push r23
001d76 2f6a                      	mov r22, r26 //store the rate into r22
001d77 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001d78 9f67                      	mul r22, r23
001d79 917f                      	pop r23
001d7a 916f                      	pop r22
                                 
001d7b 9416                      	lsr r1 //shift out the fractional bits
001d7c 9407                      	ror r0
001d7d 9416                      	lsr r1
001d7e 9407                      	ror r0
001d7f 9416                      	lsr r1
001d80 9407                      	ror r0
001d81 9416                      	lsr r1
001d82 9407                      	ror r0
001d83 9200 2935                 	sts noise_fx_1xx, r0
001d85 9210 2936                 	sts noise_fx_1xx+1, r1
001d87 cfb5                      	rjmp sound_driver_channel3_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel3_fx_2xx:
001d88 9220 2935                 	sts noise_fx_1xx, zero //turn off any 1xx pitch slide down
001d8a 9220 2936                 	sts noise_fx_1xx+1, zero
001d8c 9220 2933                 	sts noise_fx_0xy_sequence, zero //disable any 0xy effect
001d8e 9220 2934                 	sts noise_fx_0xy_sequence+1, zero
001d90 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001d91 937f                      	push r23
001d92 2f6a                      	mov r22, r26 //store the rate into r22
001d93 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001d94 9f67                      	mul r22, r23
001d95 917f                      	pop r23
001d96 916f                      	pop r22
                                 
001d97 9416                      	lsr r1 //shift out the fractional bits
001d98 9407                      	ror r0
001d99 9416                      	lsr r1
001d9a 9407                      	ror r0
001d9b 9416                      	lsr r1
001d9c 9407                      	ror r0
001d9d 9416                      	lsr r1
001d9e 9407                      	ror r0
001d9f 9200 2939                 	sts noise_fx_2xx, r0
001da1 9210 293a                 	sts noise_fx_2xx+1, r1
001da3 cf99                      	rjmp sound_driver_channel3_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel3_fx_3xx:
001da4 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001da5 937f                      	push r23
001da6 2f6a                      	mov r22, r26 //store the rate into r22
001da7 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001da8 9f67                      	mul r22, r23
001da9 917f                      	pop r23
001daa 916f                      	pop r22
                                 
001dab 9416                      	lsr r1 //shift out the fractional bits
001dac 9407                      	ror r0
001dad 9416                      	lsr r1
001dae 9407                      	ror r0
001daf 9416                      	lsr r1
001db0 9407                      	ror r0
001db1 9416                      	lsr r1
001db2 9407                      	ror r0
001db3 9200 2941                 	sts noise_fx_3xx_speed, r0
001db5 9210 2942                 	sts noise_fx_3xx_speed+1, r1
                                 
001db7 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001db8 c001                      	rjmp sound_driver_channel3_fx_3xx_enabled
001db9 cf83                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_3xx_enabled:
001dba 91a0 0abc                 	lds r26, TCB3_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001dbc 91b0 0abd                 	lds r27, TCB3_CCMPH
001dbe 93a0 293d                 	sts noise_fx_3xx_start, r26
001dc0 93b0 293e                 	sts noise_fx_3xx_start+1, r27
                                 
001dc2 9220 2943                 	sts noise_fx_3xx_total_offset, zero
001dc4 9220 2944                 	sts noise_fx_3xx_total_offset+1, zero
001dc6 cf76                      	rjmp sound_driver_channel3_main
                                 
                                 //VIBRATO
                                 sound_driver_channel3_fx_4xy:
001dc7 2fba                      	mov r27, r26
001dc8 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001dc9 95a2                      	swap r26
001dca 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001dcb 93a0 2945                 	sts noise_fx_4xy_speed, r26
001dcd 93b0 2946                 	sts noise_fx_4xy_depth, r27
001dcf 9220 2947                 	sts noise_fx_4xy_phase, zero //reset the phase to 0
001dd1 cf6b                      	rjmp sound_driver_channel3_main
                                 
                                 //TREMELO
                                 sound_driver_channel3_fx_7xy:
001dd2 2fba                      	mov r27, r26
001dd3 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001dd4 95a2                      	swap r26
001dd5 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001dd6 93a0 2948                 	sts noise_fx_7xy_speed, r26
001dd8 93b0 2949                 	sts noise_fx_7xy_depth, r27
001dda 9220 294a                 	sts noise_fx_7xy_phase, zero //reset the phase to 0
001ddc 9220 294b                 	sts noise_fx_7xy_value, zero //reset the tremelo value
001dde cf5e                      	rjmp sound_driver_channel3_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel3_fx_Axy:
001ddf 93a0 294c                 	sts noise_fx_Axy, r26
001de1 cf5b                      	rjmp sound_driver_channel3_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel3_fx_Bxx:
001de2 93a0 281f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001de4 cf58                      	rjmp sound_driver_channel3_main
                                 
                                 //HALT
                                 sound_driver_channel3_fx_Cxx:
001de5 93b0 2820                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001de7 cf55                      	rjmp sound_driver_channel3_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel3_fx_Dxx:
001de8 93b0 2821                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001dea cf52                      	rjmp sound_driver_channel3_main
                                 
                                 //VOLUME
                                 sound_driver_channel3_fx_Exx:
001deb 91b0 2813                 	lds r27, noise_param
001ded 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
001dee 2bba                      	or r27, r26 //move new VVVV bits into noise_param
001def 93b0 2813                 	sts noise_param, r27
001df1 cf4b                      	rjmp sound_driver_channel3_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel3_fx_Fxx:
001df2 93a0 281e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001df4 cf48                      	rjmp sound_driver_channel3_main
                                 
                                 //DELAY
                                 sound_driver_channel3_fx_Gxx:
001df5 15a2                      	cp r26, zero
001df6 f051                      	breq sound_driver_channel3_fx_Gxx_invalid
001df7 91b0 281e                 	lds r27, song_speed
001df9 17ab                      	cp r26, r27
001dfa f430                      	brsh sound_driver_channel3_fx_Gxx_invalid
001dfb 93a0 294d                 	sts noise_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001dfd e0b1                      	ldi r27, 0x01
001dfe 93b0 2912                 	sts noise_pattern_delay_rows, r27
001e00 c20c                      	rjmp sound_driver_channel4
                                 sound_driver_channel3_fx_Gxx_invalid:
001e01 cf3b                      	rjmp sound_driver_channel3_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel3_fx_Hxy: //hardware sweep up
001e02 cf3a                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Ixy: //hardware sweep down
001e03 cf39                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Hxx: //FDS modulation depth
001e04 cf38                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Ixx: //FDS modulation speed
001e05 cf37                      	rjmp sound_driver_channel3_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel3_fx_Pxx:
001e06 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001e07 937f                      	push r23
001e08 2f6a                      	mov r22, r26
001e09 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001e0a 0367                      	mulsu r22, r23
001e0b 917f                      	pop r23
001e0c 916f                      	pop r22
001e0d 9416                      	lsr r1 //shift out the fractional bits
001e0e 9407                      	ror r0
001e0f 9416                      	lsr r1
001e10 9407                      	ror r0
001e11 9416                      	lsr r1
001e12 9407                      	ror r0
001e13 9416                      	lsr r1
001e14 9407                      	ror r0
001e15 fe13                      	sbrs r1, 3 //check if result was a negative number
001e16 c002                      	rjmp sound_driver_channel3_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel3_fx_Pxx_negative:
001e17 efb0                      	ldi r27, 0xF0
001e18 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel3_fx_Pxx_store:
001e19 9200 294f                 	sts noise_fx_Pxx_total, r0
001e1b 9210 2950                 	sts noise_fx_Pxx_total+1, r1
001e1d cf1f                      	rjmp sound_driver_channel3_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel3_fx_Qxy:
                                 sound_driver_channel3_fx_Qxy_check_arpeggio_macro:
001e1e 91e0 291b                 	lds ZL, noise_arpeggio_macro
001e20 91f0 291c                 	lds ZH, noise_arpeggio_macro+1
001e22 9630                      	adiw Z, 0
001e23 f009                      	breq sound_driver_channel3_fx_Qxy_check_pitch_macro
001e24 cf18                      	rjmp sound_driver_channel3_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Qxy_check_pitch_macro:
001e25 91e0 2923                 	lds ZL, noise_pitch_macro
001e27 91f0 2924                 	lds ZH, noise_pitch_macro+1
001e29 9630                      	adiw Z, 0
001e2a f009                      	breq sound_driver_channel3_fx_Qxy_check_hi_pitch_macro
001e2b cf11                      	rjmp sound_driver_channel3_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Qxy_check_hi_pitch_macro:
001e2c 91e0 2929                 	lds ZL, noise_hi_pitch_macro
001e2e 91f0 292a                 	lds ZH, noise_hi_pitch_macro+1
001e30 9630                      	adiw Z, 0
001e31 f009                      	breq sound_driver_channel3_fx_Qxy_process
001e32 cf0a                      	rjmp sound_driver_channel3_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Qxy_process:
001e33 2fba                      	mov r27, r26 //copy fx parameters into r27
001e34 70bf                      	andi r27, 0x0F //mask note index offset
001e35 91c0 2951                 	lds r28, noise_fx_Qxy_target_note //load current note index
001e37 0fbc                      	add r27, r28
001e38 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001e39 f008                      	brlo sound_driver_channel3_fx_Qxy_process_continue
001e3a e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel3_fx_Qxy_process_continue:
001e3b 93b0 2951                 	sts noise_fx_Qxy_target_note, r27
001e3d e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001e3e e0f0                      	ldi ZH, HIGH(note_table << 1)
001e3f 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001e40 0feb                      	add ZL, r27 //add offset
001e41 1df2                      	adc ZH, zero
001e42 91c5                      	lpm r28, Z+ //load bytes
001e43 91d4                      	lpm r29, Z
001e44 93c0 2952                 	sts noise_fx_Qxy_target, r28 //load the LOW bits for the target period
001e46 93d0 2953                 	sts noise_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel3_fx_Qxy_process_speed:
001e48 95a2                      	swap r26
001e49 70af                      	andi r26, 0x0F //mask effect speed
001e4a 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001e4b 95a3                      	inc r26 //increment the speed by 1
                                 
001e4c 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001e4d 937f                      	push r23
001e4e 2f6a                      	mov r22, r26 //store the speed data into r27
001e4f eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001e50 9f67                      	mul r22, r23
001e51 917f                      	pop r23
001e52 916f                      	pop r22
                                 
001e53 9416                      	lsr r1 //shift out the fractional bits
001e54 9407                      	ror r0
001e55 9416                      	lsr r1
001e56 9407                      	ror r0
001e57 9416                      	lsr r1
001e58 9407                      	ror r0
001e59 9416                      	lsr r1
001e5a 9407                      	ror r0
                                 
001e5b 9200 2954                 	sts noise_fx_Qxy_speed, r0 //store the effect speed
001e5d 9210 2955                 	sts noise_fx_Qxy_speed+1, r1
001e5f cedd                      	rjmp sound_driver_channel3_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel3_fx_Rxy:
                                 sound_driver_channel3_fx_Rxy_check_arpeggio_macro:
001e60 91e0 291b                 	lds ZL, noise_arpeggio_macro
001e62 91f0 291c                 	lds ZH, noise_arpeggio_macro+1
001e64 9630                      	adiw Z, 0
001e65 f009                      	breq sound_driver_channel3_fx_Rxy_check_pitch_macro
001e66 ced6                      	rjmp sound_driver_channel3_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Rxy_check_pitch_macro:
001e67 91e0 2923                 	lds ZL, noise_pitch_macro
001e69 91f0 2924                 	lds ZH, noise_pitch_macro+1
001e6b 9630                      	adiw Z, 0
001e6c f009                      	breq sound_driver_channel3_fx_Rxy_check_hi_pitch_macro
001e6d cecf                      	rjmp sound_driver_channel3_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Rxy_check_hi_pitch_macro:
001e6e 91e0 2929                 	lds ZL, noise_hi_pitch_macro
001e70 91f0 292a                 	lds ZH, noise_hi_pitch_macro+1
001e72 9630                      	adiw Z, 0
001e73 f009                      	breq sound_driver_channel3_fx_Rxy_process
001e74 cec8                      	rjmp sound_driver_channel3_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Rxy_process:
001e75 2fba                      	mov r27, r26 //copy fx parameters into r27
001e76 70bf                      	andi r27, 0x0F //mask note index offset
001e77 91c0 2958                 	lds r28, noise_fx_Rxy_target_note //load current note index
001e79 1bcb                      	sub r28, r27
001e7a f408                      	brcc sound_driver_channel3_fx_Rxy_process_continue
001e7b e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel3_fx_Rxy_process_continue:
001e7c 93c0 2958                 	sts noise_fx_Rxy_target_note, r28
001e7e e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001e7f e0f0                      	ldi ZH, HIGH(note_table << 1)
001e80 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001e81 0fec                      	add ZL, r28 //add offset
001e82 1df2                      	adc ZH, zero
001e83 91c5                      	lpm r28, Z+ //load bytes
001e84 91d4                      	lpm r29, Z
001e85 93c0 2959                 	sts noise_fx_Rxy_target, r28 //load the LOW bits for the target period
001e87 93d0 295a                 	sts noise_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel3_fx_Rxy_process_speed:
001e89 95a2                      	swap r26
001e8a 70af                      	andi r26, 0x0F //mask effect speed
001e8b 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001e8c 95a3                      	inc r26 //increment the speed by 1
                                 
001e8d 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001e8e 937f                      	push r23
001e8f 2f6a                      	mov r22, r26 //store the speed data into r27
001e90 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001e91 9f67                      	mul r22, r23
001e92 917f                      	pop r23
001e93 916f                      	pop r22
                                 
001e94 9416                      	lsr r1 //shift out the fractional bits
001e95 9407                      	ror r0
001e96 9416                      	lsr r1
001e97 9407                      	ror r0
001e98 9416                      	lsr r1
001e99 9407                      	ror r0
001e9a 9416                      	lsr r1
001e9b 9407                      	ror r0
                                 
001e9c 9200 295b                 	sts noise_fx_Rxy_speed, r0 //store the effect speed
001e9e 9210 295c                 	sts noise_fx_Rxy_speed+1, r1
001ea0 ce9c                      	rjmp sound_driver_channel3_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel3_fx_Sxx:
001ea1 15a2                      	cp r26, zero
001ea2 f051                      	breq sound_driver_channel3_fx_Sxx_invalid
001ea3 91b0 281e                 	lds r27, song_speed
001ea5 17ab                      	cp r26, r27
001ea6 f430                      	brsh sound_driver_channel3_fx_Sxx_invalid
001ea7 93a0 295f                 	sts noise_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001ea9 e0b1                      	ldi r27, 0x01
001eaa 93b0 2912                 	sts noise_pattern_delay_rows, r27
001eac c160                      	rjmp sound_driver_channel4
                                 sound_driver_channel3_fx_Sxx_invalid:
001ead ce8f                      	rjmp sound_driver_channel3_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel3_fx_Vxx:
001eae 95a6                      	lsr r26
001eaf 95a7                      	ror r26 //move mode bit to bit 7
001eb0 91b0 2814                 	lds r27, noise_period
001eb2 77bf                      	andi r27, 0b01111111
001eb3 2bba                      	or r27, r26 //store the new noise mode
001eb4 93b0 2813                 	sts noise_param, r27
                                 
001eb6 776f                      	andi noise_sequence_HIGH, 0b01111111
001eb7 2b6a                      	or noise_sequence_HIGH, r26
001eb8 ce84                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_Wxx: //DPCM sample speed
001eb9 ce83                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Xxx: //DPCM sample retrigger
001eba ce82                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Yxx: //DPCM sample offset
001ebb ce81                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Zxx: //DPCM sample delta counter
001ebc ce80                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 sound_driver_channel3_note:
001ebd 93b0 2817                 	sts noise_note, r27 //store the note index
001ebf 93b0 2951                 	sts noise_fx_Qxy_target_note, r27
001ec1 93b0 2958                 	sts noise_fx_Rxy_target_note, r27
001ec3 e0a3                      	ldi r26, 0x03
001ec4 e0b2                      	ldi r27, 0x02
001ec5 93b0 2918                 	sts noise_volume_macro_offset, r27 //reset all macro offsets
001ec7 93a0 291d                 	sts noise_arpeggio_macro_offset, r26
001ec9 93b0 2925                 	sts noise_pitch_macro_offset, r27
001ecb 93b0 292b                 	sts noise_hi_pitch_macro_offset, r27
001ecd 93b0 2930                 	sts noise_duty_macro_offset, r27
001ecf 9220 2921                 	sts noise_total_pitch_offset, zero //reset the pitch and hi pitch offset
001ed1 9220 2922                 	sts noise_total_pitch_offset+1, zero
001ed3 9220 2928                 	sts noise_total_hi_pitch_offset, zero
001ed5 9220 2937                 	sts noise_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001ed7 9220 2938                 	sts noise_fx_1xx_total+1, zero
001ed9 9220 293b                 	sts noise_fx_2xx_total, zero
001edb 9220 293c                 	sts noise_fx_2xx_total+1, zero
001edd 9220 2943                 	sts noise_fx_3xx_total_offset, zero //reset 3xx offset
001edf 9220 2944                 	sts noise_fx_3xx_total_offset+1, zero
001ee1 91a0 0abc                 	lds r26, TCB3_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001ee3 91b0 0abd                 	lds r27, TCB3_CCMPH
001ee5 93a0 293d                 	sts noise_fx_3xx_start, r26
001ee7 93b0 293e                 	sts noise_fx_3xx_start+1, r27
001ee9 9220 2952                 	sts noise_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001eeb 9220 2953                 	sts noise_fx_Qxy_target+1, zero
001eed 9220 2956                 	sts noise_fx_Qxy_total_offset, zero
001eef 9220 2957                 	sts noise_fx_Qxy_total_offset+1, zero
001ef1 9220 2959                 	sts noise_fx_Rxy_target, zero
001ef3 9220 295a                 	sts noise_fx_Rxy_target+1, zero
001ef5 9220 295d                 	sts noise_fx_Rxy_total_offset, zero
001ef7 9220 295e                 	sts noise_fx_Rxy_total_offset+1, zero
001ef9 d0fc                      	rcall sound_driver_channel3_increment_offset
001efa ce42                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_volume:
001efb 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001efc 91a0 2813                 	lds r26, noise_param
001efe 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001eff 2bab                      	or r26, r27 //move new VVVV bits into noise_param
001f00 93a0 2813                 	sts noise_param, r26
001f02 d0f3                      	rcall sound_driver_channel3_increment_offset
001f03 ce39                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_delay:
001f04 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001f05 93b0 2912                 	sts noise_pattern_delay_rows, r27
001f07 d0ee                      	rcall sound_driver_channel3_increment_offset
001f08 c104                      	rjmp sound_driver_channel4
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change:
001f09 9220 2916                 	sts noise_volume_macro, zero //reset all macro addresses
001f0b 9220 2917                 	sts noise_volume_macro+1, zero
001f0d 9220 291b                 	sts noise_arpeggio_macro, zero
001f0f 9220 291c                 	sts noise_arpeggio_macro+1, zero
001f11 9220 2923                 	sts noise_pitch_macro, zero
001f13 9220 2924                 	sts noise_pitch_macro+1, zero
001f15 9220 2929                 	sts noise_hi_pitch_macro, zero
001f17 9220 292a                 	sts noise_hi_pitch_macro+1, zero
001f19 9220 292e                 	sts noise_duty_macro, zero
001f1b 9220 292f                 	sts noise_duty_macro+1, zero
001f1d 9220 2921                 	sts noise_total_pitch_offset, zero //reset the pitch offset
001f1f 9220 2922                 	sts noise_total_pitch_offset+1, zero
001f21 9220 2928                 	sts noise_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001f23 9631                      	adiw Z, 1 //point to the byte next to the flag
001f24 91b4                      	lpm r27, Z //store the instrument offset into r27
001f25 e2ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
001f26 e0fd                      	ldi ZH, HIGH(instruments)
001f27 0feb                      	add ZL, r27 //point Z to offsetted instrument
001f28 1df2                      	adc ZH, zero
001f29 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001f2a 1fff                      	rol ZH
001f2b 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001f2c 91b4                      	lpm r27, Z
                                 
001f2d 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001f2e 1fbb                      	rol r27
001f2f 2fea                      	mov ZL, r26
001f30 2ffb                      	mov ZH, r27
001f31 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001f32 9632                      	adiw Z, 2 //point Z to the address of the macro
001f33 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel3_instrument_change_macro_loop:
001f34 95aa                      	dec r26
001f35 f019                      	breq sound_driver_channel3_instrument_change_exit
001f36 95b6                      	lsr r27
001f37 f078                      	brcs sound_driver_channel3_instrument_change_load_macro
001f38 cffb                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_exit:
001f39 e0a3                      	ldi r26, 0x03
001f3a e0b2                      	ldi r27, 0x02
001f3b 93b0 2918                 	sts noise_volume_macro_offset, r27 //reset all macro offsets
001f3d 93a0 291d                 	sts noise_arpeggio_macro_offset, r26
001f3f 93b0 2925                 	sts noise_pitch_macro_offset, r27
001f41 93b0 292b                 	sts noise_hi_pitch_macro_offset, r27
001f43 93b0 2930                 	sts noise_duty_macro_offset, r27
001f45 d0ba                      	rcall sound_driver_channel3_increment_offset_twice
001f46 cdf6                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_load_macro:
001f47 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001f48 91d5                      	lpm r29, Z+
                                 
001f49 30a5                      	cpi r26, 5
001f4a f039                      	breq sound_driver_channel3_instrument_change_load_macro_volume
001f4b 30a4                      	cpi r26, 4
001f4c f079                      	breq sound_driver_channel3_instrument_change_load_macro_arpeggio
001f4d 30a3                      	cpi r26, 3
001f4e f0d9                      	breq sound_driver_channel3_instrument_change_load_macro_pitch
001f4f 30a2                      	cpi r26, 2
001f50 f159                      	breq sound_driver_channel3_instrument_change_load_macro_hi_pitch
001f51 c03c                      	rjmp sound_driver_channel3_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel3_instrument_change_load_macro_volume:
001f52 93c0 2916                 	sts noise_volume_macro, r28
001f54 93d0 2917                 	sts noise_volume_macro+1, r29
001f56 d041                      	rcall sound_driver_channel3_instrument_change_read_header
001f57 93c0 291a                 	sts noise_volume_macro_release, r28
001f59 93d0 2919                 	sts noise_volume_macro_loop, r29
001f5b cfd8                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 	
                                 sound_driver_channel3_instrument_change_load_macro_arpeggio:
001f5c 93c0 291b                 	sts noise_arpeggio_macro, r28
001f5e 93d0 291c                 	sts noise_arpeggio_macro+1, r29
001f60 9220 2952                 	sts noise_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001f62 9220 2953                 	sts noise_fx_Qxy_target+1, zero
001f64 9220 2959                 	sts noise_fx_Rxy_target, zero
001f66 9220 295a                 	sts noise_fx_Rxy_target+1, zero
001f68 d03a                      	rcall sound_driver_channel3_instrument_change_read_header_arpeggio
001f69 cfca                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_pitch:
001f6a 93c0 2923                 	sts noise_pitch_macro, r28
001f6c 93d0 2924                 	sts noise_pitch_macro+1, r29
001f6e 9220 2952                 	sts noise_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001f70 9220 2953                 	sts noise_fx_Qxy_target+1, zero
001f72 9220 2959                 	sts noise_fx_Rxy_target, zero
001f74 9220 295a                 	sts noise_fx_Rxy_target+1, zero
001f76 d021                      	rcall sound_driver_channel3_instrument_change_read_header
001f77 93c0 2927                 	sts noise_pitch_macro_release, r28
001f79 93d0 2926                 	sts noise_pitch_macro_loop, r29
001f7b cfb8                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_hi_pitch:
001f7c 93c0 2929                 	sts noise_hi_pitch_macro, r28
001f7e 93d0 292a                 	sts noise_hi_pitch_macro+1, r29
001f80 9220 2952                 	sts noise_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001f82 9220 2953                 	sts noise_fx_Qxy_target+1, zero
001f84 9220 2959                 	sts noise_fx_Rxy_target, zero
001f86 9220 295a                 	sts noise_fx_Rxy_target+1, zero
001f88 d00f                      	rcall sound_driver_channel3_instrument_change_read_header
001f89 93c0 292d                 	sts noise_hi_pitch_macro_release, r28
001f8b 93d0 292c                 	sts noise_hi_pitch_macro_loop, r29
001f8d cfa6                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_duty:
001f8e 93c0 292e                 	sts noise_duty_macro, r28
001f90 93d0 292f                 	sts noise_duty_macro+1, r29
001f92 d005                      	rcall sound_driver_channel3_instrument_change_read_header
001f93 93c0 2932                 	sts noise_duty_macro_release, r28
001f95 93d0 2931                 	sts noise_duty_macro_loop, r29
001f97 cf9c                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_read_header:
001f98 93ef                      	push ZL
001f99 93ff                      	push ZH
001f9a 2fec                      	mov ZL, r28
001f9b 2ffd                      	mov ZH, r29
001f9c 0fee                      	lsl ZL
001f9d 1fff                      	rol ZH
001f9e 91c5                      	lpm r28, Z+
001f9f 91d4                      	lpm r29, Z
001fa0 91ff                      	pop ZH
001fa1 91ef                      	pop ZL
001fa2 9508                      	ret
                                 
                                 sound_driver_channel3_instrument_change_read_header_arpeggio:
001fa3 93ef                      	push ZL
001fa4 93ff                      	push ZH
001fa5 2fec                      	mov ZL, r28
001fa6 2ffd                      	mov ZH, r29
001fa7 0fee                      	lsl ZL
001fa8 1fff                      	rol ZH
001fa9 91c5                      	lpm r28, Z+
001faa 91d5                      	lpm r29, Z+
001fab 93c0 291f                 	sts noise_arpeggio_macro_release, r28
001fad 93d0 291e                 	sts noise_arpeggio_macro_loop, r29
001faf 91c4                      	lpm r28, Z
001fb0 93c0 2920                 	sts noise_arpeggio_macro_mode, r28
001fb2 91ff                      	pop ZH
001fb3 91ef                      	pop ZL
001fb4 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel3_release:
                                 sound_driver_channel3_release_volume:
001fb5 91b0 291a                 	lds r27, noise_volume_macro_release
001fb7 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001fb8 f019                      	breq sound_driver_channel3_release_arpeggio //if the macro has no release flag, check the next macro
001fb9 95b3                      	inc r27
001fba 93b0 2918                 	sts noise_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel3_release_arpeggio:
001fbc 91b0 291f                 	lds r27, noise_arpeggio_macro_release
001fbe 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001fbf f019                      	breq sound_driver_channel3_release_pitch
001fc0 95b3                      	inc r27
001fc1 93b0 291d                 	sts noise_arpeggio_macro_offset, r27
                                 sound_driver_channel3_release_pitch:
001fc3 91b0 2927                 	lds r27, noise_pitch_macro_release
001fc5 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001fc6 f019                      	breq sound_driver_channel3_release_hi_pitch
001fc7 95b3                      	inc r27
001fc8 93b0 2925                 	sts noise_pitch_macro_offset, r27
                                 sound_driver_channel3_release_hi_pitch:
001fca 91b0 292d                 	lds r27, noise_hi_pitch_macro_release
001fcc 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001fcd f019                      	breq sound_driver_channel3_release_duty
001fce 95b3                      	inc r27
001fcf 93b0 292b                 	sts noise_hi_pitch_macro_offset, r27
                                 sound_driver_channel3_release_duty:
001fd1 91b0 2932                 	lds r27, noise_duty_macro_release
001fd3 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001fd4 f019                      	breq sound_driver_channel3_release_exit
001fd5 95b3                      	inc r27
001fd6 93b0 2930                 	sts noise_duty_macro_offset, r27
                                 sound_driver_channel3_release_exit:
001fd8 d01d                      	rcall sound_driver_channel3_increment_offset
001fd9 cd63                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_next_pattern:
001fda 91e0 2818                 	lds ZL, song_frames
001fdc 91f0 2819                 	lds ZH, song_frames+1
001fde 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001fe0 91b0 281b                 	lds r27, song_frame_offset+1
001fe2 93a0 281a                 	sts song_frame_offset, r26
001fe4 93b0 281b                 	sts song_frame_offset+1, r27
001fe6 9616                      	adiw r27:r26, 6 //offset for channel 3
001fe7 0fea                      	add ZL, r26
001fe8 1ffb                      	adc ZH, r27
                                 
001fe9 91a5                      	lpm r26, Z+ //load the address of the next pattern
001fea 91b4                      	lpm r27, Z
001feb 0faa                      	lsl r26
001fec 1fbb                      	rol r27
001fed 93a0 2910                 	sts noise_pattern, r26
001fef 93b0 2911                 	sts noise_pattern+1, r27
                                 
001ff1 9220 2914                 	sts noise_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001ff3 9220 2915                 	sts noise_pattern_offset+1, zero
001ff5 cd47                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_increment_offset:
001ff6 91e0 2914                 	lds ZL, noise_pattern_offset //current offset in the pattern for noise
001ff8 91f0 2915                 	lds ZH, noise_pattern_offset+1
001ffa 9631                      	adiw Z, 1
001ffb 93e0 2914                 	sts noise_pattern_offset, ZL
001ffd 93f0 2915                 	sts noise_pattern_offset+1, ZH
001fff 9508                      	ret
                                 
                                 sound_driver_channel3_increment_offset_twice: //used for data that takes up 2 bytes worth of space
002000 91e0 2914                 	lds ZL, noise_pattern_offset //current offset in the pattern for noise
002002 91f0 2915                 	lds ZH, noise_pattern_offset+1
002004 9632                      	adiw Z, 2 //increment the pointer twice
002005 93e0 2914                 	sts noise_pattern_offset, ZL
002007 93f0 2915                 	sts noise_pattern_offset+1, ZH
002009 9508                      	ret
                                 
                                 sound_driver_channel3_decrement_frame_delay:
00200a 95ba                      	dec r27
00200b 93b0 2913                 	sts noise_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel4:
                                 
                                 sound_driver_calculate_delays:
00200d 91f0 281e                 	lds r31, song_speed
00200f 2fef                      	mov r30, r31
002010 50e1                      	subi r30, 1
                                 sound_driver_calculate_delays_pulse1:
002011 91a0 2825                 	lds r26, pulse1_pattern_delay_frames
002013 11a2                      	cpse r26, zero
002014 c042                      	rjmp sound_driver_calculate_delays_pulse2
002015 c000                      	rjmp sound_driver_calculate_delays_pulse1_main
                                 
                                 sound_driver_calculate_delays_pulse1_main:
002016 2faf                      	mov r26, r31 //move the speed to r26
002017 91b0 2824                 	lds r27, pulse1_pattern_delay_rows //decrement the delay rows
002019 15b2                      	cp r27, zero
00201a f409                      	brne PC+2
00201b c03b                      	rjmp sound_driver_calculate_delays_pulse2
00201c 95ba                      	dec r27
00201d 93b0 2824                 	sts pulse1_pattern_delay_rows, r27
00201f 11b2                      	cpse r27, zero
002020 c034                      	rjmp sound_driver_calculate_delays_pulse1_store
002021 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx:
002022 efbf                      	ldi r27, 0xFF
002023 91c0 2871                 	lds r28, pulse1_fx_Sxx_pre
002025 91d0 2872                 	lds r29, pulse1_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse1_Sxx_check_pre:
002027 17cb                      	cp r28, r27
002028 f009                      	breq sound_driver_calculate_delays_pulse1_Sxx_check_post
002029 c00d                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_pre
                                 sound_driver_calculate_delays_pulse1_Sxx_check_post:
00202a 17db                      	cp r29, r27
00202b f009                      	breq sound_driver_calculate_delays_pulse1_Gxx
00202c c015                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx:
00202d 91c0 285f                 	lds r28, pulse1_fx_Gxx_pre
00202f 91d0 2860                 	lds r29, pulse1_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse1_Gxx_check_pre:
002031 17cb                      	cp r28, r27
002032 f009                      	breq sound_driver_calculate_delays_pulse1_Gxx_check_post
002033 c012                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_pre
                                 sound_driver_calculate_delays_pulse1_Gxx_check_post:
002034 17db                      	cp r29, r27
002035 f0f9                      	breq sound_driver_calculate_delays_pulse1_store
002036 c01a                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_pre:
002037 93b0 2871                 	sts pulse1_fx_Sxx_pre, r27
002039 1bec                      	sub r30, r28 //(song speed)-1-Sxx
00203a 93e0 2872                 	sts pulse1_fx_Sxx_post, r30
00203c 95ca                      	dec r28
00203d 93c0 2825                 	sts pulse1_pattern_delay_frames, r28
00203f 2fef                      	mov r30, r31
002040 50e1                      	subi r30, 1
002041 c015                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_post:
002042 93b0 2872                 	sts pulse1_fx_Sxx_post, r27
002044 2fad                      	mov r26, r29
002045 c00f                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx_pre:
002046 93b0 285f                 	sts pulse1_fx_Gxx_pre, r27
002048 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002049 93e0 2860                 	sts pulse1_fx_Gxx_post, r30
00204b 95ca                      	dec r28
00204c 93c0 2825                 	sts pulse1_pattern_delay_frames, r28
00204e 2fef                      	mov r30, r31
00204f 50e1                      	subi r30, 1
002050 c006                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse1_Gxx_post:
002051 93b0 2860                 	sts pulse1_fx_Gxx_post, r27
002053 2fad                      	mov r26, r29
002054 c000                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_store:
002055 93a0 2825                 	sts pulse1_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_pulse2:
002057 91a0 2876                 	lds r26, pulse2_pattern_delay_frames
002059 11a2                      	cpse r26, zero
00205a c042                      	rjmp sound_driver_calculate_delays_triangle
00205b c000                      	rjmp sound_driver_calculate_delays_pulse2_main
                                 
                                 sound_driver_calculate_delays_pulse2_main:
00205c 2faf                      	mov r26, r31 //move the speed to r26
00205d 91b0 2875                 	lds r27, pulse2_pattern_delay_rows //decrement the delay rows
00205f 15b2                      	cp r27, zero
002060 f409                      	brne PC+2
002061 c03b                      	rjmp sound_driver_calculate_delays_triangle
002062 95ba                      	dec r27
002063 93b0 2875                 	sts pulse2_pattern_delay_rows, r27
002065 11b2                      	cpse r27, zero
002066 c034                      	rjmp sound_driver_calculate_delays_pulse2_store
002067 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx:
002068 efbf                      	ldi r27, 0xFF
002069 91c0 28c2                 	lds r28, pulse2_fx_Sxx_pre
00206b 91d0 28c3                 	lds r29, pulse2_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse2_Sxx_check_pre:
00206d 17cb                      	cp r28, r27
00206e f009                      	breq sound_driver_calculate_delays_pulse2_Sxx_check_post
00206f c00d                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_pre
                                 sound_driver_calculate_delays_pulse2_Sxx_check_post:
002070 17db                      	cp r29, r27
002071 f009                      	breq sound_driver_calculate_delays_pulse2_Gxx
002072 c015                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx:
002073 91c0 28b0                 	lds r28, pulse2_fx_Gxx_pre
002075 91d0 28b1                 	lds r29, pulse2_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse2_Gxx_check_pre:
002077 17cb                      	cp r28, r27
002078 f009                      	breq sound_driver_calculate_delays_pulse2_Gxx_check_post
002079 c012                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_pre
                                 sound_driver_calculate_delays_pulse2_Gxx_check_post:
00207a 17db                      	cp r29, r27
00207b f0f9                      	breq sound_driver_calculate_delays_pulse2_store
00207c c01a                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_pre:
00207d 93b0 28c2                 	sts pulse2_fx_Sxx_pre, r27
00207f 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002080 93e0 28c3                 	sts pulse2_fx_Sxx_post, r30
002082 95ca                      	dec r28
002083 93c0 2876                 	sts pulse2_pattern_delay_frames, r28
002085 2fef                      	mov r30, r31
002086 50e1                      	subi r30, 1
002087 cfcf                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_post:
002088 93b0 28c3                 	sts pulse2_fx_Sxx_post, r27
00208a 2fad                      	mov r26, r29
00208b c00f                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx_pre:
00208c 93b0 28b0                 	sts pulse2_fx_Gxx_pre, r27
00208e 1bec                      	sub r30, r28 //(song speed)-1-Sxx
00208f 93e0 28b1                 	sts pulse2_fx_Gxx_post, r30
002091 95ca                      	dec r28
002092 93c0 2876                 	sts pulse2_pattern_delay_frames, r28
002094 2fef                      	mov r30, r31
002095 50e1                      	subi r30, 1
002096 cfc0                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse2_Gxx_post:
002097 93b0 28b1                 	sts pulse2_fx_Gxx_post, r27
002099 2fad                      	mov r26, r29
00209a c000                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_store:
00209b 93a0 2876                 	sts pulse2_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_triangle:
00209d 91a0 28c7                 	lds r26, triangle_pattern_delay_frames
00209f 11a2                      	cpse r26, zero
0020a0 c042                      	rjmp sound_driver_calculate_delays_noise
0020a1 c000                      	rjmp sound_driver_calculate_delays_triangle_main
                                 
                                 sound_driver_calculate_delays_triangle_main:
0020a2 2faf                      	mov r26, r31 //move the speed to r26
0020a3 91b0 28c6                 	lds r27, triangle_pattern_delay_rows //decrement the delay rows
0020a5 15b2                      	cp r27, zero
0020a6 f409                      	brne PC+2
0020a7 c03b                      	rjmp sound_driver_calculate_delays_noise
0020a8 95ba                      	dec r27
0020a9 93b0 28c6                 	sts triangle_pattern_delay_rows, r27
0020ab 11b2                      	cpse r27, zero
0020ac c034                      	rjmp sound_driver_calculate_delays_triangle_store
0020ad 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_triangle_Sxx:
0020ae efbf                      	ldi r27, 0xFF
0020af 91c0 290e                 	lds r28, triangle_fx_Sxx_pre
0020b1 91d0 290f                 	lds r29, triangle_fx_Sxx_post
                                 sound_driver_calculate_delays_triangle_Sxx_check_pre:
0020b3 17cb                      	cp r28, r27
0020b4 f009                      	breq sound_driver_calculate_delays_triangle_Sxx_check_post
0020b5 c00d                      	rjmp sound_driver_calculate_delays_triangle_Sxx_pre
                                 sound_driver_calculate_delays_triangle_Sxx_check_post:
0020b6 17db                      	cp r29, r27
0020b7 f009                      	breq sound_driver_calculate_delays_triangle_Gxx
0020b8 c015                      	rjmp sound_driver_calculate_delays_triangle_Sxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Gxx:
0020b9 91c0 28fc                 	lds r28, triangle_fx_Gxx_pre
0020bb 91d0 28fd                 	lds r29, triangle_fx_Gxx_post
                                 sound_driver_calculate_delays_triangle_Gxx_check_pre:
0020bd 17cb                      	cp r28, r27
0020be f009                      	breq sound_driver_calculate_delays_triangle_Gxx_check_post
0020bf c012                      	rjmp sound_driver_calculate_delays_triangle_Gxx_pre
                                 sound_driver_calculate_delays_triangle_Gxx_check_post:
0020c0 17db                      	cp r29, r27
0020c1 f0f9                      	breq sound_driver_calculate_delays_triangle_store
0020c2 c01a                      	rjmp sound_driver_calculate_delays_triangle_Gxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_pre:
0020c3 93b0 290e                 	sts triangle_fx_Sxx_pre, r27
0020c5 1bec                      	sub r30, r28 //(song speed)-1-Sxx
0020c6 93e0 290f                 	sts triangle_fx_Sxx_post, r30
0020c8 95ca                      	dec r28
0020c9 93c0 28c7                 	sts triangle_pattern_delay_frames, r28
0020cb 2fef                      	mov r30, r31
0020cc 50e1                      	subi r30, 1
0020cd c015                      	rjmp sound_driver_calculate_delays_noise
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_post:
0020ce 93b0 290f                 	sts triangle_fx_Sxx_post, r27
0020d0 2fad                      	mov r26, r29
0020d1 c00f                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_Gxx_pre:
0020d2 93b0 28fc                 	sts triangle_fx_Gxx_pre, r27
0020d4 1bec                      	sub r30, r28 //(song speed)-1-Sxx
0020d5 93e0 28fd                 	sts triangle_fx_Gxx_post, r30
0020d7 95ca                      	dec r28
0020d8 93c0 28c7                 	sts triangle_pattern_delay_frames, r28
0020da 2fef                      	mov r30, r31
0020db 50e1                      	subi r30, 1
0020dc c006                      	rjmp sound_driver_calculate_delays_noise
                                 	
                                 sound_driver_calculate_delays_triangle_Gxx_post:
0020dd 93b0 28fd                 	sts triangle_fx_Gxx_post, r27
0020df 2fad                      	mov r26, r29
0020e0 c000                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_store:
0020e1 93a0 28c7                 	sts triangle_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_noise:
0020e3 91a0 2913                 	lds r26, noise_pattern_delay_frames
0020e5 11a2                      	cpse r26, zero
0020e6 c042                      	rjmp sound_driver_calculate_delays_dpcm
0020e7 c000                      	rjmp sound_driver_calculate_delays_noise_main
                                 
                                 sound_driver_calculate_delays_noise_main:
0020e8 2faf                      	mov r26, r31 //move the speed to r26
0020e9 91b0 2912                 	lds r27, noise_pattern_delay_rows //decrement the delay rows
0020eb 15b2                      	cp r27, zero
0020ec f409                      	brne PC+2
0020ed c03b                      	rjmp sound_driver_calculate_delays_dpcm
0020ee 95ba                      	dec r27
0020ef 93b0 2912                 	sts noise_pattern_delay_rows, r27
0020f1 11b2                      	cpse r27, zero
0020f2 c034                      	rjmp sound_driver_calculate_delays_noise_store
0020f3 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_noise_Sxx:
0020f4 efbf                      	ldi r27, 0xFF
0020f5 91c0 295f                 	lds r28, noise_fx_Sxx_pre
0020f7 91d0 2960                 	lds r29, noise_fx_Sxx_post
                                 sound_driver_calculate_delays_noise_Sxx_check_pre:
0020f9 17cb                      	cp r28, r27
0020fa f009                      	breq sound_driver_calculate_delays_noise_Sxx_check_post
0020fb c00d                      	rjmp sound_driver_calculate_delays_noise_Sxx_pre
                                 sound_driver_calculate_delays_noise_Sxx_check_post:
0020fc 17db                      	cp r29, r27
0020fd f009                      	breq sound_driver_calculate_delays_noise_Gxx
0020fe c015                      	rjmp sound_driver_calculate_delays_noise_Sxx_post
                                 
                                 sound_driver_calculate_delays_noise_Gxx:
0020ff 91c0 294d                 	lds r28, noise_fx_Gxx_pre
002101 91d0 294e                 	lds r29, noise_fx_Gxx_post
                                 sound_driver_calculate_delays_noise_Gxx_check_pre:
002103 17cb                      	cp r28, r27
002104 f009                      	breq sound_driver_calculate_delays_noise_Gxx_check_post
002105 c012                      	rjmp sound_driver_calculate_delays_noise_Gxx_pre
                                 sound_driver_calculate_delays_noise_Gxx_check_post:
002106 17db                      	cp r29, r27
002107 f0f9                      	breq sound_driver_calculate_delays_noise_store
002108 c01a                      	rjmp sound_driver_calculate_delays_noise_Gxx_post
                                 
                                 sound_driver_calculate_delays_noise_Sxx_pre:
002109 93b0 295f                 	sts noise_fx_Sxx_pre, r27
00210b 1bec                      	sub r30, r28 //(song speed)-1-Sxx
00210c 93e0 2960                 	sts noise_fx_Sxx_post, r30
00210e 95ca                      	dec r28
00210f 93c0 2913                 	sts noise_pattern_delay_frames, r28
002111 2fef                      	mov r30, r31
002112 50e1                      	subi r30, 1
002113 c015                      	rjmp sound_driver_calculate_delays_dpcm
                                 
                                 sound_driver_calculate_delays_noise_Sxx_post:
002114 93b0 2960                 	sts noise_fx_Sxx_post, r27
002116 2fad                      	mov r26, r29
002117 c00f                      	rjmp sound_driver_calculate_delays_noise_store
                                 
                                 sound_driver_calculate_delays_noise_Gxx_pre:
002118 93b0 294d                 	sts noise_fx_Gxx_pre, r27
00211a 1bec                      	sub r30, r28 //(song speed)-1-Sxx
00211b 93e0 294e                 	sts noise_fx_Gxx_post, r30
00211d 95ca                      	dec r28
00211e 93c0 2913                 	sts noise_pattern_delay_frames, r28
002120 2fef                      	mov r30, r31
002121 50e1                      	subi r30, 1
002122 c006                      	rjmp sound_driver_calculate_delays_dpcm
                                 	
                                 sound_driver_calculate_delays_noise_Gxx_post:
002123 93b0 294e                 	sts noise_fx_Gxx_post, r27
002125 2fad                      	mov r26, r29
002126 c000                      	rjmp sound_driver_calculate_delays_noise_store
                                 
                                 sound_driver_calculate_delays_noise_store:
002127 93a0 2913                 	sts noise_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_dpcm:
                                 
                                 sound_driver_instrument_fx_routine:
                                 sound_driver_instrument_routine_channel0_volume:
002129 91e0 2828                 	lds ZL, pulse1_volume_macro
00212b 91f0 2829                 	lds ZH, pulse1_volume_macro+1
00212d 9630                      	adiw Z, 0
00212e f1a1                      	breq sound_driver_instrument_routine_channel0_volume_default //if no volume macro is in use, use default multiplier of F
00212f 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002130 1fff                      	rol ZH
002131 91a0 282a                 	lds r26, pulse1_volume_macro_offset
002133 0fea                      	add ZL, r26
002134 1df2                      	adc ZH, zero
                                 
002135 91b0 282c                 	lds r27, pulse1_volume_macro_release
002137 17ba                      	cp r27, r26
002138 f429                      	brne sound_driver_instrument_routine_channel0_volume_increment //if the current offset is not equal to the release index, increment the offset
002139 91a0 282b                 	lds r26, pulse1_volume_macro_loop
00213b 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00213c f010                      	brlo sound_driver_instrument_routine_channel0_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00213d c003                      	rjmp sound_driver_instrument_routine_channel0_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_volume_increment:
00213e 95a3                      	inc r26 //increment the macro offset
00213f 93a0 282a                 	sts pulse1_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_volume_read:
002141 91b4                      	lpm r27, Z //load volume data into r27
002142 3fbf                      	cpi r27, 0xFF //check for macro end flag
002143 f469                      	brne sound_driver_instrument_routine_channel0_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_release:
002144 91b0 282c                 	lds r27, pulse1_volume_macro_release
002146 3fbf                      	cpi r27, 0xFF
002147 f429                      	brne sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_loop:
002148 91b0 282b                 	lds r27, pulse1_volume_macro_loop //load the loop index
00214a 93b0 282a                 	sts pulse1_volume_macro_offset, r27 //store the loop index into the offset
00214c cfdc                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index:
00214d 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
00214e 93a0 282a                 	sts pulse1_volume_macro_offset, r26
002150 cfd8                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_calculate:
002151 e6e4                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
002152 e5fc                      	ldi ZH, HIGH(volumes << 1)
002153 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
002154 0feb                      	add ZL, r27 //add offset to the table
002155 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel0_volume_load:
002156 91b0 2800                 	lds r27, pulse1_param //load main volume
002158 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002159 91a0 285d                 	lds r26, pulse1_fx_7xy_value
00215b 30a0                      	cpi r26, 0x00
00215c f481                      	brne sound_driver_instrument_routine_channel0_volume_load_7xy
                                 
00215d 0feb                      	add ZL, r27 //offset the volume table by the main volume
00215e 1df2                      	adc ZH, zero
00215f 91b4                      	lpm r27, Z
002160 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
002162 c023                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default:
002163 91b0 2800                 	lds r27, pulse1_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
002165 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002166 91a0 285d                 	lds r26, pulse1_fx_7xy_value
002168 30a0                      	cpi r26, 0x00
002169 f499                      	brne sound_driver_instrument_routine_channel0_volume_default_7xy
00216a 93b0 2806                 	sts pulse1_output_volume, r27
00216c c019                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy:
00216d 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
00216e f038                      	brcs sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
00216f f031                      	breq sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
                                 
002170 0feb                      	add ZL, r27 //offset the volume table by the main volume
002171 1df2                      	adc ZH, zero
002172 91b4                      	lpm r27, Z
002173 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
002175 c010                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy_overflow:
002176 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002177 0feb                      	add ZL, r27 //offset the volume table by the main volume
002178 1df2                      	adc ZH, zero
002179 91b4                      	lpm r27, Z
00217a 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
00217c c009                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default_7xy:
00217d 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
00217e f020                      	brcs sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
00217f f019                      	breq sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
002180 93b0 2806                 	sts pulse1_output_volume, r27
002182 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel0_volume_default_7xy_overflow:
002183 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002184 93b0 2806                 	sts pulse1_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002186 91e0 282d                 	lds ZL, pulse1_arpeggio_macro
002188 91f0 282e                 	lds ZH, pulse1_arpeggio_macro+1
00218a 9630                      	adiw Z, 0
00218b f1d9                      	breq sound_driver_instrument_routine_channel0_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
00218c 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
00218d 1fff                      	rol ZH
00218e 91a0 282f                 	lds r26, pulse1_arpeggio_macro_offset
002190 0fea                      	add ZL, r26
002191 1df2                      	adc ZH, zero
                                 
002192 91b0 2831                 	lds r27, pulse1_arpeggio_macro_release
002194 17ba                      	cp r27, r26
002195 f429                      	brne sound_driver_instrument_routine_channel0_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002196 91a0 2830                 	lds r26, pulse1_arpeggio_macro_loop
002198 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002199 f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
00219a c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_increment:
00219b 95a3                      	inc r26 //increment the macro offset
00219c 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_read:
00219e 91b4                      	lpm r27, Z //load arpeggio data into r27
00219f 38b0                      	cpi r27, 0x80 //check for macro end flag
0021a0 f009                      	breq sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag
0021a1 c041                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_check_mode:
0021a2 50a1                      	subi r26, 1 //keep the offset at the end flag
0021a3 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26
0021a5 91b0 2832                 	lds r27, pulse1_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
0021a7 30b1                      	cpi r27, 0x01
0021a8 f048                      	brlo sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_release:
0021a9 91b0 2831                 	lds r27, pulse1_arpeggio_macro_release
0021ab 3fbf                      	cpi r27, 0xFF
0021ac f4d1                      	brne sound_driver_instrument_routine_channel0_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_loop:
0021ad 91b0 2830                 	lds r27, pulse1_arpeggio_macro_loop
0021af 3fbf                      	cpi r27, 0xFF
0021b0 f499                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
0021b1 c015                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute:
0021b2 91b0 2831                 	lds r27, pulse1_arpeggio_macro_release
0021b4 3fbf                      	cpi r27, 0xFF
0021b5 f421                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_check_loop:
0021b6 91b0 2830                 	lds r27, pulse1_arpeggio_macro_loop //load the loop index
0021b8 3fbf                      	cpi r27, 0xFF //check if loop flag exists
0021b9 f451                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop:
0021ba 91c0 2845                 	lds r28, pulse1_fx_0xy_sequence //check for 0xy effect
0021bc 91d0 2846                 	lds r29, pulse1_fx_0xy_sequence+1
0021be 9620                      	adiw r29:r28, 0
0021bf f469                      	brne sound_driver_instrument_routine_channel0_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
0021c0 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
0021c1 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26 //store the last valid index into the offset
0021c3 cfc2                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload:
0021c4 93b0 282f                 	sts pulse1_arpeggio_macro_offset, r27 //store the loop index into the offset
0021c6 cfbf                      	rjmp sound_driver_instrument_routine_channel0_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_default:
0021c7 91c0 2845                 	lds r28, pulse1_fx_0xy_sequence //load 0xy effect
0021c9 91d0 2846                 	lds r29, pulse1_fx_0xy_sequence+1
0021cb 9620                      	adiw r29:r28, 0 //check for 0xy effect
0021cc f099                      	breq sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel0_arpeggio_default_0xy:
0021cd 95d6                      	lsr r29
0021ce 95c7                      	ror r28
0021cf 95d7                      	ror r29
0021d0 95c7                      	ror r28
0021d1 95d7                      	ror r29
0021d2 95c7                      	ror r28
0021d3 95d7                      	ror r29
0021d4 95c7                      	ror r28
0021d5 95d7                      	ror r29
0021d6 95d2                      	swap r29
                                 
0021d7 93c0 2845                 	sts pulse1_fx_0xy_sequence, r28 //store the rolled sequence
0021d9 93d0 2846                 	sts pulse1_fx_0xy_sequence+1, r29
0021db 70cf                      	andi r28, 0x0F //mask out the 4 LSB
0021dc 91a0 2807                 	lds r26, pulse1_note //load the current note index
0021de 0fac                      	add r26, r28 //add the note offset
0021df c02e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
0021e0 91a0 2807                 	lds r26, pulse1_note //load the current note index
0021e2 c02b                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process:
0021e3 9220 2833                 	sts pulse1_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
0021e5 9220 2834                 	sts pulse1_total_pitch_offset+1, zero
0021e7 9220 283a                 	sts pulse1_total_hi_pitch_offset, zero
0021e9 91a0 2832                 	lds r26, pulse1_arpeggio_macro_mode
0021eb 30a1                      	cpi r26, 0x01 //absolute mode
0021ec f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_absolute
0021ed f069                      	breq sound_driver_instrument_routine_channel0_arpeggio_process_fixed
0021ee c00e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute:
0021ef 91a0 2807                 	lds r26, pulse1_note //load the current note index
0021f1 0fab                      	add r26, r27 //offset the note with the arpeggio data
0021f2 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0021f3 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_add:
0021f4 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0021f5 f0c0                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
0021f6 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0021f7 c016                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract:
0021f8 fda7                      	sbrc r26, 7 //check if result is negative
0021f9 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0021fa c013                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_fixed:
0021fb 2fab                      	mov r26, r27 //move the arpeggio data into r26
0021fc c011                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative:
0021fd 91a0 2807                 	lds r26, pulse1_note //load the current note index
0021ff 0fab                      	add r26, r27 //offset the note with the arpeggio data
002200 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002201 c008                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_add:
002202 93a0 2807                 	sts pulse1_note, r26 //NOTE: relative mode modifies the original note index
002204 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002205 f040                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
002206 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002207 93a0 2807                 	sts pulse1_note, r26
002209 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract:
00220a fda7                      	sbrc r26, 7 //check if result is negative
00220b e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
00220c 93a0 2807                 	sts pulse1_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_load:
00220e e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
00220f e0f0                      	ldi ZH, HIGH(note_table << 1)
002210 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002211 0fea                      	add ZL, r26 //add offset
002212 1df2                      	adc ZH, zero
002213 91a5                      	lpm r26, Z+ //load bytes
002214 91b4                      	lpm r27, Z
002215 93a0 0a8c                 	sts TCB0_CCMPL, r26 //load the LOW bits for timer
002217 93b0 0a8d                 	sts TCB0_CCMPH, r27 //load the HIGH bits for timer
002219 93a0 2851                 	sts pulse1_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
00221b 93b0 2852                 	sts pulse1_fx_3xx_target+1, r27
00221d c000                      	rjmp sound_driver_instrument_routine_channel0_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch:
00221e 91e0 2835                 	lds ZL, pulse1_pitch_macro
002220 91f0 2836                 	lds ZH, pulse1_pitch_macro+1
002222 9630                      	adiw Z, 0
002223 f409                      	brne sound_driver_instrument_routine_channel0_pitch_continue
002224 c023                      	rjmp sound_driver_instrument_routine_channel0_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel0_pitch_continue:
002225 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002226 1fff                      	rol ZH
002227 91a0 2837                 	lds r26, pulse1_pitch_macro_offset
002229 0fea                      	add ZL, r26
00222a 1df2                      	adc ZH, zero
                                 
00222b 91b0 2839                 	lds r27, pulse1_pitch_macro_release
00222d 17ba                      	cp r27, r26
00222e f429                      	brne sound_driver_instrument_routine_channel0_pitch_increment //if the current offset is not equal to the release index, increment the offset
00222f 91a0 2838                 	lds r26, pulse1_pitch_macro_loop
002231 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002232 f010                      	brlo sound_driver_instrument_routine_channel0_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002233 c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_pitch_increment:
002234 95a3                      	inc r26 //increment the macro offset
002235 93a0 2837                 	sts pulse1_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_pitch_read:
002237 91b4                      	lpm r27, Z //load pitch data into r27
002238 38b0                      	cpi r27, 0x80 //check for macro end flag
002239 f479                      	brne sound_driver_instrument_routine_channel0_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_release:
00223a 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00223b 93a0 2837                 	sts pulse1_pitch_macro_offset, r26
00223d 91b0 2839                 	lds r27, pulse1_pitch_macro_release
00223f 3fbf                      	cpi r27, 0xFF
002240 f439                      	brne sound_driver_instrument_routine_channel0_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_loop:
002241 91b0 2838                 	lds r27, pulse1_pitch_macro_loop //load the loop index
002243 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002244 f019                      	breq sound_driver_instrument_routine_channel0_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002245 93b0 2837                 	sts pulse1_pitch_macro_offset, r27 //store the loop index into the offset
002247 cfd6                      	rjmp sound_driver_instrument_routine_channel0_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_default:
002248 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel0_pitch_calculate:
002249 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00224a 937f                      	push r23
00224b 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
00224c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00224d 0367                      	mulsu r22, r23
00224e 917f                      	pop r23
00224f 916f                      	pop r22
                                 
002250 9416                      	lsr r1 //shift out the fractional bits
002251 9407                      	ror r0
002252 9416                      	lsr r1
002253 9407                      	ror r0
002254 9416                      	lsr r1
002255 9407                      	ror r0
002256 9416                      	lsr r1
002257 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_check_negative:
002258 fe13                      	sbrs r1, 3 //check if result was a negative number
002259 c007                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_negative:
00225a efc0                      	ldi r28, 0xF0
00225b 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_check_divisible_8:
00225c 70b7                      	andi r27, 0b00000111
00225d f019                      	breq sound_driver_instrument_routine_channel0_pitch_calculate_offset
                                 
00225e e0b1                      	ldi r27, 0x01
00225f 0e0b                      	add r0, r27
002260 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_offset:
002261 91a0 2833                 	lds r26, pulse1_total_pitch_offset
002263 91b0 2834                 	lds r27, pulse1_total_pitch_offset+1
002265 0e0a                      	add r0, r26
002266 1e1b                      	adc r1, r27
002267 9200 2833                 	sts pulse1_total_pitch_offset, r0
002269 9210 2834                 	sts pulse1_total_pitch_offset+1, r1
00226b 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
00226d 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
00226f 0da0                      	add r26, r0 //offset the timer values
002270 1db1                      	adc r27, r1
                                 	
002271 91c0 2849                 	lds r28, pulse1_fx_1xx_total
002273 91d0 284a                 	lds r29, pulse1_fx_1xx_total+1
002275 1bac                      	sub r26, r28
002276 0bbd                      	sbc r27, r29
002277 91c0 284d                 	lds r28, pulse1_fx_2xx_total
002279 91d0 284e                 	lds r29, pulse1_fx_2xx_total+1
00227b 0fac                      	add r26, r28
00227c 1fbd                      	adc r27, r29
00227d 91c0 2861                 	lds r28, pulse1_fx_Pxx_total
00227f 91d0 2862                 	lds r29, pulse1_fx_Pxx_total+1
002281 0fac                      	add r26, r28
002282 1fbd                      	adc r27, r29
002283 91c0 2868                 	lds r28, pulse1_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
002285 91d0 2869                 	lds r29, pulse1_fx_Qxy_total_offset+1
002287 1bac                      	sub r26, r28
002288 0bbd                      	sbc r27, r29
002289 91c0 286f                 	lds r28, pulse1_fx_Rxy_total_offset
00228b 91d0 2870                 	lds r29, pulse1_fx_Rxy_total_offset+1
00228d 0fac                      	add r26, r28
00228e 1fbd                      	adc r27, r29
                                 
00228f 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
002291 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel0_hi_pitch:
002293 91e0 283b                 	lds ZL, pulse1_hi_pitch_macro
002295 91f0 283c                 	lds ZH, pulse1_hi_pitch_macro+1
002297 9630                      	adiw Z, 0
002298 f409                      	brne sound_driver_instrument_routine_channel0_hi_pitch_continue
002299 c03c                      	rjmp sound_driver_instrument_routine_channel0_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel0_hi_pitch_continue:
00229a 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00229b 1fff                      	rol ZH
00229c 91a0 283d                 	lds r26, pulse1_hi_pitch_macro_offset
00229e 0fea                      	add ZL, r26
00229f 1df2                      	adc ZH, zero
                                 
0022a0 91b0 283f                 	lds r27, pulse1_hi_pitch_macro_release
0022a2 17ba                      	cp r27, r26
0022a3 f429                      	brne sound_driver_instrument_routine_channel0_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
0022a4 91a0 283e                 	lds r26, pulse1_hi_pitch_macro_loop
0022a6 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0022a7 f010                      	brlo sound_driver_instrument_routine_channel0_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0022a8 c003                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_increment:
0022a9 95a3                      	inc r26 //increment the macro offset
0022aa 93a0 283d                 	sts pulse1_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_hi_pitch_read:
0022ac 91b4                      	lpm r27, Z //load hi pitch data into r27
0022ad 38b0                      	cpi r27, 0x80 //check for macro end flag
0022ae f489                      	brne sound_driver_instrument_routine_channel0_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_release:
0022af 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0022b0 93a0 283d                 	sts pulse1_hi_pitch_macro_offset, r26
0022b2 91b0 283f                 	lds r27, pulse1_hi_pitch_macro_release
0022b4 3fbf                      	cpi r27, 0xFF
0022b5 f439                      	brne sound_driver_instrument_routine_channel0_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_loop:
0022b6 91b0 283e                 	lds r27, pulse1_hi_pitch_macro_loop //load the loop index
0022b8 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0022b9 f019                      	breq sound_driver_instrument_routine_channel0_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
0022ba 93b0 283d                 	sts pulse1_hi_pitch_macro_offset, r27 //store the loop index into the offset
0022bc cfd6                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_default:
0022bd 91b0 283a                 	lds r27, pulse1_total_hi_pitch_offset
0022bf c005                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate:
0022c0 91a0 283a                 	lds r26, pulse1_total_hi_pitch_offset //load the total hi pitch offset to change
0022c2 0fba                      	add r27, r26
0022c3 93b0 283a                 	sts pulse1_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply:
0022c5 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0022c6 937f                      	push r23
0022c7 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
0022c8 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0022c9 0367                      	mulsu r22, r23
0022ca 917f                      	pop r23
0022cb 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_offset:
0022cc 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
0022ce 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
0022d0 0da0                      	add r26, r0 //offset the timer values
0022d1 1db1                      	adc r27, r1
0022d2 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
0022d4 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel0_duty:
0022d6 91e0 2840                 	lds ZL, pulse1_duty_macro
0022d8 91f0 2841                 	lds ZH, pulse1_duty_macro+1
0022da 9630                      	adiw Z, 0
0022db f1b1                      	breq sound_driver_channel0_fx_routines //if no duty macro is in use, go to the next routine
0022dc 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0022dd 1fff                      	rol ZH
0022de 91a0 2842                 	lds r26, pulse1_duty_macro_offset
0022e0 0fea                      	add ZL, r26
0022e1 1df2                      	adc ZH, zero
                                 
0022e2 91b0 2844                 	lds r27, pulse1_duty_macro_release
0022e4 17ba                      	cp r27, r26
0022e5 f429                      	brne sound_driver_instrument_routine_channel0_duty_increment //if the current offset is not equal to the release index, increment the offset
0022e6 91a0 2843                 	lds r26, pulse1_duty_macro_loop
0022e8 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0022e9 f010                      	brlo sound_driver_instrument_routine_channel0_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0022ea c027                      	rjmp sound_driver_channel0_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel0_duty_increment:
0022eb 95a3                      	inc r26 //increment the macro offset
0022ec 93a0 2842                 	sts pulse1_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_duty_read:
0022ee 91b4                      	lpm r27, Z //load pitch data into r27
0022ef 3fbf                      	cpi r27, 0xFF //check for macro end flag
0022f0 f471                      	brne sound_driver_instrument_routine_channel0_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_release:
0022f1 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0022f2 93a0 2842                 	sts pulse1_duty_macro_offset, r26
0022f4 91b0 2844                 	lds r27, pulse1_duty_macro_release
0022f6 3fbf                      	cpi r27, 0xFF
0022f7 f4d1                      	brne sound_driver_channel0_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_loop:
0022f8 91b0 2843                 	lds r27, pulse1_duty_macro_loop //load the loop index
0022fa 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0022fb f0b1                      	breq sound_driver_channel0_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
0022fc 93b0 2842                 	sts pulse1_duty_macro_offset, r27 //store the loop index into the offset
0022fe cfd7                      	rjmp sound_driver_instrument_routine_channel0_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_load:
0022ff e9e0                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
002300 e5fb                      	ldi ZH, HIGH(sequences << 1)
002301 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
002302 1df2                      	adc ZH, zero
                                 
002303 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
002304 95b7                      	ror r27
002305 95b7                      	ror r27
002306 91a0 2800                 	lds r26, pulse1_param //load r26 with pulse1_param (register $4000)
002308 2fca                      	mov r28, r26 //store a copy of pulse1_param into r28
002309 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
00230a 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
00230b c001                      	rjmp sound_driver_instrument_routine_channel0_duty_load_store
00230c c005                      	rjmp sound_driver_channel0_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel0_duty_load_store:
00230d 90a4                      	lpm pulse1_sequence, Z //store the sequence
                                 
00230e 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
00230f 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
002310 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_routines:
                                 sound_driver_channel0_fx_1xx_routine:
002312 91e0 2847                 	lds ZL, pulse1_fx_1xx
002314 91f0 2848                 	lds ZH, pulse1_fx_1xx+1
002316 9630                      	adiw Z, 0
002317 f051                      	breq sound_driver_channel0_fx_2xx_routine
                                 
002318 91a0 2849                 	lds r26, pulse1_fx_1xx_total //load the rate to change the pitch by
00231a 91b0 284a                 	lds r27, pulse1_fx_1xx_total+1
00231c 0fae                      	add r26, ZL //increase the total offset by the rate
00231d 1fbf                      	adc r27, ZH
00231e 93a0 2849                 	sts pulse1_fx_1xx_total, r26
002320 93b0 284a                 	sts pulse1_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_2xx_routine:
002322 91e0 284b                 	lds ZL, pulse1_fx_2xx
002324 91f0 284c                 	lds ZH, pulse1_fx_2xx+1
002326 9630                      	adiw Z, 0
002327 f051                      	breq sound_driver_channel0_fx_3xx_routine
                                 
002328 91a0 284d                 	lds r26, pulse1_fx_2xx_total //load the rate to change the pitch by
00232a 91b0 284e                 	lds r27, pulse1_fx_2xx_total+1
00232c 0fae                      	add r26, ZL //increase the total offset by the rate
00232d 1fbf                      	adc r27, ZH
00232e 93a0 284d                 	sts pulse1_fx_2xx_total, r26
002330 93b0 284e                 	sts pulse1_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_3xx_routine:
002332 91e0 2853                 	lds ZL, pulse1_fx_3xx_speed
002334 91f0 2854                 	lds ZH, pulse1_fx_3xx_speed+1
002336 9630                      	adiw Z, 0
002337 f409                      	brne sound_driver_channel0_fx_3xx_routine_check_start
002338 c048                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_check_start:
002339 91a0 284f                 	lds r26, pulse1_fx_3xx_start
00233b 91b0 2850                 	lds r27, pulse1_fx_3xx_start+1
00233d 9610                      	adiw r26:r27, 0
00233e f409                      	brne sound_driver_channel0_fx_3xx_routine_main
00233f c041                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_main:
002340 91c0 2851                 	lds r28, pulse1_fx_3xx_target
002342 91d0 2852                 	lds r29, pulse1_fx_3xx_target+1
                                 
002344 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
002345 07bd                      	cpc r27, r29
002346 f011                      	breq sound_driver_channel0_fx_3xx_routine_disable
002347 f030                      	brlo sound_driver_channel0_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002348 c01f                      	rjmp sound_driver_channel0_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel0_fx_3xx_routine_disable:
002349 9220 284f                 	sts pulse1_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
00234b 9220 2850                 	sts pulse1_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
00234d c033                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_subtract:
00234e 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
00234f 0bdb                      	sbc r29, r27
002350 91a0 2855                 	lds r26, pulse1_fx_3xx_total_offset
002352 91b0 2856                 	lds r27, pulse1_fx_3xx_total_offset+1
                                 
002354 0fae                      	add r26, ZL //add the speed to the total offset
002355 1fbf                      	adc r27, ZH
002356 1bca                      	sub r28, r26 //invert the total difference with the total offset
002357 0bdb                      	sbc r29, r27
002358 f380                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002359 93a0 2855                 	sts pulse1_fx_3xx_total_offset, r26 //store the new total offset
00235b 93b0 2856                 	sts pulse1_fx_3xx_total_offset+1, r27
                                 
00235d 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the current timer period
00235f 91b0 0a8d                 	lds r27, TCB0_CCMPH
002361 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002362 0bbd                      	sbc r27, r29
002363 93a0 0a8c                 	sts TCB0_CCMPL, r26
002365 93b0 0a8d                 	sts TCB0_CCMPH, r27
002367 c019                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_add:
002368 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002369 0bbd                      	sbc r27, r29
00236a 91c0 2855                 	lds r28, pulse1_fx_3xx_total_offset
00236c 91d0 2856                 	lds r29, pulse1_fx_3xx_total_offset+1
                                 
00236e 0fce                      	add r28, ZL //add the speed to the total offset
00236f 1fdf                      	adc r29, ZH
002370 1bac                      	sub r26, r28 //invert the total difference with the total offset
002371 0bbd                      	sbc r27, r29
002372 f2b0                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002373 93c0 2855                 	sts pulse1_fx_3xx_total_offset, r28 //store the new total offset
002375 93d0 2856                 	sts pulse1_fx_3xx_total_offset+1, r29
                                 
002377 91c0 0a8c                 	lds r28, TCB0_CCMPL //load the current timer period
002379 91d0 0a8d                 	lds r29, TCB0_CCMPH
00237b 0fca                      	add r28, r26 //offset the current timer period with the total offset
00237c 1fdb                      	adc r29, r27
00237d 93c0 0a8c                 	sts TCB0_CCMPL, r28
00237f 93d0 0a8d                 	sts TCB0_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel0_fx_4xy_routine:
002381 91a0 2857                 	lds r26, pulse1_fx_4xy_speed
002383 15a2                      	cp r26, zero
002384 f409                      	brne sound_driver_channel0_fx_4xy_routine_continue
002385 c05c                      	rjmp sound_driver_channel0_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel0_fx_4xy_routine_continue:
002386 91b0 2858                 	lds r27, pulse1_fx_4xy_depth
002388 91c0 2859                 	lds r28, pulse1_fx_4xy_phase
00238a 0fca                      	add r28, r26 //increase the phase by the speed
00238b 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
00238c f008                      	brlo sound_driver_channel0_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
00238d e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase:
00238e 93c0 2859                 	sts pulse1_fx_4xy_phase, r28 //store the new phase
002390 31c0                      	cpi r28, 16
002391 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_0
002392 32c0                      	cpi r28, 32
002393 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_1
002394 33c0                      	cpi r28, 48
002395 f030                      	brlo sound_driver_channel0_fx_4xy_routine_phase_2
002396 c007                      	rjmp sound_driver_channel0_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_0:
002397 70cf                      	andi r28, 0x0F //mask for values 0-15
002398 c029                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_1:
002399 6fc0                      	ori r28, 0xF0
00239a 95c0                      	com r28 //invert values 0-15
00239b c026                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_2:
00239c 70cf                      	andi r28, 0x0F //mask for values 0-15
00239d c003                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_3:
00239e 6fc0                      	ori r28, 0xF0
00239f 95c0                      	com r28 //invert values 0-15
0023a0 c000                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_add:
0023a1 95b2                      	swap r27 //multiply depth by 16
0023a2 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0023a3 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0023a4 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0023a5 0fec                      	add ZL, r28 //offset the table by the depth+phase
0023a6 1df2                      	adc ZH, zero
0023a7 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
0023a8 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0023a9 937f                      	push r23
0023aa 2f6c                      	mov r22, r28 //store the vibrato value into r22
0023ab eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0023ac 9f67                      	mul r22, r23
0023ad 917f                      	pop r23
0023ae 916f                      	pop r22
                                 
0023af 9416                      	lsr r1 //shift out the fractional bits
0023b0 9407                      	ror r0
0023b1 9416                      	lsr r1
0023b2 9407                      	ror r0
0023b3 9416                      	lsr r1
0023b4 9407                      	ror r0
0023b5 9416                      	lsr r1
0023b6 9407                      	ror r0
                                 	
0023b7 91a0 0a8c                 	lds r26, TCB0_CCMPL
0023b9 91b0 0a8d                 	lds r27, TCB0_CCMPH
0023bb 0da0                      	add r26, r0
0023bc 1db1                      	adc r27, r1
0023bd 93a0 0a8c                 	sts TCB0_CCMPL, r26
0023bf 93b0 0a8d                 	sts TCB0_CCMPH, r27
0023c1 c020                      	rjmp sound_driver_channel0_fx_7xy_routine
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_subtract:
0023c2 95b2                      	swap r27 //multiply depth by 16
0023c3 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
0023c4 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0023c5 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0023c6 0fec                      	add ZL, r28 //offset the table by the depth+phase
0023c7 1df2                      	adc ZH, zero
0023c8 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
0023c9 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0023ca 937f                      	push r23
0023cb 2f6c                      	mov r22, r28 //store the vibrato value into r22
0023cc eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0023cd 9f67                      	mul r22, r23
0023ce 917f                      	pop r23
0023cf 916f                      	pop r22
                                 
0023d0 9416                      	lsr r1 //shift out the fractional bits
0023d1 9407                      	ror r0
0023d2 9416                      	lsr r1
0023d3 9407                      	ror r0
0023d4 9416                      	lsr r1
0023d5 9407                      	ror r0
0023d6 9416                      	lsr r1
0023d7 9407                      	ror r0
                                 
0023d8 91a0 0a8c                 	lds r26, TCB0_CCMPL
0023da 91b0 0a8d                 	lds r27, TCB0_CCMPH
0023dc 19a0                      	sub r26, r0
0023dd 09b1                      	sbc r27, r1
0023de 93a0 0a8c                 	sts TCB0_CCMPL, r26
0023e0 93b0 0a8d                 	sts TCB0_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_7xy_routine:
0023e2 91a0 285a                 	lds r26, pulse1_fx_7xy_speed
0023e4 15a2                      	cp r26, zero
0023e5 f0e9                      	breq sound_driver_channel0_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
0023e6 91b0 285b                 	lds r27, pulse1_fx_7xy_depth
0023e8 91c0 285c                 	lds r28, pulse1_fx_7xy_phase
0023ea 0fca                      	add r28, r26 //increase the phase by the speed
0023eb 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
0023ec f008                      	brlo sound_driver_channel0_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
0023ed e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase:
0023ee 93c0 285c                 	sts pulse1_fx_7xy_phase, r28 //store the new phase
0023f0 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
0023f1 ffc4                      	sbrs r28, 4
0023f2 c001                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_0
0023f3 c002                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel0_fx_7xy_routine_phase_0:
0023f4 70cf                      	andi r28, 0x0F //mask for values 0-15
0023f5 c003                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase_1:
0023f6 6fc0                      	ori r28, 0xF0
0023f7 95c0                      	com r28 //invert values 0-15
0023f8 c000                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_load:
0023f9 95b2                      	swap r27 //multiply depth by 16
0023fa 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0023fb e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0023fc e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0023fd 0fec                      	add ZL, r28 //offset the table by the depth+phase
0023fe 1df2                      	adc ZH, zero
0023ff 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002400 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
002401 93c0 285d                 	sts pulse1_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Axy_routine:
002403 91b0 285e                 	lds r27, pulse1_fx_Axy
002405 15b2                      	cp r27, zero
002406 f0e9                      	breq sound_driver_channel0_fx_Qxy_routine //0 means that the effect is not in use
                                 	
002407 91a0 2805                 	lds r26, pulse1_fractional_volume //load fractional volume representation of the channel
002409 91c0 2800                 	lds r28, pulse1_param //load the integer volume representation of the channel
00240b 2fda                      	mov r29, r26 //copy fractional volume into r29
00240c 2fec                      	mov r30, r28 //copy the pulse1_param into r30
00240d 95e2                      	swap r30
00240e 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
00240f 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
002410 17ed                      	cp r30, r29 //compare the fractional and integer volumes
002411 f009                      	breq sound_driver_channel0_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel0_fx_Axy_routine_reload:
002412 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate:
002413 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
002414 c004                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_addition:
002415 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002416 f428                      	brcc sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002417 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
002418 c003                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_subtraction:
002419 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
00241a f008                      	brcs sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
00241b e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_store:
00241c 93a0 2805                 	sts pulse1_fractional_volume, r26 //store the new fractional volume
00241e 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
00241f 95a2                      	swap r26
002420 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
002421 2bca                      	or r28, r26 //store the new volume back into pulse1_param
002422 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel0_fx_Qxy_routine:
002424 91e0 2864                 	lds ZL, pulse1_fx_Qxy_target
002426 91f0 2865                 	lds ZH, pulse1_fx_Qxy_target+1
002428 9630                      	adiw Z, 0
002429 f119                      	breq sound_driver_channel0_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
00242a 91a0 2868                 	lds r26, pulse1_fx_Qxy_total_offset
00242c 91b0 2869                 	lds r27, pulse1_fx_Qxy_total_offset+1
00242e 91c0 0a8c                 	lds r28, TCB0_CCMPL
002430 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
002432 1bec                      	sub ZL, r28 //calculate the difference to the target
002433 0bfd                      	sbc ZH, r29
002434 f408                      	brsh sound_driver_channel0_fx_Qxy_routine_end //if the target has been reached (or passed)
002435 f068                      	brlo sound_driver_channel0_fx_Qxy_routine_add
                                 
                                 sound_driver_channel0_fx_Qxy_routine_end:
002436 9220 2868                 	sts pulse1_fx_Qxy_total_offset, zero //turn off the effect
002438 9220 2869                 	sts pulse1_fx_Qxy_total_offset+1, zero
00243a 9220 2864                 	sts pulse1_fx_Qxy_target, zero
00243c 9220 2865                 	sts pulse1_fx_Qxy_target+1, zero
00243e 91b0 2863                 	lds r27, pulse1_fx_Qxy_target_note
002440 93b0 2807                 	sts pulse1_note, r27 //replace the note with the final target note
002442 c00a                      	rjmp sound_driver_channel0_fx_Rxy_routine
                                 
                                 sound_driver_channel0_fx_Qxy_routine_add:
002443 91c0 2866                 	lds r28, pulse1_fx_Qxy_speed
002445 91d0 2867                 	lds r29, pulse1_fx_Qxy_speed+1
002447 0fac                      	add r26, r28 //increase the total offset by the speed
002448 1fbd                      	adc r27, r29
002449 93a0 2868                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
00244b 93b0 2869                 	sts pulse1_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Rxy_routine:
00244d 91e0 286b                 	lds ZL, pulse1_fx_Rxy_target
00244f 91f0 286c                 	lds ZH, pulse1_fx_Rxy_target+1
002451 9630                      	adiw Z, 0
002452 f119                      	breq sound_driver_instrument_routine_channel1_volume //if the effect is not enabled, skip the routine
                                 
002453 91a0 286f                 	lds r26, pulse1_fx_Rxy_total_offset
002455 91b0 2870                 	lds r27, pulse1_fx_Rxy_total_offset+1
002457 91c0 0a8c                 	lds r28, TCB0_CCMPL
002459 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
00245b 1bce                      	sub r28, ZL //calculate the difference to the target
00245c 0bdf                      	sbc r29, ZH
00245d f408                      	brsh sound_driver_channel0_fx_Rxy_routine_end //if the target has been reached (or passed)
00245e f068                      	brlo sound_driver_channel0_fx_Rxy_routine_add
                                 
                                 sound_driver_channel0_fx_Rxy_routine_end:
00245f 9220 286f                 	sts pulse1_fx_Rxy_total_offset, zero //disable the effect
002461 9220 2870                 	sts pulse1_fx_Rxy_total_offset+1, zero
002463 9220 286b                 	sts pulse1_fx_Rxy_target, zero
002465 9220 286c                 	sts pulse1_fx_Rxy_target+1, zero
002467 91b0 286a                 	lds r27, pulse1_fx_Rxy_target_note
002469 93b0 2807                 	sts pulse1_note, r27 //replace the note with the final target note
00246b c00a                      	rjmp sound_driver_instrument_routine_channel1_volume
                                 
                                 sound_driver_channel0_fx_Rxy_routine_add:
00246c 91c0 286d                 	lds r28, pulse1_fx_Rxy_speed
00246e 91d0 286e                 	lds r29, pulse1_fx_Rxy_speed+1
002470 0fac                      	add r26, r28 //increase the total offset by the speed
002471 1fbd                      	adc r27, r29
002472 93a0 286f                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
002474 93b0 2870                 	sts pulse1_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume:
002476 91e0 2879                 	lds ZL, pulse2_volume_macro
002478 91f0 287a                 	lds ZH, pulse2_volume_macro+1
00247a 9630                      	adiw Z, 0
00247b f1a1                      	breq sound_driver_instrument_routine_channel1_volume_default //if no volume macro is in use, use default multiplier of F
00247c 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
00247d 1fff                      	rol ZH
00247e 91a0 287b                 	lds r26, pulse2_volume_macro_offset
002480 0fea                      	add ZL, r26
002481 1df2                      	adc ZH, zero
                                 
002482 91b0 287d                 	lds r27, pulse2_volume_macro_release
002484 17ba                      	cp r27, r26
002485 f429                      	brne sound_driver_instrument_routine_channel1_volume_increment //if the current offset is not equal to the release index, increment the offset
002486 91a0 287c                 	lds r26, pulse2_volume_macro_loop
002488 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002489 f010                      	brlo sound_driver_instrument_routine_channel1_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00248a c003                      	rjmp sound_driver_instrument_routine_channel1_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_volume_increment:
00248b 95a3                      	inc r26 //increment the macro offset
00248c 93a0 287b                 	sts pulse2_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_volume_read:
00248e 91b4                      	lpm r27, Z //load volume data into r27
00248f 3fbf                      	cpi r27, 0xFF //check for macro end flag
002490 f469                      	brne sound_driver_instrument_routine_channel1_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_release:
002491 91b0 287d                 	lds r27, pulse2_volume_macro_release
002493 3fbf                      	cpi r27, 0xFF
002494 f429                      	brne sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_loop:
002495 91b0 287c                 	lds r27, pulse2_volume_macro_loop //load the loop index
002497 93b0 287b                 	sts pulse2_volume_macro_offset, r27 //store the loop index into the offset
002499 cfdc                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index:
00249a 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
00249b 93a0 287b                 	sts pulse2_volume_macro_offset, r26
00249d cfd8                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_calculate:
00249e e6e4                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
00249f e5fc                      	ldi ZH, HIGH(volumes << 1)
0024a0 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
0024a1 0feb                      	add ZL, r27 //add offset to the table
0024a2 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel1_volume_load:
0024a3 91b0 2808                 	lds r27, pulse2_param //load main volume
0024a5 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
0024a6 91a0 28ae                 	lds r26, pulse2_fx_7xy_value
0024a8 30a0                      	cpi r26, 0x00
0024a9 f481                      	brne sound_driver_instrument_routine_channel1_volume_load_7xy
                                 
0024aa 0feb                      	add ZL, r27 //offset the volume table by the main volume
0024ab 1df2                      	adc ZH, zero
0024ac 91b4                      	lpm r27, Z
0024ad 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
0024af c023                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default:
0024b0 91b0 2808                 	lds r27, pulse2_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
0024b2 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
0024b3 91a0 28ae                 	lds r26, pulse2_fx_7xy_value
0024b5 30a0                      	cpi r26, 0x00
0024b6 f499                      	brne sound_driver_instrument_routine_channel1_volume_default_7xy
0024b7 93b0 280e                 	sts pulse2_output_volume, r27
0024b9 c019                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy:
0024ba 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
0024bb f038                      	brcs sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
0024bc f031                      	breq sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
                                 
0024bd 0feb                      	add ZL, r27 //offset the volume table by the main volume
0024be 1df2                      	adc ZH, zero
0024bf 91b4                      	lpm r27, Z
0024c0 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
0024c2 c010                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy_overflow:
0024c3 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
0024c4 0feb                      	add ZL, r27 //offset the volume table by the main volume
0024c5 1df2                      	adc ZH, zero
0024c6 91b4                      	lpm r27, Z
0024c7 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
0024c9 c009                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default_7xy:
0024ca 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
0024cb f020                      	brcs sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
0024cc f019                      	breq sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
0024cd 93b0 280e                 	sts pulse2_output_volume, r27
0024cf c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel1_volume_default_7xy_overflow:
0024d0 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
0024d1 93b0 280e                 	sts pulse2_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
0024d3 91e0 287e                 	lds ZL, pulse2_arpeggio_macro
0024d5 91f0 287f                 	lds ZH, pulse2_arpeggio_macro+1
0024d7 9630                      	adiw Z, 0
0024d8 f1d9                      	breq sound_driver_instrument_routine_channel1_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
0024d9 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0024da 1fff                      	rol ZH
0024db 91a0 2880                 	lds r26, pulse2_arpeggio_macro_offset
0024dd 0fea                      	add ZL, r26
0024de 1df2                      	adc ZH, zero
                                 
0024df 91b0 2882                 	lds r27, pulse2_arpeggio_macro_release
0024e1 17ba                      	cp r27, r26
0024e2 f429                      	brne sound_driver_instrument_routine_channel1_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
0024e3 91a0 2881                 	lds r26, pulse2_arpeggio_macro_loop
0024e5 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0024e6 f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
0024e7 c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_increment:
0024e8 95a3                      	inc r26 //increment the macro offset
0024e9 93a0 2880                 	sts pulse2_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_read:
0024eb 91b4                      	lpm r27, Z //load arpeggio data into r27
0024ec 38b0                      	cpi r27, 0x80 //check for macro end flag
0024ed f009                      	breq sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag
0024ee c041                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_check_mode:
0024ef 50a1                      	subi r26, 1 //keep the offset at the end flag
0024f0 93a0 2880                 	sts pulse2_arpeggio_macro_offset, r26
0024f2 91b0 2883                 	lds r27, pulse2_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
0024f4 30b1                      	cpi r27, 0x01
0024f5 f048                      	brlo sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_release:
0024f6 91b0 2882                 	lds r27, pulse2_arpeggio_macro_release
0024f8 3fbf                      	cpi r27, 0xFF
0024f9 f4d1                      	brne sound_driver_instrument_routine_channel1_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_loop:
0024fa 91b0 2881                 	lds r27, pulse2_arpeggio_macro_loop
0024fc 3fbf                      	cpi r27, 0xFF
0024fd f499                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
0024fe c015                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute:
0024ff 91b0 2882                 	lds r27, pulse2_arpeggio_macro_release
002501 3fbf                      	cpi r27, 0xFF
002502 f421                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_check_loop:
002503 91b0 2881                 	lds r27, pulse2_arpeggio_macro_loop //load the loop index
002505 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002506 f451                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop:
002507 91c0 2896                 	lds r28, pulse2_fx_0xy_sequence //check for 0xy effect
002509 91d0 2897                 	lds r29, pulse2_fx_0xy_sequence+1
00250b 9620                      	adiw r29:r28, 0
00250c f469                      	brne sound_driver_instrument_routine_channel1_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
00250d 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
00250e 93a0 2880                 	sts pulse2_arpeggio_macro_offset, r26 //store the last valid index into the offset
002510 cfc2                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload:
002511 93b0 2880                 	sts pulse2_arpeggio_macro_offset, r27 //store the loop index into the offset
002513 cfbf                      	rjmp sound_driver_instrument_routine_channel1_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_default:
002514 91c0 2896                 	lds r28, pulse2_fx_0xy_sequence //load 0xy effect
002516 91d0 2897                 	lds r29, pulse2_fx_0xy_sequence+1
002518 9620                      	adiw r29:r28, 0 //check for 0xy effect
002519 f099                      	breq sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel1_arpeggio_default_0xy:
00251a 95d6                      	lsr r29
00251b 95c7                      	ror r28
00251c 95d7                      	ror r29
00251d 95c7                      	ror r28
00251e 95d7                      	ror r29
00251f 95c7                      	ror r28
002520 95d7                      	ror r29
002521 95c7                      	ror r28
002522 95d7                      	ror r29
002523 95d2                      	swap r29
                                 
002524 93c0 2896                 	sts pulse2_fx_0xy_sequence, r28 //store the rolled sequence
002526 93d0 2897                 	sts pulse2_fx_0xy_sequence+1, r29
002528 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002529 91a0 280f                 	lds r26, pulse2_note //load the current note index
00252b 0fac                      	add r26, r28 //add the note offset
00252c c02e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
00252d 91a0 280f                 	lds r26, pulse2_note //load the current note index
00252f c02b                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process:
002530 9220 2884                 	sts pulse2_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002532 9220 2885                 	sts pulse2_total_pitch_offset+1, zero
002534 9220 288b                 	sts pulse2_total_hi_pitch_offset, zero
002536 91a0 2883                 	lds r26, pulse2_arpeggio_macro_mode
002538 30a1                      	cpi r26, 0x01 //absolute mode
002539 f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_absolute
00253a f069                      	breq sound_driver_instrument_routine_channel1_arpeggio_process_fixed
00253b c00e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute:
00253c 91a0 280f                 	lds r26, pulse2_note //load the current note index
00253e 0fab                      	add r26, r27 //offset the note with the arpeggio data
00253f fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002540 c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_add:
002541 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002542 f0c0                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
002543 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002544 c016                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract:
002545 fda7                      	sbrc r26, 7 //check if result is negative
002546 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002547 c013                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_fixed:
002548 2fab                      	mov r26, r27 //move the arpeggio data into r26
002549 c011                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative:
00254a 91a0 280f                 	lds r26, pulse2_note //load the current note index
00254c 0fab                      	add r26, r27 //offset the note with the arpeggio data
00254d fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
00254e c008                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_add:
00254f 93a0 280f                 	sts pulse2_note, r26 //NOTE: relative mode modifies the original note index
002551 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002552 f040                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
002553 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002554 93a0 280f                 	sts pulse2_note, r26
002556 c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract:
002557 fda7                      	sbrc r26, 7 //check if result is negative
002558 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002559 93a0 280f                 	sts pulse2_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_load:
00255b e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
00255c e0f0                      	ldi ZH, HIGH(note_table << 1)
00255d 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
00255e 0fea                      	add ZL, r26 //add offset
00255f 1df2                      	adc ZH, zero
002560 91a5                      	lpm r26, Z+ //load bytes
002561 91b4                      	lpm r27, Z
002562 93a0 0a9c                 	sts TCB1_CCMPL, r26 //load the LOW bits for timer
002564 93b0 0a9d                 	sts TCB1_CCMPH, r27 //load the HIGH bits for timer
002566 93a0 28a2                 	sts pulse2_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002568 93b0 28a3                 	sts pulse2_fx_3xx_target+1, r27
00256a c000                      	rjmp sound_driver_instrument_routine_channel1_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch:
00256b 91e0 2886                 	lds ZL, pulse2_pitch_macro
00256d 91f0 2887                 	lds ZH, pulse2_pitch_macro+1
00256f 9630                      	adiw Z, 0
002570 f409                      	brne sound_driver_instrument_routine_channel1_pitch_continue
002571 c023                      	rjmp sound_driver_instrument_routine_channel1_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel1_pitch_continue:
002572 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002573 1fff                      	rol ZH
002574 91a0 2888                 	lds r26, pulse2_pitch_macro_offset
002576 0fea                      	add ZL, r26
002577 1df2                      	adc ZH, zero
                                 
002578 91b0 288a                 	lds r27, pulse2_pitch_macro_release
00257a 17ba                      	cp r27, r26
00257b f429                      	brne sound_driver_instrument_routine_channel1_pitch_increment //if the current offset is not equal to the release index, increment the offset
00257c 91a0 2889                 	lds r26, pulse2_pitch_macro_loop
00257e 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00257f f010                      	brlo sound_driver_instrument_routine_channel1_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002580 c003                      	rjmp sound_driver_instrument_routine_channel1_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_pitch_increment:
002581 95a3                      	inc r26 //increment the macro offset
002582 93a0 2888                 	sts pulse2_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_pitch_read:
002584 91b4                      	lpm r27, Z //load pitch data into r27
002585 38b0                      	cpi r27, 0x80 //check for macro end flag
002586 f479                      	brne sound_driver_instrument_routine_channel1_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_release:
002587 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002588 93a0 2888                 	sts pulse2_pitch_macro_offset, r26
00258a 91b0 288a                 	lds r27, pulse2_pitch_macro_release
00258c 3fbf                      	cpi r27, 0xFF
00258d f439                      	brne sound_driver_instrument_routine_channel1_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_loop:
00258e 91b0 2889                 	lds r27, pulse2_pitch_macro_loop //load the loop index
002590 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002591 f019                      	breq sound_driver_instrument_routine_channel1_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002592 93b0 2888                 	sts pulse2_pitch_macro_offset, r27 //store the loop index into the offset
002594 cfd6                      	rjmp sound_driver_instrument_routine_channel1_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_default:
002595 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel1_pitch_calculate:
002596 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002597 937f                      	push r23
002598 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
002599 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00259a 0367                      	mulsu r22, r23
00259b 917f                      	pop r23
00259c 916f                      	pop r22
                                 
00259d 9416                      	lsr r1 //shift out the fractional bits
00259e 9407                      	ror r0
00259f 9416                      	lsr r1
0025a0 9407                      	ror r0
0025a1 9416                      	lsr r1
0025a2 9407                      	ror r0
0025a3 9416                      	lsr r1
0025a4 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_check_negative:
0025a5 fe13                      	sbrs r1, 3 //check if result was a negative number
0025a6 c007                      	rjmp sound_driver_instrument_routine_channel1_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_negative:
0025a7 efc0                      	ldi r28, 0xF0
0025a8 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_check_divisible_8:
0025a9 70b7                      	andi r27, 0b00000111
0025aa f019                      	breq sound_driver_instrument_routine_channel1_pitch_calculate_offset
                                 
0025ab e0b1                      	ldi r27, 0x01
0025ac 0e0b                      	add r0, r27
0025ad 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_offset:
0025ae 91a0 2884                 	lds r26, pulse2_total_pitch_offset
0025b0 91b0 2885                 	lds r27, pulse2_total_pitch_offset+1
0025b2 0e0a                      	add r0, r26
0025b3 1e1b                      	adc r1, r27
0025b4 9200 2884                 	sts pulse2_total_pitch_offset, r0
0025b6 9210 2885                 	sts pulse2_total_pitch_offset+1, r1
0025b8 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
0025ba 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
0025bc 0da0                      	add r26, r0 //offset the timer values
0025bd 1db1                      	adc r27, r1
                                 	
0025be 91c0 289a                 	lds r28, pulse2_fx_1xx_total
0025c0 91d0 289b                 	lds r29, pulse2_fx_1xx_total+1
0025c2 1bac                      	sub r26, r28
0025c3 0bbd                      	sbc r27, r29
0025c4 91c0 289e                 	lds r28, pulse2_fx_2xx_total
0025c6 91d0 289f                 	lds r29, pulse2_fx_2xx_total+1
0025c8 0fac                      	add r26, r28
0025c9 1fbd                      	adc r27, r29
0025ca 91c0 28b2                 	lds r28, pulse2_fx_Pxx_total
0025cc 91d0 28b3                 	lds r29, pulse2_fx_Pxx_total+1
0025ce 0fac                      	add r26, r28
0025cf 1fbd                      	adc r27, r29
0025d0 91c0 28b9                 	lds r28, pulse2_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
0025d2 91d0 28ba                 	lds r29, pulse2_fx_Qxy_total_offset+1
0025d4 1bac                      	sub r26, r28
0025d5 0bbd                      	sbc r27, r29
0025d6 91c0 28c0                 	lds r28, pulse2_fx_Rxy_total_offset
0025d8 91d0 28c1                 	lds r29, pulse2_fx_Rxy_total_offset+1
0025da 0fac                      	add r26, r28
0025db 1fbd                      	adc r27, r29
                                 
0025dc 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
0025de 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel1_hi_pitch:
0025e0 91e0 288c                 	lds ZL, pulse2_hi_pitch_macro
0025e2 91f0 288d                 	lds ZH, pulse2_hi_pitch_macro+1
0025e4 9630                      	adiw Z, 0
0025e5 f409                      	brne sound_driver_instrument_routine_channel1_hi_pitch_continue
0025e6 c03c                      	rjmp sound_driver_instrument_routine_channel1_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel1_hi_pitch_continue:
0025e7 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0025e8 1fff                      	rol ZH
0025e9 91a0 288e                 	lds r26, pulse2_hi_pitch_macro_offset
0025eb 0fea                      	add ZL, r26
0025ec 1df2                      	adc ZH, zero
                                 
0025ed 91b0 2890                 	lds r27, pulse2_hi_pitch_macro_release
0025ef 17ba                      	cp r27, r26
0025f0 f429                      	brne sound_driver_instrument_routine_channel1_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
0025f1 91a0 288f                 	lds r26, pulse2_hi_pitch_macro_loop
0025f3 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0025f4 f010                      	brlo sound_driver_instrument_routine_channel1_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0025f5 c003                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_increment:
0025f6 95a3                      	inc r26 //increment the macro offset
0025f7 93a0 288e                 	sts pulse2_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_hi_pitch_read:
0025f9 91b4                      	lpm r27, Z //load hi pitch data into r27
0025fa 38b0                      	cpi r27, 0x80 //check for macro end flag
0025fb f489                      	brne sound_driver_instrument_routine_channel1_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_release:
0025fc 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0025fd 93a0 288e                 	sts pulse2_hi_pitch_macro_offset, r26
0025ff 91b0 2890                 	lds r27, pulse2_hi_pitch_macro_release
002601 3fbf                      	cpi r27, 0xFF
002602 f439                      	brne sound_driver_instrument_routine_channel1_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_loop:
002603 91b0 288f                 	lds r27, pulse2_hi_pitch_macro_loop //load the loop index
002605 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002606 f019                      	breq sound_driver_instrument_routine_channel1_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002607 93b0 288e                 	sts pulse2_hi_pitch_macro_offset, r27 //store the loop index into the offset
002609 cfd6                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_default:
00260a 91b0 288b                 	lds r27, pulse2_total_hi_pitch_offset
00260c c005                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate:
00260d 91a0 288b                 	lds r26, pulse2_total_hi_pitch_offset //load the total hi pitch offset to change
00260f 0fba                      	add r27, r26
002610 93b0 288b                 	sts pulse2_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply:
002612 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002613 937f                      	push r23
002614 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002615 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002616 0367                      	mulsu r22, r23
002617 917f                      	pop r23
002618 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_offset:
002619 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
00261b 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
00261d 0da0                      	add r26, r0 //offset the timer values
00261e 1db1                      	adc r27, r1
00261f 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
002621 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel1_duty:
002623 91e0 2891                 	lds ZL, pulse2_duty_macro
002625 91f0 2892                 	lds ZH, pulse2_duty_macro+1
002627 9630                      	adiw Z, 0
002628 f1b1                      	breq sound_driver_channel1_fx_routines //if no duty macro is in use, go to the next routine
002629 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00262a 1fff                      	rol ZH
00262b 91a0 2893                 	lds r26, pulse2_duty_macro_offset
00262d 0fea                      	add ZL, r26
00262e 1df2                      	adc ZH, zero
                                 
00262f 91b0 2895                 	lds r27, pulse2_duty_macro_release
002631 17ba                      	cp r27, r26
002632 f429                      	brne sound_driver_instrument_routine_channel1_duty_increment //if the current offset is not equal to the release index, increment the offset
002633 91a0 2894                 	lds r26, pulse2_duty_macro_loop
002635 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002636 f010                      	brlo sound_driver_instrument_routine_channel1_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002637 c027                      	rjmp sound_driver_channel1_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel1_duty_increment:
002638 95a3                      	inc r26 //increment the macro offset
002639 93a0 2893                 	sts pulse2_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_duty_read:
00263b 91b4                      	lpm r27, Z //load pitch data into r27
00263c 3fbf                      	cpi r27, 0xFF //check for macro end flag
00263d f471                      	brne sound_driver_instrument_routine_channel1_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_release:
00263e 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00263f 93a0 2893                 	sts pulse2_duty_macro_offset, r26
002641 91b0 2895                 	lds r27, pulse2_duty_macro_release
002643 3fbf                      	cpi r27, 0xFF
002644 f4d1                      	brne sound_driver_channel1_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_loop:
002645 91b0 2894                 	lds r27, pulse2_duty_macro_loop //load the loop index
002647 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002648 f0b1                      	breq sound_driver_channel1_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
002649 93b0 2893                 	sts pulse2_duty_macro_offset, r27 //store the loop index into the offset
00264b cfd7                      	rjmp sound_driver_instrument_routine_channel1_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_load:
00264c e9e0                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
00264d e5fb                      	ldi ZH, HIGH(sequences << 1)
00264e 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
00264f 1df2                      	adc ZH, zero
                                 
002650 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
002651 95b7                      	ror r27
002652 95b7                      	ror r27
002653 91a0 2808                 	lds r26, pulse2_param //load r26 with pulse2_param (register $4000)
002655 2fca                      	mov r28, r26 //store a copy of pulse2_param into r28
002656 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
002657 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
002658 c001                      	rjmp sound_driver_instrument_routine_channel1_duty_load_store
002659 c005                      	rjmp sound_driver_channel1_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel1_duty_load_store:
00265a 90d4                      	lpm pulse2_sequence, Z //store the sequence
                                 
00265b 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
00265c 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
00265d 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_routines:
                                 sound_driver_channel1_fx_1xx_routine:
00265f 91e0 2898                 	lds ZL, pulse2_fx_1xx
002661 91f0 2899                 	lds ZH, pulse2_fx_1xx+1
002663 9630                      	adiw Z, 0
002664 f051                      	breq sound_driver_channel1_fx_2xx_routine
                                 
002665 91a0 289a                 	lds r26, pulse2_fx_1xx_total //load the rate to change the pitch by
002667 91b0 289b                 	lds r27, pulse2_fx_1xx_total+1
002669 0fae                      	add r26, ZL //increase the total offset by the rate
00266a 1fbf                      	adc r27, ZH
00266b 93a0 289a                 	sts pulse2_fx_1xx_total, r26
00266d 93b0 289b                 	sts pulse2_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_2xx_routine:
00266f 91e0 289c                 	lds ZL, pulse2_fx_2xx
002671 91f0 289d                 	lds ZH, pulse2_fx_2xx+1
002673 9630                      	adiw Z, 0
002674 f051                      	breq sound_driver_channel1_fx_3xx_routine
                                 
002675 91a0 289e                 	lds r26, pulse2_fx_2xx_total //load the rate to change the pitch by
002677 91b0 289f                 	lds r27, pulse2_fx_2xx_total+1
002679 0fae                      	add r26, ZL //increase the total offset by the rate
00267a 1fbf                      	adc r27, ZH
00267b 93a0 289e                 	sts pulse2_fx_2xx_total, r26
00267d 93b0 289f                 	sts pulse2_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_3xx_routine:
00267f 91e0 28a4                 	lds ZL, pulse2_fx_3xx_speed
002681 91f0 28a5                 	lds ZH, pulse2_fx_3xx_speed+1
002683 9630                      	adiw Z, 0
002684 f409                      	brne sound_driver_channel1_fx_3xx_routine_check_start
002685 c048                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_check_start:
002686 91a0 28a0                 	lds r26, pulse2_fx_3xx_start
002688 91b0 28a1                 	lds r27, pulse2_fx_3xx_start+1
00268a 9610                      	adiw r26:r27, 0
00268b f409                      	brne sound_driver_channel1_fx_3xx_routine_main
00268c c041                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_main:
00268d 91c0 28a2                 	lds r28, pulse2_fx_3xx_target
00268f 91d0 28a3                 	lds r29, pulse2_fx_3xx_target+1
                                 
002691 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
002692 07bd                      	cpc r27, r29
002693 f011                      	breq sound_driver_channel1_fx_3xx_routine_disable
002694 f030                      	brlo sound_driver_channel1_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002695 c01f                      	rjmp sound_driver_channel1_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel1_fx_3xx_routine_disable:
002696 9220 28a0                 	sts pulse2_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002698 9220 28a1                 	sts pulse2_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
00269a c033                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_subtract:
00269b 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
00269c 0bdb                      	sbc r29, r27
00269d 91a0 28a6                 	lds r26, pulse2_fx_3xx_total_offset
00269f 91b0 28a7                 	lds r27, pulse2_fx_3xx_total_offset+1
                                 
0026a1 0fae                      	add r26, ZL //add the speed to the total offset
0026a2 1fbf                      	adc r27, ZH
0026a3 1bca                      	sub r28, r26 //invert the total difference with the total offset
0026a4 0bdb                      	sbc r29, r27
0026a5 f380                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0026a6 93a0 28a6                 	sts pulse2_fx_3xx_total_offset, r26 //store the new total offset
0026a8 93b0 28a7                 	sts pulse2_fx_3xx_total_offset+1, r27
                                 
0026aa 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the current timer period
0026ac 91b0 0a9d                 	lds r27, TCB1_CCMPH
0026ae 1bac                      	sub r26, r28 //offset the current timer period with the total offset
0026af 0bbd                      	sbc r27, r29
0026b0 93a0 0a9c                 	sts TCB1_CCMPL, r26
0026b2 93b0 0a9d                 	sts TCB1_CCMPH, r27
0026b4 c019                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_add:
0026b5 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
0026b6 0bbd                      	sbc r27, r29
0026b7 91c0 28a6                 	lds r28, pulse2_fx_3xx_total_offset
0026b9 91d0 28a7                 	lds r29, pulse2_fx_3xx_total_offset+1
                                 
0026bb 0fce                      	add r28, ZL //add the speed to the total offset
0026bc 1fdf                      	adc r29, ZH
0026bd 1bac                      	sub r26, r28 //invert the total difference with the total offset
0026be 0bbd                      	sbc r27, r29
0026bf f2b0                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0026c0 93c0 28a6                 	sts pulse2_fx_3xx_total_offset, r28 //store the new total offset
0026c2 93d0 28a7                 	sts pulse2_fx_3xx_total_offset+1, r29
                                 
0026c4 91c0 0a9c                 	lds r28, TCB1_CCMPL //load the current timer period
0026c6 91d0 0a9d                 	lds r29, TCB1_CCMPH
0026c8 0fca                      	add r28, r26 //offset the current timer period with the total offset
0026c9 1fdb                      	adc r29, r27
0026ca 93c0 0a9c                 	sts TCB1_CCMPL, r28
0026cc 93d0 0a9d                 	sts TCB1_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel1_fx_4xy_routine:
0026ce 91a0 28a8                 	lds r26, pulse2_fx_4xy_speed
0026d0 15a2                      	cp r26, zero
0026d1 f409                      	brne sound_driver_channel1_fx_4xy_routine_continue
0026d2 c05c                      	rjmp sound_driver_channel1_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel1_fx_4xy_routine_continue:
0026d3 91b0 28a9                 	lds r27, pulse2_fx_4xy_depth
0026d5 91c0 28aa                 	lds r28, pulse2_fx_4xy_phase
0026d7 0fca                      	add r28, r26 //increase the phase by the speed
0026d8 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
0026d9 f008                      	brlo sound_driver_channel1_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
0026da e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase:
0026db 93c0 28aa                 	sts pulse2_fx_4xy_phase, r28 //store the new phase
0026dd 31c0                      	cpi r28, 16
0026de f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_0
0026df 32c0                      	cpi r28, 32
0026e0 f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_1
0026e1 33c0                      	cpi r28, 48
0026e2 f030                      	brlo sound_driver_channel1_fx_4xy_routine_phase_2
0026e3 c007                      	rjmp sound_driver_channel1_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_0:
0026e4 70cf                      	andi r28, 0x0F //mask for values 0-15
0026e5 c029                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_1:
0026e6 6fc0                      	ori r28, 0xF0
0026e7 95c0                      	com r28 //invert values 0-15
0026e8 c026                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_2:
0026e9 70cf                      	andi r28, 0x0F //mask for values 0-15
0026ea c003                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_3:
0026eb 6fc0                      	ori r28, 0xF0
0026ec 95c0                      	com r28 //invert values 0-15
0026ed c000                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_add:
0026ee 95b2                      	swap r27 //multiply depth by 16
0026ef 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0026f0 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0026f1 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0026f2 0fec                      	add ZL, r28 //offset the table by the depth+phase
0026f3 1df2                      	adc ZH, zero
0026f4 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
0026f5 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0026f6 937f                      	push r23
0026f7 2f6c                      	mov r22, r28 //store the vibrato value into r22
0026f8 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0026f9 9f67                      	mul r22, r23
0026fa 917f                      	pop r23
0026fb 916f                      	pop r22
                                 
0026fc 9416                      	lsr r1 //shift out the fractional bits
0026fd 9407                      	ror r0
0026fe 9416                      	lsr r1
0026ff 9407                      	ror r0
002700 9416                      	lsr r1
002701 9407                      	ror r0
002702 9416                      	lsr r1
002703 9407                      	ror r0
                                 	
002704 91a0 0a9c                 	lds r26, TCB1_CCMPL
002706 91b0 0a9d                 	lds r27, TCB1_CCMPH
002708 0da0                      	add r26, r0
002709 1db1                      	adc r27, r1
00270a 93a0 0a9c                 	sts TCB1_CCMPL, r26
00270c 93b0 0a9d                 	sts TCB1_CCMPH, r27
00270e c020                      	rjmp sound_driver_channel1_fx_7xy_routine
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_subtract:
00270f 95b2                      	swap r27 //multiply depth by 16
002710 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002711 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002712 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002713 0fec                      	add ZL, r28 //offset the table by the depth+phase
002714 1df2                      	adc ZH, zero
002715 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002716 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002717 937f                      	push r23
002718 2f6c                      	mov r22, r28 //store the vibrato value into r22
002719 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00271a 9f67                      	mul r22, r23
00271b 917f                      	pop r23
00271c 916f                      	pop r22
                                 
00271d 9416                      	lsr r1 //shift out the fractional bits
00271e 9407                      	ror r0
00271f 9416                      	lsr r1
002720 9407                      	ror r0
002721 9416                      	lsr r1
002722 9407                      	ror r0
002723 9416                      	lsr r1
002724 9407                      	ror r0
                                 
002725 91a0 0a9c                 	lds r26, TCB1_CCMPL
002727 91b0 0a9d                 	lds r27, TCB1_CCMPH
002729 19a0                      	sub r26, r0
00272a 09b1                      	sbc r27, r1
00272b 93a0 0a9c                 	sts TCB1_CCMPL, r26
00272d 93b0 0a9d                 	sts TCB1_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_7xy_routine:
00272f 91a0 28ab                 	lds r26, pulse2_fx_7xy_speed
002731 15a2                      	cp r26, zero
002732 f0e9                      	breq sound_driver_channel1_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
002733 91b0 28ac                 	lds r27, pulse2_fx_7xy_depth
002735 91c0 28ad                 	lds r28, pulse2_fx_7xy_phase
002737 0fca                      	add r28, r26 //increase the phase by the speed
002738 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002739 f008                      	brlo sound_driver_channel1_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
00273a e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase:
00273b 93c0 28ad                 	sts pulse2_fx_7xy_phase, r28 //store the new phase
00273d 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
00273e ffc4                      	sbrs r28, 4
00273f c001                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_0
002740 c002                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel1_fx_7xy_routine_phase_0:
002741 70cf                      	andi r28, 0x0F //mask for values 0-15
002742 c003                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase_1:
002743 6fc0                      	ori r28, 0xF0
002744 95c0                      	com r28 //invert values 0-15
002745 c000                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_load:
002746 95b2                      	swap r27 //multiply depth by 16
002747 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002748 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002749 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00274a 0fec                      	add ZL, r28 //offset the table by the depth+phase
00274b 1df2                      	adc ZH, zero
00274c 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
00274d 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
00274e 93c0 28ae                 	sts pulse2_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Axy_routine:
002750 91b0 28af                 	lds r27, pulse2_fx_Axy
002752 15b2                      	cp r27, zero
002753 f0e9                      	breq sound_driver_channel1_fx_Qxy_routine //0 means that the effect is not in use
                                 	
002754 91a0 280d                 	lds r26, pulse2_fractional_volume //load fractional volume representation of the channel
002756 91c0 2808                 	lds r28, pulse2_param //load the integer volume representation of the channel
002758 2fda                      	mov r29, r26 //copy fractional volume into r29
002759 2fec                      	mov r30, r28 //copy the pulse2_param into r30
00275a 95e2                      	swap r30
00275b 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
00275c 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
00275d 17ed                      	cp r30, r29 //compare the fractional and integer volumes
00275e f009                      	breq sound_driver_channel1_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel1_fx_Axy_routine_reload:
00275f 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate:
002760 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
002761 c004                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_addition:
002762 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002763 f428                      	brcc sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002764 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
002765 c003                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_subtraction:
002766 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002767 f008                      	brcs sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002768 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_store:
002769 93a0 280d                 	sts pulse2_fractional_volume, r26 //store the new fractional volume
00276b 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
00276c 95a2                      	swap r26
00276d 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
00276e 2bca                      	or r28, r26 //store the new volume back into pulse2_param
00276f 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel1_fx_Qxy_routine:
002771 91e0 28b5                 	lds ZL, pulse2_fx_Qxy_target
002773 91f0 28b6                 	lds ZH, pulse2_fx_Qxy_target+1
002775 9630                      	adiw Z, 0
002776 f119                      	breq sound_driver_channel1_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002777 91a0 28b9                 	lds r26, pulse2_fx_Qxy_total_offset
002779 91b0 28ba                 	lds r27, pulse2_fx_Qxy_total_offset+1
00277b 91c0 0a9c                 	lds r28, TCB1_CCMPL
00277d 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
00277f 1bec                      	sub ZL, r28 //calculate the difference to the target
002780 0bfd                      	sbc ZH, r29
002781 f408                      	brsh sound_driver_channel1_fx_Qxy_routine_end //if the target has been reached (or passed)
002782 f068                      	brlo sound_driver_channel1_fx_Qxy_routine_add
                                 
                                 sound_driver_channel1_fx_Qxy_routine_end:
002783 9220 28b9                 	sts pulse2_fx_Qxy_total_offset, zero //turn off the effect
002785 9220 28ba                 	sts pulse2_fx_Qxy_total_offset+1, zero
002787 9220 28b5                 	sts pulse2_fx_Qxy_target, zero
002789 9220 28b6                 	sts pulse2_fx_Qxy_target+1, zero
00278b 91b0 28b4                 	lds r27, pulse2_fx_Qxy_target_note
00278d 93b0 280f                 	sts pulse2_note, r27 //replace the note with the final target note
00278f c00a                      	rjmp sound_driver_channel1_fx_Rxy_routine
                                 
                                 sound_driver_channel1_fx_Qxy_routine_add:
002790 91c0 28b7                 	lds r28, pulse2_fx_Qxy_speed
002792 91d0 28b8                 	lds r29, pulse2_fx_Qxy_speed+1
002794 0fac                      	add r26, r28 //increase the total offset by the speed
002795 1fbd                      	adc r27, r29
002796 93a0 28b9                 	sts pulse2_fx_Qxy_total_offset, r26 //store the total offset
002798 93b0 28ba                 	sts pulse2_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Rxy_routine:
00279a 91e0 28bc                 	lds ZL, pulse2_fx_Rxy_target
00279c 91f0 28bd                 	lds ZH, pulse2_fx_Rxy_target+1
00279e 9630                      	adiw Z, 0
00279f f119                      	breq sound_driver_instrument_routine_channel2_volume //if the effect is not enabled, skip the routine
                                 
0027a0 91a0 28c0                 	lds r26, pulse2_fx_Rxy_total_offset
0027a2 91b0 28c1                 	lds r27, pulse2_fx_Rxy_total_offset+1
0027a4 91c0 0a9c                 	lds r28, TCB1_CCMPL
0027a6 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
0027a8 1bce                      	sub r28, ZL //calculate the difference to the target
0027a9 0bdf                      	sbc r29, ZH
0027aa f408                      	brsh sound_driver_channel1_fx_Rxy_routine_end //if the target has been reached (or passed)
0027ab f068                      	brlo sound_driver_channel1_fx_Rxy_routine_add
                                 
                                 sound_driver_channel1_fx_Rxy_routine_end:
0027ac 9220 28c0                 	sts pulse2_fx_Rxy_total_offset, zero //disable the effect
0027ae 9220 28c1                 	sts pulse2_fx_Rxy_total_offset+1, zero
0027b0 9220 28bc                 	sts pulse2_fx_Rxy_target, zero
0027b2 9220 28bd                 	sts pulse2_fx_Rxy_target+1, zero
0027b4 91b0 28bb                 	lds r27, pulse2_fx_Rxy_target_note
0027b6 93b0 280f                 	sts pulse2_note, r27 //replace the note with the final target note
0027b8 c00a                      	rjmp sound_driver_instrument_routine_channel2_volume
                                 
                                 sound_driver_channel1_fx_Rxy_routine_add:
0027b9 91c0 28be                 	lds r28, pulse2_fx_Rxy_speed
0027bb 91d0 28bf                 	lds r29, pulse2_fx_Rxy_speed+1
0027bd 0fac                      	add r26, r28 //increase the total offset by the speed
0027be 1fbd                      	adc r27, r29
0027bf 93a0 28c0                 	sts pulse2_fx_Rxy_total_offset, r26 //store the total offset
0027c1 93b0 28c1                 	sts pulse2_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume:
0027c3 91e0 28ca                 	lds ZL, triangle_volume_macro
0027c5 91f0 28cb                 	lds ZH, triangle_volume_macro+1
0027c7 9630                      	adiw Z, 0
0027c8 f199                      	breq sound_driver_instrument_routine_channel2_volume_default //if no volume macro is in use, do nothing
0027c9 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0027ca 1fff                      	rol ZH
0027cb 91a0 28cc                 	lds r26, triangle_volume_macro_offset
0027cd 0fea                      	add ZL, r26
0027ce 1df2                      	adc ZH, zero
                                 
0027cf 91b0 28ce                 	lds r27, triangle_volume_macro_release
0027d1 17ba                      	cp r27, r26
0027d2 f429                      	brne sound_driver_instrument_routine_channel2_volume_increment //if the current offset is not equal to the release index, increment the offset
0027d3 91a0 28cd                 	lds r26, triangle_volume_macro_loop
0027d5 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0027d6 f010                      	brlo sound_driver_instrument_routine_channel2_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0027d7 c003                      	rjmp sound_driver_instrument_routine_channel2_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_volume_increment:
0027d8 95a3                      	inc r26 //increment the macro offset
0027d9 93a0 28cc                 	sts triangle_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_volume_read:
0027db 91b4                      	lpm r27, Z //load volume data into r27
0027dc 3fbf                      	cpi r27, 0xFF //check for macro end flag
0027dd f469                      	brne sound_driver_instrument_routine_channel2_volume_process //if the data was not the macro end flag
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_release:
0027de 91b0 28ce                 	lds r27, triangle_volume_macro_release
0027e0 3fbf                      	cpi r27, 0xFF
0027e1 f429                      	brne sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_loop:
0027e2 91b0 28cd                 	lds r27, triangle_volume_macro_loop //load the loop index
0027e4 93b0 28cc                 	sts triangle_volume_macro_offset, r27 //store the loop index into the offset
0027e6 cfdc                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index:
0027e7 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
0027e8 93a0 28cc                 	sts triangle_volume_macro_offset, r26
0027ea cfd8                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_process:
0027eb 15b2                      	cp r27, zero
0027ec f041                      	breq sound_driver_instrument_routine_channel2_volume_process_disable
                                 sound_driver_instrument_routine_channel2_volume_process_enable:
0027ed 91b0 0aa5                 	lds r27, TCB2_INTCTRL
0027ef 30b1                      	cpi r27, TCB_CAPT_bm
0027f0 f459                      	brne sound_driver_instrument_routine_channel2_volume_default //if the channel has already been muted, don't enable it again
0027f1 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
0027f2 93b0 0aa5                 	sts TCB2_INTCTRL, r27
0027f4 c007                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 sound_driver_instrument_routine_channel2_volume_process_disable:
0027f5 9220 0aa5                 	sts TCB2_INTCTRL, zero
0027f7 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
0027f9 9220 0aad                 	sts TCB2_CCMPH, zero
0027fb c000                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_volume_default:
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
0027fc 91e0 28cf                 	lds ZL, triangle_arpeggio_macro
0027fe 91f0 28d0                 	lds ZH, triangle_arpeggio_macro+1
002800 9630                      	adiw Z, 0
002801 f1d9                      	breq sound_driver_instrument_routine_channel2_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002802 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002803 1fff                      	rol ZH
002804 91a0 28d1                 	lds r26, triangle_arpeggio_macro_offset
002806 0fea                      	add ZL, r26
002807 1df2                      	adc ZH, zero
                                 
002808 91b0 28d3                 	lds r27, triangle_arpeggio_macro_release
00280a 17ba                      	cp r27, r26
00280b f429                      	brne sound_driver_instrument_routine_channel2_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
00280c 91a0 28d2                 	lds r26, triangle_arpeggio_macro_loop
00280e 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00280f f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002810 c003                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_increment:
002811 95a3                      	inc r26 //increment the macro offset
002812 93a0 28d1                 	sts triangle_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_read:
002814 91b4                      	lpm r27, Z //load arpeggio data into r27
002815 38b0                      	cpi r27, 0x80 //check for macro end flag
002816 f009                      	breq sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag
002817 c041                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_check_mode:
002818 50a1                      	subi r26, 1 //keep the offset at the end flag
002819 93a0 28d1                 	sts triangle_arpeggio_macro_offset, r26
00281b 91b0 28d4                 	lds r27, triangle_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
00281d 30b1                      	cpi r27, 0x01
00281e f048                      	brlo sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_release:
00281f 91b0 28d3                 	lds r27, triangle_arpeggio_macro_release
002821 3fbf                      	cpi r27, 0xFF
002822 f4d1                      	brne sound_driver_instrument_routine_channel2_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_loop:
002823 91b0 28d2                 	lds r27, triangle_arpeggio_macro_loop
002825 3fbf                      	cpi r27, 0xFF
002826 f499                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002827 c015                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute:
002828 91b0 28d3                 	lds r27, triangle_arpeggio_macro_release
00282a 3fbf                      	cpi r27, 0xFF
00282b f421                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_check_loop:
00282c 91b0 28d2                 	lds r27, triangle_arpeggio_macro_loop //load the loop index
00282e 3fbf                      	cpi r27, 0xFF //check if loop flag exists
00282f f451                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop:
002830 91c0 28e7                 	lds r28, triangle_fx_0xy_sequence //check for 0xy effect
002832 91d0 28e8                 	lds r29, triangle_fx_0xy_sequence+1
002834 9620                      	adiw r29:r28, 0
002835 f469                      	brne sound_driver_instrument_routine_channel2_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002836 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002837 93a0 28d1                 	sts triangle_arpeggio_macro_offset, r26 //store the last valid index into the offset
002839 cfc2                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload:
00283a 93b0 28d1                 	sts triangle_arpeggio_macro_offset, r27 //store the loop index into the offset
00283c cfbf                      	rjmp sound_driver_instrument_routine_channel2_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_default:
00283d 91c0 28e7                 	lds r28, triangle_fx_0xy_sequence //load 0xy effect
00283f 91d0 28e8                 	lds r29, triangle_fx_0xy_sequence+1
002841 9620                      	adiw r29:r28, 0 //check for 0xy effect
002842 f099                      	breq sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel2_arpeggio_default_0xy:
002843 95d6                      	lsr r29
002844 95c7                      	ror r28
002845 95d7                      	ror r29
002846 95c7                      	ror r28
002847 95d7                      	ror r29
002848 95c7                      	ror r28
002849 95d7                      	ror r29
00284a 95c7                      	ror r28
00284b 95d7                      	ror r29
00284c 95d2                      	swap r29
                                 
00284d 93c0 28e7                 	sts triangle_fx_0xy_sequence, r28 //store the rolled sequence
00284f 93d0 28e8                 	sts triangle_fx_0xy_sequence+1, r29
002851 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002852 91a0 2812                 	lds r26, triangle_note //load the current note index
002854 0fac                      	add r26, r28 //add the note offset
002855 c02e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002856 91a0 2812                 	lds r26, triangle_note //load the current note index
002858 c02b                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process:
002859 9220 28d5                 	sts triangle_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
00285b 9220 28d6                 	sts triangle_total_pitch_offset+1, zero
00285d 9220 28dc                 	sts triangle_total_hi_pitch_offset, zero
00285f 91a0 28d4                 	lds r26, triangle_arpeggio_macro_mode
002861 30a1                      	cpi r26, 0x01 //absolute mode
002862 f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_absolute
002863 f069                      	breq sound_driver_instrument_routine_channel2_arpeggio_process_fixed
002864 c00e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute:
002865 91a0 2812                 	lds r26, triangle_note //load the current note index
002867 0fab                      	add r26, r27 //offset the note with the arpeggio data
002868 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002869 c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_add:
00286a 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
00286b f0c0                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
00286c e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
00286d c016                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract:
00286e fda7                      	sbrc r26, 7 //check if result is negative
00286f e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002870 c013                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_fixed:
002871 2fab                      	mov r26, r27 //move the arpeggio data into r26
002872 c011                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative:
002873 91a0 2812                 	lds r26, triangle_note //load the current note index
002875 0fab                      	add r26, r27 //offset the note with the arpeggio data
002876 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002877 c008                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_add:
002878 93a0 2812                 	sts triangle_note, r26 //NOTE: relative mode modifies the original note index
00287a 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
00287b f040                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
00287c e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
00287d 93a0 2812                 	sts triangle_note, r26
00287f c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract:
002880 fda7                      	sbrc r26, 7 //check if result is negative
002881 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002882 93a0 2812                 	sts triangle_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_load:
002884 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
002885 e0f0                      	ldi ZH, HIGH(note_table << 1)
002886 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002887 0fea                      	add ZL, r26 //add offset
002888 1df2                      	adc ZH, zero
002889 91a5                      	lpm r26, Z+ //load bytes
00288a 91b4                      	lpm r27, Z
00288b 93a0 0aac                 	sts TCB2_CCMPL, r26 //load the LOW bits for timer
00288d 93b0 0aad                 	sts TCB2_CCMPH, r27 //load the HIGH bits for timer
00288f 93a0 28f3                 	sts triangle_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002891 93b0 28f4                 	sts triangle_fx_3xx_target+1, r27
002893 c000                      	rjmp sound_driver_instrument_routine_channel2_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch:
002894 91e0 28d7                 	lds ZL, triangle_pitch_macro
002896 91f0 28d8                 	lds ZH, triangle_pitch_macro+1
002898 9630                      	adiw Z, 0
002899 f409                      	brne sound_driver_instrument_routine_channel2_pitch_continue
00289a c023                      	rjmp sound_driver_instrument_routine_channel2_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel2_pitch_continue:
00289b 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00289c 1fff                      	rol ZH
00289d 91a0 28d9                 	lds r26, triangle_pitch_macro_offset
00289f 0fea                      	add ZL, r26
0028a0 1df2                      	adc ZH, zero
                                 
0028a1 91b0 28db                 	lds r27, triangle_pitch_macro_release
0028a3 17ba                      	cp r27, r26
0028a4 f429                      	brne sound_driver_instrument_routine_channel2_pitch_increment //if the current offset is not equal to the release index, increment the offset
0028a5 91a0 28da                 	lds r26, triangle_pitch_macro_loop
0028a7 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0028a8 f010                      	brlo sound_driver_instrument_routine_channel2_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0028a9 c003                      	rjmp sound_driver_instrument_routine_channel2_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_pitch_increment:
0028aa 95a3                      	inc r26 //increment the macro offset
0028ab 93a0 28d9                 	sts triangle_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_pitch_read:
0028ad 91b4                      	lpm r27, Z //load pitch data into r27
0028ae 38b0                      	cpi r27, 0x80 //check for macro end flag
0028af f479                      	brne sound_driver_instrument_routine_channel2_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_release:
0028b0 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0028b1 93a0 28d9                 	sts triangle_pitch_macro_offset, r26
0028b3 91b0 28db                 	lds r27, triangle_pitch_macro_release
0028b5 3fbf                      	cpi r27, 0xFF
0028b6 f439                      	brne sound_driver_instrument_routine_channel2_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_loop:
0028b7 91b0 28da                 	lds r27, triangle_pitch_macro_loop //load the loop index
0028b9 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0028ba f019                      	breq sound_driver_instrument_routine_channel2_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
0028bb 93b0 28d9                 	sts triangle_pitch_macro_offset, r27 //store the loop index into the offset
0028bd cfd6                      	rjmp sound_driver_instrument_routine_channel2_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_default:
0028be e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel2_pitch_calculate:
0028bf 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0028c0 937f                      	push r23
0028c1 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
0028c2 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0028c3 0367                      	mulsu r22, r23
0028c4 917f                      	pop r23
0028c5 916f                      	pop r22
                                 
0028c6 9416                      	lsr r1 //shift out the fractional bits
0028c7 9407                      	ror r0
0028c8 9416                      	lsr r1
0028c9 9407                      	ror r0
0028ca 9416                      	lsr r1
0028cb 9407                      	ror r0
0028cc 9416                      	lsr r1
0028cd 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_check_negative:
0028ce fe13                      	sbrs r1, 3 //check if result was a negative number
0028cf c007                      	rjmp sound_driver_instrument_routine_channel2_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_negative:
0028d0 efc0                      	ldi r28, 0xF0
0028d1 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_check_divisible_8:
0028d2 70b7                      	andi r27, 0b00000111
0028d3 f019                      	breq sound_driver_instrument_routine_channel2_pitch_calculate_offset
                                 
0028d4 e0b1                      	ldi r27, 0x01
0028d5 0e0b                      	add r0, r27
0028d6 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_offset:
0028d7 91a0 28d5                 	lds r26, triangle_total_pitch_offset
0028d9 91b0 28d6                 	lds r27, triangle_total_pitch_offset+1
0028db 0e0a                      	add r0, r26
0028dc 1e1b                      	adc r1, r27
0028dd 9200 28d5                 	sts triangle_total_pitch_offset, r0
0028df 9210 28d6                 	sts triangle_total_pitch_offset+1, r1
0028e1 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
0028e3 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
0028e5 0da0                      	add r26, r0 //offset the timer values
0028e6 1db1                      	adc r27, r1
                                 	
0028e7 91c0 28eb                 	lds r28, triangle_fx_1xx_total
0028e9 91d0 28ec                 	lds r29, triangle_fx_1xx_total+1
0028eb 1bac                      	sub r26, r28
0028ec 0bbd                      	sbc r27, r29
0028ed 91c0 28ef                 	lds r28, triangle_fx_2xx_total
0028ef 91d0 28f0                 	lds r29, triangle_fx_2xx_total+1
0028f1 0fac                      	add r26, r28
0028f2 1fbd                      	adc r27, r29
0028f3 91c0 28fe                 	lds r28, triangle_fx_Pxx_total
0028f5 91d0 28ff                 	lds r29, triangle_fx_Pxx_total+1
0028f7 0fac                      	add r26, r28
0028f8 1fbd                      	adc r27, r29
0028f9 91c0 2905                 	lds r28, triangle_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
0028fb 91d0 2906                 	lds r29, triangle_fx_Qxy_total_offset+1
0028fd 1bac                      	sub r26, r28
0028fe 0bbd                      	sbc r27, r29
0028ff 91c0 290c                 	lds r28, triangle_fx_Rxy_total_offset
002901 91d0 290d                 	lds r29, triangle_fx_Rxy_total_offset+1
002903 0fac                      	add r26, r28
002904 1fbd                      	adc r27, r29
                                 
002905 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
002907 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel2_hi_pitch:
002909 91e0 28dd                 	lds ZL, triangle_hi_pitch_macro
00290b 91f0 28de                 	lds ZH, triangle_hi_pitch_macro+1
00290d 9630                      	adiw Z, 0
00290e f409                      	brne sound_driver_instrument_routine_channel2_hi_pitch_continue
00290f c03c                      	rjmp sound_driver_instrument_routine_channel2_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel2_hi_pitch_continue:
002910 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002911 1fff                      	rol ZH
002912 91a0 28df                 	lds r26, triangle_hi_pitch_macro_offset
002914 0fea                      	add ZL, r26
002915 1df2                      	adc ZH, zero
                                 
002916 91b0 28e1                 	lds r27, triangle_hi_pitch_macro_release
002918 17ba                      	cp r27, r26
002919 f429                      	brne sound_driver_instrument_routine_channel2_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
00291a 91a0 28e0                 	lds r26, triangle_hi_pitch_macro_loop
00291c 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00291d f010                      	brlo sound_driver_instrument_routine_channel2_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00291e c003                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_increment:
00291f 95a3                      	inc r26 //increment the macro offset
002920 93a0 28df                 	sts triangle_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_hi_pitch_read:
002922 91b4                      	lpm r27, Z //load hi pitch data into r27
002923 38b0                      	cpi r27, 0x80 //check for macro end flag
002924 f489                      	brne sound_driver_instrument_routine_channel2_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_release:
002925 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002926 93a0 28df                 	sts triangle_hi_pitch_macro_offset, r26
002928 91b0 28e1                 	lds r27, triangle_hi_pitch_macro_release
00292a 3fbf                      	cpi r27, 0xFF
00292b f439                      	brne sound_driver_instrument_routine_channel2_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_loop:
00292c 91b0 28e0                 	lds r27, triangle_hi_pitch_macro_loop //load the loop index
00292e 3fbf                      	cpi r27, 0xFF //check if there is a loop index
00292f f019                      	breq sound_driver_instrument_routine_channel2_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002930 93b0 28df                 	sts triangle_hi_pitch_macro_offset, r27 //store the loop index into the offset
002932 cfd6                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_default:
002933 91b0 28dc                 	lds r27, triangle_total_hi_pitch_offset
002935 c005                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate:
002936 91a0 28dc                 	lds r26, triangle_total_hi_pitch_offset //load the total hi pitch offset to change
002938 0fba                      	add r27, r26
002939 93b0 28dc                 	sts triangle_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply:
00293b 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00293c 937f                      	push r23
00293d 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
00293e eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00293f 0367                      	mulsu r22, r23
002940 917f                      	pop r23
002941 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_offset:
002942 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
002944 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
002946 0da0                      	add r26, r0 //offset the timer values
002947 1db1                      	adc r27, r1
002948 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
00294a 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: The triangle channel does not have a duty cycle
                                 sound_driver_instrument_routine_channel2_duty:
                                 
                                 
                                 
                                 sound_driver_channel2_fx_routines:
                                 sound_driver_channel2_fx_1xx_routine:
00294c 91e0 28e9                 	lds ZL, triangle_fx_1xx
00294e 91f0 28ea                 	lds ZH, triangle_fx_1xx+1
002950 9630                      	adiw Z, 0
002951 f051                      	breq sound_driver_channel2_fx_2xx_routine
                                 
002952 91a0 28eb                 	lds r26, triangle_fx_1xx_total //load the rate to change the pitch by
002954 91b0 28ec                 	lds r27, triangle_fx_1xx_total+1
002956 0fae                      	add r26, ZL //increase the total offset by the rate
002957 1fbf                      	adc r27, ZH
002958 93a0 28eb                 	sts triangle_fx_1xx_total, r26
00295a 93b0 28ec                 	sts triangle_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_2xx_routine:
00295c 91e0 28ed                 	lds ZL, triangle_fx_2xx
00295e 91f0 28ee                 	lds ZH, triangle_fx_2xx+1
002960 9630                      	adiw Z, 0
002961 f051                      	breq sound_driver_channel2_fx_3xx_routine
                                 
002962 91a0 28ef                 	lds r26, triangle_fx_2xx_total //load the rate to change the pitch by
002964 91b0 28f0                 	lds r27, triangle_fx_2xx_total+1
002966 0fae                      	add r26, ZL //increase the total offset by the rate
002967 1fbf                      	adc r27, ZH
002968 93a0 28ef                 	sts triangle_fx_2xx_total, r26
00296a 93b0 28f0                 	sts triangle_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_3xx_routine:
00296c 91e0 28f5                 	lds ZL, triangle_fx_3xx_speed
00296e 91f0 28f6                 	lds ZH, triangle_fx_3xx_speed+1
002970 9630                      	adiw Z, 0
002971 f409                      	brne sound_driver_channel2_fx_3xx_routine_check_start
002972 c048                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_check_start:
002973 91a0 28f1                 	lds r26, triangle_fx_3xx_start
002975 91b0 28f2                 	lds r27, triangle_fx_3xx_start+1
002977 9610                      	adiw r26:r27, 0
002978 f409                      	brne sound_driver_channel2_fx_3xx_routine_main
002979 c041                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_main:
00297a 91c0 28f3                 	lds r28, triangle_fx_3xx_target
00297c 91d0 28f4                 	lds r29, triangle_fx_3xx_target+1
                                 
00297e 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
00297f 07bd                      	cpc r27, r29
002980 f011                      	breq sound_driver_channel2_fx_3xx_routine_disable
002981 f030                      	brlo sound_driver_channel2_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002982 c01f                      	rjmp sound_driver_channel2_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel2_fx_3xx_routine_disable:
002983 9220 28f1                 	sts triangle_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002985 9220 28f2                 	sts triangle_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002987 c033                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_subtract:
002988 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002989 0bdb                      	sbc r29, r27
00298a 91a0 28f7                 	lds r26, triangle_fx_3xx_total_offset
00298c 91b0 28f8                 	lds r27, triangle_fx_3xx_total_offset+1
                                 
00298e 0fae                      	add r26, ZL //add the speed to the total offset
00298f 1fbf                      	adc r27, ZH
002990 1bca                      	sub r28, r26 //invert the total difference with the total offset
002991 0bdb                      	sbc r29, r27
002992 f380                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002993 93a0 28f7                 	sts triangle_fx_3xx_total_offset, r26 //store the new total offset
002995 93b0 28f8                 	sts triangle_fx_3xx_total_offset+1, r27
                                 
002997 91a0 0aac                 	lds r26, TCB2_CCMPL //load the current timer period
002999 91b0 0aad                 	lds r27, TCB2_CCMPH
00299b 1bac                      	sub r26, r28 //offset the current timer period with the total offset
00299c 0bbd                      	sbc r27, r29
00299d 93a0 0aac                 	sts TCB2_CCMPL, r26
00299f 93b0 0aad                 	sts TCB2_CCMPH, r27
0029a1 c019                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_add:
0029a2 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
0029a3 0bbd                      	sbc r27, r29
0029a4 91c0 28f7                 	lds r28, triangle_fx_3xx_total_offset
0029a6 91d0 28f8                 	lds r29, triangle_fx_3xx_total_offset+1
                                 
0029a8 0fce                      	add r28, ZL //add the speed to the total offset
0029a9 1fdf                      	adc r29, ZH
0029aa 1bac                      	sub r26, r28 //invert the total difference with the total offset
0029ab 0bbd                      	sbc r27, r29
0029ac f2b0                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0029ad 93c0 28f7                 	sts triangle_fx_3xx_total_offset, r28 //store the new total offset
0029af 93d0 28f8                 	sts triangle_fx_3xx_total_offset+1, r29
                                 
0029b1 91c0 0aac                 	lds r28, TCB2_CCMPL //load the current timer period
0029b3 91d0 0aad                 	lds r29, TCB2_CCMPH
0029b5 0fca                      	add r28, r26 //offset the current timer period with the total offset
0029b6 1fdb                      	adc r29, r27
0029b7 93c0 0aac                 	sts TCB2_CCMPL, r28
0029b9 93d0 0aad                 	sts TCB2_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel2_fx_4xy_routine:
0029bb 91a0 28f9                 	lds r26, triangle_fx_4xy_speed
0029bd 15a2                      	cp r26, zero
0029be f409                      	brne sound_driver_channel2_fx_4xy_routine_continue
0029bf c05c                      	rjmp sound_driver_channel2_fx_Qxy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel2_fx_4xy_routine_continue:
0029c0 91b0 28fa                 	lds r27, triangle_fx_4xy_depth
0029c2 91c0 28fb                 	lds r28, triangle_fx_4xy_phase
0029c4 0fca                      	add r28, r26 //increase the phase by the speed
0029c5 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
0029c6 f008                      	brlo sound_driver_channel2_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
0029c7 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase:
0029c8 93c0 28fb                 	sts triangle_fx_4xy_phase, r28 //store the new phase
0029ca 31c0                      	cpi r28, 16
0029cb f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_0
0029cc 32c0                      	cpi r28, 32
0029cd f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_1
0029ce 33c0                      	cpi r28, 48
0029cf f030                      	brlo sound_driver_channel2_fx_4xy_routine_phase_2
0029d0 c007                      	rjmp sound_driver_channel2_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_0:
0029d1 70cf                      	andi r28, 0x0F //mask for values 0-15
0029d2 c029                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_1:
0029d3 6fc0                      	ori r28, 0xF0
0029d4 95c0                      	com r28 //invert values 0-15
0029d5 c026                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_2:
0029d6 70cf                      	andi r28, 0x0F //mask for values 0-15
0029d7 c003                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_3:
0029d8 6fc0                      	ori r28, 0xF0
0029d9 95c0                      	com r28 //invert values 0-15
0029da c000                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_add:
0029db 95b2                      	swap r27 //multiply depth by 16
0029dc 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0029dd e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0029de e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0029df 0fec                      	add ZL, r28 //offset the table by the depth+phase
0029e0 1df2                      	adc ZH, zero
0029e1 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
0029e2 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0029e3 937f                      	push r23
0029e4 2f6c                      	mov r22, r28 //store the vibrato value into r22
0029e5 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0029e6 9f67                      	mul r22, r23
0029e7 917f                      	pop r23
0029e8 916f                      	pop r22
                                 
0029e9 9416                      	lsr r1 //shift out the fractional bits
0029ea 9407                      	ror r0
0029eb 9416                      	lsr r1
0029ec 9407                      	ror r0
0029ed 9416                      	lsr r1
0029ee 9407                      	ror r0
0029ef 9416                      	lsr r1
0029f0 9407                      	ror r0
                                 	
0029f1 91a0 0aac                 	lds r26, TCB2_CCMPL
0029f3 91b0 0aad                 	lds r27, TCB2_CCMPH
0029f5 0da0                      	add r26, r0
0029f6 1db1                      	adc r27, r1
0029f7 93a0 0aac                 	sts TCB2_CCMPL, r26
0029f9 93b0 0aad                 	sts TCB2_CCMPH, r27
0029fb c020                      	rjmp sound_driver_channel2_fx_Qxy_routine
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_subtract:
0029fc 95b2                      	swap r27 //multiply depth by 16
0029fd 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
0029fe e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0029ff e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002a00 0fec                      	add ZL, r28 //offset the table by the depth+phase
002a01 1df2                      	adc ZH, zero
002a02 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002a03 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002a04 937f                      	push r23
002a05 2f6c                      	mov r22, r28 //store the vibrato value into r22
002a06 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002a07 9f67                      	mul r22, r23
002a08 917f                      	pop r23
002a09 916f                      	pop r22
                                 
002a0a 9416                      	lsr r1 //shift out the fractional bits
002a0b 9407                      	ror r0
002a0c 9416                      	lsr r1
002a0d 9407                      	ror r0
002a0e 9416                      	lsr r1
002a0f 9407                      	ror r0
002a10 9416                      	lsr r1
002a11 9407                      	ror r0
                                 
002a12 91a0 0aac                 	lds r26, TCB2_CCMPL
002a14 91b0 0aad                 	lds r27, TCB2_CCMPH
002a16 19a0                      	sub r26, r0
002a17 09b1                      	sbc r27, r1
002a18 93a0 0aac                 	sts TCB2_CCMPL, r26
002a1a 93b0 0aad                 	sts TCB2_CCMPH, r27
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel2_fx_Qxy_routine:
002a1c 91e0 2901                 	lds ZL, triangle_fx_Qxy_target
002a1e 91f0 2902                 	lds ZH, triangle_fx_Qxy_target+1
002a20 9630                      	adiw Z, 0
002a21 f119                      	breq sound_driver_channel2_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002a22 91a0 2905                 	lds r26, triangle_fx_Qxy_total_offset
002a24 91b0 2906                 	lds r27, triangle_fx_Qxy_total_offset+1
002a26 91c0 0aac                 	lds r28, TCB2_CCMPL
002a28 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
002a2a 1bec                      	sub ZL, r28 //calculate the difference to the target
002a2b 0bfd                      	sbc ZH, r29
002a2c f408                      	brsh sound_driver_channel2_fx_Qxy_routine_end //if the target has been reached (or passed)
002a2d f068                      	brlo sound_driver_channel2_fx_Qxy_routine_add
                                 
                                 sound_driver_channel2_fx_Qxy_routine_end:
002a2e 9220 2905                 	sts triangle_fx_Qxy_total_offset, zero //turn off the effect
002a30 9220 2906                 	sts triangle_fx_Qxy_total_offset+1, zero
002a32 9220 2901                 	sts triangle_fx_Qxy_target, zero
002a34 9220 2902                 	sts triangle_fx_Qxy_target+1, zero
002a36 91b0 2900                 	lds r27, triangle_fx_Qxy_target_note
002a38 93b0 2812                 	sts triangle_note, r27 //replace the note with the final target note
002a3a c00a                      	rjmp sound_driver_channel2_fx_Rxy_routine
                                 
                                 sound_driver_channel2_fx_Qxy_routine_add:
002a3b 91c0 2903                 	lds r28, triangle_fx_Qxy_speed
002a3d 91d0 2904                 	lds r29, triangle_fx_Qxy_speed+1
002a3f 0fac                      	add r26, r28 //increase the total offset by the speed
002a40 1fbd                      	adc r27, r29
002a41 93a0 2905                 	sts triangle_fx_Qxy_total_offset, r26 //store the total offset
002a43 93b0 2906                 	sts triangle_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_Rxy_routine:
002a45 91e0 2908                 	lds ZL, triangle_fx_Rxy_target
002a47 91f0 2909                 	lds ZH, triangle_fx_Rxy_target+1
002a49 9630                      	adiw Z, 0
002a4a f119                      	breq sound_driver_instrument_routine_channel3_volume //if the effect is not enabled, skip the routine
                                 
002a4b 91a0 290c                 	lds r26, triangle_fx_Rxy_total_offset
002a4d 91b0 290d                 	lds r27, triangle_fx_Rxy_total_offset+1
002a4f 91c0 0aac                 	lds r28, TCB2_CCMPL
002a51 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
002a53 1bce                      	sub r28, ZL //calculate the difference to the target
002a54 0bdf                      	sbc r29, ZH
002a55 f408                      	brsh sound_driver_channel2_fx_Rxy_routine_end //if the target has been reached (or passed)
002a56 f068                      	brlo sound_driver_channel2_fx_Rxy_routine_add
                                 
                                 sound_driver_channel2_fx_Rxy_routine_end:
002a57 9220 290c                 	sts triangle_fx_Rxy_total_offset, zero //disable the effect
002a59 9220 290d                 	sts triangle_fx_Rxy_total_offset+1, zero
002a5b 9220 2908                 	sts triangle_fx_Rxy_target, zero
002a5d 9220 2909                 	sts triangle_fx_Rxy_target+1, zero
002a5f 91b0 2907                 	lds r27, triangle_fx_Rxy_target_note
002a61 93b0 2812                 	sts triangle_note, r27 //replace the note with the final target note
002a63 c00a                      	rjmp sound_driver_instrument_routine_channel3_volume
                                 
                                 sound_driver_channel2_fx_Rxy_routine_add:
002a64 91c0 290a                 	lds r28, triangle_fx_Rxy_speed
002a66 91d0 290b                 	lds r29, triangle_fx_Rxy_speed+1
002a68 0fac                      	add r26, r28 //increase the total offset by the speed
002a69 1fbd                      	adc r27, r29
002a6a 93a0 290c                 	sts triangle_fx_Rxy_total_offset, r26 //store the total offset
002a6c 93b0 290d                 	sts triangle_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume:
002a6e 91e0 2916                 	lds ZL, noise_volume_macro
002a70 91f0 2917                 	lds ZH, noise_volume_macro+1
002a72 9630                      	adiw Z, 0
002a73 f1a1                      	breq sound_driver_instrument_routine_channel3_volume_default //if no volume macro is in use, use default multiplier of F
002a74 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002a75 1fff                      	rol ZH
002a76 91a0 2918                 	lds r26, noise_volume_macro_offset
002a78 0fea                      	add ZL, r26
002a79 1df2                      	adc ZH, zero
                                 
002a7a 91b0 291a                 	lds r27, noise_volume_macro_release
002a7c 17ba                      	cp r27, r26
002a7d f429                      	brne sound_driver_instrument_routine_channel3_volume_increment //if the current offset is not equal to the release index, increment the offset
002a7e 91a0 2919                 	lds r26, noise_volume_macro_loop
002a80 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002a81 f010                      	brlo sound_driver_instrument_routine_channel3_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002a82 c003                      	rjmp sound_driver_instrument_routine_channel3_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_volume_increment:
002a83 95a3                      	inc r26 //increment the macro offset
002a84 93a0 2918                 	sts noise_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_volume_read:
002a86 91b4                      	lpm r27, Z //load volume data into r27
002a87 3fbf                      	cpi r27, 0xFF //check for macro end flag
002a88 f469                      	brne sound_driver_instrument_routine_channel3_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_check_release:
002a89 91b0 291a                 	lds r27, noise_volume_macro_release
002a8b 3fbf                      	cpi r27, 0xFF
002a8c f429                      	brne sound_driver_instrument_routine_channel3_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_check_loop:
002a8d 91b0 2919                 	lds r27, noise_volume_macro_loop //load the loop index
002a8f 93b0 2918                 	sts noise_volume_macro_offset, r27 //store the loop index into the offset
002a91 cfdc                      	rjmp sound_driver_instrument_routine_channel3_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_last_index:
002a92 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002a93 93a0 2918                 	sts noise_volume_macro_offset, r26
002a95 cfd8                      	rjmp sound_driver_instrument_routine_channel3_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume_calculate:
002a96 e6e4                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
002a97 e5fc                      	ldi ZH, HIGH(volumes << 1)
002a98 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
002a99 0feb                      	add ZL, r27 //add offset to the table
002a9a 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel3_volume_load:
002a9b 91b0 2813                 	lds r27, noise_param //load main volume
002a9d 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002a9e 91a0 294b                 	lds r26, noise_fx_7xy_value
002aa0 30a0                      	cpi r26, 0x00
002aa1 f481                      	brne sound_driver_instrument_routine_channel3_volume_load_7xy
                                 
002aa2 0feb                      	add ZL, r27 //offset the volume table by the main volume
002aa3 1df2                      	adc ZH, zero
002aa4 91b4                      	lpm r27, Z
002aa5 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002aa7 c023                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_default:
002aa8 91b0 2813                 	lds r27, noise_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
002aaa 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002aab 91a0 294b                 	lds r26, noise_fx_7xy_value
002aad 30a0                      	cpi r26, 0x00
002aae f499                      	brne sound_driver_instrument_routine_channel3_volume_default_7xy
002aaf 93b0 2816                 	sts noise_output_volume, r27
002ab1 c019                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_load_7xy:
002ab2 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002ab3 f038                      	brcs sound_driver_instrument_routine_channel3_volume_load_7xy_overflow
002ab4 f031                      	breq sound_driver_instrument_routine_channel3_volume_load_7xy_overflow
                                 
002ab5 0feb                      	add ZL, r27 //offset the volume table by the main volume
002ab6 1df2                      	adc ZH, zero
002ab7 91b4                      	lpm r27, Z
002ab8 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002aba c010                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_load_7xy_overflow:
002abb e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002abc 0feb                      	add ZL, r27 //offset the volume table by the main volume
002abd 1df2                      	adc ZH, zero
002abe 91b4                      	lpm r27, Z
002abf 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002ac1 c009                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_default_7xy:
002ac2 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002ac3 f020                      	brcs sound_driver_instrument_routine_channel3_volume_default_7xy_overflow
002ac4 f019                      	breq sound_driver_instrument_routine_channel3_volume_default_7xy_overflow
002ac5 93b0 2816                 	sts noise_output_volume, r27
002ac7 c003                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel3_volume_default_7xy_overflow:
002ac8 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002ac9 93b0 2816                 	sts noise_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002acb 91e0 291b                 	lds ZL, noise_arpeggio_macro
002acd 91f0 291c                 	lds ZH, noise_arpeggio_macro+1
002acf 9630                      	adiw Z, 0
002ad0 f1d9                      	breq sound_driver_instrument_routine_channel3_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002ad1 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002ad2 1fff                      	rol ZH
002ad3 91a0 291d                 	lds r26, noise_arpeggio_macro_offset
002ad5 0fea                      	add ZL, r26
002ad6 1df2                      	adc ZH, zero
                                 
002ad7 91b0 291f                 	lds r27, noise_arpeggio_macro_release
002ad9 17ba                      	cp r27, r26
002ada f429                      	brne sound_driver_instrument_routine_channel3_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002adb 91a0 291e                 	lds r26, noise_arpeggio_macro_loop
002add 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002ade f010                      	brlo sound_driver_instrument_routine_channel3_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002adf c003                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_increment:
002ae0 95a3                      	inc r26 //increment the macro offset
002ae1 93a0 291d                 	sts noise_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_arpeggio_read:
002ae3 91b4                      	lpm r27, Z //load arpeggio data into r27
002ae4 38b0                      	cpi r27, 0x80 //check for macro end flag
002ae5 f009                      	breq sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag
002ae6 c041                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_check_mode:
002ae7 50a1                      	subi r26, 1 //keep the offset at the end flag
002ae8 93a0 291d                 	sts noise_arpeggio_macro_offset, r26
002aea 91b0 2920                 	lds r27, noise_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002aec 30b1                      	cpi r27, 0x01
002aed f048                      	brlo sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_fixed_relative_check_release:
002aee 91b0 291f                 	lds r27, noise_arpeggio_macro_release
002af0 3fbf                      	cpi r27, 0xFF
002af1 f4d1                      	brne sound_driver_instrument_routine_channel3_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_fixed_relative_check_loop:
002af2 91b0 291e                 	lds r27, noise_arpeggio_macro_loop
002af4 3fbf                      	cpi r27, 0xFF
002af5 f499                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002af6 c015                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute:
002af7 91b0 291f                 	lds r27, noise_arpeggio_macro_release
002af9 3fbf                      	cpi r27, 0xFF
002afa f421                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_check_loop:
002afb 91b0 291e                 	lds r27, noise_arpeggio_macro_loop //load the loop index
002afd 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002afe f451                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_no_loop:
002aff 91c0 2933                 	lds r28, noise_fx_0xy_sequence //check for 0xy effect
002b01 91d0 2934                 	lds r29, noise_fx_0xy_sequence+1
002b03 9620                      	adiw r29:r28, 0
002b04 f469                      	brne sound_driver_instrument_routine_channel3_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002b05 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002b06 93a0 291d                 	sts noise_arpeggio_macro_offset, r26 //store the last valid index into the offset
002b08 cfc2                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload:
002b09 93b0 291d                 	sts noise_arpeggio_macro_offset, r27 //store the loop index into the offset
002b0b cfbf                      	rjmp sound_driver_instrument_routine_channel3_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_default:
002b0c 91c0 2933                 	lds r28, noise_fx_0xy_sequence //load 0xy effect
002b0e 91d0 2934                 	lds r29, noise_fx_0xy_sequence+1
002b10 9620                      	adiw r29:r28, 0 //check for 0xy effect
002b11 f099                      	breq sound_driver_instrument_routine_channel3_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel3_arpeggio_default_0xy:
002b12 95d6                      	lsr r29
002b13 95c7                      	ror r28
002b14 95d7                      	ror r29
002b15 95c7                      	ror r28
002b16 95d7                      	ror r29
002b17 95c7                      	ror r28
002b18 95d7                      	ror r29
002b19 95c7                      	ror r28
002b1a 95d7                      	ror r29
002b1b 95d2                      	swap r29
                                 
002b1c 93c0 2933                 	sts noise_fx_0xy_sequence, r28 //store the rolled sequence
002b1e 93d0 2934                 	sts noise_fx_0xy_sequence+1, r29
002b20 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002b21 91a0 2817                 	lds r26, noise_note //load the current note index
002b23 0fac                      	add r26, r28 //add the note offset
002b24 c02e                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel3_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002b25 91a0 2817                 	lds r26, noise_note //load the current note index
002b27 c02b                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process:
002b28 9220 2921                 	sts noise_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002b2a 9220 2922                 	sts noise_total_pitch_offset+1, zero
002b2c 9220 2928                 	sts noise_total_hi_pitch_offset, zero
002b2e 91a0 2920                 	lds r26, noise_arpeggio_macro_mode
002b30 30a1                      	cpi r26, 0x01 //absolute mode
002b31 f010                      	brlo sound_driver_instrument_routine_channel3_arpeggio_process_absolute
002b32 f069                      	breq sound_driver_instrument_routine_channel3_arpeggio_process_fixed
002b33 c00e                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_absolute:
002b34 91a0 2817                 	lds r26, noise_note //load the current note index
002b36 0fab                      	add r26, r27 //offset the note with the arpeggio data
002b37 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002b38 c004                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_absolute_add:
002b39 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002b3a f0c0                      	brlo sound_driver_instrument_routine_channel3_arpeggio_process_load //if the result is valid, go load the new note
002b3b e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002b3c c016                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_absolute_subtract:
002b3d fda7                      	sbrc r26, 7 //check if result is negative
002b3e e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002b3f c013                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_fixed:
002b40 2fab                      	mov r26, r27 //move the arpeggio data into r26
002b41 c011                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_relative:
002b42 91a0 2817                 	lds r26, noise_note //load the current note index
002b44 0fab                      	add r26, r27 //offset the note with the arpeggio data
002b45 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002b46 c008                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_relative_add:
002b47 93a0 2817                 	sts noise_note, r26 //NOTE: relative mode modifies the original note index
002b49 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002b4a f040                      	brlo sound_driver_instrument_routine_channel3_arpeggio_process_load //if the result is valid, go load the new note
002b4b e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002b4c 93a0 2817                 	sts noise_note, r26
002b4e c004                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_relative_subtract:
002b4f fda7                      	sbrc r26, 7 //check if result is negative
002b50 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002b51 93a0 2817                 	sts noise_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_load:
002b53 e4e2                      	ldi ZL, LOW(noise_period_table << 1) //load in note table
002b54 e0f1                      	ldi ZH, HIGH(noise_period_table << 1)
002b55 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002b56 0fea                      	add ZL, r26 //add offset
002b57 1df2                      	adc ZH, zero
002b58 91a5                      	lpm r26, Z+ //load bytes
002b59 91b4                      	lpm r27, Z
002b5a 93a0 0abc                 	sts TCB3_CCMPL, r26 //load the LOW bits for timer
002b5c 93b0 0abd                 	sts TCB3_CCMPH, r27 //load the HIGH bits for timer
002b5e 93a0 293f                 	sts noise_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002b60 93b0 2940                 	sts noise_fx_3xx_target+1, r27
002b62 c000                      	rjmp sound_driver_instrument_routine_channel3_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch:
002b63 91e0 2923                 	lds ZL, noise_pitch_macro
002b65 91f0 2924                 	lds ZH, noise_pitch_macro+1
002b67 9630                      	adiw Z, 0
002b68 f409                      	brne sound_driver_instrument_routine_channel3_pitch_continue
002b69 c023                      	rjmp sound_driver_instrument_routine_channel3_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel3_pitch_continue:
002b6a 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002b6b 1fff                      	rol ZH
002b6c 91a0 2925                 	lds r26, noise_pitch_macro_offset
002b6e 0fea                      	add ZL, r26
002b6f 1df2                      	adc ZH, zero
                                 
002b70 91b0 2927                 	lds r27, noise_pitch_macro_release
002b72 17ba                      	cp r27, r26
002b73 f429                      	brne sound_driver_instrument_routine_channel3_pitch_increment //if the current offset is not equal to the release index, increment the offset
002b74 91a0 2926                 	lds r26, noise_pitch_macro_loop
002b76 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002b77 f010                      	brlo sound_driver_instrument_routine_channel3_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002b78 c003                      	rjmp sound_driver_instrument_routine_channel3_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_pitch_increment:
002b79 95a3                      	inc r26 //increment the macro offset
002b7a 93a0 2925                 	sts noise_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_pitch_read:
002b7c 91b4                      	lpm r27, Z //load pitch data into r27
002b7d 38b0                      	cpi r27, 0x80 //check for macro end flag
002b7e f479                      	brne sound_driver_instrument_routine_channel3_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag_check_release:
002b7f 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002b80 93a0 2925                 	sts noise_pitch_macro_offset, r26
002b82 91b0 2927                 	lds r27, noise_pitch_macro_release
002b84 3fbf                      	cpi r27, 0xFF
002b85 f439                      	brne sound_driver_instrument_routine_channel3_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag_check_loop:
002b86 91b0 2926                 	lds r27, noise_pitch_macro_loop //load the loop index
002b88 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002b89 f019                      	breq sound_driver_instrument_routine_channel3_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002b8a 93b0 2925                 	sts noise_pitch_macro_offset, r27 //store the loop index into the offset
002b8c cfd6                      	rjmp sound_driver_instrument_routine_channel3_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch_default:
002b8d e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel3_pitch_calculate:
002b8e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002b8f 937f                      	push r23
002b90 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
002b91 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002b92 0367                      	mulsu r22, r23
002b93 917f                      	pop r23
002b94 916f                      	pop r22
                                 
002b95 9416                      	lsr r1 //shift out the fractional bits
002b96 9407                      	ror r0
002b97 9416                      	lsr r1
002b98 9407                      	ror r0
002b99 9416                      	lsr r1
002b9a 9407                      	ror r0
002b9b 9416                      	lsr r1
002b9c 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel3_pitch_calculate_check_negative:
002b9d fe13                      	sbrs r1, 3 //check if result was a negative number
002b9e c007                      	rjmp sound_driver_instrument_routine_channel3_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel3_pitch_calculate_negative:
002b9f efc0                      	ldi r28, 0xF0
002ba0 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel3_pitch_calculate_check_divisible_8:
002ba1 70b7                      	andi r27, 0b00000111
002ba2 f019                      	breq sound_driver_instrument_routine_channel3_pitch_calculate_offset
                                 
002ba3 e0b1                      	ldi r27, 0x01
002ba4 0e0b                      	add r0, r27
002ba5 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel3_pitch_calculate_offset:
002ba6 91a0 2921                 	lds r26, noise_total_pitch_offset
002ba8 91b0 2922                 	lds r27, noise_total_pitch_offset+1
002baa 0e0a                      	add r0, r26
002bab 1e1b                      	adc r1, r27
002bac 9200 2921                 	sts noise_total_pitch_offset, r0
002bae 9210 2922                 	sts noise_total_pitch_offset+1, r1
002bb0 91a0 0abc                 	lds r26, TCB3_CCMPL //load the low bits for timer
002bb2 91b0 0abd                 	lds r27, TCB3_CCMPH //load the high bits for timer
002bb4 0da0                      	add r26, r0 //offset the timer values
002bb5 1db1                      	adc r27, r1
                                 	
002bb6 91c0 2937                 	lds r28, noise_fx_1xx_total
002bb8 91d0 2938                 	lds r29, noise_fx_1xx_total+1
002bba 1bac                      	sub r26, r28
002bbb 0bbd                      	sbc r27, r29
002bbc 91c0 293b                 	lds r28, noise_fx_2xx_total
002bbe 91d0 293c                 	lds r29, noise_fx_2xx_total+1
002bc0 0fac                      	add r26, r28
002bc1 1fbd                      	adc r27, r29
002bc2 91c0 294f                 	lds r28, noise_fx_Pxx_total
002bc4 91d0 2950                 	lds r29, noise_fx_Pxx_total+1
002bc6 0fac                      	add r26, r28
002bc7 1fbd                      	adc r27, r29
002bc8 91c0 2956                 	lds r28, noise_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
002bca 91d0 2957                 	lds r29, noise_fx_Qxy_total_offset+1
002bcc 1bac                      	sub r26, r28
002bcd 0bbd                      	sbc r27, r29
002bce 91c0 295d                 	lds r28, noise_fx_Rxy_total_offset
002bd0 91d0 295e                 	lds r29, noise_fx_Rxy_total_offset+1
002bd2 0fac                      	add r26, r28
002bd3 1fbd                      	adc r27, r29
                                 
002bd4 93a0 0abc                 	sts TCB3_CCMPL, r26 //store the new low bits for timer
002bd6 93b0 0abd                 	sts TCB3_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel3_hi_pitch:
002bd8 91e0 2929                 	lds ZL, noise_hi_pitch_macro
002bda 91f0 292a                 	lds ZH, noise_hi_pitch_macro+1
002bdc 9630                      	adiw Z, 0
002bdd f409                      	brne sound_driver_instrument_routine_channel3_hi_pitch_continue
002bde c03c                      	rjmp sound_driver_instrument_routine_channel3_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel3_hi_pitch_continue:
002bdf 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002be0 1fff                      	rol ZH
002be1 91a0 292b                 	lds r26, noise_hi_pitch_macro_offset
002be3 0fea                      	add ZL, r26
002be4 1df2                      	adc ZH, zero
                                 
002be5 91b0 292d                 	lds r27, noise_hi_pitch_macro_release
002be7 17ba                      	cp r27, r26
002be8 f429                      	brne sound_driver_instrument_routine_channel3_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002be9 91a0 292c                 	lds r26, noise_hi_pitch_macro_loop
002beb 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002bec f010                      	brlo sound_driver_instrument_routine_channel3_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002bed c003                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_increment:
002bee 95a3                      	inc r26 //increment the macro offset
002bef 93a0 292b                 	sts noise_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_hi_pitch_read:
002bf1 91b4                      	lpm r27, Z //load hi pitch data into r27
002bf2 38b0                      	cpi r27, 0x80 //check for macro end flag
002bf3 f489                      	brne sound_driver_instrument_routine_channel3_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag_check_release:
002bf4 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002bf5 93a0 292b                 	sts noise_hi_pitch_macro_offset, r26
002bf7 91b0 292d                 	lds r27, noise_hi_pitch_macro_release
002bf9 3fbf                      	cpi r27, 0xFF
002bfa f439                      	brne sound_driver_instrument_routine_channel3_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag_check_loop:
002bfb 91b0 292c                 	lds r27, noise_hi_pitch_macro_loop //load the loop index
002bfd 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002bfe f019                      	breq sound_driver_instrument_routine_channel3_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002bff 93b0 292b                 	sts noise_hi_pitch_macro_offset, r27 //store the loop index into the offset
002c01 cfd6                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_default:
002c02 91b0 2928                 	lds r27, noise_total_hi_pitch_offset
002c04 c005                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate:
002c05 91a0 2928                 	lds r26, noise_total_hi_pitch_offset //load the total hi pitch offset to change
002c07 0fba                      	add r27, r26
002c08 93b0 2928                 	sts noise_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate_multiply:
002c0a 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002c0b 937f                      	push r23
002c0c 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002c0d eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002c0e 0367                      	mulsu r22, r23
002c0f 917f                      	pop r23
002c10 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate_offset:
002c11 91a0 0abc                 	lds r26, TCB3_CCMPL //load the low bits for timer
002c13 91b0 0abd                 	lds r27, TCB3_CCMPH //load the high bits for timer
002c15 0da0                      	add r26, r0 //offset the timer values
002c16 1db1                      	adc r27, r1
002c17 93a0 0abc                 	sts TCB3_CCMPL, r26 //store the new low bits for timer
002c19 93b0 0abd                 	sts TCB3_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty:
002c1b 91e0 292e                 	lds ZL, noise_duty_macro
002c1d 91f0 292f                 	lds ZH, noise_duty_macro+1
002c1f 9630                      	adiw Z, 0
002c20 f169                      	breq sound_driver_channel3_fx_routines //if no duty macro is in use, go to the next routine
002c21 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002c22 1fff                      	rol ZH
002c23 91a0 2930                 	lds r26, noise_duty_macro_offset
002c25 0fea                      	add ZL, r26
002c26 1df2                      	adc ZH, zero
                                 
002c27 91b0 2932                 	lds r27, noise_duty_macro_release
002c29 17ba                      	cp r27, r26
002c2a f429                      	brne sound_driver_instrument_routine_channel3_duty_increment //if the current offset is not equal to the release index, increment the offset
002c2b 91a0 2931                 	lds r26, noise_duty_macro_loop
002c2d 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002c2e f010                      	brlo sound_driver_instrument_routine_channel3_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002c2f c01e                      	rjmp sound_driver_channel3_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel3_duty_increment:
002c30 95a3                      	inc r26 //increment the macro offset
002c31 93a0 2930                 	sts noise_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_duty_read:
002c33 91b4                      	lpm r27, Z //load pitch data into r27
002c34 3fbf                      	cpi r27, 0xFF //check for macro end flag
002c35 f471                      	brne sound_driver_instrument_routine_channel3_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag_check_release:
002c36 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002c37 93a0 2930                 	sts noise_duty_macro_offset, r26
002c39 91b0 2932                 	lds r27, noise_duty_macro_release
002c3b 3fbf                      	cpi r27, 0xFF
002c3c f489                      	brne sound_driver_channel3_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag_check_loop:
002c3d 91b0 2931                 	lds r27, noise_duty_macro_loop //load the loop index
002c3f 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002c40 f069                      	breq sound_driver_channel3_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
002c41 93b0 2930                 	sts noise_duty_macro_offset, r27 //store the loop index into the offset
002c43 cfd7                      	rjmp sound_driver_instrument_routine_channel3_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty_load:
002c44 95b6                      	lsr r27
002c45 95b7                      	ror r27 //move mode bit to bit 7
002c46 91c0 2814                 	lds r28, noise_period
002c48 77cf                      	andi r28, 0b01111111
002c49 2bcb                      	or r28, r27 //store the new noise mode
002c4a 93c0 2813                 	sts noise_param, r28
                                 
002c4c 776f                      	andi noise_sequence_HIGH, 0b01111111
002c4d 2b6b                      	or noise_sequence_HIGH, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_routines:
                                 sound_driver_channel3_fx_1xx_routine:
002c4e 91e0 2935                 	lds ZL, noise_fx_1xx
002c50 91f0 2936                 	lds ZH, noise_fx_1xx+1
002c52 9630                      	adiw Z, 0
002c53 f051                      	breq sound_driver_channel3_fx_2xx_routine
                                 
002c54 91a0 2937                 	lds r26, noise_fx_1xx_total //load the rate to change the pitch by
002c56 91b0 2938                 	lds r27, noise_fx_1xx_total+1
002c58 0fae                      	add r26, ZL //increase the total offset by the rate
002c59 1fbf                      	adc r27, ZH
002c5a 93a0 2937                 	sts noise_fx_1xx_total, r26
002c5c 93b0 2938                 	sts noise_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_2xx_routine:
002c5e 91e0 2939                 	lds ZL, noise_fx_2xx
002c60 91f0 293a                 	lds ZH, noise_fx_2xx+1
002c62 9630                      	adiw Z, 0
002c63 f051                      	breq sound_driver_channel3_fx_3xx_routine
                                 
002c64 91a0 293b                 	lds r26, noise_fx_2xx_total //load the rate to change the pitch by
002c66 91b0 293c                 	lds r27, noise_fx_2xx_total+1
002c68 0fae                      	add r26, ZL //increase the total offset by the rate
002c69 1fbf                      	adc r27, ZH
002c6a 93a0 293b                 	sts noise_fx_2xx_total, r26
002c6c 93b0 293c                 	sts noise_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_3xx_routine:
002c6e 91e0 2941                 	lds ZL, noise_fx_3xx_speed
002c70 91f0 2942                 	lds ZH, noise_fx_3xx_speed+1
002c72 9630                      	adiw Z, 0
002c73 f409                      	brne sound_driver_channel3_fx_3xx_routine_check_start
002c74 c048                      	rjmp sound_driver_channel3_fx_4xy_routine
                                 
                                 sound_driver_channel3_fx_3xx_routine_check_start:
002c75 91a0 293d                 	lds r26, noise_fx_3xx_start
002c77 91b0 293e                 	lds r27, noise_fx_3xx_start+1
002c79 9610                      	adiw r26:r27, 0
002c7a f409                      	brne sound_driver_channel3_fx_3xx_routine_main
002c7b c041                      	rjmp sound_driver_channel3_fx_4xy_routine
                                 
                                 sound_driver_channel3_fx_3xx_routine_main:
002c7c 91c0 293f                 	lds r28, noise_fx_3xx_target
002c7e 91d0 2940                 	lds r29, noise_fx_3xx_target+1
                                 
002c80 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
002c81 07bd                      	cpc r27, r29
002c82 f011                      	breq sound_driver_channel3_fx_3xx_routine_disable
002c83 f030                      	brlo sound_driver_channel3_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002c84 c01f                      	rjmp sound_driver_channel3_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel3_fx_3xx_routine_disable:
002c85 9220 293d                 	sts noise_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002c87 9220 293e                 	sts noise_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002c89 c033                      	rjmp sound_driver_channel3_fx_4xy_routine
                                 
                                 sound_driver_channel3_fx_3xx_routine_subtract:
002c8a 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002c8b 0bdb                      	sbc r29, r27
002c8c 91a0 2943                 	lds r26, noise_fx_3xx_total_offset
002c8e 91b0 2944                 	lds r27, noise_fx_3xx_total_offset+1
                                 
002c90 0fae                      	add r26, ZL //add the speed to the total offset
002c91 1fbf                      	adc r27, ZH
002c92 1bca                      	sub r28, r26 //invert the total difference with the total offset
002c93 0bdb                      	sbc r29, r27
002c94 f380                      	brlo sound_driver_channel3_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002c95 93a0 2943                 	sts noise_fx_3xx_total_offset, r26 //store the new total offset
002c97 93b0 2944                 	sts noise_fx_3xx_total_offset+1, r27
                                 
002c99 91a0 0abc                 	lds r26, TCB3_CCMPL //load the current timer period
002c9b 91b0 0abd                 	lds r27, TCB3_CCMPH
002c9d 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002c9e 0bbd                      	sbc r27, r29
002c9f 93a0 0abc                 	sts TCB3_CCMPL, r26
002ca1 93b0 0abd                 	sts TCB3_CCMPH, r27
002ca3 c019                      	rjmp sound_driver_channel3_fx_4xy_routine
                                 
                                 sound_driver_channel3_fx_3xx_routine_add:
002ca4 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002ca5 0bbd                      	sbc r27, r29
002ca6 91c0 2943                 	lds r28, noise_fx_3xx_total_offset
002ca8 91d0 2944                 	lds r29, noise_fx_3xx_total_offset+1
                                 
002caa 0fce                      	add r28, ZL //add the speed to the total offset
002cab 1fdf                      	adc r29, ZH
002cac 1bac                      	sub r26, r28 //invert the total difference with the total offset
002cad 0bbd                      	sbc r27, r29
002cae f2b0                      	brlo sound_driver_channel3_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002caf 93c0 2943                 	sts noise_fx_3xx_total_offset, r28 //store the new total offset
002cb1 93d0 2944                 	sts noise_fx_3xx_total_offset+1, r29
                                 
002cb3 91c0 0abc                 	lds r28, TCB3_CCMPL //load the current timer period
002cb5 91d0 0abd                 	lds r29, TCB3_CCMPH
002cb7 0fca                      	add r28, r26 //offset the current timer period with the total offset
002cb8 1fdb                      	adc r29, r27
002cb9 93c0 0abc                 	sts TCB3_CCMPL, r28
002cbb 93d0 0abd                 	sts TCB3_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel3_fx_4xy_routine:
002cbd 91a0 2945                 	lds r26, noise_fx_4xy_speed
002cbf 15a2                      	cp r26, zero
002cc0 f409                      	brne sound_driver_channel3_fx_4xy_routine_continue
002cc1 c05c                      	rjmp sound_driver_channel3_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel3_fx_4xy_routine_continue:
002cc2 91b0 2946                 	lds r27, noise_fx_4xy_depth
002cc4 91c0 2947                 	lds r28, noise_fx_4xy_phase
002cc6 0fca                      	add r28, r26 //increase the phase by the speed
002cc7 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002cc8 f008                      	brlo sound_driver_channel3_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002cc9 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase:
002cca 93c0 2947                 	sts noise_fx_4xy_phase, r28 //store the new phase
002ccc 31c0                      	cpi r28, 16
002ccd f028                      	brlo sound_driver_channel3_fx_4xy_routine_phase_0
002cce 32c0                      	cpi r28, 32
002ccf f028                      	brlo sound_driver_channel3_fx_4xy_routine_phase_1
002cd0 33c0                      	cpi r28, 48
002cd1 f030                      	brlo sound_driver_channel3_fx_4xy_routine_phase_2
002cd2 c007                      	rjmp sound_driver_channel3_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_0:
002cd3 70cf                      	andi r28, 0x0F //mask for values 0-15
002cd4 c029                      	rjmp sound_driver_channel3_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_1:
002cd5 6fc0                      	ori r28, 0xF0
002cd6 95c0                      	com r28 //invert values 0-15
002cd7 c026                      	rjmp sound_driver_channel3_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_2:
002cd8 70cf                      	andi r28, 0x0F //mask for values 0-15
002cd9 c003                      	rjmp sound_driver_channel3_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_3:
002cda 6fc0                      	ori r28, 0xF0
002cdb 95c0                      	com r28 //invert values 0-15
002cdc c000                      	rjmp sound_driver_channel3_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel3_fx_4xy_routine_load_add:
002cdd 95b2                      	swap r27 //multiply depth by 16
002cde 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002cdf e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002ce0 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002ce1 0fec                      	add ZL, r28 //offset the table by the depth+phase
002ce2 1df2                      	adc ZH, zero
002ce3 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002ce4 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002ce5 937f                      	push r23
002ce6 2f6c                      	mov r22, r28 //store the vibrato value into r22
002ce7 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002ce8 9f67                      	mul r22, r23
002ce9 917f                      	pop r23
002cea 916f                      	pop r22
                                 
002ceb 9416                      	lsr r1 //shift out the fractional bits
002cec 9407                      	ror r0
002ced 9416                      	lsr r1
002cee 9407                      	ror r0
002cef 9416                      	lsr r1
002cf0 9407                      	ror r0
002cf1 9416                      	lsr r1
002cf2 9407                      	ror r0
                                 	
002cf3 91a0 0abc                 	lds r26, TCB3_CCMPL
002cf5 91b0 0abd                 	lds r27, TCB3_CCMPH
002cf7 0da0                      	add r26, r0
002cf8 1db1                      	adc r27, r1
002cf9 93a0 0abc                 	sts TCB3_CCMPL, r26
002cfb 93b0 0abd                 	sts TCB3_CCMPH, r27
002cfd c020                      	rjmp sound_driver_channel3_fx_7xy_routine
                                 
                                 sound_driver_channel3_fx_4xy_routine_load_subtract:
002cfe 95b2                      	swap r27 //multiply depth by 16
002cff 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002d00 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002d01 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002d02 0fec                      	add ZL, r28 //offset the table by the depth+phase
002d03 1df2                      	adc ZH, zero
002d04 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002d05 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002d06 937f                      	push r23
002d07 2f6c                      	mov r22, r28 //store the vibrato value into r22
002d08 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002d09 9f67                      	mul r22, r23
002d0a 917f                      	pop r23
002d0b 916f                      	pop r22
                                 
002d0c 9416                      	lsr r1 //shift out the fractional bits
002d0d 9407                      	ror r0
002d0e 9416                      	lsr r1
002d0f 9407                      	ror r0
002d10 9416                      	lsr r1
002d11 9407                      	ror r0
002d12 9416                      	lsr r1
002d13 9407                      	ror r0
                                 
002d14 91a0 0abc                 	lds r26, TCB3_CCMPL
002d16 91b0 0abd                 	lds r27, TCB3_CCMPH
002d18 19a0                      	sub r26, r0
002d19 09b1                      	sbc r27, r1
002d1a 93a0 0abc                 	sts TCB3_CCMPL, r26
002d1c 93b0 0abd                 	sts TCB3_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_7xy_routine:
002d1e 91a0 2948                 	lds r26, noise_fx_7xy_speed
002d20 15a2                      	cp r26, zero
002d21 f0e9                      	breq sound_driver_channel3_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
002d22 91b0 2949                 	lds r27, noise_fx_7xy_depth
002d24 91c0 294a                 	lds r28, noise_fx_7xy_phase
002d26 0fca                      	add r28, r26 //increase the phase by the speed
002d27 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002d28 f008                      	brlo sound_driver_channel3_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
002d29 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel3_fx_7xy_routine_phase:
002d2a 93c0 294a                 	sts noise_fx_7xy_phase, r28 //store the new phase
002d2c 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
002d2d ffc4                      	sbrs r28, 4
002d2e c001                      	rjmp sound_driver_channel3_fx_7xy_routine_phase_0
002d2f c002                      	rjmp sound_driver_channel3_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel3_fx_7xy_routine_phase_0:
002d30 70cf                      	andi r28, 0x0F //mask for values 0-15
002d31 c003                      	rjmp sound_driver_channel3_fx_7xy_routine_load
                                 
                                 sound_driver_channel3_fx_7xy_routine_phase_1:
002d32 6fc0                      	ori r28, 0xF0
002d33 95c0                      	com r28 //invert values 0-15
002d34 c000                      	rjmp sound_driver_channel3_fx_7xy_routine_load
                                 
                                 sound_driver_channel3_fx_7xy_routine_load:
002d35 95b2                      	swap r27 //multiply depth by 16
002d36 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002d37 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002d38 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002d39 0fec                      	add ZL, r28 //offset the table by the depth+phase
002d3a 1df2                      	adc ZH, zero
002d3b 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002d3c 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
002d3d 93c0 294b                 	sts noise_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Axy_routine:
002d3f 91b0 294c                 	lds r27, noise_fx_Axy
002d41 15b2                      	cp r27, zero
002d42 f0e9                      	breq sound_driver_channel3_fx_Qxy_routine //0 means that the effect is not in use
                                 	
002d43 91a0 2815                 	lds r26, noise_fractional_volume //load fractional volume representation of the channel
002d45 91c0 2813                 	lds r28, noise_param //load the integer volume representation of the channel
002d47 2fda                      	mov r29, r26 //copy fractional volume into r29
002d48 2fec                      	mov r30, r28 //copy the noise_param into r30
002d49 95e2                      	swap r30
002d4a 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
002d4b 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
002d4c 17ed                      	cp r30, r29 //compare the fractional and integer volumes
002d4d f009                      	breq sound_driver_channel3_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel3_fx_Axy_routine_reload:
002d4e 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate:
002d4f fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
002d50 c004                      	rjmp sound_driver_channel3_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_addition:
002d51 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002d52 f428                      	brcc sound_driver_channel3_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002d53 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
002d54 c003                      	rjmp sound_driver_channel3_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_subtraction:
002d55 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002d56 f008                      	brcs sound_driver_channel3_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002d57 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_store:
002d58 93a0 2815                 	sts noise_fractional_volume, r26 //store the new fractional volume
002d5a 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
002d5b 95a2                      	swap r26
002d5c 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
002d5d 2bca                      	or r28, r26 //store the new volume back into noise_param
002d5e 93c0 2813                 	sts noise_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel3_fx_Qxy_routine:
002d60 91e0 2952                 	lds ZL, noise_fx_Qxy_target
002d62 91f0 2953                 	lds ZH, noise_fx_Qxy_target+1
002d64 9630                      	adiw Z, 0
002d65 f119                      	breq sound_driver_channel3_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002d66 91a0 2956                 	lds r26, noise_fx_Qxy_total_offset
002d68 91b0 2957                 	lds r27, noise_fx_Qxy_total_offset+1
002d6a 91c0 0abc                 	lds r28, TCB3_CCMPL
002d6c 91d0 0abd                 	lds r29, TCB3_CCMPH
                                 
002d6e 1bec                      	sub ZL, r28 //calculate the difference to the target
002d6f 0bfd                      	sbc ZH, r29
002d70 f408                      	brsh sound_driver_channel3_fx_Qxy_routine_end //if the target has been reached (or passed)
002d71 f068                      	brlo sound_driver_channel3_fx_Qxy_routine_add
                                 
                                 sound_driver_channel3_fx_Qxy_routine_end:
002d72 9220 2956                 	sts noise_fx_Qxy_total_offset, zero //turn off the effect
002d74 9220 2957                 	sts noise_fx_Qxy_total_offset+1, zero
002d76 9220 2952                 	sts noise_fx_Qxy_target, zero
002d78 9220 2953                 	sts noise_fx_Qxy_target+1, zero
002d7a 91b0 2951                 	lds r27, noise_fx_Qxy_target_note
002d7c 93b0 2817                 	sts noise_note, r27 //replace the note with the final target note
002d7e c00a                      	rjmp sound_driver_channel3_fx_Rxy_routine
                                 
                                 sound_driver_channel3_fx_Qxy_routine_add:
002d7f 91c0 2954                 	lds r28, noise_fx_Qxy_speed
002d81 91d0 2955                 	lds r29, noise_fx_Qxy_speed+1
002d83 0fac                      	add r26, r28 //increase the total offset by the speed
002d84 1fbd                      	adc r27, r29
002d85 93a0 2956                 	sts noise_fx_Qxy_total_offset, r26 //store the total offset
002d87 93b0 2957                 	sts noise_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Rxy_routine:
002d89 91e0 2959                 	lds ZL, noise_fx_Rxy_target
002d8b 91f0 295a                 	lds ZH, noise_fx_Rxy_target+1
002d8d 9630                      	adiw Z, 0
002d8e f119                      	breq sound_driver_instrument_routine_channel4_volume //if the effect is not enabled, skip the routine
                                 
002d8f 91a0 295d                 	lds r26, noise_fx_Rxy_total_offset
002d91 91b0 295e                 	lds r27, noise_fx_Rxy_total_offset+1
002d93 91c0 0abc                 	lds r28, TCB3_CCMPL
002d95 91d0 0abd                 	lds r29, TCB3_CCMPH
                                 
002d97 1bce                      	sub r28, ZL //calculate the difference to the target
002d98 0bdf                      	sbc r29, ZH
002d99 f408                      	brsh sound_driver_channel3_fx_Rxy_routine_end //if the target has been reached (or passed)
002d9a f068                      	brlo sound_driver_channel3_fx_Rxy_routine_add
                                 
                                 sound_driver_channel3_fx_Rxy_routine_end:
002d9b 9220 295d                 	sts noise_fx_Rxy_total_offset, zero //disable the effect
002d9d 9220 295e                 	sts noise_fx_Rxy_total_offset+1, zero
002d9f 9220 2959                 	sts noise_fx_Rxy_target, zero
002da1 9220 295a                 	sts noise_fx_Rxy_target+1, zero
002da3 91b0 2958                 	lds r27, noise_fx_Rxy_target_note
002da5 93b0 2817                 	sts noise_note, r27 //replace the note with the final target note
002da7 c00a                      	rjmp sound_driver_instrument_routine_channel4_volume
                                 
                                 sound_driver_channel3_fx_Rxy_routine_add:
002da8 91c0 295b                 	lds r28, noise_fx_Rxy_speed
002daa 91d0 295c                 	lds r29, noise_fx_Rxy_speed+1
002dac 0fac                      	add r26, r28 //increase the total offset by the speed
002dad 1fbd                      	adc r27, r29
002dae 93a0 295d                 	sts noise_fx_Rxy_total_offset, r26 //store the total offset
002db0 93b0 295e                 	sts noise_fx_Rxy_total_offset+1, r27
                                 
                                 sound_driver_instrument_routine_channel4_volume:
                                 
                                 sound_driver_exit:
002db2 91ff                      	pop r31
002db3 91ef                      	pop r30
002db4 91df                      	pop r29
002db5 91cf                      	pop r28
002db6 940c 1293                 	jmp sequence_1_3 + 3 //+3 is to skip the stack instructions since we already pushed them
                                 
                                 
                                 
                                 //TABLES
002db8 7f05
002db9 010a
002dba 0214
002dbb 0328
002dbc 0450
002dbd 051e
002dbe 0607
002dbf 070d
002dc0 0806
002dc1 090c
002dc2 0a18
002dc3 0b30
002dc4 0c60
002dc5 0d24
002dc6 0e08
002dc7 0f10                      length: .db $05, $7F, $0A, $01, $14, $02, $28, $03, $50, $04, $1E, $05, $07, $06, $0D, $07, $06, $08, $0C, $09, $18, $0A, $30, $0B, $60, $0C, $24, $0D, $08, $0E, $10, $0F
                                 
                                 //pulse sequences: 12.5%, 25%, 50%, 75%
002dc8 0301
002dc9 fc0f                      sequences: .db 0b00000001, 0b00000011, 0b00001111, 0b11111100
                                 
                                 //list of famitracker fx: http://famitracker.com/wiki/index.php?title=Effect_list
                                 channel0_fx:
002dca 14cf
002dcb 14d4
002dcc 14f0
002dcd 150c
002dce 152f                      	.dw sound_driver_channel0_fx_0xy, sound_driver_channel0_fx_1xx, sound_driver_channel0_fx_2xx, sound_driver_channel0_fx_3xx, sound_driver_channel0_fx_4xy
002dcf 153a
002dd0 1547
002dd1 154a
002dd2 154d
002dd3 1550                      	.dw sound_driver_channel0_fx_7xy, sound_driver_channel0_fx_Axy, sound_driver_channel0_fx_Bxx, sound_driver_channel0_fx_Cxx, sound_driver_channel0_fx_Dxx
002dd4 1553
002dd5 155b
002dd6 155e
002dd7 156b
002dd8 156c                      	.dw sound_driver_channel0_fx_Exx, sound_driver_channel0_fx_Fxx, sound_driver_channel0_fx_Gxx, sound_driver_channel0_fx_Hxy, sound_driver_channel0_fx_Ixy
002dd9 156d
002dda 156e
002ddb 156f
002ddc 1587
002ddd 15c9                      	.dw sound_driver_channel0_fx_Hxx, sound_driver_channel0_fx_Ixx, sound_driver_channel0_fx_Pxx, sound_driver_channel0_fx_Qxy, sound_driver_channel0_fx_Rxy
002dde 160a
002ddf 1617
002de0 162b
002de1 162c
002de2 162d                      	.dw sound_driver_channel0_fx_Sxx, sound_driver_channel0_fx_Vxx, sound_driver_channel0_fx_Wxx, sound_driver_channel0_fx_Xxx, sound_driver_channel0_fx_Yxx
002de3 162e                      	.dw sound_driver_channel0_fx_Zxx
                                 
                                 channel1_fx:
002de4 17bd
002de5 17c2
002de6 17de
002de7 17fa
002de8 181d                      	.dw sound_driver_channel1_fx_0xy, sound_driver_channel1_fx_1xx, sound_driver_channel1_fx_2xx, sound_driver_channel1_fx_3xx, sound_driver_channel1_fx_4xy
002de9 1828
002dea 1835
002deb 1838
002dec 183b
002ded 183e                      	.dw sound_driver_channel1_fx_7xy, sound_driver_channel1_fx_Axy, sound_driver_channel1_fx_Bxx, sound_driver_channel1_fx_Cxx, sound_driver_channel1_fx_Dxx
002dee 1841
002def 1849
002df0 184c
002df1 1859
002df2 185a                      	.dw sound_driver_channel1_fx_Exx, sound_driver_channel1_fx_Fxx, sound_driver_channel1_fx_Gxx, sound_driver_channel1_fx_Hxy, sound_driver_channel1_fx_Ixy
002df3 185b
002df4 185c
002df5 185d
002df6 1875
002df7 18b7                      	.dw sound_driver_channel1_fx_Hxx, sound_driver_channel1_fx_Ixx, sound_driver_channel1_fx_Pxx, sound_driver_channel1_fx_Qxy, sound_driver_channel1_fx_Rxy
002df8 18f8
002df9 1905
002dfa 1919
002dfb 191a
002dfc 191b                      	.dw sound_driver_channel1_fx_Sxx, sound_driver_channel1_fx_Vxx, sound_driver_channel1_fx_Wxx, sound_driver_channel1_fx_Xxx, sound_driver_channel1_fx_Yxx
002dfd 191c                      	.dw sound_driver_channel1_fx_Zxx
                                 
                                 channel2_fx:
002dfe 1a9e
002dff 1aa3
002e00 1abf
002e01 1adb
002e02 1afe                      	.dw sound_driver_channel2_fx_0xy, sound_driver_channel2_fx_1xx, sound_driver_channel2_fx_2xx, sound_driver_channel2_fx_3xx, sound_driver_channel2_fx_4xy
002e03 1b09
002e04 1b0a
002e05 1b0b
002e06 1b0e
002e07 1b11                      	.dw sound_driver_channel2_fx_7xy, sound_driver_channel2_fx_Axy, sound_driver_channel2_fx_Bxx, sound_driver_channel2_fx_Cxx, sound_driver_channel2_fx_Dxx
002e08 1b14
002e09 1b21
002e0a 1b24
002e0b 1b31
002e0c 1b32                      	.dw sound_driver_channel2_fx_Exx, sound_driver_channel2_fx_Fxx, sound_driver_channel2_fx_Gxx, sound_driver_channel2_fx_Hxy, sound_driver_channel2_fx_Ixy
002e0d 1b33
002e0e 1b34
002e0f 1b35
002e10 1b4d
002e11 1b8f                      	.dw sound_driver_channel2_fx_Hxx, sound_driver_channel2_fx_Ixx, sound_driver_channel2_fx_Pxx, sound_driver_channel2_fx_Qxy, sound_driver_channel2_fx_Rxy
002e12 1bd0
002e13 1bdd
002e14 1bde
002e15 1bdf
002e16 1be0                      	.dw sound_driver_channel2_fx_Sxx, sound_driver_channel2_fx_Vxx, sound_driver_channel2_fx_Wxx, sound_driver_channel2_fx_Xxx, sound_driver_channel2_fx_Yxx
002e17 1be1                      	.dw sound_driver_channel2_fx_Zxx
                                 
                                 channel3_fx:
002e18 1d67
002e19 1d6c
002e1a 1d88
002e1b 1da4
002e1c 1dc7                      	.dw sound_driver_channel3_fx_0xy, sound_driver_channel3_fx_1xx, sound_driver_channel3_fx_2xx, sound_driver_channel3_fx_3xx, sound_driver_channel3_fx_4xy
002e1d 1dd2
002e1e 1ddf
002e1f 1de2
002e20 1de5
002e21 1de8                      	.dw sound_driver_channel3_fx_7xy, sound_driver_channel3_fx_Axy, sound_driver_channel3_fx_Bxx, sound_driver_channel3_fx_Cxx, sound_driver_channel3_fx_Dxx
002e22 1deb
002e23 1df2
002e24 1df5
002e25 1e02
002e26 1e03                      	.dw sound_driver_channel3_fx_Exx, sound_driver_channel3_fx_Fxx, sound_driver_channel3_fx_Gxx, sound_driver_channel3_fx_Hxy, sound_driver_channel3_fx_Ixy
002e27 1e04
002e28 1e05
002e29 1e06
002e2a 1e1e
002e2b 1e60                      	.dw sound_driver_channel3_fx_Hxx, sound_driver_channel3_fx_Ixx, sound_driver_channel3_fx_Pxx, sound_driver_channel3_fx_Qxy, sound_driver_channel3_fx_Rxy
002e2c 1ea1
002e2d 1eae
002e2e 1eb9
002e2f 1eba
002e30 1ebb                      	.dw sound_driver_channel3_fx_Sxx, sound_driver_channel3_fx_Vxx, sound_driver_channel3_fx_Wxx, sound_driver_channel3_fx_Xxx, sound_driver_channel3_fx_Yxx
002e31 1ebc                      	.dw sound_driver_channel3_fx_Zxx
                                 
                                 //famitracker volumes table: http://famitracker.com/wiki/index.php?title=Volume
                                 volumes:
002e32 0000
002e33 0000
002e34 0000
002e35 0000
002e36 0000
002e37 0000
002e38 0000
002e39 0000                      	.db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
002e3a 0100
002e3b 0101
002e3c 0101
002e3d 0101
002e3e 0101
002e3f 0101
002e40 0101
002e41 0101                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
002e42 0100
002e43 0101
002e44 0101
002e45 0101
002e46 0101
002e47 0101
002e48 0101
002e49 0201                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02
002e4a 0100
002e4b 0101
002e4c 0101
002e4d 0101
002e4e 0101
002e4f 0202
002e50 0202
002e51 0302                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03
002e52 0100
002e53 0101
002e54 0101
002e55 0101
002e56 0202
002e57 0202
002e58 0303
002e59 0403                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04
002e5a 0100
002e5b 0101
002e5c 0101
002e5d 0202
002e5e 0302
002e5f 0303
002e60 0404
002e61 0504                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05
002e62 0100
002e63 0101
002e64 0201
002e65 0202
002e66 0303
002e67 0404
002e68 0504
002e69 0605                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x06
002e6a 0100
002e6b 0101
002e6c 0201
002e6d 0302
002e6e 0403
002e6f 0504
002e70 0605
002e71 0706                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07
002e72 0100
002e73 0101
002e74 0202
002e75 0303
002e76 0404
002e77 0505
002e78 0606
002e79 0807                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07, 0x08
002e7a 0100
002e7b 0101
002e7c 0302
002e7d 0403
002e7e 0504
002e7f 0606
002e80 0707
002e81 0908                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09
002e82 0100
002e83 0201
002e84 0302
002e85 0404
002e86 0605
002e87 0706
002e88 0808
002e89 0a09                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A
002e8a 0100
002e8b 0201
002e8c 0302
002e8d 0504
002e8e 0605
002e8f 0807
002e90 0908
002e91 0b0a                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B
002e92 0100
002e93 0201
002e94 0403
002e95 0504
002e96 0706
002e97 0808
002e98 0a09
002e99 0c0b                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B, 0x0C
002e9a 0100
002e9b 0201
002e9c 0403
002e9d 0605
002e9e 0706
002e9f 0908
002ea0 0b0a
002ea1 0d0c                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D
002ea2 0100
002ea3 0201
002ea4 0403
002ea5 0605
002ea6 0807
002ea7 0a09
002ea8 0c0b
002ea9 0e0d                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E
002eaa 0100
002eab 0302
002eac 0504
002ead 0706
002eae 0908
002eaf 0b0a
002eb0 0d0c


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega4809" register use summary:
x  :   0 y  :   0 z  : 248 r0 : 196 r1 : 212 r2 : 709 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   6 r11:   4 r12:   9 
r13:   6 r14:   4 r15:   9 r16:   7 r17:   6 r18:   7 r19:   6 r20:   4 
r21:   9 r22: 174 r23: 160 r24:   0 r25:  24 r26: 955 r27:1197 r28: 687 
r29: 356 r30: 374 r31: 333 
Registers used: 25 out of 35 (71.4%)

"ATmega4809" instruction use summary:
.lds  :   0 .sts  :   0 adc   : 144 add   : 191 adiw  : 106 and   :   0 
andi  :  99 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   7 brcs  :  13 break :   0 breq  : 173 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  81 brlt  :   0 brmi  :   0 
brne  : 121 brpl  :   0 brsh  :  31 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :   0 cbr   :   5 
clc   :   0 clh   :   0 cli   :   8 cln   :   0 clr   :   5 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :  16 cp    : 101 cpc   :  10 
cpi   : 168 cpse  :  20 dec   :  35 des   :   0 eor   :   2 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   4 in    :   7 inc   :  48 
jmp   :  11 ld    :   0 ldd   :   0 ldi   : 294 lds   : 719 lpm   : 260 
lsl   :  79 lsr   : 171 mov   : 139 movw  :   0 mul   :  28 muls  :   0 
mulsu :  12 neg   :   0 nop   :   0 or    :  26 ori   :  12 out   :   9 
pop   : 115 push  : 109 rcall :  50 ret   :  32 reti  :   7 rjmp  : 518 
rol   :  53 ror   : 192 sbc   :  40 sbci  :   0 sbi   :   0 sbic  :   0 
sbis  :   0 sbiw  :   0 sbr   :  12 sbrc  :  29 sbrs  :  20 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   :1413 sub   :  58 subi  :  45 swap  :  46 tst   :   0 wdr   :   0 

Instructions used: 52 out of 114 (45.6%)

"ATmega4809" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x005d64  15886   7910  23796   49152  48.4%
[.dseg] 0x002800 0x002962      0    354    354    6144   5.8%
[.eseg] 0x000000 0x000000      0      0      0     256   0.0%

Assembly complete, 0 errors, 55 warnings
