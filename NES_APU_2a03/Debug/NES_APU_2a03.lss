
AVRASM ver. 2.2.8  C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm Thu Jan 07 00:04:40 2021

C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
                                 
                                 
                                 ; NES_APU_2a03.asm
                                 ;
                                 ; Created: 11/29/2020 1:44:10 AM
                                 ; Author : Tennyson Cheng
                                 ;
                                 
                                 .list
                                 
                                 .dseg
002800                           pulse1_param: .byte 1 //$4000 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002801                           pulse1_sweep_param: .byte 1 //$4001 EPPP.NSSS = Enable, Period, Negate, Shift
                                 //NOTE: In order to account for multiplier, we use 16 instead of 11 bits for the timer
002802                           pulse1_timerL: .byte 1 //$4002 LLLL.LLLL = Low 8 bits for timer
002803                           pulse1_timerH: .byte 1 //$4002 HHHH.HHHH = High 8 bits for timer
002804                           pulse1_length: .byte 1 //$4002 000l.llll = Length counter load
002805                           pulse1_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002806                           pulse1_output_volume: .byte 1 //this is the final output volume of pulse 1
002807                           pulse1_note: .byte 1 //the current note index in the note table
                                 
002808                           song_frames: .byte 2
00280a                           song_frame_offset: .byte 2
                                 
                                 
                                 
00280c                           pulse1_pattern: .byte 2
00280e                           pulse1_pattern_delay: .byte 1
00280f                           pulse1_pattern_offset: .byte 2
                                 
002811                           pulse1_volume_macro: .byte 2
002813                           pulse1_volume_macro_offset: .byte 1
002814                           pulse1_volume_macro_loop: .byte 1
002815                           pulse1_volume_macro_release: .byte 1
                                 
002816                           pulse1_arpeggio_macro: .byte 2
002818                           pulse1_arpeggio_macro_offset: .byte 1
002819                           pulse1_arpeggio_macro_loop: .byte 1
00281a                           pulse1_arpeggio_macro_release: .byte 1
00281b                           pulse1_arpeggio_macro_mode: .byte 1
                                 
00281c                           pulse1_total_pitch_offset: .byte 1 //used to reference the overall change in pitch for the pitch macro
00281d                           pulse1_pitch_macro: .byte 2
00281f                           pulse1_pitch_macro_offset: .byte 1
002820                           pulse1_pitch_macro_loop: .byte 1
002821                           pulse1_pitch_macro_release: .byte 1
                                 
002822                           pulse1_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
002823                           pulse1_hi_pitch_macro: .byte 2
002825                           pulse1_hi_pitch_macro_offset: .byte 1
002826                           pulse1_hi_pitch_macro_loop: .byte 1
002827                           pulse1_hi_pitch_macro_release: .byte 1
                                 
002828                           pulse1_duty_macro: .byte 2
00282a                           pulse1_duty_macro_offset: .byte 1
00282b                           pulse1_duty_macro_loop: .byte 1
00282c                           pulse1_duty_macro_release: .byte 1
                                 
00282d                           pulse1_fx_Pxx: .byte 1 //refers to the fine pitch offset set by the Pxx effect
00282e                           pulse1_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
00282f                           pulse1_fx_Qxy_target: .byte 2 //target note period
002831                           pulse1_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002833                           pulse1_fx_Qxy_total_offset: .byte 2 //number of times to compute NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002835                           pulse1_fx_Rxy_target: .byte 2 //target note period
002837                           pulse1_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
002839                           pulse1_fx_Rxy_total_offset: .byte 2 //number of times to compute
                                 
00283b                           pulse2_pattern_delay: .byte 1
00283c                           triangle_pattern_delay: .byte 1
00283d                           noise_pattern_delay: .byte 1
00283e                           dcpm_pattern_delay: .byte 1
                                 
                                 .cseg
                                 
                                 //NOTE: zero is defined in order to use the cp instruction without the need to load 0x00 into a register beforehand
                                 .def zero = r2
                                 .def channel_flags = r25 //[pulse1.pulse2] RSlc.0000 = Reload, Start, Length halt/Loop, Constant volume
                                 .def pulse1_sequence = r13
                                 .def pulse1_length_counter = r14
                                 .def pulse1_sweep = r15 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse1_volume_divider = r16 //0000.PPPP = Period divider
                                 .def pulse1_volume_decay = r17 //0000.dddd = Decay
                                 
                                 reset:
000000 940c 0f24                 	jmp init
                                 
                                 .org TCA0_OVF_vect
00000e 940c 1037                 	jmp sound_driver
                                 
                                 .org TCA0_CMP0_vect
000012 940c 101d                 	jmp sequence_0_2
                                 
                                 .org TCA0_CMP1_vect
000014 940c 1027                 	jmp sequence_1_3
                                 
                                 .org TCA0_CMP2_vect
000016 940c 101d                 	jmp sequence_0_2
                                 
                                 .org TCB0_INT_vect
000018 940c 145c                 	jmp pulse1_sequence_routine
                                 
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(47): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(48): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(49): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(50): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(51): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(52): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(53): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(54): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(55): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(56): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(57): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(58): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(59): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(60): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(61): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(62): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(64): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(65): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(67): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(68): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(69): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(71): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(72): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(73): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(75): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(76): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(77): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(78): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(81): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(82): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(83): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(85): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(86): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(88): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(89): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(90): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(97): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(98): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(99): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(104): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(109): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(110): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(111): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(112): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(113): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(114): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(115): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(116): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(117): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(120): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(121): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(122): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(128): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(129): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(131): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(132): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(133): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(134): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(136): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(137): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(138): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(139): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(140): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(141): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(146): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(257): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(258): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(259): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(261): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(266): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(267): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(268): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(269): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(270): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(271): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(272): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(273): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(274): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(276): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(280): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(281): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(282): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(283): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(285): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(286): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(288): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(292): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(296): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(297): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(298): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(299): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(301): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(302): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(303): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(306): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(307): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(310): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(311): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(313): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(320): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(321): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(104): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
                                 .list
                                 
                                 init:
                                 	//MAIN CLOCK
000f24 edb8                      	ldi r27, CPU_CCP_IOREG_gc //protected write
000f25 93b0 0034                 	sts CPU_CCP, r27
000f27 e0b0                      	ldi r27, 0 << CLKCTRL_PEN_bp //disable prescaler for 20 MHz on main clock
000f28 93b0 0061                 	sts CLKCTRL_MCLKCTRLB, r27
                                 
                                 /*	//TEST FOR C4, 1 SECOND, 50% DD
                                 	ldi r26, 0x97
                                 	ldi r27, 0x12
                                 	ldi r26, 0x15
                                 	ldi r27, 0x09
                                 	sts pulse1_timerL, r26
                                 	sts pulse1_timerH, r27
                                 	ldi r27, 0b10111111
                                 	sts pulse1_param, r27
                                 	ldi r27, 0x01
                                 	sts pulse1_length, r27
                                 	//TEST FOR SWEEP UP
                                 	ldi r27, 0b11111111
                                 	sts pulse1_sweep_param, r27*/
                                 
                                 	//ZERO
000f2a 2422                      	clr zero
                                 
                                 	//MEMORY
000f2b e3b0                      	ldi r27, 0b00110000
000f2c 93b0 2800                 	sts pulse1_param, r27
000f2e e8b0                      	ldi r27, 0b10000000
000f2f 93b0 2801                 	sts pulse1_sweep_param, r27
000f31 efbf                      	ldi r27, 0xFF
000f32 93b0 2802                 	sts pulse1_timerL, r27
000f34 93b0 2803                 	sts pulse1_timerH, r27
000f36 93b0 2804                 	sts pulse1_length, r27
                                 
000f38 e0b0                      	ldi r27, 0x00
000f39 93b0 280a                 	sts song_frame_offset, r27
000f3b 93b0 280b                 	sts song_frame_offset+1, r27
000f3d eee2                      	ldi ZL, LOW(song0_frames << 1)
000f3e e0f0                      	ldi ZH, HIGH(song0_frames << 1)
000f3f 93e0 2808                 	sts song_frames, ZL
000f41 93f0 2809                 	sts song_frames+1, ZH
                                 
                                 	//CHANNEL 0 TEST
000f43 e0b0                      	ldi r27, 0x00
000f44 0feb                      	add ZL, r27
000f45 1df2                      	adc ZH, zero
000f46 91a5                      	lpm r26, Z+
000f47 91b4                      	lpm r27, Z
000f48 0faa                      	lsl r26
000f49 1fbb                      	rol r27
000f4a 93a0 280c                 	sts pulse1_pattern, r26
000f4c 93b0 280d                 	sts pulse1_pattern+1, r27
000f4e e0b0                      	ldi r27, 0x00
000f4f 9220 280e                 	sts pulse1_pattern_delay, zero
000f51 9220 280f                 	sts pulse1_pattern_offset, zero
000f53 9220 2810                 	sts pulse1_pattern_offset+1, zero
                                 
                                 	//channel 0 instrument macros
000f55 efbf                      	ldi r27, 0xFF
000f56 9220 2813                 	sts pulse1_volume_macro_offset, zero
000f58 93b0 2814                 	sts pulse1_volume_macro_loop, r27
000f5a 93b0 2815                 	sts pulse1_volume_macro_release, r27
000f5c 9220 2818                 	sts pulse1_arpeggio_macro_offset, zero
000f5e 93b0 2819                 	sts pulse1_arpeggio_macro_loop, r27
000f60 93b0 281a                 	sts pulse1_arpeggio_macro_release, r27
000f62 93b0 281b                 	sts pulse1_arpeggio_macro_mode, r27
000f64 9220 281f                 	sts pulse1_pitch_macro_offset, zero
000f66 93b0 2820                 	sts pulse1_pitch_macro_loop, r27
000f68 93b0 2821                 	sts pulse1_pitch_macro_release, r27
000f6a 9220 2825                 	sts pulse1_hi_pitch_macro_offset, zero
000f6c 93b0 2826                 	sts pulse1_hi_pitch_macro_loop, r27
000f6e 93b0 2827                 	sts pulse1_hi_pitch_macro_release, r27
000f70 9220 282a                 	sts pulse1_duty_macro_offset, zero
000f72 93b0 282b                 	sts pulse1_duty_macro_loop, r27
000f74 93b0 282c                 	sts pulse1_duty_macro_release, r27
                                 
000f76 9220 2811                 	sts pulse1_volume_macro, zero
000f78 9220 2812                 	sts pulse1_volume_macro+1, zero
000f7a 9220 2816                 	sts pulse1_arpeggio_macro, zero
000f7c 9220 2817                 	sts pulse1_arpeggio_macro+1, zero
000f7e 9220 281c                 	sts pulse1_total_pitch_offset, zero
000f80 9220 281d                 	sts pulse1_pitch_macro, zero
000f82 9220 281e                 	sts pulse1_pitch_macro+1, zero
000f84 9220 2822                 	sts pulse1_total_hi_pitch_offset, zero
000f86 9220 2823                 	sts pulse1_hi_pitch_macro, zero
000f88 9220 2824                 	sts pulse1_hi_pitch_macro+1, zero
000f8a 9220 2828                 	sts pulse1_duty_macro, zero
000f8c 9220 2829                 	sts pulse1_duty_macro+1, zero
                                 
000f8e 9220 283b                 	sts pulse2_pattern_delay, zero
000f90 9220 283c                 	sts triangle_pattern_delay, zero
000f92 9220 283d                 	sts noise_pattern_delay, zero
000f94 9220 283e                 	sts dcpm_pattern_delay, zero
                                 
                                 	//PINS
000f96 efbf                      	ldi r27, 0xFF //set all pins in VPORTD to output
000f97 b9b0                      	out VPORTA_DIR, r27
                                 
                                 	//ENVELOPE
000f98 e00f                      	ldi pulse1_volume_divider, 0x0F
000f99 9110 2800                 	lds pulse1_volume_decay, pulse1_param
000f9b 701f                      	andi pulse1_volume_decay, 0x0F //mask for VVVV bits
000f9c 9190 2800                 	lds channel_flags, pulse1_param
000f9e 7390                      	andi channel_flags, 0b00110000
000f9f 6490                      	sbr channel_flags, 0b01000000 //set start flag
000fa0 9220 2806                 	sts pulse1_output_volume, zero
000fa2 93b0 2805                 	sts pulse1_fractional_volume, r27 //initialize fractional volume to max value
                                 	
                                 	//LENGTH
000fa4 91d0 2804                 	lds r29, pulse1_length
000fa6 d502                      	rcall length_converter
000fa7 2eed                      	mov pulse1_length_counter, r29
                                 
                                 	//SEQUENCE
000fa8 91d0 2800                 	lds r29, pulse1_param //load param for sequence table
000faa 0fdd                      	lsl r29 //shift duty cycle bits to LSB
000fab 1fdd                      	rol r29
000fac 1fdd                      	rol r29
000fad 70d3                      	andi r29, 0b00000011 //mask duty cycle bits
000fae d510                      	rcall duty_cycle_sequences
000faf 2edd                      	mov pulse1_sequence, r29
                                 
                                 	//SWEEP
000fb0 90f0 2801                 	lds pulse1_sweep, pulse1_sweep_param
000fb2 94f2                      	swap pulse1_sweep //swap data from high byte and low byte
000fb3 6890                      	sbr channel_flags, 0b10000000 //set reload flag
                                 
                                 	//FX
000fb4 9220 282d                 	sts pulse1_fx_Pxx, zero
000fb6 9220 282e                 	sts pulse1_fx_Axy, zero
000fb8 9220 282f                 	sts pulse1_fx_Qxy_target, zero
000fba 9220 2830                 	sts pulse1_fx_Qxy_target+1, zero
000fbc 9220 2831                 	sts pulse1_fx_Qxy_speed, zero
000fbe 9220 2832                 	sts pulse1_fx_Qxy_speed+1, zero
000fc0 9220 2833                 	sts pulse1_fx_Qxy_total_offset, zero
000fc2 9220 2834                 	sts pulse1_fx_Qxy_total_offset+1, zero
000fc4 9220 2835                 	sts pulse1_fx_Rxy_target, zero
000fc6 9220 2836                 	sts pulse1_fx_Rxy_target+1, zero
000fc8 9220 2837                 	sts pulse1_fx_Rxy_speed, zero
000fca 9220 2838                 	sts pulse1_fx_Rxy_speed+1, zero
000fcc 9220 2839                 	sts pulse1_fx_Rxy_total_offset, zero
000fce 9220 283a                 	sts pulse1_fx_Rxy_total_offset+1, zero
                                 
                                 	//TIMERS
                                 	//Frame Counter
                                 	//NOTE:The frame counter will be defaulted to NTSC mode (60 Hz, 120 Hz, 240 Hz)
                                 	//Each interrupt will be setup to interrupt every 240 Hz clock
                                 	//CMP0 = sequence 0, CMP1 = sequence 1, CMP2 = sequence 2, OVF = sequence 3/sound driver
                                 	//Sequence 3 will clock the sound driver every 60Hz, in which new audio data is read and written to the registers
                                 	//Timer period Calculation: (0.00416666666 * 20000000/64)-1 = 1301.08333125 = 0x0515
                                 	//The ATmega4809 is cofigured to run at 20000000 Hz
                                 	//0.00416666666 seconds is the period for 240 Hz
                                 	//The /64 comes from the prescaler divider used
000fd0 e7b0                      	ldi r27, TCA_SINGLE_CMP0EN_bm | TCA_SINGLE_CMP1EN_bm | TCA_SINGLE_CMP2EN_bm | TCA_SINGLE_WGMODE_NORMAL_gc //interrupt mode
000fd1 93b0 0a01                 	sts TCA0_SINGLE_CTRLB, r27
000fd3 e7b1                      	ldi r27, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP1_bm | TCA_SINGLE_CMP2_bm | TCA_SINGLE_OVF_bm //enable overflow and compare interrupts
000fd4 93b0 0a0a                 	sts TCA0_SINGLE_INTCTRL, r27
000fd6 e1b5                      	ldi r27, 0x15 //set the period for CMP0
000fd7 93b0 0a28                 	sts TCA0_SINGLE_CMP0, r27
000fd9 e0b5                      	ldi r27, 0x05
000fda 93b0 0a29                 	sts TCA0_SINGLE_CMP0 + 1, r27
000fdc e2bb                      	ldi r27, 0x2B //set the period for CMP1
000fdd 93b0 0a2a                 	sts TCA0_SINGLE_CMP1, r27
000fdf e0ba                      	ldi r27, 0x0A
000fe0 93b0 0a2b                 	sts TCA0_SINGLE_CMP1 + 1, r27
000fe2 e4b1                      	ldi r27, 0x41 //set the period for CMP2
000fe3 93b0 0a2c                 	sts TCA0_SINGLE_CMP2, r27
000fe5 e0bf                      	ldi r27, 0x0F
000fe6 93b0 0a2d                 	sts TCA0_SINGLE_CMP2 + 1, r27
000fe8 e5b7                      	ldi r27, 0x57 //set the period for OVF
000fe9 93b0 0a26                 	sts TCA0_SINGLE_PER, r27
000feb e1b4                      	ldi r27, 0x14
000fec 93b0 0a27                 	sts TCA0_SINGLE_PER + 1, r27
000fee e0bb                      	ldi r27, TCA_SINGLE_CLKSEL_DIV64_gc | TCA_SINGLE_ENABLE_bm //use prescale divider of 64 and enable timer
000fef 93b0 0a00                 	sts TCA0_SINGLE_CTRLA, r27
                                 
                                 	//NOTE: Channel Timers are clocked (20/2)/(0.8948865) = 11.1746014718 times faster than the NES APU
                                 	//Because of this, we multiply all the NES timer values by 11.1746014718 beforehand
                                 	//Since we rotate the sequence when the timer goes from t-(t-1) to 0, instead of 0 to t like the NES, we add 1 to the NES timers before multiplying
                                 	//The ATmega4809 is configured to run at 20 MHz
                                 	//The /2 comes from the prescaler divider used
                                 	//0.8948865 MHz is the speed of the NTSC NES APU
                                 	//NOTE: This means that any offset to the pitch for the NES timers would be multiplied by 11.1746014718 aswell.
                                 	//Pulse 1
000ff1 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
000ff2 93b0 0a81                 	sts TCB0_CTRLB, r27
000ff4 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
000ff5 93b0 0a85                 	sts TCB0_INTCTRL, r27
000ff7 91b0 2802                 	lds r27, pulse1_timerL //load the LOW bits for timer
000ff9 93b0 0a8c                 	sts TCB0_CCMPL, r27
000ffb 91b0 2803                 	lds r27, pulse1_timerH //load the HIGH bits for timer
000ffd 93b0 0a8d                 	sts TCB0_CCMPH, r27
000fff e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
001000 93b0 0a80                 	sts TCB0_CTRLA, r27
001002 9478                      	sei //global interrupt enable
                                 
                                 pulse1:
001003 fed0                      	sbrs pulse1_sequence, 0 //if the sequence output is zero, return
001004 c012                      	rjmp pulse1_off
                                 
001005 14e2                      	cp pulse1_length_counter, zero //if length is zero, return
001006 f081                      	breq pulse1_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
                                 pulse1_check_timer_08:
001007 91c0 0a8c                 	lds r28, TCB0_CCMPL
001009 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 pulse1_check_timer_08_HIGH:
00100b 30d1                      	cpi r29, 0x01 //check timer HIGH period
00100c f008                      	brlo pulse1_check_timer_08_LOW //if the timer HIGH period is $00, check the LOW period
00100d c002                      	rjmp pulse1_check_timer_7FF_HIGH //if the timer HIGH period is > $01, check > $07FF condition
                                 pulse1_check_timer_08_LOW:
00100e 35c9                      	cpi r28, 0x59 //check timer LOW period
00100f f038                      	brlo pulse1_off //if the HIGH period == $00 && LOW period <= $59, pulse off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $5965
                                 pulse1_check_timer_7FF_HIGH:
001010 35d9                      	cpi r29, 0x59 //check timer HIGH period
001011 f038                      	brlo pulse1_on //if the HIGH period is < $59, then all conditions have passed and pulse is not muted
001012 f009                      	breq pulse1_check_timer_7FF_LOW //if the HIGH period is == $59, we go check if the LOW period is < $65
001013 c003                      	rjmp pulse1_off //pulse off if HIGH period is > $59
                                 pulse1_check_timer_7FF_LOW:
001014 36c5                      	cpi r28, 0x65 //check timer LOW period
001015 f408                      	brsh pulse1_off //if the HIGH period == $59 && LOW period >= $65, pulse off
001016 c002                      	rjmp pulse1_on //if the HIGH period == $59 && LOW period < $65, pulse on
                                 
                                 pulse1_off:
001017 b821                      	out VPORTA_OUT, zero
001018 cfea                      	rjmp pulse1
                                 
                                 pulse1_on:
001019 91d0 2806                 	lds r29, pulse1_output_volume
                                 /*	cpse r29, zero
                                 	rjmp pulse1_off //if VVVV bits are 0, then there is no volume (channel off)*/
                                 
00101b b9d1                      	out VPORTA_OUT, r29
00101c cfe6                      	rjmp pulse1
                                 
                                 //FRAME COUNTER/AUDIO SAMPLE ISR
                                 sequence_0_2:
00101d b7bf                      	in r27, CPU_SREG
00101e 93bf                      	push r27
00101f 94f8                      	cli
                                 
                                 	//ENVELOPE
001020 d470                      	rcall pulse1_envelope_routine
                                 
001021 e5b0                      	ldi r27, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP2_bm //clear OVF flag
001022 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
001024 91bf                      	pop r27
001025 bfbf                      	out CPU_SREG, r27
001026 9518                      	reti
                                 
                                 sequence_1_3:
001027 b7bf                      	in r27, CPU_SREG
001028 93bf                      	push r27
001029 94f8                      	cli
                                 
                                 	//ENVELOPE
00102a d466                      	rcall pulse1_envelope_routine
                                 
                                 	//SWEEP
00102b fcf3                      	sbrc pulse1_sweep, 3 //check if the sweep enable bit is cleared
00102c d43a                      	rcall pulse1_sweep_routine
                                 
                                 	//LENGTH
                                 	//NOTE: The length routine is relatively simple, so we will not be using clocks to rjmp and ret to a seperate lable
00102d fd95                      	sbrc channel_flags, 5 //check if the length counter halt bit is cleared
00102e c002                      	rjmp sequence_1_3_exit
00102f 10e2                      	cpse pulse1_length_counter, zero //if length counter is already 0, don't decrement
001030 94ea                      	dec pulse1_length_counter
                                 
                                 sequence_1_3_exit:
001031 e2b1                      	ldi r27, TCA_SINGLE_CMP1_bm | TCA_SINGLE_OVF_bm //clear OVF flag
001032 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
001034 91bf                      	pop r27
001035 bfbf                      	out CPU_SREG, r27
001036 9518                      	reti
                                 
                                 sound_driver:
001037 b7bf                      	in r27, CPU_SREG
001038 93bf                      	push r27
001039 94f8                      	cli
00103a 93cf                      	push r28
00103b 93df                      	push r29
                                 
                                 	//SOUND DRIVER
00103c 91b0 280e                 	lds r27, pulse1_pattern_delay
00103e 11b2                      	cpse r27, zero //if the pattern delay is 0, proceed with sound driver procedures
00103f c212                      	rjmp sound_driver_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 
                                 
                                 sound_driver_channel0:
001040 91e0 280c                 	lds ZL, pulse1_pattern //current pattern for pulse 1
001042 91f0 280d                 	lds ZH, pulse1_pattern+1
001044 91a0 280f                 	lds r26, pulse1_pattern_offset //current offset in the pattern for pulse 1
001046 91b0 2810                 	lds r27, pulse1_pattern_offset+1
001048 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001049 1ffb                      	adc ZH, r27
00104a 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel0_check_if_note: //check if data is a note (0x00 - 0x56)
00104b 35b7                      	cpi r27, 0x57
00104c f408                      	brsh sound_driver_channel0_check_if_volume
00104d c0d2                      	rjmp sound_driver_channel0_note
                                 sound_driver_channel0_check_if_volume: //check if data is volume (0x57-0x66)
00104e 36b7                      	cpi r27, 0x67
00104f f408                      	brsh sound_driver_channel0_check_if_delay
001050 c0f3                      	rjmp sound_driver_channel0_volume
                                 sound_driver_channel0_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001051 3eb3                      	cpi r27, 0xE3
001052 f408                      	brsh sound_driver_channel0_check_if_instrument
001053 c0fa                      	rjmp sound_driver_channel0_delay
                                 sound_driver_channel0_check_if_instrument: //check for instrument flag (0xE3)
001054 f409                      	brne sound_driver_channel0_check_if_release
001055 c0fd                      	rjmp sound_driver_channel0_instrument_change 
                                 sound_driver_channel0_check_if_release: //check for note release flag (0xE4)
001056 3eb4                      	cpi r27, 0xE4
001057 f409                      	brne sound_driver_channel0_check_if_end
001058 c1a4                      	rjmp sound_driver_channel0_release
                                 sound_driver_channel0_check_if_end:
001059 3fbf                      	cpi r27, 0xFF
00105a f409                      	brne sound_driver_channel0_check_if_fx
00105b c1c6                      	rjmp sound_driver_channel0_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel0_check_if_fx: //fx flags (0xE5 - 0xFE)
00105c 9631                      	adiw Z, 1 //point Z to the byte next to the flag
00105d 91a4                      	lpm r26, Z //load the fx data into r26
00105e d1e9                      	rcall sound_driver_channel0_increment_offset_twice
                                 
00105f 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001060 e8ee                      	ldi ZL, LOW(fx << 1) //load in note table
001061 e2f9                      	ldi ZH, HIGH(fx << 1)
001062 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001063 0feb                      	add ZL, r27 //add offset
001064 1df2                      	adc ZH, zero
001065 91c5                      	lpm r28, Z+ //load address bytes
001066 91d4                      	lpm r29, Z
001067 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001068 2ffd                      	mov ZH, r29
001069 9409                      	ijmp
                                 
                                 
                                 
                                 sound_driver_channel0_fx_0xy: //arpeggio
00106a cfd5                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_1xx: //pitch slide up
00106b cfd4                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_2xx: //pitch slide down
00106c cfd3                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_3xx: //automatic portamento
00106d cfd2                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_4xy: //vibrato
00106e cfd1                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_7xy: //tremelo effect
00106f cfd0                      	rjmp sound_driver_channel0
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel0_fx_Axy:
001070 93a0 282e                 	sts pulse1_fx_Axy, r26
001072 cfcd                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_channel0_fx_Bxx: //pattern jump
001073 cfcc                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Cxx: //halt
001074 cfcb                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Dxx: //frame skip
001075 cfca                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Exx: //volume
001076 cfc9                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Fxx: //speed and tempo
001077 cfc8                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Gxx: //note delay
001078 cfc7                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Hxy: //hardware sweep up
001079 cfc6                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_lxy: //hardware sweep down
00107a cfc5                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Hxx: //FDS modulation depth
00107b cfc4                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Ixx: //FDS modulation speed
00107c cfc3                      	rjmp sound_driver_channel0
                                 
                                 //FINE PITCH
                                 sound_driver_channel0_fx_Pxx:
00107d 93a0 282d                 	sts pulse1_fx_Pxx, r26
00107f cfc0                      	rjmp sound_driver_channel0
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel0_fx_Qxy:
                                 sound_driver_channel0_fx_Qxy_check_arpeggio_macro:
001080 91e0 2816                 	lds ZL, pulse1_arpeggio_macro
001082 91f0 2817                 	lds ZH, pulse1_arpeggio_macro+1
001084 9630                      	adiw Z, 0
001085 f009                      	breq sound_driver_channel0_fx_Qxy_check_pitch_macro
001086 cfb9                      	rjmp sound_driver_channel0 //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_pitch_macro:
001087 91e0 281d                 	lds ZL, pulse1_pitch_macro
001089 91f0 281e                 	lds ZH, pulse1_pitch_macro+1
00108b 9630                      	adiw Z, 0
00108c f009                      	breq sound_driver_channel0_fx_Qxy_check_hi_pitch_macro
00108d cfb2                      	rjmp sound_driver_channel0 //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_hi_pitch_macro:
00108e 91e0 2823                 	lds ZL, pulse1_hi_pitch_macro
001090 91f0 2824                 	lds ZH, pulse1_hi_pitch_macro+1
001092 9630                      	adiw Z, 0
001093 f009                      	breq sound_driver_channel0_fx_Qxy_process
001094 cfab                      	rjmp sound_driver_channel0 //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_process:
001095 2fba                      	mov r27, r26 //copy fx parameters into r27
001096 70bf                      	andi r27, 0x0F //mask note index offset
001097 91c0 2807                 	lds r28, pulse1_note //load current note index
001099 0fbc                      	add r27, r28
00109a 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
00109b f008                      	brlo sound_driver_channel0_fx_Qxy_process_continue
00109c e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel0_fx_Qxy_process_continue:
00109d e3e4                      	ldi ZL, LOW(note_table << 1) //load in note table
00109e e0f0                      	ldi ZH, HIGH(note_table << 1)
00109f 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
0010a0 0feb                      	add ZL, r27 //add offset
0010a1 1df2                      	adc ZH, zero
0010a2 91c5                      	lpm r28, Z+ //load bytes
0010a3 91d4                      	lpm r29, Z
0010a4 93c0 282f                 	sts pulse1_fx_Qxy_target, r28 //load the LOW bits for the target period
0010a6 93d0 2830                 	sts pulse1_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
0010a8 95a2                      	swap r26
0010a9 70af                      	andi r26, 0x0F //mask effect speed
0010aa 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0010ab 95a3                      	inc r26 //increment the speed by 1
                                 
0010ac 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0010ad 937f                      	push r23
0010ae 2f6a                      	mov r22, r26 //store the speed data into r27
0010af eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0010b0 9f67                      	mul r22, r23
0010b1 917f                      	pop r23
0010b2 916f                      	pop r22
                                 
0010b3 9416                      	lsr r1 //shift out the fractional bits
0010b4 9407                      	ror r0
0010b5 9416                      	lsr r1
0010b6 9407                      	ror r0
0010b7 9416                      	lsr r1
0010b8 9407                      	ror r0
0010b9 9416                      	lsr r1
0010ba 9407                      	ror r0
                                 
0010bb 9200 2831                 	sts pulse1_fx_Qxy_speed, r0 //store the effect speed
0010bd 9210 2832                 	sts pulse1_fx_Qxy_speed+1, r1
0010bf 9220 2833                 	sts pulse1_fx_Qxy_total_offset, zero
0010c1 9220 2834                 	sts pulse1_fx_Qxy_total_offset+1, zero
0010c3 cf7c                      	rjmp sound_driver_channel0
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel0_fx_Rxy:
                                 sound_driver_channel0_fx_Rxy_check_arpeggio_macro:
0010c4 91e0 2816                 	lds ZL, pulse1_arpeggio_macro
0010c6 91f0 2817                 	lds ZH, pulse1_arpeggio_macro+1
0010c8 9630                      	adiw Z, 0
0010c9 f009                      	breq sound_driver_channel0_fx_Rxy_check_pitch_macro
0010ca cf75                      	rjmp sound_driver_channel0 //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_pitch_macro:
0010cb 91e0 281d                 	lds ZL, pulse1_pitch_macro
0010cd 91f0 281e                 	lds ZH, pulse1_pitch_macro+1
0010cf 9630                      	adiw Z, 0
0010d0 f009                      	breq sound_driver_channel0_fx_Rxy_check_hi_pitch_macro
0010d1 cf6e                      	rjmp sound_driver_channel0 //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_hi_pitch_macro:
0010d2 91e0 2823                 	lds ZL, pulse1_hi_pitch_macro
0010d4 91f0 2824                 	lds ZH, pulse1_hi_pitch_macro+1
0010d6 9630                      	adiw Z, 0
0010d7 f009                      	breq sound_driver_channel0_fx_Rxy_process
0010d8 cf67                      	rjmp sound_driver_channel0 //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_process:
0010d9 2fba                      	mov r27, r26 //copy fx parameters into r27
0010da 70bf                      	andi r27, 0x0F //mask note index offset
0010db 91c0 2807                 	lds r28, pulse1_note //load current note index
0010dd 1bcb                      	sub r28, r27
0010de f408                      	brcc sound_driver_channel0_fx_Rxy_process_continue
0010df e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel0_fx_Rxy_process_continue:
0010e0 e3e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0010e1 e0f0                      	ldi ZH, HIGH(note_table << 1)
0010e2 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
0010e3 0fec                      	add ZL, r28 //add offset
0010e4 1df2                      	adc ZH, zero
0010e5 91c5                      	lpm r28, Z+ //load bytes
0010e6 91d4                      	lpm r29, Z
0010e7 93c0 2835                 	sts pulse1_fx_Rxy_target, r28 //load the LOW bits for the target period
0010e9 93d0 2836                 	sts pulse1_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
0010eb 95a2                      	swap r26
0010ec 70af                      	andi r26, 0x0F //mask effect speed
0010ed 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0010ee 95a3                      	inc r26 //increment the speed by 1
                                 
0010ef 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0010f0 937f                      	push r23
0010f1 2f6a                      	mov r22, r26 //store the speed data into r27
0010f2 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0010f3 9f67                      	mul r22, r23
0010f4 917f                      	pop r23
0010f5 916f                      	pop r22
                                 
0010f6 9416                      	lsr r1 //shift out the fractional bits
0010f7 9407                      	ror r0
0010f8 9416                      	lsr r1
0010f9 9407                      	ror r0
0010fa 9416                      	lsr r1
0010fb 9407                      	ror r0
0010fc 9416                      	lsr r1
0010fd 9407                      	ror r0
                                 
0010fe 9200 2837                 	sts pulse1_fx_Rxy_speed, r0 //store the effect speed
001100 9210 2838                 	sts pulse1_fx_Rxy_speed+1, r1
001102 9220 2839                 	sts pulse1_fx_Rxy_total_offset, zero
001104 9220 283a                 	sts pulse1_fx_Rxy_total_offset+1, zero
001106 cf39                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_channel0_fx_Sxx: //mute delay
001107 cf38                      	rjmp sound_driver_channel0
                                 
                                 //DUTY
                                 sound_driver_channel0_fx_Vxx:
001108 e2f9                      	ldi ZH, HIGH(sequences << 1) //point Z to sequence table
001109 e8ea                      	ldi ZL, LOW(sequences << 1)
00110a 0fea                      	add ZL, r26 //offset the pointer
00110b 1df2                      	adc ZH, zero
                                 
00110c 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
00110d 95a7                      	ror r26
00110e 95a7                      	ror r26
00110f 91b0 2800                 	lds r27, pulse1_param //load r27 with pulse1_param (register $4000)
001111 2fcb                      	mov r28, r27 //store a copy of pulse1_param into r28
001112 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
001113 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
001114 c001                      	rjmp sound_driver_channel0_fx_Vxx_store
001115 cf2a                      	rjmp sound_driver_channel0 //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel0_fx_Vxx_store:
001116 90d4                      	lpm pulse1_sequence, Z //store the sequence
                                 
001117 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
001118 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
001119 93c0 2800                 	sts pulse1_param, r28
00111b cf24                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_channel0_fx_Wxx: //DPCM sample speed
00111c cf23                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Xxx: //DPCM sample retrigger
00111d cf22                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Yxx: //DPCM sample offset
00111e cf21                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Zxx: //DPCM sample delta counter
00111f cf20                      	rjmp sound_driver_channel0
                                 
                                 
                                 sound_driver_channel0_note:
001120 93b0 2807                 	sts pulse1_note, r27 //store the note index
001122 e0a3                      	ldi r26, 0x03
001123 e0b2                      	ldi r27, 0x02
001124 93b0 2813                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
001126 93a0 2818                 	sts pulse1_arpeggio_macro_offset, r26
001128 93b0 281f                 	sts pulse1_pitch_macro_offset, r27
00112a 93b0 2825                 	sts pulse1_hi_pitch_macro_offset, r27
00112c 93b0 282a                 	sts pulse1_duty_macro_offset, r27
00112e 9220 281c                 	sts pulse1_total_pitch_offset, zero //reset the pitch and hi pitch offset
001130 9220 2822                 	sts pulse1_total_hi_pitch_offset, zero
001132 9220 282f                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001134 9220 2830                 	sts pulse1_fx_Qxy_target+1, zero
001136 9220 2833                 	sts pulse1_fx_Qxy_total_offset, zero
001138 9220 2834                 	sts pulse1_fx_Qxy_total_offset+1, zero
00113a 9220 2835                 	sts pulse1_fx_Rxy_target, zero
00113c 9220 2836                 	sts pulse1_fx_Rxy_target+1, zero
00113e 9220 2839                 	sts pulse1_fx_Rxy_total_offset, zero
001140 9220 283a                 	sts pulse1_fx_Rxy_total_offset+1, zero
001142 d0fb                      	rcall sound_driver_channel0_increment_offset
001143 cefc                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0_volume:
001144 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001145 91a0 2800                 	lds r26, pulse1_param
001147 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001148 2bab                      	or r26, r27 //move new VVVV bits into pulse1_param
001149 93a0 2800                 	sts pulse1_param, r26
00114b 6096                      	sbr channel_flags, 6
00114c d0f1                      	rcall sound_driver_channel0_increment_offset
00114d cef2                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0_delay:
00114e 56b7                      	subi r27, 0x67 //NOTE: the delay values are offset by the highest volume value, which is 0x66
00114f 93b0 280e                 	sts pulse1_pattern_delay, r27
001151 d0ec                      	rcall sound_driver_channel0_increment_offset
001152 c102                      	rjmp sound_driver_instrument_routine
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change:
001153 9220 2811                 	sts pulse1_volume_macro, zero //reset all macro addresses
001155 9220 2812                 	sts pulse1_volume_macro+1, zero
001157 9220 2816                 	sts pulse1_arpeggio_macro, zero
001159 9220 2817                 	sts pulse1_arpeggio_macro+1, zero
00115b 9220 281d                 	sts pulse1_pitch_macro, zero
00115d 9220 281e                 	sts pulse1_pitch_macro+1, zero
00115f 9220 2823                 	sts pulse1_hi_pitch_macro, zero
001161 9220 2824                 	sts pulse1_hi_pitch_macro+1, zero
001163 9220 2828                 	sts pulse1_duty_macro, zero
001165 9220 2829                 	sts pulse1_duty_macro+1, zero
001167 9220 281c                 	sts pulse1_total_pitch_offset, zero //reset the pitch offset
001169 9220 2822                 	sts pulse1_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
00116b 9631                      	adiw Z, 1 //point to the byte next to the flag
00116c 91b4                      	lpm r27, Z //store the instrument offset into r27
00116d e0e4                      	ldi ZL, LOW(instruments) //point Z to instruments table
00116e e0fd                      	ldi ZH, HIGH(instruments)
00116f 0feb                      	add ZL, r27 //point Z to offsetted instrument
001170 1df2                      	adc ZH, zero
001171 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001172 1fff                      	rol ZH
001173 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001174 91b4                      	lpm r27, Z
                                 
001175 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001176 1fbb                      	rol r27
001177 2fea                      	mov ZL, r26
001178 2ffb                      	mov ZH, r27
001179 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
00117a 9632                      	adiw Z, 2 //point Z to the address of the macro
00117b e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel0_instrument_change_macro_loop:
00117c 95aa                      	dec r26
00117d f019                      	breq sound_driver_channel0_instrument_change_exit
00117e 95b6                      	lsr r27
00117f f078                      	brcs sound_driver_channel0_instrument_change_load_macro
001180 cffb                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_exit:
001181 e0a3                      	ldi r26, 0x03
001182 e0b2                      	ldi r27, 0x02
001183 93b0 2813                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
001185 93a0 2818                 	sts pulse1_arpeggio_macro_offset, r26
001187 93b0 281f                 	sts pulse1_pitch_macro_offset, r27
001189 93b0 2825                 	sts pulse1_hi_pitch_macro_offset, r27
00118b 93b0 282a                 	sts pulse1_duty_macro_offset, r27
00118d d0ba                      	rcall sound_driver_channel0_increment_offset_twice
00118e ceb1                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_load_macro:
00118f 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001190 91d5                      	lpm r29, Z+
                                 
001191 30a5                      	cpi r26, 5
001192 f039                      	breq sound_driver_channel0_instrument_change_load_macro_volume
001193 30a4                      	cpi r26, 4
001194 f079                      	breq sound_driver_channel0_instrument_change_load_macro_arpeggio
001195 30a3                      	cpi r26, 3
001196 f0d9                      	breq sound_driver_channel0_instrument_change_load_macro_pitch
001197 30a2                      	cpi r26, 2
001198 f159                      	breq sound_driver_channel0_instrument_change_load_macro_hi_pitch
001199 c03c                      	rjmp sound_driver_channel0_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel0_instrument_change_load_macro_volume:
00119a 93c0 2811                 	sts pulse1_volume_macro, r28
00119c 93d0 2812                 	sts pulse1_volume_macro+1, r29
00119e d041                      	rcall sound_driver_channel0_instrument_change_read_header
00119f 93c0 2815                 	sts pulse1_volume_macro_release, r28
0011a1 93d0 2814                 	sts pulse1_volume_macro_loop, r29
0011a3 cfd8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 	
                                 sound_driver_channel0_instrument_change_load_macro_arpeggio:
0011a4 93c0 2816                 	sts pulse1_arpeggio_macro, r28
0011a6 93d0 2817                 	sts pulse1_arpeggio_macro+1, r29
0011a8 9220 282f                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0011aa 9220 2830                 	sts pulse1_fx_Qxy_target+1, zero
0011ac 9220 2835                 	sts pulse1_fx_Rxy_target, zero
0011ae 9220 2836                 	sts pulse1_fx_Rxy_target+1, zero
0011b0 d03a                      	rcall sound_driver_channel0_instrument_change_read_header_arpeggio
0011b1 cfca                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_pitch:
0011b2 93c0 281d                 	sts pulse1_pitch_macro, r28
0011b4 93d0 281e                 	sts pulse1_pitch_macro+1, r29
0011b6 9220 282f                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0011b8 9220 2830                 	sts pulse1_fx_Qxy_target+1, zero
0011ba 9220 2835                 	sts pulse1_fx_Rxy_target, zero
0011bc 9220 2836                 	sts pulse1_fx_Rxy_target+1, zero
0011be d021                      	rcall sound_driver_channel0_instrument_change_read_header
0011bf 93c0 2821                 	sts pulse1_pitch_macro_release, r28
0011c1 93d0 2820                 	sts pulse1_pitch_macro_loop, r29
0011c3 cfb8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_hi_pitch:
0011c4 93c0 2823                 	sts pulse1_hi_pitch_macro, r28
0011c6 93d0 2824                 	sts pulse1_hi_pitch_macro+1, r29
0011c8 9220 282f                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0011ca 9220 2830                 	sts pulse1_fx_Qxy_target+1, zero
0011cc 9220 2835                 	sts pulse1_fx_Rxy_target, zero
0011ce 9220 2836                 	sts pulse1_fx_Rxy_target+1, zero
0011d0 d00f                      	rcall sound_driver_channel0_instrument_change_read_header
0011d1 93c0 2827                 	sts pulse1_hi_pitch_macro_release, r28
0011d3 93d0 2826                 	sts pulse1_hi_pitch_macro_loop, r29
0011d5 cfa6                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_duty:
0011d6 93c0 2828                 	sts pulse1_duty_macro, r28
0011d8 93d0 2829                 	sts pulse1_duty_macro+1, r29
0011da d005                      	rcall sound_driver_channel0_instrument_change_read_header
0011db 93c0 282c                 	sts pulse1_duty_macro_release, r28
0011dd 93d0 282b                 	sts pulse1_duty_macro_loop, r29
0011df cf9c                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_read_header:
0011e0 93ef                      	push ZL
0011e1 93ff                      	push ZH
0011e2 2fec                      	mov ZL, r28
0011e3 2ffd                      	mov ZH, r29
0011e4 0fee                      	lsl ZL
0011e5 1fff                      	rol ZH
0011e6 91c5                      	lpm r28, Z+
0011e7 91d4                      	lpm r29, Z
0011e8 91ff                      	pop ZH
0011e9 91ef                      	pop ZL
0011ea 9508                      	ret
                                 
                                 sound_driver_channel0_instrument_change_read_header_arpeggio:
0011eb 93ef                      	push ZL
0011ec 93ff                      	push ZH
0011ed 2fec                      	mov ZL, r28
0011ee 2ffd                      	mov ZH, r29
0011ef 0fee                      	lsl ZL
0011f0 1fff                      	rol ZH
0011f1 91c5                      	lpm r28, Z+
0011f2 91d5                      	lpm r29, Z+
0011f3 93c0 281a                 	sts pulse1_arpeggio_macro_release, r28
0011f5 93d0 2819                 	sts pulse1_arpeggio_macro_loop, r29
0011f7 91c4                      	lpm r28, Z
0011f8 93c0 281b                 	sts pulse1_arpeggio_macro_mode, r28
0011fa 91ff                      	pop ZH
0011fb 91ef                      	pop ZL
0011fc 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel0_release:
                                 sound_driver_channel0_release_volume:
0011fd 91b0 2815                 	lds r27, pulse1_volume_macro_release
0011ff 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001200 f019                      	breq sound_driver_channel0_release_arpeggio //if the macro has no release flag, check the next macro
001201 95b3                      	inc r27
001202 93b0 2813                 	sts pulse1_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel0_release_arpeggio:
001204 91b0 281a                 	lds r27, pulse1_arpeggio_macro_release
001206 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001207 f019                      	breq sound_driver_channel0_release_pitch
001208 95b3                      	inc r27
001209 93b0 2818                 	sts pulse1_arpeggio_macro_offset, r27
                                 sound_driver_channel0_release_pitch:
00120b 91b0 2821                 	lds r27, pulse1_pitch_macro_release
00120d 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
00120e f019                      	breq sound_driver_channel0_release_hi_pitch
00120f 95b3                      	inc r27
001210 93b0 281f                 	sts pulse1_pitch_macro_offset, r27
                                 sound_driver_channel0_release_hi_pitch:
001212 91b0 2827                 	lds r27, pulse1_hi_pitch_macro_release
001214 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001215 f019                      	breq sound_driver_channel0_release_duty
001216 95b3                      	inc r27
001217 93b0 2825                 	sts pulse1_hi_pitch_macro_offset, r27
                                 sound_driver_channel0_release_duty:
001219 91b0 282c                 	lds r27, pulse1_duty_macro_release
00121b 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
00121c f019                      	breq sound_driver_channel0_release_exit
00121d 95b3                      	inc r27
00121e 93b0 282a                 	sts pulse1_duty_macro_offset, r27
                                 sound_driver_channel0_release_exit:
001220 d01d                      	rcall sound_driver_channel0_increment_offset
001221 ce1e                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0_next_pattern:
001222 91e0 2808                 	lds ZL, song_frames
001224 91f0 2809                 	lds ZH, song_frames+1
001226 91a0 280a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001228 91b0 280b                 	lds r27, song_frame_offset+1
00122a 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
00122b 93a0 280a                 	sts song_frame_offset, r26
00122d 93b0 280b                 	sts song_frame_offset+1, r27
                                 	//adiw r27:r26, 2 //offset for channel 1 (test)
00122f 0fea                      	add ZL, r26
001230 1ffb                      	adc ZH, r27
                                 
001231 91a5                      	lpm r26, Z+ //load the address of the next pattern
001232 91b4                      	lpm r27, Z
001233 0faa                      	lsl r26
001234 1fbb                      	rol r27
001235 93a0 280c                 	sts pulse1_pattern, r26
001237 93b0 280d                 	sts pulse1_pattern+1, r27
                                 
001239 9220 280f                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
00123b 9220 2810                 	sts pulse1_pattern_offset+1, zero
00123d ce02                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0_increment_offset:
00123e 91e0 280f                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
001240 91f0 2810                 	lds ZH, pulse1_pattern_offset+1
001242 9631                      	adiw Z, 1
001243 93e0 280f                 	sts pulse1_pattern_offset, ZL
001245 93f0 2810                 	sts pulse1_pattern_offset+1, ZH
001247 9508                      	ret
                                 
                                 sound_driver_channel0_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001248 91e0 280f                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
00124a 91f0 2810                 	lds ZH, pulse1_pattern_offset+1
00124c 9632                      	adiw Z, 2 //increment the pointer twice
00124d 93e0 280f                 	sts pulse1_pattern_offset, ZL
00124f 93f0 2810                 	sts pulse1_pattern_offset+1, ZH
001251 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_decrement_frame_delay:
001252 95ba                      	dec r27
001253 93b0 280e                 	sts pulse1_pattern_delay, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine:
                                 sound_driver_instrument_routine_channel0_volume:
001255 91e0 2811                 	lds ZL, pulse1_volume_macro
001257 91f0 2812                 	lds ZH, pulse1_volume_macro+1
001259 9630                      	adiw Z, 0
00125a f181                      	breq sound_driver_instrument_routine_channel0_volume_default //if no volume macro is in use, use default multiplier of F
00125b 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
00125c 1fff                      	rol ZH
00125d 91a0 2813                 	lds r26, pulse1_volume_macro_offset
00125f 0fea                      	add ZL, r26
001260 1df2                      	adc ZH, zero
                                 
001261 91b0 2815                 	lds r27, pulse1_volume_macro_release
001263 17ba                      	cp r27, r26
001264 f429                      	brne sound_driver_instrument_routine_channel0_volume_increment //if the current offset is not equal to the release index, increment the offset
001265 91a0 2814                 	lds r26, pulse1_volume_macro_loop
001267 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
001268 f010                      	brlo sound_driver_instrument_routine_channel0_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
001269 c003                      	rjmp sound_driver_instrument_routine_channel0_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_volume_increment:
00126a 95a3                      	inc r26 //increment the macro offset
00126b 93a0 2813                 	sts pulse1_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_volume_read:
00126d 91b4                      	lpm r27, Z //load volume data into r27
00126e 3fbf                      	cpi r27, 0xFF //check for macro end flag
00126f f469                      	brne sound_driver_instrument_routine_channel0_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_release:
001270 91b0 2815                 	lds r27, pulse1_volume_macro_release
001272 3fbf                      	cpi r27, 0xFF
001273 f429                      	brne sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_loop:
001274 91b0 2814                 	lds r27, pulse1_volume_macro_loop //load the loop index
001276 93b0 2813                 	sts pulse1_volume_macro_offset, r27 //store the loop index into the offset
001278 cfdc                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index:
001279 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
00127a 93a0 2813                 	sts pulse1_volume_macro_offset, r26
00127c cfd8                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_calculate:
00127d ece2                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
00127e e2f9                      	ldi ZH, HIGH(volumes << 1)
00127f 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
001280 0feb                      	add ZL, r27 //add offset to the table
001281 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel0_volume_load:
001282 91b0 2800                 	lds r27, pulse1_param //load main volume
001284 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
001285 0feb                      	add ZL, r27 //offset the volume table by the main volume
001286 1df2                      	adc ZH, zero
001287 91b4                      	lpm r27, Z
001288 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
00128a c005                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default:
00128b 91b0 2800                 	lds r27, pulse1_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
00128d 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
00128e 93b0 2806                 	sts pulse1_output_volume, r27
                                 	
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
001290 91e0 2816                 	lds ZL, pulse1_arpeggio_macro
001292 91f0 2817                 	lds ZH, pulse1_arpeggio_macro+1
001294 9630                      	adiw Z, 0
001295 f1f9                      	breq sound_driver_instrument_routine_channel0_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
001296 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
001297 1fff                      	rol ZH
001298 91a0 2818                 	lds r26, pulse1_arpeggio_macro_offset
00129a 0fea                      	add ZL, r26
00129b 1df2                      	adc ZH, zero
                                 
00129c 91b0 281a                 	lds r27, pulse1_arpeggio_macro_release
00129e 17ba                      	cp r27, r26
00129f f429                      	brne sound_driver_instrument_routine_channel0_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
0012a0 91a0 2819                 	lds r26, pulse1_arpeggio_macro_loop
0012a2 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0012a3 f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
0012a4 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_increment:
0012a5 95a3                      	inc r26 //increment the macro offset
0012a6 93a0 2818                 	sts pulse1_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_read:
0012a8 91b4                      	lpm r27, Z //load arpeggio data into r27
0012a9 38b0                      	cpi r27, 0x80 //check for macro end flag
0012aa f4f9                      	brne sound_driver_instrument_routine_channel0_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_check_mode:
0012ab 50a1                      	subi r26, 1 //keep the offset at the end flag
0012ac 93a0 2818                 	sts pulse1_arpeggio_macro_offset, r26
0012ae 91b0 281b                 	lds r27, pulse1_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
0012b0 30b1                      	cpi r27, 0x01
0012b1 f048                      	brlo sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_release:
0012b2 91b0 281a                 	lds r27, pulse1_arpeggio_macro_release
0012b4 3fbf                      	cpi r27, 0xFF
0012b5 f4f9                      	brne sound_driver_instrument_routine_channel0_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_loop:
0012b6 91b0 2819                 	lds r27, pulse1_arpeggio_macro_loop
0012b8 3fbf                      	cpi r27, 0xFF
0012b9 f469                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
0012ba c01a                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute:
0012bb 91b0 281a                 	lds r27, pulse1_arpeggio_macro_release
0012bd 3fbf                      	cpi r27, 0xFF
0012be f421                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_check_loop:
0012bf 91b0 2819                 	lds r27, pulse1_arpeggio_macro_loop //load the loop index
0012c1 3fbf                      	cpi r27, 0xFF //check if loop flag exists
0012c2 f421                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop:
0012c3 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
0012c4 93a0 2818                 	sts pulse1_arpeggio_macro_offset, r26 //store the last valid index into the offset
0012c6 cfc9                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload:
0012c7 93b0 2818                 	sts pulse1_arpeggio_macro_offset, r27 //store the loop index into the offset
0012c9 cfc6                      	rjmp sound_driver_instrument_routine_channel0_arpeggio //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process:
0012ca 9220 281c                 	sts pulse1_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
0012cc 9220 2822                 	sts pulse1_total_hi_pitch_offset, zero
0012ce 91a0 281b                 	lds r26, pulse1_arpeggio_macro_mode
0012d0 30a0                      	cpi r26, 0x00 //absolute mode
0012d1 f031                      	breq sound_driver_instrument_routine_channel0_arpeggio_process_absolute
0012d2 30a1                      	cpi r26, 0x01 //fixed mode
0012d3 f081                      	breq sound_driver_instrument_routine_channel0_arpeggio_process_fixed
0012d4 c011                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_default:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
0012d5 91a0 2807                 	lds r26, pulse1_note //load the current note index
0012d7 c01f                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute:
0012d8 91a0 2807                 	lds r26, pulse1_note //load the current note index
0012da 0fab                      	add r26, r27 //offset the note with the arpeggio data
0012db fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0012dc c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_add:
0012dd 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0012de f0c0                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
0012df e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0012e0 c016                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract:
0012e1 fda7                      	sbrc r26, 7 //check if result is negative
0012e2 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0012e3 c013                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_fixed:
0012e4 2fab                      	mov r26, r27 //move the arpeggio data into r26
0012e5 c011                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative:
0012e6 91a0 2807                 	lds r26, pulse1_note //load the current note index
0012e8 0fab                      	add r26, r27 //offset the note with the arpeggio data
0012e9 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0012ea c008                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_add:
0012eb 93a0 2807                 	sts pulse1_note, r26 //NOTE: relative mode modifies the original note index
0012ed 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0012ee f040                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
0012ef e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0012f0 93a0 2807                 	sts pulse1_note, r26
0012f2 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract:
0012f3 fda7                      	sbrc r26, 7 //check if result is negative
0012f4 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0012f5 93a0 2807                 	sts pulse1_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_load:
0012f7 e3e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0012f8 e0f0                      	ldi ZH, HIGH(note_table << 1)
0012f9 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
0012fa 0fea                      	add ZL, r26 //add offset
0012fb 1df2                      	adc ZH, zero
0012fc 91a5                      	lpm r26, Z+ //load bytes
0012fd 91b4                      	lpm r27, Z
0012fe 93a0 0a8c                 	sts TCB0_CCMPL, r26 //load the LOW bits for timer
001300 93b0 0a8d                 	sts TCB0_CCMPH, r27 //load the HIGH bits for timer
001302 c000                      	rjmp sound_driver_instrument_routine_channel0_pitch
                                 
                                 
                                 
                                 //NOTE: There is a limitation with the pitch routines in that the total pitch can not be offset by 127 in both,
                                 //the positive and negative direction, from the original note pitch. This shouldn't be too much of a problem as
                                 //most songs that use instruments with the pitch macro, do not stray that far from the original note pitch.
                                 //In the case of hi pitch, the total pitch can not be offset by 127*16 from the original pitch. This is also
                                 //not a big deal as you can easily reach the entire note range with an offset of up to 127*16.
                                 sound_driver_instrument_routine_channel0_pitch:
001303 91e0 281d                 	lds ZL, pulse1_pitch_macro
001305 91f0 281e                 	lds ZH, pulse1_pitch_macro+1
001307 9630                      	adiw Z, 0
001308 f409                      	brne sound_driver_instrument_routine_channel0_pitch_continue
001309 c023                      	rjmp sound_driver_instrument_routine_channel0_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel0_pitch_continue:
00130a 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00130b 1fff                      	rol ZH
00130c 91a0 281f                 	lds r26, pulse1_pitch_macro_offset
00130e 0fea                      	add ZL, r26
00130f 1df2                      	adc ZH, zero
                                 
001310 91b0 2821                 	lds r27, pulse1_pitch_macro_release
001312 17ba                      	cp r27, r26
001313 f429                      	brne sound_driver_instrument_routine_channel0_pitch_increment //if the current offset is not equal to the release index, increment the offset
001314 91a0 2820                 	lds r26, pulse1_pitch_macro_loop
001316 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
001317 f010                      	brlo sound_driver_instrument_routine_channel0_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
001318 c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_pitch_increment:
001319 95a3                      	inc r26 //increment the macro offset
00131a 93a0 281f                 	sts pulse1_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_pitch_read:
00131c 91b4                      	lpm r27, Z //load pitch data into r27
00131d 38b0                      	cpi r27, 0x80 //check for macro end flag
00131e f489                      	brne sound_driver_instrument_routine_channel0_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_release:
00131f 50a1                      	subi r26, 1 //keep the macro offset at the end flag
001320 93a0 281f                 	sts pulse1_pitch_macro_offset, r26
001322 91b0 2821                 	lds r27, pulse1_pitch_macro_release
001324 3fbf                      	cpi r27, 0xFF
001325 f439                      	brne sound_driver_instrument_routine_channel0_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_loop:
001326 91b0 2820                 	lds r27, pulse1_pitch_macro_loop //load the loop index
001328 3fbf                      	cpi r27, 0xFF //check if there is a loop index
001329 f019                      	breq sound_driver_instrument_routine_channel0_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
00132a 93b0 281f                 	sts pulse1_pitch_macro_offset, r27 //store the loop index into the offset
00132c cfd6                      	rjmp sound_driver_instrument_routine_channel0_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_default:
00132d 91b0 281c                 	lds r27, pulse1_total_pitch_offset
00132f c005                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate:
001330 91a0 281c                 	lds r26, pulse1_total_pitch_offset //load the total pitch offset to change
001332 0fba                      	add r27, r26
001333 93b0 281c                 	sts pulse1_total_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_multiply:
                                 	//NOTE: The Pxx effect is processed with the pitch instrument macro because the calculations are the same
001335 91a0 282d                 	lds r26, pulse1_fx_Pxx
001337 0fba                      	add r27, r26
                                 
001338 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001339 937f                      	push r23
00133a 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
00133b eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00133c 0367                      	mulsu r22, r23
00133d 917f                      	pop r23
00133e 916f                      	pop r22
                                 
00133f 9416                      	lsr r1 //shift out the fractional bits
001340 9407                      	ror r0
001341 9416                      	lsr r1
001342 9407                      	ror r0
001343 9416                      	lsr r1
001344 9407                      	ror r0
001345 9416                      	lsr r1
001346 9407                      	ror r0
001347 fe13                      	sbrs r1, 3 //check if result was a negative number
001348 c002                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_negative:
001349 efb0                      	ldi r27, 0xF0
00134a 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_offset:
00134b 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
00134d 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
00134f 0da0                      	add r26, r0 //offset the timer values
001350 1db1                      	adc r27, r1
                                 
001351 91c0 2833                 	lds r28, pulse1_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
001353 91d0 2834                 	lds r29, pulse1_fx_Qxy_total_offset+1
001355 1bac                      	sub r26, r28
001356 0bbd                      	sbc r27, r29
001357 91c0 2839                 	lds r28, pulse1_fx_Rxy_total_offset
001359 91d0 283a                 	lds r29, pulse1_fx_Rxy_total_offset+1
00135b 0fac                      	add r26, r28
00135c 1fbd                      	adc r27, r29
                                 
00135d 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
00135f 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel0_hi_pitch:
001361 91e0 2823                 	lds ZL, pulse1_hi_pitch_macro
001363 91f0 2824                 	lds ZH, pulse1_hi_pitch_macro+1
001365 9630                      	adiw Z, 0
001366 f409                      	brne sound_driver_instrument_routine_channel0_hi_pitch_continue
001367 c03c                      	rjmp sound_driver_instrument_routine_channel0_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel0_hi_pitch_continue:
001368 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
001369 1fff                      	rol ZH
00136a 91a0 2825                 	lds r26, pulse1_hi_pitch_macro_offset
00136c 0fea                      	add ZL, r26
00136d 1df2                      	adc ZH, zero
                                 
00136e 91b0 2827                 	lds r27, pulse1_hi_pitch_macro_release
001370 17ba                      	cp r27, r26
001371 f429                      	brne sound_driver_instrument_routine_channel0_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
001372 91a0 2826                 	lds r26, pulse1_hi_pitch_macro_loop
001374 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
001375 f010                      	brlo sound_driver_instrument_routine_channel0_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
001376 c003                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_increment:
001377 95a3                      	inc r26 //increment the macro offset
001378 93a0 2825                 	sts pulse1_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_hi_pitch_read:
00137a 91b4                      	lpm r27, Z //load hi pitch data into r27
00137b 38b0                      	cpi r27, 0x80 //check for macro end flag
00137c f489                      	brne sound_driver_instrument_routine_channel0_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_release:
00137d 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00137e 93a0 2825                 	sts pulse1_hi_pitch_macro_offset, r26
001380 91b0 2827                 	lds r27, pulse1_hi_pitch_macro_release
001382 3fbf                      	cpi r27, 0xFF
001383 f439                      	brne sound_driver_instrument_routine_channel0_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_loop:
001384 91b0 2826                 	lds r27, pulse1_hi_pitch_macro_loop //load the loop index
001386 3fbf                      	cpi r27, 0xFF //check if there is a loop index
001387 f019                      	breq sound_driver_instrument_routine_channel0_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
001388 93b0 2825                 	sts pulse1_hi_pitch_macro_offset, r27 //store the loop index into the offset
00138a cfd6                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_default:
00138b 91b0 2822                 	lds r27, pulse1_total_hi_pitch_offset
00138d c005                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate:
00138e 91a0 2822                 	lds r26, pulse1_total_hi_pitch_offset //load the total hi pitch offset to change
001390 0fba                      	add r27, r26
001391 93b0 2822                 	sts pulse1_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply:
001393 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001394 937f                      	push r23
001395 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
001396 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001397 0367                      	mulsu r22, r23
001398 917f                      	pop r23
001399 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_offset:
00139a 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
00139c 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
00139e 0da0                      	add r26, r0 //offset the timer values
00139f 1db1                      	adc r27, r1
0013a0 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
0013a2 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel0_duty:
0013a4 91e0 2828                 	lds ZL, pulse1_duty_macro
0013a6 91f0 2829                 	lds ZH, pulse1_duty_macro+1
0013a8 9630                      	adiw Z, 0
0013a9 f1b1                      	breq sound_driver_channel0_fx_routines //if no duty macro is in use, go to the next routine
0013aa 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0013ab 1fff                      	rol ZH
0013ac 91a0 282a                 	lds r26, pulse1_duty_macro_offset
0013ae 0fea                      	add ZL, r26
0013af 1df2                      	adc ZH, zero
                                 
0013b0 91b0 282c                 	lds r27, pulse1_duty_macro_release
0013b2 17ba                      	cp r27, r26
0013b3 f429                      	brne sound_driver_instrument_routine_channel0_duty_increment //if the current offset is not equal to the release index, increment the offset
0013b4 91a0 282b                 	lds r26, pulse1_duty_macro_loop
0013b6 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0013b7 f010                      	brlo sound_driver_instrument_routine_channel0_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0013b8 c027                      	rjmp sound_driver_channel0_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel0_duty_increment:
0013b9 95a3                      	inc r26 //increment the macro offset
0013ba 93a0 282a                 	sts pulse1_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_duty_read:
0013bc 91b4                      	lpm r27, Z //load pitch data into r27
0013bd 3fbf                      	cpi r27, 0xFF //check for macro end flag
0013be f471                      	brne sound_driver_instrument_routine_channel0_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_release:
0013bf 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0013c0 93a0 282a                 	sts pulse1_duty_macro_offset, r26
0013c2 91b0 282c                 	lds r27, pulse1_duty_macro_release
0013c4 3fbf                      	cpi r27, 0xFF
0013c5 f4d1                      	brne sound_driver_channel0_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_loop:
0013c6 91b0 282b                 	lds r27, pulse1_duty_macro_loop //load the loop index
0013c8 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0013c9 f0b1                      	breq sound_driver_channel0_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
0013ca 93b0 282a                 	sts pulse1_duty_macro_offset, r27 //store the loop index into the offset
0013cc cfd7                      	rjmp sound_driver_instrument_routine_channel0_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_load:
0013cd e2f9                      	ldi ZH, HIGH(sequences << 1) //point Z to sequence table
0013ce e8ea                      	ldi ZL, LOW(sequences << 1)
0013cf 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
0013d0 1df2                      	adc ZH, zero
                                 
0013d1 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
0013d2 95b7                      	ror r27
0013d3 95b7                      	ror r27
0013d4 91a0 2800                 	lds r26, pulse1_param //load r26 with pulse1_param (register $4000)
0013d6 2fca                      	mov r28, r26 //store a copy of pulse1_param into r28
0013d7 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
0013d8 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
0013d9 c001                      	rjmp sound_driver_instrument_routine_channel0_duty_load_store
0013da c005                      	rjmp sound_driver_channel0_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel0_duty_load_store:
0013db 90d4                      	lpm pulse1_sequence, Z //store the sequence
                                 
0013dc 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
0013dd 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
0013de 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_routines:
                                 sound_driver_channel0_fx_Axy_routine:
0013e0 91b0 282e                 	lds r27, pulse1_fx_Axy
0013e2 15b2                      	cp r27, zero
0013e3 f0e9                      	breq sound_driver_channel0_fx_Qxy_routine //0 means that the effect is not in use
                                 	
0013e4 91a0 2805                 	lds r26, pulse1_fractional_volume //load fractional volume representation of the channel
0013e6 91c0 2800                 	lds r28, pulse1_param //load the integer volume representation of the channel
0013e8 2fda                      	mov r29, r26 //copy fractional volume into r29
0013e9 2fec                      	mov r30, r28 //copy the pulse1_param into r30
0013ea 95e2                      	swap r30
0013eb 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
0013ec 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
0013ed 17ed                      	cp r30, r29 //compare the fractional and integer volumes
0013ee f009                      	breq sound_driver_channel0_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel0_fx_Axy_routine_reload:
0013ef 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate:
0013f0 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
0013f1 c004                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_addition:
0013f2 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0013f3 f428                      	brcc sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0013f4 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
0013f5 c003                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_subtraction:
0013f6 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0013f7 f008                      	brcs sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0013f8 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_store:
0013f9 93a0 2805                 	sts pulse1_fractional_volume, r26 //store the new fractional volume
0013fb 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
0013fc 95a2                      	swap r26
0013fd 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
0013fe 2bca                      	or r28, r26 //store the new volume back into pulse1_param
0013ff 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel0_fx_Qxy_routine:
001401 91e0 282f                 	lds ZL, pulse1_fx_Qxy_target
001403 91f0 2830                 	lds ZH, pulse1_fx_Qxy_target+1
001405 9630                      	adiw Z, 0
001406 f131                      	breq sound_driver_channel0_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
001407 91a0 2833                 	lds r26, pulse1_fx_Qxy_total_offset
001409 91b0 2834                 	lds r27, pulse1_fx_Qxy_total_offset+1
00140b 91c0 0a8c                 	lds r28, TCB0_CCMPL
00140d 91d0 0a8d                 	lds r29, TCB0_CCMPH
00140f 1bca                      	sub r28, r26 //subtract the timer period by the total offset
001410 0bdb                      	sbc r29, r27
                                 
001411 17ce                      	cp r28, ZL //compare the new timer period with the target
001412 07df                      	cpc r29, ZH
001413 f010                      	brlo sound_driver_channel0_fx_Qxy_routine_end //if the target has been reached (or passed)
001414 f009                      	breq sound_driver_channel0_fx_Qxy_routine_end
001415 f468                      	brsh sound_driver_channel0_fx_Qxy_routine_add
                                 
                                 sound_driver_channel0_fx_Qxy_routine_end:
001416 1bec                      	sub ZL, r28 //calculate the difference to the target
001417 0bfd                      	sbc ZH, r29
001418 0fae                      	add r26, ZL //increase the total offset to the exact amount needed to reach the target
001419 1fbf                      	adc r27, ZH
00141a 93a0 2833                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
00141c 93b0 2834                 	sts pulse1_fx_Qxy_total_offset+1, r27
00141e 9220 282f                 	sts pulse1_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
001420 9220 2830                 	sts pulse1_fx_Qxy_target+1, zero
001422 c00a                      	rjmp sound_driver_channel0_fx_Rxy_routine
                                 
                                 sound_driver_channel0_fx_Qxy_routine_add:
001423 91c0 2831                 	lds r28, pulse1_fx_Qxy_speed
001425 91d0 2832                 	lds r29, pulse1_fx_Qxy_speed+1
001427 0fac                      	add r26, r28 //increase the total offset by the speed
001428 1fbd                      	adc r27, r29
001429 93a0 2833                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
00142b 93b0 2834                 	sts pulse1_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Rxy_routine:
00142d 91e0 2835                 	lds ZL, pulse1_fx_Rxy_target
00142f 91f0 2836                 	lds ZH, pulse1_fx_Rxy_target+1
001431 9630                      	adiw Z, 0
001432 f131                      	breq sound_driver_channel0_fx_xy_routine //if the effect is not enabled, skip the routine
                                 
001433 91a0 2839                 	lds r26, pulse1_fx_Rxy_total_offset
001435 91b0 283a                 	lds r27, pulse1_fx_Rxy_total_offset+1
001437 91c0 0a8c                 	lds r28, TCB0_CCMPL
001439 91d0 0a8d                 	lds r29, TCB0_CCMPH
00143b 0fca                      	add r28, r26 //add the total offset to the timer period
00143c 0fdb                      	add r29, r27
                                 
00143d 17ce                      	cp r28, ZL //compare the new timer period with the target
00143e 07df                      	cpc r29, ZH
00143f f010                      	brlo sound_driver_channel0_fx_Rxy_routine_end //if the target has been reached (or passed)
001440 f009                      	breq sound_driver_channel0_fx_Rxy_routine_end
001441 f468                      	brsh sound_driver_channel0_fx_Rxy_routine_add
                                 
                                 sound_driver_channel0_fx_Rxy_routine_end:
001442 1bec                      	sub ZL, r28 //calculate the difference to the target
001443 0bfd                      	sbc ZH, r29
001444 0fae                      	add r26, ZL //increase the total offset to the exact amount needed to reach the target
001445 1fbf                      	adc r27, ZH
001446 93a0 2839                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
001448 93b0 283a                 	sts pulse1_fx_Rxy_total_offset+1, r27
00144a 9220 2835                 	sts pulse1_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
00144c 9220 2836                 	sts pulse1_fx_Rxy_target+1, zero
00144e c00a                      	rjmp sound_driver_channel0_fx_xy_routine
                                 
                                 sound_driver_channel0_fx_Rxy_routine_add:
00144f 91c0 2837                 	lds r28, pulse1_fx_Rxy_speed
001451 91d0 2838                 	lds r29, pulse1_fx_Rxy_speed+1
001453 0fac                      	add r26, r28 //increase the total offset by the speed
001454 1fbd                      	adc r27, r29
001455 93a0 2839                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
001457 93b0 283a                 	sts pulse1_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 sound_driver_channel0_fx_xy_routine:
                                 
                                 sound_driver_exit:
001459 91df                      	pop r29
00145a 91cf                      	pop r28
00145b cbce                      	rjmp sequence_1_3 + 3 //+3 is to skip the stack instructions since we already pushed them
                                 
                                 //PULSE 1 ROUTINES
                                 pulse1_sequence_routine:
00145c b7bf                      	in r27, CPU_SREG
00145d 93bf                      	push r27
00145e 94f8                      	cli
                                 
00145f 0cdd                      	lsl pulse1_sequence //shifts sequence to the left
001460 1cd2                      	adc pulse1_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
001461 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
001462 93b0 0a86                 	sts TCB0_INTFLAGS, r27
001464 91bf                      	pop r27
001465 bfbf                      	out CPU_SREG, r27
001466 9518                      	reti
                                 
                                 pulse1_sweep_routine:
001467 2dbf                      	mov r27, pulse1_sweep
001468 70b7                      	andi r27, 0x07 //mask for period divider bits
001469 f4f9                      	brne pulse1_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse1_sweep_routine_action: //if the divider is == 0, update the pulse timer period
00146a 93df                      	push r29
00146b 2ddf                      	mov r29, pulse1_sweep
00146c 95d2                      	swap r29
00146d 70d7                      	andi r29, 0x07 //mask for shift bits
00146e f409                      	brne PC+2 //check of shift == 0
00146f 91df                      	pop r29
001470 c019                      	rjmp pulse1_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
001471 91a0 0a8c                 	lds r26, TCB0_CCMPL
001473 91b0 0a8d                 	lds r27, TCB0_CCMPH
001475 95b6                      	lsr r27
001476 95a7                      	ror r26
001477 95da                      	dec r29
001478 f7e1                      	brne PC-3 //keep looping/shifting until shift count is 0
                                 
001479 fef7                      	sbrs pulse1_sweep, 7 //check the negate flag
00147a c002                      	rjmp PC+3 //if negate flag was clear, go straight to addition
                                 
00147b 95a0                      	com r26 //pulse1 uses one's complement if the negate flag is set
00147c 95b0                      	com r27
                                 
00147d 91d0 0a8c                 	lds r29, TCB0_CCMPL //perform addition to get new timer period
00147f 0fad                      	add r26, r29
001480 91d0 0a8d                 	lds r29, TCB0_CCMPH
001482 1fbd                      	adc r27, r29
                                 
001483 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new LOW bits for timer
001485 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new HIGH bits for timer
                                 
                                 	//sts pulse1_timerL, r26
                                 	//sts pulse1_timerH, r27
                                 
                                 /*	//Sweep Test
                                 	mov r29, pulse1_sweep //invert the negate bit
                                 	ldi r27, 0b10000000
                                 	eor r29, r27
                                 	ori r29, 0b01111111
                                 
                                 	lds r27, pulse1_sweep_param //reload the pulse sweep divider params
                                 	swap r27
                                 	ori r27, 0b10000000
                                 	and r27, r29
                                 	mov pulse1_sweep, r27
                                 	sbr channel_flags, 0b10000000*/
                                 	
001487 91df                      	pop r29
001488 c001                      	rjmp pulse1_sweep_routine_check_reload
                                 
                                 pulse1_sweep_routine_decrement_divider:
001489 94fa                      	dec pulse1_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse1_sweep_routine_check_reload:
00148a ff97                      	sbrs channel_flags, 7 //if the reload flag is set, reload the sweep divider
00148b 9508                      	ret
                                 
                                 pulse1_sweep_reload:
00148c 90f0 2801                 	lds pulse1_sweep, pulse1_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
00148e 94f2                      	swap pulse1_sweep //bring data from high byte to low byte
00148f 779f                      	cbr channel_flags, 0b10000000 //clear ready flag
001490 9508                      	ret
                                 
                                 pulse1_envelope_routine:
001491 fd96                      	sbrc channel_flags, 6 //check if start flag is cleared
001492 c010                      	rjmp pulse1_envelope_routine_clear_start
                                 
001493 3000                      	cpi pulse1_volume_divider, 0x00 //check if the divider is 0
001494 f011                      	breq PC+3 //if the divider == 0, check loop flag
001495 950a                      	dec pulse1_volume_divider //if the divider != 0, decrement and return
001496 9508                      	ret
                                 
001497 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the divider == 0, reset the divider period
001499 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
00149a ff95                      	sbrs channel_flags, 5 //check if the loop flag is set
00149b c002                      	rjmp pulse1_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
00149c e01f                      	ldi pulse1_volume_decay, 0x0F //if the loop flag is set, reset decay and return
00149d 9508                      	ret
                                 
                                 pulse1_envelope_routine_decrement_decay:
00149e 3010                      	cpi pulse1_volume_decay, 0x00 //check if the decay is 0
00149f f409                      	brne PC+2 //if decay != 0, go decrement
0014a0 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
0014a1 951a                      	dec pulse1_volume_decay
0014a2 9508                      	ret
                                 
                                 pulse1_envelope_routine_clear_start:
0014a3 7b9f                      	cbr channel_flags, 0b01000000 //if the start flag is set, clear it
0014a4 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the start flag is set, reset the divider period
0014a6 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
0014a7 e01f                      	ldi pulse1_volume_decay, 0x0F //if the start flag is set, reset decay
0014a8 9508                      	ret
                                 
                                 //CONVERTERS (TABLES)
                                 //converts and loads 5 bit length to corresponding 8 bit length value into r29
                                 length_converter:
0014a9 e2f9                      	ldi ZH, HIGH(length << 1)
0014aa e5ee                      	ldi ZL, LOW(length << 1)
0014ab 0fed                      	add ZL, r29
0014ac 1df2                      	adc ZH, zero
0014ad 91d4                      	lpm r29, Z
0014ae 9508                      	ret
                                 
0014af 7f05
0014b0 010a
0014b1 0214
0014b2 0328
0014b3 0450
0014b4 051e
0014b5 0607
0014b6 070d
0014b7 0806
0014b8 090c
0014b9 0a18
0014ba 0b30
0014bb 0c60
0014bc 0d24
0014bd 0e08
0014be 0f10                      length: .db $05, $7F, $0A, $01, $14, $02, $28, $03, $50, $04, $1E, $05, $07, $06, $0D, $07, $06, $08, $0C, $09, $18, $0A, $30, $0B, $60, $0C, $24, $0D, $08, $0E, $10, $0F
                                 
                                 //loads pulse sequence into r29
                                 duty_cycle_sequences:
0014bf e2f9                      	ldi ZH, HIGH(sequences << 1)
0014c0 e8ea                      	ldi ZL, LOW(sequences << 1)
0014c1 0fed                      	add ZL, r29
0014c2 1df2                      	adc ZH, zero
0014c3 91d4                      	lpm r29, Z
0014c4 9508                      	ret
                                 
                                 //pulse sequences: 12.5%, 25%, 50%, 75%
0014c5 0301
0014c6 fc0f                      sequences: .db 0b00000001, 0b00000011, 0b00001111, 0b11111100
                                 
                                 //list of famitracker fx: http://famitracker.com/wiki/index.php?title=Effect_list
                                 fx:
0014c7 106a
0014c8 106b
0014c9 106c
0014ca 106d
0014cb 106e                      	.dw sound_driver_channel0_fx_0xy, sound_driver_channel0_fx_1xx, sound_driver_channel0_fx_2xx, sound_driver_channel0_fx_3xx, sound_driver_channel0_fx_4xy
0014cc 106f
0014cd 1070
0014ce 1073
0014cf 1074
0014d0 1075                      	.dw sound_driver_channel0_fx_7xy, sound_driver_channel0_fx_Axy, sound_driver_channel0_fx_Bxx, sound_driver_channel0_fx_Cxx, sound_driver_channel0_fx_Dxx
0014d1 1076
0014d2 1077
0014d3 1078
0014d4 1079
0014d5 107a                      	.dw sound_driver_channel0_fx_Exx, sound_driver_channel0_fx_Fxx, sound_driver_channel0_fx_Gxx, sound_driver_channel0_fx_Hxy, sound_driver_channel0_fx_lxy
0014d6 107b
0014d7 107c
0014d8 107d
0014d9 1080
0014da 10c4                      	.dw sound_driver_channel0_fx_Hxx, sound_driver_channel0_fx_Ixx, sound_driver_channel0_fx_Pxx, sound_driver_channel0_fx_Qxy, sound_driver_channel0_fx_Rxy
0014db 1107
0014dc 1108
0014dd 111c
0014de 111d
0014df 111e                      	.dw sound_driver_channel0_fx_Sxx, sound_driver_channel0_fx_Vxx, sound_driver_channel0_fx_Wxx, sound_driver_channel0_fx_Xxx, sound_driver_channel0_fx_Yxx
0014e0 111f                      	.dw sound_driver_channel0_fx_Zxx
                                 
                                 //famitracker volumes table: http://famitracker.com/wiki/index.php?title=Volume
                                 volumes:
0014e1 0000
0014e2 0000
0014e3 0000
0014e4 0000
0014e5 0000
0014e6 0000
0014e7 0000
0014e8 0000                      	.db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
0014e9 0100
0014ea 0101
0014eb 0101
0014ec 0101
0014ed 0101
0014ee 0101
0014ef 0101
0014f0 0101                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
0014f1 0100
0014f2 0101
0014f3 0101
0014f4 0101
0014f5 0101
0014f6 0101
0014f7 0101
0014f8 0201                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02
0014f9 0100
0014fa 0101
0014fb 0101
0014fc 0101
0014fd 0101
0014fe 0202
0014ff 0202
001500 0302                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03
001501 0100
001502 0101
001503 0101
001504 0101
001505 0202
001506 0202
001507 0303
001508 0403                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04
001509 0100
00150a 0101
00150b 0101
00150c 0202
00150d 0302
00150e 0303
00150f 0404
001510 0504                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05
001511 0100
001512 0101
001513 0201
001514 0202
001515 0303
001516 0404
001517 0504
001518 0605                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x06
001519 0100
00151a 0101
00151b 0201
00151c 0302
00151d 0403
00151e 0504
00151f 0605
001520 0706                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07
001521 0100
001522 0101
001523 0202
001524 0303
001525 0404
001526 0505
001527 0606
001528 0807                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07, 0x08
001529 0100
00152a 0101
00152b 0302
00152c 0403
00152d 0504
00152e 0606
00152f 0707
001530 0908                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09
001531 0100
001532 0201
001533 0302
001534 0404
001535 0605
001536 0706
001537 0808
001538 0a09                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A
001539 0100
00153a 0201
00153b 0302
00153c 0504
00153d 0605
00153e 0807
00153f 0908
001540 0b0a                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B
001541 0100
001542 0201
001543 0403
001544 0504
001545 0706
001546 0808
001547 0a09
001548 0c0b                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B, 0x0C
001549 0100
00154a 0201
00154b 0403
00154c 0605
00154d 0706
00154e 0908
00154f 0b0a
001550 0d0c                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D
001551 0100
001552 0201
001553 0403
001554 0605
001555 0807
001556 0a09
001557 0c0b
001558 0e0d                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E
001559 0100
00155a 0302
00155b 0504
00155c 0706
00155d 0908
00155e 0b0a
00155f 0d0c


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega4809" register use summary:
x  :   0 y  :   0 z  :  53 r0 :  16 r1 :  18 r2 : 109 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 
r13:   6 r14:   4 r15:   9 r16:   7 r17:   6 r18:   0 r19:   0 r20:   0 
r21:   0 r22:  16 r23:  16 r24:   0 r25:  11 r26: 166 r27: 288 r28:  64 
r29:  70 r30:  77 r31:  72 
Registers used: 18 out of 35 (51.4%)

"ATmega4809" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  28 add   :  37 adiw  :  19 and   :   0 
andi  :  22 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   2 brcs  :   2 break :   0 breq  :  33 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  14 brlt  :   0 brmi  :   0 
brne  :  27 brpl  :   0 brsh  :   6 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :   0 cbr   :   2 
clc   :   0 clh   :   0 cli   :   4 cln   :   0 clr   :   1 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :   2 cp    :  15 cpc   :   2 
cpi   :  42 cpse  :   4 dec   :   7 des   :   0 eor   :   0 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   1 in    :   4 inc   :  12 
jmp   :   6 ld    :   0 ldd   :   0 ldi   :  70 lds   : 128 lpm   :  58 
lsl   :  19 lsr   :  16 mov   :  24 movw  :   0 mul   :   2 muls  :   0 
mulsu :   2 neg   :   0 nop   :   0 or    :   5 ori   :   0 out   :   6 
pop   :  19 push  :  19 rcall :  16 ret   :  13 reti  :   3 rjmp  : 101 
rol   :  13 ror   :  17 sbc   :   4 sbci  :   0 sbi   :   0 sbic  :   0 
sbis  :   0 sbiw  :   0 sbr   :   3 sbrc  :   8 sbrs  :   5 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   : 230 sub   :   5 subi  :   9 swap  :   8 tst   :   0 wdr   :   0 

Instructions used: 50 out of 114 (43.9%)

"ATmega4809" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x002ac2   2874   8044  10918   49152  22.2%
[.dseg] 0x002800 0x00283f      0     63     63    6144   1.0%
[.eseg] 0x000000 0x000000      0      0      0     256   0.0%

Assembly complete, 0 errors, 101 warnings
