
AVRASM ver. 2.2.8  C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm Fri Jan 22 23:48:27 2021

C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
                                 
                                 
                                 ; NES_APU_2a03.asm
                                 ;
                                 ; Created: 11/29/2020 1:44:10 AM
                                 ; Author : Tennyson Cheng
                                 ;
                                 
                                 .list
                                 
                                 .dseg
002800                           pulse1_param: .byte 1 //$4000 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002801                           pulse1_sweep_param: .byte 1 //$4001 EPPP.NSSS = Enable, Period, Negate, Shift
                                 //NOTE: In order to account for multiplier, we use 16 instead of 11 bits for the timer
002802                           pulse1_timerL: .byte 1 //$4002 LLLL.LLLL = Low 8 bits for timer
002803                           pulse1_timerH: .byte 1 //$4002 HHHH.HHHH = High 8 bits for timer
002804                           pulse1_length: .byte 1 //$4003 000l.llll = Length counter load
002805                           pulse1_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002806                           pulse1_output_volume: .byte 1 //this is the final output volume of pulse 1
002807                           pulse1_note: .byte 1 //the current note index in the note table
                                 
002808                           pulse2_param: .byte 1 //$4004 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002809                           pulse2_sweep_param: .byte 1 //$4005 EPPP.NSSS = Enable, Period, Negate, Shift
00280a                           pulse2_timerL: .byte 1 //$4006 LLLL.LLLL = Low 8 bits for timer
00280b                           pulse2_timerH: .byte 1 //$4006 HHHH.HHHH = High 8 bits for timer
00280c                           pulse2_length: .byte 1 //$4007 000l.llll = Length counter load
00280d                           pulse2_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
00280e                           pulse2_output_volume: .byte 1 //this is the final output volume of pulse 2
00280f                           pulse2_note: .byte 1 //the current note index in the note table
                                 
002810                           triangle_timerL: .byte 1 //$400A LLLL.LLLL = Low 8 bits for timer
002811                           triangle_timerH: .byte 1 //$400A HHHH.HHHH = High 8 bits for time
002812                           triangle_note: .byte 1 //the current note index in the note table
                                 
002813                           noise_param: .byte 1 //$400C 00lc.vvvv = Length counter halt/Loop flag, Constant volume flag, Volume
002814                           noise_period: .byte 1 //$400E M000.PPPP = Mode, Period
002815                           noise_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002816                           noise_output_volume: .byte 1 //this is the final output volume of pulse 2
002817                           noise_note: .byte 1 //the current note index in the period table
                                 
002818                           song_frames: .byte 2
00281a                           song_frame_offset: .byte 2
00281c                           song_size: .byte 2
00281e                           song_speed: .byte 1
                                 //song_channel_delay_reload: .byte 1 //bit 0-4 represents channels 0-4. a set bit means that there is a delay that needs to be calculated for that channel.
00281f                           song_fx_Bxx: .byte 1
002820                           song_fx_Cxx: .byte 1
002821                           song_fx_Dxx: .byte 1
                                 
                                 //PULSE 1
002822                           pulse1_pattern: .byte 2
002824                           pulse1_pattern_delay_rows: .byte 1
002825                           pulse1_pattern_delay_frames: .byte 1
002826                           pulse1_pattern_offset: .byte 2
                                 
002828                           pulse1_volume_macro: .byte 2
00282a                           pulse1_volume_macro_offset: .byte 1
00282b                           pulse1_volume_macro_loop: .byte 1
00282c                           pulse1_volume_macro_release: .byte 1
                                 
00282d                           pulse1_arpeggio_macro: .byte 2
00282f                           pulse1_arpeggio_macro_offset: .byte 1
002830                           pulse1_arpeggio_macro_loop: .byte 1
002831                           pulse1_arpeggio_macro_release: .byte 1
002832                           pulse1_arpeggio_macro_mode: .byte 1
                                 
002833                           pulse1_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002835                           pulse1_pitch_macro: .byte 2
002837                           pulse1_pitch_macro_offset: .byte 1
002838                           pulse1_pitch_macro_loop: .byte 1
002839                           pulse1_pitch_macro_release: .byte 1
                                 
00283a                           pulse1_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00283b                           pulse1_hi_pitch_macro: .byte 2
00283d                           pulse1_hi_pitch_macro_offset: .byte 1
00283e                           pulse1_hi_pitch_macro_loop: .byte 1
00283f                           pulse1_hi_pitch_macro_release: .byte 1
                                 
002840                           pulse1_duty_macro: .byte 2
002842                           pulse1_duty_macro_offset: .byte 1
002843                           pulse1_duty_macro_loop: .byte 1
002844                           pulse1_duty_macro_release: .byte 1
                                 
002845                           pulse1_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002847                           pulse1_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002849                           pulse1_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00284b                           pulse1_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
00284d                           pulse1_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
00284f                           pulse1_fx_3xx_start: .byte 2 //the starting note period
002851                           pulse1_fx_3xx_target: .byte 2 //target note period
002853                           pulse1_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
002855                           pulse1_fx_3xx_total_offset: .byte 2
002857                           pulse1_fx_4xy_speed: .byte 1
002858                           pulse1_fx_4xy_depth: .byte 1
002859                           pulse1_fx_4xy_phase: .byte 1
00285a                           pulse1_fx_7xy_speed: .byte 1
00285b                           pulse1_fx_7xy_depth: .byte 1
00285c                           pulse1_fx_7xy_phase: .byte 1
00285d                           pulse1_fx_7xy_value: .byte 1 //value to offset the volume
00285e                           pulse1_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
00285f                           pulse1_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002860                           pulse1_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002861                           pulse1_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
002863                           pulse1_fx_Qxy_target: .byte 2 //target note period
002865                           pulse1_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002867                           pulse1_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002869                           pulse1_fx_Rxy_target: .byte 2 //target note period
00286b                           pulse1_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
00286d                           pulse1_fx_Rxy_total_offset: .byte 2
00286f                           pulse1_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002870                           pulse1_fx_Sxx_post: .byte 1
                                 
                                 //PULSE 2
002871                           pulse2_pattern: .byte 2
002873                           pulse2_pattern_delay_rows: .byte 1
002874                           pulse2_pattern_delay_frames: .byte 1
002875                           pulse2_pattern_offset: .byte 2
                                 
002877                           pulse2_volume_macro: .byte 2
002879                           pulse2_volume_macro_offset: .byte 1
00287a                           pulse2_volume_macro_loop: .byte 1
00287b                           pulse2_volume_macro_release: .byte 1
                                 
00287c                           pulse2_arpeggio_macro: .byte 2
00287e                           pulse2_arpeggio_macro_offset: .byte 1
00287f                           pulse2_arpeggio_macro_loop: .byte 1
002880                           pulse2_arpeggio_macro_release: .byte 1
002881                           pulse2_arpeggio_macro_mode: .byte 1
                                 
002882                           pulse2_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002884                           pulse2_pitch_macro: .byte 2
002886                           pulse2_pitch_macro_offset: .byte 1
002887                           pulse2_pitch_macro_loop: .byte 1
002888                           pulse2_pitch_macro_release: .byte 1
                                 
002889                           pulse2_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00288a                           pulse2_hi_pitch_macro: .byte 2
00288c                           pulse2_hi_pitch_macro_offset: .byte 1
00288d                           pulse2_hi_pitch_macro_loop: .byte 1
00288e                           pulse2_hi_pitch_macro_release: .byte 1
                                 
00288f                           pulse2_duty_macro: .byte 2
002891                           pulse2_duty_macro_offset: .byte 1
002892                           pulse2_duty_macro_loop: .byte 1
002893                           pulse2_duty_macro_release: .byte 1
                                 
002894                           pulse2_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002896                           pulse2_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002898                           pulse2_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00289a                           pulse2_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
00289c                           pulse2_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
00289e                           pulse2_fx_3xx_start: .byte 2 //the starting note period
0028a0                           pulse2_fx_3xx_target: .byte 2 //target note period
0028a2                           pulse2_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028a4                           pulse2_fx_3xx_total_offset: .byte 2
0028a6                           pulse2_fx_4xy_speed: .byte 1
0028a7                           pulse2_fx_4xy_depth: .byte 1
0028a8                           pulse2_fx_4xy_phase: .byte 1
0028a9                           pulse2_fx_7xy_speed: .byte 1
0028aa                           pulse2_fx_7xy_depth: .byte 1
0028ab                           pulse2_fx_7xy_phase: .byte 1
0028ac                           pulse2_fx_7xy_value: .byte 1 //value to offset the volume
0028ad                           pulse2_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
0028ae                           pulse2_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028af                           pulse2_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028b0                           pulse2_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
0028b2                           pulse2_fx_Qxy_target: .byte 2 //target note period
0028b4                           pulse2_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
0028b6                           pulse2_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
0028b8                           pulse2_fx_Rxy_target: .byte 2 //target note period
0028ba                           pulse2_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
0028bc                           pulse2_fx_Rxy_total_offset: .byte 2
0028be                           pulse2_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
0028bf                           pulse2_fx_Sxx_post: .byte 1
                                 
                                 //TRIANGLE
0028c0                           triangle_pattern: .byte 2
0028c2                           triangle_pattern_delay_rows: .byte 1
0028c3                           triangle_pattern_delay_frames: .byte 1
0028c4                           triangle_pattern_offset: .byte 2
                                 
0028c6                           triangle_volume_macro: .byte 2
0028c8                           triangle_volume_macro_offset: .byte 1
0028c9                           triangle_volume_macro_loop: .byte 1
0028ca                           triangle_volume_macro_release: .byte 1
                                 
0028cb                           triangle_arpeggio_macro: .byte 2
0028cd                           triangle_arpeggio_macro_offset: .byte 1
0028ce                           triangle_arpeggio_macro_loop: .byte 1
0028cf                           triangle_arpeggio_macro_release: .byte 1
0028d0                           triangle_arpeggio_macro_mode: .byte 1
                                 
0028d1                           triangle_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
0028d3                           triangle_pitch_macro: .byte 2
0028d5                           triangle_pitch_macro_offset: .byte 1
0028d6                           triangle_pitch_macro_loop: .byte 1
0028d7                           triangle_pitch_macro_release: .byte 1
                                 
0028d8                           triangle_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
0028d9                           triangle_hi_pitch_macro: .byte 2
0028db                           triangle_hi_pitch_macro_offset: .byte 1
0028dc                           triangle_hi_pitch_macro_loop: .byte 1
0028dd                           triangle_hi_pitch_macro_release: .byte 1
                                 
0028de                           triangle_duty_macro: .byte 2
0028e0                           triangle_duty_macro_offset: .byte 1
0028e1                           triangle_duty_macro_loop: .byte 1
0028e2                           triangle_duty_macro_release: .byte 1
                                 
0028e3                           triangle_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
0028e5                           triangle_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
0028e7                           triangle_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
0028e9                           triangle_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
0028eb                           triangle_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
0028ed                           triangle_fx_3xx_start: .byte 2 //the starting note period
0028ef                           triangle_fx_3xx_target: .byte 2 //target note period
0028f1                           triangle_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028f3                           triangle_fx_3xx_total_offset: .byte 2
0028f5                           triangle_fx_4xy_speed: .byte 1
0028f6                           triangle_fx_4xy_depth: .byte 1
0028f7                           triangle_fx_4xy_phase: .byte 1
0028f8                           triangle_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028f9                           triangle_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028fa                           triangle_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
0028fc                           triangle_fx_Qxy_target: .byte 2 //target note period
0028fe                           triangle_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002900                           triangle_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002902                           triangle_fx_Rxy_target: .byte 2 //target note period
002904                           triangle_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
002906                           triangle_fx_Rxy_total_offset: .byte 2
002908                           triangle_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002909                           triangle_fx_Sxx_post: .byte 1
                                 
                                 //NOISE
00290a                           noise_pattern: .byte 2
00290c                           noise_pattern_delay_rows: .byte 1
00290d                           noise_pattern_delay_frames: .byte 1
00290e                           noise_pattern_offset: .byte 2
                                 
002910                           noise_volume_macro: .byte 2
002912                           noise_volume_macro_offset: .byte 1
002913                           noise_volume_macro_loop: .byte 1
002914                           noise_volume_macro_release: .byte 1
                                 
002915                           noise_arpeggio_macro: .byte 2
002917                           noise_arpeggio_macro_offset: .byte 1
002918                           noise_arpeggio_macro_loop: .byte 1
002919                           noise_arpeggio_macro_release: .byte 1
00291a                           noise_arpeggio_macro_mode: .byte 1
                                 
00291b                           noise_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
00291d                           noise_pitch_macro: .byte 2
00291f                           noise_pitch_macro_offset: .byte 1
002920                           noise_pitch_macro_loop: .byte 1
002921                           noise_pitch_macro_release: .byte 1
                                 
002922                           noise_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
002923                           noise_hi_pitch_macro: .byte 2
002925                           noise_hi_pitch_macro_offset: .byte 1
002926                           noise_hi_pitch_macro_loop: .byte 1
002927                           noise_hi_pitch_macro_release: .byte 1
                                 
002928                           noise_duty_macro: .byte 2
00292a                           noise_duty_macro_offset: .byte 1
00292b                           noise_duty_macro_loop: .byte 1
00292c                           noise_duty_macro_release: .byte 1
                                 
00292d                           noise_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
00292f                           noise_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002931                           noise_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
002933                           noise_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
002935                           noise_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
002937                           noise_fx_3xx_start: .byte 2 //the starting note period
002939                           noise_fx_3xx_target: .byte 2 //target note period
00293b                           noise_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
00293d                           noise_fx_3xx_total_offset: .byte 2
00293f                           noise_fx_4xy_speed: .byte 1
002940                           noise_fx_4xy_depth: .byte 1
002941                           noise_fx_4xy_phase: .byte 1
002942                           noise_fx_7xy_speed: .byte 1
002943                           noise_fx_7xy_depth: .byte 1
002944                           noise_fx_7xy_phase: .byte 1
002945                           noise_fx_7xy_value: .byte 1 //value to offset the volume
002946                           noise_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
002947                           noise_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002948                           noise_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002949                           noise_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
00294b                           noise_fx_Qxy_target: .byte 2 //target note period
00294d                           noise_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
00294f                           noise_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002951                           noise_fx_Rxy_target: .byte 2 //target note period
002953                           noise_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
002955                           noise_fx_Rxy_total_offset: .byte 2
002957                           noise_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002958                           noise_fx_Sxx_post: .byte 1
                                 
                                 //DPCM
002959                           dcpm_pattern_delay: .byte 1
                                 
                                 .cseg
                                 
                                 //NOTE: zero is defined in order to use the cp instruction without the need to load 0x00 into a register beforehand
                                 .def zero = r2
                                 .def pulse_channel_flags = r25 //[pulse1.pulse2] RSlc.RSlc = Reload, Start, Length halt/Loop, Constant volume
                                 .def pulse1_sequence = r10
                                 .def pulse1_length_counter = r11
                                 .def pulse1_sweep = r12 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse1_volume_divider = r16 //0000.PPPP = Period divider
                                 .def pulse1_volume_decay = r17 //0000.dddd = Decay
                                 .def pulse2_sequence = r13
                                 .def pulse2_length_counter = r14
                                 .def pulse2_sweep = r15 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse2_volume_divider = r18 //0000.PPPP = Period divider
                                 .def pulse2_volume_decay = r19 //0000.dddd = Decay
                                 .def triangle_sequence = r20
                                 .def noise_sequence_LOW = r21
                                 .def noise_sequence_HIGH = r22
                                 
                                 reset:
000000 940c 1372                 	jmp init
                                 
                                 .org TCA0_OVF_vect
00000e 940c 181d                 	jmp sound_driver
                                 
                                 .org TCA0_CMP0_vect
000012 940c 1724                 	jmp sequence_0_2
                                 
                                 .org TCA0_CMP1_vect
000014 940c 172f                 	jmp sequence_1_3
                                 
                                 .org TCA0_CMP2_vect
000016 940c 1724                 	jmp sequence_0_2
                                 
                                 .org TCB0_INT_vect
000018 940c 1746                 	jmp pulse1_sequence_routine
                                 
                                 .org TCB1_INT_vect
00001a 940c 1793                 	jmp pulse2_sequence_routine
                                 
                                 .org TCB2_INT_vect
000032 940c 17e0                 	jmp triangle_sequence_routine
                                 
                                 .org TCB3_INT_vect
000048 940c 17eb                 	jmp noise_sequence_routine
                                 
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(33): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(48): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(85): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(86): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(88): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(90): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(91): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(92): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(93): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(96): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(98): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(99): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(100): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(105): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(106): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(111): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(115): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(116): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(119): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(121): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(122): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(123): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(127): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(130): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(131): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(132): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(134): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(135): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(136): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(137): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(138): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(139): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(142): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(145): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(146): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(149): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(150): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(196): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(197): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(198): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(202): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(203): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(205): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(206): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(207): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(211): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(212): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(213): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(216): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(217): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(218): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(221): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(222): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
                                 .list
                                 
                                 init:
                                 	//MAIN CLOCK
001372 edc8                      	ldi r28, CPU_CCP_IOREG_gc //protected write
001373 93c0 0034                 	sts CPU_CCP, r28
001375 e0c0                      	ldi r28, 0 << CLKCTRL_PEN_bp //disable prescaler for 20 MHz on main clock
001376 93c0 0061                 	sts CLKCTRL_MCLKCTRLB, r28
                                 
                                 	//ZERO
001378 2422                      	clr zero
                                 
                                 	//MEMORY
001379 e3c0                      	ldi r28, 0b00110000
00137a 93c0 2800                 	sts pulse1_param, r28
00137c e8c0                      	ldi r28, 0b10000000
00137d 93c0 2801                 	sts pulse1_sweep_param, r28
00137f efcf                      	ldi r28, 0xFF
001380 93c0 2802                 	sts pulse1_timerL, r28
001382 93c0 2803                 	sts pulse1_timerH, r28
001384 93c0 2804                 	sts pulse1_length, r28
                                 
001386 e3c0                      	ldi r28, 0b00110000
001387 93c0 2808                 	sts pulse2_param, r28
001389 e8c0                      	ldi r28, 0b10000000
00138a 93c0 2809                 	sts pulse2_sweep_param, r28
00138c efcf                      	ldi r28, 0xFF
00138d 93c0 280a                 	sts pulse2_timerL, r28
00138f 93c0 280b                 	sts pulse2_timerH, r28
001391 93c0 280c                 	sts pulse2_length, r28
                                 
001393 efcf                      	ldi r28, 0xFF
001394 93c0 2810                 	sts triangle_timerL, r28
001396 93c0 2811                 	sts triangle_timerH, r28
                                 
001398 e3c0                      	ldi r28, 0b00110000
001399 93c0 2813                 	sts noise_param, r28
00139b e0cf                      	ldi r28, 0b00001111
00139c 93c0 2814                 	sts noise_period, r28
                                 
00139e e0c2                      	ldi r28, 0x02
00139f 93c0 281a                 	sts song_frame_offset, r28
0013a1 9220 281b                 	sts song_frame_offset+1, zero
0013a3 efcf                      	ldi r28, 0xFF
0013a4 93c0 281f                 	sts song_fx_Bxx, r28
0013a6 9220 2820                 	sts song_fx_Cxx, zero
0013a8 9220 2821                 	sts song_fx_Dxx, zero
0013aa e4ee                      	ldi ZL, LOW(song0_frames << 1)
0013ab e0f3                      	ldi ZH, HIGH(song0_frames << 1)
0013ac 93e0 2818                 	sts song_frames, ZL
0013ae 93f0 2819                 	sts song_frames+1, ZH
0013b0 91c5                      	lpm r28, Z+ //load the song size
0013b1 91d5                      	lpm r29, Z+
0013b2 93c0 281c                 	sts song_size, r28
0013b4 93d0 281d                 	sts song_size+1, r29
0013b6 9220 281e                 	sts song_speed, zero
                                 
                                 	//CHANNEL 0
0013b8 91c5                      	lpm r28, Z+
0013b9 91d5                      	lpm r29, Z+
0013ba 0fcc                      	lsl r28
0013bb 1fdd                      	rol r29
0013bc 93c0 2822                 	sts pulse1_pattern, r28
0013be 93d0 2823                 	sts pulse1_pattern+1, r29
0013c0 9220 2824                 	sts pulse1_pattern_delay_rows, zero
0013c2 9220 2825                 	sts pulse1_pattern_delay_frames, zero
0013c4 9220 2826                 	sts pulse1_pattern_offset, zero
0013c6 9220 2827                 	sts pulse1_pattern_offset+1, zero
                                 
                                 	//CHANNEL 1
0013c8 91c5                      	lpm r28, Z+
0013c9 91d5                      	lpm r29, Z+
0013ca 0fcc                      	lsl r28
0013cb 1fdd                      	rol r29
0013cc 93c0 2871                 	sts pulse2_pattern, r28
0013ce 93d0 2872                 	sts pulse2_pattern+1, r29
0013d0 9220 2873                 	sts pulse2_pattern_delay_rows, zero
0013d2 9220 2874                 	sts pulse2_pattern_delay_frames, zero
0013d4 9220 2875                 	sts pulse2_pattern_offset, zero
0013d6 9220 2876                 	sts pulse2_pattern_offset+1, zero
                                 
                                 	//CHANNEL 2
0013d8 91c5                      	lpm r28, Z+
0013d9 91d5                      	lpm r29, Z+
0013da 0fcc                      	lsl r28
0013db 1fdd                      	rol r29
0013dc 93c0 28c0                 	sts triangle_pattern, r28
0013de 93d0 28c1                 	sts triangle_pattern+1, r29
0013e0 9220 28c2                 	sts triangle_pattern_delay_rows, zero
0013e2 9220 28c3                 	sts triangle_pattern_delay_frames, zero
0013e4 9220 28c4                 	sts triangle_pattern_offset, zero
0013e6 9220 28c5                 	sts triangle_pattern_offset+1, zero
                                 
                                 	//CHANNEL 3
0013e8 91c5                      	lpm r28, Z+
0013e9 91d5                      	lpm r29, Z+
0013ea 0fcc                      	lsl r28
0013eb 1fdd                      	rol r29
0013ec 93c0 290a                 	sts noise_pattern, r28
0013ee 93d0 290b                 	sts noise_pattern+1, r29
0013f0 9220 290c                 	sts noise_pattern_delay_rows, zero
0013f2 9220 290d                 	sts noise_pattern_delay_frames, zero
0013f4 9220 290e                 	sts noise_pattern_offset, zero
0013f6 9220 290f                 	sts noise_pattern_offset+1, zero
                                 
                                 	//CHANNEL 0 instrument macros
0013f8 efcf                      	ldi r28, 0xFF
0013f9 9220 282a                 	sts pulse1_volume_macro_offset, zero
0013fb 93c0 282b                 	sts pulse1_volume_macro_loop, r28
0013fd 93c0 282c                 	sts pulse1_volume_macro_release, r28
0013ff 9220 282f                 	sts pulse1_arpeggio_macro_offset, zero
001401 93c0 2830                 	sts pulse1_arpeggio_macro_loop, r28
001403 93c0 2831                 	sts pulse1_arpeggio_macro_release, r28
001405 93c0 2832                 	sts pulse1_arpeggio_macro_mode, r28
001407 9220 2837                 	sts pulse1_pitch_macro_offset, zero
001409 93c0 2838                 	sts pulse1_pitch_macro_loop, r28
00140b 93c0 2839                 	sts pulse1_pitch_macro_release, r28
00140d 9220 283d                 	sts pulse1_hi_pitch_macro_offset, zero
00140f 93c0 283e                 	sts pulse1_hi_pitch_macro_loop, r28
001411 93c0 283f                 	sts pulse1_hi_pitch_macro_release, r28
001413 9220 2842                 	sts pulse1_duty_macro_offset, zero
001415 93c0 2843                 	sts pulse1_duty_macro_loop, r28
001417 93c0 2844                 	sts pulse1_duty_macro_release, r28
                                 
001419 9220 2828                 	sts pulse1_volume_macro, zero
00141b 9220 2829                 	sts pulse1_volume_macro+1, zero
00141d 9220 282d                 	sts pulse1_arpeggio_macro, zero
00141f 9220 282e                 	sts pulse1_arpeggio_macro+1, zero
001421 9220 2833                 	sts pulse1_total_pitch_offset, zero
001423 9220 2834                 	sts pulse1_total_pitch_offset+1, zero
001425 9220 2835                 	sts pulse1_pitch_macro, zero
001427 9220 2836                 	sts pulse1_pitch_macro+1, zero
001429 9220 283a                 	sts pulse1_total_hi_pitch_offset, zero
00142b 9220 283b                 	sts pulse1_hi_pitch_macro, zero
00142d 9220 283c                 	sts pulse1_hi_pitch_macro+1, zero
00142f 9220 2840                 	sts pulse1_duty_macro, zero
001431 9220 2841                 	sts pulse1_duty_macro+1, zero
                                 
                                 	//CHANNEL 0 ENVELOPE
001433 e00f                      	ldi pulse1_volume_divider, 0x0F
001434 9110 2800                 	lds pulse1_volume_decay, pulse1_param
001436 701f                      	andi pulse1_volume_decay, 0x0F //mask for VVVV bits
001437 9190 2800                 	lds pulse_channel_flags, pulse1_param
001439 7390                      	andi pulse_channel_flags, 0b00110000
00143a 6490                      	sbr pulse_channel_flags, 0b01000000 //set start flag
00143b 9220 2806                 	sts pulse1_output_volume, zero
00143d 93c0 2805                 	sts pulse1_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 0 LENGTH
00143f 2ebc                      	mov pulse1_length_counter, r28
                                 
                                 	//CHANNEL 0 SEQUENCE
001440 e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
001441 2eac                      	mov pulse1_sequence, r28
                                 
                                 	//CHANNEL 0 SWEEP
001442 90c0 2801                 	lds pulse1_sweep, pulse1_sweep_param
001444 94c2                      	swap pulse1_sweep //swap data from high byte and low byte
001445 6890                      	sbr pulse_channel_flags, 0b10000000 //set reload flag
                                 
                                 	//CHANNEL 0 FX
001446 efcf                      	ldi r28, 0xFF
001447 9220 2845                 	sts pulse1_fx_0xy_sequence, zero
001449 9220 2846                 	sts pulse1_fx_0xy_sequence+1, zero
00144b 9220 2847                 	sts pulse1_fx_1xx, zero
00144d 9220 2848                 	sts pulse1_fx_1xx+1, zero
00144f 9220 2849                 	sts pulse1_fx_1xx_total, zero
001451 9220 284a                 	sts pulse1_fx_1xx_total+1, zero
001453 9220 284b                 	sts pulse1_fx_2xx, zero
001455 9220 284c                 	sts pulse1_fx_2xx+1, zero
001457 9220 284d                 	sts pulse1_fx_2xx_total, zero
001459 9220 284e                 	sts pulse1_fx_2xx_total+1, zero
00145b 9220 284f                 	sts pulse1_fx_3xx_start, zero
00145d 9220 2850                 	sts pulse1_fx_3xx_start+1, zero
00145f 9220 2851                 	sts pulse1_fx_3xx_target, zero
001461 9220 2852                 	sts pulse1_fx_3xx_target+1, zero
001463 9220 2853                 	sts pulse1_fx_3xx_speed, zero
001465 9220 2854                 	sts pulse1_fx_3xx_speed+1, zero
001467 9220 2855                 	sts pulse1_fx_3xx_total_offset, zero
001469 9220 2856                 	sts pulse1_fx_3xx_total_offset+1, zero
00146b 9220 2857                 	sts pulse1_fx_4xy_speed, zero
00146d 9220 2858                 	sts pulse1_fx_4xy_depth, zero
00146f 9220 2859                 	sts pulse1_fx_4xy_phase, zero
001471 9220 285a                 	sts pulse1_fx_7xy_speed, zero
001473 9220 285b                 	sts pulse1_fx_7xy_depth, zero
001475 9220 285c                 	sts pulse1_fx_7xy_phase, zero
001477 9220 285d                 	sts pulse1_fx_7xy_value, zero
001479 9220 285e                 	sts pulse1_fx_Axy, zero
00147b 93c0 285f                 	sts pulse1_fx_Gxx_pre, r28
00147d 93c0 2860                 	sts pulse1_fx_Gxx_post, r28
00147f 9220 2861                 	sts pulse1_fx_Pxx_total, zero
001481 9220 2862                 	sts pulse1_fx_Pxx_total+1, zero
001483 9220 2863                 	sts pulse1_fx_Qxy_target, zero
001485 9220 2864                 	sts pulse1_fx_Qxy_target+1, zero
001487 9220 2865                 	sts pulse1_fx_Qxy_speed, zero
001489 9220 2866                 	sts pulse1_fx_Qxy_speed+1, zero
00148b 9220 2867                 	sts pulse1_fx_Qxy_total_offset, zero
00148d 9220 2868                 	sts pulse1_fx_Qxy_total_offset+1, zero
00148f 9220 2869                 	sts pulse1_fx_Rxy_target, zero
001491 9220 286a                 	sts pulse1_fx_Rxy_target+1, zero
001493 9220 286b                 	sts pulse1_fx_Rxy_speed, zero
001495 9220 286c                 	sts pulse1_fx_Rxy_speed+1, zero
001497 9220 286d                 	sts pulse1_fx_Rxy_total_offset, zero
001499 9220 286e                 	sts pulse1_fx_Rxy_total_offset+1, zero
00149b 93c0 286f                 	sts pulse1_fx_Sxx_pre, r28
00149d 93c0 2870                 	sts pulse1_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 1 instrument macros
00149f efcf                      	ldi r28, 0xFF
0014a0 9220 2879                 	sts pulse2_volume_macro_offset, zero
0014a2 93c0 287a                 	sts pulse2_volume_macro_loop, r28
0014a4 93c0 287b                 	sts pulse2_volume_macro_release, r28
0014a6 9220 287e                 	sts pulse2_arpeggio_macro_offset, zero
0014a8 93c0 287f                 	sts pulse2_arpeggio_macro_loop, r28
0014aa 93c0 2880                 	sts pulse2_arpeggio_macro_release, r28
0014ac 93c0 2881                 	sts pulse2_arpeggio_macro_mode, r28
0014ae 9220 2886                 	sts pulse2_pitch_macro_offset, zero
0014b0 93c0 2887                 	sts pulse2_pitch_macro_loop, r28
0014b2 93c0 2888                 	sts pulse2_pitch_macro_release, r28
0014b4 9220 288c                 	sts pulse2_hi_pitch_macro_offset, zero
0014b6 93c0 288d                 	sts pulse2_hi_pitch_macro_loop, r28
0014b8 93c0 288e                 	sts pulse2_hi_pitch_macro_release, r28
0014ba 9220 2891                 	sts pulse2_duty_macro_offset, zero
0014bc 93c0 2892                 	sts pulse2_duty_macro_loop, r28
0014be 93c0 2893                 	sts pulse2_duty_macro_release, r28
                                 
0014c0 9220 2877                 	sts pulse2_volume_macro, zero
0014c2 9220 2878                 	sts pulse2_volume_macro+1, zero
0014c4 9220 287c                 	sts pulse2_arpeggio_macro, zero
0014c6 9220 287d                 	sts pulse2_arpeggio_macro+1, zero
0014c8 9220 2882                 	sts pulse2_total_pitch_offset, zero
0014ca 9220 2883                 	sts pulse2_total_pitch_offset+1, zero
0014cc 9220 2884                 	sts pulse2_pitch_macro, zero
0014ce 9220 2885                 	sts pulse2_pitch_macro+1, zero
0014d0 9220 2889                 	sts pulse2_total_hi_pitch_offset, zero
0014d2 9220 288a                 	sts pulse2_hi_pitch_macro, zero
0014d4 9220 288b                 	sts pulse2_hi_pitch_macro+1, zero
0014d6 9220 288f                 	sts pulse2_duty_macro, zero
0014d8 9220 2890                 	sts pulse2_duty_macro+1, zero
                                 
                                 	//CHANNEL 1 ENVELOPE
0014da e02f                      	ldi pulse2_volume_divider, 0x0F
0014db 9130 2808                 	lds pulse2_volume_decay, pulse2_param
0014dd 703f                      	andi pulse2_volume_decay, 0x0F //mask for VVVV bits
0014de 91d0 2808                 	lds r29, pulse2_param
0014e0 73d0                      	andi r29, 0b00110000
0014e1 62d0                      	sbr r29, 0b0100000 //set start flag
0014e2 95d2                      	swap r29
0014e3 2b9d                      	or pulse_channel_flags, r29
0014e4 9220 280e                 	sts pulse2_output_volume, zero
0014e6 93c0 280d                 	sts pulse2_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 1 LENGTH
0014e8 2eec                      	mov pulse2_length_counter, r28
                                 
                                 	//CHANNEL 1 SEQUENCE
0014e9 e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
0014ea 2edc                      	mov pulse2_sequence, r28
                                 
                                 	//CHANNEL 1 SWEEP
0014eb 90f0 2809                 	lds pulse2_sweep, pulse2_sweep_param
0014ed 94f2                      	swap pulse2_sweep //swap data from high byte and low byte
0014ee 6098                      	sbr pulse_channel_flags, 0b00001000 //set reload flag
                                 
                                 	//CHANNEL 1 FX
0014ef efcf                      	ldi r28, 0xFF
0014f0 9220 2894                 	sts pulse2_fx_0xy_sequence, zero
0014f2 9220 2895                 	sts pulse2_fx_0xy_sequence+1, zero
0014f4 9220 2896                 	sts pulse2_fx_1xx, zero
0014f6 9220 2897                 	sts pulse2_fx_1xx+1, zero
0014f8 9220 2898                 	sts pulse2_fx_1xx_total, zero
0014fa 9220 2899                 	sts pulse2_fx_1xx_total+1, zero
0014fc 9220 289a                 	sts pulse2_fx_2xx, zero
0014fe 9220 289b                 	sts pulse2_fx_2xx+1, zero
001500 9220 289c                 	sts pulse2_fx_2xx_total, zero
001502 9220 289d                 	sts pulse2_fx_2xx_total+1, zero
001504 9220 289e                 	sts pulse2_fx_3xx_start, zero
001506 9220 289f                 	sts pulse2_fx_3xx_start+1, zero
001508 9220 28a0                 	sts pulse2_fx_3xx_target, zero
00150a 9220 28a1                 	sts pulse2_fx_3xx_target+1, zero
00150c 9220 28a2                 	sts pulse2_fx_3xx_speed, zero
00150e 9220 28a3                 	sts pulse2_fx_3xx_speed+1, zero
001510 9220 28a4                 	sts pulse2_fx_3xx_total_offset, zero
001512 9220 28a5                 	sts pulse2_fx_3xx_total_offset+1, zero
001514 9220 28a6                 	sts pulse2_fx_4xy_speed, zero
001516 9220 28a7                 	sts pulse2_fx_4xy_depth, zero
001518 9220 28a8                 	sts pulse2_fx_4xy_phase, zero
00151a 9220 28a9                 	sts pulse2_fx_7xy_speed, zero
00151c 9220 28aa                 	sts pulse2_fx_7xy_depth, zero
00151e 9220 28ab                 	sts pulse2_fx_7xy_phase, zero
001520 9220 28ac                 	sts pulse2_fx_7xy_value, zero
001522 9220 28ad                 	sts pulse2_fx_Axy, zero
001524 93c0 28ae                 	sts pulse2_fx_Gxx_pre, r28
001526 93c0 28af                 	sts pulse2_fx_Gxx_post, r28
001528 9220 28b0                 	sts pulse2_fx_Pxx_total, zero
00152a 9220 28b1                 	sts pulse2_fx_Pxx_total+1, zero
00152c 9220 28b2                 	sts pulse2_fx_Qxy_target, zero
00152e 9220 28b3                 	sts pulse2_fx_Qxy_target+1, zero
001530 9220 28b4                 	sts pulse2_fx_Qxy_speed, zero
001532 9220 28b5                 	sts pulse2_fx_Qxy_speed+1, zero
001534 9220 28b6                 	sts pulse2_fx_Qxy_total_offset, zero
001536 9220 28b7                 	sts pulse2_fx_Qxy_total_offset+1, zero
001538 9220 28b8                 	sts pulse2_fx_Rxy_target, zero
00153a 9220 28b9                 	sts pulse2_fx_Rxy_target+1, zero
00153c 9220 28ba                 	sts pulse2_fx_Rxy_speed, zero
00153e 9220 28bb                 	sts pulse2_fx_Rxy_speed+1, zero
001540 9220 28bc                 	sts pulse2_fx_Rxy_total_offset, zero
001542 9220 28bd                 	sts pulse2_fx_Rxy_total_offset+1, zero
001544 93c0 28be                 	sts pulse2_fx_Sxx_pre, r28
001546 93c0 28bf                 	sts pulse2_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 2 instrument macros
001548 efcf                      	ldi r28, 0xFF
001549 9220 28c8                 	sts triangle_volume_macro_offset, zero
00154b 93c0 28c9                 	sts triangle_volume_macro_loop, r28
00154d 93c0 28ca                 	sts triangle_volume_macro_release, r28
00154f 9220 28cd                 	sts triangle_arpeggio_macro_offset, zero
001551 93c0 28ce                 	sts triangle_arpeggio_macro_loop, r28
001553 93c0 28cf                 	sts triangle_arpeggio_macro_release, r28
001555 93c0 28d0                 	sts triangle_arpeggio_macro_mode, r28
001557 9220 28d5                 	sts triangle_pitch_macro_offset, zero
001559 93c0 28d6                 	sts triangle_pitch_macro_loop, r28
00155b 93c0 28d7                 	sts triangle_pitch_macro_release, r28
00155d 9220 28db                 	sts triangle_hi_pitch_macro_offset, zero
00155f 93c0 28dc                 	sts triangle_hi_pitch_macro_loop, r28
001561 93c0 28dd                 	sts triangle_hi_pitch_macro_release, r28
001563 9220 28e0                 	sts triangle_duty_macro_offset, zero
001565 93c0 28e1                 	sts triangle_duty_macro_loop, r28
001567 93c0 28e2                 	sts triangle_duty_macro_release, r28
                                 
001569 9220 28c6                 	sts triangle_volume_macro, zero
00156b 9220 28c7                 	sts triangle_volume_macro+1, zero
00156d 9220 28cb                 	sts triangle_arpeggio_macro, zero
00156f 9220 28cc                 	sts triangle_arpeggio_macro+1, zero
001571 9220 28d1                 	sts triangle_total_pitch_offset, zero
001573 9220 28d2                 	sts triangle_total_pitch_offset+1, zero
001575 9220 28d3                 	sts triangle_pitch_macro, zero
001577 9220 28d4                 	sts triangle_pitch_macro+1, zero
001579 9220 28d8                 	sts triangle_total_hi_pitch_offset, zero
00157b 9220 28d9                 	sts triangle_hi_pitch_macro, zero
00157d 9220 28da                 	sts triangle_hi_pitch_macro+1, zero
00157f 9220 28de                 	sts triangle_duty_macro, zero
001581 9220 28df                 	sts triangle_duty_macro+1, zero
                                 
                                 	//CHANNEL 2 SEQUENCE
001583 e0c0                      	ldi r28, 0b00000000 //reset sequence to 0
001584 2f4c                      	mov triangle_sequence, r28
                                 
                                 	//CHANNEL 2 FX
001585 efcf                      	ldi r28, 0xFF
001586 9220 28e3                 	sts triangle_fx_0xy_sequence, zero
001588 9220 28e4                 	sts triangle_fx_0xy_sequence+1, zero
00158a 9220 28e5                 	sts triangle_fx_1xx, zero
00158c 9220 28e6                 	sts triangle_fx_1xx+1, zero
00158e 9220 28e7                 	sts triangle_fx_1xx_total, zero
001590 9220 28e8                 	sts triangle_fx_1xx_total+1, zero
001592 9220 28e9                 	sts triangle_fx_2xx, zero
001594 9220 28ea                 	sts triangle_fx_2xx+1, zero
001596 9220 28eb                 	sts triangle_fx_2xx_total, zero
001598 9220 28ec                 	sts triangle_fx_2xx_total+1, zero
00159a 9220 28ed                 	sts triangle_fx_3xx_start, zero
00159c 9220 28ee                 	sts triangle_fx_3xx_start+1, zero
00159e 9220 28ef                 	sts triangle_fx_3xx_target, zero
0015a0 9220 28f0                 	sts triangle_fx_3xx_target+1, zero
0015a2 9220 28f1                 	sts triangle_fx_3xx_speed, zero
0015a4 9220 28f2                 	sts triangle_fx_3xx_speed+1, zero
0015a6 9220 28f3                 	sts triangle_fx_3xx_total_offset, zero
0015a8 9220 28f4                 	sts triangle_fx_3xx_total_offset+1, zero
0015aa 9220 28f5                 	sts triangle_fx_4xy_speed, zero
0015ac 9220 28f6                 	sts triangle_fx_4xy_depth, zero
0015ae 9220 28f7                 	sts triangle_fx_4xy_phase, zero
0015b0 93c0 28f8                 	sts triangle_fx_Gxx_pre, r28
0015b2 93c0 28f9                 	sts triangle_fx_Gxx_post, r28
0015b4 9220 28fa                 	sts triangle_fx_Pxx_total, zero
0015b6 9220 28fb                 	sts triangle_fx_Pxx_total+1, zero
0015b8 9220 28fc                 	sts triangle_fx_Qxy_target, zero
0015ba 9220 28fd                 	sts triangle_fx_Qxy_target+1, zero
0015bc 9220 28fe                 	sts triangle_fx_Qxy_speed, zero
0015be 9220 28ff                 	sts triangle_fx_Qxy_speed+1, zero
0015c0 9220 2900                 	sts triangle_fx_Qxy_total_offset, zero
0015c2 9220 2901                 	sts triangle_fx_Qxy_total_offset+1, zero
0015c4 9220 2902                 	sts triangle_fx_Rxy_target, zero
0015c6 9220 2903                 	sts triangle_fx_Rxy_target+1, zero
0015c8 9220 2904                 	sts triangle_fx_Rxy_speed, zero
0015ca 9220 2905                 	sts triangle_fx_Rxy_speed+1, zero
0015cc 9220 2906                 	sts triangle_fx_Rxy_total_offset, zero
0015ce 9220 2907                 	sts triangle_fx_Rxy_total_offset+1, zero
0015d0 93c0 2908                 	sts triangle_fx_Sxx_pre, r28
0015d2 93c0 2909                 	sts triangle_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 3 instrument macros
0015d4 efcf                      	ldi r28, 0xFF
0015d5 9220 2912                 	sts noise_volume_macro_offset, zero
0015d7 93c0 2913                 	sts noise_volume_macro_loop, r28
0015d9 93c0 2914                 	sts noise_volume_macro_release, r28
0015db 9220 2917                 	sts noise_arpeggio_macro_offset, zero
0015dd 93c0 2918                 	sts noise_arpeggio_macro_loop, r28
0015df 93c0 2919                 	sts noise_arpeggio_macro_release, r28
0015e1 93c0 291a                 	sts noise_arpeggio_macro_mode, r28
0015e3 9220 291f                 	sts noise_pitch_macro_offset, zero
0015e5 93c0 2920                 	sts noise_pitch_macro_loop, r28
0015e7 93c0 2921                 	sts noise_pitch_macro_release, r28
0015e9 9220 2925                 	sts noise_hi_pitch_macro_offset, zero
0015eb 93c0 2926                 	sts noise_hi_pitch_macro_loop, r28
0015ed 93c0 2927                 	sts noise_hi_pitch_macro_release, r28
0015ef 9220 292a                 	sts noise_duty_macro_offset, zero
0015f1 93c0 292b                 	sts noise_duty_macro_loop, r28
0015f3 93c0 292c                 	sts noise_duty_macro_release, r28
                                 
0015f5 9220 2910                 	sts noise_volume_macro, zero
0015f7 9220 2911                 	sts noise_volume_macro+1, zero
0015f9 9220 2915                 	sts noise_arpeggio_macro, zero
0015fb 9220 2916                 	sts noise_arpeggio_macro+1, zero
0015fd 9220 291b                 	sts noise_total_pitch_offset, zero
0015ff 9220 291c                 	sts noise_total_pitch_offset+1, zero
001601 9220 291d                 	sts noise_pitch_macro, zero
001603 9220 291e                 	sts noise_pitch_macro+1, zero
001605 9220 2922                 	sts noise_total_hi_pitch_offset, zero
001607 9220 2923                 	sts noise_hi_pitch_macro, zero
001609 9220 2924                 	sts noise_hi_pitch_macro+1, zero
00160b 9220 2928                 	sts noise_duty_macro, zero
00160d 9220 2929                 	sts noise_duty_macro+1, zero
                                 
                                 	//CHANNEL 3 VOLUME
00160f 9220 2816                 	sts noise_output_volume, zero
001611 93c0 2815                 	sts noise_fractional_volume, r28 //initialize fractional volume to max value
                                 
                                 	//CHANNEL 3 SEQUENCE
001613 e0c1                      	ldi r28, 0b00000001 //noise sequence is reset to 0x0001
001614 2f5c                      	mov noise_sequence_LOW, r28
001615 2d62                      	mov noise_sequence_HIGH, zero
                                 
                                 	//CHANNEL 3 FX
001616 efcf                      	ldi r28, 0xFF
001617 9220 292d                 	sts noise_fx_0xy_sequence, zero
001619 9220 292e                 	sts noise_fx_0xy_sequence+1, zero
00161b 9220 292f                 	sts noise_fx_1xx, zero
00161d 9220 2930                 	sts noise_fx_1xx+1, zero
00161f 9220 2931                 	sts noise_fx_1xx_total, zero
001621 9220 2932                 	sts noise_fx_1xx_total+1, zero
001623 9220 2933                 	sts noise_fx_2xx, zero
001625 9220 2934                 	sts noise_fx_2xx+1, zero
001627 9220 2935                 	sts noise_fx_2xx_total, zero
001629 9220 2936                 	sts noise_fx_2xx_total+1, zero
00162b 9220 2937                 	sts noise_fx_3xx_start, zero
00162d 9220 2938                 	sts noise_fx_3xx_start+1, zero
00162f 9220 2939                 	sts noise_fx_3xx_target, zero
001631 9220 293a                 	sts noise_fx_3xx_target+1, zero
001633 9220 293b                 	sts noise_fx_3xx_speed, zero
001635 9220 293c                 	sts noise_fx_3xx_speed+1, zero
001637 9220 293d                 	sts noise_fx_3xx_total_offset, zero
001639 9220 293e                 	sts noise_fx_3xx_total_offset+1, zero
00163b 9220 293f                 	sts noise_fx_4xy_speed, zero
00163d 9220 2940                 	sts noise_fx_4xy_depth, zero
00163f 9220 2941                 	sts noise_fx_4xy_phase, zero
001641 9220 2942                 	sts noise_fx_7xy_speed, zero
001643 9220 2943                 	sts noise_fx_7xy_depth, zero
001645 9220 2944                 	sts noise_fx_7xy_phase, zero
001647 9220 2945                 	sts noise_fx_7xy_value, zero
001649 9220 2946                 	sts noise_fx_Axy, zero
00164b 93c0 2947                 	sts noise_fx_Gxx_pre, r28
00164d 93c0 2948                 	sts noise_fx_Gxx_post, r28
00164f 9220 2949                 	sts noise_fx_Pxx_total, zero
001651 9220 294a                 	sts noise_fx_Pxx_total+1, zero
001653 9220 294b                 	sts noise_fx_Qxy_target, zero
001655 9220 294c                 	sts noise_fx_Qxy_target+1, zero
001657 9220 294d                 	sts noise_fx_Qxy_speed, zero
001659 9220 294e                 	sts noise_fx_Qxy_speed+1, zero
00165b 9220 294f                 	sts noise_fx_Qxy_total_offset, zero
00165d 9220 2950                 	sts noise_fx_Qxy_total_offset+1, zero
00165f 9220 2951                 	sts noise_fx_Rxy_target, zero
001661 9220 2952                 	sts noise_fx_Rxy_target+1, zero
001663 9220 2953                 	sts noise_fx_Rxy_speed, zero
001665 9220 2954                 	sts noise_fx_Rxy_speed+1, zero
001667 9220 2955                 	sts noise_fx_Rxy_total_offset, zero
001669 9220 2956                 	sts noise_fx_Rxy_total_offset+1, zero
00166b 93c0 2957                 	sts noise_fx_Sxx_pre, r28
00166d 93c0 2958                 	sts noise_fx_Sxx_post, r28
                                 
                                 	//PINS
00166f efcf                      	ldi r28, 0xFF
001670 b9c0                      	out VPORTA_DIR, r28 //set all pins in VPORTA to output
                                 
                                 	//TIMERS
                                 	//Frame Counter
                                 	//NOTE:The frame counter will be defaulted to NTSC mode (60 Hz, 120 Hz, 240 Hz)
                                 	//Each interrupt will be setup to interrupt every 240 Hz clock
                                 	//CMP0 = sequence 0, CMP1 = sequence 1, CMP2 = sequence 2, OVF = sequence 3/sound driver
                                 	//Sequence 3 will clock the sound driver every 60Hz, in which new audio data is read and written to the registers
                                 	//Timer period Calculation: (0.00416666666 * 20000000/64)-1 = 1301.08333125 = 0x0515
                                 	//The ATmega4809 is cofigured to run at 20000000 Hz
                                 	//0.00416666666 seconds is the period for 240 Hz
                                 	//The /64 comes from the prescaler divider used
001671 e7c0                      	ldi r28, TCA_SINGLE_CMP0EN_bm | TCA_SINGLE_CMP1EN_bm | TCA_SINGLE_CMP2EN_bm | TCA_SINGLE_WGMODE_NORMAL_gc //interrupt mode
001672 93c0 0a01                 	sts TCA0_SINGLE_CTRLB, r28
001674 e7c1                      	ldi r28, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP1_bm | TCA_SINGLE_CMP2_bm | TCA_SINGLE_OVF_bm //enable overflow and compare interrupts
001675 93c0 0a0a                 	sts TCA0_SINGLE_INTCTRL, r28
001677 e1c5                      	ldi r28, 0x15 //set the period for CMP0
001678 93c0 0a28                 	sts TCA0_SINGLE_CMP0, r28
00167a e0c5                      	ldi r28, 0x05
00167b 93c0 0a29                 	sts TCA0_SINGLE_CMP0 + 1, r28
00167d e2cb                      	ldi r28, 0x2B //set the period for CMP1
00167e 93c0 0a2a                 	sts TCA0_SINGLE_CMP1, r28
001680 e0ca                      	ldi r28, 0x0A
001681 93c0 0a2b                 	sts TCA0_SINGLE_CMP1 + 1, r28
001683 e4c1                      	ldi r28, 0x41 //set the period for CMP2
001684 93c0 0a2c                 	sts TCA0_SINGLE_CMP2, r28
001686 e0cf                      	ldi r28, 0x0F
001687 93c0 0a2d                 	sts TCA0_SINGLE_CMP2 + 1, r28
001689 e5c7                      	ldi r28, 0x57 //set the period for OVF
00168a 93c0 0a26                 	sts TCA0_SINGLE_PER, r28
00168c e1c4                      	ldi r28, 0x14
00168d 93c0 0a27                 	sts TCA0_SINGLE_PER + 1, r28
00168f e0cb                      	ldi r28, TCA_SINGLE_CLKSEL_DIV64_gc | TCA_SINGLE_ENABLE_bm //use prescale divider of 64 and enable timer
001690 93c0 0a00                 	sts TCA0_SINGLE_CTRLA, r28
                                 
                                 	//NOTE: Channel Timers are clocked (20/2)/(0.8948865) = 11.1746014718 times faster than the NES APU
                                 	//Because of this, we multiply all the NES timer values by 11.1746014718 beforehand
                                 	//Since we rotate the sequence when the timer goes from t-(t-1) to 0, instead of 0 to t like the NES, we add 1 to the NES timers before multiplying
                                 	//The ATmega4809 is configured to run at 20 MHz
                                 	//The /2 comes from the prescaler divider used
                                 	//0.8948865 MHz is the speed of the NTSC NES APU
                                 	//NOTE: This means that any offset to the pitch for the NES timers would be multiplied by 11.1746014718 aswell.
                                 	//Pulse 1
001692 e0c0                      	ldi r28, TCB_CNTMODE_INT_gc //interrupt mode
001693 93c0 0a81                 	sts TCB0_CTRLB, r28
001695 e0c1                      	ldi r28, TCB_CAPT_bm //enable interrupts
001696 93c0 0a85                 	sts TCB0_INTCTRL, r28
001698 91c0 2802                 	lds r28, pulse1_timerL //load the LOW bits for timer
00169a 93c0 0a8c                 	sts TCB0_CCMPL, r28
00169c 91c0 2803                 	lds r28, pulse1_timerH //load the HIGH bits for timer
00169e 93c0 0a8d                 	sts TCB0_CCMPH, r28
0016a0 e0c3                      	ldi r28, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
0016a1 93c0 0a80                 	sts TCB0_CTRLA, r28
                                 
                                 	//PULSE 2
0016a3 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
0016a4 93b0 0a91                 	sts TCB1_CTRLB, r27
0016a6 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
0016a7 93b0 0a95                 	sts TCB1_INTCTRL, r27
0016a9 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
0016ab 93b0 0a9c                 	sts TCB1_CCMPL, r27
0016ad 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
0016af 93b0 0a9d                 	sts TCB1_CCMPH, r27
0016b1 e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
0016b2 93b0 0a90                 	sts TCB1_CTRLA, r27
                                 
                                 	//NOTE: The triangle timer is clocked at the same speed as the NES CPU, aka twice the NES APU.
                                 	//Therefore, we won't be using a /2 clock divider like we did with the pulse timers.
                                 	//TRIANGLE
0016b4 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
0016b5 93b0 0aa1                 	sts TCB2_CTRLB, r27
0016b7 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
                                 	//sts TCB2_INTCTRL, r27 //keep interrupts disabled to mute channel since triangle doesn't have volume bits
0016b8 91b0 2810                 	lds r27, triangle_timerL //load the LOW bits for timer
0016ba 93b0 0aac                 	sts TCB2_CCMPL, r27
0016bc 91b0 2811                 	lds r27, triangle_timerH //load the HIGH bits for timer
0016be 93b0 0aad                 	sts TCB2_CCMPH, r27
0016c0 e0b1                      	ldi r27, TCB_CLKSEL_CLKDIV1_gc | TCB_ENABLE_bm //use prescaler divider of 1 and enable timer
0016c1 93b0 0aa0                 	sts TCB2_CTRLA, r27
0016c3 9478                      	sei //global interrupt enable
                                 
                                 	//NOISE
0016c4 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
0016c5 93b0 0ab1                 	sts TCB3_CTRLB, r27
0016c7 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
0016c8 93b0 0ab5                 	sts TCB3_INTCTRL, r27
0016ca 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
0016cc 93b0 0abc                 	sts TCB3_CCMPL, r27
0016ce 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
0016d0 93b0 0abd                 	sts TCB3_CCMPH, r27
0016d2 e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
0016d3 93b0 0ab0                 	sts TCB3_CTRLA, r27
                                 
                                 
                                 
                                 //https://wiki.nesdev.com/w/index.php/APU_Mixer
                                 volume_mixer:
0016d5 91c0 2806                 	lds r28, pulse1_output_volume
0016d7 91d0 280e                 	lds r29, pulse2_output_volume
                                 
                                 volume_mixer_pulse1:
0016d9 fea0                      	sbrs pulse1_sequence, 0 //if the sequence output is zero, return
0016da c015                      	rjmp volume_mixer_pulse1_off
                                 
0016db 14b2                      	cp pulse1_length_counter, zero //if length is zero, return
0016dc f099                      	breq volume_mixer_pulse1_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
0016dd 91e0 0a8c                 	lds r30, TCB0_CCMPL
0016df e5f9                      	ldi r31, 0x059
0016e0 17ef                      	cp r30, r31
0016e1 91e0 0a8d                 	lds r30, TCB0_CCMPH
0016e3 e0f0                      	ldi r31, 0x00
0016e4 07ef                      	cpc r30, r31
0016e5 f050                      	brlo volume_mixer_pulse1_off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $5965
0016e6 91e0 0a8c                 	lds r30, TCB0_CCMPL
0016e8 e6f6                      	ldi r31, 0x66
0016e9 17ef                      	cp r30, r31
0016ea 91e0 0a8d                 	lds r30, TCB0_CCMPH
0016ec e5f9                      	ldi r31, 0x59
0016ed 07ef                      	cpc r30, r31
0016ee f408                      	brsh volume_mixer_pulse1_off
0016ef c001                      	rjmp volume_mixer_pulse2 //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse1_off:
0016f0 27cc                      	clr r28
                                 
                                 volume_mixer_pulse2:
0016f1 fed0                      	sbrs pulse2_sequence, 0 //if the sequence output is zero, return
0016f2 c015                      	rjmp volume_mixer_pulse2_off
                                 
0016f3 14e2                      	cp pulse2_length_counter, zero //if length is zero, return
0016f4 f099                      	breq volume_mixer_pulse2_off
                                 
0016f5 91e0 0a9c                 	lds r30, TCB1_CCMPL
0016f7 e5f9                      	ldi r31, 0x059
0016f8 17ef                      	cp r30, r31
0016f9 91e0 0a9d                 	lds r30, TCB1_CCMPH
0016fb e0f0                      	ldi r31, 0x00
0016fc 07ef                      	cpc r30, r31
0016fd f050                      	brlo volume_mixer_pulse2_off
                                 
0016fe 91e0 0a9c                 	lds r30, TCB1_CCMPL
001700 e6f6                      	ldi r31, 0x66
001701 17ef                      	cp r30, r31
001702 91e0 0a9d                 	lds r30, TCB1_CCMPH
001704 e5f9                      	ldi r31, 0x59
001705 07ef                      	cpc r30, r31
001706 f408                      	brsh volume_mixer_pulse2_off
001707 c001                      	rjmp volume_mixer_pulse_out //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse2_off:
001708 27dd                      	clr r29
                                 
                                 volume_mixer_pulse_out:
001709 0fcd                      	add r28, r29
00170a e6e2                      	ldi ZL, LOW(pulse_volume_table << 1)
00170b e0f2                      	ldi ZH, HIGH(pulse_volume_table << 1)
00170c 0fec                      	add ZL, r28
00170d 1df2                      	adc ZH, zero
00170e 91c4                      	lpm r28, Z
                                 
                                 volume_mixer_tnd_triangle:
00170f 2fd4                      	mov r29, triangle_sequence
001710 fdd4                      	sbrc r29, 4 //check 5th bit
001711 95d0                      	com r29
001712 70df                      	andi r29, 0x0F
001713 2fed                      	mov r30, r29
001714 0fde                      	add r29, r30 //multiply the triangle volume by 3
001715 0fde                      	add r29, r30
                                 
                                 volume_mixer_tnd_noise:
001716 ff50                      	sbrs noise_sequence_LOW, 0 //check 0th bit, skip if set
001717 c004                      	rjmp volume_mixer_tnd_out
001718 91e0 2816                 	lds r30, noise_output_volume
00171a 0fee                      	lsl r30 //multiply noise volume by 2
00171b 0fde                      	add r29, r30
                                 
                                 volume_mixer_tnd_out:
00171c e8e2                      	ldi ZL, LOW(tnd_volume_table << 1)
00171d e0f2                      	ldi ZH, HIGH(tnd_volume_table << 1)
00171e 0fed                      	add ZL, r29
00171f 1df2                      	adc ZH, zero
001720 91d4                      	lpm r29, Z
                                 
                                 volume_mixer_output:
001721 0fcd                      	add r28, r29
001722 b9c1                      	out VPORTA_OUT, r28
001723 cfb1                      	rjmp volume_mixer
                                 
                                 
                                 
                                 //FRAME COUNTER/AUDIO SAMPLE ISR
                                 sequence_0_2:
001724 b7bf                      	in r27, CPU_SREG
001725 93bf                      	push r27
001726 94f8                      	cli
                                 
                                 	//ENVELOPE
001727 d053                      	rcall pulse1_envelope_routine
001728 d09f                      	rcall pulse2_envelope_routine
                                 
001729 e5b0                      	ldi r27, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP2_bm //clear OVF flag
00172a 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
00172c 91bf                      	pop r27
00172d bfbf                      	out CPU_SREG, r27
00172e 9518                      	reti
                                 
                                 sequence_1_3:
00172f b7bf                      	in r27, CPU_SREG
001730 93bf                      	push r27
001731 94f8                      	cli
                                 
                                 	//ENVELOPE
001732 d048                      	rcall pulse1_envelope_routine
001733 d094                      	rcall pulse2_envelope_routine
                                 
                                 	//SWEEP
001734 fcc3                      	sbrc pulse1_sweep, 3 //check if the sweep enable bit is cleared
001735 d01b                      	rcall pulse1_sweep_routine
001736 fcf3                      	sbrc pulse2_sweep, 3
001737 d066                      	rcall pulse2_sweep_routine
                                 
                                 	//LENGTH
                                 	//NOTE: The length routine is relatively simple, so we will not be using clocks to rjmp and ret to a seperate lable
                                 sequence_1_3_pulse1_length:
001738 fd95                      	sbrc pulse_channel_flags, 5 //check if the length counter halt bit is cleared
001739 c002                      	rjmp sequence_1_3_pulse2_length
00173a 10b2                      	cpse pulse1_length_counter, zero //if length counter is already 0, don't decrement
00173b 94ba                      	dec pulse1_length_counter
                                 sequence_1_3_pulse2_length:
00173c fd91                      	sbrc pulse_channel_flags, 1 //check if the length counter halt bit is cleared
00173d c002                      	rjmp sequence_1_3_exit
00173e 10e2                      	cpse pulse2_length_counter, zero //if length counter is already 0, don't decrement
00173f 94ea                      	dec pulse2_length_counter
                                 
                                 sequence_1_3_exit:
001740 e2b1                      	ldi r27, TCA_SINGLE_CMP1_bm | TCA_SINGLE_OVF_bm //clear OVF flag
001741 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
001743 91bf                      	pop r27
001744 bfbf                      	out CPU_SREG, r27
001745 9518                      	reti
                                 
                                 //PULSE 1 ROUTINES
                                 pulse1_sequence_routine:
001746 b7bf                      	in r27, CPU_SREG
001747 93bf                      	push r27
001748 94f8                      	cli
                                 
001749 0caa                      	lsl pulse1_sequence //shifts sequence to the left
00174a 1ca2                      	adc pulse1_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
00174b e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
00174c 93b0 0a86                 	sts TCB0_INTFLAGS, r27
00174e 91bf                      	pop r27
00174f bfbf                      	out CPU_SREG, r27
001750 9518                      	reti
                                 
                                 pulse1_sweep_routine:
001751 2dbc                      	mov r27, pulse1_sweep
001752 70b7                      	andi r27, 0x07 //mask for period divider bits
001753 f4f9                      	brne pulse1_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse1_sweep_routine_action: //if the divider is == 0, update the pulse timer period
001754 93df                      	push r29
001755 2ddc                      	mov r29, pulse1_sweep
001756 95d2                      	swap r29
001757 70d7                      	andi r29, 0x07 //mask for shift bits
001758 f411                      	brne pulse1_sweep_routine_action_main //shift != 0
001759 91df                      	pop r29
00175a c019                      	rjmp pulse1_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse1_sweep_routine_action_main:
00175b 91a0 0a8c                 	lds r26, TCB0_CCMPL
00175d 91b0 0a8d                 	lds r27, TCB0_CCMPH
                                 pulse1_sweep_routine_action_main_loop:
00175f 95b6                      	lsr r27
001760 95a7                      	ror r26
001761 95da                      	dec r29
001762 f7e1                      	brne pulse1_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
001763 fec7                      	sbrs pulse1_sweep, 7 //check the negate flag
001764 c002                      	rjmp pulse1_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
001765 95a0                      	com r26 //pulse1 uses one's complement if the negate flag is set
001766 95b0                      	com r27
                                 
                                 pulse1_sweep_routine_action_main_add:
001767 91d0 0a8c                 	lds r29, TCB0_CCMPL //perform addition to get new timer period
001769 0fad                      	add r26, r29
00176a 91d0 0a8d                 	lds r29, TCB0_CCMPH
00176c 1fbd                      	adc r27, r29
                                 
00176d 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new LOW bits for timer
00176f 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new HIGH bits for timer
                                 	
001771 91df                      	pop r29
001772 c001                      	rjmp pulse1_sweep_routine_check_reload
                                 
                                 pulse1_sweep_routine_decrement_divider:
001773 94ca                      	dec pulse1_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse1_sweep_routine_check_reload:
001774 ff97                      	sbrs pulse_channel_flags, 7 //if the reload flag is set, reload the sweep divider
001775 9508                      	ret
                                 
                                 pulse1_sweep_reload:
001776 90c0 2801                 	lds pulse1_sweep, pulse1_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
001778 94c2                      	swap pulse1_sweep //bring data from high byte to low byte
001779 779f                      	cbr pulse_channel_flags, 0b10000000 //clear reload flag
00177a 9508                      	ret
                                 
                                 
                                 
                                 pulse1_envelope_routine:
00177b fd96                      	sbrc pulse_channel_flags, 6 //check if start flag is cleared
00177c c010                      	rjmp pulse1_envelope_routine_clear_start
                                 
00177d 3000                      	cpi pulse1_volume_divider, 0x00 //check if the divider is 0
00177e f011                      	breq PC+3 //if the divider == 0, check loop flag
00177f 950a                      	dec pulse1_volume_divider //if the divider != 0, decrement and return
001780 9508                      	ret
                                 
001781 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the divider == 0, reset the divider period
001783 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
001784 ff95                      	sbrs pulse_channel_flags, 5 //check if the loop flag is set
001785 c002                      	rjmp pulse1_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
001786 e01f                      	ldi pulse1_volume_decay, 0x0F //if the loop flag is set, reset decay and return
001787 9508                      	ret
                                 
                                 pulse1_envelope_routine_decrement_decay:
001788 3010                      	cpi pulse1_volume_decay, 0x00 //check if the decay is 0
001789 f409                      	brne PC+2 //if decay != 0, go decrement
00178a 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
00178b 951a                      	dec pulse1_volume_decay
00178c 9508                      	ret
                                 
                                 pulse1_envelope_routine_clear_start:
00178d 7b9f                      	cbr pulse_channel_flags, 0b01000000 //if the start flag is set, clear it
00178e 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the start flag is set, reset the divider period
001790 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
001791 e01f                      	ldi pulse1_volume_decay, 0x0F //if the start flag is set, reset decay
001792 9508                      	ret
                                 
                                 //PULSE 2 ROUTINES
                                 pulse2_sequence_routine:
001793 b7bf                      	in r27, CPU_SREG
001794 93bf                      	push r27
001795 94f8                      	cli
                                 
001796 0cdd                      	lsl pulse2_sequence //shifts sequence to the left
001797 1cd2                      	adc pulse2_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
001798 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
001799 93b0 0a96                 	sts TCB1_INTFLAGS, r27
00179b 91bf                      	pop r27
00179c bfbf                      	out CPU_SREG, r27
00179d 9518                      	reti
                                 
                                 pulse2_sweep_routine:
00179e 2dbf                      	mov r27, pulse2_sweep
00179f 70b7                      	andi r27, 0x07 //mask for period divider bits
0017a0 f4f9                      	brne pulse2_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse2_sweep_routine_action: //if the divider is == 0, update the pulse timer period
0017a1 93df                      	push r29
0017a2 2ddf                      	mov r29, pulse2_sweep
0017a3 95d2                      	swap r29
0017a4 70d7                      	andi r29, 0x07 //mask for shift bits
0017a5 f411                      	brne pulse2_sweep_routine_action_main //shift != 0
0017a6 91df                      	pop r29
0017a7 c019                      	rjmp pulse2_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse2_sweep_routine_action_main:
0017a8 91a0 0a9c                 	lds r26, TCB1_CCMPL
0017aa 91b0 0a9d                 	lds r27, TCB1_CCMPH
                                 pulse2_sweep_routine_action_main_loop:
0017ac 95b6                      	lsr r27
0017ad 95a7                      	ror r26
0017ae 95da                      	dec r29
0017af f7e1                      	brne pulse2_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
0017b0 fef7                      	sbrs pulse2_sweep, 7 //check the negate flag
0017b1 c002                      	rjmp pulse2_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
0017b2 95a0                      	com r26 //pulse2 uses one's complement if the negate flag is set
0017b3 95b0                      	com r27
                                 
                                 pulse2_sweep_routine_action_main_add:
0017b4 91d0 0a9c                 	lds r29, TCB1_CCMPL //perform addition to get new timer period
0017b6 0fad                      	add r26, r29
0017b7 91d0 0a9d                 	lds r29, TCB1_CCMPH
0017b9 1fbd                      	adc r27, r29
                                 
0017ba 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new LOW bits for timer
0017bc 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new HIGH bits for timer
                                 	
0017be 91df                      	pop r29
0017bf c001                      	rjmp pulse2_sweep_routine_check_reload
                                 
                                 pulse2_sweep_routine_decrement_divider:
0017c0 94fa                      	dec pulse2_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse2_sweep_routine_check_reload:
0017c1 ff93                      	sbrs pulse_channel_flags, 3 //if the reload flag is set, reload the sweep divider
0017c2 9508                      	ret
                                 
                                 pulse2_sweep_reload:
0017c3 90f0 2809                 	lds pulse2_sweep, pulse2_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
0017c5 94f2                      	swap pulse2_sweep //bring data from high byte to low byte
0017c6 7f97                      	cbr pulse_channel_flags, 0b00001000 //clear reload flag
0017c7 9508                      	ret
                                 
                                 
                                 
                                 pulse2_envelope_routine:
0017c8 fd92                      	sbrc pulse_channel_flags, 2 //check if start flag is cleared
0017c9 c010                      	rjmp pulse2_envelope_routine_clear_start
                                 
0017ca 3020                      	cpi pulse2_volume_divider, 0x00 //check if the divider is 0
0017cb f011                      	breq PC+3 //if the divider == 0, check loop flag
0017cc 952a                      	dec pulse2_volume_divider //if the divider != 0, decrement and return
0017cd 9508                      	ret
                                 
0017ce 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the divider == 0, reset the divider period
0017d0 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
0017d1 ff91                      	sbrs pulse_channel_flags, 1 //check if the loop flag is set
0017d2 c002                      	rjmp pulse2_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
0017d3 e03f                      	ldi pulse2_volume_decay, 0x0F //if the loop flag is set, reset decay and return
0017d4 9508                      	ret
                                 
                                 pulse2_envelope_routine_decrement_decay:
0017d5 3030                      	cpi pulse2_volume_decay, 0x00 //check if the decay is 0
0017d6 f409                      	brne PC+2 //if decay != 0, go decrement
0017d7 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
0017d8 953a                      	dec pulse2_volume_decay
0017d9 9508                      	ret
                                 
                                 pulse2_envelope_routine_clear_start:
0017da 7f9b                      	cbr pulse_channel_flags, 0b00000100 //if the start flag is set, clear it
0017db 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the start flag is set, reset the divider period
0017dd 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
0017de e03f                      	ldi pulse2_volume_decay, 0x0F //if the start flag is set, reset decay
0017df 9508                      	ret
                                 
                                 //TRIANGLE ROUTINES
                                 triangle_sequence_routine:
0017e0 b7bf                      	in r27, CPU_SREG
0017e1 93bf                      	push r27
0017e2 94f8                      	cli
                                 
0017e3 5f4f                      	subi triangle_sequence, -1 //increment sequence by 1
0017e4 714f                      	andi triangle_sequence, 0b00011111 //mask out bits 5, 6 and 7 NOTE: the sequence only needs bits 0-4.
                                 
0017e5 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
0017e6 93b0 0aa6                 	sts TCB2_INTFLAGS, r27
0017e8 91bf                      	pop r27
0017e9 bfbf                      	out CPU_SREG, r27
0017ea 9518                      	reti
                                 
                                 //NOISE ROUTINES
                                 noise_sequence_routine:
0017eb b7bf                      	in r27, CPU_SREG
0017ec 93bf                      	push r27
0017ed 94f8                      	cli
                                 
0017ee 2fa5                      	mov r26, noise_sequence_LOW
0017ef fd67                      	sbrc noise_sequence_HIGH, 7 //skip if MODE bit is clear
0017f0 c00b                      	rjmp noise_sequence_routine_mode_set
                                 
                                 noise_sequence_routine_mode_clear:
0017f1 95a6                      	lsr r26 //move the 1th bit to the 0th bit place
0017f2 27a5                      	eor r26, noise_sequence_LOW
0017f3 fda0                      	sbrc r26, 0 //skip if the EOR of bit 0 and 1 is clear
0017f4 c003                      	rjmp noise_sequence_routine_mode_clear_EOR_set
                                 
                                 noise_sequence_routine_mode_clear_EOR_clear:
0017f5 9566                      	lsr noise_sequence_HIGH
0017f6 9557                      	ror noise_sequence_LOW
0017f7 c013                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_clear_EOR_set:
0017f8 9566                      	lsr noise_sequence_HIGH
0017f9 9557                      	ror noise_sequence_LOW
0017fa 6460                      	ori noise_sequence_HIGH, 0b01000000 //set the 14th bit
0017fb c00f                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_set:
0017fc 0faa                      	lsl r26
0017fd 1faa                      	rol r26
0017fe 1faa                      	rol r26 //move the 6th bit to the 0th bit place
0017ff 27a5                      	eor r26, noise_sequence_LOW
001800 fda0                      	sbrc r26, 0 //skip if the EOR of bit 0 and 1 is clear
001801 c005                      	rjmp noise_sequence_routine_mode_set_EOR_set
                                 
                                 noise_sequence_routine_mode_set_EOR_clear:
001802 776f                      	cbr noise_sequence_HIGH, 0b10000000 //clear the MODE flag
001803 9566                      	lsr noise_sequence_HIGH
001804 9557                      	ror noise_sequence_LOW
001805 6860                      	sbr noise_sequence_HIGH, 0b10000000 //set the MODE flag
001806 c004                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_set_EOR_set:
001807 9566                      	lsr noise_sequence_HIGH
001808 9557                      	ror noise_sequence_LOW
001809 6860                      	sbr noise_sequence_HIGH, 0b10000000 //set the MODE flag
00180a c000                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_exit:
00180b e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
00180c 93b0 0ab6                 	sts TCB3_INTFLAGS, r27
00180e 91bf                      	pop r27
00180f bfbf                      	out CPU_SREG, r27
001810 9518                      	reti
                                 
                                 //CONVERTERS
                                 //converts and loads 5 bit length to corresponding 8 bit length value into r29
                                 length_converter:
001811 ede2                      	ldi ZL, LOW(length << 1)
001812 e6f4                      	ldi ZH, HIGH(length << 1)
001813 0fed                      	add ZL, r29
001814 1df2                      	adc ZH, zero
001815 91d4                      	lpm r29, Z
001816 9508                      	ret
                                 
                                 //loads pulse sequence into r29
                                 duty_cycle_sequences:
001817 efe2                      	ldi ZL, LOW(sequences << 1)
001818 e6f4                      	ldi ZH, HIGH(sequences << 1)
001819 0fed                      	add ZL, r29
00181a 1df2                      	adc ZH, zero
00181b 91d4                      	lpm r29, Z
00181c 9508                      	ret
                                 
                                 
                                 
                                 //SOUND DRIVER
                                 sound_driver:
00181d b7bf                      	in r27, CPU_SREG
00181e 93bf                      	push r27
00181f 94f8                      	cli
001820 93cf                      	push r28
001821 93df                      	push r29
001822 93ef                      	push r30
001823 93ff                      	push r31
                                 
                                 	//SOUND DRIVER
001824 91a0 281f                 	lds r26, song_fx_Bxx
001826 3faf                      	cpi r26, 0xFF //0xFF means that the flag is disabled
001827 f4a9                      	brne sound_driver_fx_Bxx_routine
001828 91a0 2820                 	lds r26, song_fx_Cxx
00182a 11a2                      	cpse r26, zero
00182b c08b                      	rjmp sound_driver_fx_Cxx_routine
00182c 91a0 2821                 	lds r26, song_fx_Dxx
00182e 11a2                      	cpse r26, zero
00182f c096                      	rjmp sound_driver_fx_Dxx_routine
                                 
001830 91a0 281a                 	lds r26, song_frame_offset
001832 91b0 281b                 	lds r27, song_frame_offset+1
001834 91c0 281c                 	lds r28, song_size
001836 91d0 281d                 	lds r29, song_size+1
001838 17ac                      	cp r26, r28
001839 07bd                      	cpc r27, r29
00183a f408                      	brsh sound_driver_fx_song_loop
00183b c101                      	rjmp sound_driver_channel0
                                 
                                 
                                 sound_driver_fx_song_loop:
00183c e0a0                      	ldi r26, 0x00
                                 sound_driver_fx_Bxx_routine:
00183d 91e0 2818                 	lds ZL, song_frames
00183f 91f0 2819                 	lds ZH, song_frames+1
001841 27cc                      	clr r28 //initialize r29:r28 to 0
001842 27dd                      	clr r29
001843 95a3                      	inc r26 //increment xx parameter by 1
                                 sound_driver_fx_Bxx_routine_loop:
001844 95aa                      	dec r26
001845 f011                      	breq sound_driver_fx_Bxx_routine_loop_exit //once r26 == 0, r29:r28 will hold Bxx*(5*2).
001846 962a                      	adiw r29:r28, 10 //increment the offset by 10 because 5 channels, and each address takes 2 bytes (5*2 = 10)
001847 cffc                      	rjmp sound_driver_fx_Bxx_routine_loop
                                 
                                 sound_driver_fx_Bxx_routine_loop_exit:
001848 9622                      	adiw r29:r28, 2 //add 2 to skip the first 2 bytes (first 2 bytes is the song size)
001849 93c0 281a                 	sts song_frame_offset, r28
00184b 93d0 281b                 	sts song_frame_offset+1, r29
00184d 0fec                      	add ZL, r28
00184e 1ffd                      	adc ZH, r29
                                 
00184f 91a5                      	lpm r26, Z+ //load the address of the frame(pattern)
001850 91b5                      	lpm r27, Z+
001851 0faa                      	lsl r26
001852 1fbb                      	rol r27
001853 93a0 2822                 	sts pulse1_pattern, r26
001855 93b0 2823                 	sts pulse1_pattern+1, r27
001857 91a5                      	lpm r26, Z+
001858 91b5                      	lpm r27, Z+
001859 0faa                      	lsl r26
00185a 1fbb                      	rol r27
00185b 93a0 2871                 	sts pulse2_pattern, r26
00185d 93b0 2872                 	sts pulse2_pattern+1, r27
00185f 91a5                      	lpm r26, Z+
001860 91b5                      	lpm r27, Z+
001861 0faa                      	lsl r26
001862 1fbb                      	rol r27
001863 93a0 28c0                 	sts triangle_pattern, r26
001865 93b0 28c1                 	sts triangle_pattern+1, r27
001867 91a5                      	lpm r26, Z+
001868 91b5                      	lpm r27, Z+
001869 0faa                      	lsl r26
00186a 1fbb                      	rol r27
00186b 93a0 290a                 	sts noise_pattern, r26
00186d 93b0 290b                 	sts noise_pattern+1, r27
                                 
00186f 9220 2826                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001871 9220 2827                 	sts pulse1_pattern_offset+1, zero
001873 9220 2824                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
001875 9220 2825                 	sts pulse1_pattern_delay_frames, zero
001877 9220 2875                 	sts pulse2_pattern_offset, zero
001879 9220 2876                 	sts pulse2_pattern_offset+1, zero
00187b 9220 2873                 	sts pulse2_pattern_delay_rows, zero
00187d 9220 2874                 	sts pulse2_pattern_delay_frames, zero
00187f 9220 28c4                 	sts triangle_pattern_offset, zero
001881 9220 28c5                 	sts triangle_pattern_offset+1, zero
001883 9220 28c2                 	sts triangle_pattern_delay_rows, zero
001885 9220 28c3                 	sts triangle_pattern_delay_frames, zero
001887 9220 290e                 	sts noise_pattern_offset, zero
001889 9220 290f                 	sts noise_pattern_offset+1, zero
00188b 9220 290c                 	sts noise_pattern_delay_rows, zero
00188d 9220 290d                 	sts noise_pattern_delay_frames, zero
                                 
00188f efaf                      	ldi r26, 0xFF
001890 93a0 285f                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
001892 93a0 2860                 	sts pulse1_fx_Gxx_post, r26
001894 93a0 286f                 	sts pulse1_fx_Sxx_pre, r26
001896 93a0 2870                 	sts pulse1_fx_Sxx_post, r26
001898 93a0 28ae                 	sts pulse2_fx_Gxx_pre, r26
00189a 93a0 28af                 	sts pulse2_fx_Gxx_post, r26
00189c 93a0 28be                 	sts pulse2_fx_Sxx_pre, r26
00189e 93a0 28bf                 	sts pulse2_fx_Sxx_post, r26
0018a0 93a0 28f8                 	sts triangle_fx_Gxx_pre, r26
0018a2 93a0 28f9                 	sts triangle_fx_Gxx_post, r26
0018a4 93a0 2908                 	sts triangle_fx_Sxx_pre, r26
0018a6 93a0 2909                 	sts triangle_fx_Sxx_post, r26
0018a8 93a0 2947                 	sts noise_fx_Gxx_pre, r26
0018aa 93a0 2948                 	sts noise_fx_Gxx_post, r26
0018ac 93a0 2957                 	sts noise_fx_Sxx_pre, r26
0018ae 93a0 2958                 	sts noise_fx_Sxx_post, r26
                                 
0018b0 93a0 281f                 	sts song_fx_Bxx, r26 //reset all song effects
0018b2 9220 2820                 	sts song_fx_Cxx, zero
0018b4 9220 2821                 	sts song_fx_Dxx, zero
0018b6 c086                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_fx_Cxx_routine:
0018b7 91ff                      	pop r31
0018b8 91ef                      	pop r30
0018b9 91df                      	pop r29
0018ba 91cf                      	pop r28
0018bb 91bf                      	pop r27
0018bc bfbf                      	out CPU_SREG, r27
0018bd 94f8                      	cli //disable global interrupts
                                 		
0018be efaf                      	ldi r26, 0xFF
0018bf 93a0 281f                 	sts song_fx_Bxx, r26 //reset all song effects
0018c1 9220 2820                 	sts song_fx_Cxx, zero
0018c3 9220 2821                 	sts song_fx_Dxx, zero
0018c5 9518                      	reti
                                 
                                 sound_driver_fx_Dxx_routine:
0018c6 91e0 2818                 	lds ZL, song_frames
0018c8 91f0 2819                 	lds ZH, song_frames+1
0018ca 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
0018cc 91b0 281b                 	lds r27, song_frame_offset+1
0018ce 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
0018cf 93a0 281a                 	sts song_frame_offset, r26
0018d1 93b0 281b                 	sts song_frame_offset+1, r27
0018d3 0fea                      	add ZL, r26
0018d4 1ffb                      	adc ZH, r27
                                 
0018d5 91a5                      	lpm r26, Z+ //load the address of the next pattern
0018d6 91b5                      	lpm r27, Z+
0018d7 0faa                      	lsl r26
0018d8 1fbb                      	rol r27
0018d9 93a0 2822                 	sts pulse1_pattern, r26
0018db 93b0 2823                 	sts pulse1_pattern+1, r27
0018dd 91a5                      	lpm r26, Z+
0018de 91b5                      	lpm r27, Z+
0018df 0faa                      	lsl r26
0018e0 1fbb                      	rol r27
0018e1 93a0 2871                 	sts pulse2_pattern, r26
0018e3 93b0 2872                 	sts pulse2_pattern+1, r27
0018e5 91a5                      	lpm r26, Z+
0018e6 91b5                      	lpm r27, Z+
0018e7 0faa                      	lsl r26
0018e8 1fbb                      	rol r27
0018e9 93a0 28c0                 	sts triangle_pattern, r26
0018eb 93b0 28c1                 	sts triangle_pattern+1, r27
0018ed 91a5                      	lpm r26, Z+
0018ee 91b5                      	lpm r27, Z+
0018ef 0faa                      	lsl r26
0018f0 1fbb                      	rol r27
0018f1 93a0 290a                 	sts noise_pattern, r26
0018f3 93b0 290b                 	sts noise_pattern+1, r27
                                 
0018f5 9220 2826                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
0018f7 9220 2827                 	sts pulse1_pattern_offset+1, zero
0018f9 9220 2824                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
0018fb 9220 2825                 	sts pulse1_pattern_delay_frames, zero
0018fd 9220 2875                 	sts pulse2_pattern_offset, zero
0018ff 9220 2876                 	sts pulse2_pattern_offset+1, zero
001901 9220 2873                 	sts pulse2_pattern_delay_rows, zero
001903 9220 2874                 	sts pulse2_pattern_delay_frames, zero
001905 9220 28c4                 	sts triangle_pattern_offset, zero
001907 9220 28c5                 	sts triangle_pattern_offset+1, zero
001909 9220 28c2                 	sts triangle_pattern_delay_rows, zero
00190b 9220 28c3                 	sts triangle_pattern_delay_frames, zero
00190d 9220 290e                 	sts noise_pattern_offset, zero
00190f 9220 290f                 	sts noise_pattern_offset+1, zero
001911 9220 290c                 	sts noise_pattern_delay_rows, zero
001913 9220 290d                 	sts noise_pattern_delay_frames, zero
                                 
001915 efaf                      	ldi r26, 0xFF
001916 93a0 285f                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
001918 93a0 2860                 	sts pulse1_fx_Gxx_post, r26
00191a 93a0 286f                 	sts pulse1_fx_Sxx_pre, r26
00191c 93a0 2870                 	sts pulse1_fx_Sxx_post, r26
00191e 93a0 28ae                 	sts pulse2_fx_Gxx_pre, r26
001920 93a0 28af                 	sts pulse2_fx_Gxx_post, r26
001922 93a0 28be                 	sts pulse2_fx_Sxx_pre, r26
001924 93a0 28bf                 	sts pulse2_fx_Sxx_post, r26
001926 93a0 28f8                 	sts triangle_fx_Gxx_pre, r26
001928 93a0 28f9                 	sts triangle_fx_Gxx_post, r26
00192a 93a0 2908                 	sts triangle_fx_Sxx_pre, r26
00192c 93a0 2909                 	sts triangle_fx_Sxx_post, r26
00192e 93a0 2947                 	sts noise_fx_Gxx_pre, r26
001930 93a0 2948                 	sts noise_fx_Gxx_post, r26
001932 93a0 2957                 	sts noise_fx_Sxx_pre, r26
001934 93a0 2958                 	sts noise_fx_Sxx_post, r26
                                 
001936 93a0 281f                 	sts song_fx_Bxx, r26 //reset all song effects
001938 9220 2820                 	sts song_fx_Cxx, zero
00193a 9220 2821                 	sts song_fx_Dxx, zero
00193c c000                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0:
00193d 91a0 2824                 	lds r26, pulse1_pattern_delay_rows
00193f 91b0 2825                 	lds r27, pulse1_pattern_delay_frames
001941 9610                      	adiw r27:r26, 0
001942 f009                      	breq sound_driver_channel0_main //if the pattern delay is 0, proceed with sound driver procedures
001943 c2e4                      	rjmp sound_driver_channel0_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel0_main:
001944 91e0 2822                 	lds ZL, pulse1_pattern //current pattern for pulse 1
001946 91f0 2823                 	lds ZH, pulse1_pattern+1
001948 91a0 2826                 	lds r26, pulse1_pattern_offset //current offset in the pattern for pulse 1
00194a 91b0 2827                 	lds r27, pulse1_pattern_offset+1
00194c 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
00194d 1ffb                      	adc ZH, r27
00194e 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel0_check_if_note: //check if data is a note (0x00 - 0x56)
00194f 35b7                      	cpi r27, 0x57
001950 f408                      	brsh sound_driver_channel0_check_if_volume
001951 c180                      	rjmp sound_driver_channel0_note
                                 sound_driver_channel0_check_if_volume: //check if data is volume (0x57-0x66)
001952 36b7                      	cpi r27, 0x67
001953 f408                      	brsh sound_driver_channel0_check_if_delay
001954 c1ba                      	rjmp sound_driver_channel0_volume
                                 sound_driver_channel0_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001955 3eb3                      	cpi r27, 0xE3
001956 f408                      	brsh sound_driver_channel0_check_if_instrument
001957 c1c1                      	rjmp sound_driver_channel0_delay
                                 sound_driver_channel0_check_if_instrument: //check for instrument flag (0xE3)
001958 f409                      	brne sound_driver_channel0_check_if_release
001959 c1c4                      	rjmp sound_driver_channel0_instrument_change 
                                 sound_driver_channel0_check_if_release: //check for note release flag (0xE4)
00195a 3eb4                      	cpi r27, 0xE4
00195b f409                      	brne sound_driver_channel0_check_if_end
00195c c26d                      	rjmp sound_driver_channel0_release
                                 sound_driver_channel0_check_if_end:
00195d 3fbf                      	cpi r27, 0xFF
00195e f409                      	brne sound_driver_channel0_check_if_fx
00195f c28f                      	rjmp sound_driver_channel0_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel0_check_if_fx: //fx flags (0xE5 - 0xFE)
001960 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001961 91a4                      	lpm r26, Z //load the fx data into r26
001962 d2bb                      	rcall sound_driver_channel0_increment_offset_twice
                                 
001963 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001964 efe6                      	ldi ZL, LOW(channel0_fx << 1) //load in note table
001965 e6f4                      	ldi ZH, HIGH(channel0_fx << 1)
001966 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001967 0feb                      	add ZL, r27 //add offset
001968 1df2                      	adc ZH, zero
001969 91c5                      	lpm r28, Z+ //load address bytes
00196a 91d4                      	lpm r29, Z
00196b 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
00196c 2ffd                      	mov ZH, r29
00196d 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel0_fx_0xy:
00196e 93a0 2845                 	sts pulse1_fx_0xy_sequence, r26
001970 9220 2846                 	sts pulse1_fx_0xy_sequence+1, zero
001972 cfd1                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel0_fx_1xx:
001973 9220 284b                 	sts pulse1_fx_2xx, zero //turn off any 2xx pitch slide down
001975 9220 284c                 	sts pulse1_fx_2xx+1, zero
001977 9220 2845                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
001979 9220 2846                 	sts pulse1_fx_0xy_sequence+1, zero
00197b 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00197c 937f                      	push r23
00197d 2f6a                      	mov r22, r26 //store the rate into r22
00197e eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00197f 9f67                      	mul r22, r23
001980 917f                      	pop r23
001981 916f                      	pop r22
                                 
001982 9416                      	lsr r1 //shift out the fractional bits
001983 9407                      	ror r0
001984 9416                      	lsr r1
001985 9407                      	ror r0
001986 9416                      	lsr r1
001987 9407                      	ror r0
001988 9416                      	lsr r1
001989 9407                      	ror r0
00198a 9200 2847                 	sts pulse1_fx_1xx, r0
00198c 9210 2848                 	sts pulse1_fx_1xx+1, r1
00198e cfb5                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel0_fx_2xx:
00198f 9220 2847                 	sts pulse1_fx_1xx, zero //turn off any 1xx pitch slide down
001991 9220 2848                 	sts pulse1_fx_1xx+1, zero
001993 9220 2845                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
001995 9220 2846                 	sts pulse1_fx_0xy_sequence+1, zero
001997 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001998 937f                      	push r23
001999 2f6a                      	mov r22, r26 //store the rate into r22
00199a eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00199b 9f67                      	mul r22, r23
00199c 917f                      	pop r23
00199d 916f                      	pop r22
                                 
00199e 9416                      	lsr r1 //shift out the fractional bits
00199f 9407                      	ror r0
0019a0 9416                      	lsr r1
0019a1 9407                      	ror r0
0019a2 9416                      	lsr r1
0019a3 9407                      	ror r0
0019a4 9416                      	lsr r1
0019a5 9407                      	ror r0
0019a6 9200 284b                 	sts pulse1_fx_2xx, r0
0019a8 9210 284c                 	sts pulse1_fx_2xx+1, r1
0019aa cf99                      	rjmp sound_driver_channel0_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel0_fx_3xx:
0019ab 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0019ac 937f                      	push r23
0019ad 2f6a                      	mov r22, r26 //store the rate into r22
0019ae eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0019af 9f67                      	mul r22, r23
0019b0 917f                      	pop r23
0019b1 916f                      	pop r22
                                 
0019b2 9416                      	lsr r1 //shift out the fractional bits
0019b3 9407                      	ror r0
0019b4 9416                      	lsr r1
0019b5 9407                      	ror r0
0019b6 9416                      	lsr r1
0019b7 9407                      	ror r0
0019b8 9416                      	lsr r1
0019b9 9407                      	ror r0
0019ba 9200 2853                 	sts pulse1_fx_3xx_speed, r0
0019bc 9210 2854                 	sts pulse1_fx_3xx_speed+1, r1
                                 
0019be 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
0019bf c001                      	rjmp sound_driver_channel0_fx_3xx_enabled
0019c0 cf83                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_3xx_enabled:
0019c1 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
0019c3 91b0 0a8d                 	lds r27, TCB0_CCMPH
0019c5 93a0 284f                 	sts pulse1_fx_3xx_start, r26
0019c7 93b0 2850                 	sts pulse1_fx_3xx_start+1, r27
                                 
0019c9 9220 2855                 	sts pulse1_fx_3xx_total_offset, zero
0019cb 9220 2856                 	sts pulse1_fx_3xx_total_offset+1, zero
0019cd cf76                      	rjmp sound_driver_channel0_main
                                 
                                 //VIBRATO
                                 sound_driver_channel0_fx_4xy:
0019ce 2fba                      	mov r27, r26
0019cf 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
0019d0 95a2                      	swap r26
0019d1 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0019d2 93a0 2857                 	sts pulse1_fx_4xy_speed, r26
0019d4 93b0 2858                 	sts pulse1_fx_4xy_depth, r27
0019d6 9220 2859                 	sts pulse1_fx_4xy_phase, zero //reset the phase to 0
0019d8 cf6b                      	rjmp sound_driver_channel0_main
                                 
                                 //TREMELO
                                 sound_driver_channel0_fx_7xy:
0019d9 2fba                      	mov r27, r26
0019da 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
0019db 95a2                      	swap r26
0019dc 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0019dd 93a0 285a                 	sts pulse1_fx_7xy_speed, r26
0019df 93b0 285b                 	sts pulse1_fx_7xy_depth, r27
0019e1 9220 285c                 	sts pulse1_fx_7xy_phase, zero //reset the phase to 0
0019e3 9220 285d                 	sts pulse1_fx_7xy_value, zero //reset the tremelo value
0019e5 cf5e                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel0_fx_Axy:
0019e6 93a0 285e                 	sts pulse1_fx_Axy, r26
0019e8 cf5b                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel0_fx_Bxx:
0019e9 93a0 281f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
0019eb cf58                      	rjmp sound_driver_channel0_main
                                 
                                 //HALT
                                 sound_driver_channel0_fx_Cxx:
0019ec 93b0 2820                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
0019ee cf55                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel0_fx_Dxx:
0019ef 93b0 2821                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
0019f1 cf52                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME
                                 sound_driver_channel0_fx_Exx:
0019f2 91b0 2800                 	lds r27, pulse1_param
0019f4 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
0019f5 2bba                      	or r27, r26 //move new VVVV bits into pulse1_param
0019f6 93b0 2800                 	sts pulse1_param, r27
0019f8 6096                      	sbr pulse_channel_flags, 6
0019f9 cf4a                      	rjmp sound_driver_channel0_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel0_fx_Fxx:
0019fa 93a0 281e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
0019fc cf47                      	rjmp sound_driver_channel0_main
                                 
                                 //DELAY
                                 sound_driver_channel0_fx_Gxx:
0019fd 15a2                      	cp r26, zero
0019fe f051                      	breq sound_driver_channel0_fx_Gxx_invalid
0019ff 91b0 281e                 	lds r27, song_speed
001a01 17ab                      	cp r26, r27
001a02 f430                      	brsh sound_driver_channel0_fx_Gxx_invalid
001a03 93a0 285f                 	sts pulse1_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001a05 e0b1                      	ldi r27, 0x01
001a06 93b0 2824                 	sts pulse1_pattern_delay_rows, r27
001a08 c222                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Gxx_invalid:
001a09 cf3a                      	rjmp sound_driver_channel0_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel0_fx_Hxy: //hardware sweep up
001a0a cf39                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixy: //hardware sweep down
001a0b cf38                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Hxx: //FDS modulation depth
001a0c cf37                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixx: //FDS modulation speed
001a0d cf36                      	rjmp sound_driver_channel0_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel0_fx_Pxx:
001a0e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001a0f 937f                      	push r23
001a10 2f6a                      	mov r22, r26
001a11 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001a12 0367                      	mulsu r22, r23
001a13 917f                      	pop r23
001a14 916f                      	pop r22
001a15 9416                      	lsr r1 //shift out the fractional bits
001a16 9407                      	ror r0
001a17 9416                      	lsr r1
001a18 9407                      	ror r0
001a19 9416                      	lsr r1
001a1a 9407                      	ror r0
001a1b 9416                      	lsr r1
001a1c 9407                      	ror r0
001a1d fe13                      	sbrs r1, 3 //check if result was a negative number
001a1e c002                      	rjmp sound_driver_channel0_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel0_fx_Pxx_negative:
001a1f efb0                      	ldi r27, 0xF0
001a20 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel0_fx_Pxx_store:
001a21 9200 2861                 	sts pulse1_fx_Pxx_total, r0
001a23 9210 2862                 	sts pulse1_fx_Pxx_total+1, r1
001a25 cf1e                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel0_fx_Qxy:
                                 sound_driver_channel0_fx_Qxy_check_arpeggio_macro:
001a26 91e0 282d                 	lds ZL, pulse1_arpeggio_macro
001a28 91f0 282e                 	lds ZH, pulse1_arpeggio_macro+1
001a2a 9630                      	adiw Z, 0
001a2b f009                      	breq sound_driver_channel0_fx_Qxy_check_pitch_macro
001a2c cf17                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_pitch_macro:
001a2d 91e0 2835                 	lds ZL, pulse1_pitch_macro
001a2f 91f0 2836                 	lds ZH, pulse1_pitch_macro+1
001a31 9630                      	adiw Z, 0
001a32 f009                      	breq sound_driver_channel0_fx_Qxy_check_hi_pitch_macro
001a33 cf10                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_hi_pitch_macro:
001a34 91e0 283b                 	lds ZL, pulse1_hi_pitch_macro
001a36 91f0 283c                 	lds ZH, pulse1_hi_pitch_macro+1
001a38 9630                      	adiw Z, 0
001a39 f009                      	breq sound_driver_channel0_fx_Qxy_process
001a3a cf09                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_process:
001a3b 2fba                      	mov r27, r26 //copy fx parameters into r27
001a3c 70bf                      	andi r27, 0x0F //mask note index offset
001a3d 91c0 2807                 	lds r28, pulse1_note //load current note index
001a3f 0fbc                      	add r27, r28
001a40 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001a41 f008                      	brlo sound_driver_channel0_fx_Qxy_process_continue
001a42 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel0_fx_Qxy_process_continue:
001a43 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001a44 e0f0                      	ldi ZH, HIGH(note_table << 1)
001a45 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001a46 0feb                      	add ZL, r27 //add offset
001a47 1df2                      	adc ZH, zero
001a48 91c5                      	lpm r28, Z+ //load bytes
001a49 91d4                      	lpm r29, Z
001a4a 93c0 2863                 	sts pulse1_fx_Qxy_target, r28 //load the LOW bits for the target period
001a4c 93d0 2864                 	sts pulse1_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
001a4e 95a2                      	swap r26
001a4f 70af                      	andi r26, 0x0F //mask effect speed
001a50 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001a51 95a3                      	inc r26 //increment the speed by 1
                                 
001a52 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001a53 937f                      	push r23
001a54 2f6a                      	mov r22, r26 //store the speed data into r27
001a55 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001a56 9f67                      	mul r22, r23
001a57 917f                      	pop r23
001a58 916f                      	pop r22
                                 
001a59 9416                      	lsr r1 //shift out the fractional bits
001a5a 9407                      	ror r0
001a5b 9416                      	lsr r1
001a5c 9407                      	ror r0
001a5d 9416                      	lsr r1
001a5e 9407                      	ror r0
001a5f 9416                      	lsr r1
001a60 9407                      	ror r0
                                 
001a61 9200 2865                 	sts pulse1_fx_Qxy_speed, r0 //store the effect speed
001a63 9210 2866                 	sts pulse1_fx_Qxy_speed+1, r1
001a65 9220 2867                 	sts pulse1_fx_Qxy_total_offset, zero
001a67 9220 2868                 	sts pulse1_fx_Qxy_total_offset+1, zero
001a69 ceda                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel0_fx_Rxy:
                                 sound_driver_channel0_fx_Rxy_check_arpeggio_macro:
001a6a 91e0 282d                 	lds ZL, pulse1_arpeggio_macro
001a6c 91f0 282e                 	lds ZH, pulse1_arpeggio_macro+1
001a6e 9630                      	adiw Z, 0
001a6f f009                      	breq sound_driver_channel0_fx_Rxy_check_pitch_macro
001a70 ced3                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_pitch_macro:
001a71 91e0 2835                 	lds ZL, pulse1_pitch_macro
001a73 91f0 2836                 	lds ZH, pulse1_pitch_macro+1
001a75 9630                      	adiw Z, 0
001a76 f009                      	breq sound_driver_channel0_fx_Rxy_check_hi_pitch_macro
001a77 cecc                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_hi_pitch_macro:
001a78 91e0 283b                 	lds ZL, pulse1_hi_pitch_macro
001a7a 91f0 283c                 	lds ZH, pulse1_hi_pitch_macro+1
001a7c 9630                      	adiw Z, 0
001a7d f009                      	breq sound_driver_channel0_fx_Rxy_process
001a7e cec5                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_process:
001a7f 2fba                      	mov r27, r26 //copy fx parameters into r27
001a80 70bf                      	andi r27, 0x0F //mask note index offset
001a81 91c0 2807                 	lds r28, pulse1_note //load current note index
001a83 1bcb                      	sub r28, r27
001a84 f408                      	brcc sound_driver_channel0_fx_Rxy_process_continue
001a85 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel0_fx_Rxy_process_continue:
001a86 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001a87 e0f0                      	ldi ZH, HIGH(note_table << 1)
001a88 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001a89 0fec                      	add ZL, r28 //add offset
001a8a 1df2                      	adc ZH, zero
001a8b 91c5                      	lpm r28, Z+ //load bytes
001a8c 91d4                      	lpm r29, Z
001a8d 93c0 2869                 	sts pulse1_fx_Rxy_target, r28 //load the LOW bits for the target period
001a8f 93d0 286a                 	sts pulse1_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
001a91 95a2                      	swap r26
001a92 70af                      	andi r26, 0x0F //mask effect speed
001a93 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001a94 95a3                      	inc r26 //increment the speed by 1
                                 
001a95 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001a96 937f                      	push r23
001a97 2f6a                      	mov r22, r26 //store the speed data into r27
001a98 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001a99 9f67                      	mul r22, r23
001a9a 917f                      	pop r23
001a9b 916f                      	pop r22
                                 
001a9c 9416                      	lsr r1 //shift out the fractional bits
001a9d 9407                      	ror r0
001a9e 9416                      	lsr r1
001a9f 9407                      	ror r0
001aa0 9416                      	lsr r1
001aa1 9407                      	ror r0
001aa2 9416                      	lsr r1
001aa3 9407                      	ror r0
                                 
001aa4 9200 286b                 	sts pulse1_fx_Rxy_speed, r0 //store the effect speed
001aa6 9210 286c                 	sts pulse1_fx_Rxy_speed+1, r1
001aa8 9220 286d                 	sts pulse1_fx_Rxy_total_offset, zero
001aaa 9220 286e                 	sts pulse1_fx_Rxy_total_offset+1, zero
001aac ce97                      	rjmp sound_driver_channel0_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel0_fx_Sxx:
001aad 15a2                      	cp r26, zero
001aae f051                      	breq sound_driver_channel0_fx_Sxx_invalid
001aaf 91b0 281e                 	lds r27, song_speed
001ab1 17ab                      	cp r26, r27
001ab2 f430                      	brsh sound_driver_channel0_fx_Sxx_invalid
001ab3 93a0 286f                 	sts pulse1_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001ab5 e0b1                      	ldi r27, 0x01
001ab6 93b0 2824                 	sts pulse1_pattern_delay_rows, r27
001ab8 c172                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Sxx_invalid:
001ab9 ce8a                      	rjmp sound_driver_channel0_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel0_fx_Vxx:
001aba efe2                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
001abb e6f4                      	ldi ZH, HIGH(sequences << 1)
001abc 0fea                      	add ZL, r26 //offset the pointer
001abd 1df2                      	adc ZH, zero
                                 
001abe 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
001abf 95a7                      	ror r26
001ac0 95a7                      	ror r26
001ac1 91b0 2800                 	lds r27, pulse1_param //load r27 with pulse1_param (register $4000)
001ac3 2fcb                      	mov r28, r27 //store a copy of pulse1_param into r28
001ac4 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
001ac5 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
001ac6 c001                      	rjmp sound_driver_channel0_fx_Vxx_store
001ac7 ce7c                      	rjmp sound_driver_channel0_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel0_fx_Vxx_store:
001ac8 90a4                      	lpm pulse1_sequence, Z //store the sequence
                                 
001ac9 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
001aca 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
001acb 93c0 2800                 	sts pulse1_param, r28
001acd ce76                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_Wxx: //DPCM sample speed
001ace ce75                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Xxx: //DPCM sample retrigger
001acf ce74                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Yxx: //DPCM sample offset
001ad0 ce73                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Zxx: //DPCM sample delta counter
001ad1 ce72                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 sound_driver_channel0_note:
001ad2 93b0 2807                 	sts pulse1_note, r27 //store the note index
001ad4 e0a3                      	ldi r26, 0x03
001ad5 e0b2                      	ldi r27, 0x02
001ad6 93b0 282a                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
001ad8 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26
001ada 93b0 2837                 	sts pulse1_pitch_macro_offset, r27
001adc 93b0 283d                 	sts pulse1_hi_pitch_macro_offset, r27
001ade 93b0 2842                 	sts pulse1_duty_macro_offset, r27
001ae0 9220 2833                 	sts pulse1_total_pitch_offset, zero //reset the pitch and hi pitch offset
001ae2 9220 2834                 	sts pulse1_total_pitch_offset+1, zero
001ae4 9220 283a                 	sts pulse1_total_hi_pitch_offset, zero
001ae6 9220 2849                 	sts pulse1_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001ae8 9220 284a                 	sts pulse1_fx_1xx_total+1, zero
001aea 9220 284d                 	sts pulse1_fx_2xx_total, zero
001aec 9220 284e                 	sts pulse1_fx_2xx_total+1, zero
001aee 9220 2855                 	sts pulse1_fx_3xx_total_offset, zero //reset 3xx offset
001af0 9220 2856                 	sts pulse1_fx_3xx_total_offset+1, zero
001af2 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001af4 91b0 0a8d                 	lds r27, TCB0_CCMPH
001af6 93a0 284f                 	sts pulse1_fx_3xx_start, r26
001af8 93b0 2850                 	sts pulse1_fx_3xx_start+1, r27
001afa 9220 2801                 	sts pulse1_sweep_param, zero //reset any sweep effect
001afc 6097                      	sbr pulse_channel_flags, 7 //set reload flag
001afd 9220 2863                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001aff 9220 2864                 	sts pulse1_fx_Qxy_target+1, zero
001b01 9220 2867                 	sts pulse1_fx_Qxy_total_offset, zero
001b03 9220 2868                 	sts pulse1_fx_Qxy_total_offset+1, zero
001b05 9220 2869                 	sts pulse1_fx_Rxy_target, zero
001b07 9220 286a                 	sts pulse1_fx_Rxy_target+1, zero
001b09 9220 286d                 	sts pulse1_fx_Rxy_total_offset, zero
001b0b 9220 286e                 	sts pulse1_fx_Rxy_total_offset+1, zero
001b0d d106                      	rcall sound_driver_channel0_increment_offset
001b0e ce35                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_volume:
001b0f 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001b10 91a0 2800                 	lds r26, pulse1_param
001b12 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001b13 2bab                      	or r26, r27 //move new VVVV bits into pulse1_param
001b14 93a0 2800                 	sts pulse1_param, r26
001b16 6096                      	sbr pulse_channel_flags, 6
001b17 d0fc                      	rcall sound_driver_channel0_increment_offset
001b18 ce2b                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_delay:
001b19 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001b1a 93b0 2824                 	sts pulse1_pattern_delay_rows, r27
001b1c d0f7                      	rcall sound_driver_channel0_increment_offset
001b1d c10d                      	rjmp sound_driver_channel1
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change:
001b1e 9220 2828                 	sts pulse1_volume_macro, zero //reset all macro addresses
001b20 9220 2829                 	sts pulse1_volume_macro+1, zero
001b22 9220 282d                 	sts pulse1_arpeggio_macro, zero
001b24 9220 282e                 	sts pulse1_arpeggio_macro+1, zero
001b26 9220 2835                 	sts pulse1_pitch_macro, zero
001b28 9220 2836                 	sts pulse1_pitch_macro+1, zero
001b2a 9220 283b                 	sts pulse1_hi_pitch_macro, zero
001b2c 9220 283c                 	sts pulse1_hi_pitch_macro+1, zero
001b2e 9220 2840                 	sts pulse1_duty_macro, zero
001b30 9220 2841                 	sts pulse1_duty_macro+1, zero
001b32 9220 2833                 	sts pulse1_total_pitch_offset, zero //reset the pitch offset
001b34 9220 2834                 	sts pulse1_total_pitch_offset+1, zero
001b36 9220 283a                 	sts pulse1_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001b38 9631                      	adiw Z, 1 //point to the byte next to the flag
001b39 91b4                      	lpm r27, Z //store the instrument offset into r27
001b3a e8ec                      	ldi ZL, LOW(instruments) //point Z to instruments table
001b3b e1f2                      	ldi ZH, HIGH(instruments)
001b3c 0feb                      	add ZL, r27 //point Z to offsetted instrument
001b3d 1df2                      	adc ZH, zero
001b3e 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001b3f 1fff                      	rol ZH
001b40 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001b41 91b4                      	lpm r27, Z
                                 
001b42 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001b43 1fbb                      	rol r27
001b44 2fea                      	mov ZL, r26
001b45 2ffb                      	mov ZH, r27
001b46 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001b47 9632                      	adiw Z, 2 //point Z to the address of the macro
001b48 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel0_instrument_change_macro_loop:
001b49 95aa                      	dec r26
001b4a f019                      	breq sound_driver_channel0_instrument_change_exit
001b4b 95b6                      	lsr r27
001b4c f078                      	brcs sound_driver_channel0_instrument_change_load_macro
001b4d cffb                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_exit:
001b4e e0a3                      	ldi r26, 0x03
001b4f e0b2                      	ldi r27, 0x02
001b50 93b0 282a                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
001b52 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26
001b54 93b0 2837                 	sts pulse1_pitch_macro_offset, r27
001b56 93b0 283d                 	sts pulse1_hi_pitch_macro_offset, r27
001b58 93b0 2842                 	sts pulse1_duty_macro_offset, r27
001b5a d0c3                      	rcall sound_driver_channel0_increment_offset_twice
001b5b cde8                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_load_macro:
001b5c 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001b5d 91d5                      	lpm r29, Z+
                                 
001b5e 30a5                      	cpi r26, 5
001b5f f039                      	breq sound_driver_channel0_instrument_change_load_macro_volume
001b60 30a4                      	cpi r26, 4
001b61 f079                      	breq sound_driver_channel0_instrument_change_load_macro_arpeggio
001b62 30a3                      	cpi r26, 3
001b63 f0d9                      	breq sound_driver_channel0_instrument_change_load_macro_pitch
001b64 30a2                      	cpi r26, 2
001b65 f159                      	breq sound_driver_channel0_instrument_change_load_macro_hi_pitch
001b66 c03c                      	rjmp sound_driver_channel0_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel0_instrument_change_load_macro_volume:
001b67 93c0 2828                 	sts pulse1_volume_macro, r28
001b69 93d0 2829                 	sts pulse1_volume_macro+1, r29
001b6b d041                      	rcall sound_driver_channel0_instrument_change_read_header
001b6c 93c0 282c                 	sts pulse1_volume_macro_release, r28
001b6e 93d0 282b                 	sts pulse1_volume_macro_loop, r29
001b70 cfd8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 	
                                 sound_driver_channel0_instrument_change_load_macro_arpeggio:
001b71 93c0 282d                 	sts pulse1_arpeggio_macro, r28
001b73 93d0 282e                 	sts pulse1_arpeggio_macro+1, r29
001b75 9220 2863                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001b77 9220 2864                 	sts pulse1_fx_Qxy_target+1, zero
001b79 9220 2869                 	sts pulse1_fx_Rxy_target, zero
001b7b 9220 286a                 	sts pulse1_fx_Rxy_target+1, zero
001b7d d03a                      	rcall sound_driver_channel0_instrument_change_read_header_arpeggio
001b7e cfca                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_pitch:
001b7f 93c0 2835                 	sts pulse1_pitch_macro, r28
001b81 93d0 2836                 	sts pulse1_pitch_macro+1, r29
001b83 9220 2863                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001b85 9220 2864                 	sts pulse1_fx_Qxy_target+1, zero
001b87 9220 2869                 	sts pulse1_fx_Rxy_target, zero
001b89 9220 286a                 	sts pulse1_fx_Rxy_target+1, zero
001b8b d021                      	rcall sound_driver_channel0_instrument_change_read_header
001b8c 93c0 2839                 	sts pulse1_pitch_macro_release, r28
001b8e 93d0 2838                 	sts pulse1_pitch_macro_loop, r29
001b90 cfb8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_hi_pitch:
001b91 93c0 283b                 	sts pulse1_hi_pitch_macro, r28
001b93 93d0 283c                 	sts pulse1_hi_pitch_macro+1, r29
001b95 9220 2863                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001b97 9220 2864                 	sts pulse1_fx_Qxy_target+1, zero
001b99 9220 2869                 	sts pulse1_fx_Rxy_target, zero
001b9b 9220 286a                 	sts pulse1_fx_Rxy_target+1, zero
001b9d d00f                      	rcall sound_driver_channel0_instrument_change_read_header
001b9e 93c0 283f                 	sts pulse1_hi_pitch_macro_release, r28
001ba0 93d0 283e                 	sts pulse1_hi_pitch_macro_loop, r29
001ba2 cfa6                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_duty:
001ba3 93c0 2840                 	sts pulse1_duty_macro, r28
001ba5 93d0 2841                 	sts pulse1_duty_macro+1, r29
001ba7 d005                      	rcall sound_driver_channel0_instrument_change_read_header
001ba8 93c0 2844                 	sts pulse1_duty_macro_release, r28
001baa 93d0 2843                 	sts pulse1_duty_macro_loop, r29
001bac cf9c                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_read_header:
001bad 93ef                      	push ZL
001bae 93ff                      	push ZH
001baf 2fec                      	mov ZL, r28
001bb0 2ffd                      	mov ZH, r29
001bb1 0fee                      	lsl ZL
001bb2 1fff                      	rol ZH
001bb3 91c5                      	lpm r28, Z+
001bb4 91d4                      	lpm r29, Z
001bb5 91ff                      	pop ZH
001bb6 91ef                      	pop ZL
001bb7 9508                      	ret
                                 
                                 sound_driver_channel0_instrument_change_read_header_arpeggio:
001bb8 93ef                      	push ZL
001bb9 93ff                      	push ZH
001bba 2fec                      	mov ZL, r28
001bbb 2ffd                      	mov ZH, r29
001bbc 0fee                      	lsl ZL
001bbd 1fff                      	rol ZH
001bbe 91c5                      	lpm r28, Z+
001bbf 91d5                      	lpm r29, Z+
001bc0 93c0 2831                 	sts pulse1_arpeggio_macro_release, r28
001bc2 93d0 2830                 	sts pulse1_arpeggio_macro_loop, r29
001bc4 91c4                      	lpm r28, Z
001bc5 93c0 2832                 	sts pulse1_arpeggio_macro_mode, r28
001bc7 91ff                      	pop ZH
001bc8 91ef                      	pop ZL
001bc9 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel0_release:
                                 sound_driver_channel0_release_volume:
001bca 91b0 282c                 	lds r27, pulse1_volume_macro_release
001bcc 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001bcd f019                      	breq sound_driver_channel0_release_arpeggio //if the macro has no release flag, check the next macro
001bce 95b3                      	inc r27
001bcf 93b0 282a                 	sts pulse1_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel0_release_arpeggio:
001bd1 91b0 2831                 	lds r27, pulse1_arpeggio_macro_release
001bd3 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001bd4 f019                      	breq sound_driver_channel0_release_pitch
001bd5 95b3                      	inc r27
001bd6 93b0 282f                 	sts pulse1_arpeggio_macro_offset, r27
                                 sound_driver_channel0_release_pitch:
001bd8 91b0 2839                 	lds r27, pulse1_pitch_macro_release
001bda 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001bdb f019                      	breq sound_driver_channel0_release_hi_pitch
001bdc 95b3                      	inc r27
001bdd 93b0 2837                 	sts pulse1_pitch_macro_offset, r27
                                 sound_driver_channel0_release_hi_pitch:
001bdf 91b0 283f                 	lds r27, pulse1_hi_pitch_macro_release
001be1 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001be2 f019                      	breq sound_driver_channel0_release_duty
001be3 95b3                      	inc r27
001be4 93b0 283d                 	sts pulse1_hi_pitch_macro_offset, r27
                                 sound_driver_channel0_release_duty:
001be6 91b0 2844                 	lds r27, pulse1_duty_macro_release
001be8 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001be9 f019                      	breq sound_driver_channel0_release_exit
001bea 95b3                      	inc r27
001beb 93b0 2842                 	sts pulse1_duty_macro_offset, r27
                                 sound_driver_channel0_release_exit:
001bed d026                      	rcall sound_driver_channel0_increment_offset
001bee cd55                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_next_pattern:
001bef 91e0 2818                 	lds ZL, song_frames
001bf1 91f0 2819                 	lds ZH, song_frames+1
001bf3 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001bf5 91b0 281b                 	lds r27, song_frame_offset+1
001bf7 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
001bf8 93a0 281a                 	sts song_frame_offset, r26
001bfa 93b0 281b                 	sts song_frame_offset+1, r27
                                 
001bfc 91c0 281c                 	lds r28, song_size
001bfe 91d0 281d                 	lds r29, song_size+1
001c00 17ac                      	cp r26, r28
001c01 07bd                      	cpc r27, r29
001c02 f010                      	brlo sound_driver_channel0_next_pattern_exists
001c03 940c 3263                 	jmp sound_driver_exit
                                 
                                 sound_driver_channel0_next_pattern_exists:
001c05 0fea                      	add ZL, r26
001c06 1ffb                      	adc ZH, r27
                                 
001c07 91a5                      	lpm r26, Z+ //load the address of the next pattern
001c08 91b4                      	lpm r27, Z
001c09 0faa                      	lsl r26
001c0a 1fbb                      	rol r27
001c0b 93a0 2822                 	sts pulse1_pattern, r26
001c0d 93b0 2823                 	sts pulse1_pattern+1, r27
                                 
001c0f 9220 2826                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001c11 9220 2827                 	sts pulse1_pattern_offset+1, zero
001c13 cd30                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_increment_offset:
001c14 91e0 2826                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
001c16 91f0 2827                 	lds ZH, pulse1_pattern_offset+1
001c18 9631                      	adiw Z, 1
001c19 93e0 2826                 	sts pulse1_pattern_offset, ZL
001c1b 93f0 2827                 	sts pulse1_pattern_offset+1, ZH
001c1d 9508                      	ret
                                 
                                 sound_driver_channel0_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001c1e 91e0 2826                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
001c20 91f0 2827                 	lds ZH, pulse1_pattern_offset+1
001c22 9632                      	adiw Z, 2 //increment the pointer twice
001c23 93e0 2826                 	sts pulse1_pattern_offset, ZL
001c25 93f0 2827                 	sts pulse1_pattern_offset+1, ZH
001c27 9508                      	ret
                                 
                                 sound_driver_channel0_decrement_frame_delay:
001c28 95ba                      	dec r27
001c29 93b0 2825                 	sts pulse1_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel1:
001c2b 91a0 2873                 	lds r26, pulse2_pattern_delay_rows
001c2d 91b0 2874                 	lds r27, pulse2_pattern_delay_frames
001c2f 9610                      	adiw r27:r26, 0
001c30 f009                      	breq sound_driver_channel1_main //if the pattern delay is 0, proceed with sound driver procedures
001c31 c2d7                      	rjmp sound_driver_channel1_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel1_main:
001c32 91e0 2871                 	lds ZL, pulse2_pattern //current pattern for pulse 2
001c34 91f0 2872                 	lds ZH, pulse2_pattern+1
001c36 91a0 2875                 	lds r26, pulse2_pattern_offset //current offset in the pattern for pulse 2
001c38 91b0 2876                 	lds r27, pulse2_pattern_offset+1
001c3a 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001c3b 1ffb                      	adc ZH, r27
001c3c 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel1_check_if_note: //check if data is a note (0x00 - 0x56)
001c3d 35b7                      	cpi r27, 0x57
001c3e f408                      	brsh sound_driver_channel1_check_if_volume
001c3f c180                      	rjmp sound_driver_channel1_note
                                 sound_driver_channel1_check_if_volume: //check if data is volume (0x57-0x66)
001c40 36b7                      	cpi r27, 0x67
001c41 f408                      	brsh sound_driver_channel1_check_if_delay
001c42 c1ba                      	rjmp sound_driver_channel1_volume
                                 sound_driver_channel1_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001c43 3eb3                      	cpi r27, 0xE3
001c44 f408                      	brsh sound_driver_channel1_check_if_instrument
001c45 c1c1                      	rjmp sound_driver_channel1_delay
                                 sound_driver_channel1_check_if_instrument: //check for instrument flag (0xE3)
001c46 f409                      	brne sound_driver_channel1_check_if_release
001c47 c1c4                      	rjmp sound_driver_channel1_instrument_change 
                                 sound_driver_channel1_check_if_release: //check for note release flag (0xE4)
001c48 3eb4                      	cpi r27, 0xE4
001c49 f409                      	brne sound_driver_channel1_check_if_end
001c4a c26d                      	rjmp sound_driver_channel1_release
                                 sound_driver_channel1_check_if_end:
001c4b 3fbf                      	cpi r27, 0xFF
001c4c f409                      	brne sound_driver_channel1_check_if_fx
001c4d c28f                      	rjmp sound_driver_channel1_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel1_check_if_fx: //fx flags (0xE5 - 0xFE)
001c4e 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001c4f 91a4                      	lpm r26, Z //load the fx data into r26
001c50 d2ae                      	rcall sound_driver_channel1_increment_offset_twice
                                 
001c51 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001c52 e2ea                      	ldi ZL, LOW(channel1_fx << 1) //load in note table
001c53 e6f5                      	ldi ZH, HIGH(channel1_fx << 1)
001c54 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001c55 0feb                      	add ZL, r27 //add offset
001c56 1df2                      	adc ZH, zero
001c57 91c5                      	lpm r28, Z+ //load address bytes
001c58 91d4                      	lpm r29, Z
001c59 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001c5a 2ffd                      	mov ZH, r29
001c5b 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel1_fx_0xy:
001c5c 93a0 2894                 	sts pulse2_fx_0xy_sequence, r26
001c5e 9220 2895                 	sts pulse2_fx_0xy_sequence+1, zero
001c60 cfd1                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel1_fx_1xx:
001c61 9220 289a                 	sts pulse2_fx_2xx, zero //turn off any 2xx pitch slide down
001c63 9220 289b                 	sts pulse2_fx_2xx+1, zero
001c65 9220 2894                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
001c67 9220 2895                 	sts pulse2_fx_0xy_sequence+1, zero
001c69 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001c6a 937f                      	push r23
001c6b 2f6a                      	mov r22, r26 //store the rate into r22
001c6c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001c6d 9f67                      	mul r22, r23
001c6e 917f                      	pop r23
001c6f 916f                      	pop r22
                                 
001c70 9416                      	lsr r1 //shift out the fractional bits
001c71 9407                      	ror r0
001c72 9416                      	lsr r1
001c73 9407                      	ror r0
001c74 9416                      	lsr r1
001c75 9407                      	ror r0
001c76 9416                      	lsr r1
001c77 9407                      	ror r0
001c78 9200 2896                 	sts pulse2_fx_1xx, r0
001c7a 9210 2897                 	sts pulse2_fx_1xx+1, r1
001c7c cfb5                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel1_fx_2xx:
001c7d 9220 2896                 	sts pulse2_fx_1xx, zero //turn off any 1xx pitch slide down
001c7f 9220 2897                 	sts pulse2_fx_1xx+1, zero
001c81 9220 2894                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
001c83 9220 2895                 	sts pulse2_fx_0xy_sequence+1, zero
001c85 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001c86 937f                      	push r23
001c87 2f6a                      	mov r22, r26 //store the rate into r22
001c88 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001c89 9f67                      	mul r22, r23
001c8a 917f                      	pop r23
001c8b 916f                      	pop r22
                                 
001c8c 9416                      	lsr r1 //shift out the fractional bits
001c8d 9407                      	ror r0
001c8e 9416                      	lsr r1
001c8f 9407                      	ror r0
001c90 9416                      	lsr r1
001c91 9407                      	ror r0
001c92 9416                      	lsr r1
001c93 9407                      	ror r0
001c94 9200 289a                 	sts pulse2_fx_2xx, r0
001c96 9210 289b                 	sts pulse2_fx_2xx+1, r1
001c98 cf99                      	rjmp sound_driver_channel1_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel1_fx_3xx:
001c99 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001c9a 937f                      	push r23
001c9b 2f6a                      	mov r22, r26 //store the rate into r22
001c9c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001c9d 9f67                      	mul r22, r23
001c9e 917f                      	pop r23
001c9f 916f                      	pop r22
                                 
001ca0 9416                      	lsr r1 //shift out the fractional bits
001ca1 9407                      	ror r0
001ca2 9416                      	lsr r1
001ca3 9407                      	ror r0
001ca4 9416                      	lsr r1
001ca5 9407                      	ror r0
001ca6 9416                      	lsr r1
001ca7 9407                      	ror r0
001ca8 9200 28a2                 	sts pulse2_fx_3xx_speed, r0
001caa 9210 28a3                 	sts pulse2_fx_3xx_speed+1, r1
                                 
001cac 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001cad c001                      	rjmp sound_driver_channel1_fx_3xx_enabled
001cae cf83                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_3xx_enabled:
001caf 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001cb1 91b0 0a9d                 	lds r27, TCB1_CCMPH
001cb3 93a0 289e                 	sts pulse2_fx_3xx_start, r26
001cb5 93b0 289f                 	sts pulse2_fx_3xx_start+1, r27
                                 
001cb7 9220 28a4                 	sts pulse2_fx_3xx_total_offset, zero
001cb9 9220 28a5                 	sts pulse2_fx_3xx_total_offset+1, zero
001cbb cf76                      	rjmp sound_driver_channel1_main
                                 
                                 //VIBRATO
                                 sound_driver_channel1_fx_4xy:
001cbc 2fba                      	mov r27, r26
001cbd 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001cbe 95a2                      	swap r26
001cbf 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001cc0 93a0 28a6                 	sts pulse2_fx_4xy_speed, r26
001cc2 93b0 28a7                 	sts pulse2_fx_4xy_depth, r27
001cc4 9220 28a8                 	sts pulse2_fx_4xy_phase, zero //reset the phase to 0
001cc6 cf6b                      	rjmp sound_driver_channel1_main
                                 
                                 //TREMELO
                                 sound_driver_channel1_fx_7xy:
001cc7 2fba                      	mov r27, r26
001cc8 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001cc9 95a2                      	swap r26
001cca 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001ccb 93a0 28a9                 	sts pulse2_fx_7xy_speed, r26
001ccd 93b0 28aa                 	sts pulse2_fx_7xy_depth, r27
001ccf 9220 28ab                 	sts pulse2_fx_7xy_phase, zero //reset the phase to 0
001cd1 9220 28ac                 	sts pulse2_fx_7xy_value, zero //reset the tremelo value
001cd3 cf5e                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel1_fx_Axy:
001cd4 93a0 28ad                 	sts pulse2_fx_Axy, r26
001cd6 cf5b                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel1_fx_Bxx:
001cd7 93a0 281f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001cd9 cf58                      	rjmp sound_driver_channel1_main
                                 
                                 //HALT
                                 sound_driver_channel1_fx_Cxx:
001cda 93b0 2820                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001cdc cf55                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel1_fx_Dxx:
001cdd 93b0 2821                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001cdf cf52                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME
                                 sound_driver_channel1_fx_Exx:
001ce0 91b0 2808                 	lds r27, pulse2_param
001ce2 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
001ce3 2bba                      	or r27, r26 //move new VVVV bits into pulse2_param
001ce4 93b0 2808                 	sts pulse2_param, r27
001ce6 6092                      	sbr pulse_channel_flags, 2
001ce7 cf4a                      	rjmp sound_driver_channel1_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel1_fx_Fxx:
001ce8 93a0 281e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001cea cf47                      	rjmp sound_driver_channel1_main
                                 
                                 //DELAY
                                 sound_driver_channel1_fx_Gxx:
001ceb 15a2                      	cp r26, zero
001cec f051                      	breq sound_driver_channel1_fx_Gxx_invalid
001ced 91b0 281e                 	lds r27, song_speed
001cef 17ab                      	cp r26, r27
001cf0 f430                      	brsh sound_driver_channel1_fx_Gxx_invalid
001cf1 93a0 28ae                 	sts pulse2_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001cf3 e0b1                      	ldi r27, 0x01
001cf4 93b0 2873                 	sts pulse2_pattern_delay_rows, r27
001cf6 c215                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Gxx_invalid:
001cf7 cf3a                      	rjmp sound_driver_channel1_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel1_fx_Hxy: //hardware sweep up
001cf8 cf39                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixy: //hardware sweep down
001cf9 cf38                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Hxx: //FDS modulation depth
001cfa cf37                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixx: //FDS modulation speed
001cfb cf36                      	rjmp sound_driver_channel1_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel1_fx_Pxx:
001cfc 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001cfd 937f                      	push r23
001cfe 2f6a                      	mov r22, r26
001cff eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001d00 0367                      	mulsu r22, r23
001d01 917f                      	pop r23
001d02 916f                      	pop r22
001d03 9416                      	lsr r1 //shift out the fractional bits
001d04 9407                      	ror r0
001d05 9416                      	lsr r1
001d06 9407                      	ror r0
001d07 9416                      	lsr r1
001d08 9407                      	ror r0
001d09 9416                      	lsr r1
001d0a 9407                      	ror r0
001d0b fe13                      	sbrs r1, 3 //check if result was a negative number
001d0c c002                      	rjmp sound_driver_channel1_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel1_fx_Pxx_negative:
001d0d efb0                      	ldi r27, 0xF0
001d0e 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel1_fx_Pxx_store:
001d0f 9200 28b0                 	sts pulse2_fx_Pxx_total, r0
001d11 9210 28b1                 	sts pulse2_fx_Pxx_total+1, r1
001d13 cf1e                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel1_fx_Qxy:
                                 sound_driver_channel1_fx_Qxy_check_arpeggio_macro:
001d14 91e0 287c                 	lds ZL, pulse2_arpeggio_macro
001d16 91f0 287d                 	lds ZH, pulse2_arpeggio_macro+1
001d18 9630                      	adiw Z, 0
001d19 f009                      	breq sound_driver_channel1_fx_Qxy_check_pitch_macro
001d1a cf17                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_pitch_macro:
001d1b 91e0 2884                 	lds ZL, pulse2_pitch_macro
001d1d 91f0 2885                 	lds ZH, pulse2_pitch_macro+1
001d1f 9630                      	adiw Z, 0
001d20 f009                      	breq sound_driver_channel1_fx_Qxy_check_hi_pitch_macro
001d21 cf10                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_hi_pitch_macro:
001d22 91e0 288a                 	lds ZL, pulse2_hi_pitch_macro
001d24 91f0 288b                 	lds ZH, pulse2_hi_pitch_macro+1
001d26 9630                      	adiw Z, 0
001d27 f009                      	breq sound_driver_channel1_fx_Qxy_process
001d28 cf09                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_process:
001d29 2fba                      	mov r27, r26 //copy fx parameters into r27
001d2a 70bf                      	andi r27, 0x0F //mask note index offset
001d2b 91c0 280f                 	lds r28, pulse2_note //load current note index
001d2d 0fbc                      	add r27, r28
001d2e 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001d2f f008                      	brlo sound_driver_channel1_fx_Qxy_process_continue
001d30 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel1_fx_Qxy_process_continue:
001d31 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001d32 e0f0                      	ldi ZH, HIGH(note_table << 1)
001d33 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001d34 0feb                      	add ZL, r27 //add offset
001d35 1df2                      	adc ZH, zero
001d36 91c5                      	lpm r28, Z+ //load bytes
001d37 91d4                      	lpm r29, Z
001d38 93c0 28b2                 	sts pulse2_fx_Qxy_target, r28 //load the LOW bits for the target period
001d3a 93d0 28b3                 	sts pulse2_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
001d3c 95a2                      	swap r26
001d3d 70af                      	andi r26, 0x0F //mask effect speed
001d3e 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001d3f 95a3                      	inc r26 //increment the speed by 1
                                 
001d40 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001d41 937f                      	push r23
001d42 2f6a                      	mov r22, r26 //store the speed data into r27
001d43 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001d44 9f67                      	mul r22, r23
001d45 917f                      	pop r23
001d46 916f                      	pop r22
                                 
001d47 9416                      	lsr r1 //shift out the fractional bits
001d48 9407                      	ror r0
001d49 9416                      	lsr r1
001d4a 9407                      	ror r0
001d4b 9416                      	lsr r1
001d4c 9407                      	ror r0
001d4d 9416                      	lsr r1
001d4e 9407                      	ror r0
                                 
001d4f 9200 28b4                 	sts pulse2_fx_Qxy_speed, r0 //store the effect speed
001d51 9210 28b5                 	sts pulse2_fx_Qxy_speed+1, r1
001d53 9220 28b6                 	sts pulse2_fx_Qxy_total_offset, zero
001d55 9220 28b7                 	sts pulse2_fx_Qxy_total_offset+1, zero
001d57 ceda                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel1_fx_Rxy:
                                 sound_driver_channel1_fx_Rxy_check_arpeggio_macro:
001d58 91e0 287c                 	lds ZL, pulse2_arpeggio_macro
001d5a 91f0 287d                 	lds ZH, pulse2_arpeggio_macro+1
001d5c 9630                      	adiw Z, 0
001d5d f009                      	breq sound_driver_channel1_fx_Rxy_check_pitch_macro
001d5e ced3                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_pitch_macro:
001d5f 91e0 2884                 	lds ZL, pulse2_pitch_macro
001d61 91f0 2885                 	lds ZH, pulse2_pitch_macro+1
001d63 9630                      	adiw Z, 0
001d64 f009                      	breq sound_driver_channel1_fx_Rxy_check_hi_pitch_macro
001d65 cecc                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_hi_pitch_macro:
001d66 91e0 288a                 	lds ZL, pulse2_hi_pitch_macro
001d68 91f0 288b                 	lds ZH, pulse2_hi_pitch_macro+1
001d6a 9630                      	adiw Z, 0
001d6b f009                      	breq sound_driver_channel1_fx_Rxy_process
001d6c cec5                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_process:
001d6d 2fba                      	mov r27, r26 //copy fx parameters into r27
001d6e 70bf                      	andi r27, 0x0F //mask note index offset
001d6f 91c0 280f                 	lds r28, pulse2_note //load current note index
001d71 1bcb                      	sub r28, r27
001d72 f408                      	brcc sound_driver_channel1_fx_Rxy_process_continue
001d73 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel1_fx_Rxy_process_continue:
001d74 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001d75 e0f0                      	ldi ZH, HIGH(note_table << 1)
001d76 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001d77 0fec                      	add ZL, r28 //add offset
001d78 1df2                      	adc ZH, zero
001d79 91c5                      	lpm r28, Z+ //load bytes
001d7a 91d4                      	lpm r29, Z
001d7b 93c0 28b8                 	sts pulse2_fx_Rxy_target, r28 //load the LOW bits for the target period
001d7d 93d0 28b9                 	sts pulse2_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
001d7f 95a2                      	swap r26
001d80 70af                      	andi r26, 0x0F //mask effect speed
001d81 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001d82 95a3                      	inc r26 //increment the speed by 1
                                 
001d83 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001d84 937f                      	push r23
001d85 2f6a                      	mov r22, r26 //store the speed data into r27
001d86 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001d87 9f67                      	mul r22, r23
001d88 917f                      	pop r23
001d89 916f                      	pop r22
                                 
001d8a 9416                      	lsr r1 //shift out the fractional bits
001d8b 9407                      	ror r0
001d8c 9416                      	lsr r1
001d8d 9407                      	ror r0
001d8e 9416                      	lsr r1
001d8f 9407                      	ror r0
001d90 9416                      	lsr r1
001d91 9407                      	ror r0
                                 
001d92 9200 28ba                 	sts pulse2_fx_Rxy_speed, r0 //store the effect speed
001d94 9210 28bb                 	sts pulse2_fx_Rxy_speed+1, r1
001d96 9220 28bc                 	sts pulse2_fx_Rxy_total_offset, zero
001d98 9220 28bd                 	sts pulse2_fx_Rxy_total_offset+1, zero
001d9a ce97                      	rjmp sound_driver_channel1_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel1_fx_Sxx:
001d9b 15a2                      	cp r26, zero
001d9c f051                      	breq sound_driver_channel1_fx_Sxx_invalid
001d9d 91b0 281e                 	lds r27, song_speed
001d9f 17ab                      	cp r26, r27
001da0 f430                      	brsh sound_driver_channel1_fx_Sxx_invalid
001da1 93a0 28be                 	sts pulse2_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001da3 e0b1                      	ldi r27, 0x01
001da4 93b0 2873                 	sts pulse2_pattern_delay_rows, r27
001da6 c165                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Sxx_invalid:
001da7 ce8a                      	rjmp sound_driver_channel1_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel1_fx_Vxx:
001da8 efe2                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
001da9 e6f4                      	ldi ZH, HIGH(sequences << 1)
001daa 0fea                      	add ZL, r26 //offset the pointer
001dab 1df2                      	adc ZH, zero
                                 
001dac 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
001dad 95a7                      	ror r26
001dae 95a7                      	ror r26
001daf 91b0 2808                 	lds r27, pulse2_param //load r27 with pulse2_param (register $4000)
001db1 2fcb                      	mov r28, r27 //store a copy of pulse2_param into r28
001db2 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
001db3 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
001db4 c001                      	rjmp sound_driver_channel1_fx_Vxx_store
001db5 ce7c                      	rjmp sound_driver_channel1_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel1_fx_Vxx_store:
001db6 90d4                      	lpm pulse2_sequence, Z //store the sequence
                                 
001db7 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
001db8 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
001db9 93c0 2808                 	sts pulse2_param, r28
001dbb ce76                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_Wxx: //DPCM sample speed
001dbc ce75                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Xxx: //DPCM sample retrigger
001dbd ce74                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Yxx: //DPCM sample offset
001dbe ce73                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Zxx: //DPCM sample delta counter
001dbf ce72                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 sound_driver_channel1_note:
001dc0 93b0 280f                 	sts pulse2_note, r27 //store the note index
001dc2 e0a3                      	ldi r26, 0x03
001dc3 e0b2                      	ldi r27, 0x02
001dc4 93b0 2879                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
001dc6 93a0 287e                 	sts pulse2_arpeggio_macro_offset, r26
001dc8 93b0 2886                 	sts pulse2_pitch_macro_offset, r27
001dca 93b0 288c                 	sts pulse2_hi_pitch_macro_offset, r27
001dcc 93b0 2891                 	sts pulse2_duty_macro_offset, r27
001dce 9220 2882                 	sts pulse2_total_pitch_offset, zero //reset the pitch and hi pitch offset
001dd0 9220 2883                 	sts pulse2_total_pitch_offset+1, zero
001dd2 9220 2889                 	sts pulse2_total_hi_pitch_offset, zero
001dd4 9220 2898                 	sts pulse2_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001dd6 9220 2899                 	sts pulse2_fx_1xx_total+1, zero
001dd8 9220 289c                 	sts pulse2_fx_2xx_total, zero
001dda 9220 289d                 	sts pulse2_fx_2xx_total+1, zero
001ddc 9220 28a4                 	sts pulse2_fx_3xx_total_offset, zero //reset 3xx offset
001dde 9220 28a5                 	sts pulse2_fx_3xx_total_offset+1, zero
001de0 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001de2 91b0 0a9d                 	lds r27, TCB1_CCMPH
001de4 93a0 289e                 	sts pulse2_fx_3xx_start, r26
001de6 93b0 289f                 	sts pulse2_fx_3xx_start+1, r27
001de8 9220 2809                 	sts pulse2_sweep_param, zero //reset any sweep effect
001dea 6093                      	sbr pulse_channel_flags, 3 //set reload flag
001deb 9220 28b2                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001ded 9220 28b3                 	sts pulse2_fx_Qxy_target+1, zero
001def 9220 28b6                 	sts pulse2_fx_Qxy_total_offset, zero
001df1 9220 28b7                 	sts pulse2_fx_Qxy_total_offset+1, zero
001df3 9220 28b8                 	sts pulse2_fx_Rxy_target, zero
001df5 9220 28b9                 	sts pulse2_fx_Rxy_target+1, zero
001df7 9220 28bc                 	sts pulse2_fx_Rxy_total_offset, zero
001df9 9220 28bd                 	sts pulse2_fx_Rxy_total_offset+1, zero
001dfb d0f9                      	rcall sound_driver_channel1_increment_offset
001dfc ce35                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_volume:
001dfd 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001dfe 91a0 2808                 	lds r26, pulse2_param
001e00 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001e01 2bab                      	or r26, r27 //move new VVVV bits into pulse2_param
001e02 93a0 2808                 	sts pulse2_param, r26
001e04 6092                      	sbr pulse_channel_flags, 2
001e05 d0ef                      	rcall sound_driver_channel1_increment_offset
001e06 ce2b                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_delay:
001e07 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001e08 93b0 2873                 	sts pulse2_pattern_delay_rows, r27
001e0a d0ea                      	rcall sound_driver_channel1_increment_offset
001e0b c100                      	rjmp sound_driver_channel2
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change:
001e0c 9220 2877                 	sts pulse2_volume_macro, zero //reset all macro addresses
001e0e 9220 2878                 	sts pulse2_volume_macro+1, zero
001e10 9220 287c                 	sts pulse2_arpeggio_macro, zero
001e12 9220 287d                 	sts pulse2_arpeggio_macro+1, zero
001e14 9220 2884                 	sts pulse2_pitch_macro, zero
001e16 9220 2885                 	sts pulse2_pitch_macro+1, zero
001e18 9220 288a                 	sts pulse2_hi_pitch_macro, zero
001e1a 9220 288b                 	sts pulse2_hi_pitch_macro+1, zero
001e1c 9220 288f                 	sts pulse2_duty_macro, zero
001e1e 9220 2890                 	sts pulse2_duty_macro+1, zero
001e20 9220 2882                 	sts pulse2_total_pitch_offset, zero //reset the pitch offset
001e22 9220 2883                 	sts pulse2_total_pitch_offset+1, zero
001e24 9220 2889                 	sts pulse2_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001e26 9631                      	adiw Z, 1 //point to the byte next to the flag
001e27 91b4                      	lpm r27, Z //store the instrument offset into r27
001e28 e8ec                      	ldi ZL, LOW(instruments) //point Z to instruments table
001e29 e1f2                      	ldi ZH, HIGH(instruments)
001e2a 0feb                      	add ZL, r27 //point Z to offsetted instrument
001e2b 1df2                      	adc ZH, zero
001e2c 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001e2d 1fff                      	rol ZH
001e2e 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001e2f 91b4                      	lpm r27, Z
                                 
001e30 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001e31 1fbb                      	rol r27
001e32 2fea                      	mov ZL, r26
001e33 2ffb                      	mov ZH, r27
001e34 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001e35 9632                      	adiw Z, 2 //point Z to the address of the macro
001e36 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel1_instrument_change_macro_loop:
001e37 95aa                      	dec r26
001e38 f019                      	breq sound_driver_channel1_instrument_change_exit
001e39 95b6                      	lsr r27
001e3a f078                      	brcs sound_driver_channel1_instrument_change_load_macro
001e3b cffb                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_exit:
001e3c e0a3                      	ldi r26, 0x03
001e3d e0b2                      	ldi r27, 0x02
001e3e 93b0 2879                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
001e40 93a0 287e                 	sts pulse2_arpeggio_macro_offset, r26
001e42 93b0 2886                 	sts pulse2_pitch_macro_offset, r27
001e44 93b0 288c                 	sts pulse2_hi_pitch_macro_offset, r27
001e46 93b0 2891                 	sts pulse2_duty_macro_offset, r27
001e48 d0b6                      	rcall sound_driver_channel1_increment_offset_twice
001e49 cde8                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_load_macro:
001e4a 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001e4b 91d5                      	lpm r29, Z+
                                 
001e4c 30a5                      	cpi r26, 5
001e4d f039                      	breq sound_driver_channel1_instrument_change_load_macro_volume
001e4e 30a4                      	cpi r26, 4
001e4f f079                      	breq sound_driver_channel1_instrument_change_load_macro_arpeggio
001e50 30a3                      	cpi r26, 3
001e51 f0d9                      	breq sound_driver_channel1_instrument_change_load_macro_pitch
001e52 30a2                      	cpi r26, 2
001e53 f159                      	breq sound_driver_channel1_instrument_change_load_macro_hi_pitch
001e54 c03c                      	rjmp sound_driver_channel1_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel1_instrument_change_load_macro_volume:
001e55 93c0 2877                 	sts pulse2_volume_macro, r28
001e57 93d0 2878                 	sts pulse2_volume_macro+1, r29
001e59 d041                      	rcall sound_driver_channel1_instrument_change_read_header
001e5a 93c0 287b                 	sts pulse2_volume_macro_release, r28
001e5c 93d0 287a                 	sts pulse2_volume_macro_loop, r29
001e5e cfd8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 	
                                 sound_driver_channel1_instrument_change_load_macro_arpeggio:
001e5f 93c0 287c                 	sts pulse2_arpeggio_macro, r28
001e61 93d0 287d                 	sts pulse2_arpeggio_macro+1, r29
001e63 9220 28b2                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001e65 9220 28b3                 	sts pulse2_fx_Qxy_target+1, zero
001e67 9220 28b8                 	sts pulse2_fx_Rxy_target, zero
001e69 9220 28b9                 	sts pulse2_fx_Rxy_target+1, zero
001e6b d03a                      	rcall sound_driver_channel1_instrument_change_read_header_arpeggio
001e6c cfca                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_pitch:
001e6d 93c0 2884                 	sts pulse2_pitch_macro, r28
001e6f 93d0 2885                 	sts pulse2_pitch_macro+1, r29
001e71 9220 28b2                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001e73 9220 28b3                 	sts pulse2_fx_Qxy_target+1, zero
001e75 9220 28b8                 	sts pulse2_fx_Rxy_target, zero
001e77 9220 28b9                 	sts pulse2_fx_Rxy_target+1, zero
001e79 d021                      	rcall sound_driver_channel1_instrument_change_read_header
001e7a 93c0 2888                 	sts pulse2_pitch_macro_release, r28
001e7c 93d0 2887                 	sts pulse2_pitch_macro_loop, r29
001e7e cfb8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_hi_pitch:
001e7f 93c0 288a                 	sts pulse2_hi_pitch_macro, r28
001e81 93d0 288b                 	sts pulse2_hi_pitch_macro+1, r29
001e83 9220 28b2                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001e85 9220 28b3                 	sts pulse2_fx_Qxy_target+1, zero
001e87 9220 28b8                 	sts pulse2_fx_Rxy_target, zero
001e89 9220 28b9                 	sts pulse2_fx_Rxy_target+1, zero
001e8b d00f                      	rcall sound_driver_channel1_instrument_change_read_header
001e8c 93c0 288e                 	sts pulse2_hi_pitch_macro_release, r28
001e8e 93d0 288d                 	sts pulse2_hi_pitch_macro_loop, r29
001e90 cfa6                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_duty:
001e91 93c0 288f                 	sts pulse2_duty_macro, r28
001e93 93d0 2890                 	sts pulse2_duty_macro+1, r29
001e95 d005                      	rcall sound_driver_channel1_instrument_change_read_header
001e96 93c0 2893                 	sts pulse2_duty_macro_release, r28
001e98 93d0 2892                 	sts pulse2_duty_macro_loop, r29
001e9a cf9c                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_read_header:
001e9b 93ef                      	push ZL
001e9c 93ff                      	push ZH
001e9d 2fec                      	mov ZL, r28
001e9e 2ffd                      	mov ZH, r29
001e9f 0fee                      	lsl ZL
001ea0 1fff                      	rol ZH
001ea1 91c5                      	lpm r28, Z+
001ea2 91d4                      	lpm r29, Z
001ea3 91ff                      	pop ZH
001ea4 91ef                      	pop ZL
001ea5 9508                      	ret
                                 
                                 sound_driver_channel1_instrument_change_read_header_arpeggio:
001ea6 93ef                      	push ZL
001ea7 93ff                      	push ZH
001ea8 2fec                      	mov ZL, r28
001ea9 2ffd                      	mov ZH, r29
001eaa 0fee                      	lsl ZL
001eab 1fff                      	rol ZH
001eac 91c5                      	lpm r28, Z+
001ead 91d5                      	lpm r29, Z+
001eae 93c0 2880                 	sts pulse2_arpeggio_macro_release, r28
001eb0 93d0 287f                 	sts pulse2_arpeggio_macro_loop, r29
001eb2 91c4                      	lpm r28, Z
001eb3 93c0 2881                 	sts pulse2_arpeggio_macro_mode, r28
001eb5 91ff                      	pop ZH
001eb6 91ef                      	pop ZL
001eb7 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel1_release:
                                 sound_driver_channel1_release_volume:
001eb8 91b0 287b                 	lds r27, pulse2_volume_macro_release
001eba 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001ebb f019                      	breq sound_driver_channel1_release_arpeggio //if the macro has no release flag, check the next macro
001ebc 95b3                      	inc r27
001ebd 93b0 2879                 	sts pulse2_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel1_release_arpeggio:
001ebf 91b0 2880                 	lds r27, pulse2_arpeggio_macro_release
001ec1 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001ec2 f019                      	breq sound_driver_channel1_release_pitch
001ec3 95b3                      	inc r27
001ec4 93b0 287e                 	sts pulse2_arpeggio_macro_offset, r27
                                 sound_driver_channel1_release_pitch:
001ec6 91b0 2888                 	lds r27, pulse2_pitch_macro_release
001ec8 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001ec9 f019                      	breq sound_driver_channel1_release_hi_pitch
001eca 95b3                      	inc r27
001ecb 93b0 2886                 	sts pulse2_pitch_macro_offset, r27
                                 sound_driver_channel1_release_hi_pitch:
001ecd 91b0 288e                 	lds r27, pulse2_hi_pitch_macro_release
001ecf 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001ed0 f019                      	breq sound_driver_channel1_release_duty
001ed1 95b3                      	inc r27
001ed2 93b0 288c                 	sts pulse2_hi_pitch_macro_offset, r27
                                 sound_driver_channel1_release_duty:
001ed4 91b0 2893                 	lds r27, pulse2_duty_macro_release
001ed6 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001ed7 f019                      	breq sound_driver_channel1_release_exit
001ed8 95b3                      	inc r27
001ed9 93b0 2891                 	sts pulse2_duty_macro_offset, r27
                                 sound_driver_channel1_release_exit:
001edb d019                      	rcall sound_driver_channel1_increment_offset
001edc cd55                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_next_pattern:
001edd 91e0 2818                 	lds ZL, song_frames
001edf 91f0 2819                 	lds ZH, song_frames+1
001ee1 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001ee3 91b0 281b                 	lds r27, song_frame_offset+1
001ee5 9612                      	adiw r27:r26, 2 //offset for channel 1
001ee6 0fea                      	add ZL, r26
001ee7 1ffb                      	adc ZH, r27
                                 
001ee8 91a5                      	lpm r26, Z+ //load the address of the next pattern
001ee9 91b4                      	lpm r27, Z
001eea 0faa                      	lsl r26
001eeb 1fbb                      	rol r27
001eec 93a0 2871                 	sts pulse2_pattern, r26
001eee 93b0 2872                 	sts pulse2_pattern+1, r27
                                 
001ef0 9220 2875                 	sts pulse2_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001ef2 9220 2876                 	sts pulse2_pattern_offset+1, zero
001ef4 cd3d                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_increment_offset:
001ef5 91e0 2875                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001ef7 91f0 2876                 	lds ZH, pulse2_pattern_offset+1
001ef9 9631                      	adiw Z, 1
001efa 93e0 2875                 	sts pulse2_pattern_offset, ZL
001efc 93f0 2876                 	sts pulse2_pattern_offset+1, ZH
001efe 9508                      	ret
                                 
                                 sound_driver_channel1_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001eff 91e0 2875                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001f01 91f0 2876                 	lds ZH, pulse2_pattern_offset+1
001f03 9632                      	adiw Z, 2 //increment the pointer twice
001f04 93e0 2875                 	sts pulse2_pattern_offset, ZL
001f06 93f0 2876                 	sts pulse2_pattern_offset+1, ZH
001f08 9508                      	ret
                                 
                                 sound_driver_channel1_decrement_frame_delay:
001f09 95ba                      	dec r27
001f0a 93b0 2874                 	sts pulse2_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel2:
001f0c 91a0 28c2                 	lds r26, triangle_pattern_delay_rows
001f0e 91b0 28c3                 	lds r27, triangle_pattern_delay_frames
001f10 9610                      	adiw r27:r26, 0
001f11 f009                      	breq sound_driver_channel2_main //if the pattern delay is 0, proceed with sound driver procedures
001f12 c2bf                      	rjmp sound_driver_channel2_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel2_main:
001f13 91e0 28c0                 	lds ZL, triangle_pattern //current pattern for triangle
001f15 91f0 28c1                 	lds ZH, triangle_pattern+1
001f17 91a0 28c4                 	lds r26, triangle_pattern_offset //current offset in the pattern for triangle
001f19 91b0 28c5                 	lds r27, triangle_pattern_offset+1
001f1b 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001f1c 1ffb                      	adc ZH, r27
001f1d 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel2_check_if_note: //check if data is a note (0x00 - 0x56)
001f1e 35b7                      	cpi r27, 0x57
001f1f f408                      	brsh sound_driver_channel2_check_if_volume
001f20 c164                      	rjmp sound_driver_channel2_note
                                 sound_driver_channel2_check_if_volume: //check if data is volume (0x57-0x66)
001f21 36b7                      	cpi r27, 0x67
001f22 f408                      	brsh sound_driver_channel2_check_if_delay
001f23 c19e                      	rjmp sound_driver_channel2_volume
                                 sound_driver_channel2_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001f24 3eb3                      	cpi r27, 0xE3
001f25 f408                      	brsh sound_driver_channel2_check_if_instrument
001f26 c1a9                      	rjmp sound_driver_channel2_delay
                                 sound_driver_channel2_check_if_instrument: //check for instrument flag (0xE3)
001f27 f409                      	brne sound_driver_channel2_check_if_release
001f28 c1ac                      	rjmp sound_driver_channel2_instrument_change 
                                 sound_driver_channel2_check_if_release: //check for note release flag (0xE4)
001f29 3eb4                      	cpi r27, 0xE4
001f2a f409                      	brne sound_driver_channel2_check_if_end
001f2b c255                      	rjmp sound_driver_channel2_release
                                 sound_driver_channel2_check_if_end:
001f2c 3fbf                      	cpi r27, 0xFF
001f2d f409                      	brne sound_driver_channel2_check_if_fx
001f2e c277                      	rjmp sound_driver_channel2_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel2_check_if_fx: //fx flags (0xE5 - 0xFE)
001f2f 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001f30 91a4                      	lpm r26, Z //load the fx data into r26
001f31 d296                      	rcall sound_driver_channel2_increment_offset_twice
                                 
001f32 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001f33 e5ee                      	ldi ZL, LOW(channel2_fx << 1) //load in note table
001f34 e6f5                      	ldi ZH, HIGH(channel2_fx << 1)
001f35 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001f36 0feb                      	add ZL, r27 //add offset
001f37 1df2                      	adc ZH, zero
001f38 91c5                      	lpm r28, Z+ //load address bytes
001f39 91d4                      	lpm r29, Z
001f3a 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001f3b 2ffd                      	mov ZH, r29
001f3c 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel2_fx_0xy:
001f3d 93a0 28e3                 	sts triangle_fx_0xy_sequence, r26
001f3f 9220 28e4                 	sts triangle_fx_0xy_sequence+1, zero
001f41 cfd1                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel2_fx_1xx:
001f42 9220 28e9                 	sts triangle_fx_2xx, zero //turn off any 2xx pitch slide down
001f44 9220 28ea                 	sts triangle_fx_2xx+1, zero
001f46 9220 28e3                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001f48 9220 28e4                 	sts triangle_fx_0xy_sequence+1, zero
001f4a 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001f4b 937f                      	push r23
001f4c 2f6a                      	mov r22, r26 //store the rate into r22
001f4d eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001f4e 9f67                      	mul r22, r23
001f4f 917f                      	pop r23
001f50 916f                      	pop r22
                                 
001f51 9416                      	lsr r1 //shift out the fractional bits
001f52 9407                      	ror r0
001f53 9416                      	lsr r1
001f54 9407                      	ror r0
001f55 9416                      	lsr r1
001f56 9407                      	ror r0
001f57 9416                      	lsr r1
001f58 9407                      	ror r0
001f59 9200 28e5                 	sts triangle_fx_1xx, r0
001f5b 9210 28e6                 	sts triangle_fx_1xx+1, r1
001f5d cfb5                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel2_fx_2xx:
001f5e 9220 28e5                 	sts triangle_fx_1xx, zero //turn off any 1xx pitch slide down
001f60 9220 28e6                 	sts triangle_fx_1xx+1, zero
001f62 9220 28e3                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001f64 9220 28e4                 	sts triangle_fx_0xy_sequence+1, zero
001f66 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001f67 937f                      	push r23
001f68 2f6a                      	mov r22, r26 //store the rate into r22
001f69 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001f6a 9f67                      	mul r22, r23
001f6b 917f                      	pop r23
001f6c 916f                      	pop r22
                                 
001f6d 9416                      	lsr r1 //shift out the fractional bits
001f6e 9407                      	ror r0
001f6f 9416                      	lsr r1
001f70 9407                      	ror r0
001f71 9416                      	lsr r1
001f72 9407                      	ror r0
001f73 9416                      	lsr r1
001f74 9407                      	ror r0
001f75 9200 28e9                 	sts triangle_fx_2xx, r0
001f77 9210 28ea                 	sts triangle_fx_2xx+1, r1
001f79 cf99                      	rjmp sound_driver_channel2_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel2_fx_3xx:
001f7a 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001f7b 937f                      	push r23
001f7c 2f6a                      	mov r22, r26 //store the rate into r22
001f7d eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001f7e 9f67                      	mul r22, r23
001f7f 917f                      	pop r23
001f80 916f                      	pop r22
                                 
001f81 9416                      	lsr r1 //shift out the fractional bits
001f82 9407                      	ror r0
001f83 9416                      	lsr r1
001f84 9407                      	ror r0
001f85 9416                      	lsr r1
001f86 9407                      	ror r0
001f87 9416                      	lsr r1
001f88 9407                      	ror r0
001f89 9200 28f1                 	sts triangle_fx_3xx_speed, r0
001f8b 9210 28f2                 	sts triangle_fx_3xx_speed+1, r1
                                 
001f8d 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001f8e c001                      	rjmp sound_driver_channel2_fx_3xx_enabled
001f8f cf83                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_3xx_enabled:
001f90 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001f92 91b0 0aad                 	lds r27, TCB2_CCMPH
001f94 93a0 28ed                 	sts triangle_fx_3xx_start, r26
001f96 93b0 28ee                 	sts triangle_fx_3xx_start+1, r27
                                 
001f98 9220 28f3                 	sts triangle_fx_3xx_total_offset, zero
001f9a 9220 28f4                 	sts triangle_fx_3xx_total_offset+1, zero
001f9c cf76                      	rjmp sound_driver_channel2_main
                                 
                                 //VIBRATO
                                 sound_driver_channel2_fx_4xy:
001f9d 2fba                      	mov r27, r26
001f9e 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001f9f 95a2                      	swap r26
001fa0 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001fa1 93a0 28f5                 	sts triangle_fx_4xy_speed, r26
001fa3 93b0 28f6                 	sts triangle_fx_4xy_depth, r27
001fa5 9220 28f7                 	sts triangle_fx_4xy_phase, zero //reset the phase to 0
001fa7 cf6b                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_7xy: //tremelo
001fa8 cf6a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Axy: //volume slide
001fa9 cf69                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel2_fx_Bxx:
001faa 93a0 281f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001fac cf66                      	rjmp sound_driver_channel2_main
                                 
                                 //HALT
                                 sound_driver_channel2_fx_Cxx:
001fad 93b0 2820                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001faf cf63                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel2_fx_Dxx:
001fb0 93b0 2821                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001fb2 cf60                      	rjmp sound_driver_channel2_main
                                 
                                 //VOLUME
                                 sound_driver_channel2_fx_Exx:
001fb3 15a2                      	cp r26, zero
001fb4 f021                      	breq sound_driver_channel2_fx_Exx_disable
                                 sound_driver_channel2_fx_Exx_enable:
001fb5 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001fb6 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001fb8 cf5a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Exx_disable:
001fb9 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
001fbb 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
001fbd 9220 0aad                 	sts TCB2_CCMPH, zero
001fbf cf53                      	rjmp sound_driver_channel2_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel2_fx_Fxx:
001fc0 93a0 281e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001fc2 cf50                      	rjmp sound_driver_channel2_main
                                 
                                 //DELAY
                                 sound_driver_channel2_fx_Gxx:
001fc3 15a2                      	cp r26, zero
001fc4 f051                      	breq sound_driver_channel2_fx_Gxx_invalid
001fc5 91b0 281e                 	lds r27, song_speed
001fc7 17ab                      	cp r26, r27
001fc8 f430                      	brsh sound_driver_channel2_fx_Gxx_invalid
001fc9 93a0 28f8                 	sts triangle_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001fcb e0b1                      	ldi r27, 0x01
001fcc 93b0 28c2                 	sts triangle_pattern_delay_rows, r27
001fce c206                      	rjmp sound_driver_channel3
                                 sound_driver_channel2_fx_Gxx_invalid:
001fcf cf43                      	rjmp sound_driver_channel2_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Hxy: //hardware sweep up
001fd0 cf42                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixy: //hardware sweep down
001fd1 cf41                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Hxx: //FDS modulation depth
001fd2 cf40                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixx: //FDS modulation speed
001fd3 cf3f                      	rjmp sound_driver_channel2_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel2_fx_Pxx:
001fd4 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001fd5 937f                      	push r23
001fd6 2f6a                      	mov r22, r26
001fd7 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001fd8 0367                      	mulsu r22, r23
001fd9 917f                      	pop r23
001fda 916f                      	pop r22
001fdb 9416                      	lsr r1 //shift out the fractional bits
001fdc 9407                      	ror r0
001fdd 9416                      	lsr r1
001fde 9407                      	ror r0
001fdf 9416                      	lsr r1
001fe0 9407                      	ror r0
001fe1 9416                      	lsr r1
001fe2 9407                      	ror r0
001fe3 fe13                      	sbrs r1, 3 //check if result was a negative number
001fe4 c002                      	rjmp sound_driver_channel2_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel2_fx_Pxx_negative:
001fe5 efb0                      	ldi r27, 0xF0
001fe6 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel2_fx_Pxx_store:
001fe7 9200 28fa                 	sts triangle_fx_Pxx_total, r0
001fe9 9210 28fb                 	sts triangle_fx_Pxx_total+1, r1
001feb cf27                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel2_fx_Qxy:
                                 sound_driver_channel2_fx_Qxy_check_arpeggio_macro:
001fec 91e0 28cb                 	lds ZL, triangle_arpeggio_macro
001fee 91f0 28cc                 	lds ZH, triangle_arpeggio_macro+1
001ff0 9630                      	adiw Z, 0
001ff1 f009                      	breq sound_driver_channel2_fx_Qxy_check_pitch_macro
001ff2 cf20                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_pitch_macro:
001ff3 91e0 28d3                 	lds ZL, triangle_pitch_macro
001ff5 91f0 28d4                 	lds ZH, triangle_pitch_macro+1
001ff7 9630                      	adiw Z, 0
001ff8 f009                      	breq sound_driver_channel2_fx_Qxy_check_hi_pitch_macro
001ff9 cf19                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_hi_pitch_macro:
001ffa 91e0 28d9                 	lds ZL, triangle_hi_pitch_macro
001ffc 91f0 28da                 	lds ZH, triangle_hi_pitch_macro+1
001ffe 9630                      	adiw Z, 0
001fff f009                      	breq sound_driver_channel2_fx_Qxy_process
002000 cf12                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_process:
002001 2fba                      	mov r27, r26 //copy fx parameters into r27
002002 70bf                      	andi r27, 0x0F //mask note index offset
002003 91c0 2812                 	lds r28, triangle_note //load current note index
002005 0fbc                      	add r27, r28
002006 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
002007 f008                      	brlo sound_driver_channel2_fx_Qxy_process_continue
002008 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel2_fx_Qxy_process_continue:
002009 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
00200a e0f0                      	ldi ZH, HIGH(note_table << 1)
00200b 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
00200c 0feb                      	add ZL, r27 //add offset
00200d 1df2                      	adc ZH, zero
00200e 91c5                      	lpm r28, Z+ //load bytes
00200f 91d4                      	lpm r29, Z
002010 93c0 28fc                 	sts triangle_fx_Qxy_target, r28 //load the LOW bits for the target period
002012 93d0 28fd                 	sts triangle_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
002014 95a2                      	swap r26
002015 70af                      	andi r26, 0x0F //mask effect speed
002016 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
002017 95a3                      	inc r26 //increment the speed by 1
                                 
002018 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002019 937f                      	push r23
00201a 2f6a                      	mov r22, r26 //store the speed data into r27
00201b eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00201c 9f67                      	mul r22, r23
00201d 917f                      	pop r23
00201e 916f                      	pop r22
                                 
00201f 9416                      	lsr r1 //shift out the fractional bits
002020 9407                      	ror r0
002021 9416                      	lsr r1
002022 9407                      	ror r0
002023 9416                      	lsr r1
002024 9407                      	ror r0
002025 9416                      	lsr r1
002026 9407                      	ror r0
                                 
002027 9200 28fe                 	sts triangle_fx_Qxy_speed, r0 //store the effect speed
002029 9210 28ff                 	sts triangle_fx_Qxy_speed+1, r1
00202b 9220 2900                 	sts triangle_fx_Qxy_total_offset, zero
00202d 9220 2901                 	sts triangle_fx_Qxy_total_offset+1, zero
00202f cee3                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel2_fx_Rxy:
                                 sound_driver_channel2_fx_Rxy_check_arpeggio_macro:
002030 91e0 28cb                 	lds ZL, triangle_arpeggio_macro
002032 91f0 28cc                 	lds ZH, triangle_arpeggio_macro+1
002034 9630                      	adiw Z, 0
002035 f009                      	breq sound_driver_channel2_fx_Rxy_check_pitch_macro
002036 cedc                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_pitch_macro:
002037 91e0 28d3                 	lds ZL, triangle_pitch_macro
002039 91f0 28d4                 	lds ZH, triangle_pitch_macro+1
00203b 9630                      	adiw Z, 0
00203c f009                      	breq sound_driver_channel2_fx_Rxy_check_hi_pitch_macro
00203d ced5                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_hi_pitch_macro:
00203e 91e0 28d9                 	lds ZL, triangle_hi_pitch_macro
002040 91f0 28da                 	lds ZH, triangle_hi_pitch_macro+1
002042 9630                      	adiw Z, 0
002043 f009                      	breq sound_driver_channel2_fx_Rxy_process
002044 cece                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_process:
002045 2fba                      	mov r27, r26 //copy fx parameters into r27
002046 70bf                      	andi r27, 0x0F //mask note index offset
002047 91c0 2812                 	lds r28, triangle_note //load current note index
002049 1bcb                      	sub r28, r27
00204a f408                      	brcc sound_driver_channel2_fx_Rxy_process_continue
00204b e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel2_fx_Rxy_process_continue:
00204c e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
00204d e0f0                      	ldi ZH, HIGH(note_table << 1)
00204e 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
00204f 0fec                      	add ZL, r28 //add offset
002050 1df2                      	adc ZH, zero
002051 91c5                      	lpm r28, Z+ //load bytes
002052 91d4                      	lpm r29, Z
002053 93c0 2902                 	sts triangle_fx_Rxy_target, r28 //load the LOW bits for the target period
002055 93d0 2903                 	sts triangle_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
002057 95a2                      	swap r26
002058 70af                      	andi r26, 0x0F //mask effect speed
002059 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
00205a 95a3                      	inc r26 //increment the speed by 1
                                 
00205b 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00205c 937f                      	push r23
00205d 2f6a                      	mov r22, r26 //store the speed data into r27
00205e eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00205f 9f67                      	mul r22, r23
002060 917f                      	pop r23
002061 916f                      	pop r22
                                 
002062 9416                      	lsr r1 //shift out the fractional bits
002063 9407                      	ror r0
002064 9416                      	lsr r1
002065 9407                      	ror r0
002066 9416                      	lsr r1
002067 9407                      	ror r0
002068 9416                      	lsr r1
002069 9407                      	ror r0
                                 
00206a 9200 2904                 	sts triangle_fx_Rxy_speed, r0 //store the effect speed
00206c 9210 2905                 	sts triangle_fx_Rxy_speed+1, r1
00206e 9220 2906                 	sts triangle_fx_Rxy_total_offset, zero
002070 9220 2907                 	sts triangle_fx_Rxy_total_offset+1, zero
002072 cea0                      	rjmp sound_driver_channel2_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel2_fx_Sxx:
002073 15a2                      	cp r26, zero
002074 f051                      	breq sound_driver_channel2_fx_Sxx_invalid
002075 91b0 281e                 	lds r27, song_speed
002077 17ab                      	cp r26, r27
002078 f430                      	brsh sound_driver_channel2_fx_Sxx_invalid
002079 93a0 2908                 	sts triangle_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
00207b e0b1                      	ldi r27, 0x01
00207c 93b0 28c2                 	sts triangle_pattern_delay_rows, r27
00207e c156                      	rjmp sound_driver_channel3
                                 sound_driver_channel2_fx_Sxx_invalid:
00207f ce93                      	rjmp sound_driver_channel2_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Vxx: //duty
002080 ce92                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Wxx: //DPCM sample speed
002081 ce91                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Xxx: //DPCM sample retrigger
002082 ce90                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Yxx: //DPCM sample offset
002083 ce8f                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Zxx: //DPCM sample delta counter
002084 ce8e                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 sound_driver_channel2_note:
002085 93b0 2812                 	sts triangle_note, r27 //store the note index
002087 e0a3                      	ldi r26, 0x03
002088 e0b2                      	ldi r27, 0x02
002089 93b0 28c8                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
00208b 93a0 28cd                 	sts triangle_arpeggio_macro_offset, r26
00208d 93b0 28d5                 	sts triangle_pitch_macro_offset, r27
00208f 93b0 28db                 	sts triangle_hi_pitch_macro_offset, r27
002091 93b0 28e0                 	sts triangle_duty_macro_offset, r27
002093 9220 28d1                 	sts triangle_total_pitch_offset, zero //reset the pitch and hi pitch offset
002095 9220 28d2                 	sts triangle_total_pitch_offset+1, zero
002097 9220 28d8                 	sts triangle_total_hi_pitch_offset, zero
002099 9220 28e7                 	sts triangle_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
00209b 9220 28e8                 	sts triangle_fx_1xx_total+1, zero
00209d 9220 28eb                 	sts triangle_fx_2xx_total, zero
00209f 9220 28ec                 	sts triangle_fx_2xx_total+1, zero
0020a1 9220 28f3                 	sts triangle_fx_3xx_total_offset, zero //reset 3xx offset
0020a3 9220 28f4                 	sts triangle_fx_3xx_total_offset+1, zero
0020a5 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
0020a7 91b0 0aad                 	lds r27, TCB2_CCMPH
0020a9 93a0 28ed                 	sts triangle_fx_3xx_start, r26
0020ab 93b0 28ee                 	sts triangle_fx_3xx_start+1, r27
0020ad 9220 28fc                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0020af 9220 28fd                 	sts triangle_fx_Qxy_target+1, zero
0020b1 9220 2900                 	sts triangle_fx_Qxy_total_offset, zero
0020b3 9220 2901                 	sts triangle_fx_Qxy_total_offset+1, zero
0020b5 9220 2902                 	sts triangle_fx_Rxy_target, zero
0020b7 9220 2903                 	sts triangle_fx_Rxy_target+1, zero
0020b9 9220 2906                 	sts triangle_fx_Rxy_total_offset, zero
0020bb 9220 2907                 	sts triangle_fx_Rxy_total_offset+1, zero
0020bd e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
0020be 93b0 0aa5                 	sts TCB2_INTCTRL, r27
0020c0 d0fd                      	rcall sound_driver_channel2_increment_offset
0020c1 ce51                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_volume:
0020c2 d0fb                      	rcall sound_driver_channel2_increment_offset
0020c3 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
0020c4 f021                      	breq sound_driver_channel2_volume_disable
                                 sound_driver_channel2_volume_enable:
0020c5 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
0020c6 93b0 0aa5                 	sts TCB2_INTCTRL, r27
0020c8 ce4a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_volume_disable:
0020c9 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
0020cb 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
0020cd 9220 0aad                 	sts TCB2_CCMPH, zero
0020cf ce43                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_delay:
0020d0 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
0020d1 93b0 28c2                 	sts triangle_pattern_delay_rows, r27
0020d3 d0ea                      	rcall sound_driver_channel2_increment_offset
0020d4 c100                      	rjmp sound_driver_channel3
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change:
0020d5 9220 28c6                 	sts triangle_volume_macro, zero //reset all macro addresses
0020d7 9220 28c7                 	sts triangle_volume_macro+1, zero
0020d9 9220 28cb                 	sts triangle_arpeggio_macro, zero
0020db 9220 28cc                 	sts triangle_arpeggio_macro+1, zero
0020dd 9220 28d3                 	sts triangle_pitch_macro, zero
0020df 9220 28d4                 	sts triangle_pitch_macro+1, zero
0020e1 9220 28d9                 	sts triangle_hi_pitch_macro, zero
0020e3 9220 28da                 	sts triangle_hi_pitch_macro+1, zero
0020e5 9220 28de                 	sts triangle_duty_macro, zero
0020e7 9220 28df                 	sts triangle_duty_macro+1, zero
0020e9 9220 28d1                 	sts triangle_total_pitch_offset, zero //reset the pitch offset
0020eb 9220 28d2                 	sts triangle_total_pitch_offset+1, zero
0020ed 9220 28d8                 	sts triangle_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
0020ef 9631                      	adiw Z, 1 //point to the byte next to the flag
0020f0 91b4                      	lpm r27, Z //store the instrument offset into r27
0020f1 e8ec                      	ldi ZL, LOW(instruments) //point Z to instruments table
0020f2 e1f2                      	ldi ZH, HIGH(instruments)
0020f3 0feb                      	add ZL, r27 //point Z to offsetted instrument
0020f4 1df2                      	adc ZH, zero
0020f5 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
0020f6 1fff                      	rol ZH
0020f7 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
0020f8 91b4                      	lpm r27, Z
                                 
0020f9 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
0020fa 1fbb                      	rol r27
0020fb 2fea                      	mov ZL, r26
0020fc 2ffb                      	mov ZH, r27
0020fd 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
0020fe 9632                      	adiw Z, 2 //point Z to the address of the macro
0020ff e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel2_instrument_change_macro_loop:
002100 95aa                      	dec r26
002101 f019                      	breq sound_driver_channel2_instrument_change_exit
002102 95b6                      	lsr r27
002103 f078                      	brcs sound_driver_channel2_instrument_change_load_macro
002104 cffb                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_exit:
002105 e0a3                      	ldi r26, 0x03
002106 e0b2                      	ldi r27, 0x02
002107 93b0 28c8                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
002109 93a0 28cd                 	sts triangle_arpeggio_macro_offset, r26
00210b 93b0 28d5                 	sts triangle_pitch_macro_offset, r27
00210d 93b0 28db                 	sts triangle_hi_pitch_macro_offset, r27
00210f 93b0 28e0                 	sts triangle_duty_macro_offset, r27
002111 d0b6                      	rcall sound_driver_channel2_increment_offset_twice
002112 ce00                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_load_macro:
002113 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
002114 91d5                      	lpm r29, Z+
                                 
002115 30a5                      	cpi r26, 5
002116 f039                      	breq sound_driver_channel2_instrument_change_load_macro_volume
002117 30a4                      	cpi r26, 4
002118 f079                      	breq sound_driver_channel2_instrument_change_load_macro_arpeggio
002119 30a3                      	cpi r26, 3
00211a f0d9                      	breq sound_driver_channel2_instrument_change_load_macro_pitch
00211b 30a2                      	cpi r26, 2
00211c f159                      	breq sound_driver_channel2_instrument_change_load_macro_hi_pitch
00211d c03c                      	rjmp sound_driver_channel2_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel2_instrument_change_load_macro_volume:
00211e 93c0 28c6                 	sts triangle_volume_macro, r28
002120 93d0 28c7                 	sts triangle_volume_macro+1, r29
002122 d041                      	rcall sound_driver_channel2_instrument_change_read_header
002123 93c0 28ca                 	sts triangle_volume_macro_release, r28
002125 93d0 28c9                 	sts triangle_volume_macro_loop, r29
002127 cfd8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 	
                                 sound_driver_channel2_instrument_change_load_macro_arpeggio:
002128 93c0 28cb                 	sts triangle_arpeggio_macro, r28
00212a 93d0 28cc                 	sts triangle_arpeggio_macro+1, r29
00212c 9220 28fc                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00212e 9220 28fd                 	sts triangle_fx_Qxy_target+1, zero
002130 9220 2902                 	sts triangle_fx_Rxy_target, zero
002132 9220 2903                 	sts triangle_fx_Rxy_target+1, zero
002134 d03a                      	rcall sound_driver_channel2_instrument_change_read_header_arpeggio
002135 cfca                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_pitch:
002136 93c0 28d3                 	sts triangle_pitch_macro, r28
002138 93d0 28d4                 	sts triangle_pitch_macro+1, r29
00213a 9220 28fc                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00213c 9220 28fd                 	sts triangle_fx_Qxy_target+1, zero
00213e 9220 2902                 	sts triangle_fx_Rxy_target, zero
002140 9220 2903                 	sts triangle_fx_Rxy_target+1, zero
002142 d021                      	rcall sound_driver_channel2_instrument_change_read_header
002143 93c0 28d7                 	sts triangle_pitch_macro_release, r28
002145 93d0 28d6                 	sts triangle_pitch_macro_loop, r29
002147 cfb8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_hi_pitch:
002148 93c0 28d9                 	sts triangle_hi_pitch_macro, r28
00214a 93d0 28da                 	sts triangle_hi_pitch_macro+1, r29
00214c 9220 28fc                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00214e 9220 28fd                 	sts triangle_fx_Qxy_target+1, zero
002150 9220 2902                 	sts triangle_fx_Rxy_target, zero
002152 9220 2903                 	sts triangle_fx_Rxy_target+1, zero
002154 d00f                      	rcall sound_driver_channel2_instrument_change_read_header
002155 93c0 28dd                 	sts triangle_hi_pitch_macro_release, r28
002157 93d0 28dc                 	sts triangle_hi_pitch_macro_loop, r29
002159 cfa6                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_duty:
00215a 93c0 28de                 	sts triangle_duty_macro, r28
00215c 93d0 28df                 	sts triangle_duty_macro+1, r29
00215e d005                      	rcall sound_driver_channel2_instrument_change_read_header
00215f 93c0 28e2                 	sts triangle_duty_macro_release, r28
002161 93d0 28e1                 	sts triangle_duty_macro_loop, r29
002163 cf9c                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_read_header:
002164 93ef                      	push ZL
002165 93ff                      	push ZH
002166 2fec                      	mov ZL, r28
002167 2ffd                      	mov ZH, r29
002168 0fee                      	lsl ZL
002169 1fff                      	rol ZH
00216a 91c5                      	lpm r28, Z+
00216b 91d4                      	lpm r29, Z
00216c 91ff                      	pop ZH
00216d 91ef                      	pop ZL
00216e 9508                      	ret
                                 
                                 sound_driver_channel2_instrument_change_read_header_arpeggio:
00216f 93ef                      	push ZL
002170 93ff                      	push ZH
002171 2fec                      	mov ZL, r28
002172 2ffd                      	mov ZH, r29
002173 0fee                      	lsl ZL
002174 1fff                      	rol ZH
002175 91c5                      	lpm r28, Z+
002176 91d5                      	lpm r29, Z+
002177 93c0 28cf                 	sts triangle_arpeggio_macro_release, r28
002179 93d0 28ce                 	sts triangle_arpeggio_macro_loop, r29
00217b 91c4                      	lpm r28, Z
00217c 93c0 28d0                 	sts triangle_arpeggio_macro_mode, r28
00217e 91ff                      	pop ZH
00217f 91ef                      	pop ZL
002180 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel2_release:
                                 sound_driver_channel2_release_volume:
002181 91b0 28ca                 	lds r27, triangle_volume_macro_release
002183 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
002184 f019                      	breq sound_driver_channel2_release_arpeggio //if the macro has no release flag, check the next macro
002185 95b3                      	inc r27
002186 93b0 28c8                 	sts triangle_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel2_release_arpeggio:
002188 91b0 28cf                 	lds r27, triangle_arpeggio_macro_release
00218a 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
00218b f019                      	breq sound_driver_channel2_release_pitch
00218c 95b3                      	inc r27
00218d 93b0 28cd                 	sts triangle_arpeggio_macro_offset, r27
                                 sound_driver_channel2_release_pitch:
00218f 91b0 28d7                 	lds r27, triangle_pitch_macro_release
002191 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
002192 f019                      	breq sound_driver_channel2_release_hi_pitch
002193 95b3                      	inc r27
002194 93b0 28d5                 	sts triangle_pitch_macro_offset, r27
                                 sound_driver_channel2_release_hi_pitch:
002196 91b0 28dd                 	lds r27, triangle_hi_pitch_macro_release
002198 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
002199 f019                      	breq sound_driver_channel2_release_duty
00219a 95b3                      	inc r27
00219b 93b0 28db                 	sts triangle_hi_pitch_macro_offset, r27
                                 sound_driver_channel2_release_duty:
00219d 91b0 28e2                 	lds r27, triangle_duty_macro_release
00219f 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
0021a0 f019                      	breq sound_driver_channel2_release_exit
0021a1 95b3                      	inc r27
0021a2 93b0 28e0                 	sts triangle_duty_macro_offset, r27
                                 sound_driver_channel2_release_exit:
0021a4 d019                      	rcall sound_driver_channel2_increment_offset
0021a5 cd6d                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_next_pattern:
0021a6 91e0 2818                 	lds ZL, song_frames
0021a8 91f0 2819                 	lds ZH, song_frames+1
0021aa 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
0021ac 91b0 281b                 	lds r27, song_frame_offset+1
0021ae 9614                      	adiw r27:r26, 4 //offset for channel 2
0021af 0fea                      	add ZL, r26
0021b0 1ffb                      	adc ZH, r27
                                 
0021b1 91a5                      	lpm r26, Z+ //load the address of the next pattern
0021b2 91b4                      	lpm r27, Z
0021b3 0faa                      	lsl r26
0021b4 1fbb                      	rol r27
0021b5 93a0 28c0                 	sts triangle_pattern, r26
0021b7 93b0 28c1                 	sts triangle_pattern+1, r27
                                 
0021b9 9220 28c4                 	sts triangle_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
0021bb 9220 28c5                 	sts triangle_pattern_offset+1, zero
0021bd cd55                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_increment_offset:
0021be 91e0 28c4                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
0021c0 91f0 28c5                 	lds ZH, triangle_pattern_offset+1
0021c2 9631                      	adiw Z, 1
0021c3 93e0 28c4                 	sts triangle_pattern_offset, ZL
0021c5 93f0 28c5                 	sts triangle_pattern_offset+1, ZH
0021c7 9508                      	ret
                                 
                                 sound_driver_channel2_increment_offset_twice: //used for data that takes up 2 bytes worth of space
0021c8 91e0 28c4                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
0021ca 91f0 28c5                 	lds ZH, triangle_pattern_offset+1
0021cc 9632                      	adiw Z, 2 //increment the pointer twice
0021cd 93e0 28c4                 	sts triangle_pattern_offset, ZL
0021cf 93f0 28c5                 	sts triangle_pattern_offset+1, ZH
0021d1 9508                      	ret
                                 
                                 sound_driver_channel2_decrement_frame_delay:
0021d2 95ba                      	dec r27
0021d3 93b0 28c3                 	sts triangle_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel3:
0021d5 91a0 290c                 	lds r26, noise_pattern_delay_rows
0021d7 91b0 290d                 	lds r27, noise_pattern_delay_frames
0021d9 9610                      	adiw r27:r26, 0
0021da f009                      	breq sound_driver_channel3_main //if the pattern delay is 0, proceed with sound driver procedures
0021db c2cd                      	rjmp sound_driver_channel3_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel3_main:
0021dc 91e0 290a                 	lds ZL, noise_pattern //current pattern for noise
0021de 91f0 290b                 	lds ZH, noise_pattern+1
0021e0 91a0 290e                 	lds r26, noise_pattern_offset //current offset in the pattern for noise
0021e2 91b0 290f                 	lds r27, noise_pattern_offset+1
0021e4 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
0021e5 1ffb                      	adc ZH, r27
0021e6 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel3_check_if_note: //check if data is a note (0x00 - 0x56)
0021e7 35b7                      	cpi r27, 0x57
0021e8 f408                      	brsh sound_driver_channel3_check_if_volume
0021e9 c176                      	rjmp sound_driver_channel3_note
                                 sound_driver_channel3_check_if_volume: //check if data is volume (0x57-0x66)
0021ea 36b7                      	cpi r27, 0x67
0021eb f408                      	brsh sound_driver_channel3_check_if_delay
0021ec c1ad                      	rjmp sound_driver_channel3_volume
                                 sound_driver_channel3_check_if_delay: //check if data is a delay (0x67 - 0xE2)
0021ed 3eb3                      	cpi r27, 0xE3
0021ee f408                      	brsh sound_driver_channel3_check_if_instrument
0021ef c1b3                      	rjmp sound_driver_channel3_delay
                                 sound_driver_channel3_check_if_instrument: //check for instrument flag (0xE3)
0021f0 f409                      	brne sound_driver_channel3_check_if_release
0021f1 c1b6                      	rjmp sound_driver_channel3_instrument_change 
                                 sound_driver_channel3_check_if_release: //check for note release flag (0xE4)
0021f2 3eb4                      	cpi r27, 0xE4
0021f3 f409                      	brne sound_driver_channel3_check_if_end
0021f4 c25f                      	rjmp sound_driver_channel3_release
                                 sound_driver_channel3_check_if_end:
0021f5 3fbf                      	cpi r27, 0xFF
0021f6 f409                      	brne sound_driver_channel3_check_if_fx
0021f7 c281                      	rjmp sound_driver_channel3_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel3_check_if_fx: //fx flags (0xE5 - 0xFE)
0021f8 9631                      	adiw Z, 1 //point Z to the byte next to the flag
0021f9 91a4                      	lpm r26, Z //load the fx data into r26
0021fa d2a4                      	rcall sound_driver_channel3_increment_offset_twice
                                 
0021fb 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
0021fc e9e2                      	ldi ZL, LOW(channel3_fx << 1) //load in note table
0021fd e6f5                      	ldi ZH, HIGH(channel3_fx << 1)
0021fe 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
0021ff 0feb                      	add ZL, r27 //add offset
002200 1df2                      	adc ZH, zero
002201 91c5                      	lpm r28, Z+ //load address bytes
002202 91d4                      	lpm r29, Z
002203 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
002204 2ffd                      	mov ZH, r29
002205 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel3_fx_0xy:
002206 93a0 292d                 	sts noise_fx_0xy_sequence, r26
002208 9220 292e                 	sts noise_fx_0xy_sequence+1, zero
00220a cfd1                      	rjmp sound_driver_channel3_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel3_fx_1xx:
00220b 9220 2933                 	sts noise_fx_2xx, zero //turn off any 2xx pitch slide down
00220d 9220 2934                 	sts noise_fx_2xx+1, zero
00220f 9220 292d                 	sts noise_fx_0xy_sequence, zero //disable any 0xy effect
002211 9220 292e                 	sts noise_fx_0xy_sequence+1, zero
002213 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002214 937f                      	push r23
002215 2f6a                      	mov r22, r26 //store the rate into r22
002216 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002217 9f67                      	mul r22, r23
002218 917f                      	pop r23
002219 916f                      	pop r22
                                 
00221a 9416                      	lsr r1 //shift out the fractional bits
00221b 9407                      	ror r0
00221c 9416                      	lsr r1
00221d 9407                      	ror r0
00221e 9416                      	lsr r1
00221f 9407                      	ror r0
002220 9416                      	lsr r1
002221 9407                      	ror r0
002222 9200 292f                 	sts noise_fx_1xx, r0
002224 9210 2930                 	sts noise_fx_1xx+1, r1
002226 cfb5                      	rjmp sound_driver_channel3_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel3_fx_2xx:
002227 9220 292f                 	sts noise_fx_1xx, zero //turn off any 1xx pitch slide down
002229 9220 2930                 	sts noise_fx_1xx+1, zero
00222b 9220 292d                 	sts noise_fx_0xy_sequence, zero //disable any 0xy effect
00222d 9220 292e                 	sts noise_fx_0xy_sequence+1, zero
00222f 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002230 937f                      	push r23
002231 2f6a                      	mov r22, r26 //store the rate into r22
002232 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002233 9f67                      	mul r22, r23
002234 917f                      	pop r23
002235 916f                      	pop r22
                                 
002236 9416                      	lsr r1 //shift out the fractional bits
002237 9407                      	ror r0
002238 9416                      	lsr r1
002239 9407                      	ror r0
00223a 9416                      	lsr r1
00223b 9407                      	ror r0
00223c 9416                      	lsr r1
00223d 9407                      	ror r0
00223e 9200 2933                 	sts noise_fx_2xx, r0
002240 9210 2934                 	sts noise_fx_2xx+1, r1
002242 cf99                      	rjmp sound_driver_channel3_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel3_fx_3xx:
002243 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002244 937f                      	push r23
002245 2f6a                      	mov r22, r26 //store the rate into r22
002246 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002247 9f67                      	mul r22, r23
002248 917f                      	pop r23
002249 916f                      	pop r22
                                 
00224a 9416                      	lsr r1 //shift out the fractional bits
00224b 9407                      	ror r0
00224c 9416                      	lsr r1
00224d 9407                      	ror r0
00224e 9416                      	lsr r1
00224f 9407                      	ror r0
002250 9416                      	lsr r1
002251 9407                      	ror r0
002252 9200 293b                 	sts noise_fx_3xx_speed, r0
002254 9210 293c                 	sts noise_fx_3xx_speed+1, r1
                                 
002256 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
002257 c001                      	rjmp sound_driver_channel3_fx_3xx_enabled
002258 cf83                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_3xx_enabled:
002259 91a0 0abc                 	lds r26, TCB3_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
00225b 91b0 0abd                 	lds r27, TCB3_CCMPH
00225d 93a0 2937                 	sts noise_fx_3xx_start, r26
00225f 93b0 2938                 	sts noise_fx_3xx_start+1, r27
                                 
002261 9220 293d                 	sts noise_fx_3xx_total_offset, zero
002263 9220 293e                 	sts noise_fx_3xx_total_offset+1, zero
002265 cf76                      	rjmp sound_driver_channel3_main
                                 
                                 //VIBRATO
                                 sound_driver_channel3_fx_4xy:
002266 2fba                      	mov r27, r26
002267 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
002268 95a2                      	swap r26
002269 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
00226a 93a0 293f                 	sts noise_fx_4xy_speed, r26
00226c 93b0 2940                 	sts noise_fx_4xy_depth, r27
00226e 9220 2941                 	sts noise_fx_4xy_phase, zero //reset the phase to 0
002270 cf6b                      	rjmp sound_driver_channel3_main
                                 
                                 //TREMELO
                                 sound_driver_channel3_fx_7xy:
002271 2fba                      	mov r27, r26
002272 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
002273 95a2                      	swap r26
002274 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
002275 93a0 2942                 	sts noise_fx_7xy_speed, r26
002277 93b0 2943                 	sts noise_fx_7xy_depth, r27
002279 9220 2944                 	sts noise_fx_7xy_phase, zero //reset the phase to 0
00227b 9220 2945                 	sts noise_fx_7xy_value, zero //reset the tremelo value
00227d cf5e                      	rjmp sound_driver_channel3_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel3_fx_Axy:
00227e 93a0 2946                 	sts noise_fx_Axy, r26
002280 cf5b                      	rjmp sound_driver_channel3_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel3_fx_Bxx:
002281 93a0 281f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
002283 cf58                      	rjmp sound_driver_channel3_main
                                 
                                 //HALT
                                 sound_driver_channel3_fx_Cxx:
002284 93b0 2820                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
002286 cf55                      	rjmp sound_driver_channel3_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel3_fx_Dxx:
002287 93b0 2821                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
002289 cf52                      	rjmp sound_driver_channel3_main
                                 
                                 //VOLUME
                                 sound_driver_channel3_fx_Exx:
00228a 91b0 2813                 	lds r27, noise_param
00228c 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
00228d 2bba                      	or r27, r26 //move new VVVV bits into noise_param
00228e 93b0 2813                 	sts noise_param, r27
002290 cf4b                      	rjmp sound_driver_channel3_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel3_fx_Fxx:
002291 93a0 281e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
002293 cf48                      	rjmp sound_driver_channel3_main
                                 
                                 //DELAY
                                 sound_driver_channel3_fx_Gxx:
002294 15a2                      	cp r26, zero
002295 f051                      	breq sound_driver_channel3_fx_Gxx_invalid
002296 91b0 281e                 	lds r27, song_speed
002298 17ab                      	cp r26, r27
002299 f430                      	brsh sound_driver_channel3_fx_Gxx_invalid
00229a 93a0 2947                 	sts noise_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
00229c e0b1                      	ldi r27, 0x01
00229d 93b0 290c                 	sts noise_pattern_delay_rows, r27
00229f c20c                      	rjmp sound_driver_channel4
                                 sound_driver_channel3_fx_Gxx_invalid:
0022a0 cf3b                      	rjmp sound_driver_channel3_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel3_fx_Hxy: //hardware sweep up
0022a1 cf3a                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Ixy: //hardware sweep down
0022a2 cf39                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Hxx: //FDS modulation depth
0022a3 cf38                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Ixx: //FDS modulation speed
0022a4 cf37                      	rjmp sound_driver_channel3_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel3_fx_Pxx:
0022a5 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0022a6 937f                      	push r23
0022a7 2f6a                      	mov r22, r26
0022a8 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0022a9 0367                      	mulsu r22, r23
0022aa 917f                      	pop r23
0022ab 916f                      	pop r22
0022ac 9416                      	lsr r1 //shift out the fractional bits
0022ad 9407                      	ror r0
0022ae 9416                      	lsr r1
0022af 9407                      	ror r0
0022b0 9416                      	lsr r1
0022b1 9407                      	ror r0
0022b2 9416                      	lsr r1
0022b3 9407                      	ror r0
0022b4 fe13                      	sbrs r1, 3 //check if result was a negative number
0022b5 c002                      	rjmp sound_driver_channel3_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel3_fx_Pxx_negative:
0022b6 efb0                      	ldi r27, 0xF0
0022b7 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel3_fx_Pxx_store:
0022b8 9200 2949                 	sts noise_fx_Pxx_total, r0
0022ba 9210 294a                 	sts noise_fx_Pxx_total+1, r1
0022bc cf1f                      	rjmp sound_driver_channel3_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel3_fx_Qxy:
                                 sound_driver_channel3_fx_Qxy_check_arpeggio_macro:
0022bd 91e0 2915                 	lds ZL, noise_arpeggio_macro
0022bf 91f0 2916                 	lds ZH, noise_arpeggio_macro+1
0022c1 9630                      	adiw Z, 0
0022c2 f009                      	breq sound_driver_channel3_fx_Qxy_check_pitch_macro
0022c3 cf18                      	rjmp sound_driver_channel3_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Qxy_check_pitch_macro:
0022c4 91e0 291d                 	lds ZL, noise_pitch_macro
0022c6 91f0 291e                 	lds ZH, noise_pitch_macro+1
0022c8 9630                      	adiw Z, 0
0022c9 f009                      	breq sound_driver_channel3_fx_Qxy_check_hi_pitch_macro
0022ca cf11                      	rjmp sound_driver_channel3_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Qxy_check_hi_pitch_macro:
0022cb 91e0 2923                 	lds ZL, noise_hi_pitch_macro
0022cd 91f0 2924                 	lds ZH, noise_hi_pitch_macro+1
0022cf 9630                      	adiw Z, 0
0022d0 f009                      	breq sound_driver_channel3_fx_Qxy_process
0022d1 cf0a                      	rjmp sound_driver_channel3_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Qxy_process:
0022d2 2fba                      	mov r27, r26 //copy fx parameters into r27
0022d3 70bf                      	andi r27, 0x0F //mask note index offset
0022d4 91c0 2817                 	lds r28, noise_note //load current note index
0022d6 0fbc                      	add r27, r28
0022d7 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
0022d8 f008                      	brlo sound_driver_channel3_fx_Qxy_process_continue
0022d9 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel3_fx_Qxy_process_continue:
0022da e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0022db e0f0                      	ldi ZH, HIGH(note_table << 1)
0022dc 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
0022dd 0feb                      	add ZL, r27 //add offset
0022de 1df2                      	adc ZH, zero
0022df 91c5                      	lpm r28, Z+ //load bytes
0022e0 91d4                      	lpm r29, Z
0022e1 93c0 294b                 	sts noise_fx_Qxy_target, r28 //load the LOW bits for the target period
0022e3 93d0 294c                 	sts noise_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
0022e5 95a2                      	swap r26
0022e6 70af                      	andi r26, 0x0F //mask effect speed
0022e7 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0022e8 95a3                      	inc r26 //increment the speed by 1
                                 
0022e9 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0022ea 937f                      	push r23
0022eb 2f6a                      	mov r22, r26 //store the speed data into r27
0022ec eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0022ed 9f67                      	mul r22, r23
0022ee 917f                      	pop r23
0022ef 916f                      	pop r22
                                 
0022f0 9416                      	lsr r1 //shift out the fractional bits
0022f1 9407                      	ror r0
0022f2 9416                      	lsr r1
0022f3 9407                      	ror r0
0022f4 9416                      	lsr r1
0022f5 9407                      	ror r0
0022f6 9416                      	lsr r1
0022f7 9407                      	ror r0
                                 
0022f8 9200 294d                 	sts noise_fx_Qxy_speed, r0 //store the effect speed
0022fa 9210 294e                 	sts noise_fx_Qxy_speed+1, r1
0022fc 9220 294f                 	sts noise_fx_Qxy_total_offset, zero
0022fe 9220 2950                 	sts noise_fx_Qxy_total_offset+1, zero
002300 cedb                      	rjmp sound_driver_channel3_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel3_fx_Rxy:
                                 sound_driver_channel3_fx_Rxy_check_arpeggio_macro:
002301 91e0 2915                 	lds ZL, noise_arpeggio_macro
002303 91f0 2916                 	lds ZH, noise_arpeggio_macro+1
002305 9630                      	adiw Z, 0
002306 f009                      	breq sound_driver_channel3_fx_Rxy_check_pitch_macro
002307 ced4                      	rjmp sound_driver_channel3_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Rxy_check_pitch_macro:
002308 91e0 291d                 	lds ZL, noise_pitch_macro
00230a 91f0 291e                 	lds ZH, noise_pitch_macro+1
00230c 9630                      	adiw Z, 0
00230d f009                      	breq sound_driver_channel3_fx_Rxy_check_hi_pitch_macro
00230e cecd                      	rjmp sound_driver_channel3_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Rxy_check_hi_pitch_macro:
00230f 91e0 2923                 	lds ZL, noise_hi_pitch_macro
002311 91f0 2924                 	lds ZH, noise_hi_pitch_macro+1
002313 9630                      	adiw Z, 0
002314 f009                      	breq sound_driver_channel3_fx_Rxy_process
002315 cec6                      	rjmp sound_driver_channel3_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Rxy_process:
002316 2fba                      	mov r27, r26 //copy fx parameters into r27
002317 70bf                      	andi r27, 0x0F //mask note index offset
002318 91c0 2817                 	lds r28, noise_note //load current note index
00231a 1bcb                      	sub r28, r27
00231b f408                      	brcc sound_driver_channel3_fx_Rxy_process_continue
00231c e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel3_fx_Rxy_process_continue:
00231d e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
00231e e0f0                      	ldi ZH, HIGH(note_table << 1)
00231f 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
002320 0fec                      	add ZL, r28 //add offset
002321 1df2                      	adc ZH, zero
002322 91c5                      	lpm r28, Z+ //load bytes
002323 91d4                      	lpm r29, Z
002324 93c0 2951                 	sts noise_fx_Rxy_target, r28 //load the LOW bits for the target period
002326 93d0 2952                 	sts noise_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
002328 95a2                      	swap r26
002329 70af                      	andi r26, 0x0F //mask effect speed
00232a 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
00232b 95a3                      	inc r26 //increment the speed by 1
                                 
00232c 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00232d 937f                      	push r23
00232e 2f6a                      	mov r22, r26 //store the speed data into r27
00232f eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002330 9f67                      	mul r22, r23
002331 917f                      	pop r23
002332 916f                      	pop r22
                                 
002333 9416                      	lsr r1 //shift out the fractional bits
002334 9407                      	ror r0
002335 9416                      	lsr r1
002336 9407                      	ror r0
002337 9416                      	lsr r1
002338 9407                      	ror r0
002339 9416                      	lsr r1
00233a 9407                      	ror r0
                                 
00233b 9200 2953                 	sts noise_fx_Rxy_speed, r0 //store the effect speed
00233d 9210 2954                 	sts noise_fx_Rxy_speed+1, r1
00233f 9220 2955                 	sts noise_fx_Rxy_total_offset, zero
002341 9220 2956                 	sts noise_fx_Rxy_total_offset+1, zero
002343 ce98                      	rjmp sound_driver_channel3_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel3_fx_Sxx:
002344 15a2                      	cp r26, zero
002345 f051                      	breq sound_driver_channel3_fx_Sxx_invalid
002346 91b0 281e                 	lds r27, song_speed
002348 17ab                      	cp r26, r27
002349 f430                      	brsh sound_driver_channel3_fx_Sxx_invalid
00234a 93a0 2957                 	sts noise_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
00234c e0b1                      	ldi r27, 0x01
00234d 93b0 290c                 	sts noise_pattern_delay_rows, r27
00234f c15c                      	rjmp sound_driver_channel4
                                 sound_driver_channel3_fx_Sxx_invalid:
002350 ce8b                      	rjmp sound_driver_channel3_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel3_fx_Vxx:
002351 95a6                      	lsr r26
002352 95a7                      	ror r26 //move mode bit to bit 7
002353 91b0 2814                 	lds r27, noise_period
002355 77bf                      	andi r27, 0b01111111
002356 2bba                      	or r27, r26 //store the new noise mode
002357 93b0 2813                 	sts noise_param, r27
                                 
002359 776f                      	andi noise_sequence_HIGH, 0b01111111
00235a 2b6a                      	or noise_sequence_HIGH, r26
00235b ce80                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_Wxx: //DPCM sample speed
00235c ce7f                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Xxx: //DPCM sample retrigger
00235d ce7e                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Yxx: //DPCM sample offset
00235e ce7d                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Zxx: //DPCM sample delta counter
00235f ce7c                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 sound_driver_channel3_note:
002360 93b0 2817                 	sts noise_note, r27 //store the note index
002362 e0a3                      	ldi r26, 0x03
002363 e0b2                      	ldi r27, 0x02
002364 93b0 2912                 	sts noise_volume_macro_offset, r27 //reset all macro offsets
002366 93a0 2917                 	sts noise_arpeggio_macro_offset, r26
002368 93b0 291f                 	sts noise_pitch_macro_offset, r27
00236a 93b0 2925                 	sts noise_hi_pitch_macro_offset, r27
00236c 93b0 292a                 	sts noise_duty_macro_offset, r27
00236e 9220 291b                 	sts noise_total_pitch_offset, zero //reset the pitch and hi pitch offset
002370 9220 291c                 	sts noise_total_pitch_offset+1, zero
002372 9220 2922                 	sts noise_total_hi_pitch_offset, zero
002374 9220 2931                 	sts noise_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
002376 9220 2932                 	sts noise_fx_1xx_total+1, zero
002378 9220 2935                 	sts noise_fx_2xx_total, zero
00237a 9220 2936                 	sts noise_fx_2xx_total+1, zero
00237c 9220 293d                 	sts noise_fx_3xx_total_offset, zero //reset 3xx offset
00237e 9220 293e                 	sts noise_fx_3xx_total_offset+1, zero
002380 91a0 0abc                 	lds r26, TCB3_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
002382 91b0 0abd                 	lds r27, TCB3_CCMPH
002384 93a0 2937                 	sts noise_fx_3xx_start, r26
002386 93b0 2938                 	sts noise_fx_3xx_start+1, r27
002388 9220 294b                 	sts noise_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00238a 9220 294c                 	sts noise_fx_Qxy_target+1, zero
00238c 9220 294f                 	sts noise_fx_Qxy_total_offset, zero
00238e 9220 2950                 	sts noise_fx_Qxy_total_offset+1, zero
002390 9220 2951                 	sts noise_fx_Rxy_target, zero
002392 9220 2952                 	sts noise_fx_Rxy_target+1, zero
002394 9220 2955                 	sts noise_fx_Rxy_total_offset, zero
002396 9220 2956                 	sts noise_fx_Rxy_total_offset+1, zero
002398 d0fc                      	rcall sound_driver_channel3_increment_offset
002399 ce42                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_volume:
00239a 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
00239b 91a0 2813                 	lds r26, noise_param
00239d 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
00239e 2bab                      	or r26, r27 //move new VVVV bits into noise_param
00239f 93a0 2813                 	sts noise_param, r26
0023a1 d0f3                      	rcall sound_driver_channel3_increment_offset
0023a2 ce39                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_delay:
0023a3 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
0023a4 93b0 290c                 	sts noise_pattern_delay_rows, r27
0023a6 d0ee                      	rcall sound_driver_channel3_increment_offset
0023a7 c104                      	rjmp sound_driver_channel4
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change:
0023a8 9220 2910                 	sts noise_volume_macro, zero //reset all macro addresses
0023aa 9220 2911                 	sts noise_volume_macro+1, zero
0023ac 9220 2915                 	sts noise_arpeggio_macro, zero
0023ae 9220 2916                 	sts noise_arpeggio_macro+1, zero
0023b0 9220 291d                 	sts noise_pitch_macro, zero
0023b2 9220 291e                 	sts noise_pitch_macro+1, zero
0023b4 9220 2923                 	sts noise_hi_pitch_macro, zero
0023b6 9220 2924                 	sts noise_hi_pitch_macro+1, zero
0023b8 9220 2928                 	sts noise_duty_macro, zero
0023ba 9220 2929                 	sts noise_duty_macro+1, zero
0023bc 9220 291b                 	sts noise_total_pitch_offset, zero //reset the pitch offset
0023be 9220 291c                 	sts noise_total_pitch_offset+1, zero
0023c0 9220 2922                 	sts noise_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
0023c2 9631                      	adiw Z, 1 //point to the byte next to the flag
0023c3 91b4                      	lpm r27, Z //store the instrument offset into r27
0023c4 e8ec                      	ldi ZL, LOW(instruments) //point Z to instruments table
0023c5 e1f2                      	ldi ZH, HIGH(instruments)
0023c6 0feb                      	add ZL, r27 //point Z to offsetted instrument
0023c7 1df2                      	adc ZH, zero
0023c8 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
0023c9 1fff                      	rol ZH
0023ca 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
0023cb 91b4                      	lpm r27, Z
                                 
0023cc 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
0023cd 1fbb                      	rol r27
0023ce 2fea                      	mov ZL, r26
0023cf 2ffb                      	mov ZH, r27
0023d0 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
0023d1 9632                      	adiw Z, 2 //point Z to the address of the macro
0023d2 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel3_instrument_change_macro_loop:
0023d3 95aa                      	dec r26
0023d4 f019                      	breq sound_driver_channel3_instrument_change_exit
0023d5 95b6                      	lsr r27
0023d6 f078                      	brcs sound_driver_channel3_instrument_change_load_macro
0023d7 cffb                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_exit:
0023d8 e0a3                      	ldi r26, 0x03
0023d9 e0b2                      	ldi r27, 0x02
0023da 93b0 2912                 	sts noise_volume_macro_offset, r27 //reset all macro offsets
0023dc 93a0 2917                 	sts noise_arpeggio_macro_offset, r26
0023de 93b0 291f                 	sts noise_pitch_macro_offset, r27
0023e0 93b0 2925                 	sts noise_hi_pitch_macro_offset, r27
0023e2 93b0 292a                 	sts noise_duty_macro_offset, r27
0023e4 d0ba                      	rcall sound_driver_channel3_increment_offset_twice
0023e5 cdf6                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_load_macro:
0023e6 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
0023e7 91d5                      	lpm r29, Z+
                                 
0023e8 30a5                      	cpi r26, 5
0023e9 f039                      	breq sound_driver_channel3_instrument_change_load_macro_volume
0023ea 30a4                      	cpi r26, 4
0023eb f079                      	breq sound_driver_channel3_instrument_change_load_macro_arpeggio
0023ec 30a3                      	cpi r26, 3
0023ed f0d9                      	breq sound_driver_channel3_instrument_change_load_macro_pitch
0023ee 30a2                      	cpi r26, 2
0023ef f159                      	breq sound_driver_channel3_instrument_change_load_macro_hi_pitch
0023f0 c03c                      	rjmp sound_driver_channel3_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel3_instrument_change_load_macro_volume:
0023f1 93c0 2910                 	sts noise_volume_macro, r28
0023f3 93d0 2911                 	sts noise_volume_macro+1, r29
0023f5 d041                      	rcall sound_driver_channel3_instrument_change_read_header
0023f6 93c0 2914                 	sts noise_volume_macro_release, r28
0023f8 93d0 2913                 	sts noise_volume_macro_loop, r29
0023fa cfd8                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 	
                                 sound_driver_channel3_instrument_change_load_macro_arpeggio:
0023fb 93c0 2915                 	sts noise_arpeggio_macro, r28
0023fd 93d0 2916                 	sts noise_arpeggio_macro+1, r29
0023ff 9220 294b                 	sts noise_fx_Qxy_target, zero //reset the Qxy, Rxy effects
002401 9220 294c                 	sts noise_fx_Qxy_target+1, zero
002403 9220 2951                 	sts noise_fx_Rxy_target, zero
002405 9220 2952                 	sts noise_fx_Rxy_target+1, zero
002407 d03a                      	rcall sound_driver_channel3_instrument_change_read_header_arpeggio
002408 cfca                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_pitch:
002409 93c0 291d                 	sts noise_pitch_macro, r28
00240b 93d0 291e                 	sts noise_pitch_macro+1, r29
00240d 9220 294b                 	sts noise_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00240f 9220 294c                 	sts noise_fx_Qxy_target+1, zero
002411 9220 2951                 	sts noise_fx_Rxy_target, zero
002413 9220 2952                 	sts noise_fx_Rxy_target+1, zero
002415 d021                      	rcall sound_driver_channel3_instrument_change_read_header
002416 93c0 2921                 	sts noise_pitch_macro_release, r28
002418 93d0 2920                 	sts noise_pitch_macro_loop, r29
00241a cfb8                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_hi_pitch:
00241b 93c0 2923                 	sts noise_hi_pitch_macro, r28
00241d 93d0 2924                 	sts noise_hi_pitch_macro+1, r29
00241f 9220 294b                 	sts noise_fx_Qxy_target, zero //reset the Qxy, Rxy effects
002421 9220 294c                 	sts noise_fx_Qxy_target+1, zero
002423 9220 2951                 	sts noise_fx_Rxy_target, zero
002425 9220 2952                 	sts noise_fx_Rxy_target+1, zero
002427 d00f                      	rcall sound_driver_channel3_instrument_change_read_header
002428 93c0 2927                 	sts noise_hi_pitch_macro_release, r28
00242a 93d0 2926                 	sts noise_hi_pitch_macro_loop, r29
00242c cfa6                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_duty:
00242d 93c0 2928                 	sts noise_duty_macro, r28
00242f 93d0 2929                 	sts noise_duty_macro+1, r29
002431 d005                      	rcall sound_driver_channel3_instrument_change_read_header
002432 93c0 292c                 	sts noise_duty_macro_release, r28
002434 93d0 292b                 	sts noise_duty_macro_loop, r29
002436 cf9c                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_read_header:
002437 93ef                      	push ZL
002438 93ff                      	push ZH
002439 2fec                      	mov ZL, r28
00243a 2ffd                      	mov ZH, r29
00243b 0fee                      	lsl ZL
00243c 1fff                      	rol ZH
00243d 91c5                      	lpm r28, Z+
00243e 91d4                      	lpm r29, Z
00243f 91ff                      	pop ZH
002440 91ef                      	pop ZL
002441 9508                      	ret
                                 
                                 sound_driver_channel3_instrument_change_read_header_arpeggio:
002442 93ef                      	push ZL
002443 93ff                      	push ZH
002444 2fec                      	mov ZL, r28
002445 2ffd                      	mov ZH, r29
002446 0fee                      	lsl ZL
002447 1fff                      	rol ZH
002448 91c5                      	lpm r28, Z+
002449 91d5                      	lpm r29, Z+
00244a 93c0 2919                 	sts noise_arpeggio_macro_release, r28
00244c 93d0 2918                 	sts noise_arpeggio_macro_loop, r29
00244e 91c4                      	lpm r28, Z
00244f 93c0 291a                 	sts noise_arpeggio_macro_mode, r28
002451 91ff                      	pop ZH
002452 91ef                      	pop ZL
002453 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel3_release:
                                 sound_driver_channel3_release_volume:
002454 91b0 2914                 	lds r27, noise_volume_macro_release
002456 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
002457 f019                      	breq sound_driver_channel3_release_arpeggio //if the macro has no release flag, check the next macro
002458 95b3                      	inc r27
002459 93b0 2912                 	sts noise_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel3_release_arpeggio:
00245b 91b0 2919                 	lds r27, noise_arpeggio_macro_release
00245d 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
00245e f019                      	breq sound_driver_channel3_release_pitch
00245f 95b3                      	inc r27
002460 93b0 2917                 	sts noise_arpeggio_macro_offset, r27
                                 sound_driver_channel3_release_pitch:
002462 91b0 2921                 	lds r27, noise_pitch_macro_release
002464 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
002465 f019                      	breq sound_driver_channel3_release_hi_pitch
002466 95b3                      	inc r27
002467 93b0 291f                 	sts noise_pitch_macro_offset, r27
                                 sound_driver_channel3_release_hi_pitch:
002469 91b0 2927                 	lds r27, noise_hi_pitch_macro_release
00246b 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
00246c f019                      	breq sound_driver_channel3_release_duty
00246d 95b3                      	inc r27
00246e 93b0 2925                 	sts noise_hi_pitch_macro_offset, r27
                                 sound_driver_channel3_release_duty:
002470 91b0 292c                 	lds r27, noise_duty_macro_release
002472 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
002473 f019                      	breq sound_driver_channel3_release_exit
002474 95b3                      	inc r27
002475 93b0 292a                 	sts noise_duty_macro_offset, r27
                                 sound_driver_channel3_release_exit:
002477 d01d                      	rcall sound_driver_channel3_increment_offset
002478 cd63                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_next_pattern:
002479 91e0 2818                 	lds ZL, song_frames
00247b 91f0 2819                 	lds ZH, song_frames+1
00247d 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
00247f 91b0 281b                 	lds r27, song_frame_offset+1
002481 93a0 281a                 	sts song_frame_offset, r26
002483 93b0 281b                 	sts song_frame_offset+1, r27
002485 9616                      	adiw r27:r26, 6 //offset for channel 3
002486 0fea                      	add ZL, r26
002487 1ffb                      	adc ZH, r27
                                 
002488 91a5                      	lpm r26, Z+ //load the address of the next pattern
002489 91b4                      	lpm r27, Z
00248a 0faa                      	lsl r26
00248b 1fbb                      	rol r27
00248c 93a0 290a                 	sts noise_pattern, r26
00248e 93b0 290b                 	sts noise_pattern+1, r27
                                 
002490 9220 290e                 	sts noise_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
002492 9220 290f                 	sts noise_pattern_offset+1, zero
002494 cd47                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_increment_offset:
002495 91e0 290e                 	lds ZL, noise_pattern_offset //current offset in the pattern for noise
002497 91f0 290f                 	lds ZH, noise_pattern_offset+1
002499 9631                      	adiw Z, 1
00249a 93e0 290e                 	sts noise_pattern_offset, ZL
00249c 93f0 290f                 	sts noise_pattern_offset+1, ZH
00249e 9508                      	ret
                                 
                                 sound_driver_channel3_increment_offset_twice: //used for data that takes up 2 bytes worth of space
00249f 91e0 290e                 	lds ZL, noise_pattern_offset //current offset in the pattern for noise
0024a1 91f0 290f                 	lds ZH, noise_pattern_offset+1
0024a3 9632                      	adiw Z, 2 //increment the pointer twice
0024a4 93e0 290e                 	sts noise_pattern_offset, ZL
0024a6 93f0 290f                 	sts noise_pattern_offset+1, ZH
0024a8 9508                      	ret
                                 
                                 sound_driver_channel3_decrement_frame_delay:
0024a9 95ba                      	dec r27
0024aa 93b0 290d                 	sts noise_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel4:
                                 
                                 sound_driver_calculate_delays:
0024ac 91f0 281e                 	lds r31, song_speed
0024ae 2fef                      	mov r30, r31
0024af 50e1                      	subi r30, 1
                                 sound_driver_calculate_delays_pulse1:
0024b0 91a0 2825                 	lds r26, pulse1_pattern_delay_frames
0024b2 11a2                      	cpse r26, zero
0024b3 c042                      	rjmp sound_driver_calculate_delays_pulse2
0024b4 c000                      	rjmp sound_driver_calculate_delays_pulse1_main
                                 
                                 sound_driver_calculate_delays_pulse1_main:
0024b5 2faf                      	mov r26, r31 //move the speed to r26
0024b6 91b0 2824                 	lds r27, pulse1_pattern_delay_rows //decrement the delay rows
0024b8 15b2                      	cp r27, zero
0024b9 f409                      	brne PC+2
0024ba c03b                      	rjmp sound_driver_calculate_delays_pulse2
0024bb 95ba                      	dec r27
0024bc 93b0 2824                 	sts pulse1_pattern_delay_rows, r27
0024be 11b2                      	cpse r27, zero
0024bf c034                      	rjmp sound_driver_calculate_delays_pulse1_store
0024c0 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx:
0024c1 efbf                      	ldi r27, 0xFF
0024c2 91c0 286f                 	lds r28, pulse1_fx_Sxx_pre
0024c4 91d0 2870                 	lds r29, pulse1_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse1_Sxx_check_pre:
0024c6 17cb                      	cp r28, r27
0024c7 f009                      	breq sound_driver_calculate_delays_pulse1_Sxx_check_post
0024c8 c00d                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_pre
                                 sound_driver_calculate_delays_pulse1_Sxx_check_post:
0024c9 17db                      	cp r29, r27
0024ca f009                      	breq sound_driver_calculate_delays_pulse1_Gxx
0024cb c015                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx:
0024cc 91c0 285f                 	lds r28, pulse1_fx_Gxx_pre
0024ce 91d0 2860                 	lds r29, pulse1_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse1_Gxx_check_pre:
0024d0 17cb                      	cp r28, r27
0024d1 f009                      	breq sound_driver_calculate_delays_pulse1_Gxx_check_post
0024d2 c012                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_pre
                                 sound_driver_calculate_delays_pulse1_Gxx_check_post:
0024d3 17db                      	cp r29, r27
0024d4 f0f9                      	breq sound_driver_calculate_delays_pulse1_store
0024d5 c01a                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_pre:
0024d6 93b0 286f                 	sts pulse1_fx_Sxx_pre, r27
0024d8 1bec                      	sub r30, r28 //(song speed)-1-Sxx
0024d9 93e0 2870                 	sts pulse1_fx_Sxx_post, r30
0024db 95ca                      	dec r28
0024dc 93c0 2825                 	sts pulse1_pattern_delay_frames, r28
0024de 2fef                      	mov r30, r31
0024df 50e1                      	subi r30, 1
0024e0 c015                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_post:
0024e1 93b0 2870                 	sts pulse1_fx_Sxx_post, r27
0024e3 2fad                      	mov r26, r29
0024e4 c00f                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx_pre:
0024e5 93b0 285f                 	sts pulse1_fx_Gxx_pre, r27
0024e7 1bec                      	sub r30, r28 //(song speed)-1-Sxx
0024e8 93e0 2860                 	sts pulse1_fx_Gxx_post, r30
0024ea 95ca                      	dec r28
0024eb 93c0 2825                 	sts pulse1_pattern_delay_frames, r28
0024ed 2fef                      	mov r30, r31
0024ee 50e1                      	subi r30, 1
0024ef c006                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse1_Gxx_post:
0024f0 93b0 2860                 	sts pulse1_fx_Gxx_post, r27
0024f2 2fad                      	mov r26, r29
0024f3 c000                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_store:
0024f4 93a0 2825                 	sts pulse1_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_pulse2:
0024f6 91a0 2874                 	lds r26, pulse2_pattern_delay_frames
0024f8 11a2                      	cpse r26, zero
0024f9 c042                      	rjmp sound_driver_calculate_delays_triangle
0024fa c000                      	rjmp sound_driver_calculate_delays_pulse2_main
                                 
                                 sound_driver_calculate_delays_pulse2_main:
0024fb 2faf                      	mov r26, r31 //move the speed to r26
0024fc 91b0 2873                 	lds r27, pulse2_pattern_delay_rows //decrement the delay rows
0024fe 15b2                      	cp r27, zero
0024ff f409                      	brne PC+2
002500 c03b                      	rjmp sound_driver_calculate_delays_triangle
002501 95ba                      	dec r27
002502 93b0 2873                 	sts pulse2_pattern_delay_rows, r27
002504 11b2                      	cpse r27, zero
002505 c034                      	rjmp sound_driver_calculate_delays_pulse2_store
002506 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx:
002507 efbf                      	ldi r27, 0xFF
002508 91c0 28be                 	lds r28, pulse2_fx_Sxx_pre
00250a 91d0 28bf                 	lds r29, pulse2_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse2_Sxx_check_pre:
00250c 17cb                      	cp r28, r27
00250d f009                      	breq sound_driver_calculate_delays_pulse2_Sxx_check_post
00250e c00d                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_pre
                                 sound_driver_calculate_delays_pulse2_Sxx_check_post:
00250f 17db                      	cp r29, r27
002510 f009                      	breq sound_driver_calculate_delays_pulse2_Gxx
002511 c015                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx:
002512 91c0 28ae                 	lds r28, pulse2_fx_Gxx_pre
002514 91d0 28af                 	lds r29, pulse2_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse2_Gxx_check_pre:
002516 17cb                      	cp r28, r27
002517 f009                      	breq sound_driver_calculate_delays_pulse2_Gxx_check_post
002518 c012                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_pre
                                 sound_driver_calculate_delays_pulse2_Gxx_check_post:
002519 17db                      	cp r29, r27
00251a f0f9                      	breq sound_driver_calculate_delays_pulse2_store
00251b c01a                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_pre:
00251c 93b0 28be                 	sts pulse2_fx_Sxx_pre, r27
00251e 1bec                      	sub r30, r28 //(song speed)-1-Sxx
00251f 93e0 28bf                 	sts pulse2_fx_Sxx_post, r30
002521 95ca                      	dec r28
002522 93c0 2874                 	sts pulse2_pattern_delay_frames, r28
002524 2fef                      	mov r30, r31
002525 50e1                      	subi r30, 1
002526 cfcf                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_post:
002527 93b0 28bf                 	sts pulse2_fx_Sxx_post, r27
002529 2fad                      	mov r26, r29
00252a c00f                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx_pre:
00252b 93b0 28ae                 	sts pulse2_fx_Gxx_pre, r27
00252d 1bec                      	sub r30, r28 //(song speed)-1-Sxx
00252e 93e0 28af                 	sts pulse2_fx_Gxx_post, r30
002530 95ca                      	dec r28
002531 93c0 2874                 	sts pulse2_pattern_delay_frames, r28
002533 2fef                      	mov r30, r31
002534 50e1                      	subi r30, 1
002535 cfc0                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse2_Gxx_post:
002536 93b0 28af                 	sts pulse2_fx_Gxx_post, r27
002538 2fad                      	mov r26, r29
002539 c000                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_store:
00253a 93a0 2874                 	sts pulse2_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_triangle:
00253c 91a0 28c3                 	lds r26, triangle_pattern_delay_frames
00253e 11a2                      	cpse r26, zero
00253f c042                      	rjmp sound_driver_calculate_delays_noise
002540 c000                      	rjmp sound_driver_calculate_delays_triangle_main
                                 
                                 sound_driver_calculate_delays_triangle_main:
002541 2faf                      	mov r26, r31 //move the speed to r26
002542 91b0 28c2                 	lds r27, triangle_pattern_delay_rows //decrement the delay rows
002544 15b2                      	cp r27, zero
002545 f409                      	brne PC+2
002546 c03b                      	rjmp sound_driver_calculate_delays_noise
002547 95ba                      	dec r27
002548 93b0 28c2                 	sts triangle_pattern_delay_rows, r27
00254a 11b2                      	cpse r27, zero
00254b c034                      	rjmp sound_driver_calculate_delays_triangle_store
00254c 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_triangle_Sxx:
00254d efbf                      	ldi r27, 0xFF
00254e 91c0 2908                 	lds r28, triangle_fx_Sxx_pre
002550 91d0 2909                 	lds r29, triangle_fx_Sxx_post
                                 sound_driver_calculate_delays_triangle_Sxx_check_pre:
002552 17cb                      	cp r28, r27
002553 f009                      	breq sound_driver_calculate_delays_triangle_Sxx_check_post
002554 c00d                      	rjmp sound_driver_calculate_delays_triangle_Sxx_pre
                                 sound_driver_calculate_delays_triangle_Sxx_check_post:
002555 17db                      	cp r29, r27
002556 f009                      	breq sound_driver_calculate_delays_triangle_Gxx
002557 c015                      	rjmp sound_driver_calculate_delays_triangle_Sxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Gxx:
002558 91c0 28f8                 	lds r28, triangle_fx_Gxx_pre
00255a 91d0 28f9                 	lds r29, triangle_fx_Gxx_post
                                 sound_driver_calculate_delays_triangle_Gxx_check_pre:
00255c 17cb                      	cp r28, r27
00255d f009                      	breq sound_driver_calculate_delays_triangle_Gxx_check_post
00255e c012                      	rjmp sound_driver_calculate_delays_triangle_Gxx_pre
                                 sound_driver_calculate_delays_triangle_Gxx_check_post:
00255f 17db                      	cp r29, r27
002560 f0f9                      	breq sound_driver_calculate_delays_triangle_store
002561 c01a                      	rjmp sound_driver_calculate_delays_triangle_Gxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_pre:
002562 93b0 2908                 	sts triangle_fx_Sxx_pre, r27
002564 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002565 93e0 2909                 	sts triangle_fx_Sxx_post, r30
002567 95ca                      	dec r28
002568 93c0 28c3                 	sts triangle_pattern_delay_frames, r28
00256a 2fef                      	mov r30, r31
00256b 50e1                      	subi r30, 1
00256c c015                      	rjmp sound_driver_calculate_delays_noise
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_post:
00256d 93b0 2909                 	sts triangle_fx_Sxx_post, r27
00256f 2fad                      	mov r26, r29
002570 c00f                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_Gxx_pre:
002571 93b0 28f8                 	sts triangle_fx_Gxx_pre, r27
002573 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002574 93e0 28f9                 	sts triangle_fx_Gxx_post, r30
002576 95ca                      	dec r28
002577 93c0 28c3                 	sts triangle_pattern_delay_frames, r28
002579 2fef                      	mov r30, r31
00257a 50e1                      	subi r30, 1
00257b c006                      	rjmp sound_driver_calculate_delays_noise
                                 	
                                 sound_driver_calculate_delays_triangle_Gxx_post:
00257c 93b0 28f9                 	sts triangle_fx_Gxx_post, r27
00257e 2fad                      	mov r26, r29
00257f c000                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_store:
002580 93a0 28c3                 	sts triangle_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_noise:
002582 91a0 290d                 	lds r26, noise_pattern_delay_frames
002584 11a2                      	cpse r26, zero
002585 c042                      	rjmp sound_driver_calculate_delays_dpcm
002586 c000                      	rjmp sound_driver_calculate_delays_noise_main
                                 
                                 sound_driver_calculate_delays_noise_main:
002587 2faf                      	mov r26, r31 //move the speed to r26
002588 91b0 290c                 	lds r27, noise_pattern_delay_rows //decrement the delay rows
00258a 15b2                      	cp r27, zero
00258b f409                      	brne PC+2
00258c c03b                      	rjmp sound_driver_calculate_delays_dpcm
00258d 95ba                      	dec r27
00258e 93b0 290c                 	sts noise_pattern_delay_rows, r27
002590 11b2                      	cpse r27, zero
002591 c034                      	rjmp sound_driver_calculate_delays_noise_store
002592 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_noise_Sxx:
002593 efbf                      	ldi r27, 0xFF
002594 91c0 2957                 	lds r28, noise_fx_Sxx_pre
002596 91d0 2958                 	lds r29, noise_fx_Sxx_post
                                 sound_driver_calculate_delays_noise_Sxx_check_pre:
002598 17cb                      	cp r28, r27
002599 f009                      	breq sound_driver_calculate_delays_noise_Sxx_check_post
00259a c00d                      	rjmp sound_driver_calculate_delays_noise_Sxx_pre
                                 sound_driver_calculate_delays_noise_Sxx_check_post:
00259b 17db                      	cp r29, r27
00259c f009                      	breq sound_driver_calculate_delays_noise_Gxx
00259d c015                      	rjmp sound_driver_calculate_delays_noise_Sxx_post
                                 
                                 sound_driver_calculate_delays_noise_Gxx:
00259e 91c0 2947                 	lds r28, noise_fx_Gxx_pre
0025a0 91d0 2948                 	lds r29, noise_fx_Gxx_post
                                 sound_driver_calculate_delays_noise_Gxx_check_pre:
0025a2 17cb                      	cp r28, r27
0025a3 f009                      	breq sound_driver_calculate_delays_noise_Gxx_check_post
0025a4 c012                      	rjmp sound_driver_calculate_delays_noise_Gxx_pre
                                 sound_driver_calculate_delays_noise_Gxx_check_post:
0025a5 17db                      	cp r29, r27
0025a6 f0f9                      	breq sound_driver_calculate_delays_noise_store
0025a7 c01a                      	rjmp sound_driver_calculate_delays_noise_Gxx_post
                                 
                                 sound_driver_calculate_delays_noise_Sxx_pre:
0025a8 93b0 2957                 	sts noise_fx_Sxx_pre, r27
0025aa 1bec                      	sub r30, r28 //(song speed)-1-Sxx
0025ab 93e0 2958                 	sts noise_fx_Sxx_post, r30
0025ad 95ca                      	dec r28
0025ae 93c0 290d                 	sts noise_pattern_delay_frames, r28
0025b0 2fef                      	mov r30, r31
0025b1 50e1                      	subi r30, 1
0025b2 c015                      	rjmp sound_driver_calculate_delays_dpcm
                                 
                                 sound_driver_calculate_delays_noise_Sxx_post:
0025b3 93b0 2958                 	sts noise_fx_Sxx_post, r27
0025b5 2fad                      	mov r26, r29
0025b6 c00f                      	rjmp sound_driver_calculate_delays_noise_store
                                 
                                 sound_driver_calculate_delays_noise_Gxx_pre:
0025b7 93b0 2947                 	sts noise_fx_Gxx_pre, r27
0025b9 1bec                      	sub r30, r28 //(song speed)-1-Sxx
0025ba 93e0 2948                 	sts noise_fx_Gxx_post, r30
0025bc 95ca                      	dec r28
0025bd 93c0 290d                 	sts noise_pattern_delay_frames, r28
0025bf 2fef                      	mov r30, r31
0025c0 50e1                      	subi r30, 1
0025c1 c006                      	rjmp sound_driver_calculate_delays_dpcm
                                 	
                                 sound_driver_calculate_delays_noise_Gxx_post:
0025c2 93b0 2948                 	sts noise_fx_Gxx_post, r27
0025c4 2fad                      	mov r26, r29
0025c5 c000                      	rjmp sound_driver_calculate_delays_noise_store
                                 
                                 sound_driver_calculate_delays_noise_store:
0025c6 93a0 290d                 	sts noise_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_dpcm:
                                 
                                 sound_driver_instrument_fx_routine:
                                 sound_driver_instrument_routine_channel0_volume:
0025c8 91e0 2828                 	lds ZL, pulse1_volume_macro
0025ca 91f0 2829                 	lds ZH, pulse1_volume_macro+1
0025cc 9630                      	adiw Z, 0
0025cd f1a1                      	breq sound_driver_instrument_routine_channel0_volume_default //if no volume macro is in use, use default multiplier of F
0025ce 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0025cf 1fff                      	rol ZH
0025d0 91a0 282a                 	lds r26, pulse1_volume_macro_offset
0025d2 0fea                      	add ZL, r26
0025d3 1df2                      	adc ZH, zero
                                 
0025d4 91b0 282c                 	lds r27, pulse1_volume_macro_release
0025d6 17ba                      	cp r27, r26
0025d7 f429                      	brne sound_driver_instrument_routine_channel0_volume_increment //if the current offset is not equal to the release index, increment the offset
0025d8 91a0 282b                 	lds r26, pulse1_volume_macro_loop
0025da 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0025db f010                      	brlo sound_driver_instrument_routine_channel0_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0025dc c003                      	rjmp sound_driver_instrument_routine_channel0_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_volume_increment:
0025dd 95a3                      	inc r26 //increment the macro offset
0025de 93a0 282a                 	sts pulse1_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_volume_read:
0025e0 91b4                      	lpm r27, Z //load volume data into r27
0025e1 3fbf                      	cpi r27, 0xFF //check for macro end flag
0025e2 f469                      	brne sound_driver_instrument_routine_channel0_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_release:
0025e3 91b0 282c                 	lds r27, pulse1_volume_macro_release
0025e5 3fbf                      	cpi r27, 0xFF
0025e6 f429                      	brne sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_loop:
0025e7 91b0 282b                 	lds r27, pulse1_volume_macro_loop //load the loop index
0025e9 93b0 282a                 	sts pulse1_volume_macro_offset, r27 //store the loop index into the offset
0025eb cfdc                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index:
0025ec 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
0025ed 93a0 282a                 	sts pulse1_volume_macro_offset, r26
0025ef cfd8                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_calculate:
0025f0 ece6                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
0025f1 e6f5                      	ldi ZH, HIGH(volumes << 1)
0025f2 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
0025f3 0feb                      	add ZL, r27 //add offset to the table
0025f4 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel0_volume_load:
0025f5 91b0 2800                 	lds r27, pulse1_param //load main volume
0025f7 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
0025f8 91a0 285d                 	lds r26, pulse1_fx_7xy_value
0025fa 30a0                      	cpi r26, 0x00
0025fb f481                      	brne sound_driver_instrument_routine_channel0_volume_load_7xy
                                 
0025fc 0feb                      	add ZL, r27 //offset the volume table by the main volume
0025fd 1df2                      	adc ZH, zero
0025fe 91b4                      	lpm r27, Z
0025ff 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
002601 c024                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default:
002602 91b0 2800                 	lds r27, pulse1_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
002604 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002605 91a0 285d                 	lds r26, pulse1_fx_7xy_value
002607 30a0                      	cpi r26, 0x00
002608 f4a1                      	brne sound_driver_instrument_routine_channel0_volume_default_7xy
002609 93b0 2806                 	sts pulse1_output_volume, r27
00260b c01a                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy:
00260c 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
00260d f040                      	brcs sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
00260e f039                      	breq sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
00260f e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
                                 
002610 0feb                      	add ZL, r27 //offset the volume table by the main volume
002611 1df2                      	adc ZH, zero
002612 91b4                      	lpm r27, Z
002613 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
002615 c010                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy_overflow:
002616 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002617 0feb                      	add ZL, r27 //offset the volume table by the main volume
002618 1df2                      	adc ZH, zero
002619 91b4                      	lpm r27, Z
00261a 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
00261c c009                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default_7xy:
00261d 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
00261e f020                      	brcs sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
00261f f019                      	breq sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
002620 93b0 2806                 	sts pulse1_output_volume, r27
002622 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel0_volume_default_7xy_overflow:
002623 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002624 93b0 2806                 	sts pulse1_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002626 91e0 282d                 	lds ZL, pulse1_arpeggio_macro
002628 91f0 282e                 	lds ZH, pulse1_arpeggio_macro+1
00262a 9630                      	adiw Z, 0
00262b f1d9                      	breq sound_driver_instrument_routine_channel0_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
00262c 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
00262d 1fff                      	rol ZH
00262e 91a0 282f                 	lds r26, pulse1_arpeggio_macro_offset
002630 0fea                      	add ZL, r26
002631 1df2                      	adc ZH, zero
                                 
002632 91b0 2831                 	lds r27, pulse1_arpeggio_macro_release
002634 17ba                      	cp r27, r26
002635 f429                      	brne sound_driver_instrument_routine_channel0_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002636 91a0 2830                 	lds r26, pulse1_arpeggio_macro_loop
002638 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002639 f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
00263a c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_increment:
00263b 95a3                      	inc r26 //increment the macro offset
00263c 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_read:
00263e 91b4                      	lpm r27, Z //load arpeggio data into r27
00263f 38b0                      	cpi r27, 0x80 //check for macro end flag
002640 f009                      	breq sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag
002641 c041                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_check_mode:
002642 50a1                      	subi r26, 1 //keep the offset at the end flag
002643 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26
002645 91b0 2832                 	lds r27, pulse1_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002647 30b1                      	cpi r27, 0x01
002648 f048                      	brlo sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_release:
002649 91b0 2831                 	lds r27, pulse1_arpeggio_macro_release
00264b 3fbf                      	cpi r27, 0xFF
00264c f4d1                      	brne sound_driver_instrument_routine_channel0_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_loop:
00264d 91b0 2830                 	lds r27, pulse1_arpeggio_macro_loop
00264f 3fbf                      	cpi r27, 0xFF
002650 f499                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002651 c015                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute:
002652 91b0 2831                 	lds r27, pulse1_arpeggio_macro_release
002654 3fbf                      	cpi r27, 0xFF
002655 f421                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_check_loop:
002656 91b0 2830                 	lds r27, pulse1_arpeggio_macro_loop //load the loop index
002658 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002659 f451                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop:
00265a 91c0 2845                 	lds r28, pulse1_fx_0xy_sequence //check for 0xy effect
00265c 91d0 2846                 	lds r29, pulse1_fx_0xy_sequence+1
00265e 9620                      	adiw r29:r28, 0
00265f f469                      	brne sound_driver_instrument_routine_channel0_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002660 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002661 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26 //store the last valid index into the offset
002663 cfc2                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload:
002664 93b0 282f                 	sts pulse1_arpeggio_macro_offset, r27 //store the loop index into the offset
002666 cfbf                      	rjmp sound_driver_instrument_routine_channel0_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_default:
002667 91c0 2845                 	lds r28, pulse1_fx_0xy_sequence //load 0xy effect
002669 91d0 2846                 	lds r29, pulse1_fx_0xy_sequence+1
00266b 9620                      	adiw r29:r28, 0 //check for 0xy effect
00266c f099                      	breq sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel0_arpeggio_default_xy:
00266d 95d6                      	lsr r29
00266e 95c7                      	ror r28
00266f 95d7                      	ror r29
002670 95c7                      	ror r28
002671 95d7                      	ror r29
002672 95c7                      	ror r28
002673 95d7                      	ror r29
002674 95c7                      	ror r28
002675 95d7                      	ror r29
002676 95d2                      	swap r29
                                 
002677 93c0 2845                 	sts pulse1_fx_0xy_sequence, r28 //store the rolled sequence
002679 93d0 2846                 	sts pulse1_fx_0xy_sequence+1, r29
00267b 70cf                      	andi r28, 0x0F //mask out the 4 LSB
00267c 91a0 2807                 	lds r26, pulse1_note //load the current note index
00267e 0fac                      	add r26, r28 //add the note offset
00267f c02e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002680 91a0 2807                 	lds r26, pulse1_note //load the current note index
002682 c02b                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process:
002683 9220 2833                 	sts pulse1_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002685 9220 2834                 	sts pulse1_total_pitch_offset+1, zero
002687 9220 283a                 	sts pulse1_total_hi_pitch_offset, zero
002689 91a0 2832                 	lds r26, pulse1_arpeggio_macro_mode
00268b 30a1                      	cpi r26, 0x01 //absolute mode
00268c f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_absolute
00268d f069                      	breq sound_driver_instrument_routine_channel0_arpeggio_process_fixed
00268e c00e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute:
00268f 91a0 2807                 	lds r26, pulse1_note //load the current note index
002691 0fab                      	add r26, r27 //offset the note with the arpeggio data
002692 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002693 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_add:
002694 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002695 f0c0                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
002696 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002697 c016                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract:
002698 fda7                      	sbrc r26, 7 //check if result is negative
002699 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
00269a c013                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_fixed:
00269b 2fab                      	mov r26, r27 //move the arpeggio data into r26
00269c c011                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative:
00269d 91a0 2807                 	lds r26, pulse1_note //load the current note index
00269f 0fab                      	add r26, r27 //offset the note with the arpeggio data
0026a0 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0026a1 c008                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_add:
0026a2 93a0 2807                 	sts pulse1_note, r26 //NOTE: relative mode modifies the original note index
0026a4 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0026a5 f040                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
0026a6 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0026a7 93a0 2807                 	sts pulse1_note, r26
0026a9 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract:
0026aa fda7                      	sbrc r26, 7 //check if result is negative
0026ab e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0026ac 93a0 2807                 	sts pulse1_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_load:
0026ae e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0026af e0f0                      	ldi ZH, HIGH(note_table << 1)
0026b0 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
0026b1 0fea                      	add ZL, r26 //add offset
0026b2 1df2                      	adc ZH, zero
0026b3 91a5                      	lpm r26, Z+ //load bytes
0026b4 91b4                      	lpm r27, Z
0026b5 93a0 0a8c                 	sts TCB0_CCMPL, r26 //load the LOW bits for timer
0026b7 93b0 0a8d                 	sts TCB0_CCMPH, r27 //load the HIGH bits for timer
0026b9 93a0 2851                 	sts pulse1_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
0026bb 93b0 2852                 	sts pulse1_fx_3xx_target+1, r27
0026bd c000                      	rjmp sound_driver_instrument_routine_channel0_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch:
0026be 91e0 2835                 	lds ZL, pulse1_pitch_macro
0026c0 91f0 2836                 	lds ZH, pulse1_pitch_macro+1
0026c2 9630                      	adiw Z, 0
0026c3 f409                      	brne sound_driver_instrument_routine_channel0_pitch_continue
0026c4 c023                      	rjmp sound_driver_instrument_routine_channel0_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel0_pitch_continue:
0026c5 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0026c6 1fff                      	rol ZH
0026c7 91a0 2837                 	lds r26, pulse1_pitch_macro_offset
0026c9 0fea                      	add ZL, r26
0026ca 1df2                      	adc ZH, zero
                                 
0026cb 91b0 2839                 	lds r27, pulse1_pitch_macro_release
0026cd 17ba                      	cp r27, r26
0026ce f429                      	brne sound_driver_instrument_routine_channel0_pitch_increment //if the current offset is not equal to the release index, increment the offset
0026cf 91a0 2838                 	lds r26, pulse1_pitch_macro_loop
0026d1 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0026d2 f010                      	brlo sound_driver_instrument_routine_channel0_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0026d3 c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_pitch_increment:
0026d4 95a3                      	inc r26 //increment the macro offset
0026d5 93a0 2837                 	sts pulse1_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_pitch_read:
0026d7 91b4                      	lpm r27, Z //load pitch data into r27
0026d8 38b0                      	cpi r27, 0x80 //check for macro end flag
0026d9 f479                      	brne sound_driver_instrument_routine_channel0_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_release:
0026da 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0026db 93a0 2837                 	sts pulse1_pitch_macro_offset, r26
0026dd 91b0 2839                 	lds r27, pulse1_pitch_macro_release
0026df 3fbf                      	cpi r27, 0xFF
0026e0 f439                      	brne sound_driver_instrument_routine_channel0_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_loop:
0026e1 91b0 2838                 	lds r27, pulse1_pitch_macro_loop //load the loop index
0026e3 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0026e4 f019                      	breq sound_driver_instrument_routine_channel0_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
0026e5 93b0 2837                 	sts pulse1_pitch_macro_offset, r27 //store the loop index into the offset
0026e7 cfd6                      	rjmp sound_driver_instrument_routine_channel0_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_default:
0026e8 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel0_pitch_calculate:
0026e9 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0026ea 937f                      	push r23
0026eb 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
0026ec eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0026ed 0367                      	mulsu r22, r23
0026ee 917f                      	pop r23
0026ef 916f                      	pop r22
                                 
0026f0 9416                      	lsr r1 //shift out the fractional bits
0026f1 9407                      	ror r0
0026f2 9416                      	lsr r1
0026f3 9407                      	ror r0
0026f4 9416                      	lsr r1
0026f5 9407                      	ror r0
0026f6 9416                      	lsr r1
0026f7 9407                      	ror r0
0026f8 fe13                      	sbrs r1, 3 //check if result was a negative number
0026f9 c002                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_negative:
0026fa efb0                      	ldi r27, 0xF0
0026fb 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_offset:
0026fc 91a0 2833                 	lds r26, pulse1_total_pitch_offset
0026fe 91b0 2834                 	lds r27, pulse1_total_pitch_offset+1
002700 0e0a                      	add r0, r26
002701 1e1b                      	adc r1, r27
002702 9200 2833                 	sts pulse1_total_pitch_offset, r0
002704 9210 2834                 	sts pulse1_total_pitch_offset+1, r1
002706 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
002708 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
00270a 0da0                      	add r26, r0 //offset the timer values
00270b 1db1                      	adc r27, r1
                                 	
00270c 91c0 2849                 	lds r28, pulse1_fx_1xx_total
00270e 91d0 284a                 	lds r29, pulse1_fx_1xx_total+1
002710 1bac                      	sub r26, r28
002711 0bbd                      	sbc r27, r29
002712 91c0 284d                 	lds r28, pulse1_fx_2xx_total
002714 91d0 284e                 	lds r29, pulse1_fx_2xx_total+1
002716 0fac                      	add r26, r28
002717 1fbd                      	adc r27, r29
002718 91c0 2861                 	lds r28, pulse1_fx_Pxx_total
00271a 91d0 2862                 	lds r29, pulse1_fx_Pxx_total+1
00271c 0fac                      	add r26, r28
00271d 1fbd                      	adc r27, r29
00271e 91c0 2867                 	lds r28, pulse1_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
002720 91d0 2868                 	lds r29, pulse1_fx_Qxy_total_offset+1
002722 1bac                      	sub r26, r28
002723 0bbd                      	sbc r27, r29
002724 91c0 286d                 	lds r28, pulse1_fx_Rxy_total_offset
002726 91d0 286e                 	lds r29, pulse1_fx_Rxy_total_offset+1
002728 0fac                      	add r26, r28
002729 1fbd                      	adc r27, r29
                                 
00272a 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
00272c 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel0_hi_pitch:
00272e 91e0 283b                 	lds ZL, pulse1_hi_pitch_macro
002730 91f0 283c                 	lds ZH, pulse1_hi_pitch_macro+1
002732 9630                      	adiw Z, 0
002733 f409                      	brne sound_driver_instrument_routine_channel0_hi_pitch_continue
002734 c03c                      	rjmp sound_driver_instrument_routine_channel0_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel0_hi_pitch_continue:
002735 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002736 1fff                      	rol ZH
002737 91a0 283d                 	lds r26, pulse1_hi_pitch_macro_offset
002739 0fea                      	add ZL, r26
00273a 1df2                      	adc ZH, zero
                                 
00273b 91b0 283f                 	lds r27, pulse1_hi_pitch_macro_release
00273d 17ba                      	cp r27, r26
00273e f429                      	brne sound_driver_instrument_routine_channel0_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
00273f 91a0 283e                 	lds r26, pulse1_hi_pitch_macro_loop
002741 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002742 f010                      	brlo sound_driver_instrument_routine_channel0_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002743 c003                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_increment:
002744 95a3                      	inc r26 //increment the macro offset
002745 93a0 283d                 	sts pulse1_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_hi_pitch_read:
002747 91b4                      	lpm r27, Z //load hi pitch data into r27
002748 38b0                      	cpi r27, 0x80 //check for macro end flag
002749 f489                      	brne sound_driver_instrument_routine_channel0_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_release:
00274a 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00274b 93a0 283d                 	sts pulse1_hi_pitch_macro_offset, r26
00274d 91b0 283f                 	lds r27, pulse1_hi_pitch_macro_release
00274f 3fbf                      	cpi r27, 0xFF
002750 f439                      	brne sound_driver_instrument_routine_channel0_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_loop:
002751 91b0 283e                 	lds r27, pulse1_hi_pitch_macro_loop //load the loop index
002753 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002754 f019                      	breq sound_driver_instrument_routine_channel0_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002755 93b0 283d                 	sts pulse1_hi_pitch_macro_offset, r27 //store the loop index into the offset
002757 cfd6                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_default:
002758 91b0 283a                 	lds r27, pulse1_total_hi_pitch_offset
00275a c005                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate:
00275b 91a0 283a                 	lds r26, pulse1_total_hi_pitch_offset //load the total hi pitch offset to change
00275d 0fba                      	add r27, r26
00275e 93b0 283a                 	sts pulse1_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply:
002760 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002761 937f                      	push r23
002762 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002763 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002764 0367                      	mulsu r22, r23
002765 917f                      	pop r23
002766 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_offset:
002767 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
002769 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
00276b 0da0                      	add r26, r0 //offset the timer values
00276c 1db1                      	adc r27, r1
00276d 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
00276f 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel0_duty:
002771 91e0 2840                 	lds ZL, pulse1_duty_macro
002773 91f0 2841                 	lds ZH, pulse1_duty_macro+1
002775 9630                      	adiw Z, 0
002776 f1b1                      	breq sound_driver_channel0_fx_routines //if no duty macro is in use, go to the next routine
002777 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002778 1fff                      	rol ZH
002779 91a0 2842                 	lds r26, pulse1_duty_macro_offset
00277b 0fea                      	add ZL, r26
00277c 1df2                      	adc ZH, zero
                                 
00277d 91b0 2844                 	lds r27, pulse1_duty_macro_release
00277f 17ba                      	cp r27, r26
002780 f429                      	brne sound_driver_instrument_routine_channel0_duty_increment //if the current offset is not equal to the release index, increment the offset
002781 91a0 2843                 	lds r26, pulse1_duty_macro_loop
002783 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002784 f010                      	brlo sound_driver_instrument_routine_channel0_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002785 c027                      	rjmp sound_driver_channel0_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel0_duty_increment:
002786 95a3                      	inc r26 //increment the macro offset
002787 93a0 2842                 	sts pulse1_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_duty_read:
002789 91b4                      	lpm r27, Z //load pitch data into r27
00278a 3fbf                      	cpi r27, 0xFF //check for macro end flag
00278b f471                      	brne sound_driver_instrument_routine_channel0_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_release:
00278c 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00278d 93a0 2842                 	sts pulse1_duty_macro_offset, r26
00278f 91b0 2844                 	lds r27, pulse1_duty_macro_release
002791 3fbf                      	cpi r27, 0xFF
002792 f4d1                      	brne sound_driver_channel0_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_loop:
002793 91b0 2843                 	lds r27, pulse1_duty_macro_loop //load the loop index
002795 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002796 f0b1                      	breq sound_driver_channel0_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
002797 93b0 2842                 	sts pulse1_duty_macro_offset, r27 //store the loop index into the offset
002799 cfd7                      	rjmp sound_driver_instrument_routine_channel0_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_load:
00279a efe2                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
00279b e6f4                      	ldi ZH, HIGH(sequences << 1)
00279c 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
00279d 1df2                      	adc ZH, zero
                                 
00279e 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
00279f 95b7                      	ror r27
0027a0 95b7                      	ror r27
0027a1 91a0 2800                 	lds r26, pulse1_param //load r26 with pulse1_param (register $4000)
0027a3 2fca                      	mov r28, r26 //store a copy of pulse1_param into r28
0027a4 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
0027a5 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
0027a6 c001                      	rjmp sound_driver_instrument_routine_channel0_duty_load_store
0027a7 c005                      	rjmp sound_driver_channel0_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel0_duty_load_store:
0027a8 90a4                      	lpm pulse1_sequence, Z //store the sequence
                                 
0027a9 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
0027aa 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
0027ab 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_routines:
                                 sound_driver_channel0_fx_1xx_routine:
0027ad 91e0 2847                 	lds ZL, pulse1_fx_1xx
0027af 91f0 2848                 	lds ZH, pulse1_fx_1xx+1
0027b1 9630                      	adiw Z, 0
0027b2 f051                      	breq sound_driver_channel0_fx_2xx_routine
                                 
0027b3 91a0 2849                 	lds r26, pulse1_fx_1xx_total //load the rate to change the pitch by
0027b5 91b0 284a                 	lds r27, pulse1_fx_1xx_total+1
0027b7 0fae                      	add r26, ZL //increase the total offset by the rate
0027b8 1fbf                      	adc r27, ZH
0027b9 93a0 2849                 	sts pulse1_fx_1xx_total, r26
0027bb 93b0 284a                 	sts pulse1_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_2xx_routine:
0027bd 91e0 284b                 	lds ZL, pulse1_fx_2xx
0027bf 91f0 284c                 	lds ZH, pulse1_fx_2xx+1
0027c1 9630                      	adiw Z, 0
0027c2 f051                      	breq sound_driver_channel0_fx_3xx_routine
                                 
0027c3 91a0 284d                 	lds r26, pulse1_fx_2xx_total //load the rate to change the pitch by
0027c5 91b0 284e                 	lds r27, pulse1_fx_2xx_total+1
0027c7 0fae                      	add r26, ZL //increase the total offset by the rate
0027c8 1fbf                      	adc r27, ZH
0027c9 93a0 284d                 	sts pulse1_fx_2xx_total, r26
0027cb 93b0 284e                 	sts pulse1_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_3xx_routine:
0027cd 91e0 2853                 	lds ZL, pulse1_fx_3xx_speed
0027cf 91f0 2854                 	lds ZH, pulse1_fx_3xx_speed+1
0027d1 9630                      	adiw Z, 0
0027d2 f409                      	brne sound_driver_channel0_fx_3xx_routine_check_start
0027d3 c048                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_check_start:
0027d4 91a0 284f                 	lds r26, pulse1_fx_3xx_start
0027d6 91b0 2850                 	lds r27, pulse1_fx_3xx_start+1
0027d8 9610                      	adiw r26:r27, 0
0027d9 f409                      	brne sound_driver_channel0_fx_3xx_routine_main
0027da c041                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_main:
0027db 91c0 2851                 	lds r28, pulse1_fx_3xx_target
0027dd 91d0 2852                 	lds r29, pulse1_fx_3xx_target+1
                                 
0027df 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
0027e0 07bd                      	cpc r27, r29
0027e1 f011                      	breq sound_driver_channel0_fx_3xx_routine_disable
0027e2 f030                      	brlo sound_driver_channel0_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
0027e3 c01f                      	rjmp sound_driver_channel0_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel0_fx_3xx_routine_disable:
0027e4 9220 284f                 	sts pulse1_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
0027e6 9220 2850                 	sts pulse1_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
0027e8 c033                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_subtract:
0027e9 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
0027ea 0bdb                      	sbc r29, r27
0027eb 91a0 2855                 	lds r26, pulse1_fx_3xx_total_offset
0027ed 91b0 2856                 	lds r27, pulse1_fx_3xx_total_offset+1
                                 
0027ef 0fae                      	add r26, ZL //add the speed to the total offset
0027f0 1fbf                      	adc r27, ZH
0027f1 1bca                      	sub r28, r26 //invert the total difference with the total offset
0027f2 0bdb                      	sbc r29, r27
0027f3 f380                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0027f4 93a0 2855                 	sts pulse1_fx_3xx_total_offset, r26 //store the new total offset
0027f6 93b0 2856                 	sts pulse1_fx_3xx_total_offset+1, r27
                                 
0027f8 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the current timer period
0027fa 91b0 0a8d                 	lds r27, TCB0_CCMPH
0027fc 1bac                      	sub r26, r28 //offset the current timer period with the total offset
0027fd 0bbd                      	sbc r27, r29
0027fe 93a0 0a8c                 	sts TCB0_CCMPL, r26
002800 93b0 0a8d                 	sts TCB0_CCMPH, r27
002802 c019                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_add:
002803 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002804 0bbd                      	sbc r27, r29
002805 91c0 2855                 	lds r28, pulse1_fx_3xx_total_offset
002807 91d0 2856                 	lds r29, pulse1_fx_3xx_total_offset+1
                                 
002809 0fce                      	add r28, ZL //add the speed to the total offset
00280a 1fdf                      	adc r29, ZH
00280b 1bac                      	sub r26, r28 //invert the total difference with the total offset
00280c 0bbd                      	sbc r27, r29
00280d f2b0                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
00280e 93c0 2855                 	sts pulse1_fx_3xx_total_offset, r28 //store the new total offset
002810 93d0 2856                 	sts pulse1_fx_3xx_total_offset+1, r29
                                 
002812 91c0 0a8c                 	lds r28, TCB0_CCMPL //load the current timer period
002814 91d0 0a8d                 	lds r29, TCB0_CCMPH
002816 0fca                      	add r28, r26 //offset the current timer period with the total offset
002817 1fdb                      	adc r29, r27
002818 93c0 0a8c                 	sts TCB0_CCMPL, r28
00281a 93d0 0a8d                 	sts TCB0_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel0_fx_4xy_routine:
00281c 91a0 2857                 	lds r26, pulse1_fx_4xy_speed
00281e 15a2                      	cp r26, zero
00281f f409                      	brne sound_driver_channel0_fx_4xy_routine_continue
002820 c05c                      	rjmp sound_driver_channel0_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel0_fx_4xy_routine_continue:
002821 91b0 2858                 	lds r27, pulse1_fx_4xy_depth
002823 91c0 2859                 	lds r28, pulse1_fx_4xy_phase
002825 0fca                      	add r28, r26 //increase the phase by the speed
002826 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
002827 f008                      	brlo sound_driver_channel0_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002828 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase:
002829 93c0 2859                 	sts pulse1_fx_4xy_phase, r28 //store the new phase
00282b 31c0                      	cpi r28, 16
00282c f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_0
00282d 32c0                      	cpi r28, 32
00282e f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_1
00282f 33c0                      	cpi r28, 48
002830 f030                      	brlo sound_driver_channel0_fx_4xy_routine_phase_2
002831 c007                      	rjmp sound_driver_channel0_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_0:
002832 70cf                      	andi r28, 0x0F //mask for values 0-15
002833 c029                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_1:
002834 6fc0                      	ori r28, 0xF0
002835 95c0                      	com r28 //invert values 0-15
002836 c026                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_2:
002837 70cf                      	andi r28, 0x0F //mask for values 0-15
002838 c003                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_3:
002839 6fc0                      	ori r28, 0xF0
00283a 95c0                      	com r28 //invert values 0-15
00283b c000                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_add:
00283c 95b2                      	swap r27 //multiply depth by 16
00283d 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
00283e e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00283f e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002840 0fec                      	add ZL, r28 //offset the table by the depth+phase
002841 1df2                      	adc ZH, zero
002842 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002843 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002844 937f                      	push r23
002845 2f6c                      	mov r22, r28 //store the vibrato value into r22
002846 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002847 9f67                      	mul r22, r23
002848 917f                      	pop r23
002849 916f                      	pop r22
                                 
00284a 9416                      	lsr r1 //shift out the fractional bits
00284b 9407                      	ror r0
00284c 9416                      	lsr r1
00284d 9407                      	ror r0
00284e 9416                      	lsr r1
00284f 9407                      	ror r0
002850 9416                      	lsr r1
002851 9407                      	ror r0
                                 	
002852 91a0 0a8c                 	lds r26, TCB0_CCMPL
002854 91b0 0a8d                 	lds r27, TCB0_CCMPH
002856 0da0                      	add r26, r0
002857 1db1                      	adc r27, r1
002858 93a0 0a8c                 	sts TCB0_CCMPL, r26
00285a 93b0 0a8d                 	sts TCB0_CCMPH, r27
00285c c020                      	rjmp sound_driver_channel0_fx_7xy_routine
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_subtract:
00285d 95b2                      	swap r27 //multiply depth by 16
00285e 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
00285f e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002860 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002861 0fec                      	add ZL, r28 //offset the table by the depth+phase
002862 1df2                      	adc ZH, zero
002863 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002864 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002865 937f                      	push r23
002866 2f6c                      	mov r22, r28 //store the vibrato value into r22
002867 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002868 9f67                      	mul r22, r23
002869 917f                      	pop r23
00286a 916f                      	pop r22
                                 
00286b 9416                      	lsr r1 //shift out the fractional bits
00286c 9407                      	ror r0
00286d 9416                      	lsr r1
00286e 9407                      	ror r0
00286f 9416                      	lsr r1
002870 9407                      	ror r0
002871 9416                      	lsr r1
002872 9407                      	ror r0
                                 
002873 91a0 0a8c                 	lds r26, TCB0_CCMPL
002875 91b0 0a8d                 	lds r27, TCB0_CCMPH
002877 19a0                      	sub r26, r0
002878 09b1                      	sbc r27, r1
002879 93a0 0a8c                 	sts TCB0_CCMPL, r26
00287b 93b0 0a8d                 	sts TCB0_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_7xy_routine:
00287d 91a0 285a                 	lds r26, pulse1_fx_7xy_speed
00287f 15a2                      	cp r26, zero
002880 f0f1                      	breq sound_driver_channel0_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
002881 91b0 285b                 	lds r27, pulse1_fx_7xy_depth
002883 91c0 285c                 	lds r28, pulse1_fx_7xy_phase
002885 0fca                      	add r28, r26 //increase the phase by the speed
002886 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
002887 f010                      	brlo sound_driver_channel0_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
002888 e0c0                      	ldi r28, 0x00
002889 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase:
00288a 93c0 285c                 	sts pulse1_fx_7xy_phase, r28 //store the new phase
00288c 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
00288d ffc4                      	sbrs r28, 4
00288e c001                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_0
00288f c002                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel0_fx_7xy_routine_phase_0:
002890 70cf                      	andi r28, 0x0F //mask for values 0-15
002891 c003                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase_1:
002892 6fc0                      	ori r28, 0xF0
002893 95c0                      	com r28 //invert values 0-15
002894 c000                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_load:
002895 95b2                      	swap r27 //multiply depth by 16
002896 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002897 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002898 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002899 0fec                      	add ZL, r28 //offset the table by the depth+phase
00289a 1df2                      	adc ZH, zero
00289b 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
00289c 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
00289d 93c0 285d                 	sts pulse1_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Axy_routine:
00289f 91b0 285e                 	lds r27, pulse1_fx_Axy
0028a1 15b2                      	cp r27, zero
0028a2 f0e9                      	breq sound_driver_channel0_fx_Qxy_routine //0 means that the effect is not in use
                                 	
0028a3 91a0 2805                 	lds r26, pulse1_fractional_volume //load fractional volume representation of the channel
0028a5 91c0 2800                 	lds r28, pulse1_param //load the integer volume representation of the channel
0028a7 2fda                      	mov r29, r26 //copy fractional volume into r29
0028a8 2fec                      	mov r30, r28 //copy the pulse1_param into r30
0028a9 95e2                      	swap r30
0028aa 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
0028ab 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
0028ac 17ed                      	cp r30, r29 //compare the fractional and integer volumes
0028ad f009                      	breq sound_driver_channel0_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel0_fx_Axy_routine_reload:
0028ae 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate:
0028af fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
0028b0 c004                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_addition:
0028b1 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0028b2 f428                      	brcc sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0028b3 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
0028b4 c003                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_subtraction:
0028b5 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0028b6 f008                      	brcs sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0028b7 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_store:
0028b8 93a0 2805                 	sts pulse1_fractional_volume, r26 //store the new fractional volume
0028ba 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
0028bb 95a2                      	swap r26
0028bc 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
0028bd 2bca                      	or r28, r26 //store the new volume back into pulse1_param
0028be 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel0_fx_Qxy_routine:
0028c0 91e0 2863                 	lds ZL, pulse1_fx_Qxy_target
0028c2 91f0 2864                 	lds ZH, pulse1_fx_Qxy_target+1
0028c4 9630                      	adiw Z, 0
0028c5 f139                      	breq sound_driver_channel0_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
0028c6 91a0 2867                 	lds r26, pulse1_fx_Qxy_total_offset
0028c8 91b0 2868                 	lds r27, pulse1_fx_Qxy_total_offset+1
0028ca 91c0 0a8c                 	lds r28, TCB0_CCMPL
0028cc 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
0028ce 1bec                      	sub ZL, r28 //calculate the difference to the target
0028cf 0bfd                      	sbc ZH, r29
0028d0 f408                      	brsh sound_driver_channel0_fx_Qxy_routine_end //if the target has been reached (or passed)
0028d1 f088                      	brlo sound_driver_channel0_fx_Qxy_routine_add
                                 
                                 sound_driver_channel0_fx_Qxy_routine_end:
0028d2 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
0028d3 0bbf                      	sbc r27, ZH
                                 
0028d4 91c0 2861                 	lds r28, pulse1_fx_Pxx_total
0028d6 91d0 2862                 	lds r29, pulse1_fx_Pxx_total+1
                                 
0028d8 0fac                      	add r26, r28
0028d9 1fbd                      	adc r27, r29
                                 
0028da 93a0 2867                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
0028dc 93b0 2868                 	sts pulse1_fx_Qxy_total_offset+1, r27
0028de 9220 2863                 	sts pulse1_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
0028e0 9220 2864                 	sts pulse1_fx_Qxy_target+1, zero
0028e2 c00a                      	rjmp sound_driver_channel0_fx_Rxy_routine
                                 
                                 sound_driver_channel0_fx_Qxy_routine_add:
0028e3 91c0 2865                 	lds r28, pulse1_fx_Qxy_speed
0028e5 91d0 2866                 	lds r29, pulse1_fx_Qxy_speed+1
0028e7 0fac                      	add r26, r28 //increase the total offset by the speed
0028e8 1fbd                      	adc r27, r29
0028e9 93a0 2867                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
0028eb 93b0 2868                 	sts pulse1_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Rxy_routine:
0028ed 91e0 2869                 	lds ZL, pulse1_fx_Rxy_target
0028ef 91f0 286a                 	lds ZH, pulse1_fx_Rxy_target+1
0028f1 9630                      	adiw Z, 0
0028f2 f139                      	breq sound_driver_instrument_routine_channel1_volume //if the effect is not enabled, skip the routine
                                 
0028f3 91a0 286d                 	lds r26, pulse1_fx_Rxy_total_offset
0028f5 91b0 286e                 	lds r27, pulse1_fx_Rxy_total_offset+1
0028f7 91c0 0a8c                 	lds r28, TCB0_CCMPL
0028f9 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
0028fb 1bce                      	sub r28, ZL //calculate the difference to the target
0028fc 0bdf                      	sbc r29, ZH
0028fd f408                      	brsh sound_driver_channel0_fx_Rxy_routine_end //if the target has been reached (or passed)
0028fe f088                      	brlo sound_driver_channel0_fx_Rxy_routine_add
                                 
                                 sound_driver_channel0_fx_Rxy_routine_end:
0028ff 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
002900 0bbd                      	sbc r27, r29
                                 
002901 91c0 2861                 	lds r28, pulse1_fx_Pxx_total
002903 91d0 2862                 	lds r29, pulse1_fx_Pxx_total+1
                                 
002905 0fac                      	add r26, r28
002906 1fbd                      	adc r27, r29
                                 
002907 93a0 286d                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
002909 93b0 286e                 	sts pulse1_fx_Rxy_total_offset+1, r27
00290b 9220 2869                 	sts pulse1_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
00290d 9220 286a                 	sts pulse1_fx_Rxy_target+1, zero
00290f c00a                      	rjmp sound_driver_instrument_routine_channel1_volume
                                 
                                 sound_driver_channel0_fx_Rxy_routine_add:
002910 91c0 286b                 	lds r28, pulse1_fx_Rxy_speed
002912 91d0 286c                 	lds r29, pulse1_fx_Rxy_speed+1
002914 0fac                      	add r26, r28 //increase the total offset by the speed
002915 1fbd                      	adc r27, r29
002916 93a0 286d                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
002918 93b0 286e                 	sts pulse1_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume:
00291a 91e0 2877                 	lds ZL, pulse2_volume_macro
00291c 91f0 2878                 	lds ZH, pulse2_volume_macro+1
00291e 9630                      	adiw Z, 0
00291f f1a1                      	breq sound_driver_instrument_routine_channel1_volume_default //if no volume macro is in use, use default multiplier of F
002920 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002921 1fff                      	rol ZH
002922 91a0 2879                 	lds r26, pulse2_volume_macro_offset
002924 0fea                      	add ZL, r26
002925 1df2                      	adc ZH, zero
                                 
002926 91b0 287b                 	lds r27, pulse2_volume_macro_release
002928 17ba                      	cp r27, r26
002929 f429                      	brne sound_driver_instrument_routine_channel1_volume_increment //if the current offset is not equal to the release index, increment the offset
00292a 91a0 287a                 	lds r26, pulse2_volume_macro_loop
00292c 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00292d f010                      	brlo sound_driver_instrument_routine_channel1_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00292e c003                      	rjmp sound_driver_instrument_routine_channel1_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_volume_increment:
00292f 95a3                      	inc r26 //increment the macro offset
002930 93a0 2879                 	sts pulse2_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_volume_read:
002932 91b4                      	lpm r27, Z //load volume data into r27
002933 3fbf                      	cpi r27, 0xFF //check for macro end flag
002934 f469                      	brne sound_driver_instrument_routine_channel1_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_release:
002935 91b0 287b                 	lds r27, pulse2_volume_macro_release
002937 3fbf                      	cpi r27, 0xFF
002938 f429                      	brne sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_loop:
002939 91b0 287a                 	lds r27, pulse2_volume_macro_loop //load the loop index
00293b 93b0 2879                 	sts pulse2_volume_macro_offset, r27 //store the loop index into the offset
00293d cfdc                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index:
00293e 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
00293f 93a0 2879                 	sts pulse2_volume_macro_offset, r26
002941 cfd8                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_calculate:
002942 ece6                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
002943 e6f5                      	ldi ZH, HIGH(volumes << 1)
002944 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
002945 0feb                      	add ZL, r27 //add offset to the table
002946 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel1_volume_load:
002947 91b0 2808                 	lds r27, pulse2_param //load main volume
002949 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
00294a 91a0 28ac                 	lds r26, pulse2_fx_7xy_value
00294c 30a0                      	cpi r26, 0x00
00294d f481                      	brne sound_driver_instrument_routine_channel1_volume_load_7xy
                                 
00294e 0feb                      	add ZL, r27 //offset the volume table by the main volume
00294f 1df2                      	adc ZH, zero
002950 91b4                      	lpm r27, Z
002951 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
002953 c024                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default:
002954 91b0 2808                 	lds r27, pulse2_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
002956 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002957 91a0 28ac                 	lds r26, pulse2_fx_7xy_value
002959 30a0                      	cpi r26, 0x00
00295a f4a1                      	brne sound_driver_instrument_routine_channel1_volume_default_7xy
00295b 93b0 280e                 	sts pulse2_output_volume, r27
00295d c01a                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy:
00295e 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
00295f f040                      	brcs sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
002960 f039                      	breq sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
002961 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
                                 
002962 0feb                      	add ZL, r27 //offset the volume table by the main volume
002963 1df2                      	adc ZH, zero
002964 91b4                      	lpm r27, Z
002965 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
002967 c010                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy_overflow:
002968 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002969 0feb                      	add ZL, r27 //offset the volume table by the main volume
00296a 1df2                      	adc ZH, zero
00296b 91b4                      	lpm r27, Z
00296c 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
00296e c009                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default_7xy:
00296f 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002970 f020                      	brcs sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
002971 f019                      	breq sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
002972 93b0 280e                 	sts pulse2_output_volume, r27
002974 c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel1_volume_default_7xy_overflow:
002975 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002976 93b0 280e                 	sts pulse2_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002978 91e0 287c                 	lds ZL, pulse2_arpeggio_macro
00297a 91f0 287d                 	lds ZH, pulse2_arpeggio_macro+1
00297c 9630                      	adiw Z, 0
00297d f1d9                      	breq sound_driver_instrument_routine_channel1_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
00297e 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
00297f 1fff                      	rol ZH
002980 91a0 287e                 	lds r26, pulse2_arpeggio_macro_offset
002982 0fea                      	add ZL, r26
002983 1df2                      	adc ZH, zero
                                 
002984 91b0 2880                 	lds r27, pulse2_arpeggio_macro_release
002986 17ba                      	cp r27, r26
002987 f429                      	brne sound_driver_instrument_routine_channel1_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002988 91a0 287f                 	lds r26, pulse2_arpeggio_macro_loop
00298a 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00298b f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
00298c c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_increment:
00298d 95a3                      	inc r26 //increment the macro offset
00298e 93a0 287e                 	sts pulse2_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_read:
002990 91b4                      	lpm r27, Z //load arpeggio data into r27
002991 38b0                      	cpi r27, 0x80 //check for macro end flag
002992 f009                      	breq sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag
002993 c041                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_check_mode:
002994 50a1                      	subi r26, 1 //keep the offset at the end flag
002995 93a0 287e                 	sts pulse2_arpeggio_macro_offset, r26
002997 91b0 2881                 	lds r27, pulse2_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002999 30b1                      	cpi r27, 0x01
00299a f048                      	brlo sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_release:
00299b 91b0 2880                 	lds r27, pulse2_arpeggio_macro_release
00299d 3fbf                      	cpi r27, 0xFF
00299e f4d1                      	brne sound_driver_instrument_routine_channel1_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_loop:
00299f 91b0 287f                 	lds r27, pulse2_arpeggio_macro_loop
0029a1 3fbf                      	cpi r27, 0xFF
0029a2 f499                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
0029a3 c015                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute:
0029a4 91b0 2880                 	lds r27, pulse2_arpeggio_macro_release
0029a6 3fbf                      	cpi r27, 0xFF
0029a7 f421                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_check_loop:
0029a8 91b0 287f                 	lds r27, pulse2_arpeggio_macro_loop //load the loop index
0029aa 3fbf                      	cpi r27, 0xFF //check if loop flag exists
0029ab f451                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop:
0029ac 91c0 2894                 	lds r28, pulse2_fx_0xy_sequence //check for 0xy effect
0029ae 91d0 2895                 	lds r29, pulse2_fx_0xy_sequence+1
0029b0 9620                      	adiw r29:r28, 0
0029b1 f469                      	brne sound_driver_instrument_routine_channel1_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
0029b2 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
0029b3 93a0 287e                 	sts pulse2_arpeggio_macro_offset, r26 //store the last valid index into the offset
0029b5 cfc2                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload:
0029b6 93b0 287e                 	sts pulse2_arpeggio_macro_offset, r27 //store the loop index into the offset
0029b8 cfbf                      	rjmp sound_driver_instrument_routine_channel1_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_default:
0029b9 91c0 2894                 	lds r28, pulse2_fx_0xy_sequence //load 0xy effect
0029bb 91d0 2895                 	lds r29, pulse2_fx_0xy_sequence+1
0029bd 9620                      	adiw r29:r28, 0 //check for 0xy effect
0029be f099                      	breq sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel1_arpeggio_default_xy:
0029bf 95d6                      	lsr r29
0029c0 95c7                      	ror r28
0029c1 95d7                      	ror r29
0029c2 95c7                      	ror r28
0029c3 95d7                      	ror r29
0029c4 95c7                      	ror r28
0029c5 95d7                      	ror r29
0029c6 95c7                      	ror r28
0029c7 95d7                      	ror r29
0029c8 95d2                      	swap r29
                                 
0029c9 93c0 2894                 	sts pulse2_fx_0xy_sequence, r28 //store the rolled sequence
0029cb 93d0 2895                 	sts pulse2_fx_0xy_sequence+1, r29
0029cd 70cf                      	andi r28, 0x0F //mask out the 4 LSB
0029ce 91a0 280f                 	lds r26, pulse2_note //load the current note index
0029d0 0fac                      	add r26, r28 //add the note offset
0029d1 c02e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
0029d2 91a0 280f                 	lds r26, pulse2_note //load the current note index
0029d4 c02b                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process:
0029d5 9220 2882                 	sts pulse2_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
0029d7 9220 2883                 	sts pulse2_total_pitch_offset+1, zero
0029d9 9220 2889                 	sts pulse2_total_hi_pitch_offset, zero
0029db 91a0 2881                 	lds r26, pulse2_arpeggio_macro_mode
0029dd 30a1                      	cpi r26, 0x01 //absolute mode
0029de f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_absolute
0029df f069                      	breq sound_driver_instrument_routine_channel1_arpeggio_process_fixed
0029e0 c00e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute:
0029e1 91a0 280f                 	lds r26, pulse2_note //load the current note index
0029e3 0fab                      	add r26, r27 //offset the note with the arpeggio data
0029e4 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0029e5 c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_add:
0029e6 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0029e7 f0c0                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
0029e8 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0029e9 c016                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract:
0029ea fda7                      	sbrc r26, 7 //check if result is negative
0029eb e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0029ec c013                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_fixed:
0029ed 2fab                      	mov r26, r27 //move the arpeggio data into r26
0029ee c011                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative:
0029ef 91a0 280f                 	lds r26, pulse2_note //load the current note index
0029f1 0fab                      	add r26, r27 //offset the note with the arpeggio data
0029f2 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0029f3 c008                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_add:
0029f4 93a0 280f                 	sts pulse2_note, r26 //NOTE: relative mode modifies the original note index
0029f6 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0029f7 f040                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
0029f8 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0029f9 93a0 280f                 	sts pulse2_note, r26
0029fb c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract:
0029fc fda7                      	sbrc r26, 7 //check if result is negative
0029fd e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0029fe 93a0 280f                 	sts pulse2_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_load:
002a00 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
002a01 e0f0                      	ldi ZH, HIGH(note_table << 1)
002a02 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002a03 0fea                      	add ZL, r26 //add offset
002a04 1df2                      	adc ZH, zero
002a05 91a5                      	lpm r26, Z+ //load bytes
002a06 91b4                      	lpm r27, Z
002a07 93a0 0a9c                 	sts TCB1_CCMPL, r26 //load the LOW bits for timer
002a09 93b0 0a9d                 	sts TCB1_CCMPH, r27 //load the HIGH bits for timer
002a0b 93a0 28a0                 	sts pulse2_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002a0d 93b0 28a1                 	sts pulse2_fx_3xx_target+1, r27
002a0f c000                      	rjmp sound_driver_instrument_routine_channel1_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch:
002a10 91e0 2884                 	lds ZL, pulse2_pitch_macro
002a12 91f0 2885                 	lds ZH, pulse2_pitch_macro+1
002a14 9630                      	adiw Z, 0
002a15 f409                      	brne sound_driver_instrument_routine_channel1_pitch_continue
002a16 c023                      	rjmp sound_driver_instrument_routine_channel1_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel1_pitch_continue:
002a17 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002a18 1fff                      	rol ZH
002a19 91a0 2886                 	lds r26, pulse2_pitch_macro_offset
002a1b 0fea                      	add ZL, r26
002a1c 1df2                      	adc ZH, zero
                                 
002a1d 91b0 2888                 	lds r27, pulse2_pitch_macro_release
002a1f 17ba                      	cp r27, r26
002a20 f429                      	brne sound_driver_instrument_routine_channel1_pitch_increment //if the current offset is not equal to the release index, increment the offset
002a21 91a0 2887                 	lds r26, pulse2_pitch_macro_loop
002a23 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002a24 f010                      	brlo sound_driver_instrument_routine_channel1_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002a25 c003                      	rjmp sound_driver_instrument_routine_channel1_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_pitch_increment:
002a26 95a3                      	inc r26 //increment the macro offset
002a27 93a0 2886                 	sts pulse2_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_pitch_read:
002a29 91b4                      	lpm r27, Z //load pitch data into r27
002a2a 38b0                      	cpi r27, 0x80 //check for macro end flag
002a2b f479                      	brne sound_driver_instrument_routine_channel1_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_release:
002a2c 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002a2d 93a0 2886                 	sts pulse2_pitch_macro_offset, r26
002a2f 91b0 2888                 	lds r27, pulse2_pitch_macro_release
002a31 3fbf                      	cpi r27, 0xFF
002a32 f439                      	brne sound_driver_instrument_routine_channel1_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_loop:
002a33 91b0 2887                 	lds r27, pulse2_pitch_macro_loop //load the loop index
002a35 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002a36 f019                      	breq sound_driver_instrument_routine_channel1_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002a37 93b0 2886                 	sts pulse2_pitch_macro_offset, r27 //store the loop index into the offset
002a39 cfd6                      	rjmp sound_driver_instrument_routine_channel1_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_default:
002a3a e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel1_pitch_calculate:
002a3b 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002a3c 937f                      	push r23
002a3d 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
002a3e eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002a3f 0367                      	mulsu r22, r23
002a40 917f                      	pop r23
002a41 916f                      	pop r22
                                 
002a42 9416                      	lsr r1 //shift out the fractional bits
002a43 9407                      	ror r0
002a44 9416                      	lsr r1
002a45 9407                      	ror r0
002a46 9416                      	lsr r1
002a47 9407                      	ror r0
002a48 9416                      	lsr r1
002a49 9407                      	ror r0
002a4a fe13                      	sbrs r1, 3 //check if result was a negative number
002a4b c002                      	rjmp sound_driver_instrument_routine_channel1_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_negative:
002a4c efb0                      	ldi r27, 0xF0
002a4d 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_offset:
002a4e 91a0 2882                 	lds r26, pulse2_total_pitch_offset
002a50 91b0 2883                 	lds r27, pulse2_total_pitch_offset+1
002a52 0e0a                      	add r0, r26
002a53 1e1b                      	adc r1, r27
002a54 9200 2882                 	sts pulse2_total_pitch_offset, r0
002a56 9210 2883                 	sts pulse2_total_pitch_offset+1, r1
002a58 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
002a5a 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
002a5c 0da0                      	add r26, r0 //offset the timer values
002a5d 1db1                      	adc r27, r1
                                 	
002a5e 91c0 2898                 	lds r28, pulse2_fx_1xx_total
002a60 91d0 2899                 	lds r29, pulse2_fx_1xx_total+1
002a62 1bac                      	sub r26, r28
002a63 0bbd                      	sbc r27, r29
002a64 91c0 289c                 	lds r28, pulse2_fx_2xx_total
002a66 91d0 289d                 	lds r29, pulse2_fx_2xx_total+1
002a68 0fac                      	add r26, r28
002a69 1fbd                      	adc r27, r29
002a6a 91c0 28b0                 	lds r28, pulse2_fx_Pxx_total
002a6c 91d0 28b1                 	lds r29, pulse2_fx_Pxx_total+1
002a6e 0fac                      	add r26, r28
002a6f 1fbd                      	adc r27, r29
002a70 91c0 28b6                 	lds r28, pulse2_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
002a72 91d0 28b7                 	lds r29, pulse2_fx_Qxy_total_offset+1
002a74 1bac                      	sub r26, r28
002a75 0bbd                      	sbc r27, r29
002a76 91c0 28bc                 	lds r28, pulse2_fx_Rxy_total_offset
002a78 91d0 28bd                 	lds r29, pulse2_fx_Rxy_total_offset+1
002a7a 0fac                      	add r26, r28
002a7b 1fbd                      	adc r27, r29
                                 
002a7c 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
002a7e 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel1_hi_pitch:
002a80 91e0 288a                 	lds ZL, pulse2_hi_pitch_macro
002a82 91f0 288b                 	lds ZH, pulse2_hi_pitch_macro+1
002a84 9630                      	adiw Z, 0
002a85 f409                      	brne sound_driver_instrument_routine_channel1_hi_pitch_continue
002a86 c03c                      	rjmp sound_driver_instrument_routine_channel1_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel1_hi_pitch_continue:
002a87 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002a88 1fff                      	rol ZH
002a89 91a0 288c                 	lds r26, pulse2_hi_pitch_macro_offset
002a8b 0fea                      	add ZL, r26
002a8c 1df2                      	adc ZH, zero
                                 
002a8d 91b0 288e                 	lds r27, pulse2_hi_pitch_macro_release
002a8f 17ba                      	cp r27, r26
002a90 f429                      	brne sound_driver_instrument_routine_channel1_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002a91 91a0 288d                 	lds r26, pulse2_hi_pitch_macro_loop
002a93 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002a94 f010                      	brlo sound_driver_instrument_routine_channel1_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002a95 c003                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_increment:
002a96 95a3                      	inc r26 //increment the macro offset
002a97 93a0 288c                 	sts pulse2_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_hi_pitch_read:
002a99 91b4                      	lpm r27, Z //load hi pitch data into r27
002a9a 38b0                      	cpi r27, 0x80 //check for macro end flag
002a9b f489                      	brne sound_driver_instrument_routine_channel1_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_release:
002a9c 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002a9d 93a0 288c                 	sts pulse2_hi_pitch_macro_offset, r26
002a9f 91b0 288e                 	lds r27, pulse2_hi_pitch_macro_release
002aa1 3fbf                      	cpi r27, 0xFF
002aa2 f439                      	brne sound_driver_instrument_routine_channel1_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_loop:
002aa3 91b0 288d                 	lds r27, pulse2_hi_pitch_macro_loop //load the loop index
002aa5 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002aa6 f019                      	breq sound_driver_instrument_routine_channel1_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002aa7 93b0 288c                 	sts pulse2_hi_pitch_macro_offset, r27 //store the loop index into the offset
002aa9 cfd6                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_default:
002aaa 91b0 2889                 	lds r27, pulse2_total_hi_pitch_offset
002aac c005                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate:
002aad 91a0 2889                 	lds r26, pulse2_total_hi_pitch_offset //load the total hi pitch offset to change
002aaf 0fba                      	add r27, r26
002ab0 93b0 2889                 	sts pulse2_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply:
002ab2 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002ab3 937f                      	push r23
002ab4 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002ab5 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002ab6 0367                      	mulsu r22, r23
002ab7 917f                      	pop r23
002ab8 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_offset:
002ab9 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
002abb 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
002abd 0da0                      	add r26, r0 //offset the timer values
002abe 1db1                      	adc r27, r1
002abf 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
002ac1 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel1_duty:
002ac3 91e0 288f                 	lds ZL, pulse2_duty_macro
002ac5 91f0 2890                 	lds ZH, pulse2_duty_macro+1
002ac7 9630                      	adiw Z, 0
002ac8 f1b1                      	breq sound_driver_channel1_fx_routines //if no duty macro is in use, go to the next routine
002ac9 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002aca 1fff                      	rol ZH
002acb 91a0 2891                 	lds r26, pulse2_duty_macro_offset
002acd 0fea                      	add ZL, r26
002ace 1df2                      	adc ZH, zero
                                 
002acf 91b0 2893                 	lds r27, pulse2_duty_macro_release
002ad1 17ba                      	cp r27, r26
002ad2 f429                      	brne sound_driver_instrument_routine_channel1_duty_increment //if the current offset is not equal to the release index, increment the offset
002ad3 91a0 2892                 	lds r26, pulse2_duty_macro_loop
002ad5 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002ad6 f010                      	brlo sound_driver_instrument_routine_channel1_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002ad7 c027                      	rjmp sound_driver_channel1_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel1_duty_increment:
002ad8 95a3                      	inc r26 //increment the macro offset
002ad9 93a0 2891                 	sts pulse2_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_duty_read:
002adb 91b4                      	lpm r27, Z //load pitch data into r27
002adc 3fbf                      	cpi r27, 0xFF //check for macro end flag
002add f471                      	brne sound_driver_instrument_routine_channel1_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_release:
002ade 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002adf 93a0 2891                 	sts pulse2_duty_macro_offset, r26
002ae1 91b0 2893                 	lds r27, pulse2_duty_macro_release
002ae3 3fbf                      	cpi r27, 0xFF
002ae4 f4d1                      	brne sound_driver_channel1_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_loop:
002ae5 91b0 2892                 	lds r27, pulse2_duty_macro_loop //load the loop index
002ae7 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002ae8 f0b1                      	breq sound_driver_channel1_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
002ae9 93b0 2891                 	sts pulse2_duty_macro_offset, r27 //store the loop index into the offset
002aeb cfd7                      	rjmp sound_driver_instrument_routine_channel1_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_load:
002aec efe2                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
002aed e6f4                      	ldi ZH, HIGH(sequences << 1)
002aee 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
002aef 1df2                      	adc ZH, zero
                                 
002af0 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
002af1 95b7                      	ror r27
002af2 95b7                      	ror r27
002af3 91a0 2808                 	lds r26, pulse2_param //load r26 with pulse2_param (register $4000)
002af5 2fca                      	mov r28, r26 //store a copy of pulse2_param into r28
002af6 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
002af7 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
002af8 c001                      	rjmp sound_driver_instrument_routine_channel1_duty_load_store
002af9 c005                      	rjmp sound_driver_channel1_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel1_duty_load_store:
002afa 90d4                      	lpm pulse2_sequence, Z //store the sequence
                                 
002afb 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
002afc 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
002afd 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_routines:
                                 sound_driver_channel1_fx_1xx_routine:
002aff 91e0 2896                 	lds ZL, pulse2_fx_1xx
002b01 91f0 2897                 	lds ZH, pulse2_fx_1xx+1
002b03 9630                      	adiw Z, 0
002b04 f051                      	breq sound_driver_channel1_fx_2xx_routine
                                 
002b05 91a0 2898                 	lds r26, pulse2_fx_1xx_total //load the rate to change the pitch by
002b07 91b0 2899                 	lds r27, pulse2_fx_1xx_total+1
002b09 0fae                      	add r26, ZL //increase the total offset by the rate
002b0a 1fbf                      	adc r27, ZH
002b0b 93a0 2898                 	sts pulse2_fx_1xx_total, r26
002b0d 93b0 2899                 	sts pulse2_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_2xx_routine:
002b0f 91e0 289a                 	lds ZL, pulse2_fx_2xx
002b11 91f0 289b                 	lds ZH, pulse2_fx_2xx+1
002b13 9630                      	adiw Z, 0
002b14 f051                      	breq sound_driver_channel1_fx_3xx_routine
                                 
002b15 91a0 289c                 	lds r26, pulse2_fx_2xx_total //load the rate to change the pitch by
002b17 91b0 289d                 	lds r27, pulse2_fx_2xx_total+1
002b19 0fae                      	add r26, ZL //increase the total offset by the rate
002b1a 1fbf                      	adc r27, ZH
002b1b 93a0 289c                 	sts pulse2_fx_2xx_total, r26
002b1d 93b0 289d                 	sts pulse2_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_3xx_routine:
002b1f 91e0 28a2                 	lds ZL, pulse2_fx_3xx_speed
002b21 91f0 28a3                 	lds ZH, pulse2_fx_3xx_speed+1
002b23 9630                      	adiw Z, 0
002b24 f409                      	brne sound_driver_channel1_fx_3xx_routine_check_start
002b25 c048                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_check_start:
002b26 91a0 289e                 	lds r26, pulse2_fx_3xx_start
002b28 91b0 289f                 	lds r27, pulse2_fx_3xx_start+1
002b2a 9610                      	adiw r26:r27, 0
002b2b f409                      	brne sound_driver_channel1_fx_3xx_routine_main
002b2c c041                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_main:
002b2d 91c0 28a0                 	lds r28, pulse2_fx_3xx_target
002b2f 91d0 28a1                 	lds r29, pulse2_fx_3xx_target+1
                                 
002b31 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
002b32 07bd                      	cpc r27, r29
002b33 f011                      	breq sound_driver_channel1_fx_3xx_routine_disable
002b34 f030                      	brlo sound_driver_channel1_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002b35 c01f                      	rjmp sound_driver_channel1_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel1_fx_3xx_routine_disable:
002b36 9220 289e                 	sts pulse2_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002b38 9220 289f                 	sts pulse2_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002b3a c033                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_subtract:
002b3b 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002b3c 0bdb                      	sbc r29, r27
002b3d 91a0 28a4                 	lds r26, pulse2_fx_3xx_total_offset
002b3f 91b0 28a5                 	lds r27, pulse2_fx_3xx_total_offset+1
                                 
002b41 0fae                      	add r26, ZL //add the speed to the total offset
002b42 1fbf                      	adc r27, ZH
002b43 1bca                      	sub r28, r26 //invert the total difference with the total offset
002b44 0bdb                      	sbc r29, r27
002b45 f380                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002b46 93a0 28a4                 	sts pulse2_fx_3xx_total_offset, r26 //store the new total offset
002b48 93b0 28a5                 	sts pulse2_fx_3xx_total_offset+1, r27
                                 
002b4a 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the current timer period
002b4c 91b0 0a9d                 	lds r27, TCB1_CCMPH
002b4e 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002b4f 0bbd                      	sbc r27, r29
002b50 93a0 0a9c                 	sts TCB1_CCMPL, r26
002b52 93b0 0a9d                 	sts TCB1_CCMPH, r27
002b54 c019                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_add:
002b55 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002b56 0bbd                      	sbc r27, r29
002b57 91c0 28a4                 	lds r28, pulse2_fx_3xx_total_offset
002b59 91d0 28a5                 	lds r29, pulse2_fx_3xx_total_offset+1
                                 
002b5b 0fce                      	add r28, ZL //add the speed to the total offset
002b5c 1fdf                      	adc r29, ZH
002b5d 1bac                      	sub r26, r28 //invert the total difference with the total offset
002b5e 0bbd                      	sbc r27, r29
002b5f f2b0                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002b60 93c0 28a4                 	sts pulse2_fx_3xx_total_offset, r28 //store the new total offset
002b62 93d0 28a5                 	sts pulse2_fx_3xx_total_offset+1, r29
                                 
002b64 91c0 0a9c                 	lds r28, TCB1_CCMPL //load the current timer period
002b66 91d0 0a9d                 	lds r29, TCB1_CCMPH
002b68 0fca                      	add r28, r26 //offset the current timer period with the total offset
002b69 1fdb                      	adc r29, r27
002b6a 93c0 0a9c                 	sts TCB1_CCMPL, r28
002b6c 93d0 0a9d                 	sts TCB1_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel1_fx_4xy_routine:
002b6e 91a0 28a6                 	lds r26, pulse2_fx_4xy_speed
002b70 15a2                      	cp r26, zero
002b71 f409                      	brne sound_driver_channel1_fx_4xy_routine_continue
002b72 c05c                      	rjmp sound_driver_channel1_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel1_fx_4xy_routine_continue:
002b73 91b0 28a7                 	lds r27, pulse2_fx_4xy_depth
002b75 91c0 28a8                 	lds r28, pulse2_fx_4xy_phase
002b77 0fca                      	add r28, r26 //increase the phase by the speed
002b78 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
002b79 f008                      	brlo sound_driver_channel1_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002b7a 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase:
002b7b 93c0 28a8                 	sts pulse2_fx_4xy_phase, r28 //store the new phase
002b7d 31c0                      	cpi r28, 16
002b7e f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_0
002b7f 32c0                      	cpi r28, 32
002b80 f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_1
002b81 33c0                      	cpi r28, 48
002b82 f030                      	brlo sound_driver_channel1_fx_4xy_routine_phase_2
002b83 c007                      	rjmp sound_driver_channel1_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_0:
002b84 70cf                      	andi r28, 0x0F //mask for values 0-15
002b85 c029                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_1:
002b86 6fc0                      	ori r28, 0xF0
002b87 95c0                      	com r28 //invert values 0-15
002b88 c026                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_2:
002b89 70cf                      	andi r28, 0x0F //mask for values 0-15
002b8a c003                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_3:
002b8b 6fc0                      	ori r28, 0xF0
002b8c 95c0                      	com r28 //invert values 0-15
002b8d c000                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_add:
002b8e 95b2                      	swap r27 //multiply depth by 16
002b8f 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002b90 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002b91 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002b92 0fec                      	add ZL, r28 //offset the table by the depth+phase
002b93 1df2                      	adc ZH, zero
002b94 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002b95 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002b96 937f                      	push r23
002b97 2f6c                      	mov r22, r28 //store the vibrato value into r22
002b98 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002b99 9f67                      	mul r22, r23
002b9a 917f                      	pop r23
002b9b 916f                      	pop r22
                                 
002b9c 9416                      	lsr r1 //shift out the fractional bits
002b9d 9407                      	ror r0
002b9e 9416                      	lsr r1
002b9f 9407                      	ror r0
002ba0 9416                      	lsr r1
002ba1 9407                      	ror r0
002ba2 9416                      	lsr r1
002ba3 9407                      	ror r0
                                 	
002ba4 91a0 0a9c                 	lds r26, TCB1_CCMPL
002ba6 91b0 0a9d                 	lds r27, TCB1_CCMPH
002ba8 0da0                      	add r26, r0
002ba9 1db1                      	adc r27, r1
002baa 93a0 0a9c                 	sts TCB1_CCMPL, r26
002bac 93b0 0a9d                 	sts TCB1_CCMPH, r27
002bae c020                      	rjmp sound_driver_channel1_fx_7xy_routine
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_subtract:
002baf 95b2                      	swap r27 //multiply depth by 16
002bb0 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002bb1 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002bb2 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002bb3 0fec                      	add ZL, r28 //offset the table by the depth+phase
002bb4 1df2                      	adc ZH, zero
002bb5 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002bb6 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002bb7 937f                      	push r23
002bb8 2f6c                      	mov r22, r28 //store the vibrato value into r22
002bb9 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002bba 9f67                      	mul r22, r23
002bbb 917f                      	pop r23
002bbc 916f                      	pop r22
                                 
002bbd 9416                      	lsr r1 //shift out the fractional bits
002bbe 9407                      	ror r0
002bbf 9416                      	lsr r1
002bc0 9407                      	ror r0
002bc1 9416                      	lsr r1
002bc2 9407                      	ror r0
002bc3 9416                      	lsr r1
002bc4 9407                      	ror r0
                                 
002bc5 91a0 0a9c                 	lds r26, TCB1_CCMPL
002bc7 91b0 0a9d                 	lds r27, TCB1_CCMPH
002bc9 19a0                      	sub r26, r0
002bca 09b1                      	sbc r27, r1
002bcb 93a0 0a9c                 	sts TCB1_CCMPL, r26
002bcd 93b0 0a9d                 	sts TCB1_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_7xy_routine:
002bcf 91a0 28a9                 	lds r26, pulse2_fx_7xy_speed
002bd1 15a2                      	cp r26, zero
002bd2 f0f1                      	breq sound_driver_channel1_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
002bd3 91b0 28aa                 	lds r27, pulse2_fx_7xy_depth
002bd5 91c0 28ab                 	lds r28, pulse2_fx_7xy_phase
002bd7 0fca                      	add r28, r26 //increase the phase by the speed
002bd8 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
002bd9 f010                      	brlo sound_driver_channel1_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
002bda e0c0                      	ldi r28, 0x00
002bdb 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase:
002bdc 93c0 28ab                 	sts pulse2_fx_7xy_phase, r28 //store the new phase
002bde 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
002bdf ffc4                      	sbrs r28, 4
002be0 c001                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_0
002be1 c002                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel1_fx_7xy_routine_phase_0:
002be2 70cf                      	andi r28, 0x0F //mask for values 0-15
002be3 c003                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase_1:
002be4 6fc0                      	ori r28, 0xF0
002be5 95c0                      	com r28 //invert values 0-15
002be6 c000                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_load:
002be7 95b2                      	swap r27 //multiply depth by 16
002be8 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002be9 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002bea e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002beb 0fec                      	add ZL, r28 //offset the table by the depth+phase
002bec 1df2                      	adc ZH, zero
002bed 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002bee 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
002bef 93c0 28ac                 	sts pulse2_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Axy_routine:
002bf1 91b0 28ad                 	lds r27, pulse2_fx_Axy
002bf3 15b2                      	cp r27, zero
002bf4 f0e9                      	breq sound_driver_channel1_fx_Qxy_routine //0 means that the effect is not in use
                                 	
002bf5 91a0 280d                 	lds r26, pulse2_fractional_volume //load fractional volume representation of the channel
002bf7 91c0 2808                 	lds r28, pulse2_param //load the integer volume representation of the channel
002bf9 2fda                      	mov r29, r26 //copy fractional volume into r29
002bfa 2fec                      	mov r30, r28 //copy the pulse2_param into r30
002bfb 95e2                      	swap r30
002bfc 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
002bfd 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
002bfe 17ed                      	cp r30, r29 //compare the fractional and integer volumes
002bff f009                      	breq sound_driver_channel1_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel1_fx_Axy_routine_reload:
002c00 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate:
002c01 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
002c02 c004                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_addition:
002c03 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002c04 f428                      	brcc sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002c05 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
002c06 c003                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_subtraction:
002c07 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002c08 f008                      	brcs sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002c09 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_store:
002c0a 93a0 280d                 	sts pulse2_fractional_volume, r26 //store the new fractional volume
002c0c 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
002c0d 95a2                      	swap r26
002c0e 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
002c0f 2bca                      	or r28, r26 //store the new volume back into pulse2_param
002c10 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel1_fx_Qxy_routine:
002c12 91e0 28b2                 	lds ZL, pulse2_fx_Qxy_target
002c14 91f0 28b3                 	lds ZH, pulse2_fx_Qxy_target+1
002c16 9630                      	adiw Z, 0
002c17 f139                      	breq sound_driver_channel1_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002c18 91a0 28b6                 	lds r26, pulse2_fx_Qxy_total_offset
002c1a 91b0 28b7                 	lds r27, pulse2_fx_Qxy_total_offset+1
002c1c 91c0 0a9c                 	lds r28, TCB1_CCMPL
002c1e 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
002c20 1bec                      	sub ZL, r28 //calculate the difference to the target
002c21 0bfd                      	sbc ZH, r29
002c22 f408                      	brsh sound_driver_channel1_fx_Qxy_routine_end //if the target has been reached (or passed)
002c23 f088                      	brlo sound_driver_channel1_fx_Qxy_routine_add
                                 
                                 sound_driver_channel1_fx_Qxy_routine_end:
002c24 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
002c25 0bbf                      	sbc r27, ZH
                                 
002c26 91c0 28b0                 	lds r28, pulse2_fx_Pxx_total
002c28 91d0 28b1                 	lds r29, pulse2_fx_Pxx_total+1
                                 
002c2a 0fac                      	add r26, r28
002c2b 1fbd                      	adc r27, r29
                                 
002c2c 93a0 28b6                 	sts pulse2_fx_Qxy_total_offset, r26 //store the total offset
002c2e 93b0 28b7                 	sts pulse2_fx_Qxy_total_offset+1, r27
002c30 9220 28b2                 	sts pulse2_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
002c32 9220 28b3                 	sts pulse2_fx_Qxy_target+1, zero
002c34 c00a                      	rjmp sound_driver_channel1_fx_Rxy_routine
                                 
                                 sound_driver_channel1_fx_Qxy_routine_add:
002c35 91c0 28b4                 	lds r28, pulse2_fx_Qxy_speed
002c37 91d0 28b5                 	lds r29, pulse2_fx_Qxy_speed+1
002c39 0fac                      	add r26, r28 //increase the total offset by the speed
002c3a 1fbd                      	adc r27, r29
002c3b 93a0 28b6                 	sts pulse2_fx_Qxy_total_offset, r26 //store the total offset
002c3d 93b0 28b7                 	sts pulse2_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Rxy_routine:
002c3f 91e0 28b8                 	lds ZL, pulse2_fx_Rxy_target
002c41 91f0 28b9                 	lds ZH, pulse2_fx_Rxy_target+1
002c43 9630                      	adiw Z, 0
002c44 f139                      	breq sound_driver_instrument_routine_channel2_volume //if the effect is not enabled, skip the routine
                                 
002c45 91a0 28bc                 	lds r26, pulse2_fx_Rxy_total_offset
002c47 91b0 28bd                 	lds r27, pulse2_fx_Rxy_total_offset+1
002c49 91c0 0a9c                 	lds r28, TCB1_CCMPL
002c4b 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
002c4d 1bce                      	sub r28, ZL //calculate the difference to the target
002c4e 0bdf                      	sbc r29, ZH
002c4f f408                      	brsh sound_driver_channel1_fx_Rxy_routine_end //if the target has been reached (or passed)
002c50 f088                      	brlo sound_driver_channel1_fx_Rxy_routine_add
                                 
                                 sound_driver_channel1_fx_Rxy_routine_end:
002c51 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
002c52 0bbd                      	sbc r27, r29
                                 
002c53 91c0 28b0                 	lds r28, pulse2_fx_Pxx_total
002c55 91d0 28b1                 	lds r29, pulse2_fx_Pxx_total+1
                                 
002c57 0fac                      	add r26, r28
002c58 1fbd                      	adc r27, r29
                                 
002c59 93a0 28bc                 	sts pulse2_fx_Rxy_total_offset, r26 //store the total offset
002c5b 93b0 28bd                 	sts pulse2_fx_Rxy_total_offset+1, r27
002c5d 9220 28b8                 	sts pulse2_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
002c5f 9220 28b9                 	sts pulse2_fx_Rxy_target+1, zero
002c61 c00a                      	rjmp sound_driver_instrument_routine_channel2_volume
                                 
                                 sound_driver_channel1_fx_Rxy_routine_add:
002c62 91c0 28ba                 	lds r28, pulse2_fx_Rxy_speed
002c64 91d0 28bb                 	lds r29, pulse2_fx_Rxy_speed+1
002c66 0fac                      	add r26, r28 //increase the total offset by the speed
002c67 1fbd                      	adc r27, r29
002c68 93a0 28bc                 	sts pulse2_fx_Rxy_total_offset, r26 //store the total offset
002c6a 93b0 28bd                 	sts pulse2_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume:
002c6c 91e0 28c6                 	lds ZL, triangle_volume_macro
002c6e 91f0 28c7                 	lds ZH, triangle_volume_macro+1
002c70 9630                      	adiw Z, 0
002c71 f199                      	breq sound_driver_instrument_routine_channel2_volume_default //if no volume macro is in use, do nothing
002c72 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002c73 1fff                      	rol ZH
002c74 91a0 28c8                 	lds r26, triangle_volume_macro_offset
002c76 0fea                      	add ZL, r26
002c77 1df2                      	adc ZH, zero
                                 
002c78 91b0 28ca                 	lds r27, triangle_volume_macro_release
002c7a 17ba                      	cp r27, r26
002c7b f429                      	brne sound_driver_instrument_routine_channel2_volume_increment //if the current offset is not equal to the release index, increment the offset
002c7c 91a0 28c9                 	lds r26, triangle_volume_macro_loop
002c7e 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002c7f f010                      	brlo sound_driver_instrument_routine_channel2_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002c80 c003                      	rjmp sound_driver_instrument_routine_channel2_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_volume_increment:
002c81 95a3                      	inc r26 //increment the macro offset
002c82 93a0 28c8                 	sts triangle_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_volume_read:
002c84 91b4                      	lpm r27, Z //load volume data into r27
002c85 3fbf                      	cpi r27, 0xFF //check for macro end flag
002c86 f469                      	brne sound_driver_instrument_routine_channel2_volume_process //if the data was not the macro end flag
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_release:
002c87 91b0 28ca                 	lds r27, triangle_volume_macro_release
002c89 3fbf                      	cpi r27, 0xFF
002c8a f429                      	brne sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_loop:
002c8b 91b0 28c9                 	lds r27, triangle_volume_macro_loop //load the loop index
002c8d 93b0 28c8                 	sts triangle_volume_macro_offset, r27 //store the loop index into the offset
002c8f cfdc                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index:
002c90 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002c91 93a0 28c8                 	sts triangle_volume_macro_offset, r26
002c93 cfd8                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_process:
002c94 15b2                      	cp r27, zero
002c95 f041                      	breq sound_driver_instrument_routine_channel2_volume_process_disable
                                 sound_driver_instrument_routine_channel2_volume_process_enable:
002c96 91b0 0aa5                 	lds r27, TCB2_INTCTRL
002c98 30b1                      	cpi r27, TCB_CAPT_bm
002c99 f459                      	brne sound_driver_instrument_routine_channel2_volume_default //if the channel has already been muted, don't enable it again
002c9a e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
002c9b 93b0 0aa5                 	sts TCB2_INTCTRL, r27
002c9d c007                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 sound_driver_instrument_routine_channel2_volume_process_disable:
002c9e 9220 0aa5                 	sts TCB2_INTCTRL, zero
002ca0 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
002ca2 9220 0aad                 	sts TCB2_CCMPH, zero
002ca4 c000                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_volume_default:
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002ca5 91e0 28cb                 	lds ZL, triangle_arpeggio_macro
002ca7 91f0 28cc                 	lds ZH, triangle_arpeggio_macro+1
002ca9 9630                      	adiw Z, 0
002caa f1d9                      	breq sound_driver_instrument_routine_channel2_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002cab 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002cac 1fff                      	rol ZH
002cad 91a0 28cd                 	lds r26, triangle_arpeggio_macro_offset
002caf 0fea                      	add ZL, r26
002cb0 1df2                      	adc ZH, zero
                                 
002cb1 91b0 28cf                 	lds r27, triangle_arpeggio_macro_release
002cb3 17ba                      	cp r27, r26
002cb4 f429                      	brne sound_driver_instrument_routine_channel2_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002cb5 91a0 28ce                 	lds r26, triangle_arpeggio_macro_loop
002cb7 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002cb8 f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002cb9 c003                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_increment:
002cba 95a3                      	inc r26 //increment the macro offset
002cbb 93a0 28cd                 	sts triangle_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_read:
002cbd 91b4                      	lpm r27, Z //load arpeggio data into r27
002cbe 38b0                      	cpi r27, 0x80 //check for macro end flag
002cbf f009                      	breq sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag
002cc0 c041                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_check_mode:
002cc1 50a1                      	subi r26, 1 //keep the offset at the end flag
002cc2 93a0 28cd                 	sts triangle_arpeggio_macro_offset, r26
002cc4 91b0 28d0                 	lds r27, triangle_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002cc6 30b1                      	cpi r27, 0x01
002cc7 f048                      	brlo sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_release:
002cc8 91b0 28cf                 	lds r27, triangle_arpeggio_macro_release
002cca 3fbf                      	cpi r27, 0xFF
002ccb f4d1                      	brne sound_driver_instrument_routine_channel2_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_loop:
002ccc 91b0 28ce                 	lds r27, triangle_arpeggio_macro_loop
002cce 3fbf                      	cpi r27, 0xFF
002ccf f499                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002cd0 c015                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute:
002cd1 91b0 28cf                 	lds r27, triangle_arpeggio_macro_release
002cd3 3fbf                      	cpi r27, 0xFF
002cd4 f421                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_check_loop:
002cd5 91b0 28ce                 	lds r27, triangle_arpeggio_macro_loop //load the loop index
002cd7 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002cd8 f451                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop:
002cd9 91c0 28e3                 	lds r28, triangle_fx_0xy_sequence //check for 0xy effect
002cdb 91d0 28e4                 	lds r29, triangle_fx_0xy_sequence+1
002cdd 9620                      	adiw r29:r28, 0
002cde f469                      	brne sound_driver_instrument_routine_channel2_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002cdf 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002ce0 93a0 28cd                 	sts triangle_arpeggio_macro_offset, r26 //store the last valid index into the offset
002ce2 cfc2                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload:
002ce3 93b0 28cd                 	sts triangle_arpeggio_macro_offset, r27 //store the loop index into the offset
002ce5 cfbf                      	rjmp sound_driver_instrument_routine_channel2_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_default:
002ce6 91c0 28e3                 	lds r28, triangle_fx_0xy_sequence //load 0xy effect
002ce8 91d0 28e4                 	lds r29, triangle_fx_0xy_sequence+1
002cea 9620                      	adiw r29:r28, 0 //check for 0xy effect
002ceb f099                      	breq sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel2_arpeggio_default_xy:
002cec 95d6                      	lsr r29
002ced 95c7                      	ror r28
002cee 95d7                      	ror r29
002cef 95c7                      	ror r28
002cf0 95d7                      	ror r29
002cf1 95c7                      	ror r28
002cf2 95d7                      	ror r29
002cf3 95c7                      	ror r28
002cf4 95d7                      	ror r29
002cf5 95d2                      	swap r29
                                 
002cf6 93c0 28e3                 	sts triangle_fx_0xy_sequence, r28 //store the rolled sequence
002cf8 93d0 28e4                 	sts triangle_fx_0xy_sequence+1, r29
002cfa 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002cfb 91a0 2812                 	lds r26, triangle_note //load the current note index
002cfd 0fac                      	add r26, r28 //add the note offset
002cfe c02e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002cff 91a0 2812                 	lds r26, triangle_note //load the current note index
002d01 c02b                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process:
002d02 9220 28d1                 	sts triangle_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002d04 9220 28d2                 	sts triangle_total_pitch_offset+1, zero
002d06 9220 28d8                 	sts triangle_total_hi_pitch_offset, zero
002d08 91a0 28d0                 	lds r26, triangle_arpeggio_macro_mode
002d0a 30a1                      	cpi r26, 0x01 //absolute mode
002d0b f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_absolute
002d0c f069                      	breq sound_driver_instrument_routine_channel2_arpeggio_process_fixed
002d0d c00e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute:
002d0e 91a0 2812                 	lds r26, triangle_note //load the current note index
002d10 0fab                      	add r26, r27 //offset the note with the arpeggio data
002d11 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002d12 c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_add:
002d13 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002d14 f0c0                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
002d15 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002d16 c016                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract:
002d17 fda7                      	sbrc r26, 7 //check if result is negative
002d18 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002d19 c013                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_fixed:
002d1a 2fab                      	mov r26, r27 //move the arpeggio data into r26
002d1b c011                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative:
002d1c 91a0 2812                 	lds r26, triangle_note //load the current note index
002d1e 0fab                      	add r26, r27 //offset the note with the arpeggio data
002d1f fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002d20 c008                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_add:
002d21 93a0 2812                 	sts triangle_note, r26 //NOTE: relative mode modifies the original note index
002d23 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002d24 f040                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
002d25 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002d26 93a0 2812                 	sts triangle_note, r26
002d28 c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract:
002d29 fda7                      	sbrc r26, 7 //check if result is negative
002d2a e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002d2b 93a0 2812                 	sts triangle_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_load:
002d2d e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
002d2e e0f0                      	ldi ZH, HIGH(note_table << 1)
002d2f 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002d30 0fea                      	add ZL, r26 //add offset
002d31 1df2                      	adc ZH, zero
002d32 91a5                      	lpm r26, Z+ //load bytes
002d33 91b4                      	lpm r27, Z
002d34 93a0 0aac                 	sts TCB2_CCMPL, r26 //load the LOW bits for timer
002d36 93b0 0aad                 	sts TCB2_CCMPH, r27 //load the HIGH bits for timer
002d38 93a0 28ef                 	sts triangle_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002d3a 93b0 28f0                 	sts triangle_fx_3xx_target+1, r27
002d3c c000                      	rjmp sound_driver_instrument_routine_channel2_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch:
002d3d 91e0 28d3                 	lds ZL, triangle_pitch_macro
002d3f 91f0 28d4                 	lds ZH, triangle_pitch_macro+1
002d41 9630                      	adiw Z, 0
002d42 f409                      	brne sound_driver_instrument_routine_channel2_pitch_continue
002d43 c023                      	rjmp sound_driver_instrument_routine_channel2_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel2_pitch_continue:
002d44 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002d45 1fff                      	rol ZH
002d46 91a0 28d5                 	lds r26, triangle_pitch_macro_offset
002d48 0fea                      	add ZL, r26
002d49 1df2                      	adc ZH, zero
                                 
002d4a 91b0 28d7                 	lds r27, triangle_pitch_macro_release
002d4c 17ba                      	cp r27, r26
002d4d f429                      	brne sound_driver_instrument_routine_channel2_pitch_increment //if the current offset is not equal to the release index, increment the offset
002d4e 91a0 28d6                 	lds r26, triangle_pitch_macro_loop
002d50 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002d51 f010                      	brlo sound_driver_instrument_routine_channel2_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002d52 c003                      	rjmp sound_driver_instrument_routine_channel2_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_pitch_increment:
002d53 95a3                      	inc r26 //increment the macro offset
002d54 93a0 28d5                 	sts triangle_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_pitch_read:
002d56 91b4                      	lpm r27, Z //load pitch data into r27
002d57 38b0                      	cpi r27, 0x80 //check for macro end flag
002d58 f479                      	brne sound_driver_instrument_routine_channel2_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_release:
002d59 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002d5a 93a0 28d5                 	sts triangle_pitch_macro_offset, r26
002d5c 91b0 28d7                 	lds r27, triangle_pitch_macro_release
002d5e 3fbf                      	cpi r27, 0xFF
002d5f f439                      	brne sound_driver_instrument_routine_channel2_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_loop:
002d60 91b0 28d6                 	lds r27, triangle_pitch_macro_loop //load the loop index
002d62 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002d63 f019                      	breq sound_driver_instrument_routine_channel2_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002d64 93b0 28d5                 	sts triangle_pitch_macro_offset, r27 //store the loop index into the offset
002d66 cfd6                      	rjmp sound_driver_instrument_routine_channel2_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_default:
002d67 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel2_pitch_calculate:
002d68 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002d69 937f                      	push r23
002d6a 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
002d6b eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002d6c 0367                      	mulsu r22, r23
002d6d 917f                      	pop r23
002d6e 916f                      	pop r22
                                 
002d6f 9416                      	lsr r1 //shift out the fractional bits
002d70 9407                      	ror r0
002d71 9416                      	lsr r1
002d72 9407                      	ror r0
002d73 9416                      	lsr r1
002d74 9407                      	ror r0
002d75 9416                      	lsr r1
002d76 9407                      	ror r0
002d77 fe13                      	sbrs r1, 3 //check if result was a negative number
002d78 c002                      	rjmp sound_driver_instrument_routine_channel2_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_negative:
002d79 efb0                      	ldi r27, 0xF0
002d7a 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_offset:
002d7b 91a0 28d1                 	lds r26, triangle_total_pitch_offset
002d7d 91b0 28d2                 	lds r27, triangle_total_pitch_offset+1
002d7f 0e0a                      	add r0, r26
002d80 1e1b                      	adc r1, r27
002d81 9200 28d1                 	sts triangle_total_pitch_offset, r0
002d83 9210 28d2                 	sts triangle_total_pitch_offset+1, r1
002d85 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
002d87 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
002d89 0da0                      	add r26, r0 //offset the timer values
002d8a 1db1                      	adc r27, r1
                                 	
002d8b 91c0 28e7                 	lds r28, triangle_fx_1xx_total
002d8d 91d0 28e8                 	lds r29, triangle_fx_1xx_total+1
002d8f 1bac                      	sub r26, r28
002d90 0bbd                      	sbc r27, r29
002d91 91c0 28eb                 	lds r28, triangle_fx_2xx_total
002d93 91d0 28ec                 	lds r29, triangle_fx_2xx_total+1
002d95 0fac                      	add r26, r28
002d96 1fbd                      	adc r27, r29
002d97 91c0 28fa                 	lds r28, triangle_fx_Pxx_total
002d99 91d0 28fb                 	lds r29, triangle_fx_Pxx_total+1
002d9b 0fac                      	add r26, r28
002d9c 1fbd                      	adc r27, r29
002d9d 91c0 2900                 	lds r28, triangle_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
002d9f 91d0 2901                 	lds r29, triangle_fx_Qxy_total_offset+1
002da1 1bac                      	sub r26, r28
002da2 0bbd                      	sbc r27, r29
002da3 91c0 2906                 	lds r28, triangle_fx_Rxy_total_offset
002da5 91d0 2907                 	lds r29, triangle_fx_Rxy_total_offset+1
002da7 0fac                      	add r26, r28
002da8 1fbd                      	adc r27, r29
                                 
002da9 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
002dab 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel2_hi_pitch:
002dad 91e0 28d9                 	lds ZL, triangle_hi_pitch_macro
002daf 91f0 28da                 	lds ZH, triangle_hi_pitch_macro+1
002db1 9630                      	adiw Z, 0
002db2 f409                      	brne sound_driver_instrument_routine_channel2_hi_pitch_continue
002db3 c03c                      	rjmp sound_driver_instrument_routine_channel2_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel2_hi_pitch_continue:
002db4 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002db5 1fff                      	rol ZH
002db6 91a0 28db                 	lds r26, triangle_hi_pitch_macro_offset
002db8 0fea                      	add ZL, r26
002db9 1df2                      	adc ZH, zero
                                 
002dba 91b0 28dd                 	lds r27, triangle_hi_pitch_macro_release
002dbc 17ba                      	cp r27, r26
002dbd f429                      	brne sound_driver_instrument_routine_channel2_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002dbe 91a0 28dc                 	lds r26, triangle_hi_pitch_macro_loop
002dc0 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002dc1 f010                      	brlo sound_driver_instrument_routine_channel2_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002dc2 c003                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_increment:
002dc3 95a3                      	inc r26 //increment the macro offset
002dc4 93a0 28db                 	sts triangle_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_hi_pitch_read:
002dc6 91b4                      	lpm r27, Z //load hi pitch data into r27
002dc7 38b0                      	cpi r27, 0x80 //check for macro end flag
002dc8 f489                      	brne sound_driver_instrument_routine_channel2_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_release:
002dc9 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002dca 93a0 28db                 	sts triangle_hi_pitch_macro_offset, r26
002dcc 91b0 28dd                 	lds r27, triangle_hi_pitch_macro_release
002dce 3fbf                      	cpi r27, 0xFF
002dcf f439                      	brne sound_driver_instrument_routine_channel2_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_loop:
002dd0 91b0 28dc                 	lds r27, triangle_hi_pitch_macro_loop //load the loop index
002dd2 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002dd3 f019                      	breq sound_driver_instrument_routine_channel2_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002dd4 93b0 28db                 	sts triangle_hi_pitch_macro_offset, r27 //store the loop index into the offset
002dd6 cfd6                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_default:
002dd7 91b0 28d8                 	lds r27, triangle_total_hi_pitch_offset
002dd9 c005                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate:
002dda 91a0 28d8                 	lds r26, triangle_total_hi_pitch_offset //load the total hi pitch offset to change
002ddc 0fba                      	add r27, r26
002ddd 93b0 28d8                 	sts triangle_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply:
002ddf 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002de0 937f                      	push r23
002de1 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002de2 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002de3 0367                      	mulsu r22, r23
002de4 917f                      	pop r23
002de5 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_offset:
002de6 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
002de8 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
002dea 0da0                      	add r26, r0 //offset the timer values
002deb 1db1                      	adc r27, r1
002dec 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
002dee 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: The triangle channel does not have a duty cycle
                                 sound_driver_instrument_routine_channel2_duty:
                                 
                                 
                                 
                                 sound_driver_channel2_fx_routines:
                                 sound_driver_channel2_fx_1xx_routine:
002df0 91e0 28e5                 	lds ZL, triangle_fx_1xx
002df2 91f0 28e6                 	lds ZH, triangle_fx_1xx+1
002df4 9630                      	adiw Z, 0
002df5 f051                      	breq sound_driver_channel2_fx_2xx_routine
                                 
002df6 91a0 28e7                 	lds r26, triangle_fx_1xx_total //load the rate to change the pitch by
002df8 91b0 28e8                 	lds r27, triangle_fx_1xx_total+1
002dfa 0fae                      	add r26, ZL //increase the total offset by the rate
002dfb 1fbf                      	adc r27, ZH
002dfc 93a0 28e7                 	sts triangle_fx_1xx_total, r26
002dfe 93b0 28e8                 	sts triangle_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_2xx_routine:
002e00 91e0 28e9                 	lds ZL, triangle_fx_2xx
002e02 91f0 28ea                 	lds ZH, triangle_fx_2xx+1
002e04 9630                      	adiw Z, 0
002e05 f051                      	breq sound_driver_channel2_fx_3xx_routine
                                 
002e06 91a0 28eb                 	lds r26, triangle_fx_2xx_total //load the rate to change the pitch by
002e08 91b0 28ec                 	lds r27, triangle_fx_2xx_total+1
002e0a 0fae                      	add r26, ZL //increase the total offset by the rate
002e0b 1fbf                      	adc r27, ZH
002e0c 93a0 28eb                 	sts triangle_fx_2xx_total, r26
002e0e 93b0 28ec                 	sts triangle_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_3xx_routine:
002e10 91e0 28f1                 	lds ZL, triangle_fx_3xx_speed
002e12 91f0 28f2                 	lds ZH, triangle_fx_3xx_speed+1
002e14 9630                      	adiw Z, 0
002e15 f409                      	brne sound_driver_channel2_fx_3xx_routine_check_start
002e16 c048                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_check_start:
002e17 91a0 28ed                 	lds r26, triangle_fx_3xx_start
002e19 91b0 28ee                 	lds r27, triangle_fx_3xx_start+1
002e1b 9610                      	adiw r26:r27, 0
002e1c f409                      	brne sound_driver_channel2_fx_3xx_routine_main
002e1d c041                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_main:
002e1e 91c0 28ef                 	lds r28, triangle_fx_3xx_target
002e20 91d0 28f0                 	lds r29, triangle_fx_3xx_target+1
                                 
002e22 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
002e23 07bd                      	cpc r27, r29
002e24 f011                      	breq sound_driver_channel2_fx_3xx_routine_disable
002e25 f030                      	brlo sound_driver_channel2_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002e26 c01f                      	rjmp sound_driver_channel2_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel2_fx_3xx_routine_disable:
002e27 9220 28ed                 	sts triangle_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002e29 9220 28ee                 	sts triangle_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002e2b c033                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_subtract:
002e2c 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002e2d 0bdb                      	sbc r29, r27
002e2e 91a0 28f3                 	lds r26, triangle_fx_3xx_total_offset
002e30 91b0 28f4                 	lds r27, triangle_fx_3xx_total_offset+1
                                 
002e32 0fae                      	add r26, ZL //add the speed to the total offset
002e33 1fbf                      	adc r27, ZH
002e34 1bca                      	sub r28, r26 //invert the total difference with the total offset
002e35 0bdb                      	sbc r29, r27
002e36 f380                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002e37 93a0 28f3                 	sts triangle_fx_3xx_total_offset, r26 //store the new total offset
002e39 93b0 28f4                 	sts triangle_fx_3xx_total_offset+1, r27
                                 
002e3b 91a0 0aac                 	lds r26, TCB2_CCMPL //load the current timer period
002e3d 91b0 0aad                 	lds r27, TCB2_CCMPH
002e3f 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002e40 0bbd                      	sbc r27, r29
002e41 93a0 0aac                 	sts TCB2_CCMPL, r26
002e43 93b0 0aad                 	sts TCB2_CCMPH, r27
002e45 c019                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_add:
002e46 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002e47 0bbd                      	sbc r27, r29
002e48 91c0 28f3                 	lds r28, triangle_fx_3xx_total_offset
002e4a 91d0 28f4                 	lds r29, triangle_fx_3xx_total_offset+1
                                 
002e4c 0fce                      	add r28, ZL //add the speed to the total offset
002e4d 1fdf                      	adc r29, ZH
002e4e 1bac                      	sub r26, r28 //invert the total difference with the total offset
002e4f 0bbd                      	sbc r27, r29
002e50 f2b0                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002e51 93c0 28f3                 	sts triangle_fx_3xx_total_offset, r28 //store the new total offset
002e53 93d0 28f4                 	sts triangle_fx_3xx_total_offset+1, r29
                                 
002e55 91c0 0aac                 	lds r28, TCB2_CCMPL //load the current timer period
002e57 91d0 0aad                 	lds r29, TCB2_CCMPH
002e59 0fca                      	add r28, r26 //offset the current timer period with the total offset
002e5a 1fdb                      	adc r29, r27
002e5b 93c0 0aac                 	sts TCB2_CCMPL, r28
002e5d 93d0 0aad                 	sts TCB2_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel2_fx_4xy_routine:
002e5f 91a0 28f5                 	lds r26, triangle_fx_4xy_speed
002e61 15a2                      	cp r26, zero
002e62 f409                      	brne sound_driver_channel2_fx_4xy_routine_continue
002e63 c05c                      	rjmp sound_driver_channel2_fx_Qxy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel2_fx_4xy_routine_continue:
002e64 91b0 28f6                 	lds r27, triangle_fx_4xy_depth
002e66 91c0 28f7                 	lds r28, triangle_fx_4xy_phase
002e68 0fca                      	add r28, r26 //increase the phase by the speed
002e69 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
002e6a f008                      	brlo sound_driver_channel2_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002e6b 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase:
002e6c 93c0 28f7                 	sts triangle_fx_4xy_phase, r28 //store the new phase
002e6e 31c0                      	cpi r28, 16
002e6f f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_0
002e70 32c0                      	cpi r28, 32
002e71 f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_1
002e72 33c0                      	cpi r28, 48
002e73 f030                      	brlo sound_driver_channel2_fx_4xy_routine_phase_2
002e74 c007                      	rjmp sound_driver_channel2_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_0:
002e75 70cf                      	andi r28, 0x0F //mask for values 0-15
002e76 c029                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_1:
002e77 6fc0                      	ori r28, 0xF0
002e78 95c0                      	com r28 //invert values 0-15
002e79 c026                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_2:
002e7a 70cf                      	andi r28, 0x0F //mask for values 0-15
002e7b c003                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_3:
002e7c 6fc0                      	ori r28, 0xF0
002e7d 95c0                      	com r28 //invert values 0-15
002e7e c000                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_add:
002e7f 95b2                      	swap r27 //multiply depth by 16
002e80 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002e81 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002e82 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002e83 0fec                      	add ZL, r28 //offset the table by the depth+phase
002e84 1df2                      	adc ZH, zero
002e85 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002e86 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002e87 937f                      	push r23
002e88 2f6c                      	mov r22, r28 //store the vibrato value into r22
002e89 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002e8a 9f67                      	mul r22, r23
002e8b 917f                      	pop r23
002e8c 916f                      	pop r22
                                 
002e8d 9416                      	lsr r1 //shift out the fractional bits
002e8e 9407                      	ror r0
002e8f 9416                      	lsr r1
002e90 9407                      	ror r0
002e91 9416                      	lsr r1
002e92 9407                      	ror r0
002e93 9416                      	lsr r1
002e94 9407                      	ror r0
                                 	
002e95 91a0 0aac                 	lds r26, TCB2_CCMPL
002e97 91b0 0aad                 	lds r27, TCB2_CCMPH
002e99 0da0                      	add r26, r0
002e9a 1db1                      	adc r27, r1
002e9b 93a0 0aac                 	sts TCB2_CCMPL, r26
002e9d 93b0 0aad                 	sts TCB2_CCMPH, r27
002e9f c020                      	rjmp sound_driver_channel2_fx_Qxy_routine
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_subtract:
002ea0 95b2                      	swap r27 //multiply depth by 16
002ea1 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002ea2 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002ea3 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002ea4 0fec                      	add ZL, r28 //offset the table by the depth+phase
002ea5 1df2                      	adc ZH, zero
002ea6 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002ea7 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002ea8 937f                      	push r23
002ea9 2f6c                      	mov r22, r28 //store the vibrato value into r22
002eaa eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002eab 9f67                      	mul r22, r23
002eac 917f                      	pop r23
002ead 916f                      	pop r22
                                 
002eae 9416                      	lsr r1 //shift out the fractional bits
002eaf 9407                      	ror r0
002eb0 9416                      	lsr r1
002eb1 9407                      	ror r0
002eb2 9416                      	lsr r1
002eb3 9407                      	ror r0
002eb4 9416                      	lsr r1
002eb5 9407                      	ror r0
                                 
002eb6 91a0 0aac                 	lds r26, TCB2_CCMPL
002eb8 91b0 0aad                 	lds r27, TCB2_CCMPH
002eba 19a0                      	sub r26, r0
002ebb 09b1                      	sbc r27, r1
002ebc 93a0 0aac                 	sts TCB2_CCMPL, r26
002ebe 93b0 0aad                 	sts TCB2_CCMPH, r27
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel2_fx_Qxy_routine:
002ec0 91e0 28fc                 	lds ZL, triangle_fx_Qxy_target
002ec2 91f0 28fd                 	lds ZH, triangle_fx_Qxy_target+1
002ec4 9630                      	adiw Z, 0
002ec5 f139                      	breq sound_driver_channel2_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002ec6 91a0 2900                 	lds r26, triangle_fx_Qxy_total_offset
002ec8 91b0 2901                 	lds r27, triangle_fx_Qxy_total_offset+1
002eca 91c0 0aac                 	lds r28, TCB2_CCMPL
002ecc 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
002ece 1bec                      	sub ZL, r28 //calculate the difference to the target
002ecf 0bfd                      	sbc ZH, r29
002ed0 f408                      	brsh sound_driver_channel2_fx_Qxy_routine_end //if the target has been reached (or passed)
002ed1 f088                      	brlo sound_driver_channel2_fx_Qxy_routine_add
                                 
                                 sound_driver_channel2_fx_Qxy_routine_end:
002ed2 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
002ed3 0bbf                      	sbc r27, ZH
                                 
002ed4 91c0 28fa                 	lds r28, triangle_fx_Pxx_total
002ed6 91d0 28fb                 	lds r29, triangle_fx_Pxx_total+1
                                 
002ed8 0fac                      	add r26, r28
002ed9 1fbd                      	adc r27, r29
                                 
002eda 93a0 2900                 	sts triangle_fx_Qxy_total_offset, r26 //store the total offset
002edc 93b0 2901                 	sts triangle_fx_Qxy_total_offset+1, r27
002ede 9220 28fc                 	sts triangle_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
002ee0 9220 28fd                 	sts triangle_fx_Qxy_target+1, zero
002ee2 c00a                      	rjmp sound_driver_channel2_fx_Rxy_routine
                                 
                                 sound_driver_channel2_fx_Qxy_routine_add:
002ee3 91c0 28fe                 	lds r28, triangle_fx_Qxy_speed
002ee5 91d0 28ff                 	lds r29, triangle_fx_Qxy_speed+1
002ee7 0fac                      	add r26, r28 //increase the total offset by the speed
002ee8 1fbd                      	adc r27, r29
002ee9 93a0 2900                 	sts triangle_fx_Qxy_total_offset, r26 //store the total offset
002eeb 93b0 2901                 	sts triangle_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_Rxy_routine:
002eed 91e0 2902                 	lds ZL, triangle_fx_Rxy_target
002eef 91f0 2903                 	lds ZH, triangle_fx_Rxy_target+1
002ef1 9630                      	adiw Z, 0
002ef2 f139                      	breq sound_driver_instrument_routine_channel3_volume //if the effect is not enabled, skip the routine
                                 
002ef3 91a0 2906                 	lds r26, triangle_fx_Rxy_total_offset
002ef5 91b0 2907                 	lds r27, triangle_fx_Rxy_total_offset+1
002ef7 91c0 0aac                 	lds r28, TCB2_CCMPL
002ef9 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
002efb 1bce                      	sub r28, ZL //calculate the difference to the target
002efc 0bdf                      	sbc r29, ZH
002efd f408                      	brsh sound_driver_channel2_fx_Rxy_routine_end //if the target has been reached (or passed)
002efe f088                      	brlo sound_driver_channel2_fx_Rxy_routine_add
                                 
                                 sound_driver_channel2_fx_Rxy_routine_end:
002eff 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
002f00 0bbd                      	sbc r27, r29
                                 
002f01 91c0 28fa                 	lds r28, triangle_fx_Pxx_total
002f03 91d0 28fb                 	lds r29, triangle_fx_Pxx_total+1
                                 
002f05 0fac                      	add r26, r28
002f06 1fbd                      	adc r27, r29
                                 
002f07 93a0 2906                 	sts triangle_fx_Rxy_total_offset, r26 //store the total offset
002f09 93b0 2907                 	sts triangle_fx_Rxy_total_offset+1, r27
002f0b 9220 2902                 	sts triangle_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
002f0d 9220 2903                 	sts triangle_fx_Rxy_target+1, zero
002f0f c00a                      	rjmp sound_driver_instrument_routine_channel3_volume
                                 
                                 sound_driver_channel2_fx_Rxy_routine_add:
002f10 91c0 2904                 	lds r28, triangle_fx_Rxy_speed
002f12 91d0 2905                 	lds r29, triangle_fx_Rxy_speed+1
002f14 0fac                      	add r26, r28 //increase the total offset by the speed
002f15 1fbd                      	adc r27, r29
002f16 93a0 2906                 	sts triangle_fx_Rxy_total_offset, r26 //store the total offset
002f18 93b0 2907                 	sts triangle_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume:
002f1a 91e0 2910                 	lds ZL, noise_volume_macro
002f1c 91f0 2911                 	lds ZH, noise_volume_macro+1
002f1e 9630                      	adiw Z, 0
002f1f f1a1                      	breq sound_driver_instrument_routine_channel3_volume_default //if no volume macro is in use, use default multiplier of F
002f20 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002f21 1fff                      	rol ZH
002f22 91a0 2912                 	lds r26, noise_volume_macro_offset
002f24 0fea                      	add ZL, r26
002f25 1df2                      	adc ZH, zero
                                 
002f26 91b0 2914                 	lds r27, noise_volume_macro_release
002f28 17ba                      	cp r27, r26
002f29 f429                      	brne sound_driver_instrument_routine_channel3_volume_increment //if the current offset is not equal to the release index, increment the offset
002f2a 91a0 2913                 	lds r26, noise_volume_macro_loop
002f2c 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002f2d f010                      	brlo sound_driver_instrument_routine_channel3_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002f2e c003                      	rjmp sound_driver_instrument_routine_channel3_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_volume_increment:
002f2f 95a3                      	inc r26 //increment the macro offset
002f30 93a0 2912                 	sts noise_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_volume_read:
002f32 91b4                      	lpm r27, Z //load volume data into r27
002f33 3fbf                      	cpi r27, 0xFF //check for macro end flag
002f34 f469                      	brne sound_driver_instrument_routine_channel3_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_check_release:
002f35 91b0 2914                 	lds r27, noise_volume_macro_release
002f37 3fbf                      	cpi r27, 0xFF
002f38 f429                      	brne sound_driver_instrument_routine_channel3_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_check_loop:
002f39 91b0 2913                 	lds r27, noise_volume_macro_loop //load the loop index
002f3b 93b0 2912                 	sts noise_volume_macro_offset, r27 //store the loop index into the offset
002f3d cfdc                      	rjmp sound_driver_instrument_routine_channel3_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_last_index:
002f3e 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002f3f 93a0 2912                 	sts noise_volume_macro_offset, r26
002f41 cfd8                      	rjmp sound_driver_instrument_routine_channel3_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume_calculate:
002f42 ece6                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
002f43 e6f5                      	ldi ZH, HIGH(volumes << 1)
002f44 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
002f45 0feb                      	add ZL, r27 //add offset to the table
002f46 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel3_volume_load:
002f47 91b0 2813                 	lds r27, noise_param //load main volume
002f49 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002f4a 91a0 2945                 	lds r26, noise_fx_7xy_value
002f4c 30a0                      	cpi r26, 0x00
002f4d f481                      	brne sound_driver_instrument_routine_channel3_volume_load_7xy
                                 
002f4e 0feb                      	add ZL, r27 //offset the volume table by the main volume
002f4f 1df2                      	adc ZH, zero
002f50 91b4                      	lpm r27, Z
002f51 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002f53 c024                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_default:
002f54 91b0 2813                 	lds r27, noise_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
002f56 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002f57 91a0 2945                 	lds r26, noise_fx_7xy_value
002f59 30a0                      	cpi r26, 0x00
002f5a f4a1                      	brne sound_driver_instrument_routine_channel3_volume_default_7xy
002f5b 93b0 2816                 	sts noise_output_volume, r27
002f5d c01a                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_load_7xy:
002f5e 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002f5f f040                      	brcs sound_driver_instrument_routine_channel3_volume_load_7xy_overflow
002f60 f039                      	breq sound_driver_instrument_routine_channel3_volume_load_7xy_overflow
002f61 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
                                 
002f62 0feb                      	add ZL, r27 //offset the volume table by the main volume
002f63 1df2                      	adc ZH, zero
002f64 91b4                      	lpm r27, Z
002f65 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002f67 c010                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_load_7xy_overflow:
002f68 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002f69 0feb                      	add ZL, r27 //offset the volume table by the main volume
002f6a 1df2                      	adc ZH, zero
002f6b 91b4                      	lpm r27, Z
002f6c 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002f6e c009                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_default_7xy:
002f6f 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002f70 f020                      	brcs sound_driver_instrument_routine_channel3_volume_default_7xy_overflow
002f71 f019                      	breq sound_driver_instrument_routine_channel3_volume_default_7xy_overflow
002f72 93b0 2816                 	sts noise_output_volume, r27
002f74 c003                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel3_volume_default_7xy_overflow:
002f75 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002f76 93b0 2816                 	sts noise_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002f78 91e0 2915                 	lds ZL, noise_arpeggio_macro
002f7a 91f0 2916                 	lds ZH, noise_arpeggio_macro+1
002f7c 9630                      	adiw Z, 0
002f7d f1d9                      	breq sound_driver_instrument_routine_channel3_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002f7e 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002f7f 1fff                      	rol ZH
002f80 91a0 2917                 	lds r26, noise_arpeggio_macro_offset
002f82 0fea                      	add ZL, r26
002f83 1df2                      	adc ZH, zero
                                 
002f84 91b0 2919                 	lds r27, noise_arpeggio_macro_release
002f86 17ba                      	cp r27, r26
002f87 f429                      	brne sound_driver_instrument_routine_channel3_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002f88 91a0 2918                 	lds r26, noise_arpeggio_macro_loop
002f8a 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002f8b f010                      	brlo sound_driver_instrument_routine_channel3_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002f8c c003                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_increment:
002f8d 95a3                      	inc r26 //increment the macro offset
002f8e 93a0 2917                 	sts noise_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_arpeggio_read:
002f90 91b4                      	lpm r27, Z //load arpeggio data into r27
002f91 38b0                      	cpi r27, 0x80 //check for macro end flag
002f92 f009                      	breq sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag
002f93 c041                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_check_mode:
002f94 50a1                      	subi r26, 1 //keep the offset at the end flag
002f95 93a0 2917                 	sts noise_arpeggio_macro_offset, r26
002f97 91b0 291a                 	lds r27, noise_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002f99 30b1                      	cpi r27, 0x01
002f9a f048                      	brlo sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_fixed_relative_check_release:
002f9b 91b0 2919                 	lds r27, noise_arpeggio_macro_release
002f9d 3fbf                      	cpi r27, 0xFF
002f9e f4d1                      	brne sound_driver_instrument_routine_channel3_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_fixed_relative_check_loop:
002f9f 91b0 2918                 	lds r27, noise_arpeggio_macro_loop
002fa1 3fbf                      	cpi r27, 0xFF
002fa2 f499                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002fa3 c015                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute:
002fa4 91b0 2919                 	lds r27, noise_arpeggio_macro_release
002fa6 3fbf                      	cpi r27, 0xFF
002fa7 f421                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_check_loop:
002fa8 91b0 2918                 	lds r27, noise_arpeggio_macro_loop //load the loop index
002faa 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002fab f451                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_no_loop:
002fac 91c0 292d                 	lds r28, noise_fx_0xy_sequence //check for 0xy effect
002fae 91d0 292e                 	lds r29, noise_fx_0xy_sequence+1
002fb0 9620                      	adiw r29:r28, 0
002fb1 f469                      	brne sound_driver_instrument_routine_channel3_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002fb2 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002fb3 93a0 2917                 	sts noise_arpeggio_macro_offset, r26 //store the last valid index into the offset
002fb5 cfc2                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload:
002fb6 93b0 2917                 	sts noise_arpeggio_macro_offset, r27 //store the loop index into the offset
002fb8 cfbf                      	rjmp sound_driver_instrument_routine_channel3_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_default:
002fb9 91c0 292d                 	lds r28, noise_fx_0xy_sequence //load 0xy effect
002fbb 91d0 292e                 	lds r29, noise_fx_0xy_sequence+1
002fbd 9620                      	adiw r29:r28, 0 //check for 0xy effect
002fbe f099                      	breq sound_driver_instrument_routine_channel3_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel3_arpeggio_default_xy:
002fbf 95d6                      	lsr r29
002fc0 95c7                      	ror r28
002fc1 95d7                      	ror r29
002fc2 95c7                      	ror r28
002fc3 95d7                      	ror r29
002fc4 95c7                      	ror r28
002fc5 95d7                      	ror r29
002fc6 95c7                      	ror r28
002fc7 95d7                      	ror r29
002fc8 95d2                      	swap r29
                                 
002fc9 93c0 292d                 	sts noise_fx_0xy_sequence, r28 //store the rolled sequence
002fcb 93d0 292e                 	sts noise_fx_0xy_sequence+1, r29
002fcd 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002fce 91a0 2817                 	lds r26, noise_note //load the current note index
002fd0 0fac                      	add r26, r28 //add the note offset
002fd1 c02e                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel3_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002fd2 91a0 2817                 	lds r26, noise_note //load the current note index
002fd4 c02b                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process:
002fd5 9220 291b                 	sts noise_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002fd7 9220 291c                 	sts noise_total_pitch_offset+1, zero
002fd9 9220 2922                 	sts noise_total_hi_pitch_offset, zero
002fdb 91a0 291a                 	lds r26, noise_arpeggio_macro_mode
002fdd 30a1                      	cpi r26, 0x01 //absolute mode
002fde f010                      	brlo sound_driver_instrument_routine_channel3_arpeggio_process_absolute
002fdf f069                      	breq sound_driver_instrument_routine_channel3_arpeggio_process_fixed
002fe0 c00e                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_absolute:
002fe1 91a0 2817                 	lds r26, noise_note //load the current note index
002fe3 0fab                      	add r26, r27 //offset the note with the arpeggio data
002fe4 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002fe5 c004                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_absolute_add:
002fe6 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002fe7 f0c0                      	brlo sound_driver_instrument_routine_channel3_arpeggio_process_load //if the result is valid, go load the new note
002fe8 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002fe9 c016                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_absolute_subtract:
002fea fda7                      	sbrc r26, 7 //check if result is negative
002feb e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002fec c013                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_fixed:
002fed 2fab                      	mov r26, r27 //move the arpeggio data into r26
002fee c011                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_relative:
002fef 91a0 2817                 	lds r26, noise_note //load the current note index
002ff1 0fab                      	add r26, r27 //offset the note with the arpeggio data
002ff2 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002ff3 c008                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_relative_add:
002ff4 93a0 2817                 	sts noise_note, r26 //NOTE: relative mode modifies the original note index
002ff6 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002ff7 f040                      	brlo sound_driver_instrument_routine_channel3_arpeggio_process_load //if the result is valid, go load the new note
002ff8 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002ff9 93a0 2817                 	sts noise_note, r26
002ffb c004                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_relative_subtract:
002ffc fda7                      	sbrc r26, 7 //check if result is negative
002ffd e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002ffe 93a0 2817                 	sts noise_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_load:
003000 e4e2                      	ldi ZL, LOW(noise_period_table << 1) //load in note table
003001 e0f1                      	ldi ZH, HIGH(noise_period_table << 1)
003002 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
003003 0fea                      	add ZL, r26 //add offset
003004 1df2                      	adc ZH, zero
003005 91a5                      	lpm r26, Z+ //load bytes
003006 91b4                      	lpm r27, Z
003007 93a0 0abc                 	sts TCB3_CCMPL, r26 //load the LOW bits for timer
003009 93b0 0abd                 	sts TCB3_CCMPH, r27 //load the HIGH bits for timer
00300b 93a0 2939                 	sts noise_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
00300d 93b0 293a                 	sts noise_fx_3xx_target+1, r27
00300f c000                      	rjmp sound_driver_instrument_routine_channel3_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch:
003010 91e0 291d                 	lds ZL, noise_pitch_macro
003012 91f0 291e                 	lds ZH, noise_pitch_macro+1
003014 9630                      	adiw Z, 0
003015 f409                      	brne sound_driver_instrument_routine_channel3_pitch_continue
003016 c023                      	rjmp sound_driver_instrument_routine_channel3_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel3_pitch_continue:
003017 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
003018 1fff                      	rol ZH
003019 91a0 291f                 	lds r26, noise_pitch_macro_offset
00301b 0fea                      	add ZL, r26
00301c 1df2                      	adc ZH, zero
                                 
00301d 91b0 2921                 	lds r27, noise_pitch_macro_release
00301f 17ba                      	cp r27, r26
003020 f429                      	brne sound_driver_instrument_routine_channel3_pitch_increment //if the current offset is not equal to the release index, increment the offset
003021 91a0 2920                 	lds r26, noise_pitch_macro_loop
003023 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
003024 f010                      	brlo sound_driver_instrument_routine_channel3_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
003025 c003                      	rjmp sound_driver_instrument_routine_channel3_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_pitch_increment:
003026 95a3                      	inc r26 //increment the macro offset
003027 93a0 291f                 	sts noise_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_pitch_read:
003029 91b4                      	lpm r27, Z //load pitch data into r27
00302a 38b0                      	cpi r27, 0x80 //check for macro end flag
00302b f479                      	brne sound_driver_instrument_routine_channel3_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag_check_release:
00302c 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00302d 93a0 291f                 	sts noise_pitch_macro_offset, r26
00302f 91b0 2921                 	lds r27, noise_pitch_macro_release
003031 3fbf                      	cpi r27, 0xFF
003032 f439                      	brne sound_driver_instrument_routine_channel3_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag_check_loop:
003033 91b0 2920                 	lds r27, noise_pitch_macro_loop //load the loop index
003035 3fbf                      	cpi r27, 0xFF //check if there is a loop index
003036 f019                      	breq sound_driver_instrument_routine_channel3_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
003037 93b0 291f                 	sts noise_pitch_macro_offset, r27 //store the loop index into the offset
003039 cfd6                      	rjmp sound_driver_instrument_routine_channel3_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch_default:
00303a e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel3_pitch_calculate:
00303b 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00303c 937f                      	push r23
00303d 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
00303e eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00303f 0367                      	mulsu r22, r23
003040 917f                      	pop r23
003041 916f                      	pop r22
                                 
003042 9416                      	lsr r1 //shift out the fractional bits
003043 9407                      	ror r0
003044 9416                      	lsr r1
003045 9407                      	ror r0
003046 9416                      	lsr r1
003047 9407                      	ror r0
003048 9416                      	lsr r1
003049 9407                      	ror r0
00304a fe13                      	sbrs r1, 3 //check if result was a negative number
00304b c002                      	rjmp sound_driver_instrument_routine_channel3_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel3_pitch_calculate_negative:
00304c efb0                      	ldi r27, 0xF0
00304d 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel3_pitch_calculate_offset:
00304e 91a0 291b                 	lds r26, noise_total_pitch_offset
003050 91b0 291c                 	lds r27, noise_total_pitch_offset+1
003052 0e0a                      	add r0, r26
003053 1e1b                      	adc r1, r27
003054 9200 291b                 	sts noise_total_pitch_offset, r0
003056 9210 291c                 	sts noise_total_pitch_offset+1, r1
003058 91a0 0abc                 	lds r26, TCB3_CCMPL //load the low bits for timer
00305a 91b0 0abd                 	lds r27, TCB3_CCMPH //load the high bits for timer
00305c 0da0                      	add r26, r0 //offset the timer values
00305d 1db1                      	adc r27, r1
                                 	
00305e 91c0 2931                 	lds r28, noise_fx_1xx_total
003060 91d0 2932                 	lds r29, noise_fx_1xx_total+1
003062 1bac                      	sub r26, r28
003063 0bbd                      	sbc r27, r29
003064 91c0 2935                 	lds r28, noise_fx_2xx_total
003066 91d0 2936                 	lds r29, noise_fx_2xx_total+1
003068 0fac                      	add r26, r28
003069 1fbd                      	adc r27, r29
00306a 91c0 2949                 	lds r28, noise_fx_Pxx_total
00306c 91d0 294a                 	lds r29, noise_fx_Pxx_total+1
00306e 0fac                      	add r26, r28
00306f 1fbd                      	adc r27, r29
003070 91c0 294f                 	lds r28, noise_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
003072 91d0 2950                 	lds r29, noise_fx_Qxy_total_offset+1
003074 1bac                      	sub r26, r28
003075 0bbd                      	sbc r27, r29
003076 91c0 2955                 	lds r28, noise_fx_Rxy_total_offset
003078 91d0 2956                 	lds r29, noise_fx_Rxy_total_offset+1
00307a 0fac                      	add r26, r28
00307b 1fbd                      	adc r27, r29
                                 
00307c 93a0 0abc                 	sts TCB3_CCMPL, r26 //store the new low bits for timer
00307e 93b0 0abd                 	sts TCB3_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel3_hi_pitch:
003080 91e0 2923                 	lds ZL, noise_hi_pitch_macro
003082 91f0 2924                 	lds ZH, noise_hi_pitch_macro+1
003084 9630                      	adiw Z, 0
003085 f409                      	brne sound_driver_instrument_routine_channel3_hi_pitch_continue
003086 c03c                      	rjmp sound_driver_instrument_routine_channel3_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel3_hi_pitch_continue:
003087 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
003088 1fff                      	rol ZH
003089 91a0 2925                 	lds r26, noise_hi_pitch_macro_offset
00308b 0fea                      	add ZL, r26
00308c 1df2                      	adc ZH, zero
                                 
00308d 91b0 2927                 	lds r27, noise_hi_pitch_macro_release
00308f 17ba                      	cp r27, r26
003090 f429                      	brne sound_driver_instrument_routine_channel3_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
003091 91a0 2926                 	lds r26, noise_hi_pitch_macro_loop
003093 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
003094 f010                      	brlo sound_driver_instrument_routine_channel3_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
003095 c003                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_increment:
003096 95a3                      	inc r26 //increment the macro offset
003097 93a0 2925                 	sts noise_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_hi_pitch_read:
003099 91b4                      	lpm r27, Z //load hi pitch data into r27
00309a 38b0                      	cpi r27, 0x80 //check for macro end flag
00309b f489                      	brne sound_driver_instrument_routine_channel3_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag_check_release:
00309c 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00309d 93a0 2925                 	sts noise_hi_pitch_macro_offset, r26
00309f 91b0 2927                 	lds r27, noise_hi_pitch_macro_release
0030a1 3fbf                      	cpi r27, 0xFF
0030a2 f439                      	brne sound_driver_instrument_routine_channel3_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag_check_loop:
0030a3 91b0 2926                 	lds r27, noise_hi_pitch_macro_loop //load the loop index
0030a5 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0030a6 f019                      	breq sound_driver_instrument_routine_channel3_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
0030a7 93b0 2925                 	sts noise_hi_pitch_macro_offset, r27 //store the loop index into the offset
0030a9 cfd6                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_default:
0030aa 91b0 2922                 	lds r27, noise_total_hi_pitch_offset
0030ac c005                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate:
0030ad 91a0 2922                 	lds r26, noise_total_hi_pitch_offset //load the total hi pitch offset to change
0030af 0fba                      	add r27, r26
0030b0 93b0 2922                 	sts noise_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate_multiply:
0030b2 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0030b3 937f                      	push r23
0030b4 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
0030b5 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0030b6 0367                      	mulsu r22, r23
0030b7 917f                      	pop r23
0030b8 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate_offset:
0030b9 91a0 0abc                 	lds r26, TCB3_CCMPL //load the low bits for timer
0030bb 91b0 0abd                 	lds r27, TCB3_CCMPH //load the high bits for timer
0030bd 0da0                      	add r26, r0 //offset the timer values
0030be 1db1                      	adc r27, r1
0030bf 93a0 0abc                 	sts TCB3_CCMPL, r26 //store the new low bits for timer
0030c1 93b0 0abd                 	sts TCB3_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty:
0030c3 91e0 2928                 	lds ZL, noise_duty_macro
0030c5 91f0 2929                 	lds ZH, noise_duty_macro+1
0030c7 9630                      	adiw Z, 0
0030c8 f169                      	breq sound_driver_channel3_fx_routines //if no duty macro is in use, go to the next routine
0030c9 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0030ca 1fff                      	rol ZH
0030cb 91a0 292a                 	lds r26, noise_duty_macro_offset
0030cd 0fea                      	add ZL, r26
0030ce 1df2                      	adc ZH, zero
                                 
0030cf 91b0 292c                 	lds r27, noise_duty_macro_release
0030d1 17ba                      	cp r27, r26
0030d2 f429                      	brne sound_driver_instrument_routine_channel3_duty_increment //if the current offset is not equal to the release index, increment the offset
0030d3 91a0 292b                 	lds r26, noise_duty_macro_loop
0030d5 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0030d6 f010                      	brlo sound_driver_instrument_routine_channel3_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0030d7 c01e                      	rjmp sound_driver_channel3_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel3_duty_increment:
0030d8 95a3                      	inc r26 //increment the macro offset
0030d9 93a0 292a                 	sts noise_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_duty_read:
0030db 91b4                      	lpm r27, Z //load pitch data into r27
0030dc 3fbf                      	cpi r27, 0xFF //check for macro end flag
0030dd f471                      	brne sound_driver_instrument_routine_channel3_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag_check_release:
0030de 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0030df 93a0 292a                 	sts noise_duty_macro_offset, r26
0030e1 91b0 292c                 	lds r27, noise_duty_macro_release
0030e3 3fbf                      	cpi r27, 0xFF
0030e4 f489                      	brne sound_driver_channel3_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag_check_loop:
0030e5 91b0 292b                 	lds r27, noise_duty_macro_loop //load the loop index
0030e7 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0030e8 f069                      	breq sound_driver_channel3_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
0030e9 93b0 292a                 	sts noise_duty_macro_offset, r27 //store the loop index into the offset
0030eb cfd7                      	rjmp sound_driver_instrument_routine_channel3_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty_load:
0030ec 95b6                      	lsr r27
0030ed 95b7                      	ror r27 //move mode bit to bit 7
0030ee 91c0 2814                 	lds r28, noise_period
0030f0 77cf                      	andi r28, 0b01111111
0030f1 2bcb                      	or r28, r27 //store the new noise mode
0030f2 93c0 2813                 	sts noise_param, r28
                                 
0030f4 776f                      	andi noise_sequence_HIGH, 0b01111111
0030f5 2b6b                      	or noise_sequence_HIGH, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_routines:
                                 sound_driver_channel3_fx_1xx_routine:
0030f6 91e0 292f                 	lds ZL, noise_fx_1xx
0030f8 91f0 2930                 	lds ZH, noise_fx_1xx+1
0030fa 9630                      	adiw Z, 0
0030fb f051                      	breq sound_driver_channel3_fx_2xx_routine
                                 
0030fc 91a0 2931                 	lds r26, noise_fx_1xx_total //load the rate to change the pitch by
0030fe 91b0 2932                 	lds r27, noise_fx_1xx_total+1
003100 0fae                      	add r26, ZL //increase the total offset by the rate
003101 1fbf                      	adc r27, ZH
003102 93a0 2931                 	sts noise_fx_1xx_total, r26
003104 93b0 2932                 	sts noise_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_2xx_routine:
003106 91e0 2933                 	lds ZL, noise_fx_2xx
003108 91f0 2934                 	lds ZH, noise_fx_2xx+1
00310a 9630                      	adiw Z, 0
00310b f051                      	breq sound_driver_channel3_fx_3xx_routine
                                 
00310c 91a0 2935                 	lds r26, noise_fx_2xx_total //load the rate to change the pitch by
00310e 91b0 2936                 	lds r27, noise_fx_2xx_total+1
003110 0fae                      	add r26, ZL //increase the total offset by the rate
003111 1fbf                      	adc r27, ZH
003112 93a0 2935                 	sts noise_fx_2xx_total, r26
003114 93b0 2936                 	sts noise_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_3xx_routine:
003116 91e0 293b                 	lds ZL, noise_fx_3xx_speed
003118 91f0 293c                 	lds ZH, noise_fx_3xx_speed+1
00311a 9630                      	adiw Z, 0
00311b f409                      	brne sound_driver_channel3_fx_3xx_routine_check_start
00311c c048                      	rjmp sound_driver_channel3_fx_4xy_routine
                                 
                                 sound_driver_channel3_fx_3xx_routine_check_start:
00311d 91a0 2937                 	lds r26, noise_fx_3xx_start
00311f 91b0 2938                 	lds r27, noise_fx_3xx_start+1
003121 9610                      	adiw r26:r27, 0
003122 f409                      	brne sound_driver_channel3_fx_3xx_routine_main
003123 c041                      	rjmp sound_driver_channel3_fx_4xy_routine
                                 
                                 sound_driver_channel3_fx_3xx_routine_main:
003124 91c0 2939                 	lds r28, noise_fx_3xx_target
003126 91d0 293a                 	lds r29, noise_fx_3xx_target+1
                                 
003128 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
003129 07bd                      	cpc r27, r29
00312a f011                      	breq sound_driver_channel3_fx_3xx_routine_disable
00312b f030                      	brlo sound_driver_channel3_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
00312c c01f                      	rjmp sound_driver_channel3_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel3_fx_3xx_routine_disable:
00312d 9220 2937                 	sts noise_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
00312f 9220 2938                 	sts noise_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
003131 c033                      	rjmp sound_driver_channel3_fx_4xy_routine
                                 
                                 sound_driver_channel3_fx_3xx_routine_subtract:
003132 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
003133 0bdb                      	sbc r29, r27
003134 91a0 293d                 	lds r26, noise_fx_3xx_total_offset
003136 91b0 293e                 	lds r27, noise_fx_3xx_total_offset+1
                                 
003138 0fae                      	add r26, ZL //add the speed to the total offset
003139 1fbf                      	adc r27, ZH
00313a 1bca                      	sub r28, r26 //invert the total difference with the total offset
00313b 0bdb                      	sbc r29, r27
00313c f380                      	brlo sound_driver_channel3_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
00313d 93a0 293d                 	sts noise_fx_3xx_total_offset, r26 //store the new total offset
00313f 93b0 293e                 	sts noise_fx_3xx_total_offset+1, r27
                                 
003141 91a0 0abc                 	lds r26, TCB3_CCMPL //load the current timer period
003143 91b0 0abd                 	lds r27, TCB3_CCMPH
003145 1bac                      	sub r26, r28 //offset the current timer period with the total offset
003146 0bbd                      	sbc r27, r29
003147 93a0 0abc                 	sts TCB3_CCMPL, r26
003149 93b0 0abd                 	sts TCB3_CCMPH, r27
00314b c019                      	rjmp sound_driver_channel3_fx_4xy_routine
                                 
                                 sound_driver_channel3_fx_3xx_routine_add:
00314c 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
00314d 0bbd                      	sbc r27, r29
00314e 91c0 293d                 	lds r28, noise_fx_3xx_total_offset
003150 91d0 293e                 	lds r29, noise_fx_3xx_total_offset+1
                                 
003152 0fce                      	add r28, ZL //add the speed to the total offset
003153 1fdf                      	adc r29, ZH
003154 1bac                      	sub r26, r28 //invert the total difference with the total offset
003155 0bbd                      	sbc r27, r29
003156 f2b0                      	brlo sound_driver_channel3_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
003157 93c0 293d                 	sts noise_fx_3xx_total_offset, r28 //store the new total offset
003159 93d0 293e                 	sts noise_fx_3xx_total_offset+1, r29
                                 
00315b 91c0 0abc                 	lds r28, TCB3_CCMPL //load the current timer period
00315d 91d0 0abd                 	lds r29, TCB3_CCMPH
00315f 0fca                      	add r28, r26 //offset the current timer period with the total offset
003160 1fdb                      	adc r29, r27
003161 93c0 0abc                 	sts TCB3_CCMPL, r28
003163 93d0 0abd                 	sts TCB3_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel3_fx_4xy_routine:
003165 91a0 293f                 	lds r26, noise_fx_4xy_speed
003167 15a2                      	cp r26, zero
003168 f409                      	brne sound_driver_channel3_fx_4xy_routine_continue
003169 c05c                      	rjmp sound_driver_channel3_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel3_fx_4xy_routine_continue:
00316a 91b0 2940                 	lds r27, noise_fx_4xy_depth
00316c 91c0 2941                 	lds r28, noise_fx_4xy_phase
00316e 0fca                      	add r28, r26 //increase the phase by the speed
00316f 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
003170 f008                      	brlo sound_driver_channel3_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
003171 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase:
003172 93c0 2941                 	sts noise_fx_4xy_phase, r28 //store the new phase
003174 31c0                      	cpi r28, 16
003175 f028                      	brlo sound_driver_channel3_fx_4xy_routine_phase_0
003176 32c0                      	cpi r28, 32
003177 f028                      	brlo sound_driver_channel3_fx_4xy_routine_phase_1
003178 33c0                      	cpi r28, 48
003179 f030                      	brlo sound_driver_channel3_fx_4xy_routine_phase_2
00317a c007                      	rjmp sound_driver_channel3_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_0:
00317b 70cf                      	andi r28, 0x0F //mask for values 0-15
00317c c029                      	rjmp sound_driver_channel3_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_1:
00317d 6fc0                      	ori r28, 0xF0
00317e 95c0                      	com r28 //invert values 0-15
00317f c026                      	rjmp sound_driver_channel3_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_2:
003180 70cf                      	andi r28, 0x0F //mask for values 0-15
003181 c003                      	rjmp sound_driver_channel3_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_3:
003182 6fc0                      	ori r28, 0xF0
003183 95c0                      	com r28 //invert values 0-15
003184 c000                      	rjmp sound_driver_channel3_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel3_fx_4xy_routine_load_add:
003185 95b2                      	swap r27 //multiply depth by 16
003186 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
003187 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
003188 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
003189 0fec                      	add ZL, r28 //offset the table by the depth+phase
00318a 1df2                      	adc ZH, zero
00318b 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
00318c 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00318d 937f                      	push r23
00318e 2f6c                      	mov r22, r28 //store the vibrato value into r22
00318f eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
003190 9f67                      	mul r22, r23
003191 917f                      	pop r23
003192 916f                      	pop r22
                                 
003193 9416                      	lsr r1 //shift out the fractional bits
003194 9407                      	ror r0
003195 9416                      	lsr r1
003196 9407                      	ror r0
003197 9416                      	lsr r1
003198 9407                      	ror r0
003199 9416                      	lsr r1
00319a 9407                      	ror r0
                                 	
00319b 91a0 0abc                 	lds r26, TCB3_CCMPL
00319d 91b0 0abd                 	lds r27, TCB3_CCMPH
00319f 0da0                      	add r26, r0
0031a0 1db1                      	adc r27, r1
0031a1 93a0 0abc                 	sts TCB3_CCMPL, r26
0031a3 93b0 0abd                 	sts TCB3_CCMPH, r27
0031a5 c020                      	rjmp sound_driver_channel3_fx_7xy_routine
                                 
                                 sound_driver_channel3_fx_4xy_routine_load_subtract:
0031a6 95b2                      	swap r27 //multiply depth by 16
0031a7 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
0031a8 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0031a9 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0031aa 0fec                      	add ZL, r28 //offset the table by the depth+phase
0031ab 1df2                      	adc ZH, zero
0031ac 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
0031ad 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0031ae 937f                      	push r23
0031af 2f6c                      	mov r22, r28 //store the vibrato value into r22
0031b0 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0031b1 9f67                      	mul r22, r23
0031b2 917f                      	pop r23
0031b3 916f                      	pop r22
                                 
0031b4 9416                      	lsr r1 //shift out the fractional bits
0031b5 9407                      	ror r0
0031b6 9416                      	lsr r1
0031b7 9407                      	ror r0
0031b8 9416                      	lsr r1
0031b9 9407                      	ror r0
0031ba 9416                      	lsr r1
0031bb 9407                      	ror r0
                                 
0031bc 91a0 0abc                 	lds r26, TCB3_CCMPL
0031be 91b0 0abd                 	lds r27, TCB3_CCMPH
0031c0 19a0                      	sub r26, r0
0031c1 09b1                      	sbc r27, r1
0031c2 93a0 0abc                 	sts TCB3_CCMPL, r26
0031c4 93b0 0abd                 	sts TCB3_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_7xy_routine:
0031c6 91a0 2942                 	lds r26, noise_fx_7xy_speed
0031c8 15a2                      	cp r26, zero
0031c9 f0f1                      	breq sound_driver_channel3_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
0031ca 91b0 2943                 	lds r27, noise_fx_7xy_depth
0031cc 91c0 2944                 	lds r28, noise_fx_7xy_phase
0031ce 0fca                      	add r28, r26 //increase the phase by the speed
0031cf 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
0031d0 f010                      	brlo sound_driver_channel3_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
0031d1 e0c0                      	ldi r28, 0x00
0031d2 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel3_fx_7xy_routine_phase:
0031d3 93c0 2944                 	sts noise_fx_7xy_phase, r28 //store the new phase
0031d5 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
0031d6 ffc4                      	sbrs r28, 4
0031d7 c001                      	rjmp sound_driver_channel3_fx_7xy_routine_phase_0
0031d8 c002                      	rjmp sound_driver_channel3_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel3_fx_7xy_routine_phase_0:
0031d9 70cf                      	andi r28, 0x0F //mask for values 0-15
0031da c003                      	rjmp sound_driver_channel3_fx_7xy_routine_load
                                 
                                 sound_driver_channel3_fx_7xy_routine_phase_1:
0031db 6fc0                      	ori r28, 0xF0
0031dc 95c0                      	com r28 //invert values 0-15
0031dd c000                      	rjmp sound_driver_channel3_fx_7xy_routine_load
                                 
                                 sound_driver_channel3_fx_7xy_routine_load:
0031de 95b2                      	swap r27 //multiply depth by 16
0031df 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0031e0 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0031e1 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0031e2 0fec                      	add ZL, r28 //offset the table by the depth+phase
0031e3 1df2                      	adc ZH, zero
0031e4 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
0031e5 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
0031e6 93c0 2945                 	sts noise_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Axy_routine:
0031e8 91b0 2946                 	lds r27, noise_fx_Axy
0031ea 15b2                      	cp r27, zero
0031eb f0e9                      	breq sound_driver_channel3_fx_Qxy_routine //0 means that the effect is not in use
                                 	
0031ec 91a0 2815                 	lds r26, noise_fractional_volume //load fractional volume representation of the channel
0031ee 91c0 2813                 	lds r28, noise_param //load the integer volume representation of the channel
0031f0 2fda                      	mov r29, r26 //copy fractional volume into r29
0031f1 2fec                      	mov r30, r28 //copy the noise_param into r30
0031f2 95e2                      	swap r30
0031f3 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
0031f4 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
0031f5 17ed                      	cp r30, r29 //compare the fractional and integer volumes
0031f6 f009                      	breq sound_driver_channel3_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel3_fx_Axy_routine_reload:
0031f7 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate:
0031f8 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
0031f9 c004                      	rjmp sound_driver_channel3_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_addition:
0031fa 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0031fb f428                      	brcc sound_driver_channel3_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0031fc efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
0031fd c003                      	rjmp sound_driver_channel3_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_subtraction:
0031fe 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0031ff f008                      	brcs sound_driver_channel3_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
003200 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_store:
003201 93a0 2815                 	sts noise_fractional_volume, r26 //store the new fractional volume
003203 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
003204 95a2                      	swap r26
003205 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
003206 2bca                      	or r28, r26 //store the new volume back into noise_param
003207 93c0 2813                 	sts noise_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel3_fx_Qxy_routine:
003209 91e0 294b                 	lds ZL, noise_fx_Qxy_target
00320b 91f0 294c                 	lds ZH, noise_fx_Qxy_target+1
00320d 9630                      	adiw Z, 0
00320e f139                      	breq sound_driver_channel3_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
00320f 91a0 294f                 	lds r26, noise_fx_Qxy_total_offset
003211 91b0 2950                 	lds r27, noise_fx_Qxy_total_offset+1
003213 91c0 0abc                 	lds r28, TCB3_CCMPL
003215 91d0 0abd                 	lds r29, TCB3_CCMPH
                                 
003217 1bec                      	sub ZL, r28 //calculate the difference to the target
003218 0bfd                      	sbc ZH, r29
003219 f408                      	brsh sound_driver_channel3_fx_Qxy_routine_end //if the target has been reached (or passed)
00321a f088                      	brlo sound_driver_channel3_fx_Qxy_routine_add
                                 
                                 sound_driver_channel3_fx_Qxy_routine_end:
00321b 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
00321c 0bbf                      	sbc r27, ZH
                                 
00321d 91c0 2949                 	lds r28, noise_fx_Pxx_total
00321f 91d0 294a                 	lds r29, noise_fx_Pxx_total+1
                                 
003221 0fac                      	add r26, r28
003222 1fbd                      	adc r27, r29
                                 
003223 93a0 294f                 	sts noise_fx_Qxy_total_offset, r26 //store the total offset
003225 93b0 2950                 	sts noise_fx_Qxy_total_offset+1, r27
003227 9220 294b                 	sts noise_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
003229 9220 294c                 	sts noise_fx_Qxy_target+1, zero
00322b c00a                      	rjmp sound_driver_channel3_fx_Rxy_routine
                                 
                                 sound_driver_channel3_fx_Qxy_routine_add:
00322c 91c0 294d                 	lds r28, noise_fx_Qxy_speed
00322e 91d0 294e                 	lds r29, noise_fx_Qxy_speed+1
003230 0fac                      	add r26, r28 //increase the total offset by the speed
003231 1fbd                      	adc r27, r29
003232 93a0 294f                 	sts noise_fx_Qxy_total_offset, r26 //store the total offset
003234 93b0 2950                 	sts noise_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Rxy_routine:
003236 91e0 2951                 	lds ZL, noise_fx_Rxy_target
003238 91f0 2952                 	lds ZH, noise_fx_Rxy_target+1
00323a 9630                      	adiw Z, 0
00323b f139                      	breq sound_driver_instrument_routine_channel4_volume //if the effect is not enabled, skip the routine
                                 
00323c 91a0 2955                 	lds r26, noise_fx_Rxy_total_offset
00323e 91b0 2956                 	lds r27, noise_fx_Rxy_total_offset+1
003240 91c0 0abc                 	lds r28, TCB3_CCMPL
003242 91d0 0abd                 	lds r29, TCB3_CCMPH
                                 
003244 1bce                      	sub r28, ZL //calculate the difference to the target
003245 0bdf                      	sbc r29, ZH
003246 f408                      	brsh sound_driver_channel3_fx_Rxy_routine_end //if the target has been reached (or passed)
003247 f088                      	brlo sound_driver_channel3_fx_Rxy_routine_add
                                 
                                 sound_driver_channel3_fx_Rxy_routine_end:
003248 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
003249 0bbd                      	sbc r27, r29
                                 
00324a 91c0 2949                 	lds r28, noise_fx_Pxx_total
00324c 91d0 294a                 	lds r29, noise_fx_Pxx_total+1
                                 
00324e 0fac                      	add r26, r28
00324f 1fbd                      	adc r27, r29
                                 
003250 93a0 2955                 	sts noise_fx_Rxy_total_offset, r26 //store the total offset
003252 93b0 2956                 	sts noise_fx_Rxy_total_offset+1, r27
003254 9220 2951                 	sts noise_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
003256 9220 2952                 	sts noise_fx_Rxy_target+1, zero
003258 c00a                      	rjmp sound_driver_instrument_routine_channel4_volume
                                 
                                 sound_driver_channel3_fx_Rxy_routine_add:
003259 91c0 2953                 	lds r28, noise_fx_Rxy_speed
00325b 91d0 2954                 	lds r29, noise_fx_Rxy_speed+1
00325d 0fac                      	add r26, r28 //increase the total offset by the speed
00325e 1fbd                      	adc r27, r29
00325f 93a0 2955                 	sts noise_fx_Rxy_total_offset, r26 //store the total offset
003261 93b0 2956                 	sts noise_fx_Rxy_total_offset+1, r27
                                 
                                 sound_driver_instrument_routine_channel4_volume:
                                 
                                 sound_driver_exit:
003263 91ff                      	pop r31
003264 91ef                      	pop r30
003265 91df                      	pop r29
003266 91cf                      	pop r28
003267 940c 1732                 	jmp sequence_1_3 + 3 //+3 is to skip the stack instructions since we already pushed them
                                 
                                 
                                 
                                 //TABLES
003269 7f05
00326a 010a
00326b 0214
00326c 0328
00326d 0450
00326e 051e
00326f 0607
003270 070d
003271 0806
003272 090c
003273 0a18
003274 0b30
003275 0c60
003276 0d24
003277 0e08
003278 0f10                      length: .db $05, $7F, $0A, $01, $14, $02, $28, $03, $50, $04, $1E, $05, $07, $06, $0D, $07, $06, $08, $0C, $09, $18, $0A, $30, $0B, $60, $0C, $24, $0D, $08, $0E, $10, $0F
                                 
                                 //pulse sequences: 12.5%, 25%, 50%, 75%
003279 0301
00327a fc0f                      sequences: .db 0b00000001, 0b00000011, 0b00001111, 0b11111100
                                 
                                 //list of famitracker fx: http://famitracker.com/wiki/index.php?title=Effect_list
                                 channel0_fx:
00327b 196e
00327c 1973
00327d 198f
00327e 19ab
00327f 19ce                      	.dw sound_driver_channel0_fx_0xy, sound_driver_channel0_fx_1xx, sound_driver_channel0_fx_2xx, sound_driver_channel0_fx_3xx, sound_driver_channel0_fx_4xy
003280 19d9
003281 19e6
003282 19e9
003283 19ec
003284 19ef                      	.dw sound_driver_channel0_fx_7xy, sound_driver_channel0_fx_Axy, sound_driver_channel0_fx_Bxx, sound_driver_channel0_fx_Cxx, sound_driver_channel0_fx_Dxx
003285 19f2
003286 19fa
003287 19fd
003288 1a0a
003289 1a0b                      	.dw sound_driver_channel0_fx_Exx, sound_driver_channel0_fx_Fxx, sound_driver_channel0_fx_Gxx, sound_driver_channel0_fx_Hxy, sound_driver_channel0_fx_Ixy
00328a 1a0c
00328b 1a0d
00328c 1a0e
00328d 1a26
00328e 1a6a                      	.dw sound_driver_channel0_fx_Hxx, sound_driver_channel0_fx_Ixx, sound_driver_channel0_fx_Pxx, sound_driver_channel0_fx_Qxy, sound_driver_channel0_fx_Rxy
00328f 1aad
003290 1aba
003291 1ace
003292 1acf
003293 1ad0                      	.dw sound_driver_channel0_fx_Sxx, sound_driver_channel0_fx_Vxx, sound_driver_channel0_fx_Wxx, sound_driver_channel0_fx_Xxx, sound_driver_channel0_fx_Yxx
003294 1ad1                      	.dw sound_driver_channel0_fx_Zxx
                                 
                                 channel1_fx:
003295 1c5c
003296 1c61
003297 1c7d
003298 1c99
003299 1cbc                      	.dw sound_driver_channel1_fx_0xy, sound_driver_channel1_fx_1xx, sound_driver_channel1_fx_2xx, sound_driver_channel1_fx_3xx, sound_driver_channel1_fx_4xy
00329a 1cc7
00329b 1cd4
00329c 1cd7
00329d 1cda
00329e 1cdd                      	.dw sound_driver_channel1_fx_7xy, sound_driver_channel1_fx_Axy, sound_driver_channel1_fx_Bxx, sound_driver_channel1_fx_Cxx, sound_driver_channel1_fx_Dxx
00329f 1ce0
0032a0 1ce8
0032a1 1ceb
0032a2 1cf8
0032a3 1cf9                      	.dw sound_driver_channel1_fx_Exx, sound_driver_channel1_fx_Fxx, sound_driver_channel1_fx_Gxx, sound_driver_channel1_fx_Hxy, sound_driver_channel1_fx_Ixy
0032a4 1cfa
0032a5 1cfb
0032a6 1cfc
0032a7 1d14
0032a8 1d58                      	.dw sound_driver_channel1_fx_Hxx, sound_driver_channel1_fx_Ixx, sound_driver_channel1_fx_Pxx, sound_driver_channel1_fx_Qxy, sound_driver_channel1_fx_Rxy
0032a9 1d9b
0032aa 1da8
0032ab 1dbc
0032ac 1dbd
0032ad 1dbe                      	.dw sound_driver_channel1_fx_Sxx, sound_driver_channel1_fx_Vxx, sound_driver_channel1_fx_Wxx, sound_driver_channel1_fx_Xxx, sound_driver_channel1_fx_Yxx
0032ae 1dbf                      	.dw sound_driver_channel1_fx_Zxx
                                 
                                 channel2_fx:
0032af 1f3d
0032b0 1f42
0032b1 1f5e
0032b2 1f7a
0032b3 1f9d                      	.dw sound_driver_channel2_fx_0xy, sound_driver_channel2_fx_1xx, sound_driver_channel2_fx_2xx, sound_driver_channel2_fx_3xx, sound_driver_channel2_fx_4xy
0032b4 1fa8
0032b5 1fa9
0032b6 1faa
0032b7 1fad
0032b8 1fb0                      	.dw sound_driver_channel2_fx_7xy, sound_driver_channel2_fx_Axy, sound_driver_channel2_fx_Bxx, sound_driver_channel2_fx_Cxx, sound_driver_channel2_fx_Dxx
0032b9 1fb3
0032ba 1fc0
0032bb 1fc3
0032bc 1fd0
0032bd 1fd1                      	.dw sound_driver_channel2_fx_Exx, sound_driver_channel2_fx_Fxx, sound_driver_channel2_fx_Gxx, sound_driver_channel2_fx_Hxy, sound_driver_channel2_fx_Ixy
0032be 1fd2
0032bf 1fd3
0032c0 1fd4
0032c1 1fec
0032c2 2030                      	.dw sound_driver_channel2_fx_Hxx, sound_driver_channel2_fx_Ixx, sound_driver_channel2_fx_Pxx, sound_driver_channel2_fx_Qxy, sound_driver_channel2_fx_Rxy
0032c3 2073
0032c4 2080
0032c5 2081
0032c6 2082
0032c7 2083                      	.dw sound_driver_channel2_fx_Sxx, sound_driver_channel2_fx_Vxx, sound_driver_channel2_fx_Wxx, sound_driver_channel2_fx_Xxx, sound_driver_channel2_fx_Yxx
0032c8 2084                      	.dw sound_driver_channel2_fx_Zxx
                                 
                                 channel3_fx:
0032c9 2206
0032ca 220b
0032cb 2227
0032cc 2243
0032cd 2266                      	.dw sound_driver_channel3_fx_0xy, sound_driver_channel3_fx_1xx, sound_driver_channel3_fx_2xx, sound_driver_channel3_fx_3xx, sound_driver_channel3_fx_4xy
0032ce 2271
0032cf 227e
0032d0 2281
0032d1 2284
0032d2 2287                      	.dw sound_driver_channel3_fx_7xy, sound_driver_channel3_fx_Axy, sound_driver_channel3_fx_Bxx, sound_driver_channel3_fx_Cxx, sound_driver_channel3_fx_Dxx
0032d3 228a
0032d4 2291
0032d5 2294
0032d6 22a1
0032d7 22a2                      	.dw sound_driver_channel3_fx_Exx, sound_driver_channel3_fx_Fxx, sound_driver_channel3_fx_Gxx, sound_driver_channel3_fx_Hxy, sound_driver_channel3_fx_Ixy
0032d8 22a3
0032d9 22a4
0032da 22a5
0032db 22bd
0032dc 2301                      	.dw sound_driver_channel3_fx_Hxx, sound_driver_channel3_fx_Ixx, sound_driver_channel3_fx_Pxx, sound_driver_channel3_fx_Qxy, sound_driver_channel3_fx_Rxy
0032dd 2344
0032de 2351
0032df 235c
0032e0 235d
0032e1 235e                      	.dw sound_driver_channel3_fx_Sxx, sound_driver_channel3_fx_Vxx, sound_driver_channel3_fx_Wxx, sound_driver_channel3_fx_Xxx, sound_driver_channel3_fx_Yxx
0032e2 235f                      	.dw sound_driver_channel3_fx_Zxx
                                 
                                 //famitracker volumes table: http://famitracker.com/wiki/index.php?title=Volume
                                 volumes:
0032e3 0000
0032e4 0000
0032e5 0000
0032e6 0000
0032e7 0000
0032e8 0000
0032e9 0000
0032ea 0000                      	.db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
0032eb 0100
0032ec 0101
0032ed 0101
0032ee 0101
0032ef 0101
0032f0 0101
0032f1 0101
0032f2 0101                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
0032f3 0100
0032f4 0101
0032f5 0101
0032f6 0101
0032f7 0101
0032f8 0101
0032f9 0101
0032fa 0201                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02
0032fb 0100
0032fc 0101
0032fd 0101
0032fe 0101
0032ff 0101
003300 0202
003301 0202
003302 0302                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03
003303 0100
003304 0101
003305 0101
003306 0101
003307 0202
003308 0202
003309 0303
00330a 0403                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04
00330b 0100
00330c 0101
00330d 0101
00330e 0202
00330f 0302
003310 0303
003311 0404
003312 0504                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05
003313 0100
003314 0101
003315 0201
003316 0202
003317 0303
003318 0404
003319 0504
00331a 0605                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x06
00331b 0100
00331c 0101
00331d 0201
00331e 0302
00331f 0403
003320 0504
003321 0605
003322 0706                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07
003323 0100
003324 0101
003325 0202
003326 0303
003327 0404
003328 0505
003329 0606
00332a 0807                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07, 0x08
00332b 0100
00332c 0101
00332d 0302
00332e 0403
00332f 0504
003330 0606
003331 0707
003332 0908                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09
003333 0100
003334 0201
003335 0302
003336 0404
003337 0605
003338 0706
003339 0808
00333a 0a09                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A
00333b 0100
00333c 0201
00333d 0302
00333e 0504
00333f 0605
003340 0807
003341 0908
003342 0b0a                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B
003343 0100
003344 0201
003345 0403
003346 0504
003347 0706
003348 0808
003349 0a09
00334a 0c0b                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B, 0x0C
00334b 0100
00334c 0201
00334d 0403
00334e 0605
00334f 0706
003350 0908
003351 0b0a
003352 0d0c                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D
003353 0100
003354 0201
003355 0403
003356 0605
003357 0807
003358 0a09
003359 0c0b
00335a 0e0d                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E
00335b 0100
00335c 0302
00335d 0504
00335e 0706
00335f 0908
003360 0b0a
003361 0d0c


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega4809" register use summary:
x  :   0 y  :   0 z  : 248 r0 : 192 r1 : 208 r2 : 697 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   6 r11:   4 r12:   9 
r13:   6 r14:   4 r15:   9 r16:   7 r17:   6 r18:   7 r19:   6 r20:   4 
r21:   9 r22: 174 r23: 160 r24:   0 r25:  24 r26: 979 r27:1192 r28: 698 
r29: 376 r30: 378 r31: 337 
Registers used: 25 out of 35 (71.4%)

"ATmega4809" instruction use summary:
.lds  :   0 .sts  :   0 adc   : 148 add   : 195 adiw  : 106 and   :   0 
andi  :  95 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   7 brcs  :  13 break :   0 breq  : 169 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  81 brlt  :   0 brmi  :   0 
brne  : 121 brpl  :   0 brsh  :  31 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :   0 cbr   :   5 
clc   :   0 clh   :   0 cli   :   8 cln   :   0 clr   :   5 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :  16 cp    : 101 cpc   :  10 
cpi   : 168 cpse  :  20 dec   :  35 des   :   0 eor   :   2 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   4 in    :   7 inc   :  48 
jmp   :  11 ld    :   0 ldd   :   0 ldi   : 289 lds   : 727 lpm   : 260 
lsl   :  79 lsr   : 171 mov   : 139 movw  :   0 mul   :  28 muls  :   0 
mulsu :  12 neg   :   0 nop   :   0 or    :  26 ori   :  12 out   :   9 
pop   : 115 push  : 109 rcall :  50 ret   :  32 reti  :   7 rjmp  : 518 
rol   :  53 ror   : 192 sbc   :  48 sbci  :   0 sbi   :   0 sbic  :   0 
sbis  :   0 sbiw  :   0 sbr   :  12 sbrc  :  29 sbrs  :  20 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   :1397 sub   :  66 subi  :  52 swap  :  46 tst   :   0 wdr   :   0 

Instructions used: 52 out of 114 (45.6%)

"ATmega4809" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x0066c6  15890  10308  26198   49152  53.3%
[.dseg] 0x002800 0x00295a      0    346    346    6144   5.6%
[.eseg] 0x000000 0x000000      0      0      0     256   0.0%

Assembly complete, 0 errors, 53 warnings
