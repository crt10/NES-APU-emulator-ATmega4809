
AVRASM ver. 2.2.8  C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm Fri Jan 22 22:44:48 2021

C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
                                 
                                 
                                 ; NES_APU_2a03.asm
                                 ;
                                 ; Created: 11/29/2020 1:44:10 AM
                                 ; Author : Tennyson Cheng
                                 ;
                                 
                                 .list
                                 
                                 .dseg
002800                           pulse1_param: .byte 1 //$4000 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002801                           pulse1_sweep_param: .byte 1 //$4001 EPPP.NSSS = Enable, Period, Negate, Shift
                                 //NOTE: In order to account for multiplier, we use 16 instead of 11 bits for the timer
002802                           pulse1_timerL: .byte 1 //$4002 LLLL.LLLL = Low 8 bits for timer
002803                           pulse1_timerH: .byte 1 //$4002 HHHH.HHHH = High 8 bits for timer
002804                           pulse1_length: .byte 1 //$4003 000l.llll = Length counter load
002805                           pulse1_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002806                           pulse1_output_volume: .byte 1 //this is the final output volume of pulse 1
002807                           pulse1_note: .byte 1 //the current note index in the note table
                                 
002808                           pulse2_param: .byte 1 //$4004 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002809                           pulse2_sweep_param: .byte 1 //$4005 EPPP.NSSS = Enable, Period, Negate, Shift
00280a                           pulse2_timerL: .byte 1 //$4006 LLLL.LLLL = Low 8 bits for timer
00280b                           pulse2_timerH: .byte 1 //$4006 HHHH.HHHH = High 8 bits for timer
00280c                           pulse2_length: .byte 1 //$4007 000l.llll = Length counter load
00280d                           pulse2_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
00280e                           pulse2_output_volume: .byte 1 //this is the final output volume of pulse 2
00280f                           pulse2_note: .byte 1 //the current note index in the note table
                                 
002810                           triangle_timerL: .byte 1 //$400A LLLL.LLLL = Low 8 bits for timer
002811                           triangle_timerH: .byte 1 //$400A HHHH.HHHH = High 8 bits for time
002812                           triangle_note: .byte 1 //the current note index in the note table
                                 
002813                           noise_param: .byte 1 //$400C 00lc.vvvv = Length counter halt/Loop flag, Constant volume flag, Volume
002814                           noise_period: .byte 1 //$400E M000.PPPP = Mode, Period
002815                           noise_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002816                           noise_output_volume: .byte 1 //this is the final output volume of pulse 2
002817                           noise_note: .byte 1 //the current note index in the period table
                                 
002818                           song_frames: .byte 2
00281a                           song_frame_offset: .byte 2
00281c                           song_size: .byte 2
00281e                           song_speed: .byte 1
                                 //song_channel_delay_reload: .byte 1 //bit 0-4 represents channels 0-4. a set bit means that there is a delay that needs to be calculated for that channel.
00281f                           song_fx_Bxx: .byte 1
002820                           song_fx_Cxx: .byte 1
002821                           song_fx_Dxx: .byte 1
                                 
                                 //PULSE 1
002822                           pulse1_pattern: .byte 2
002824                           pulse1_pattern_delay_rows: .byte 1
002825                           pulse1_pattern_delay_frames: .byte 1
002826                           pulse1_pattern_offset: .byte 2
                                 
002828                           pulse1_volume_macro: .byte 2
00282a                           pulse1_volume_macro_offset: .byte 1
00282b                           pulse1_volume_macro_loop: .byte 1
00282c                           pulse1_volume_macro_release: .byte 1
                                 
00282d                           pulse1_arpeggio_macro: .byte 2
00282f                           pulse1_arpeggio_macro_offset: .byte 1
002830                           pulse1_arpeggio_macro_loop: .byte 1
002831                           pulse1_arpeggio_macro_release: .byte 1
002832                           pulse1_arpeggio_macro_mode: .byte 1
                                 
002833                           pulse1_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002835                           pulse1_pitch_macro: .byte 2
002837                           pulse1_pitch_macro_offset: .byte 1
002838                           pulse1_pitch_macro_loop: .byte 1
002839                           pulse1_pitch_macro_release: .byte 1
                                 
00283a                           pulse1_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00283b                           pulse1_hi_pitch_macro: .byte 2
00283d                           pulse1_hi_pitch_macro_offset: .byte 1
00283e                           pulse1_hi_pitch_macro_loop: .byte 1
00283f                           pulse1_hi_pitch_macro_release: .byte 1
                                 
002840                           pulse1_duty_macro: .byte 2
002842                           pulse1_duty_macro_offset: .byte 1
002843                           pulse1_duty_macro_loop: .byte 1
002844                           pulse1_duty_macro_release: .byte 1
                                 
002845                           pulse1_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002847                           pulse1_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002849                           pulse1_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00284b                           pulse1_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
00284d                           pulse1_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
00284f                           pulse1_fx_3xx_start: .byte 2 //the starting note period
002851                           pulse1_fx_3xx_target: .byte 2 //target note period
002853                           pulse1_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
002855                           pulse1_fx_3xx_total_offset: .byte 2
002857                           pulse1_fx_4xy_speed: .byte 1
002858                           pulse1_fx_4xy_depth: .byte 1
002859                           pulse1_fx_4xy_phase: .byte 1
00285a                           pulse1_fx_7xy_speed: .byte 1
00285b                           pulse1_fx_7xy_depth: .byte 1
00285c                           pulse1_fx_7xy_phase: .byte 1
00285d                           pulse1_fx_7xy_value: .byte 1 //value to offset the volume
00285e                           pulse1_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
00285f                           pulse1_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002860                           pulse1_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002861                           pulse1_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
002863                           pulse1_fx_Qxy_target: .byte 2 //target note period
002865                           pulse1_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002867                           pulse1_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002869                           pulse1_fx_Rxy_target: .byte 2 //target note period
00286b                           pulse1_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
00286d                           pulse1_fx_Rxy_total_offset: .byte 2
00286f                           pulse1_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002870                           pulse1_fx_Sxx_post: .byte 1
                                 
                                 //PULSE 2
002871                           pulse2_pattern: .byte 2
002873                           pulse2_pattern_delay_rows: .byte 1
002874                           pulse2_pattern_delay_frames: .byte 1
002875                           pulse2_pattern_offset: .byte 2
                                 
002877                           pulse2_volume_macro: .byte 2
002879                           pulse2_volume_macro_offset: .byte 1
00287a                           pulse2_volume_macro_loop: .byte 1
00287b                           pulse2_volume_macro_release: .byte 1
                                 
00287c                           pulse2_arpeggio_macro: .byte 2
00287e                           pulse2_arpeggio_macro_offset: .byte 1
00287f                           pulse2_arpeggio_macro_loop: .byte 1
002880                           pulse2_arpeggio_macro_release: .byte 1
002881                           pulse2_arpeggio_macro_mode: .byte 1
                                 
002882                           pulse2_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002884                           pulse2_pitch_macro: .byte 2
002886                           pulse2_pitch_macro_offset: .byte 1
002887                           pulse2_pitch_macro_loop: .byte 1
002888                           pulse2_pitch_macro_release: .byte 1
                                 
002889                           pulse2_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00288a                           pulse2_hi_pitch_macro: .byte 2
00288c                           pulse2_hi_pitch_macro_offset: .byte 1
00288d                           pulse2_hi_pitch_macro_loop: .byte 1
00288e                           pulse2_hi_pitch_macro_release: .byte 1
                                 
00288f                           pulse2_duty_macro: .byte 2
002891                           pulse2_duty_macro_offset: .byte 1
002892                           pulse2_duty_macro_loop: .byte 1
002893                           pulse2_duty_macro_release: .byte 1
                                 
002894                           pulse2_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002896                           pulse2_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002898                           pulse2_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00289a                           pulse2_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
00289c                           pulse2_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
00289e                           pulse2_fx_3xx_start: .byte 2 //the starting note period
0028a0                           pulse2_fx_3xx_target: .byte 2 //target note period
0028a2                           pulse2_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028a4                           pulse2_fx_3xx_total_offset: .byte 2
0028a6                           pulse2_fx_4xy_speed: .byte 1
0028a7                           pulse2_fx_4xy_depth: .byte 1
0028a8                           pulse2_fx_4xy_phase: .byte 1
0028a9                           pulse2_fx_7xy_speed: .byte 1
0028aa                           pulse2_fx_7xy_depth: .byte 1
0028ab                           pulse2_fx_7xy_phase: .byte 1
0028ac                           pulse2_fx_7xy_value: .byte 1 //value to offset the volume
0028ad                           pulse2_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
0028ae                           pulse2_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028af                           pulse2_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028b0                           pulse2_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
0028b2                           pulse2_fx_Qxy_target: .byte 2 //target note period
0028b4                           pulse2_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
0028b6                           pulse2_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
0028b8                           pulse2_fx_Rxy_target: .byte 2 //target note period
0028ba                           pulse2_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
0028bc                           pulse2_fx_Rxy_total_offset: .byte 2
0028be                           pulse2_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
0028bf                           pulse2_fx_Sxx_post: .byte 1
                                 
                                 //TRIANGLE
0028c0                           triangle_pattern: .byte 2
0028c2                           triangle_pattern_delay_rows: .byte 1
0028c3                           triangle_pattern_delay_frames: .byte 1
0028c4                           triangle_pattern_offset: .byte 2
                                 
0028c6                           triangle_volume_macro: .byte 2
0028c8                           triangle_volume_macro_offset: .byte 1
0028c9                           triangle_volume_macro_loop: .byte 1
0028ca                           triangle_volume_macro_release: .byte 1
                                 
0028cb                           triangle_arpeggio_macro: .byte 2
0028cd                           triangle_arpeggio_macro_offset: .byte 1
0028ce                           triangle_arpeggio_macro_loop: .byte 1
0028cf                           triangle_arpeggio_macro_release: .byte 1
0028d0                           triangle_arpeggio_macro_mode: .byte 1
                                 
0028d1                           triangle_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
0028d3                           triangle_pitch_macro: .byte 2
0028d5                           triangle_pitch_macro_offset: .byte 1
0028d6                           triangle_pitch_macro_loop: .byte 1
0028d7                           triangle_pitch_macro_release: .byte 1
                                 
0028d8                           triangle_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
0028d9                           triangle_hi_pitch_macro: .byte 2
0028db                           triangle_hi_pitch_macro_offset: .byte 1
0028dc                           triangle_hi_pitch_macro_loop: .byte 1
0028dd                           triangle_hi_pitch_macro_release: .byte 1
                                 
0028de                           triangle_duty_macro: .byte 2
0028e0                           triangle_duty_macro_offset: .byte 1
0028e1                           triangle_duty_macro_loop: .byte 1
0028e2                           triangle_duty_macro_release: .byte 1
                                 
0028e3                           triangle_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
0028e5                           triangle_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
0028e7                           triangle_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
0028e9                           triangle_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
0028eb                           triangle_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
0028ed                           triangle_fx_3xx_start: .byte 2 //the starting note period
0028ef                           triangle_fx_3xx_target: .byte 2 //target note period
0028f1                           triangle_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028f3                           triangle_fx_3xx_total_offset: .byte 2
0028f5                           triangle_fx_4xy_speed: .byte 1
0028f6                           triangle_fx_4xy_depth: .byte 1
0028f7                           triangle_fx_4xy_phase: .byte 1
0028f8                           triangle_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028f9                           triangle_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028fa                           triangle_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
0028fc                           triangle_fx_Qxy_target: .byte 2 //target note period
0028fe                           triangle_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002900                           triangle_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002902                           triangle_fx_Rxy_target: .byte 2 //target note period
002904                           triangle_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
002906                           triangle_fx_Rxy_total_offset: .byte 2
002908                           triangle_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002909                           triangle_fx_Sxx_post: .byte 1
                                 
                                 //NOISE
00290a                           noise_pattern: .byte 2
00290c                           noise_pattern_delay_rows: .byte 1
00290d                           noise_pattern_delay_frames: .byte 1
00290e                           noise_pattern_offset: .byte 2
                                 
002910                           noise_volume_macro: .byte 2
002912                           noise_volume_macro_offset: .byte 1
002913                           noise_volume_macro_loop: .byte 1
002914                           noise_volume_macro_release: .byte 1
                                 
002915                           noise_arpeggio_macro: .byte 2
002917                           noise_arpeggio_macro_offset: .byte 1
002918                           noise_arpeggio_macro_loop: .byte 1
002919                           noise_arpeggio_macro_release: .byte 1
00291a                           noise_arpeggio_macro_mode: .byte 1
                                 
00291b                           noise_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
00291d                           noise_pitch_macro: .byte 2
00291f                           noise_pitch_macro_offset: .byte 1
002920                           noise_pitch_macro_loop: .byte 1
002921                           noise_pitch_macro_release: .byte 1
                                 
002922                           noise_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
002923                           noise_hi_pitch_macro: .byte 2
002925                           noise_hi_pitch_macro_offset: .byte 1
002926                           noise_hi_pitch_macro_loop: .byte 1
002927                           noise_hi_pitch_macro_release: .byte 1
                                 
002928                           noise_duty_macro: .byte 2
00292a                           noise_duty_macro_offset: .byte 1
00292b                           noise_duty_macro_loop: .byte 1
00292c                           noise_duty_macro_release: .byte 1
                                 
00292d                           noise_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
00292f                           noise_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002931                           noise_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
002933                           noise_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
002935                           noise_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
002937                           noise_fx_3xx_start: .byte 2 //the starting note period
002939                           noise_fx_3xx_target: .byte 2 //target note period
00293b                           noise_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
00293d                           noise_fx_3xx_total_offset: .byte 2
00293f                           noise_fx_4xy_speed: .byte 1
002940                           noise_fx_4xy_depth: .byte 1
002941                           noise_fx_4xy_phase: .byte 1
002942                           noise_fx_7xy_speed: .byte 1
002943                           noise_fx_7xy_depth: .byte 1
002944                           noise_fx_7xy_phase: .byte 1
002945                           noise_fx_7xy_value: .byte 1 //value to offset the volume
002946                           noise_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
002947                           noise_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002948                           noise_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002949                           noise_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
00294b                           noise_fx_Qxy_target: .byte 2 //target note period
00294d                           noise_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
00294f                           noise_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002951                           noise_fx_Rxy_target: .byte 2 //target note period
002953                           noise_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
002955                           noise_fx_Rxy_total_offset: .byte 2
002957                           noise_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002958                           noise_fx_Sxx_post: .byte 1
                                 
                                 //DPCM
002959                           dcpm_pattern_delay: .byte 1
                                 
                                 .cseg
                                 
                                 //NOTE: zero is defined in order to use the cp instruction without the need to load 0x00 into a register beforehand
                                 .def zero = r2
                                 .def pulse_channel_flags = r25 //[pulse1.pulse2] RSlc.RSlc = Reload, Start, Length halt/Loop, Constant volume
                                 .def pulse1_sequence = r10
                                 .def pulse1_length_counter = r11
                                 .def pulse1_sweep = r12 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse1_volume_divider = r16 //0000.PPPP = Period divider
                                 .def pulse1_volume_decay = r17 //0000.dddd = Decay
                                 .def pulse2_sequence = r13
                                 .def pulse2_length_counter = r14
                                 .def pulse2_sweep = r15 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse2_volume_divider = r18 //0000.PPPP = Period divider
                                 .def pulse2_volume_decay = r19 //0000.dddd = Decay
                                 .def triangle_sequence = r20
                                 .def noise_sequence_LOW = r21
                                 .def noise_sequence_HIGH = r22
                                 
                                 reset:
000000 940c 023e                 	jmp init
                                 
                                 .org TCA0_OVF_vect
00000e 940c 06e9                 	jmp sound_driver
                                 
                                 .org TCA0_CMP0_vect
000012 940c 05f0                 	jmp sequence_0_2
                                 
                                 .org TCA0_CMP1_vect
000014 940c 05fb                 	jmp sequence_1_3
                                 
                                 .org TCA0_CMP2_vect
000016 940c 05f0                 	jmp sequence_0_2
                                 
                                 .org TCB0_INT_vect
000018 940c 0612                 	jmp pulse1_sequence_routine
                                 
                                 .org TCB1_INT_vect
00001a 940c 065f                 	jmp pulse2_sequence_routine
                                 
                                 .org TCB2_INT_vect
000032 940c 06ac                 	jmp triangle_sequence_routine
                                 
                                 .org TCB3_INT_vect
000048 940c 06b7                 	jmp noise_sequence_routine
                                 
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(33): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(48): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(84): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(85): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(86): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(87): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(88): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(89): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(90): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(91): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(92): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(93): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(94): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(95): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
                                 .list
                                 
                                 init:
                                 	//MAIN CLOCK
00023e edc8                      	ldi r28, CPU_CCP_IOREG_gc //protected write
00023f 93c0 0034                 	sts CPU_CCP, r28
000241 e0c0                      	ldi r28, 0 << CLKCTRL_PEN_bp //disable prescaler for 20 MHz on main clock
000242 93c0 0061                 	sts CLKCTRL_MCLKCTRLB, r28
                                 
                                 	//ZERO
000244 2422                      	clr zero
                                 
                                 	//MEMORY
000245 e3c0                      	ldi r28, 0b00110000
000246 93c0 2800                 	sts pulse1_param, r28
000248 e8c0                      	ldi r28, 0b10000000
000249 93c0 2801                 	sts pulse1_sweep_param, r28
00024b efcf                      	ldi r28, 0xFF
00024c 93c0 2802                 	sts pulse1_timerL, r28
00024e 93c0 2803                 	sts pulse1_timerH, r28
000250 93c0 2804                 	sts pulse1_length, r28
                                 
000252 e3c0                      	ldi r28, 0b00110000
000253 93c0 2808                 	sts pulse2_param, r28
000255 e8c0                      	ldi r28, 0b10000000
000256 93c0 2809                 	sts pulse2_sweep_param, r28
000258 efcf                      	ldi r28, 0xFF
000259 93c0 280a                 	sts pulse2_timerL, r28
00025b 93c0 280b                 	sts pulse2_timerH, r28
00025d 93c0 280c                 	sts pulse2_length, r28
                                 
00025f efcf                      	ldi r28, 0xFF
000260 93c0 2810                 	sts triangle_timerL, r28
000262 93c0 2811                 	sts triangle_timerH, r28
                                 
000264 e3c0                      	ldi r28, 0b00110000
000265 93c0 2813                 	sts noise_param, r28
000267 e0cf                      	ldi r28, 0b00001111
000268 93c0 2814                 	sts noise_period, r28
                                 
00026a e0c2                      	ldi r28, 0x02
00026b 93c0 281a                 	sts song_frame_offset, r28
00026d 9220 281b                 	sts song_frame_offset+1, zero
00026f efcf                      	ldi r28, 0xFF
000270 93c0 281f                 	sts song_fx_Bxx, r28
000272 9220 2820                 	sts song_fx_Cxx, zero
000274 9220 2821                 	sts song_fx_Dxx, zero
000276 e4ee                      	ldi ZL, LOW(song0_frames << 1)
000277 e0f3                      	ldi ZH, HIGH(song0_frames << 1)
000278 93e0 2818                 	sts song_frames, ZL
00027a 93f0 2819                 	sts song_frames+1, ZH
00027c 91c5                      	lpm r28, Z+ //load the song size
00027d 91d5                      	lpm r29, Z+
00027e 93c0 281c                 	sts song_size, r28
000280 93d0 281d                 	sts song_size+1, r29
000282 9220 281e                 	sts song_speed, zero
                                 
                                 	//CHANNEL 0
000284 91c5                      	lpm r28, Z+
000285 91d5                      	lpm r29, Z+
000286 0fcc                      	lsl r28
000287 1fdd                      	rol r29
000288 93c0 2822                 	sts pulse1_pattern, r28
00028a 93d0 2823                 	sts pulse1_pattern+1, r29
00028c 9220 2824                 	sts pulse1_pattern_delay_rows, zero
00028e 9220 2825                 	sts pulse1_pattern_delay_frames, zero
000290 9220 2826                 	sts pulse1_pattern_offset, zero
000292 9220 2827                 	sts pulse1_pattern_offset+1, zero
                                 
                                 	//CHANNEL 1
000294 91c5                      	lpm r28, Z+
000295 91d5                      	lpm r29, Z+
000296 0fcc                      	lsl r28
000297 1fdd                      	rol r29
000298 93c0 2871                 	sts pulse2_pattern, r28
00029a 93d0 2872                 	sts pulse2_pattern+1, r29
00029c 9220 2873                 	sts pulse2_pattern_delay_rows, zero
00029e 9220 2874                 	sts pulse2_pattern_delay_frames, zero
0002a0 9220 2875                 	sts pulse2_pattern_offset, zero
0002a2 9220 2876                 	sts pulse2_pattern_offset+1, zero
                                 
                                 	//CHANNEL 2
0002a4 91c5                      	lpm r28, Z+
0002a5 91d5                      	lpm r29, Z+
0002a6 0fcc                      	lsl r28
0002a7 1fdd                      	rol r29
0002a8 93c0 28c0                 	sts triangle_pattern, r28
0002aa 93d0 28c1                 	sts triangle_pattern+1, r29
0002ac 9220 28c2                 	sts triangle_pattern_delay_rows, zero
0002ae 9220 28c3                 	sts triangle_pattern_delay_frames, zero
0002b0 9220 28c4                 	sts triangle_pattern_offset, zero
0002b2 9220 28c5                 	sts triangle_pattern_offset+1, zero
                                 
                                 	//CHANNEL 3
0002b4 91c5                      	lpm r28, Z+
0002b5 91d5                      	lpm r29, Z+
0002b6 0fcc                      	lsl r28
0002b7 1fdd                      	rol r29
0002b8 93c0 290a                 	sts noise_pattern, r28
0002ba 93d0 290b                 	sts noise_pattern+1, r29
0002bc 9220 290c                 	sts noise_pattern_delay_rows, zero
0002be 9220 290d                 	sts noise_pattern_delay_frames, zero
0002c0 9220 290e                 	sts noise_pattern_offset, zero
0002c2 9220 290f                 	sts noise_pattern_offset+1, zero
                                 
                                 	//CHANNEL 0 instrument macros
0002c4 efcf                      	ldi r28, 0xFF
0002c5 9220 282a                 	sts pulse1_volume_macro_offset, zero
0002c7 93c0 282b                 	sts pulse1_volume_macro_loop, r28
0002c9 93c0 282c                 	sts pulse1_volume_macro_release, r28
0002cb 9220 282f                 	sts pulse1_arpeggio_macro_offset, zero
0002cd 93c0 2830                 	sts pulse1_arpeggio_macro_loop, r28
0002cf 93c0 2831                 	sts pulse1_arpeggio_macro_release, r28
0002d1 93c0 2832                 	sts pulse1_arpeggio_macro_mode, r28
0002d3 9220 2837                 	sts pulse1_pitch_macro_offset, zero
0002d5 93c0 2838                 	sts pulse1_pitch_macro_loop, r28
0002d7 93c0 2839                 	sts pulse1_pitch_macro_release, r28
0002d9 9220 283d                 	sts pulse1_hi_pitch_macro_offset, zero
0002db 93c0 283e                 	sts pulse1_hi_pitch_macro_loop, r28
0002dd 93c0 283f                 	sts pulse1_hi_pitch_macro_release, r28
0002df 9220 2842                 	sts pulse1_duty_macro_offset, zero
0002e1 93c0 2843                 	sts pulse1_duty_macro_loop, r28
0002e3 93c0 2844                 	sts pulse1_duty_macro_release, r28
                                 
0002e5 9220 2828                 	sts pulse1_volume_macro, zero
0002e7 9220 2829                 	sts pulse1_volume_macro+1, zero
0002e9 9220 282d                 	sts pulse1_arpeggio_macro, zero
0002eb 9220 282e                 	sts pulse1_arpeggio_macro+1, zero
0002ed 9220 2833                 	sts pulse1_total_pitch_offset, zero
0002ef 9220 2834                 	sts pulse1_total_pitch_offset+1, zero
0002f1 9220 2835                 	sts pulse1_pitch_macro, zero
0002f3 9220 2836                 	sts pulse1_pitch_macro+1, zero
0002f5 9220 283a                 	sts pulse1_total_hi_pitch_offset, zero
0002f7 9220 283b                 	sts pulse1_hi_pitch_macro, zero
0002f9 9220 283c                 	sts pulse1_hi_pitch_macro+1, zero
0002fb 9220 2840                 	sts pulse1_duty_macro, zero
0002fd 9220 2841                 	sts pulse1_duty_macro+1, zero
                                 
                                 	//CHANNEL 0 ENVELOPE
0002ff e00f                      	ldi pulse1_volume_divider, 0x0F
000300 9110 2800                 	lds pulse1_volume_decay, pulse1_param
000302 701f                      	andi pulse1_volume_decay, 0x0F //mask for VVVV bits
000303 9190 2800                 	lds pulse_channel_flags, pulse1_param
000305 7390                      	andi pulse_channel_flags, 0b00110000
000306 6490                      	sbr pulse_channel_flags, 0b01000000 //set start flag
000307 9220 2806                 	sts pulse1_output_volume, zero
000309 93c0 2805                 	sts pulse1_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 0 LENGTH
00030b 2ebc                      	mov pulse1_length_counter, r28
                                 
                                 	//CHANNEL 0 SEQUENCE
00030c e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
00030d 2eac                      	mov pulse1_sequence, r28
                                 
                                 	//CHANNEL 0 SWEEP
00030e 90c0 2801                 	lds pulse1_sweep, pulse1_sweep_param
000310 94c2                      	swap pulse1_sweep //swap data from high byte and low byte
000311 6890                      	sbr pulse_channel_flags, 0b10000000 //set reload flag
                                 
                                 	//CHANNEL 0 FX
000312 efcf                      	ldi r28, 0xFF
000313 9220 2845                 	sts pulse1_fx_0xy_sequence, zero
000315 9220 2846                 	sts pulse1_fx_0xy_sequence+1, zero
000317 9220 2847                 	sts pulse1_fx_1xx, zero
000319 9220 2848                 	sts pulse1_fx_1xx+1, zero
00031b 9220 2849                 	sts pulse1_fx_1xx_total, zero
00031d 9220 284a                 	sts pulse1_fx_1xx_total+1, zero
00031f 9220 284b                 	sts pulse1_fx_2xx, zero
000321 9220 284c                 	sts pulse1_fx_2xx+1, zero
000323 9220 284d                 	sts pulse1_fx_2xx_total, zero
000325 9220 284e                 	sts pulse1_fx_2xx_total+1, zero
000327 9220 284f                 	sts pulse1_fx_3xx_start, zero
000329 9220 2850                 	sts pulse1_fx_3xx_start+1, zero
00032b 9220 2851                 	sts pulse1_fx_3xx_target, zero
00032d 9220 2852                 	sts pulse1_fx_3xx_target+1, zero
00032f 9220 2853                 	sts pulse1_fx_3xx_speed, zero
000331 9220 2854                 	sts pulse1_fx_3xx_speed+1, zero
000333 9220 2855                 	sts pulse1_fx_3xx_total_offset, zero
000335 9220 2856                 	sts pulse1_fx_3xx_total_offset+1, zero
000337 9220 2857                 	sts pulse1_fx_4xy_speed, zero
000339 9220 2858                 	sts pulse1_fx_4xy_depth, zero
00033b 9220 2859                 	sts pulse1_fx_4xy_phase, zero
00033d 9220 285a                 	sts pulse1_fx_7xy_speed, zero
00033f 9220 285b                 	sts pulse1_fx_7xy_depth, zero
000341 9220 285c                 	sts pulse1_fx_7xy_phase, zero
000343 9220 285d                 	sts pulse1_fx_7xy_value, zero
000345 9220 285e                 	sts pulse1_fx_Axy, zero
000347 93c0 285f                 	sts pulse1_fx_Gxx_pre, r28
000349 93c0 2860                 	sts pulse1_fx_Gxx_post, r28
00034b 9220 2861                 	sts pulse1_fx_Pxx_total, zero
00034d 9220 2862                 	sts pulse1_fx_Pxx_total+1, zero
00034f 9220 2863                 	sts pulse1_fx_Qxy_target, zero
000351 9220 2864                 	sts pulse1_fx_Qxy_target+1, zero
000353 9220 2865                 	sts pulse1_fx_Qxy_speed, zero
000355 9220 2866                 	sts pulse1_fx_Qxy_speed+1, zero
000357 9220 2867                 	sts pulse1_fx_Qxy_total_offset, zero
000359 9220 2868                 	sts pulse1_fx_Qxy_total_offset+1, zero
00035b 9220 2869                 	sts pulse1_fx_Rxy_target, zero
00035d 9220 286a                 	sts pulse1_fx_Rxy_target+1, zero
00035f 9220 286b                 	sts pulse1_fx_Rxy_speed, zero
000361 9220 286c                 	sts pulse1_fx_Rxy_speed+1, zero
000363 9220 286d                 	sts pulse1_fx_Rxy_total_offset, zero
000365 9220 286e                 	sts pulse1_fx_Rxy_total_offset+1, zero
000367 93c0 286f                 	sts pulse1_fx_Sxx_pre, r28
000369 93c0 2870                 	sts pulse1_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 1 instrument macros
00036b efcf                      	ldi r28, 0xFF
00036c 9220 2879                 	sts pulse2_volume_macro_offset, zero
00036e 93c0 287a                 	sts pulse2_volume_macro_loop, r28
000370 93c0 287b                 	sts pulse2_volume_macro_release, r28
000372 9220 287e                 	sts pulse2_arpeggio_macro_offset, zero
000374 93c0 287f                 	sts pulse2_arpeggio_macro_loop, r28
000376 93c0 2880                 	sts pulse2_arpeggio_macro_release, r28
000378 93c0 2881                 	sts pulse2_arpeggio_macro_mode, r28
00037a 9220 2886                 	sts pulse2_pitch_macro_offset, zero
00037c 93c0 2887                 	sts pulse2_pitch_macro_loop, r28
00037e 93c0 2888                 	sts pulse2_pitch_macro_release, r28
000380 9220 288c                 	sts pulse2_hi_pitch_macro_offset, zero
000382 93c0 288d                 	sts pulse2_hi_pitch_macro_loop, r28
000384 93c0 288e                 	sts pulse2_hi_pitch_macro_release, r28
000386 9220 2891                 	sts pulse2_duty_macro_offset, zero
000388 93c0 2892                 	sts pulse2_duty_macro_loop, r28
00038a 93c0 2893                 	sts pulse2_duty_macro_release, r28
                                 
00038c 9220 2877                 	sts pulse2_volume_macro, zero
00038e 9220 2878                 	sts pulse2_volume_macro+1, zero
000390 9220 287c                 	sts pulse2_arpeggio_macro, zero
000392 9220 287d                 	sts pulse2_arpeggio_macro+1, zero
000394 9220 2882                 	sts pulse2_total_pitch_offset, zero
000396 9220 2883                 	sts pulse2_total_pitch_offset+1, zero
000398 9220 2884                 	sts pulse2_pitch_macro, zero
00039a 9220 2885                 	sts pulse2_pitch_macro+1, zero
00039c 9220 2889                 	sts pulse2_total_hi_pitch_offset, zero
00039e 9220 288a                 	sts pulse2_hi_pitch_macro, zero
0003a0 9220 288b                 	sts pulse2_hi_pitch_macro+1, zero
0003a2 9220 288f                 	sts pulse2_duty_macro, zero
0003a4 9220 2890                 	sts pulse2_duty_macro+1, zero
                                 
                                 	//CHANNEL 1 ENVELOPE
0003a6 e02f                      	ldi pulse2_volume_divider, 0x0F
0003a7 9130 2808                 	lds pulse2_volume_decay, pulse2_param
0003a9 703f                      	andi pulse2_volume_decay, 0x0F //mask for VVVV bits
0003aa 91d0 2808                 	lds r29, pulse2_param
0003ac 73d0                      	andi r29, 0b00110000
0003ad 62d0                      	sbr r29, 0b0100000 //set start flag
0003ae 95d2                      	swap r29
0003af 2b9d                      	or pulse_channel_flags, r29
0003b0 9220 280e                 	sts pulse2_output_volume, zero
0003b2 93c0 280d                 	sts pulse2_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 1 LENGTH
0003b4 2eec                      	mov pulse2_length_counter, r28
                                 
                                 	//CHANNEL 1 SEQUENCE
0003b5 e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
0003b6 2edc                      	mov pulse2_sequence, r28
                                 
                                 	//CHANNEL 1 SWEEP
0003b7 90f0 2809                 	lds pulse2_sweep, pulse2_sweep_param
0003b9 94f2                      	swap pulse2_sweep //swap data from high byte and low byte
0003ba 6098                      	sbr pulse_channel_flags, 0b00001000 //set reload flag
                                 
                                 	//CHANNEL 1 FX
0003bb efcf                      	ldi r28, 0xFF
0003bc 9220 2894                 	sts pulse2_fx_0xy_sequence, zero
0003be 9220 2895                 	sts pulse2_fx_0xy_sequence+1, zero
0003c0 9220 2896                 	sts pulse2_fx_1xx, zero
0003c2 9220 2897                 	sts pulse2_fx_1xx+1, zero
0003c4 9220 2898                 	sts pulse2_fx_1xx_total, zero
0003c6 9220 2899                 	sts pulse2_fx_1xx_total+1, zero
0003c8 9220 289a                 	sts pulse2_fx_2xx, zero
0003ca 9220 289b                 	sts pulse2_fx_2xx+1, zero
0003cc 9220 289c                 	sts pulse2_fx_2xx_total, zero
0003ce 9220 289d                 	sts pulse2_fx_2xx_total+1, zero
0003d0 9220 289e                 	sts pulse2_fx_3xx_start, zero
0003d2 9220 289f                 	sts pulse2_fx_3xx_start+1, zero
0003d4 9220 28a0                 	sts pulse2_fx_3xx_target, zero
0003d6 9220 28a1                 	sts pulse2_fx_3xx_target+1, zero
0003d8 9220 28a2                 	sts pulse2_fx_3xx_speed, zero
0003da 9220 28a3                 	sts pulse2_fx_3xx_speed+1, zero
0003dc 9220 28a4                 	sts pulse2_fx_3xx_total_offset, zero
0003de 9220 28a5                 	sts pulse2_fx_3xx_total_offset+1, zero
0003e0 9220 28a6                 	sts pulse2_fx_4xy_speed, zero
0003e2 9220 28a7                 	sts pulse2_fx_4xy_depth, zero
0003e4 9220 28a8                 	sts pulse2_fx_4xy_phase, zero
0003e6 9220 28a9                 	sts pulse2_fx_7xy_speed, zero
0003e8 9220 28aa                 	sts pulse2_fx_7xy_depth, zero
0003ea 9220 28ab                 	sts pulse2_fx_7xy_phase, zero
0003ec 9220 28ac                 	sts pulse2_fx_7xy_value, zero
0003ee 9220 28ad                 	sts pulse2_fx_Axy, zero
0003f0 93c0 28ae                 	sts pulse2_fx_Gxx_pre, r28
0003f2 93c0 28af                 	sts pulse2_fx_Gxx_post, r28
0003f4 9220 28b0                 	sts pulse2_fx_Pxx_total, zero
0003f6 9220 28b1                 	sts pulse2_fx_Pxx_total+1, zero
0003f8 9220 28b2                 	sts pulse2_fx_Qxy_target, zero
0003fa 9220 28b3                 	sts pulse2_fx_Qxy_target+1, zero
0003fc 9220 28b4                 	sts pulse2_fx_Qxy_speed, zero
0003fe 9220 28b5                 	sts pulse2_fx_Qxy_speed+1, zero
000400 9220 28b6                 	sts pulse2_fx_Qxy_total_offset, zero
000402 9220 28b7                 	sts pulse2_fx_Qxy_total_offset+1, zero
000404 9220 28b8                 	sts pulse2_fx_Rxy_target, zero
000406 9220 28b9                 	sts pulse2_fx_Rxy_target+1, zero
000408 9220 28ba                 	sts pulse2_fx_Rxy_speed, zero
00040a 9220 28bb                 	sts pulse2_fx_Rxy_speed+1, zero
00040c 9220 28bc                 	sts pulse2_fx_Rxy_total_offset, zero
00040e 9220 28bd                 	sts pulse2_fx_Rxy_total_offset+1, zero
000410 93c0 28be                 	sts pulse2_fx_Sxx_pre, r28
000412 93c0 28bf                 	sts pulse2_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 2 instrument macros
000414 efcf                      	ldi r28, 0xFF
000415 9220 28c8                 	sts triangle_volume_macro_offset, zero
000417 93c0 28c9                 	sts triangle_volume_macro_loop, r28
000419 93c0 28ca                 	sts triangle_volume_macro_release, r28
00041b 9220 28cd                 	sts triangle_arpeggio_macro_offset, zero
00041d 93c0 28ce                 	sts triangle_arpeggio_macro_loop, r28
00041f 93c0 28cf                 	sts triangle_arpeggio_macro_release, r28
000421 93c0 28d0                 	sts triangle_arpeggio_macro_mode, r28
000423 9220 28d5                 	sts triangle_pitch_macro_offset, zero
000425 93c0 28d6                 	sts triangle_pitch_macro_loop, r28
000427 93c0 28d7                 	sts triangle_pitch_macro_release, r28
000429 9220 28db                 	sts triangle_hi_pitch_macro_offset, zero
00042b 93c0 28dc                 	sts triangle_hi_pitch_macro_loop, r28
00042d 93c0 28dd                 	sts triangle_hi_pitch_macro_release, r28
00042f 9220 28e0                 	sts triangle_duty_macro_offset, zero
000431 93c0 28e1                 	sts triangle_duty_macro_loop, r28
000433 93c0 28e2                 	sts triangle_duty_macro_release, r28
                                 
000435 9220 28c6                 	sts triangle_volume_macro, zero
000437 9220 28c7                 	sts triangle_volume_macro+1, zero
000439 9220 28cb                 	sts triangle_arpeggio_macro, zero
00043b 9220 28cc                 	sts triangle_arpeggio_macro+1, zero
00043d 9220 28d1                 	sts triangle_total_pitch_offset, zero
00043f 9220 28d2                 	sts triangle_total_pitch_offset+1, zero
000441 9220 28d3                 	sts triangle_pitch_macro, zero
000443 9220 28d4                 	sts triangle_pitch_macro+1, zero
000445 9220 28d8                 	sts triangle_total_hi_pitch_offset, zero
000447 9220 28d9                 	sts triangle_hi_pitch_macro, zero
000449 9220 28da                 	sts triangle_hi_pitch_macro+1, zero
00044b 9220 28de                 	sts triangle_duty_macro, zero
00044d 9220 28df                 	sts triangle_duty_macro+1, zero
                                 
                                 	//CHANNEL 2 SEQUENCE
00044f e0c0                      	ldi r28, 0b00000000 //reset sequence to 0
000450 2f4c                      	mov triangle_sequence, r28
                                 
                                 	//CHANNEL 2 FX
000451 efcf                      	ldi r28, 0xFF
000452 9220 28e3                 	sts triangle_fx_0xy_sequence, zero
000454 9220 28e4                 	sts triangle_fx_0xy_sequence+1, zero
000456 9220 28e5                 	sts triangle_fx_1xx, zero
000458 9220 28e6                 	sts triangle_fx_1xx+1, zero
00045a 9220 28e7                 	sts triangle_fx_1xx_total, zero
00045c 9220 28e8                 	sts triangle_fx_1xx_total+1, zero
00045e 9220 28e9                 	sts triangle_fx_2xx, zero
000460 9220 28ea                 	sts triangle_fx_2xx+1, zero
000462 9220 28eb                 	sts triangle_fx_2xx_total, zero
000464 9220 28ec                 	sts triangle_fx_2xx_total+1, zero
000466 9220 28ed                 	sts triangle_fx_3xx_start, zero
000468 9220 28ee                 	sts triangle_fx_3xx_start+1, zero
00046a 9220 28ef                 	sts triangle_fx_3xx_target, zero
00046c 9220 28f0                 	sts triangle_fx_3xx_target+1, zero
00046e 9220 28f1                 	sts triangle_fx_3xx_speed, zero
000470 9220 28f2                 	sts triangle_fx_3xx_speed+1, zero
000472 9220 28f3                 	sts triangle_fx_3xx_total_offset, zero
000474 9220 28f4                 	sts triangle_fx_3xx_total_offset+1, zero
000476 9220 28f5                 	sts triangle_fx_4xy_speed, zero
000478 9220 28f6                 	sts triangle_fx_4xy_depth, zero
00047a 9220 28f7                 	sts triangle_fx_4xy_phase, zero
00047c 93c0 28f8                 	sts triangle_fx_Gxx_pre, r28
00047e 93c0 28f9                 	sts triangle_fx_Gxx_post, r28
000480 9220 28fa                 	sts triangle_fx_Pxx_total, zero
000482 9220 28fb                 	sts triangle_fx_Pxx_total+1, zero
000484 9220 28fc                 	sts triangle_fx_Qxy_target, zero
000486 9220 28fd                 	sts triangle_fx_Qxy_target+1, zero
000488 9220 28fe                 	sts triangle_fx_Qxy_speed, zero
00048a 9220 28ff                 	sts triangle_fx_Qxy_speed+1, zero
00048c 9220 2900                 	sts triangle_fx_Qxy_total_offset, zero
00048e 9220 2901                 	sts triangle_fx_Qxy_total_offset+1, zero
000490 9220 2902                 	sts triangle_fx_Rxy_target, zero
000492 9220 2903                 	sts triangle_fx_Rxy_target+1, zero
000494 9220 2904                 	sts triangle_fx_Rxy_speed, zero
000496 9220 2905                 	sts triangle_fx_Rxy_speed+1, zero
000498 9220 2906                 	sts triangle_fx_Rxy_total_offset, zero
00049a 9220 2907                 	sts triangle_fx_Rxy_total_offset+1, zero
00049c 93c0 2908                 	sts triangle_fx_Sxx_pre, r28
00049e 93c0 2909                 	sts triangle_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 3 instrument macros
0004a0 efcf                      	ldi r28, 0xFF
0004a1 9220 2912                 	sts noise_volume_macro_offset, zero
0004a3 93c0 2913                 	sts noise_volume_macro_loop, r28
0004a5 93c0 2914                 	sts noise_volume_macro_release, r28
0004a7 9220 2917                 	sts noise_arpeggio_macro_offset, zero
0004a9 93c0 2918                 	sts noise_arpeggio_macro_loop, r28
0004ab 93c0 2919                 	sts noise_arpeggio_macro_release, r28
0004ad 93c0 291a                 	sts noise_arpeggio_macro_mode, r28
0004af 9220 291f                 	sts noise_pitch_macro_offset, zero
0004b1 93c0 2920                 	sts noise_pitch_macro_loop, r28
0004b3 93c0 2921                 	sts noise_pitch_macro_release, r28
0004b5 9220 2925                 	sts noise_hi_pitch_macro_offset, zero
0004b7 93c0 2926                 	sts noise_hi_pitch_macro_loop, r28
0004b9 93c0 2927                 	sts noise_hi_pitch_macro_release, r28
0004bb 9220 292a                 	sts noise_duty_macro_offset, zero
0004bd 93c0 292b                 	sts noise_duty_macro_loop, r28
0004bf 93c0 292c                 	sts noise_duty_macro_release, r28
                                 
0004c1 9220 2910                 	sts noise_volume_macro, zero
0004c3 9220 2911                 	sts noise_volume_macro+1, zero
0004c5 9220 2915                 	sts noise_arpeggio_macro, zero
0004c7 9220 2916                 	sts noise_arpeggio_macro+1, zero
0004c9 9220 291b                 	sts noise_total_pitch_offset, zero
0004cb 9220 291c                 	sts noise_total_pitch_offset+1, zero
0004cd 9220 291d                 	sts noise_pitch_macro, zero
0004cf 9220 291e                 	sts noise_pitch_macro+1, zero
0004d1 9220 2922                 	sts noise_total_hi_pitch_offset, zero
0004d3 9220 2923                 	sts noise_hi_pitch_macro, zero
0004d5 9220 2924                 	sts noise_hi_pitch_macro+1, zero
0004d7 9220 2928                 	sts noise_duty_macro, zero
0004d9 9220 2929                 	sts noise_duty_macro+1, zero
                                 
                                 	//CHANNEL 3 VOLUME
0004db 9220 2816                 	sts noise_output_volume, zero
0004dd 93c0 2815                 	sts noise_fractional_volume, r28 //initialize fractional volume to max value
                                 
                                 	//CHANNEL 3 SEQUENCE
0004df e0c1                      	ldi r28, 0b00000001 //noise sequence is reset to 0x0001
0004e0 2f5c                      	mov noise_sequence_LOW, r28
0004e1 2d62                      	mov noise_sequence_HIGH, zero
                                 
                                 	//CHANNEL 3 FX
0004e2 efcf                      	ldi r28, 0xFF
0004e3 9220 292d                 	sts noise_fx_0xy_sequence, zero
0004e5 9220 292e                 	sts noise_fx_0xy_sequence+1, zero
0004e7 9220 292f                 	sts noise_fx_1xx, zero
0004e9 9220 2930                 	sts noise_fx_1xx+1, zero
0004eb 9220 2931                 	sts noise_fx_1xx_total, zero
0004ed 9220 2932                 	sts noise_fx_1xx_total+1, zero
0004ef 9220 2933                 	sts noise_fx_2xx, zero
0004f1 9220 2934                 	sts noise_fx_2xx+1, zero
0004f3 9220 2935                 	sts noise_fx_2xx_total, zero
0004f5 9220 2936                 	sts noise_fx_2xx_total+1, zero
0004f7 9220 2937                 	sts noise_fx_3xx_start, zero
0004f9 9220 2938                 	sts noise_fx_3xx_start+1, zero
0004fb 9220 2939                 	sts noise_fx_3xx_target, zero
0004fd 9220 293a                 	sts noise_fx_3xx_target+1, zero
0004ff 9220 293b                 	sts noise_fx_3xx_speed, zero
000501 9220 293c                 	sts noise_fx_3xx_speed+1, zero
000503 9220 293d                 	sts noise_fx_3xx_total_offset, zero
000505 9220 293e                 	sts noise_fx_3xx_total_offset+1, zero
000507 9220 293f                 	sts noise_fx_4xy_speed, zero
000509 9220 2940                 	sts noise_fx_4xy_depth, zero
00050b 9220 2941                 	sts noise_fx_4xy_phase, zero
00050d 9220 2942                 	sts noise_fx_7xy_speed, zero
00050f 9220 2943                 	sts noise_fx_7xy_depth, zero
000511 9220 2944                 	sts noise_fx_7xy_phase, zero
000513 9220 2945                 	sts noise_fx_7xy_value, zero
000515 9220 2946                 	sts noise_fx_Axy, zero
000517 93c0 2947                 	sts noise_fx_Gxx_pre, r28
000519 93c0 2948                 	sts noise_fx_Gxx_post, r28
00051b 9220 2949                 	sts noise_fx_Pxx_total, zero
00051d 9220 294a                 	sts noise_fx_Pxx_total+1, zero
00051f 9220 294b                 	sts noise_fx_Qxy_target, zero
000521 9220 294c                 	sts noise_fx_Qxy_target+1, zero
000523 9220 294d                 	sts noise_fx_Qxy_speed, zero
000525 9220 294e                 	sts noise_fx_Qxy_speed+1, zero
000527 9220 294f                 	sts noise_fx_Qxy_total_offset, zero
000529 9220 2950                 	sts noise_fx_Qxy_total_offset+1, zero
00052b 9220 2951                 	sts noise_fx_Rxy_target, zero
00052d 9220 2952                 	sts noise_fx_Rxy_target+1, zero
00052f 9220 2953                 	sts noise_fx_Rxy_speed, zero
000531 9220 2954                 	sts noise_fx_Rxy_speed+1, zero
000533 9220 2955                 	sts noise_fx_Rxy_total_offset, zero
000535 9220 2956                 	sts noise_fx_Rxy_total_offset+1, zero
000537 93c0 2957                 	sts noise_fx_Sxx_pre, r28
000539 93c0 2958                 	sts noise_fx_Sxx_post, r28
                                 
                                 	//PINS
00053b efcf                      	ldi r28, 0xFF
00053c b9c0                      	out VPORTA_DIR, r28 //set all pins in VPORTA to output
                                 
                                 	//TIMERS
                                 	//Frame Counter
                                 	//NOTE:The frame counter will be defaulted to NTSC mode (60 Hz, 120 Hz, 240 Hz)
                                 	//Each interrupt will be setup to interrupt every 240 Hz clock
                                 	//CMP0 = sequence 0, CMP1 = sequence 1, CMP2 = sequence 2, OVF = sequence 3/sound driver
                                 	//Sequence 3 will clock the sound driver every 60Hz, in which new audio data is read and written to the registers
                                 	//Timer period Calculation: (0.00416666666 * 20000000/64)-1 = 1301.08333125 = 0x0515
                                 	//The ATmega4809 is cofigured to run at 20000000 Hz
                                 	//0.00416666666 seconds is the period for 240 Hz
                                 	//The /64 comes from the prescaler divider used
00053d e7c0                      	ldi r28, TCA_SINGLE_CMP0EN_bm | TCA_SINGLE_CMP1EN_bm | TCA_SINGLE_CMP2EN_bm | TCA_SINGLE_WGMODE_NORMAL_gc //interrupt mode
00053e 93c0 0a01                 	sts TCA0_SINGLE_CTRLB, r28
000540 e7c1                      	ldi r28, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP1_bm | TCA_SINGLE_CMP2_bm | TCA_SINGLE_OVF_bm //enable overflow and compare interrupts
000541 93c0 0a0a                 	sts TCA0_SINGLE_INTCTRL, r28
000543 e1c5                      	ldi r28, 0x15 //set the period for CMP0
000544 93c0 0a28                 	sts TCA0_SINGLE_CMP0, r28
000546 e0c5                      	ldi r28, 0x05
000547 93c0 0a29                 	sts TCA0_SINGLE_CMP0 + 1, r28
000549 e2cb                      	ldi r28, 0x2B //set the period for CMP1
00054a 93c0 0a2a                 	sts TCA0_SINGLE_CMP1, r28
00054c e0ca                      	ldi r28, 0x0A
00054d 93c0 0a2b                 	sts TCA0_SINGLE_CMP1 + 1, r28
00054f e4c1                      	ldi r28, 0x41 //set the period for CMP2
000550 93c0 0a2c                 	sts TCA0_SINGLE_CMP2, r28
000552 e0cf                      	ldi r28, 0x0F
000553 93c0 0a2d                 	sts TCA0_SINGLE_CMP2 + 1, r28
000555 e5c7                      	ldi r28, 0x57 //set the period for OVF
000556 93c0 0a26                 	sts TCA0_SINGLE_PER, r28
000558 e1c4                      	ldi r28, 0x14
000559 93c0 0a27                 	sts TCA0_SINGLE_PER + 1, r28
00055b e0cb                      	ldi r28, TCA_SINGLE_CLKSEL_DIV64_gc | TCA_SINGLE_ENABLE_bm //use prescale divider of 64 and enable timer
00055c 93c0 0a00                 	sts TCA0_SINGLE_CTRLA, r28
                                 
                                 	//NOTE: Channel Timers are clocked (20/2)/(0.8948865) = 11.1746014718 times faster than the NES APU
                                 	//Because of this, we multiply all the NES timer values by 11.1746014718 beforehand
                                 	//Since we rotate the sequence when the timer goes from t-(t-1) to 0, instead of 0 to t like the NES, we add 1 to the NES timers before multiplying
                                 	//The ATmega4809 is configured to run at 20 MHz
                                 	//The /2 comes from the prescaler divider used
                                 	//0.8948865 MHz is the speed of the NTSC NES APU
                                 	//NOTE: This means that any offset to the pitch for the NES timers would be multiplied by 11.1746014718 aswell.
                                 	//Pulse 1
00055e e0c0                      	ldi r28, TCB_CNTMODE_INT_gc //interrupt mode
00055f 93c0 0a81                 	sts TCB0_CTRLB, r28
000561 e0c1                      	ldi r28, TCB_CAPT_bm //enable interrupts
000562 93c0 0a85                 	sts TCB0_INTCTRL, r28
000564 91c0 2802                 	lds r28, pulse1_timerL //load the LOW bits for timer
000566 93c0 0a8c                 	sts TCB0_CCMPL, r28
000568 91c0 2803                 	lds r28, pulse1_timerH //load the HIGH bits for timer
00056a 93c0 0a8d                 	sts TCB0_CCMPH, r28
00056c e0c3                      	ldi r28, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
00056d 93c0 0a80                 	sts TCB0_CTRLA, r28
                                 
                                 	//PULSE 2
00056f e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
000570 93b0 0a91                 	sts TCB1_CTRLB, r27
000572 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
000573 93b0 0a95                 	sts TCB1_INTCTRL, r27
000575 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
000577 93b0 0a9c                 	sts TCB1_CCMPL, r27
000579 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
00057b 93b0 0a9d                 	sts TCB1_CCMPH, r27
00057d e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
00057e 93b0 0a90                 	sts TCB1_CTRLA, r27
                                 
                                 	//NOTE: The triangle timer is clocked at the same speed as the NES CPU, aka twice the NES APU.
                                 	//Therefore, we won't be using a /2 clock divider like we did with the pulse timers.
                                 	//TRIANGLE
000580 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
000581 93b0 0aa1                 	sts TCB2_CTRLB, r27
000583 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
                                 	//sts TCB2_INTCTRL, r27
000584 91b0 2810                 	lds r27, triangle_timerL //load the LOW bits for timer
000586 93b0 0aac                 	sts TCB2_CCMPL, r27
000588 91b0 2811                 	lds r27, triangle_timerH //load the HIGH bits for timer
00058a 93b0 0aad                 	sts TCB2_CCMPH, r27
00058c e0b1                      	ldi r27, TCB_CLKSEL_CLKDIV1_gc | TCB_ENABLE_bm //use prescaler divider of 1 and enable timer
00058d 93b0 0aa0                 	sts TCB2_CTRLA, r27
00058f 9478                      	sei //global interrupt enable
                                 
                                 	//NOISE
000590 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
000591 93b0 0ab1                 	sts TCB3_CTRLB, r27
000593 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
000594 93b0 0ab5                 	sts TCB3_INTCTRL, r27
000596 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
000598 93b0 0abc                 	sts TCB3_CCMPL, r27
00059a 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
00059c 93b0 0abd                 	sts TCB3_CCMPH, r27
00059e e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
00059f 93b0 0ab0                 	sts TCB3_CTRLA, r27
                                 
                                 
                                 
                                 //https://wiki.nesdev.com/w/index.php/APU_Mixer
                                 volume_mixer:
0005a1 91c0 2806                 	lds r28, pulse1_output_volume
0005a3 91d0 280e                 	lds r29, pulse2_output_volume
                                 
                                 volume_mixer_pulse1:
0005a5 fea0                      	sbrs pulse1_sequence, 0 //if the sequence output is zero, return
0005a6 c015                      	rjmp volume_mixer_pulse1_off
                                 
0005a7 14b2                      	cp pulse1_length_counter, zero //if length is zero, return
0005a8 f099                      	breq volume_mixer_pulse1_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
0005a9 91e0 0a8c                 	lds r30, TCB0_CCMPL
0005ab e5f9                      	ldi r31, 0x059
0005ac 17ef                      	cp r30, r31
0005ad 91e0 0a8d                 	lds r30, TCB0_CCMPH
0005af e0f0                      	ldi r31, 0x00
0005b0 07ef                      	cpc r30, r31
0005b1 f050                      	brlo volume_mixer_pulse1_off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $5965
0005b2 91e0 0a8c                 	lds r30, TCB0_CCMPL
0005b4 e6f6                      	ldi r31, 0x66
0005b5 17ef                      	cp r30, r31
0005b6 91e0 0a8d                 	lds r30, TCB0_CCMPH
0005b8 e5f9                      	ldi r31, 0x59
0005b9 07ef                      	cpc r30, r31
0005ba f408                      	brsh volume_mixer_pulse1_off
0005bb c001                      	rjmp volume_mixer_pulse2 //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse1_off:
0005bc 27cc                      	clr r28
                                 
                                 volume_mixer_pulse2:
0005bd fed0                      	sbrs pulse2_sequence, 0 //if the sequence output is zero, return
0005be c015                      	rjmp volume_mixer_pulse2_off
                                 
0005bf 14e2                      	cp pulse2_length_counter, zero //if length is zero, return
0005c0 f099                      	breq volume_mixer_pulse2_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
0005c1 91e0 0a9c                 	lds r30, TCB1_CCMPL
0005c3 e5f9                      	ldi r31, 0x059
0005c4 17ef                      	cp r30, r31
0005c5 91e0 0a9d                 	lds r30, TCB1_CCMPH
0005c7 e0f0                      	ldi r31, 0x00
0005c8 07ef                      	cpc r30, r31
0005c9 f050                      	brlo volume_mixer_pulse2_off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $5965
0005ca 91e0 0a9c                 	lds r30, TCB1_CCMPL
0005cc e6f6                      	ldi r31, 0x66
0005cd 17ef                      	cp r30, r31
0005ce 91e0 0a9d                 	lds r30, TCB1_CCMPH
0005d0 e5f9                      	ldi r31, 0x59
0005d1 07ef                      	cpc r30, r31
0005d2 f408                      	brsh volume_mixer_pulse2_off
0005d3 c001                      	rjmp volume_mixer_pulse_out //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse2_off:
0005d4 27dd                      	clr r29
                                 
                                 volume_mixer_pulse_out:
0005d5 0fcd                      	add r28, r29
0005d6 e6e2                      	ldi ZL, LOW(pulse_volume_table << 1)
0005d7 e0f2                      	ldi ZH, HIGH(pulse_volume_table << 1)
0005d8 0fec                      	add ZL, r28
0005d9 1df2                      	adc ZH, zero
0005da 91c4                      	lpm r28, Z
                                 
                                 volume_mixer_tnd_triangle:
0005db 2fd4                      	mov r29, triangle_sequence
0005dc fdd4                      	sbrc r29, 4 //check 5th bit
0005dd 95d0                      	com r29
0005de 70df                      	andi r29, 0x0F
0005df 2fed                      	mov r30, r29
0005e0 0fde                      	add r29, r30 //multiply the triangle volume by 3
0005e1 0fde                      	add r29, r30
                                 
                                 volume_mixer_tnd_noise:
0005e2 ff50                      	sbrs noise_sequence_LOW, 0 //check 0th bit, skip if set
0005e3 c004                      	rjmp volume_mixer_tnd_out
0005e4 91e0 2816                 	lds r30, noise_output_volume
0005e6 0fee                      	lsl r30 //multiply noise volume by 2
0005e7 0fde                      	add r29, r30
                                 
                                 volume_mixer_tnd_out:
0005e8 e8e2                      	ldi ZL, LOW(tnd_volume_table << 1)
0005e9 e0f2                      	ldi ZH, HIGH(tnd_volume_table << 1)
0005ea 0fed                      	add ZL, r29
0005eb 1df2                      	adc ZH, zero
0005ec 91d4                      	lpm r29, Z
                                 
                                 volume_mixer_output:
0005ed 0fcd                      	add r28, r29
0005ee b9c1                      	out VPORTA_OUT, r28
0005ef cfb1                      	rjmp volume_mixer
                                 
                                 
                                 
                                 //FRAME COUNTER/AUDIO SAMPLE ISR
                                 sequence_0_2:
0005f0 b7bf                      	in r27, CPU_SREG
0005f1 93bf                      	push r27
0005f2 94f8                      	cli
                                 
                                 	//ENVELOPE
0005f3 d053                      	rcall pulse1_envelope_routine
0005f4 d09f                      	rcall pulse2_envelope_routine
                                 
0005f5 e5b0                      	ldi r27, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP2_bm //clear OVF flag
0005f6 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
0005f8 91bf                      	pop r27
0005f9 bfbf                      	out CPU_SREG, r27
0005fa 9518                      	reti
                                 
                                 sequence_1_3:
0005fb b7bf                      	in r27, CPU_SREG
0005fc 93bf                      	push r27
0005fd 94f8                      	cli
                                 
                                 	//ENVELOPE
0005fe d048                      	rcall pulse1_envelope_routine
0005ff d094                      	rcall pulse2_envelope_routine
                                 
                                 	//SWEEP
000600 fcc3                      	sbrc pulse1_sweep, 3 //check if the sweep enable bit is cleared
000601 d01b                      	rcall pulse1_sweep_routine
000602 fcf3                      	sbrc pulse2_sweep, 3
000603 d066                      	rcall pulse2_sweep_routine
                                 
                                 	//LENGTH
                                 	//NOTE: The length routine is relatively simple, so we will not be using clocks to rjmp and ret to a seperate lable
                                 sequence_1_3_pulse1_length:
000604 fd95                      	sbrc pulse_channel_flags, 5 //check if the length counter halt bit is cleared
000605 c002                      	rjmp sequence_1_3_pulse2_length
000606 10b2                      	cpse pulse1_length_counter, zero //if length counter is already 0, don't decrement
000607 94ba                      	dec pulse1_length_counter
                                 sequence_1_3_pulse2_length:
000608 fd91                      	sbrc pulse_channel_flags, 1 //check if the length counter halt bit is cleared
000609 c002                      	rjmp sequence_1_3_exit
00060a 10e2                      	cpse pulse2_length_counter, zero //if length counter is already 0, don't decrement
00060b 94ea                      	dec pulse2_length_counter
                                 
                                 sequence_1_3_exit:
00060c e2b1                      	ldi r27, TCA_SINGLE_CMP1_bm | TCA_SINGLE_OVF_bm //clear OVF flag
00060d 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
00060f 91bf                      	pop r27
000610 bfbf                      	out CPU_SREG, r27
000611 9518                      	reti
                                 
                                 //PULSE 1 ROUTINES
                                 pulse1_sequence_routine:
000612 b7bf                      	in r27, CPU_SREG
000613 93bf                      	push r27
000614 94f8                      	cli
                                 
000615 0caa                      	lsl pulse1_sequence //shifts sequence to the left
000616 1ca2                      	adc pulse1_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
000617 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
000618 93b0 0a86                 	sts TCB0_INTFLAGS, r27
00061a 91bf                      	pop r27
00061b bfbf                      	out CPU_SREG, r27
00061c 9518                      	reti
                                 
                                 pulse1_sweep_routine:
00061d 2dbc                      	mov r27, pulse1_sweep
00061e 70b7                      	andi r27, 0x07 //mask for period divider bits
00061f f4f9                      	brne pulse1_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse1_sweep_routine_action: //if the divider is == 0, update the pulse timer period
000620 93df                      	push r29
000621 2ddc                      	mov r29, pulse1_sweep
000622 95d2                      	swap r29
000623 70d7                      	andi r29, 0x07 //mask for shift bits
000624 f411                      	brne pulse1_sweep_routine_action_main //shift != 0
000625 91df                      	pop r29
000626 c019                      	rjmp pulse1_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse1_sweep_routine_action_main:
000627 91a0 0a8c                 	lds r26, TCB0_CCMPL
000629 91b0 0a8d                 	lds r27, TCB0_CCMPH
                                 pulse1_sweep_routine_action_main_loop:
00062b 95b6                      	lsr r27
00062c 95a7                      	ror r26
00062d 95da                      	dec r29
00062e f7e1                      	brne pulse1_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
00062f fec7                      	sbrs pulse1_sweep, 7 //check the negate flag
000630 c002                      	rjmp pulse1_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
000631 95a0                      	com r26 //pulse1 uses one's complement if the negate flag is set
000632 95b0                      	com r27
                                 
                                 pulse1_sweep_routine_action_main_add:
000633 91d0 0a8c                 	lds r29, TCB0_CCMPL //perform addition to get new timer period
000635 0fad                      	add r26, r29
000636 91d0 0a8d                 	lds r29, TCB0_CCMPH
000638 1fbd                      	adc r27, r29
                                 
000639 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new LOW bits for timer
00063b 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new HIGH bits for timer
                                 	
00063d 91df                      	pop r29
00063e c001                      	rjmp pulse1_sweep_routine_check_reload
                                 
                                 pulse1_sweep_routine_decrement_divider:
00063f 94ca                      	dec pulse1_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse1_sweep_routine_check_reload:
000640 ff97                      	sbrs pulse_channel_flags, 7 //if the reload flag is set, reload the sweep divider
000641 9508                      	ret
                                 
                                 pulse1_sweep_reload:
000642 90c0 2801                 	lds pulse1_sweep, pulse1_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
000644 94c2                      	swap pulse1_sweep //bring data from high byte to low byte
000645 779f                      	cbr pulse_channel_flags, 0b10000000 //clear reload flag
000646 9508                      	ret
                                 
                                 
                                 
                                 pulse1_envelope_routine:
000647 fd96                      	sbrc pulse_channel_flags, 6 //check if start flag is cleared
000648 c010                      	rjmp pulse1_envelope_routine_clear_start
                                 
000649 3000                      	cpi pulse1_volume_divider, 0x00 //check if the divider is 0
00064a f011                      	breq PC+3 //if the divider == 0, check loop flag
00064b 950a                      	dec pulse1_volume_divider //if the divider != 0, decrement and return
00064c 9508                      	ret
                                 
00064d 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the divider == 0, reset the divider period
00064f 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
000650 ff95                      	sbrs pulse_channel_flags, 5 //check if the loop flag is set
000651 c002                      	rjmp pulse1_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
000652 e01f                      	ldi pulse1_volume_decay, 0x0F //if the loop flag is set, reset decay and return
000653 9508                      	ret
                                 
                                 pulse1_envelope_routine_decrement_decay:
000654 3010                      	cpi pulse1_volume_decay, 0x00 //check if the decay is 0
000655 f409                      	brne PC+2 //if decay != 0, go decrement
000656 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
000657 951a                      	dec pulse1_volume_decay
000658 9508                      	ret
                                 
                                 pulse1_envelope_routine_clear_start:
000659 7b9f                      	cbr pulse_channel_flags, 0b01000000 //if the start flag is set, clear it
00065a 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the start flag is set, reset the divider period
00065c 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
00065d e01f                      	ldi pulse1_volume_decay, 0x0F //if the start flag is set, reset decay
00065e 9508                      	ret
                                 
                                 //PULSE 2 ROUTINES
                                 pulse2_sequence_routine:
00065f b7bf                      	in r27, CPU_SREG
000660 93bf                      	push r27
000661 94f8                      	cli
                                 
000662 0cdd                      	lsl pulse2_sequence //shifts sequence to the left
000663 1cd2                      	adc pulse2_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
000664 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
000665 93b0 0a96                 	sts TCB1_INTFLAGS, r27
000667 91bf                      	pop r27
000668 bfbf                      	out CPU_SREG, r27
000669 9518                      	reti
                                 
                                 pulse2_sweep_routine:
00066a 2dbf                      	mov r27, pulse2_sweep
00066b 70b7                      	andi r27, 0x07 //mask for period divider bits
00066c f4f9                      	brne pulse2_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse2_sweep_routine_action: //if the divider is == 0, update the pulse timer period
00066d 93df                      	push r29
00066e 2ddf                      	mov r29, pulse2_sweep
00066f 95d2                      	swap r29
000670 70d7                      	andi r29, 0x07 //mask for shift bits
000671 f411                      	brne pulse2_sweep_routine_action_main //shift != 0
000672 91df                      	pop r29
000673 c019                      	rjmp pulse2_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse2_sweep_routine_action_main:
000674 91a0 0a9c                 	lds r26, TCB1_CCMPL
000676 91b0 0a9d                 	lds r27, TCB1_CCMPH
                                 pulse2_sweep_routine_action_main_loop:
000678 95b6                      	lsr r27
000679 95a7                      	ror r26
00067a 95da                      	dec r29
00067b f7e1                      	brne pulse2_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
00067c fef7                      	sbrs pulse2_sweep, 7 //check the negate flag
00067d c002                      	rjmp pulse2_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
00067e 95a0                      	com r26 //pulse2 uses one's complement if the negate flag is set
00067f 95b0                      	com r27
                                 
                                 pulse2_sweep_routine_action_main_add:
000680 91d0 0a9c                 	lds r29, TCB1_CCMPL //perform addition to get new timer period
000682 0fad                      	add r26, r29
000683 91d0 0a9d                 	lds r29, TCB1_CCMPH
000685 1fbd                      	adc r27, r29
                                 
000686 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new LOW bits for timer
000688 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new HIGH bits for timer
                                 	
00068a 91df                      	pop r29
00068b c001                      	rjmp pulse2_sweep_routine_check_reload
                                 
                                 pulse2_sweep_routine_decrement_divider:
00068c 94fa                      	dec pulse2_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse2_sweep_routine_check_reload:
00068d ff93                      	sbrs pulse_channel_flags, 3 //if the reload flag is set, reload the sweep divider
00068e 9508                      	ret
                                 
                                 pulse2_sweep_reload:
00068f 90f0 2809                 	lds pulse2_sweep, pulse2_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
000691 94f2                      	swap pulse2_sweep //bring data from high byte to low byte
000692 7f97                      	cbr pulse_channel_flags, 0b00001000 //clear reload flag
000693 9508                      	ret
                                 
                                 
                                 
                                 pulse2_envelope_routine:
000694 fd92                      	sbrc pulse_channel_flags, 2 //check if start flag is cleared
000695 c010                      	rjmp pulse2_envelope_routine_clear_start
                                 
000696 3020                      	cpi pulse2_volume_divider, 0x00 //check if the divider is 0
000697 f011                      	breq PC+3 //if the divider == 0, check loop flag
000698 952a                      	dec pulse2_volume_divider //if the divider != 0, decrement and return
000699 9508                      	ret
                                 
00069a 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the divider == 0, reset the divider period
00069c 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
00069d ff91                      	sbrs pulse_channel_flags, 1 //check if the loop flag is set
00069e c002                      	rjmp pulse2_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
00069f e03f                      	ldi pulse2_volume_decay, 0x0F //if the loop flag is set, reset decay and return
0006a0 9508                      	ret
                                 
                                 pulse2_envelope_routine_decrement_decay:
0006a1 3030                      	cpi pulse2_volume_decay, 0x00 //check if the decay is 0
0006a2 f409                      	brne PC+2 //if decay != 0, go decrement
0006a3 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
0006a4 953a                      	dec pulse2_volume_decay
0006a5 9508                      	ret
                                 
                                 pulse2_envelope_routine_clear_start:
0006a6 7f9b                      	cbr pulse_channel_flags, 0b00000100 //if the start flag is set, clear it
0006a7 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the start flag is set, reset the divider period
0006a9 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
0006aa e03f                      	ldi pulse2_volume_decay, 0x0F //if the start flag is set, reset decay
0006ab 9508                      	ret
                                 
                                 //TRIANGLE ROUTINES
                                 triangle_sequence_routine:
0006ac b7bf                      	in r27, CPU_SREG
0006ad 93bf                      	push r27
0006ae 94f8                      	cli
                                 
0006af 5f4f                      	subi triangle_sequence, -1 //increment sequence by 1
0006b0 714f                      	andi triangle_sequence, 0b00011111 //mask out bits 5, 6 and 7 NOTE: the sequence only needs bits 0-4.
                                 
0006b1 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
0006b2 93b0 0aa6                 	sts TCB2_INTFLAGS, r27
0006b4 91bf                      	pop r27
0006b5 bfbf                      	out CPU_SREG, r27
0006b6 9518                      	reti
                                 
                                 //NOISE ROUTINES
                                 noise_sequence_routine:
0006b7 b7bf                      	in r27, CPU_SREG
0006b8 93bf                      	push r27
0006b9 94f8                      	cli
                                 
0006ba 2fa5                      	mov r26, noise_sequence_LOW
0006bb fd67                      	sbrc noise_sequence_HIGH, 7 //skip if MODE bit is clear
0006bc c00b                      	rjmp noise_sequence_routine_mode_set
                                 
                                 noise_sequence_routine_mode_clear:
0006bd 95a6                      	lsr r26 //move the 1th bit to the 0th bit place
0006be 27a5                      	eor r26, noise_sequence_LOW
0006bf fda0                      	sbrc r26, 0 //skip if the EOR of bit 0 and 1 is clear
0006c0 c003                      	rjmp noise_sequence_routine_mode_clear_EOR_set
                                 
                                 noise_sequence_routine_mode_clear_EOR_clear:
0006c1 9566                      	lsr noise_sequence_HIGH
0006c2 9557                      	ror noise_sequence_LOW
0006c3 c013                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_clear_EOR_set:
0006c4 9566                      	lsr noise_sequence_HIGH
0006c5 9557                      	ror noise_sequence_LOW
0006c6 6460                      	ori noise_sequence_HIGH, 0b01000000 //set the 14th bit
0006c7 c00f                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_set:
0006c8 0faa                      	lsl r26
0006c9 1faa                      	rol r26
0006ca 1faa                      	rol r26 //move the 6th bit to the 0th bit place
0006cb 27a5                      	eor r26, noise_sequence_LOW
0006cc fda0                      	sbrc r26, 0 //skip if the EOR of bit 0 and 1 is clear
0006cd c005                      	rjmp noise_sequence_routine_mode_set_EOR_set
                                 
                                 noise_sequence_routine_mode_set_EOR_clear:
0006ce 776f                      	cbr noise_sequence_HIGH, 0b10000000 //clear the MODE flag
0006cf 9566                      	lsr noise_sequence_HIGH
0006d0 9557                      	ror noise_sequence_LOW
0006d1 6860                      	sbr noise_sequence_HIGH, 0b10000000 //set the MODE flag
0006d2 c004                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_set_EOR_set:
0006d3 9566                      	lsr noise_sequence_HIGH
0006d4 9557                      	ror noise_sequence_LOW
0006d5 6860                      	sbr noise_sequence_HIGH, 0b10000000 //set the MODE flag
0006d6 c000                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_exit:
0006d7 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
0006d8 93b0 0ab6                 	sts TCB3_INTFLAGS, r27
0006da 91bf                      	pop r27
0006db bfbf                      	out CPU_SREG, r27
0006dc 9518                      	reti
                                 
                                 //CONVERTERS
                                 //converts and loads 5 bit length to corresponding 8 bit length value into r29
                                 length_converter:
0006dd e4ea                      	ldi ZL, LOW(length << 1)
0006de e4f2                      	ldi ZH, HIGH(length << 1)
0006df 0fed                      	add ZL, r29
0006e0 1df2                      	adc ZH, zero
0006e1 91d4                      	lpm r29, Z
0006e2 9508                      	ret
                                 
                                 //loads pulse sequence into r29
                                 duty_cycle_sequences:
0006e3 e6ea                      	ldi ZL, LOW(sequences << 1)
0006e4 e4f2                      	ldi ZH, HIGH(sequences << 1)
0006e5 0fed                      	add ZL, r29
0006e6 1df2                      	adc ZH, zero
0006e7 91d4                      	lpm r29, Z
0006e8 9508                      	ret
                                 
                                 
                                 
                                 //SOUND DRIVER
                                 sound_driver:
0006e9 b7bf                      	in r27, CPU_SREG
0006ea 93bf                      	push r27
0006eb 94f8                      	cli
0006ec 93cf                      	push r28
0006ed 93df                      	push r29
0006ee 93ef                      	push r30
0006ef 93ff                      	push r31
                                 
                                 	//SOUND DRIVER
0006f0 91a0 281f                 	lds r26, song_fx_Bxx
0006f2 3faf                      	cpi r26, 0xFF //0xFF means that the flag is disabled
0006f3 f4a9                      	brne sound_driver_fx_Bxx_routine
0006f4 91a0 2820                 	lds r26, song_fx_Cxx
0006f6 11a2                      	cpse r26, zero
0006f7 c08b                      	rjmp sound_driver_fx_Cxx_routine
0006f8 91a0 2821                 	lds r26, song_fx_Dxx
0006fa 11a2                      	cpse r26, zero
0006fb c096                      	rjmp sound_driver_fx_Dxx_routine
                                 
0006fc 91a0 281a                 	lds r26, song_frame_offset
0006fe 91b0 281b                 	lds r27, song_frame_offset+1
000700 91c0 281c                 	lds r28, song_size
000702 91d0 281d                 	lds r29, song_size+1
000704 17ac                      	cp r26, r28
000705 07bd                      	cpc r27, r29
000706 f408                      	brsh sound_driver_fx_song_loop
000707 c101                      	rjmp sound_driver_channel0
                                 
                                 
                                 sound_driver_fx_song_loop:
000708 e0a0                      	ldi r26, 0x00
                                 sound_driver_fx_Bxx_routine:
000709 91e0 2818                 	lds ZL, song_frames
00070b 91f0 2819                 	lds ZH, song_frames+1
00070d 27cc                      	clr r28 //initialize r29:r28 to 0
00070e 27dd                      	clr r29
00070f 95a3                      	inc r26 //increment xx parameter by 1
                                 sound_driver_fx_Bxx_routine_loop:
000710 95aa                      	dec r26
000711 f011                      	breq sound_driver_fx_Bxx_routine_loop_exit //once r26 == 0, r29:r28 will hold Bxx*(5*2).
000712 962a                      	adiw r29:r28, 10 //increment the offset by 10 because 5 channels, and each address takes 2 bytes (5*2 = 10)
000713 cffc                      	rjmp sound_driver_fx_Bxx_routine_loop
                                 
                                 sound_driver_fx_Bxx_routine_loop_exit:
000714 9622                      	adiw r29:r28, 2 //add 2 to skip the first 2 bytes (first 2 bytes is the song size)
000715 93c0 281a                 	sts song_frame_offset, r28
000717 93d0 281b                 	sts song_frame_offset+1, r29
000719 0fec                      	add ZL, r28
00071a 1ffd                      	adc ZH, r29
                                 
00071b 91a5                      	lpm r26, Z+ //load the address of the frame(pattern)
00071c 91b5                      	lpm r27, Z+
00071d 0faa                      	lsl r26
00071e 1fbb                      	rol r27
00071f 93a0 2822                 	sts pulse1_pattern, r26
000721 93b0 2823                 	sts pulse1_pattern+1, r27
000723 91a5                      	lpm r26, Z+
000724 91b5                      	lpm r27, Z+
000725 0faa                      	lsl r26
000726 1fbb                      	rol r27
000727 93a0 2871                 	sts pulse2_pattern, r26
000729 93b0 2872                 	sts pulse2_pattern+1, r27
00072b 91a5                      	lpm r26, Z+
00072c 91b5                      	lpm r27, Z+
00072d 0faa                      	lsl r26
00072e 1fbb                      	rol r27
00072f 93a0 28c0                 	sts triangle_pattern, r26
000731 93b0 28c1                 	sts triangle_pattern+1, r27
000733 91a5                      	lpm r26, Z+
000734 91b5                      	lpm r27, Z+
000735 0faa                      	lsl r26
000736 1fbb                      	rol r27
000737 93a0 290a                 	sts noise_pattern, r26
000739 93b0 290b                 	sts noise_pattern+1, r27
                                 
00073b 9220 2826                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
00073d 9220 2827                 	sts pulse1_pattern_offset+1, zero
00073f 9220 2824                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
000741 9220 2825                 	sts pulse1_pattern_delay_frames, zero
000743 9220 2875                 	sts pulse2_pattern_offset, zero
000745 9220 2876                 	sts pulse2_pattern_offset+1, zero
000747 9220 2873                 	sts pulse2_pattern_delay_rows, zero
000749 9220 2874                 	sts pulse2_pattern_delay_frames, zero
00074b 9220 28c4                 	sts triangle_pattern_offset, zero
00074d 9220 28c5                 	sts triangle_pattern_offset+1, zero
00074f 9220 28c2                 	sts triangle_pattern_delay_rows, zero
000751 9220 28c3                 	sts triangle_pattern_delay_frames, zero
000753 9220 290e                 	sts noise_pattern_offset, zero
000755 9220 290f                 	sts noise_pattern_offset+1, zero
000757 9220 290c                 	sts noise_pattern_delay_rows, zero
000759 9220 290d                 	sts noise_pattern_delay_frames, zero
                                 
00075b efaf                      	ldi r26, 0xFF
00075c 93a0 285f                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
00075e 93a0 2860                 	sts pulse1_fx_Gxx_post, r26
000760 93a0 286f                 	sts pulse1_fx_Sxx_pre, r26
000762 93a0 2870                 	sts pulse1_fx_Sxx_post, r26
000764 93a0 28ae                 	sts pulse2_fx_Gxx_pre, r26
000766 93a0 28af                 	sts pulse2_fx_Gxx_post, r26
000768 93a0 28be                 	sts pulse2_fx_Sxx_pre, r26
00076a 93a0 28bf                 	sts pulse2_fx_Sxx_post, r26
00076c 93a0 28f8                 	sts triangle_fx_Gxx_pre, r26
00076e 93a0 28f9                 	sts triangle_fx_Gxx_post, r26
000770 93a0 2908                 	sts triangle_fx_Sxx_pre, r26
000772 93a0 2909                 	sts triangle_fx_Sxx_post, r26
000774 93a0 2947                 	sts noise_fx_Gxx_pre, r26
000776 93a0 2948                 	sts noise_fx_Gxx_post, r26
000778 93a0 2957                 	sts noise_fx_Sxx_pre, r26
00077a 93a0 2958                 	sts noise_fx_Sxx_post, r26
                                 
00077c 93a0 281f                 	sts song_fx_Bxx, r26 //reset all song effects
00077e 9220 2820                 	sts song_fx_Cxx, zero
000780 9220 2821                 	sts song_fx_Dxx, zero
000782 c086                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_fx_Cxx_routine:
000783 91ff                      	pop r31
000784 91ef                      	pop r30
000785 91df                      	pop r29
000786 91cf                      	pop r28
000787 91bf                      	pop r27
000788 bfbf                      	out CPU_SREG, r27
000789 94f8                      	cli //disable global interrupts
                                 		
00078a efaf                      	ldi r26, 0xFF
00078b 93a0 281f                 	sts song_fx_Bxx, r26 //reset all song effects
00078d 9220 2820                 	sts song_fx_Cxx, zero
00078f 9220 2821                 	sts song_fx_Dxx, zero
000791 9518                      	reti
                                 
                                 sound_driver_fx_Dxx_routine:
000792 91e0 2818                 	lds ZL, song_frames
000794 91f0 2819                 	lds ZH, song_frames+1
000796 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
000798 91b0 281b                 	lds r27, song_frame_offset+1
00079a 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
00079b 93a0 281a                 	sts song_frame_offset, r26
00079d 93b0 281b                 	sts song_frame_offset+1, r27
00079f 0fea                      	add ZL, r26
0007a0 1ffb                      	adc ZH, r27
                                 
0007a1 91a5                      	lpm r26, Z+ //load the address of the next pattern
0007a2 91b5                      	lpm r27, Z+
0007a3 0faa                      	lsl r26
0007a4 1fbb                      	rol r27
0007a5 93a0 2822                 	sts pulse1_pattern, r26
0007a7 93b0 2823                 	sts pulse1_pattern+1, r27
0007a9 91a5                      	lpm r26, Z+
0007aa 91b5                      	lpm r27, Z+
0007ab 0faa                      	lsl r26
0007ac 1fbb                      	rol r27
0007ad 93a0 2871                 	sts pulse2_pattern, r26
0007af 93b0 2872                 	sts pulse2_pattern+1, r27
0007b1 91a5                      	lpm r26, Z+
0007b2 91b5                      	lpm r27, Z+
0007b3 0faa                      	lsl r26
0007b4 1fbb                      	rol r27
0007b5 93a0 28c0                 	sts triangle_pattern, r26
0007b7 93b0 28c1                 	sts triangle_pattern+1, r27
0007b9 91a5                      	lpm r26, Z+
0007ba 91b5                      	lpm r27, Z+
0007bb 0faa                      	lsl r26
0007bc 1fbb                      	rol r27
0007bd 93a0 290a                 	sts noise_pattern, r26
0007bf 93b0 290b                 	sts noise_pattern+1, r27
                                 
0007c1 9220 2826                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
0007c3 9220 2827                 	sts pulse1_pattern_offset+1, zero
0007c5 9220 2824                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
0007c7 9220 2825                 	sts pulse1_pattern_delay_frames, zero
0007c9 9220 2875                 	sts pulse2_pattern_offset, zero
0007cb 9220 2876                 	sts pulse2_pattern_offset+1, zero
0007cd 9220 2873                 	sts pulse2_pattern_delay_rows, zero
0007cf 9220 2874                 	sts pulse2_pattern_delay_frames, zero
0007d1 9220 28c4                 	sts triangle_pattern_offset, zero
0007d3 9220 28c5                 	sts triangle_pattern_offset+1, zero
0007d5 9220 28c2                 	sts triangle_pattern_delay_rows, zero
0007d7 9220 28c3                 	sts triangle_pattern_delay_frames, zero
0007d9 9220 290e                 	sts noise_pattern_offset, zero
0007db 9220 290f                 	sts noise_pattern_offset+1, zero
0007dd 9220 290c                 	sts noise_pattern_delay_rows, zero
0007df 9220 290d                 	sts noise_pattern_delay_frames, zero
                                 
0007e1 efaf                      	ldi r26, 0xFF
0007e2 93a0 285f                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
0007e4 93a0 2860                 	sts pulse1_fx_Gxx_post, r26
0007e6 93a0 286f                 	sts pulse1_fx_Sxx_pre, r26
0007e8 93a0 2870                 	sts pulse1_fx_Sxx_post, r26
0007ea 93a0 28ae                 	sts pulse2_fx_Gxx_pre, r26
0007ec 93a0 28af                 	sts pulse2_fx_Gxx_post, r26
0007ee 93a0 28be                 	sts pulse2_fx_Sxx_pre, r26
0007f0 93a0 28bf                 	sts pulse2_fx_Sxx_post, r26
0007f2 93a0 28f8                 	sts triangle_fx_Gxx_pre, r26
0007f4 93a0 28f9                 	sts triangle_fx_Gxx_post, r26
0007f6 93a0 2908                 	sts triangle_fx_Sxx_pre, r26
0007f8 93a0 2909                 	sts triangle_fx_Sxx_post, r26
0007fa 93a0 2947                 	sts noise_fx_Gxx_pre, r26
0007fc 93a0 2948                 	sts noise_fx_Gxx_post, r26
0007fe 93a0 2957                 	sts noise_fx_Sxx_pre, r26
000800 93a0 2958                 	sts noise_fx_Sxx_post, r26
                                 
000802 93a0 281f                 	sts song_fx_Bxx, r26 //reset all song effects
000804 9220 2820                 	sts song_fx_Cxx, zero
000806 9220 2821                 	sts song_fx_Dxx, zero
000808 c000                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0:
000809 91a0 2824                 	lds r26, pulse1_pattern_delay_rows
00080b 91b0 2825                 	lds r27, pulse1_pattern_delay_frames
00080d 9610                      	adiw r27:r26, 0
00080e f009                      	breq sound_driver_channel0_main //if the pattern delay is 0, proceed with sound driver procedures
00080f c2e0                      	rjmp sound_driver_channel0_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel0_main:
000810 91e0 2822                 	lds ZL, pulse1_pattern //current pattern for pulse 1
000812 91f0 2823                 	lds ZH, pulse1_pattern+1
000814 91a0 2826                 	lds r26, pulse1_pattern_offset //current offset in the pattern for pulse 1
000816 91b0 2827                 	lds r27, pulse1_pattern_offset+1
000818 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
000819 1ffb                      	adc ZH, r27
00081a 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel0_check_if_note: //check if data is a note (0x00 - 0x56)
00081b 35b7                      	cpi r27, 0x57
00081c f408                      	brsh sound_driver_channel0_check_if_volume
00081d c17c                      	rjmp sound_driver_channel0_note
                                 sound_driver_channel0_check_if_volume: //check if data is volume (0x57-0x66)
00081e 36b7                      	cpi r27, 0x67
00081f f408                      	brsh sound_driver_channel0_check_if_delay
000820 c1b6                      	rjmp sound_driver_channel0_volume
                                 sound_driver_channel0_check_if_delay: //check if data is a delay (0x67 - 0xE2)
000821 3eb3                      	cpi r27, 0xE3
000822 f408                      	brsh sound_driver_channel0_check_if_instrument
000823 c1bd                      	rjmp sound_driver_channel0_delay
                                 sound_driver_channel0_check_if_instrument: //check for instrument flag (0xE3)
000824 f409                      	brne sound_driver_channel0_check_if_release
000825 c1c0                      	rjmp sound_driver_channel0_instrument_change 
                                 sound_driver_channel0_check_if_release: //check for note release flag (0xE4)
000826 3eb4                      	cpi r27, 0xE4
000827 f409                      	brne sound_driver_channel0_check_if_end
000828 c269                      	rjmp sound_driver_channel0_release
                                 sound_driver_channel0_check_if_end:
000829 3fbf                      	cpi r27, 0xFF
00082a f409                      	brne sound_driver_channel0_check_if_fx
00082b c28b                      	rjmp sound_driver_channel0_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel0_check_if_fx: //fx flags (0xE5 - 0xFE)
00082c 9631                      	adiw Z, 1 //point Z to the byte next to the flag
00082d 91a4                      	lpm r26, Z //load the fx data into r26
00082e d2b7                      	rcall sound_driver_channel0_increment_offset_twice
                                 
00082f 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
000830 e6ee                      	ldi ZL, LOW(channel0_fx << 1) //load in note table
000831 e4f2                      	ldi ZH, HIGH(channel0_fx << 1)
000832 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
000833 0feb                      	add ZL, r27 //add offset
000834 1df2                      	adc ZH, zero
000835 91c5                      	lpm r28, Z+ //load address bytes
000836 91d4                      	lpm r29, Z
000837 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
000838 2ffd                      	mov ZH, r29
000839 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel0_fx_0xy:
00083a 93a0 2845                 	sts pulse1_fx_0xy_sequence, r26
00083c 9220 2846                 	sts pulse1_fx_0xy_sequence+1, zero
00083e cfd1                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel0_fx_1xx:
00083f 9220 284b                 	sts pulse1_fx_2xx, zero //turn off any 2xx pitch slide down
000841 9220 284c                 	sts pulse1_fx_2xx+1, zero
000843 9220 2845                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
000845 9220 2846                 	sts pulse1_fx_0xy_sequence+1, zero
000847 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
000848 937f                      	push r23
000849 2f6a                      	mov r22, r26 //store the rate into r22
00084a eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00084b 9f67                      	mul r22, r23
00084c 917f                      	pop r23
00084d 916f                      	pop r22
                                 
00084e 9416                      	lsr r1 //shift out the fractional bits
00084f 9407                      	ror r0
000850 9416                      	lsr r1
000851 9407                      	ror r0
000852 9416                      	lsr r1
000853 9407                      	ror r0
000854 9416                      	lsr r1
000855 9407                      	ror r0
000856 9200 2847                 	sts pulse1_fx_1xx, r0
000858 9210 2848                 	sts pulse1_fx_1xx+1, r1
00085a cfb5                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel0_fx_2xx:
00085b 9220 2847                 	sts pulse1_fx_1xx, zero //turn off any 1xx pitch slide down
00085d 9220 2848                 	sts pulse1_fx_1xx+1, zero
00085f 9220 2845                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
000861 9220 2846                 	sts pulse1_fx_0xy_sequence+1, zero
000863 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
000864 937f                      	push r23
000865 2f6a                      	mov r22, r26 //store the rate into r22
000866 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
000867 9f67                      	mul r22, r23
000868 917f                      	pop r23
000869 916f                      	pop r22
                                 
00086a 9416                      	lsr r1 //shift out the fractional bits
00086b 9407                      	ror r0
00086c 9416                      	lsr r1
00086d 9407                      	ror r0
00086e 9416                      	lsr r1
00086f 9407                      	ror r0
000870 9416                      	lsr r1
000871 9407                      	ror r0
000872 9200 284b                 	sts pulse1_fx_2xx, r0
000874 9210 284c                 	sts pulse1_fx_2xx+1, r1
000876 cf99                      	rjmp sound_driver_channel0_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel0_fx_3xx:
000877 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
000878 937f                      	push r23
000879 2f6a                      	mov r22, r26 //store the rate into r22
00087a eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00087b 9f67                      	mul r22, r23
00087c 917f                      	pop r23
00087d 916f                      	pop r22
                                 
00087e 9416                      	lsr r1 //shift out the fractional bits
00087f 9407                      	ror r0
000880 9416                      	lsr r1
000881 9407                      	ror r0
000882 9416                      	lsr r1
000883 9407                      	ror r0
000884 9416                      	lsr r1
000885 9407                      	ror r0
000886 9200 2853                 	sts pulse1_fx_3xx_speed, r0
000888 9210 2854                 	sts pulse1_fx_3xx_speed+1, r1
                                 
00088a 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
00088b c001                      	rjmp sound_driver_channel0_fx_3xx_enabled
00088c cf83                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_3xx_enabled:
00088d 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
00088f 91b0 0a8d                 	lds r27, TCB0_CCMPH
000891 93a0 284f                 	sts pulse1_fx_3xx_start, r26
000893 93b0 2850                 	sts pulse1_fx_3xx_start+1, r27
                                 
000895 9220 2855                 	sts pulse1_fx_3xx_total_offset, zero
000897 9220 2856                 	sts pulse1_fx_3xx_total_offset+1, zero
000899 cf76                      	rjmp sound_driver_channel0_main
                                 
                                 //VIBRATO
                                 sound_driver_channel0_fx_4xy:
00089a 2fba                      	mov r27, r26
00089b 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
00089c 95a2                      	swap r26
00089d 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
00089e 93a0 2857                 	sts pulse1_fx_4xy_speed, r26
0008a0 93b0 2858                 	sts pulse1_fx_4xy_depth, r27
0008a2 9220 2859                 	sts pulse1_fx_4xy_phase, zero //reset the phase to 0
0008a4 cf6b                      	rjmp sound_driver_channel0_main
                                 
                                 //TREMELO
                                 sound_driver_channel0_fx_7xy:
0008a5 2fba                      	mov r27, r26
0008a6 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
0008a7 95a2                      	swap r26
0008a8 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0008a9 93a0 285a                 	sts pulse1_fx_7xy_speed, r26
0008ab 93b0 285b                 	sts pulse1_fx_7xy_depth, r27
0008ad 9220 285c                 	sts pulse1_fx_7xy_phase, zero //reset the phase to 0
0008af 9220 285d                 	sts pulse1_fx_7xy_value, zero //reset the tremelo value
0008b1 cf5e                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel0_fx_Axy:
0008b2 93a0 285e                 	sts pulse1_fx_Axy, r26
0008b4 cf5b                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel0_fx_Bxx:
0008b5 93a0 281f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
0008b7 cf58                      	rjmp sound_driver_channel0_main
                                 
                                 //HALT
                                 sound_driver_channel0_fx_Cxx:
0008b8 93b0 2820                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
0008ba cf55                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel0_fx_Dxx:
0008bb 93b0 2821                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
0008bd cf52                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME
                                 sound_driver_channel0_fx_Exx:
0008be 91b0 2800                 	lds r27, pulse1_param
0008c0 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
0008c1 2bba                      	or r27, r26 //move new VVVV bits into pulse1_param
0008c2 93b0 2800                 	sts pulse1_param, r27
0008c4 6096                      	sbr pulse_channel_flags, 6
0008c5 cf4a                      	rjmp sound_driver_channel0_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel0_fx_Fxx:
0008c6 93a0 281e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
0008c8 cf47                      	rjmp sound_driver_channel0_main
                                 
                                 //DELAY
                                 sound_driver_channel0_fx_Gxx:
0008c9 15a2                      	cp r26, zero
0008ca f051                      	breq sound_driver_channel0_fx_Gxx_invalid
0008cb 91b0 281e                 	lds r27, song_speed
0008cd 17ab                      	cp r26, r27
0008ce f430                      	brsh sound_driver_channel0_fx_Gxx_invalid
0008cf 93a0 285f                 	sts pulse1_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
0008d1 e0b1                      	ldi r27, 0x01
0008d2 93b0 2824                 	sts pulse1_pattern_delay_rows, r27
0008d4 c21e                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Gxx_invalid:
0008d5 cf3a                      	rjmp sound_driver_channel0_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel0_fx_Hxy: //hardware sweep up
0008d6 cf39                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixy: //hardware sweep down
0008d7 cf38                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Hxx: //FDS modulation depth
0008d8 cf37                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixx: //FDS modulation speed
0008d9 cf36                      	rjmp sound_driver_channel0_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel0_fx_Pxx:
0008da 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0008db 937f                      	push r23
0008dc 2f6a                      	mov r22, r26
0008dd eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0008de 0367                      	mulsu r22, r23
0008df 917f                      	pop r23
0008e0 916f                      	pop r22
0008e1 9416                      	lsr r1 //shift out the fractional bits
0008e2 9407                      	ror r0
0008e3 9416                      	lsr r1
0008e4 9407                      	ror r0
0008e5 9416                      	lsr r1
0008e6 9407                      	ror r0
0008e7 9416                      	lsr r1
0008e8 9407                      	ror r0
0008e9 9200 2861                 	sts pulse1_fx_Pxx_total, r0
0008eb 9210 2862                 	sts pulse1_fx_Pxx_total+1, r1
0008ed cf22                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel0_fx_Qxy:
                                 sound_driver_channel0_fx_Qxy_check_arpeggio_macro:
0008ee 91e0 282d                 	lds ZL, pulse1_arpeggio_macro
0008f0 91f0 282e                 	lds ZH, pulse1_arpeggio_macro+1
0008f2 9630                      	adiw Z, 0
0008f3 f009                      	breq sound_driver_channel0_fx_Qxy_check_pitch_macro
0008f4 cf1b                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_pitch_macro:
0008f5 91e0 2835                 	lds ZL, pulse1_pitch_macro
0008f7 91f0 2836                 	lds ZH, pulse1_pitch_macro+1
0008f9 9630                      	adiw Z, 0
0008fa f009                      	breq sound_driver_channel0_fx_Qxy_check_hi_pitch_macro
0008fb cf14                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_hi_pitch_macro:
0008fc 91e0 283b                 	lds ZL, pulse1_hi_pitch_macro
0008fe 91f0 283c                 	lds ZH, pulse1_hi_pitch_macro+1
000900 9630                      	adiw Z, 0
000901 f009                      	breq sound_driver_channel0_fx_Qxy_process
000902 cf0d                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_process:
000903 2fba                      	mov r27, r26 //copy fx parameters into r27
000904 70bf                      	andi r27, 0x0F //mask note index offset
000905 91c0 2807                 	lds r28, pulse1_note //load current note index
000907 0fbc                      	add r27, r28
000908 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
000909 f008                      	brlo sound_driver_channel0_fx_Qxy_process_continue
00090a e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel0_fx_Qxy_process_continue:
00090b e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
00090c e0f0                      	ldi ZH, HIGH(note_table << 1)
00090d 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
00090e 0feb                      	add ZL, r27 //add offset
00090f 1df2                      	adc ZH, zero
000910 91c5                      	lpm r28, Z+ //load bytes
000911 91d4                      	lpm r29, Z
000912 93c0 2863                 	sts pulse1_fx_Qxy_target, r28 //load the LOW bits for the target period
000914 93d0 2864                 	sts pulse1_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
000916 95a2                      	swap r26
000917 70af                      	andi r26, 0x0F //mask effect speed
000918 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
000919 95a3                      	inc r26 //increment the speed by 1
                                 
00091a 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00091b 937f                      	push r23
00091c 2f6a                      	mov r22, r26 //store the speed data into r27
00091d eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00091e 9f67                      	mul r22, r23
00091f 917f                      	pop r23
000920 916f                      	pop r22
                                 
000921 9416                      	lsr r1 //shift out the fractional bits
000922 9407                      	ror r0
000923 9416                      	lsr r1
000924 9407                      	ror r0
000925 9416                      	lsr r1
000926 9407                      	ror r0
000927 9416                      	lsr r1
000928 9407                      	ror r0
                                 
000929 9200 2865                 	sts pulse1_fx_Qxy_speed, r0 //store the effect speed
00092b 9210 2866                 	sts pulse1_fx_Qxy_speed+1, r1
00092d 9220 2867                 	sts pulse1_fx_Qxy_total_offset, zero
00092f 9220 2868                 	sts pulse1_fx_Qxy_total_offset+1, zero
000931 cede                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel0_fx_Rxy:
                                 sound_driver_channel0_fx_Rxy_check_arpeggio_macro:
000932 91e0 282d                 	lds ZL, pulse1_arpeggio_macro
000934 91f0 282e                 	lds ZH, pulse1_arpeggio_macro+1
000936 9630                      	adiw Z, 0
000937 f009                      	breq sound_driver_channel0_fx_Rxy_check_pitch_macro
000938 ced7                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_pitch_macro:
000939 91e0 2835                 	lds ZL, pulse1_pitch_macro
00093b 91f0 2836                 	lds ZH, pulse1_pitch_macro+1
00093d 9630                      	adiw Z, 0
00093e f009                      	breq sound_driver_channel0_fx_Rxy_check_hi_pitch_macro
00093f ced0                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_hi_pitch_macro:
000940 91e0 283b                 	lds ZL, pulse1_hi_pitch_macro
000942 91f0 283c                 	lds ZH, pulse1_hi_pitch_macro+1
000944 9630                      	adiw Z, 0
000945 f009                      	breq sound_driver_channel0_fx_Rxy_process
000946 cec9                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_process:
000947 2fba                      	mov r27, r26 //copy fx parameters into r27
000948 70bf                      	andi r27, 0x0F //mask note index offset
000949 91c0 2807                 	lds r28, pulse1_note //load current note index
00094b 1bcb                      	sub r28, r27
00094c f408                      	brcc sound_driver_channel0_fx_Rxy_process_continue
00094d e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel0_fx_Rxy_process_continue:
00094e e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
00094f e0f0                      	ldi ZH, HIGH(note_table << 1)
000950 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
000951 0fec                      	add ZL, r28 //add offset
000952 1df2                      	adc ZH, zero
000953 91c5                      	lpm r28, Z+ //load bytes
000954 91d4                      	lpm r29, Z
000955 93c0 2869                 	sts pulse1_fx_Rxy_target, r28 //load the LOW bits for the target period
000957 93d0 286a                 	sts pulse1_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
000959 95a2                      	swap r26
00095a 70af                      	andi r26, 0x0F //mask effect speed
00095b 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
00095c 95a3                      	inc r26 //increment the speed by 1
                                 
00095d 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00095e 937f                      	push r23
00095f 2f6a                      	mov r22, r26 //store the speed data into r27
000960 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
000961 9f67                      	mul r22, r23
000962 917f                      	pop r23
000963 916f                      	pop r22
                                 
000964 9416                      	lsr r1 //shift out the fractional bits
000965 9407                      	ror r0
000966 9416                      	lsr r1
000967 9407                      	ror r0
000968 9416                      	lsr r1
000969 9407                      	ror r0
00096a 9416                      	lsr r1
00096b 9407                      	ror r0
                                 
00096c 9200 286b                 	sts pulse1_fx_Rxy_speed, r0 //store the effect speed
00096e 9210 286c                 	sts pulse1_fx_Rxy_speed+1, r1
000970 9220 286d                 	sts pulse1_fx_Rxy_total_offset, zero
000972 9220 286e                 	sts pulse1_fx_Rxy_total_offset+1, zero
000974 ce9b                      	rjmp sound_driver_channel0_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel0_fx_Sxx:
000975 15a2                      	cp r26, zero
000976 f051                      	breq sound_driver_channel0_fx_Sxx_invalid
000977 91b0 281e                 	lds r27, song_speed
000979 17ab                      	cp r26, r27
00097a f430                      	brsh sound_driver_channel0_fx_Sxx_invalid
00097b 93a0 286f                 	sts pulse1_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
00097d e0b1                      	ldi r27, 0x01
00097e 93b0 2824                 	sts pulse1_pattern_delay_rows, r27
000980 c172                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Sxx_invalid:
000981 ce8e                      	rjmp sound_driver_channel0_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel0_fx_Vxx:
000982 e6ea                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
000983 e4f2                      	ldi ZH, HIGH(sequences << 1)
000984 0fea                      	add ZL, r26 //offset the pointer
000985 1df2                      	adc ZH, zero
                                 
000986 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
000987 95a7                      	ror r26
000988 95a7                      	ror r26
000989 91b0 2800                 	lds r27, pulse1_param //load r27 with pulse1_param (register $4000)
00098b 2fcb                      	mov r28, r27 //store a copy of pulse1_param into r28
00098c 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
00098d 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
00098e c001                      	rjmp sound_driver_channel0_fx_Vxx_store
00098f ce80                      	rjmp sound_driver_channel0_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel0_fx_Vxx_store:
000990 90a4                      	lpm pulse1_sequence, Z //store the sequence
                                 
000991 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
000992 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
000993 93c0 2800                 	sts pulse1_param, r28
000995 ce7a                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_Wxx: //DPCM sample speed
000996 ce79                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Xxx: //DPCM sample retrigger
000997 ce78                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Yxx: //DPCM sample offset
000998 ce77                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Zxx: //DPCM sample delta counter
000999 ce76                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 sound_driver_channel0_note:
00099a 93b0 2807                 	sts pulse1_note, r27 //store the note index
00099c e0a3                      	ldi r26, 0x03
00099d e0b2                      	ldi r27, 0x02
00099e 93b0 282a                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
0009a0 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26
0009a2 93b0 2837                 	sts pulse1_pitch_macro_offset, r27
0009a4 93b0 283d                 	sts pulse1_hi_pitch_macro_offset, r27
0009a6 93b0 2842                 	sts pulse1_duty_macro_offset, r27
0009a8 9220 2833                 	sts pulse1_total_pitch_offset, zero //reset the pitch and hi pitch offset
0009aa 9220 2834                 	sts pulse1_total_pitch_offset+1, zero
0009ac 9220 283a                 	sts pulse1_total_hi_pitch_offset, zero
0009ae 9220 2849                 	sts pulse1_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
0009b0 9220 284a                 	sts pulse1_fx_1xx_total+1, zero
0009b2 9220 284d                 	sts pulse1_fx_2xx_total, zero
0009b4 9220 284e                 	sts pulse1_fx_2xx_total+1, zero
0009b6 9220 2855                 	sts pulse1_fx_3xx_total_offset, zero //reset 3xx offset
0009b8 9220 2856                 	sts pulse1_fx_3xx_total_offset+1, zero
0009ba 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
0009bc 91b0 0a8d                 	lds r27, TCB0_CCMPH
0009be 93a0 284f                 	sts pulse1_fx_3xx_start, r26
0009c0 93b0 2850                 	sts pulse1_fx_3xx_start+1, r27
0009c2 9220 2801                 	sts pulse1_sweep_param, zero //reset any sweep effect
0009c4 6097                      	sbr pulse_channel_flags, 7 //set reload flag
0009c5 9220 2863                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0009c7 9220 2864                 	sts pulse1_fx_Qxy_target+1, zero
0009c9 9220 2867                 	sts pulse1_fx_Qxy_total_offset, zero
0009cb 9220 2868                 	sts pulse1_fx_Qxy_total_offset+1, zero
0009cd 9220 2869                 	sts pulse1_fx_Rxy_target, zero
0009cf 9220 286a                 	sts pulse1_fx_Rxy_target+1, zero
0009d1 9220 286d                 	sts pulse1_fx_Rxy_total_offset, zero
0009d3 9220 286e                 	sts pulse1_fx_Rxy_total_offset+1, zero
0009d5 d106                      	rcall sound_driver_channel0_increment_offset
0009d6 ce39                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_volume:
0009d7 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
0009d8 91a0 2800                 	lds r26, pulse1_param
0009da 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
0009db 2bab                      	or r26, r27 //move new VVVV bits into pulse1_param
0009dc 93a0 2800                 	sts pulse1_param, r26
0009de 6096                      	sbr pulse_channel_flags, 6
0009df d0fc                      	rcall sound_driver_channel0_increment_offset
0009e0 ce2f                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_delay:
0009e1 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
0009e2 93b0 2824                 	sts pulse1_pattern_delay_rows, r27
0009e4 d0f7                      	rcall sound_driver_channel0_increment_offset
0009e5 c10d                      	rjmp sound_driver_channel1
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change:
0009e6 9220 2828                 	sts pulse1_volume_macro, zero //reset all macro addresses
0009e8 9220 2829                 	sts pulse1_volume_macro+1, zero
0009ea 9220 282d                 	sts pulse1_arpeggio_macro, zero
0009ec 9220 282e                 	sts pulse1_arpeggio_macro+1, zero
0009ee 9220 2835                 	sts pulse1_pitch_macro, zero
0009f0 9220 2836                 	sts pulse1_pitch_macro+1, zero
0009f2 9220 283b                 	sts pulse1_hi_pitch_macro, zero
0009f4 9220 283c                 	sts pulse1_hi_pitch_macro+1, zero
0009f6 9220 2840                 	sts pulse1_duty_macro, zero
0009f8 9220 2841                 	sts pulse1_duty_macro+1, zero
0009fa 9220 2833                 	sts pulse1_total_pitch_offset, zero //reset the pitch offset
0009fc 9220 2834                 	sts pulse1_total_pitch_offset+1, zero
0009fe 9220 283a                 	sts pulse1_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
000a00 9631                      	adiw Z, 1 //point to the byte next to the flag
000a01 91b4                      	lpm r27, Z //store the instrument offset into r27
000a02 edea                      	ldi ZL, LOW(instruments) //point Z to instruments table
000a03 e0f1                      	ldi ZH, HIGH(instruments)
000a04 0feb                      	add ZL, r27 //point Z to offsetted instrument
000a05 1df2                      	adc ZH, zero
000a06 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
000a07 1fff                      	rol ZH
000a08 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
000a09 91b4                      	lpm r27, Z
                                 
000a0a 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
000a0b 1fbb                      	rol r27
000a0c 2fea                      	mov ZL, r26
000a0d 2ffb                      	mov ZH, r27
000a0e 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
000a0f 9632                      	adiw Z, 2 //point Z to the address of the macro
000a10 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel0_instrument_change_macro_loop:
000a11 95aa                      	dec r26
000a12 f019                      	breq sound_driver_channel0_instrument_change_exit
000a13 95b6                      	lsr r27
000a14 f078                      	brcs sound_driver_channel0_instrument_change_load_macro
000a15 cffb                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_exit:
000a16 e0a3                      	ldi r26, 0x03
000a17 e0b2                      	ldi r27, 0x02
000a18 93b0 282a                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
000a1a 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26
000a1c 93b0 2837                 	sts pulse1_pitch_macro_offset, r27
000a1e 93b0 283d                 	sts pulse1_hi_pitch_macro_offset, r27
000a20 93b0 2842                 	sts pulse1_duty_macro_offset, r27
000a22 d0c3                      	rcall sound_driver_channel0_increment_offset_twice
000a23 cdec                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_load_macro:
000a24 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
000a25 91d5                      	lpm r29, Z+
                                 
000a26 30a5                      	cpi r26, 5
000a27 f039                      	breq sound_driver_channel0_instrument_change_load_macro_volume
000a28 30a4                      	cpi r26, 4
000a29 f079                      	breq sound_driver_channel0_instrument_change_load_macro_arpeggio
000a2a 30a3                      	cpi r26, 3
000a2b f0d9                      	breq sound_driver_channel0_instrument_change_load_macro_pitch
000a2c 30a2                      	cpi r26, 2
000a2d f159                      	breq sound_driver_channel0_instrument_change_load_macro_hi_pitch
000a2e c03c                      	rjmp sound_driver_channel0_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel0_instrument_change_load_macro_volume:
000a2f 93c0 2828                 	sts pulse1_volume_macro, r28
000a31 93d0 2829                 	sts pulse1_volume_macro+1, r29
000a33 d041                      	rcall sound_driver_channel0_instrument_change_read_header
000a34 93c0 282c                 	sts pulse1_volume_macro_release, r28
000a36 93d0 282b                 	sts pulse1_volume_macro_loop, r29
000a38 cfd8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 	
                                 sound_driver_channel0_instrument_change_load_macro_arpeggio:
000a39 93c0 282d                 	sts pulse1_arpeggio_macro, r28
000a3b 93d0 282e                 	sts pulse1_arpeggio_macro+1, r29
000a3d 9220 2863                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
000a3f 9220 2864                 	sts pulse1_fx_Qxy_target+1, zero
000a41 9220 2869                 	sts pulse1_fx_Rxy_target, zero
000a43 9220 286a                 	sts pulse1_fx_Rxy_target+1, zero
000a45 d03a                      	rcall sound_driver_channel0_instrument_change_read_header_arpeggio
000a46 cfca                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_pitch:
000a47 93c0 2835                 	sts pulse1_pitch_macro, r28
000a49 93d0 2836                 	sts pulse1_pitch_macro+1, r29
000a4b 9220 2863                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
000a4d 9220 2864                 	sts pulse1_fx_Qxy_target+1, zero
000a4f 9220 2869                 	sts pulse1_fx_Rxy_target, zero
000a51 9220 286a                 	sts pulse1_fx_Rxy_target+1, zero
000a53 d021                      	rcall sound_driver_channel0_instrument_change_read_header
000a54 93c0 2839                 	sts pulse1_pitch_macro_release, r28
000a56 93d0 2838                 	sts pulse1_pitch_macro_loop, r29
000a58 cfb8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_hi_pitch:
000a59 93c0 283b                 	sts pulse1_hi_pitch_macro, r28
000a5b 93d0 283c                 	sts pulse1_hi_pitch_macro+1, r29
000a5d 9220 2863                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
000a5f 9220 2864                 	sts pulse1_fx_Qxy_target+1, zero
000a61 9220 2869                 	sts pulse1_fx_Rxy_target, zero
000a63 9220 286a                 	sts pulse1_fx_Rxy_target+1, zero
000a65 d00f                      	rcall sound_driver_channel0_instrument_change_read_header
000a66 93c0 283f                 	sts pulse1_hi_pitch_macro_release, r28
000a68 93d0 283e                 	sts pulse1_hi_pitch_macro_loop, r29
000a6a cfa6                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_duty:
000a6b 93c0 2840                 	sts pulse1_duty_macro, r28
000a6d 93d0 2841                 	sts pulse1_duty_macro+1, r29
000a6f d005                      	rcall sound_driver_channel0_instrument_change_read_header
000a70 93c0 2844                 	sts pulse1_duty_macro_release, r28
000a72 93d0 2843                 	sts pulse1_duty_macro_loop, r29
000a74 cf9c                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_read_header:
000a75 93ef                      	push ZL
000a76 93ff                      	push ZH
000a77 2fec                      	mov ZL, r28
000a78 2ffd                      	mov ZH, r29
000a79 0fee                      	lsl ZL
000a7a 1fff                      	rol ZH
000a7b 91c5                      	lpm r28, Z+
000a7c 91d4                      	lpm r29, Z
000a7d 91ff                      	pop ZH
000a7e 91ef                      	pop ZL
000a7f 9508                      	ret
                                 
                                 sound_driver_channel0_instrument_change_read_header_arpeggio:
000a80 93ef                      	push ZL
000a81 93ff                      	push ZH
000a82 2fec                      	mov ZL, r28
000a83 2ffd                      	mov ZH, r29
000a84 0fee                      	lsl ZL
000a85 1fff                      	rol ZH
000a86 91c5                      	lpm r28, Z+
000a87 91d5                      	lpm r29, Z+
000a88 93c0 2831                 	sts pulse1_arpeggio_macro_release, r28
000a8a 93d0 2830                 	sts pulse1_arpeggio_macro_loop, r29
000a8c 91c4                      	lpm r28, Z
000a8d 93c0 2832                 	sts pulse1_arpeggio_macro_mode, r28
000a8f 91ff                      	pop ZH
000a90 91ef                      	pop ZL
000a91 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel0_release:
                                 sound_driver_channel0_release_volume:
000a92 91b0 282c                 	lds r27, pulse1_volume_macro_release
000a94 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
000a95 f019                      	breq sound_driver_channel0_release_arpeggio //if the macro has no release flag, check the next macro
000a96 95b3                      	inc r27
000a97 93b0 282a                 	sts pulse1_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel0_release_arpeggio:
000a99 91b0 2831                 	lds r27, pulse1_arpeggio_macro_release
000a9b 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
000a9c f019                      	breq sound_driver_channel0_release_pitch
000a9d 95b3                      	inc r27
000a9e 93b0 282f                 	sts pulse1_arpeggio_macro_offset, r27
                                 sound_driver_channel0_release_pitch:
000aa0 91b0 2839                 	lds r27, pulse1_pitch_macro_release
000aa2 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
000aa3 f019                      	breq sound_driver_channel0_release_hi_pitch
000aa4 95b3                      	inc r27
000aa5 93b0 2837                 	sts pulse1_pitch_macro_offset, r27
                                 sound_driver_channel0_release_hi_pitch:
000aa7 91b0 283f                 	lds r27, pulse1_hi_pitch_macro_release
000aa9 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
000aaa f019                      	breq sound_driver_channel0_release_duty
000aab 95b3                      	inc r27
000aac 93b0 283d                 	sts pulse1_hi_pitch_macro_offset, r27
                                 sound_driver_channel0_release_duty:
000aae 91b0 2844                 	lds r27, pulse1_duty_macro_release
000ab0 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
000ab1 f019                      	breq sound_driver_channel0_release_exit
000ab2 95b3                      	inc r27
000ab3 93b0 2842                 	sts pulse1_duty_macro_offset, r27
                                 sound_driver_channel0_release_exit:
000ab5 d026                      	rcall sound_driver_channel0_increment_offset
000ab6 cd59                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_next_pattern:
000ab7 91e0 2818                 	lds ZL, song_frames
000ab9 91f0 2819                 	lds ZH, song_frames+1
000abb 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
000abd 91b0 281b                 	lds r27, song_frame_offset+1
000abf 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
000ac0 93a0 281a                 	sts song_frame_offset, r26
000ac2 93b0 281b                 	sts song_frame_offset+1, r27
                                 
000ac4 91c0 281c                 	lds r28, song_size
000ac6 91d0 281d                 	lds r29, song_size+1
000ac8 17ac                      	cp r26, r28
000ac9 07bd                      	cpc r27, r29
000aca f010                      	brlo sound_driver_channel0_next_pattern_exists
000acb 940c 211f                 	jmp sound_driver_exit
                                 
                                 sound_driver_channel0_next_pattern_exists:
000acd 0fea                      	add ZL, r26
000ace 1ffb                      	adc ZH, r27
                                 
000acf 91a5                      	lpm r26, Z+ //load the address of the next pattern
000ad0 91b4                      	lpm r27, Z
000ad1 0faa                      	lsl r26
000ad2 1fbb                      	rol r27
000ad3 93a0 2822                 	sts pulse1_pattern, r26
000ad5 93b0 2823                 	sts pulse1_pattern+1, r27
                                 
000ad7 9220 2826                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
000ad9 9220 2827                 	sts pulse1_pattern_offset+1, zero
000adb cd34                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_increment_offset:
000adc 91e0 2826                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
000ade 91f0 2827                 	lds ZH, pulse1_pattern_offset+1
000ae0 9631                      	adiw Z, 1
000ae1 93e0 2826                 	sts pulse1_pattern_offset, ZL
000ae3 93f0 2827                 	sts pulse1_pattern_offset+1, ZH
000ae5 9508                      	ret
                                 
                                 sound_driver_channel0_increment_offset_twice: //used for data that takes up 2 bytes worth of space
000ae6 91e0 2826                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
000ae8 91f0 2827                 	lds ZH, pulse1_pattern_offset+1
000aea 9632                      	adiw Z, 2 //increment the pointer twice
000aeb 93e0 2826                 	sts pulse1_pattern_offset, ZL
000aed 93f0 2827                 	sts pulse1_pattern_offset+1, ZH
000aef 9508                      	ret
                                 
                                 sound_driver_channel0_decrement_frame_delay:
000af0 95ba                      	dec r27
000af1 93b0 2825                 	sts pulse1_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel1:
000af3 91a0 2873                 	lds r26, pulse2_pattern_delay_rows
000af5 91b0 2874                 	lds r27, pulse2_pattern_delay_frames
000af7 9610                      	adiw r27:r26, 0
000af8 f009                      	breq sound_driver_channel1_main //if the pattern delay is 0, proceed with sound driver procedures
000af9 c2d3                      	rjmp sound_driver_channel1_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel1_main:
000afa 91e0 2871                 	lds ZL, pulse2_pattern //current pattern for pulse 2
000afc 91f0 2872                 	lds ZH, pulse2_pattern+1
000afe 91a0 2875                 	lds r26, pulse2_pattern_offset //current offset in the pattern for pulse 2
000b00 91b0 2876                 	lds r27, pulse2_pattern_offset+1
000b02 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
000b03 1ffb                      	adc ZH, r27
000b04 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel1_check_if_note: //check if data is a note (0x00 - 0x56)
000b05 35b7                      	cpi r27, 0x57
000b06 f408                      	brsh sound_driver_channel1_check_if_volume
000b07 c17c                      	rjmp sound_driver_channel1_note
                                 sound_driver_channel1_check_if_volume: //check if data is volume (0x57-0x66)
000b08 36b7                      	cpi r27, 0x67
000b09 f408                      	brsh sound_driver_channel1_check_if_delay
000b0a c1b6                      	rjmp sound_driver_channel1_volume
                                 sound_driver_channel1_check_if_delay: //check if data is a delay (0x67 - 0xE2)
000b0b 3eb3                      	cpi r27, 0xE3
000b0c f408                      	brsh sound_driver_channel1_check_if_instrument
000b0d c1bd                      	rjmp sound_driver_channel1_delay
                                 sound_driver_channel1_check_if_instrument: //check for instrument flag (0xE3)
000b0e f409                      	brne sound_driver_channel1_check_if_release
000b0f c1c0                      	rjmp sound_driver_channel1_instrument_change 
                                 sound_driver_channel1_check_if_release: //check for note release flag (0xE4)
000b10 3eb4                      	cpi r27, 0xE4
000b11 f409                      	brne sound_driver_channel1_check_if_end
000b12 c269                      	rjmp sound_driver_channel1_release
                                 sound_driver_channel1_check_if_end:
000b13 3fbf                      	cpi r27, 0xFF
000b14 f409                      	brne sound_driver_channel1_check_if_fx
000b15 c28b                      	rjmp sound_driver_channel1_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel1_check_if_fx: //fx flags (0xE5 - 0xFE)
000b16 9631                      	adiw Z, 1 //point Z to the byte next to the flag
000b17 91a4                      	lpm r26, Z //load the fx data into r26
000b18 d2aa                      	rcall sound_driver_channel1_increment_offset_twice
                                 
000b19 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
000b1a eae2                      	ldi ZL, LOW(channel1_fx << 1) //load in note table
000b1b e4f2                      	ldi ZH, HIGH(channel1_fx << 1)
000b1c 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
000b1d 0feb                      	add ZL, r27 //add offset
000b1e 1df2                      	adc ZH, zero
000b1f 91c5                      	lpm r28, Z+ //load address bytes
000b20 91d4                      	lpm r29, Z
000b21 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
000b22 2ffd                      	mov ZH, r29
000b23 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel1_fx_0xy:
000b24 93a0 2894                 	sts pulse2_fx_0xy_sequence, r26
000b26 9220 2895                 	sts pulse2_fx_0xy_sequence+1, zero
000b28 cfd1                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel1_fx_1xx:
000b29 9220 289a                 	sts pulse2_fx_2xx, zero //turn off any 2xx pitch slide down
000b2b 9220 289b                 	sts pulse2_fx_2xx+1, zero
000b2d 9220 2894                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
000b2f 9220 2895                 	sts pulse2_fx_0xy_sequence+1, zero
000b31 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
000b32 937f                      	push r23
000b33 2f6a                      	mov r22, r26 //store the rate into r22
000b34 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
000b35 9f67                      	mul r22, r23
000b36 917f                      	pop r23
000b37 916f                      	pop r22
                                 
000b38 9416                      	lsr r1 //shift out the fractional bits
000b39 9407                      	ror r0
000b3a 9416                      	lsr r1
000b3b 9407                      	ror r0
000b3c 9416                      	lsr r1
000b3d 9407                      	ror r0
000b3e 9416                      	lsr r1
000b3f 9407                      	ror r0
000b40 9200 2896                 	sts pulse2_fx_1xx, r0
000b42 9210 2897                 	sts pulse2_fx_1xx+1, r1
000b44 cfb5                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel1_fx_2xx:
000b45 9220 2896                 	sts pulse2_fx_1xx, zero //turn off any 1xx pitch slide down
000b47 9220 2897                 	sts pulse2_fx_1xx+1, zero
000b49 9220 2894                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
000b4b 9220 2895                 	sts pulse2_fx_0xy_sequence+1, zero
000b4d 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
000b4e 937f                      	push r23
000b4f 2f6a                      	mov r22, r26 //store the rate into r22
000b50 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
000b51 9f67                      	mul r22, r23
000b52 917f                      	pop r23
000b53 916f                      	pop r22
                                 
000b54 9416                      	lsr r1 //shift out the fractional bits
000b55 9407                      	ror r0
000b56 9416                      	lsr r1
000b57 9407                      	ror r0
000b58 9416                      	lsr r1
000b59 9407                      	ror r0
000b5a 9416                      	lsr r1
000b5b 9407                      	ror r0
000b5c 9200 289a                 	sts pulse2_fx_2xx, r0
000b5e 9210 289b                 	sts pulse2_fx_2xx+1, r1
000b60 cf99                      	rjmp sound_driver_channel1_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel1_fx_3xx:
000b61 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
000b62 937f                      	push r23
000b63 2f6a                      	mov r22, r26 //store the rate into r22
000b64 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
000b65 9f67                      	mul r22, r23
000b66 917f                      	pop r23
000b67 916f                      	pop r22
                                 
000b68 9416                      	lsr r1 //shift out the fractional bits
000b69 9407                      	ror r0
000b6a 9416                      	lsr r1
000b6b 9407                      	ror r0
000b6c 9416                      	lsr r1
000b6d 9407                      	ror r0
000b6e 9416                      	lsr r1
000b6f 9407                      	ror r0
000b70 9200 28a2                 	sts pulse2_fx_3xx_speed, r0
000b72 9210 28a3                 	sts pulse2_fx_3xx_speed+1, r1
                                 
000b74 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
000b75 c001                      	rjmp sound_driver_channel1_fx_3xx_enabled
000b76 cf83                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_3xx_enabled:
000b77 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
000b79 91b0 0a9d                 	lds r27, TCB1_CCMPH
000b7b 93a0 289e                 	sts pulse2_fx_3xx_start, r26
000b7d 93b0 289f                 	sts pulse2_fx_3xx_start+1, r27
                                 
000b7f 9220 28a4                 	sts pulse2_fx_3xx_total_offset, zero
000b81 9220 28a5                 	sts pulse2_fx_3xx_total_offset+1, zero
000b83 cf76                      	rjmp sound_driver_channel1_main
                                 
                                 //VIBRATO
                                 sound_driver_channel1_fx_4xy:
000b84 2fba                      	mov r27, r26
000b85 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
000b86 95a2                      	swap r26
000b87 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
000b88 93a0 28a6                 	sts pulse2_fx_4xy_speed, r26
000b8a 93b0 28a7                 	sts pulse2_fx_4xy_depth, r27
000b8c 9220 28a8                 	sts pulse2_fx_4xy_phase, zero //reset the phase to 0
000b8e cf6b                      	rjmp sound_driver_channel1_main
                                 
                                 //TREMELO
                                 sound_driver_channel1_fx_7xy:
000b8f 2fba                      	mov r27, r26
000b90 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
000b91 95a2                      	swap r26
000b92 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
000b93 93a0 28a9                 	sts pulse2_fx_7xy_speed, r26
000b95 93b0 28aa                 	sts pulse2_fx_7xy_depth, r27
000b97 9220 28ab                 	sts pulse2_fx_7xy_phase, zero //reset the phase to 0
000b99 9220 28ac                 	sts pulse2_fx_7xy_value, zero //reset the tremelo value
000b9b cf5e                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel1_fx_Axy:
000b9c 93a0 28ad                 	sts pulse2_fx_Axy, r26
000b9e cf5b                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel1_fx_Bxx:
000b9f 93a0 281f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
000ba1 cf58                      	rjmp sound_driver_channel1_main
                                 
                                 //HALT
                                 sound_driver_channel1_fx_Cxx:
000ba2 93b0 2820                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
000ba4 cf55                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel1_fx_Dxx:
000ba5 93b0 2821                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
000ba7 cf52                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME
                                 sound_driver_channel1_fx_Exx:
000ba8 91b0 2808                 	lds r27, pulse2_param
000baa 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
000bab 2bba                      	or r27, r26 //move new VVVV bits into pulse2_param
000bac 93b0 2808                 	sts pulse2_param, r27
000bae 6092                      	sbr pulse_channel_flags, 2
000baf cf4a                      	rjmp sound_driver_channel1_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel1_fx_Fxx:
000bb0 93a0 281e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
000bb2 cf47                      	rjmp sound_driver_channel1_main
                                 
                                 //DELAY
                                 sound_driver_channel1_fx_Gxx:
000bb3 15a2                      	cp r26, zero
000bb4 f051                      	breq sound_driver_channel1_fx_Gxx_invalid
000bb5 91b0 281e                 	lds r27, song_speed
000bb7 17ab                      	cp r26, r27
000bb8 f430                      	brsh sound_driver_channel1_fx_Gxx_invalid
000bb9 93a0 28ae                 	sts pulse2_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
000bbb e0b1                      	ldi r27, 0x01
000bbc 93b0 2873                 	sts pulse2_pattern_delay_rows, r27
000bbe c211                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Gxx_invalid:
000bbf cf3a                      	rjmp sound_driver_channel1_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel1_fx_Hxy: //hardware sweep up
000bc0 cf39                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixy: //hardware sweep down
000bc1 cf38                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Hxx: //FDS modulation depth
000bc2 cf37                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixx: //FDS modulation speed
000bc3 cf36                      	rjmp sound_driver_channel1_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel1_fx_Pxx:
000bc4 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
000bc5 937f                      	push r23
000bc6 2f6a                      	mov r22, r26
000bc7 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
000bc8 0367                      	mulsu r22, r23
000bc9 917f                      	pop r23
000bca 916f                      	pop r22
000bcb 9416                      	lsr r1 //shift out the fractional bits
000bcc 9407                      	ror r0
000bcd 9416                      	lsr r1
000bce 9407                      	ror r0
000bcf 9416                      	lsr r1
000bd0 9407                      	ror r0
000bd1 9416                      	lsr r1
000bd2 9407                      	ror r0
000bd3 9200 28b0                 	sts pulse2_fx_Pxx_total, r0
000bd5 9210 28b1                 	sts pulse2_fx_Pxx_total+1, r1
000bd7 cf22                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel1_fx_Qxy:
                                 sound_driver_channel1_fx_Qxy_check_arpeggio_macro:
000bd8 91e0 287c                 	lds ZL, pulse2_arpeggio_macro
000bda 91f0 287d                 	lds ZH, pulse2_arpeggio_macro+1
000bdc 9630                      	adiw Z, 0
000bdd f009                      	breq sound_driver_channel1_fx_Qxy_check_pitch_macro
000bde cf1b                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_pitch_macro:
000bdf 91e0 2884                 	lds ZL, pulse2_pitch_macro
000be1 91f0 2885                 	lds ZH, pulse2_pitch_macro+1
000be3 9630                      	adiw Z, 0
000be4 f009                      	breq sound_driver_channel1_fx_Qxy_check_hi_pitch_macro
000be5 cf14                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_hi_pitch_macro:
000be6 91e0 288a                 	lds ZL, pulse2_hi_pitch_macro
000be8 91f0 288b                 	lds ZH, pulse2_hi_pitch_macro+1
000bea 9630                      	adiw Z, 0
000beb f009                      	breq sound_driver_channel1_fx_Qxy_process
000bec cf0d                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_process:
000bed 2fba                      	mov r27, r26 //copy fx parameters into r27
000bee 70bf                      	andi r27, 0x0F //mask note index offset
000bef 91c0 280f                 	lds r28, pulse2_note //load current note index
000bf1 0fbc                      	add r27, r28
000bf2 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
000bf3 f008                      	brlo sound_driver_channel1_fx_Qxy_process_continue
000bf4 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel1_fx_Qxy_process_continue:
000bf5 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
000bf6 e0f0                      	ldi ZH, HIGH(note_table << 1)
000bf7 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
000bf8 0feb                      	add ZL, r27 //add offset
000bf9 1df2                      	adc ZH, zero
000bfa 91c5                      	lpm r28, Z+ //load bytes
000bfb 91d4                      	lpm r29, Z
000bfc 93c0 28b2                 	sts pulse2_fx_Qxy_target, r28 //load the LOW bits for the target period
000bfe 93d0 28b3                 	sts pulse2_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
000c00 95a2                      	swap r26
000c01 70af                      	andi r26, 0x0F //mask effect speed
000c02 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
000c03 95a3                      	inc r26 //increment the speed by 1
                                 
000c04 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
000c05 937f                      	push r23
000c06 2f6a                      	mov r22, r26 //store the speed data into r27
000c07 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
000c08 9f67                      	mul r22, r23
000c09 917f                      	pop r23
000c0a 916f                      	pop r22
                                 
000c0b 9416                      	lsr r1 //shift out the fractional bits
000c0c 9407                      	ror r0
000c0d 9416                      	lsr r1
000c0e 9407                      	ror r0
000c0f 9416                      	lsr r1
000c10 9407                      	ror r0
000c11 9416                      	lsr r1
000c12 9407                      	ror r0
                                 
000c13 9200 28b4                 	sts pulse2_fx_Qxy_speed, r0 //store the effect speed
000c15 9210 28b5                 	sts pulse2_fx_Qxy_speed+1, r1
000c17 9220 28b6                 	sts pulse2_fx_Qxy_total_offset, zero
000c19 9220 28b7                 	sts pulse2_fx_Qxy_total_offset+1, zero
000c1b cede                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel1_fx_Rxy:
                                 sound_driver_channel1_fx_Rxy_check_arpeggio_macro:
000c1c 91e0 287c                 	lds ZL, pulse2_arpeggio_macro
000c1e 91f0 287d                 	lds ZH, pulse2_arpeggio_macro+1
000c20 9630                      	adiw Z, 0
000c21 f009                      	breq sound_driver_channel1_fx_Rxy_check_pitch_macro
000c22 ced7                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_pitch_macro:
000c23 91e0 2884                 	lds ZL, pulse2_pitch_macro
000c25 91f0 2885                 	lds ZH, pulse2_pitch_macro+1
000c27 9630                      	adiw Z, 0
000c28 f009                      	breq sound_driver_channel1_fx_Rxy_check_hi_pitch_macro
000c29 ced0                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_hi_pitch_macro:
000c2a 91e0 288a                 	lds ZL, pulse2_hi_pitch_macro
000c2c 91f0 288b                 	lds ZH, pulse2_hi_pitch_macro+1
000c2e 9630                      	adiw Z, 0
000c2f f009                      	breq sound_driver_channel1_fx_Rxy_process
000c30 cec9                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_process:
000c31 2fba                      	mov r27, r26 //copy fx parameters into r27
000c32 70bf                      	andi r27, 0x0F //mask note index offset
000c33 91c0 280f                 	lds r28, pulse2_note //load current note index
000c35 1bcb                      	sub r28, r27
000c36 f408                      	brcc sound_driver_channel1_fx_Rxy_process_continue
000c37 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel1_fx_Rxy_process_continue:
000c38 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
000c39 e0f0                      	ldi ZH, HIGH(note_table << 1)
000c3a 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
000c3b 0fec                      	add ZL, r28 //add offset
000c3c 1df2                      	adc ZH, zero
000c3d 91c5                      	lpm r28, Z+ //load bytes
000c3e 91d4                      	lpm r29, Z
000c3f 93c0 28b8                 	sts pulse2_fx_Rxy_target, r28 //load the LOW bits for the target period
000c41 93d0 28b9                 	sts pulse2_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
000c43 95a2                      	swap r26
000c44 70af                      	andi r26, 0x0F //mask effect speed
000c45 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
000c46 95a3                      	inc r26 //increment the speed by 1
                                 
000c47 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
000c48 937f                      	push r23
000c49 2f6a                      	mov r22, r26 //store the speed data into r27
000c4a eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
000c4b 9f67                      	mul r22, r23
000c4c 917f                      	pop r23
000c4d 916f                      	pop r22
                                 
000c4e 9416                      	lsr r1 //shift out the fractional bits
000c4f 9407                      	ror r0
000c50 9416                      	lsr r1
000c51 9407                      	ror r0
000c52 9416                      	lsr r1
000c53 9407                      	ror r0
000c54 9416                      	lsr r1
000c55 9407                      	ror r0
                                 
000c56 9200 28ba                 	sts pulse2_fx_Rxy_speed, r0 //store the effect speed
000c58 9210 28bb                 	sts pulse2_fx_Rxy_speed+1, r1
000c5a 9220 28bc                 	sts pulse2_fx_Rxy_total_offset, zero
000c5c 9220 28bd                 	sts pulse2_fx_Rxy_total_offset+1, zero
000c5e ce9b                      	rjmp sound_driver_channel1_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel1_fx_Sxx:
000c5f 15a2                      	cp r26, zero
000c60 f051                      	breq sound_driver_channel1_fx_Sxx_invalid
000c61 91b0 281e                 	lds r27, song_speed
000c63 17ab                      	cp r26, r27
000c64 f430                      	brsh sound_driver_channel1_fx_Sxx_invalid
000c65 93a0 28be                 	sts pulse2_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
000c67 e0b1                      	ldi r27, 0x01
000c68 93b0 2873                 	sts pulse2_pattern_delay_rows, r27
000c6a c165                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Sxx_invalid:
000c6b ce8e                      	rjmp sound_driver_channel1_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel1_fx_Vxx:
000c6c e6ea                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
000c6d e4f2                      	ldi ZH, HIGH(sequences << 1)
000c6e 0fea                      	add ZL, r26 //offset the pointer
000c6f 1df2                      	adc ZH, zero
                                 
000c70 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
000c71 95a7                      	ror r26
000c72 95a7                      	ror r26
000c73 91b0 2808                 	lds r27, pulse2_param //load r27 with pulse2_param (register $4000)
000c75 2fcb                      	mov r28, r27 //store a copy of pulse2_param into r28
000c76 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
000c77 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
000c78 c001                      	rjmp sound_driver_channel1_fx_Vxx_store
000c79 ce80                      	rjmp sound_driver_channel1_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel1_fx_Vxx_store:
000c7a 90d4                      	lpm pulse2_sequence, Z //store the sequence
                                 
000c7b 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
000c7c 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
000c7d 93c0 2808                 	sts pulse2_param, r28
000c7f ce7a                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_Wxx: //DPCM sample speed
000c80 ce79                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Xxx: //DPCM sample retrigger
000c81 ce78                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Yxx: //DPCM sample offset
000c82 ce77                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Zxx: //DPCM sample delta counter
000c83 ce76                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 sound_driver_channel1_note:
000c84 93b0 280f                 	sts pulse2_note, r27 //store the note index
000c86 e0a3                      	ldi r26, 0x03
000c87 e0b2                      	ldi r27, 0x02
000c88 93b0 2879                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
000c8a 93a0 287e                 	sts pulse2_arpeggio_macro_offset, r26
000c8c 93b0 2886                 	sts pulse2_pitch_macro_offset, r27
000c8e 93b0 288c                 	sts pulse2_hi_pitch_macro_offset, r27
000c90 93b0 2891                 	sts pulse2_duty_macro_offset, r27
000c92 9220 2882                 	sts pulse2_total_pitch_offset, zero //reset the pitch and hi pitch offset
000c94 9220 2883                 	sts pulse2_total_pitch_offset+1, zero
000c96 9220 2889                 	sts pulse2_total_hi_pitch_offset, zero
000c98 9220 2898                 	sts pulse2_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
000c9a 9220 2899                 	sts pulse2_fx_1xx_total+1, zero
000c9c 9220 289c                 	sts pulse2_fx_2xx_total, zero
000c9e 9220 289d                 	sts pulse2_fx_2xx_total+1, zero
000ca0 9220 28a4                 	sts pulse2_fx_3xx_total_offset, zero //reset 3xx offset
000ca2 9220 28a5                 	sts pulse2_fx_3xx_total_offset+1, zero
000ca4 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
000ca6 91b0 0a9d                 	lds r27, TCB1_CCMPH
000ca8 93a0 289e                 	sts pulse2_fx_3xx_start, r26
000caa 93b0 289f                 	sts pulse2_fx_3xx_start+1, r27
000cac 9220 2809                 	sts pulse2_sweep_param, zero //reset any sweep effect
000cae 6093                      	sbr pulse_channel_flags, 3 //set reload flag
000caf 9220 28b2                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
000cb1 9220 28b3                 	sts pulse2_fx_Qxy_target+1, zero
000cb3 9220 28b6                 	sts pulse2_fx_Qxy_total_offset, zero
000cb5 9220 28b7                 	sts pulse2_fx_Qxy_total_offset+1, zero
000cb7 9220 28b8                 	sts pulse2_fx_Rxy_target, zero
000cb9 9220 28b9                 	sts pulse2_fx_Rxy_target+1, zero
000cbb 9220 28bc                 	sts pulse2_fx_Rxy_total_offset, zero
000cbd 9220 28bd                 	sts pulse2_fx_Rxy_total_offset+1, zero
000cbf d0f9                      	rcall sound_driver_channel1_increment_offset
000cc0 ce39                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_volume:
000cc1 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
000cc2 91a0 2808                 	lds r26, pulse2_param
000cc4 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
000cc5 2bab                      	or r26, r27 //move new VVVV bits into pulse2_param
000cc6 93a0 2808                 	sts pulse2_param, r26
000cc8 6092                      	sbr pulse_channel_flags, 2
000cc9 d0ef                      	rcall sound_driver_channel1_increment_offset
000cca ce2f                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_delay:
000ccb 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
000ccc 93b0 2873                 	sts pulse2_pattern_delay_rows, r27
000cce d0ea                      	rcall sound_driver_channel1_increment_offset
000ccf c100                      	rjmp sound_driver_channel2
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change:
000cd0 9220 2877                 	sts pulse2_volume_macro, zero //reset all macro addresses
000cd2 9220 2878                 	sts pulse2_volume_macro+1, zero
000cd4 9220 287c                 	sts pulse2_arpeggio_macro, zero
000cd6 9220 287d                 	sts pulse2_arpeggio_macro+1, zero
000cd8 9220 2884                 	sts pulse2_pitch_macro, zero
000cda 9220 2885                 	sts pulse2_pitch_macro+1, zero
000cdc 9220 288a                 	sts pulse2_hi_pitch_macro, zero
000cde 9220 288b                 	sts pulse2_hi_pitch_macro+1, zero
000ce0 9220 288f                 	sts pulse2_duty_macro, zero
000ce2 9220 2890                 	sts pulse2_duty_macro+1, zero
000ce4 9220 2882                 	sts pulse2_total_pitch_offset, zero //reset the pitch offset
000ce6 9220 2883                 	sts pulse2_total_pitch_offset+1, zero
000ce8 9220 2889                 	sts pulse2_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
000cea 9631                      	adiw Z, 1 //point to the byte next to the flag
000ceb 91b4                      	lpm r27, Z //store the instrument offset into r27
000cec edea                      	ldi ZL, LOW(instruments) //point Z to instruments table
000ced e0f1                      	ldi ZH, HIGH(instruments)
000cee 0feb                      	add ZL, r27 //point Z to offsetted instrument
000cef 1df2                      	adc ZH, zero
000cf0 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
000cf1 1fff                      	rol ZH
000cf2 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
000cf3 91b4                      	lpm r27, Z
                                 
000cf4 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
000cf5 1fbb                      	rol r27
000cf6 2fea                      	mov ZL, r26
000cf7 2ffb                      	mov ZH, r27
000cf8 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
000cf9 9632                      	adiw Z, 2 //point Z to the address of the macro
000cfa e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel1_instrument_change_macro_loop:
000cfb 95aa                      	dec r26
000cfc f019                      	breq sound_driver_channel1_instrument_change_exit
000cfd 95b6                      	lsr r27
000cfe f078                      	brcs sound_driver_channel1_instrument_change_load_macro
000cff cffb                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_exit:
000d00 e0a3                      	ldi r26, 0x03
000d01 e0b2                      	ldi r27, 0x02
000d02 93b0 2879                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
000d04 93a0 287e                 	sts pulse2_arpeggio_macro_offset, r26
000d06 93b0 2886                 	sts pulse2_pitch_macro_offset, r27
000d08 93b0 288c                 	sts pulse2_hi_pitch_macro_offset, r27
000d0a 93b0 2891                 	sts pulse2_duty_macro_offset, r27
000d0c d0b6                      	rcall sound_driver_channel1_increment_offset_twice
000d0d cdec                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_load_macro:
000d0e 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
000d0f 91d5                      	lpm r29, Z+
                                 
000d10 30a5                      	cpi r26, 5
000d11 f039                      	breq sound_driver_channel1_instrument_change_load_macro_volume
000d12 30a4                      	cpi r26, 4
000d13 f079                      	breq sound_driver_channel1_instrument_change_load_macro_arpeggio
000d14 30a3                      	cpi r26, 3
000d15 f0d9                      	breq sound_driver_channel1_instrument_change_load_macro_pitch
000d16 30a2                      	cpi r26, 2
000d17 f159                      	breq sound_driver_channel1_instrument_change_load_macro_hi_pitch
000d18 c03c                      	rjmp sound_driver_channel1_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel1_instrument_change_load_macro_volume:
000d19 93c0 2877                 	sts pulse2_volume_macro, r28
000d1b 93d0 2878                 	sts pulse2_volume_macro+1, r29
000d1d d041                      	rcall sound_driver_channel1_instrument_change_read_header
000d1e 93c0 287b                 	sts pulse2_volume_macro_release, r28
000d20 93d0 287a                 	sts pulse2_volume_macro_loop, r29
000d22 cfd8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 	
                                 sound_driver_channel1_instrument_change_load_macro_arpeggio:
000d23 93c0 287c                 	sts pulse2_arpeggio_macro, r28
000d25 93d0 287d                 	sts pulse2_arpeggio_macro+1, r29
000d27 9220 28b2                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
000d29 9220 28b3                 	sts pulse2_fx_Qxy_target+1, zero
000d2b 9220 28b8                 	sts pulse2_fx_Rxy_target, zero
000d2d 9220 28b9                 	sts pulse2_fx_Rxy_target+1, zero
000d2f d03a                      	rcall sound_driver_channel1_instrument_change_read_header_arpeggio
000d30 cfca                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_pitch:
000d31 93c0 2884                 	sts pulse2_pitch_macro, r28
000d33 93d0 2885                 	sts pulse2_pitch_macro+1, r29
000d35 9220 28b2                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
000d37 9220 28b3                 	sts pulse2_fx_Qxy_target+1, zero
000d39 9220 28b8                 	sts pulse2_fx_Rxy_target, zero
000d3b 9220 28b9                 	sts pulse2_fx_Rxy_target+1, zero
000d3d d021                      	rcall sound_driver_channel1_instrument_change_read_header
000d3e 93c0 2888                 	sts pulse2_pitch_macro_release, r28
000d40 93d0 2887                 	sts pulse2_pitch_macro_loop, r29
000d42 cfb8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_hi_pitch:
000d43 93c0 288a                 	sts pulse2_hi_pitch_macro, r28
000d45 93d0 288b                 	sts pulse2_hi_pitch_macro+1, r29
000d47 9220 28b2                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
000d49 9220 28b3                 	sts pulse2_fx_Qxy_target+1, zero
000d4b 9220 28b8                 	sts pulse2_fx_Rxy_target, zero
000d4d 9220 28b9                 	sts pulse2_fx_Rxy_target+1, zero
000d4f d00f                      	rcall sound_driver_channel1_instrument_change_read_header
000d50 93c0 288e                 	sts pulse2_hi_pitch_macro_release, r28
000d52 93d0 288d                 	sts pulse2_hi_pitch_macro_loop, r29
000d54 cfa6                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_duty:
000d55 93c0 288f                 	sts pulse2_duty_macro, r28
000d57 93d0 2890                 	sts pulse2_duty_macro+1, r29
000d59 d005                      	rcall sound_driver_channel1_instrument_change_read_header
000d5a 93c0 2893                 	sts pulse2_duty_macro_release, r28
000d5c 93d0 2892                 	sts pulse2_duty_macro_loop, r29
000d5e cf9c                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_read_header:
000d5f 93ef                      	push ZL
000d60 93ff                      	push ZH
000d61 2fec                      	mov ZL, r28
000d62 2ffd                      	mov ZH, r29
000d63 0fee                      	lsl ZL
000d64 1fff                      	rol ZH
000d65 91c5                      	lpm r28, Z+
000d66 91d4                      	lpm r29, Z
000d67 91ff                      	pop ZH
000d68 91ef                      	pop ZL
000d69 9508                      	ret
                                 
                                 sound_driver_channel1_instrument_change_read_header_arpeggio:
000d6a 93ef                      	push ZL
000d6b 93ff                      	push ZH
000d6c 2fec                      	mov ZL, r28
000d6d 2ffd                      	mov ZH, r29
000d6e 0fee                      	lsl ZL
000d6f 1fff                      	rol ZH
000d70 91c5                      	lpm r28, Z+
000d71 91d5                      	lpm r29, Z+
000d72 93c0 2880                 	sts pulse2_arpeggio_macro_release, r28
000d74 93d0 287f                 	sts pulse2_arpeggio_macro_loop, r29
000d76 91c4                      	lpm r28, Z
000d77 93c0 2881                 	sts pulse2_arpeggio_macro_mode, r28
000d79 91ff                      	pop ZH
000d7a 91ef                      	pop ZL
000d7b 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel1_release:
                                 sound_driver_channel1_release_volume:
000d7c 91b0 287b                 	lds r27, pulse2_volume_macro_release
000d7e 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
000d7f f019                      	breq sound_driver_channel1_release_arpeggio //if the macro has no release flag, check the next macro
000d80 95b3                      	inc r27
000d81 93b0 2879                 	sts pulse2_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel1_release_arpeggio:
000d83 91b0 2880                 	lds r27, pulse2_arpeggio_macro_release
000d85 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
000d86 f019                      	breq sound_driver_channel1_release_pitch
000d87 95b3                      	inc r27
000d88 93b0 287e                 	sts pulse2_arpeggio_macro_offset, r27
                                 sound_driver_channel1_release_pitch:
000d8a 91b0 2888                 	lds r27, pulse2_pitch_macro_release
000d8c 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
000d8d f019                      	breq sound_driver_channel1_release_hi_pitch
000d8e 95b3                      	inc r27
000d8f 93b0 2886                 	sts pulse2_pitch_macro_offset, r27
                                 sound_driver_channel1_release_hi_pitch:
000d91 91b0 288e                 	lds r27, pulse2_hi_pitch_macro_release
000d93 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
000d94 f019                      	breq sound_driver_channel1_release_duty
000d95 95b3                      	inc r27
000d96 93b0 288c                 	sts pulse2_hi_pitch_macro_offset, r27
                                 sound_driver_channel1_release_duty:
000d98 91b0 2893                 	lds r27, pulse2_duty_macro_release
000d9a 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
000d9b f019                      	breq sound_driver_channel1_release_exit
000d9c 95b3                      	inc r27
000d9d 93b0 2891                 	sts pulse2_duty_macro_offset, r27
                                 sound_driver_channel1_release_exit:
000d9f d019                      	rcall sound_driver_channel1_increment_offset
000da0 cd59                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_next_pattern:
000da1 91e0 2818                 	lds ZL, song_frames
000da3 91f0 2819                 	lds ZH, song_frames+1
000da5 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
000da7 91b0 281b                 	lds r27, song_frame_offset+1
000da9 9612                      	adiw r27:r26, 2 //offset for channel 1
000daa 0fea                      	add ZL, r26
000dab 1ffb                      	adc ZH, r27
                                 
000dac 91a5                      	lpm r26, Z+ //load the address of the next pattern
000dad 91b4                      	lpm r27, Z
000dae 0faa                      	lsl r26
000daf 1fbb                      	rol r27
000db0 93a0 2871                 	sts pulse2_pattern, r26
000db2 93b0 2872                 	sts pulse2_pattern+1, r27
                                 
000db4 9220 2875                 	sts pulse2_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
000db6 9220 2876                 	sts pulse2_pattern_offset+1, zero
000db8 cd41                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_increment_offset:
000db9 91e0 2875                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
000dbb 91f0 2876                 	lds ZH, pulse2_pattern_offset+1
000dbd 9631                      	adiw Z, 1
000dbe 93e0 2875                 	sts pulse2_pattern_offset, ZL
000dc0 93f0 2876                 	sts pulse2_pattern_offset+1, ZH
000dc2 9508                      	ret
                                 
                                 sound_driver_channel1_increment_offset_twice: //used for data that takes up 2 bytes worth of space
000dc3 91e0 2875                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
000dc5 91f0 2876                 	lds ZH, pulse2_pattern_offset+1
000dc7 9632                      	adiw Z, 2 //increment the pointer twice
000dc8 93e0 2875                 	sts pulse2_pattern_offset, ZL
000dca 93f0 2876                 	sts pulse2_pattern_offset+1, ZH
000dcc 9508                      	ret
                                 
                                 sound_driver_channel1_decrement_frame_delay:
000dcd 95ba                      	dec r27
000dce 93b0 2874                 	sts pulse2_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel2:
000dd0 91a0 28c2                 	lds r26, triangle_pattern_delay_rows
000dd2 91b0 28c3                 	lds r27, triangle_pattern_delay_frames
000dd4 9610                      	adiw r27:r26, 0
000dd5 f009                      	breq sound_driver_channel2_main //if the pattern delay is 0, proceed with sound driver procedures
000dd6 c2bb                      	rjmp sound_driver_channel2_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel2_main:
000dd7 91e0 28c0                 	lds ZL, triangle_pattern //current pattern for triangle
000dd9 91f0 28c1                 	lds ZH, triangle_pattern+1
000ddb 91a0 28c4                 	lds r26, triangle_pattern_offset //current offset in the pattern for triangle
000ddd 91b0 28c5                 	lds r27, triangle_pattern_offset+1
000ddf 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
000de0 1ffb                      	adc ZH, r27
000de1 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel2_check_if_note: //check if data is a note (0x00 - 0x56)
000de2 35b7                      	cpi r27, 0x57
000de3 f408                      	brsh sound_driver_channel2_check_if_volume
000de4 c160                      	rjmp sound_driver_channel2_note
                                 sound_driver_channel2_check_if_volume: //check if data is volume (0x57-0x66)
000de5 36b7                      	cpi r27, 0x67
000de6 f408                      	brsh sound_driver_channel2_check_if_delay
000de7 c19a                      	rjmp sound_driver_channel2_volume
                                 sound_driver_channel2_check_if_delay: //check if data is a delay (0x67 - 0xE2)
000de8 3eb3                      	cpi r27, 0xE3
000de9 f408                      	brsh sound_driver_channel2_check_if_instrument
000dea c1a5                      	rjmp sound_driver_channel2_delay
                                 sound_driver_channel2_check_if_instrument: //check for instrument flag (0xE3)
000deb f409                      	brne sound_driver_channel2_check_if_release
000dec c1a8                      	rjmp sound_driver_channel2_instrument_change 
                                 sound_driver_channel2_check_if_release: //check for note release flag (0xE4)
000ded 3eb4                      	cpi r27, 0xE4
000dee f409                      	brne sound_driver_channel2_check_if_end
000def c251                      	rjmp sound_driver_channel2_release
                                 sound_driver_channel2_check_if_end:
000df0 3fbf                      	cpi r27, 0xFF
000df1 f409                      	brne sound_driver_channel2_check_if_fx
000df2 c273                      	rjmp sound_driver_channel2_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel2_check_if_fx: //fx flags (0xE5 - 0xFE)
000df3 9631                      	adiw Z, 1 //point Z to the byte next to the flag
000df4 91a4                      	lpm r26, Z //load the fx data into r26
000df5 d292                      	rcall sound_driver_channel2_increment_offset_twice
                                 
000df6 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
000df7 ede6                      	ldi ZL, LOW(channel2_fx << 1) //load in note table
000df8 e4f2                      	ldi ZH, HIGH(channel2_fx << 1)
000df9 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
000dfa 0feb                      	add ZL, r27 //add offset
000dfb 1df2                      	adc ZH, zero
000dfc 91c5                      	lpm r28, Z+ //load address bytes
000dfd 91d4                      	lpm r29, Z
000dfe 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
000dff 2ffd                      	mov ZH, r29
000e00 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel2_fx_0xy:
000e01 93a0 28e3                 	sts triangle_fx_0xy_sequence, r26
000e03 9220 28e4                 	sts triangle_fx_0xy_sequence+1, zero
000e05 cfd1                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel2_fx_1xx:
000e06 9220 28e9                 	sts triangle_fx_2xx, zero //turn off any 2xx pitch slide down
000e08 9220 28ea                 	sts triangle_fx_2xx+1, zero
000e0a 9220 28e3                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
000e0c 9220 28e4                 	sts triangle_fx_0xy_sequence+1, zero
000e0e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
000e0f 937f                      	push r23
000e10 2f6a                      	mov r22, r26 //store the rate into r22
000e11 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
000e12 9f67                      	mul r22, r23
000e13 917f                      	pop r23
000e14 916f                      	pop r22
                                 
000e15 9416                      	lsr r1 //shift out the fractional bits
000e16 9407                      	ror r0
000e17 9416                      	lsr r1
000e18 9407                      	ror r0
000e19 9416                      	lsr r1
000e1a 9407                      	ror r0
000e1b 9416                      	lsr r1
000e1c 9407                      	ror r0
000e1d 9200 28e5                 	sts triangle_fx_1xx, r0
000e1f 9210 28e6                 	sts triangle_fx_1xx+1, r1
000e21 cfb5                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel2_fx_2xx:
000e22 9220 28e5                 	sts triangle_fx_1xx, zero //turn off any 1xx pitch slide down
000e24 9220 28e6                 	sts triangle_fx_1xx+1, zero
000e26 9220 28e3                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
000e28 9220 28e4                 	sts triangle_fx_0xy_sequence+1, zero
000e2a 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
000e2b 937f                      	push r23
000e2c 2f6a                      	mov r22, r26 //store the rate into r22
000e2d eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
000e2e 9f67                      	mul r22, r23
000e2f 917f                      	pop r23
000e30 916f                      	pop r22
                                 
000e31 9416                      	lsr r1 //shift out the fractional bits
000e32 9407                      	ror r0
000e33 9416                      	lsr r1
000e34 9407                      	ror r0
000e35 9416                      	lsr r1
000e36 9407                      	ror r0
000e37 9416                      	lsr r1
000e38 9407                      	ror r0
000e39 9200 28e9                 	sts triangle_fx_2xx, r0
000e3b 9210 28ea                 	sts triangle_fx_2xx+1, r1
000e3d cf99                      	rjmp sound_driver_channel2_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel2_fx_3xx:
000e3e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
000e3f 937f                      	push r23
000e40 2f6a                      	mov r22, r26 //store the rate into r22
000e41 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
000e42 9f67                      	mul r22, r23
000e43 917f                      	pop r23
000e44 916f                      	pop r22
                                 
000e45 9416                      	lsr r1 //shift out the fractional bits
000e46 9407                      	ror r0
000e47 9416                      	lsr r1
000e48 9407                      	ror r0
000e49 9416                      	lsr r1
000e4a 9407                      	ror r0
000e4b 9416                      	lsr r1
000e4c 9407                      	ror r0
000e4d 9200 28f1                 	sts triangle_fx_3xx_speed, r0
000e4f 9210 28f2                 	sts triangle_fx_3xx_speed+1, r1
                                 
000e51 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
000e52 c001                      	rjmp sound_driver_channel2_fx_3xx_enabled
000e53 cf83                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_3xx_enabled:
000e54 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
000e56 91b0 0aad                 	lds r27, TCB2_CCMPH
000e58 93a0 28ed                 	sts triangle_fx_3xx_start, r26
000e5a 93b0 28ee                 	sts triangle_fx_3xx_start+1, r27
                                 
000e5c 9220 28f3                 	sts triangle_fx_3xx_total_offset, zero
000e5e 9220 28f4                 	sts triangle_fx_3xx_total_offset+1, zero
000e60 cf76                      	rjmp sound_driver_channel2_main
                                 
                                 //VIBRATO
                                 sound_driver_channel2_fx_4xy:
000e61 2fba                      	mov r27, r26
000e62 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
000e63 95a2                      	swap r26
000e64 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
000e65 93a0 28f5                 	sts triangle_fx_4xy_speed, r26
000e67 93b0 28f6                 	sts triangle_fx_4xy_depth, r27
000e69 9220 28f7                 	sts triangle_fx_4xy_phase, zero //reset the phase to 0
000e6b cf6b                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_7xy: //tremelo
000e6c cf6a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Axy: //volume slide
000e6d cf69                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel2_fx_Bxx:
000e6e 93a0 281f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
000e70 cf66                      	rjmp sound_driver_channel2_main
                                 
                                 //HALT
                                 sound_driver_channel2_fx_Cxx:
000e71 93b0 2820                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
000e73 cf63                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel2_fx_Dxx:
000e74 93b0 2821                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
000e76 cf60                      	rjmp sound_driver_channel2_main
                                 
                                 //VOLUME
                                 sound_driver_channel2_fx_Exx:
000e77 15a2                      	cp r26, zero
000e78 f021                      	breq sound_driver_channel2_fx_Exx_disable
                                 sound_driver_channel2_fx_Exx_enable:
000e79 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
000e7a 93b0 0aa5                 	sts TCB2_INTCTRL, r27
000e7c cf5a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Exx_disable:
000e7d 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
000e7f 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
000e81 9220 0aad                 	sts TCB2_CCMPH, zero
000e83 cf53                      	rjmp sound_driver_channel2_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel2_fx_Fxx:
000e84 93a0 281e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
000e86 cf50                      	rjmp sound_driver_channel2_main
                                 
                                 //DELAY
                                 sound_driver_channel2_fx_Gxx:
000e87 15a2                      	cp r26, zero
000e88 f051                      	breq sound_driver_channel2_fx_Gxx_invalid
000e89 91b0 281e                 	lds r27, song_speed
000e8b 17ab                      	cp r26, r27
000e8c f430                      	brsh sound_driver_channel2_fx_Gxx_invalid
000e8d 93a0 28f8                 	sts triangle_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
000e8f e0b1                      	ldi r27, 0x01
000e90 93b0 28c2                 	sts triangle_pattern_delay_rows, r27
000e92 c202                      	rjmp sound_driver_channel3
                                 sound_driver_channel2_fx_Gxx_invalid:
000e93 cf43                      	rjmp sound_driver_channel2_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Hxy: //hardware sweep up
000e94 cf42                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixy: //hardware sweep down
000e95 cf41                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Hxx: //FDS modulation depth
000e96 cf40                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixx: //FDS modulation speed
000e97 cf3f                      	rjmp sound_driver_channel2_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel2_fx_Pxx:
000e98 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
000e99 937f                      	push r23
000e9a 2f6a                      	mov r22, r26
000e9b eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
000e9c 0367                      	mulsu r22, r23
000e9d 917f                      	pop r23
000e9e 916f                      	pop r22
000e9f 9416                      	lsr r1 //shift out the fractional bits
000ea0 9407                      	ror r0
000ea1 9416                      	lsr r1
000ea2 9407                      	ror r0
000ea3 9416                      	lsr r1
000ea4 9407                      	ror r0
000ea5 9416                      	lsr r1
000ea6 9407                      	ror r0
000ea7 9200 28fa                 	sts triangle_fx_Pxx_total, r0
000ea9 9210 28fb                 	sts triangle_fx_Pxx_total+1, r1
000eab cf2b                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel2_fx_Qxy:
                                 sound_driver_channel2_fx_Qxy_check_arpeggio_macro:
000eac 91e0 28cb                 	lds ZL, triangle_arpeggio_macro
000eae 91f0 28cc                 	lds ZH, triangle_arpeggio_macro+1
000eb0 9630                      	adiw Z, 0
000eb1 f009                      	breq sound_driver_channel2_fx_Qxy_check_pitch_macro
000eb2 cf24                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_pitch_macro:
000eb3 91e0 28d3                 	lds ZL, triangle_pitch_macro
000eb5 91f0 28d4                 	lds ZH, triangle_pitch_macro+1
000eb7 9630                      	adiw Z, 0
000eb8 f009                      	breq sound_driver_channel2_fx_Qxy_check_hi_pitch_macro
000eb9 cf1d                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_hi_pitch_macro:
000eba 91e0 28d9                 	lds ZL, triangle_hi_pitch_macro
000ebc 91f0 28da                 	lds ZH, triangle_hi_pitch_macro+1
000ebe 9630                      	adiw Z, 0
000ebf f009                      	breq sound_driver_channel2_fx_Qxy_process
000ec0 cf16                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_process:
000ec1 2fba                      	mov r27, r26 //copy fx parameters into r27
000ec2 70bf                      	andi r27, 0x0F //mask note index offset
000ec3 91c0 2812                 	lds r28, triangle_note //load current note index
000ec5 0fbc                      	add r27, r28
000ec6 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
000ec7 f008                      	brlo sound_driver_channel2_fx_Qxy_process_continue
000ec8 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel2_fx_Qxy_process_continue:
000ec9 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
000eca e0f0                      	ldi ZH, HIGH(note_table << 1)
000ecb 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
000ecc 0feb                      	add ZL, r27 //add offset
000ecd 1df2                      	adc ZH, zero
000ece 91c5                      	lpm r28, Z+ //load bytes
000ecf 91d4                      	lpm r29, Z
000ed0 93c0 28fc                 	sts triangle_fx_Qxy_target, r28 //load the LOW bits for the target period
000ed2 93d0 28fd                 	sts triangle_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
000ed4 95a2                      	swap r26
000ed5 70af                      	andi r26, 0x0F //mask effect speed
000ed6 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
000ed7 95a3                      	inc r26 //increment the speed by 1
                                 
000ed8 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
000ed9 937f                      	push r23
000eda 2f6a                      	mov r22, r26 //store the speed data into r27
000edb eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
000edc 9f67                      	mul r22, r23
000edd 917f                      	pop r23
000ede 916f                      	pop r22
                                 
000edf 9416                      	lsr r1 //shift out the fractional bits
000ee0 9407                      	ror r0
000ee1 9416                      	lsr r1
000ee2 9407                      	ror r0
000ee3 9416                      	lsr r1
000ee4 9407                      	ror r0
000ee5 9416                      	lsr r1
000ee6 9407                      	ror r0
                                 
000ee7 9200 28fe                 	sts triangle_fx_Qxy_speed, r0 //store the effect speed
000ee9 9210 28ff                 	sts triangle_fx_Qxy_speed+1, r1
000eeb 9220 2900                 	sts triangle_fx_Qxy_total_offset, zero
000eed 9220 2901                 	sts triangle_fx_Qxy_total_offset+1, zero
000eef cee7                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel2_fx_Rxy:
                                 sound_driver_channel2_fx_Rxy_check_arpeggio_macro:
000ef0 91e0 28cb                 	lds ZL, triangle_arpeggio_macro
000ef2 91f0 28cc                 	lds ZH, triangle_arpeggio_macro+1
000ef4 9630                      	adiw Z, 0
000ef5 f009                      	breq sound_driver_channel2_fx_Rxy_check_pitch_macro
000ef6 cee0                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_pitch_macro:
000ef7 91e0 28d3                 	lds ZL, triangle_pitch_macro
000ef9 91f0 28d4                 	lds ZH, triangle_pitch_macro+1
000efb 9630                      	adiw Z, 0
000efc f009                      	breq sound_driver_channel2_fx_Rxy_check_hi_pitch_macro
000efd ced9                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_hi_pitch_macro:
000efe 91e0 28d9                 	lds ZL, triangle_hi_pitch_macro
000f00 91f0 28da                 	lds ZH, triangle_hi_pitch_macro+1
000f02 9630                      	adiw Z, 0
000f03 f009                      	breq sound_driver_channel2_fx_Rxy_process
000f04 ced2                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_process:
000f05 2fba                      	mov r27, r26 //copy fx parameters into r27
000f06 70bf                      	andi r27, 0x0F //mask note index offset
000f07 91c0 2812                 	lds r28, triangle_note //load current note index
000f09 1bcb                      	sub r28, r27
000f0a f408                      	brcc sound_driver_channel2_fx_Rxy_process_continue
000f0b e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel2_fx_Rxy_process_continue:
000f0c e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
000f0d e0f0                      	ldi ZH, HIGH(note_table << 1)
000f0e 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
000f0f 0fec                      	add ZL, r28 //add offset
000f10 1df2                      	adc ZH, zero
000f11 91c5                      	lpm r28, Z+ //load bytes
000f12 91d4                      	lpm r29, Z
000f13 93c0 2902                 	sts triangle_fx_Rxy_target, r28 //load the LOW bits for the target period
000f15 93d0 2903                 	sts triangle_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
000f17 95a2                      	swap r26
000f18 70af                      	andi r26, 0x0F //mask effect speed
000f19 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
000f1a 95a3                      	inc r26 //increment the speed by 1
                                 
000f1b 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
000f1c 937f                      	push r23
000f1d 2f6a                      	mov r22, r26 //store the speed data into r27
000f1e eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
000f1f 9f67                      	mul r22, r23
000f20 917f                      	pop r23
000f21 916f                      	pop r22
                                 
000f22 9416                      	lsr r1 //shift out the fractional bits
000f23 9407                      	ror r0
000f24 9416                      	lsr r1
000f25 9407                      	ror r0
000f26 9416                      	lsr r1
000f27 9407                      	ror r0
000f28 9416                      	lsr r1
000f29 9407                      	ror r0
                                 
000f2a 9200 2904                 	sts triangle_fx_Rxy_speed, r0 //store the effect speed
000f2c 9210 2905                 	sts triangle_fx_Rxy_speed+1, r1
000f2e 9220 2906                 	sts triangle_fx_Rxy_total_offset, zero
000f30 9220 2907                 	sts triangle_fx_Rxy_total_offset+1, zero
000f32 cea4                      	rjmp sound_driver_channel2_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel2_fx_Sxx:
000f33 15a2                      	cp r26, zero
000f34 f051                      	breq sound_driver_channel2_fx_Sxx_invalid
000f35 91b0 281e                 	lds r27, song_speed
000f37 17ab                      	cp r26, r27
000f38 f430                      	brsh sound_driver_channel2_fx_Sxx_invalid
000f39 93a0 2908                 	sts triangle_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
000f3b e0b1                      	ldi r27, 0x01
000f3c 93b0 28c2                 	sts triangle_pattern_delay_rows, r27
000f3e c156                      	rjmp sound_driver_channel3
                                 sound_driver_channel2_fx_Sxx_invalid:
000f3f ce97                      	rjmp sound_driver_channel2_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Vxx: //duty
000f40 ce96                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Wxx: //DPCM sample speed
000f41 ce95                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Xxx: //DPCM sample retrigger
000f42 ce94                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Yxx: //DPCM sample offset
000f43 ce93                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Zxx: //DPCM sample delta counter
000f44 ce92                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 sound_driver_channel2_note:
000f45 93b0 2812                 	sts triangle_note, r27 //store the note index
000f47 e0a3                      	ldi r26, 0x03
000f48 e0b2                      	ldi r27, 0x02
000f49 93b0 28c8                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
000f4b 93a0 28cd                 	sts triangle_arpeggio_macro_offset, r26
000f4d 93b0 28d5                 	sts triangle_pitch_macro_offset, r27
000f4f 93b0 28db                 	sts triangle_hi_pitch_macro_offset, r27
000f51 93b0 28e0                 	sts triangle_duty_macro_offset, r27
000f53 9220 28d1                 	sts triangle_total_pitch_offset, zero //reset the pitch and hi pitch offset
000f55 9220 28d2                 	sts triangle_total_pitch_offset+1, zero
000f57 9220 28d8                 	sts triangle_total_hi_pitch_offset, zero
000f59 9220 28e7                 	sts triangle_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
000f5b 9220 28e8                 	sts triangle_fx_1xx_total+1, zero
000f5d 9220 28eb                 	sts triangle_fx_2xx_total, zero
000f5f 9220 28ec                 	sts triangle_fx_2xx_total+1, zero
000f61 9220 28f3                 	sts triangle_fx_3xx_total_offset, zero //reset 3xx offset
000f63 9220 28f4                 	sts triangle_fx_3xx_total_offset+1, zero
000f65 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
000f67 91b0 0aad                 	lds r27, TCB2_CCMPH
000f69 93a0 28ed                 	sts triangle_fx_3xx_start, r26
000f6b 93b0 28ee                 	sts triangle_fx_3xx_start+1, r27
000f6d 9220 28fc                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
000f6f 9220 28fd                 	sts triangle_fx_Qxy_target+1, zero
000f71 9220 2900                 	sts triangle_fx_Qxy_total_offset, zero
000f73 9220 2901                 	sts triangle_fx_Qxy_total_offset+1, zero
000f75 9220 2902                 	sts triangle_fx_Rxy_target, zero
000f77 9220 2903                 	sts triangle_fx_Rxy_target+1, zero
000f79 9220 2906                 	sts triangle_fx_Rxy_total_offset, zero
000f7b 9220 2907                 	sts triangle_fx_Rxy_total_offset+1, zero
000f7d e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
000f7e 93b0 0aa5                 	sts TCB2_INTCTRL, r27
000f80 d0fd                      	rcall sound_driver_channel2_increment_offset
000f81 ce55                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_volume:
000f82 d0fb                      	rcall sound_driver_channel2_increment_offset
000f83 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
000f84 f021                      	breq sound_driver_channel2_volume_disable
                                 sound_driver_channel2_volume_enable:
000f85 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
000f86 93b0 0aa5                 	sts TCB2_INTCTRL, r27
000f88 ce4e                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_volume_disable:
000f89 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
000f8b 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
000f8d 9220 0aad                 	sts TCB2_CCMPH, zero
000f8f ce47                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_delay:
000f90 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
000f91 93b0 28c2                 	sts triangle_pattern_delay_rows, r27
000f93 d0ea                      	rcall sound_driver_channel2_increment_offset
000f94 c100                      	rjmp sound_driver_channel3
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change:
000f95 9220 28c6                 	sts triangle_volume_macro, zero //reset all macro addresses
000f97 9220 28c7                 	sts triangle_volume_macro+1, zero
000f99 9220 28cb                 	sts triangle_arpeggio_macro, zero
000f9b 9220 28cc                 	sts triangle_arpeggio_macro+1, zero
000f9d 9220 28d3                 	sts triangle_pitch_macro, zero
000f9f 9220 28d4                 	sts triangle_pitch_macro+1, zero
000fa1 9220 28d9                 	sts triangle_hi_pitch_macro, zero
000fa3 9220 28da                 	sts triangle_hi_pitch_macro+1, zero
000fa5 9220 28de                 	sts triangle_duty_macro, zero
000fa7 9220 28df                 	sts triangle_duty_macro+1, zero
000fa9 9220 28d1                 	sts triangle_total_pitch_offset, zero //reset the pitch offset
000fab 9220 28d2                 	sts triangle_total_pitch_offset+1, zero
000fad 9220 28d8                 	sts triangle_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
000faf 9631                      	adiw Z, 1 //point to the byte next to the flag
000fb0 91b4                      	lpm r27, Z //store the instrument offset into r27
000fb1 edea                      	ldi ZL, LOW(instruments) //point Z to instruments table
000fb2 e0f1                      	ldi ZH, HIGH(instruments)
000fb3 0feb                      	add ZL, r27 //point Z to offsetted instrument
000fb4 1df2                      	adc ZH, zero
000fb5 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
000fb6 1fff                      	rol ZH
000fb7 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
000fb8 91b4                      	lpm r27, Z
                                 
000fb9 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
000fba 1fbb                      	rol r27
000fbb 2fea                      	mov ZL, r26
000fbc 2ffb                      	mov ZH, r27
000fbd 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
000fbe 9632                      	adiw Z, 2 //point Z to the address of the macro
000fbf e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel2_instrument_change_macro_loop:
000fc0 95aa                      	dec r26
000fc1 f019                      	breq sound_driver_channel2_instrument_change_exit
000fc2 95b6                      	lsr r27
000fc3 f078                      	brcs sound_driver_channel2_instrument_change_load_macro
000fc4 cffb                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_exit:
000fc5 e0a3                      	ldi r26, 0x03
000fc6 e0b2                      	ldi r27, 0x02
000fc7 93b0 28c8                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
000fc9 93a0 28cd                 	sts triangle_arpeggio_macro_offset, r26
000fcb 93b0 28d5                 	sts triangle_pitch_macro_offset, r27
000fcd 93b0 28db                 	sts triangle_hi_pitch_macro_offset, r27
000fcf 93b0 28e0                 	sts triangle_duty_macro_offset, r27
000fd1 d0b6                      	rcall sound_driver_channel2_increment_offset_twice
000fd2 ce04                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_load_macro:
000fd3 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
000fd4 91d5                      	lpm r29, Z+
                                 
000fd5 30a5                      	cpi r26, 5
000fd6 f039                      	breq sound_driver_channel2_instrument_change_load_macro_volume
000fd7 30a4                      	cpi r26, 4
000fd8 f079                      	breq sound_driver_channel2_instrument_change_load_macro_arpeggio
000fd9 30a3                      	cpi r26, 3
000fda f0d9                      	breq sound_driver_channel2_instrument_change_load_macro_pitch
000fdb 30a2                      	cpi r26, 2
000fdc f159                      	breq sound_driver_channel2_instrument_change_load_macro_hi_pitch
000fdd c03c                      	rjmp sound_driver_channel2_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel2_instrument_change_load_macro_volume:
000fde 93c0 28c6                 	sts triangle_volume_macro, r28
000fe0 93d0 28c7                 	sts triangle_volume_macro+1, r29
000fe2 d041                      	rcall sound_driver_channel2_instrument_change_read_header
000fe3 93c0 28ca                 	sts triangle_volume_macro_release, r28
000fe5 93d0 28c9                 	sts triangle_volume_macro_loop, r29
000fe7 cfd8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 	
                                 sound_driver_channel2_instrument_change_load_macro_arpeggio:
000fe8 93c0 28cb                 	sts triangle_arpeggio_macro, r28
000fea 93d0 28cc                 	sts triangle_arpeggio_macro+1, r29
000fec 9220 28fc                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
000fee 9220 28fd                 	sts triangle_fx_Qxy_target+1, zero
000ff0 9220 2902                 	sts triangle_fx_Rxy_target, zero
000ff2 9220 2903                 	sts triangle_fx_Rxy_target+1, zero
000ff4 d03a                      	rcall sound_driver_channel2_instrument_change_read_header_arpeggio
000ff5 cfca                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_pitch:
000ff6 93c0 28d3                 	sts triangle_pitch_macro, r28
000ff8 93d0 28d4                 	sts triangle_pitch_macro+1, r29
000ffa 9220 28fc                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
000ffc 9220 28fd                 	sts triangle_fx_Qxy_target+1, zero
000ffe 9220 2902                 	sts triangle_fx_Rxy_target, zero
001000 9220 2903                 	sts triangle_fx_Rxy_target+1, zero
001002 d021                      	rcall sound_driver_channel2_instrument_change_read_header
001003 93c0 28d7                 	sts triangle_pitch_macro_release, r28
001005 93d0 28d6                 	sts triangle_pitch_macro_loop, r29
001007 cfb8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_hi_pitch:
001008 93c0 28d9                 	sts triangle_hi_pitch_macro, r28
00100a 93d0 28da                 	sts triangle_hi_pitch_macro+1, r29
00100c 9220 28fc                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00100e 9220 28fd                 	sts triangle_fx_Qxy_target+1, zero
001010 9220 2902                 	sts triangle_fx_Rxy_target, zero
001012 9220 2903                 	sts triangle_fx_Rxy_target+1, zero
001014 d00f                      	rcall sound_driver_channel2_instrument_change_read_header
001015 93c0 28dd                 	sts triangle_hi_pitch_macro_release, r28
001017 93d0 28dc                 	sts triangle_hi_pitch_macro_loop, r29
001019 cfa6                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_duty:
00101a 93c0 28de                 	sts triangle_duty_macro, r28
00101c 93d0 28df                 	sts triangle_duty_macro+1, r29
00101e d005                      	rcall sound_driver_channel2_instrument_change_read_header
00101f 93c0 28e2                 	sts triangle_duty_macro_release, r28
001021 93d0 28e1                 	sts triangle_duty_macro_loop, r29
001023 cf9c                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_read_header:
001024 93ef                      	push ZL
001025 93ff                      	push ZH
001026 2fec                      	mov ZL, r28
001027 2ffd                      	mov ZH, r29
001028 0fee                      	lsl ZL
001029 1fff                      	rol ZH
00102a 91c5                      	lpm r28, Z+
00102b 91d4                      	lpm r29, Z
00102c 91ff                      	pop ZH
00102d 91ef                      	pop ZL
00102e 9508                      	ret
                                 
                                 sound_driver_channel2_instrument_change_read_header_arpeggio:
00102f 93ef                      	push ZL
001030 93ff                      	push ZH
001031 2fec                      	mov ZL, r28
001032 2ffd                      	mov ZH, r29
001033 0fee                      	lsl ZL
001034 1fff                      	rol ZH
001035 91c5                      	lpm r28, Z+
001036 91d5                      	lpm r29, Z+
001037 93c0 28cf                 	sts triangle_arpeggio_macro_release, r28
001039 93d0 28ce                 	sts triangle_arpeggio_macro_loop, r29
00103b 91c4                      	lpm r28, Z
00103c 93c0 28d0                 	sts triangle_arpeggio_macro_mode, r28
00103e 91ff                      	pop ZH
00103f 91ef                      	pop ZL
001040 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel2_release:
                                 sound_driver_channel2_release_volume:
001041 91b0 28ca                 	lds r27, triangle_volume_macro_release
001043 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001044 f019                      	breq sound_driver_channel2_release_arpeggio //if the macro has no release flag, check the next macro
001045 95b3                      	inc r27
001046 93b0 28c8                 	sts triangle_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel2_release_arpeggio:
001048 91b0 28cf                 	lds r27, triangle_arpeggio_macro_release
00104a 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
00104b f019                      	breq sound_driver_channel2_release_pitch
00104c 95b3                      	inc r27
00104d 93b0 28cd                 	sts triangle_arpeggio_macro_offset, r27
                                 sound_driver_channel2_release_pitch:
00104f 91b0 28d7                 	lds r27, triangle_pitch_macro_release
001051 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001052 f019                      	breq sound_driver_channel2_release_hi_pitch
001053 95b3                      	inc r27
001054 93b0 28d5                 	sts triangle_pitch_macro_offset, r27
                                 sound_driver_channel2_release_hi_pitch:
001056 91b0 28dd                 	lds r27, triangle_hi_pitch_macro_release
001058 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001059 f019                      	breq sound_driver_channel2_release_duty
00105a 95b3                      	inc r27
00105b 93b0 28db                 	sts triangle_hi_pitch_macro_offset, r27
                                 sound_driver_channel2_release_duty:
00105d 91b0 28e2                 	lds r27, triangle_duty_macro_release
00105f 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001060 f019                      	breq sound_driver_channel2_release_exit
001061 95b3                      	inc r27
001062 93b0 28e0                 	sts triangle_duty_macro_offset, r27
                                 sound_driver_channel2_release_exit:
001064 d019                      	rcall sound_driver_channel2_increment_offset
001065 cd71                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_next_pattern:
001066 91e0 2818                 	lds ZL, song_frames
001068 91f0 2819                 	lds ZH, song_frames+1
00106a 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
00106c 91b0 281b                 	lds r27, song_frame_offset+1
00106e 9614                      	adiw r27:r26, 4 //offset for channel 2
00106f 0fea                      	add ZL, r26
001070 1ffb                      	adc ZH, r27
                                 
001071 91a5                      	lpm r26, Z+ //load the address of the next pattern
001072 91b4                      	lpm r27, Z
001073 0faa                      	lsl r26
001074 1fbb                      	rol r27
001075 93a0 28c0                 	sts triangle_pattern, r26
001077 93b0 28c1                 	sts triangle_pattern+1, r27
                                 
001079 9220 28c4                 	sts triangle_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
00107b 9220 28c5                 	sts triangle_pattern_offset+1, zero
00107d cd59                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_increment_offset:
00107e 91e0 28c4                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
001080 91f0 28c5                 	lds ZH, triangle_pattern_offset+1
001082 9631                      	adiw Z, 1
001083 93e0 28c4                 	sts triangle_pattern_offset, ZL
001085 93f0 28c5                 	sts triangle_pattern_offset+1, ZH
001087 9508                      	ret
                                 
                                 sound_driver_channel2_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001088 91e0 28c4                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
00108a 91f0 28c5                 	lds ZH, triangle_pattern_offset+1
00108c 9632                      	adiw Z, 2 //increment the pointer twice
00108d 93e0 28c4                 	sts triangle_pattern_offset, ZL
00108f 93f0 28c5                 	sts triangle_pattern_offset+1, ZH
001091 9508                      	ret
                                 
                                 sound_driver_channel2_decrement_frame_delay:
001092 95ba                      	dec r27
001093 93b0 28c3                 	sts triangle_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel3:
001095 91a0 290c                 	lds r26, noise_pattern_delay_rows
001097 91b0 290d                 	lds r27, noise_pattern_delay_frames
001099 9610                      	adiw r27:r26, 0
00109a f009                      	breq sound_driver_channel3_main //if the pattern delay is 0, proceed with sound driver procedures
00109b c2c9                      	rjmp sound_driver_channel3_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel3_main:
00109c 91e0 290a                 	lds ZL, noise_pattern //current pattern for noise
00109e 91f0 290b                 	lds ZH, noise_pattern+1
0010a0 91a0 290e                 	lds r26, noise_pattern_offset //current offset in the pattern for noise
0010a2 91b0 290f                 	lds r27, noise_pattern_offset+1
0010a4 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
0010a5 1ffb                      	adc ZH, r27
0010a6 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel3_check_if_note: //check if data is a note (0x00 - 0x56)
0010a7 35b7                      	cpi r27, 0x57
0010a8 f408                      	brsh sound_driver_channel3_check_if_volume
0010a9 c172                      	rjmp sound_driver_channel3_note
                                 sound_driver_channel3_check_if_volume: //check if data is volume (0x57-0x66)
0010aa 36b7                      	cpi r27, 0x67
0010ab f408                      	brsh sound_driver_channel3_check_if_delay
0010ac c1a9                      	rjmp sound_driver_channel3_volume
                                 sound_driver_channel3_check_if_delay: //check if data is a delay (0x67 - 0xE2)
0010ad 3eb3                      	cpi r27, 0xE3
0010ae f408                      	brsh sound_driver_channel3_check_if_instrument
0010af c1af                      	rjmp sound_driver_channel3_delay
                                 sound_driver_channel3_check_if_instrument: //check for instrument flag (0xE3)
0010b0 f409                      	brne sound_driver_channel3_check_if_release
0010b1 c1b2                      	rjmp sound_driver_channel3_instrument_change 
                                 sound_driver_channel3_check_if_release: //check for note release flag (0xE4)
0010b2 3eb4                      	cpi r27, 0xE4
0010b3 f409                      	brne sound_driver_channel3_check_if_end
0010b4 c25b                      	rjmp sound_driver_channel3_release
                                 sound_driver_channel3_check_if_end:
0010b5 3fbf                      	cpi r27, 0xFF
0010b6 f409                      	brne sound_driver_channel3_check_if_fx
0010b7 c27d                      	rjmp sound_driver_channel3_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel3_check_if_fx: //fx flags (0xE5 - 0xFE)
0010b8 9631                      	adiw Z, 1 //point Z to the byte next to the flag
0010b9 91a4                      	lpm r26, Z //load the fx data into r26
0010ba d2a0                      	rcall sound_driver_channel3_increment_offset_twice
                                 
0010bb 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
0010bc e0ea                      	ldi ZL, LOW(channel3_fx << 1) //load in note table
0010bd e4f3                      	ldi ZH, HIGH(channel3_fx << 1)
0010be 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
0010bf 0feb                      	add ZL, r27 //add offset
0010c0 1df2                      	adc ZH, zero
0010c1 91c5                      	lpm r28, Z+ //load address bytes
0010c2 91d4                      	lpm r29, Z
0010c3 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
0010c4 2ffd                      	mov ZH, r29
0010c5 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel3_fx_0xy:
0010c6 93a0 292d                 	sts noise_fx_0xy_sequence, r26
0010c8 9220 292e                 	sts noise_fx_0xy_sequence+1, zero
0010ca cfd1                      	rjmp sound_driver_channel3_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel3_fx_1xx:
0010cb 9220 2933                 	sts noise_fx_2xx, zero //turn off any 2xx pitch slide down
0010cd 9220 2934                 	sts noise_fx_2xx+1, zero
0010cf 9220 292d                 	sts noise_fx_0xy_sequence, zero //disable any 0xy effect
0010d1 9220 292e                 	sts noise_fx_0xy_sequence+1, zero
0010d3 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0010d4 937f                      	push r23
0010d5 2f6a                      	mov r22, r26 //store the rate into r22
0010d6 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0010d7 9f67                      	mul r22, r23
0010d8 917f                      	pop r23
0010d9 916f                      	pop r22
                                 
0010da 9416                      	lsr r1 //shift out the fractional bits
0010db 9407                      	ror r0
0010dc 9416                      	lsr r1
0010dd 9407                      	ror r0
0010de 9416                      	lsr r1
0010df 9407                      	ror r0
0010e0 9416                      	lsr r1
0010e1 9407                      	ror r0
0010e2 9200 292f                 	sts noise_fx_1xx, r0
0010e4 9210 2930                 	sts noise_fx_1xx+1, r1
0010e6 cfb5                      	rjmp sound_driver_channel3_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel3_fx_2xx:
0010e7 9220 292f                 	sts noise_fx_1xx, zero //turn off any 1xx pitch slide down
0010e9 9220 2930                 	sts noise_fx_1xx+1, zero
0010eb 9220 292d                 	sts noise_fx_0xy_sequence, zero //disable any 0xy effect
0010ed 9220 292e                 	sts noise_fx_0xy_sequence+1, zero
0010ef 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0010f0 937f                      	push r23
0010f1 2f6a                      	mov r22, r26 //store the rate into r22
0010f2 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0010f3 9f67                      	mul r22, r23
0010f4 917f                      	pop r23
0010f5 916f                      	pop r22
                                 
0010f6 9416                      	lsr r1 //shift out the fractional bits
0010f7 9407                      	ror r0
0010f8 9416                      	lsr r1
0010f9 9407                      	ror r0
0010fa 9416                      	lsr r1
0010fb 9407                      	ror r0
0010fc 9416                      	lsr r1
0010fd 9407                      	ror r0
0010fe 9200 2933                 	sts noise_fx_2xx, r0
001100 9210 2934                 	sts noise_fx_2xx+1, r1
001102 cf99                      	rjmp sound_driver_channel3_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel3_fx_3xx:
001103 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001104 937f                      	push r23
001105 2f6a                      	mov r22, r26 //store the rate into r22
001106 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001107 9f67                      	mul r22, r23
001108 917f                      	pop r23
001109 916f                      	pop r22
                                 
00110a 9416                      	lsr r1 //shift out the fractional bits
00110b 9407                      	ror r0
00110c 9416                      	lsr r1
00110d 9407                      	ror r0
00110e 9416                      	lsr r1
00110f 9407                      	ror r0
001110 9416                      	lsr r1
001111 9407                      	ror r0
001112 9200 293b                 	sts noise_fx_3xx_speed, r0
001114 9210 293c                 	sts noise_fx_3xx_speed+1, r1
                                 
001116 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001117 c001                      	rjmp sound_driver_channel3_fx_3xx_enabled
001118 cf83                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_3xx_enabled:
001119 91a0 0abc                 	lds r26, TCB3_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
00111b 91b0 0abd                 	lds r27, TCB3_CCMPH
00111d 93a0 2937                 	sts noise_fx_3xx_start, r26
00111f 93b0 2938                 	sts noise_fx_3xx_start+1, r27
                                 
001121 9220 293d                 	sts noise_fx_3xx_total_offset, zero
001123 9220 293e                 	sts noise_fx_3xx_total_offset+1, zero
001125 cf76                      	rjmp sound_driver_channel3_main
                                 
                                 //VIBRATO
                                 sound_driver_channel3_fx_4xy:
001126 2fba                      	mov r27, r26
001127 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001128 95a2                      	swap r26
001129 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
00112a 93a0 293f                 	sts noise_fx_4xy_speed, r26
00112c 93b0 2940                 	sts noise_fx_4xy_depth, r27
00112e 9220 2941                 	sts noise_fx_4xy_phase, zero //reset the phase to 0
001130 cf6b                      	rjmp sound_driver_channel3_main
                                 
                                 //TREMELO
                                 sound_driver_channel3_fx_7xy:
001131 2fba                      	mov r27, r26
001132 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001133 95a2                      	swap r26
001134 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001135 93a0 2942                 	sts noise_fx_7xy_speed, r26
001137 93b0 2943                 	sts noise_fx_7xy_depth, r27
001139 9220 2944                 	sts noise_fx_7xy_phase, zero //reset the phase to 0
00113b 9220 2945                 	sts noise_fx_7xy_value, zero //reset the tremelo value
00113d cf5e                      	rjmp sound_driver_channel3_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel3_fx_Axy:
00113e 93a0 2946                 	sts noise_fx_Axy, r26
001140 cf5b                      	rjmp sound_driver_channel3_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel3_fx_Bxx:
001141 93a0 281f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001143 cf58                      	rjmp sound_driver_channel3_main
                                 
                                 //HALT
                                 sound_driver_channel3_fx_Cxx:
001144 93b0 2820                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001146 cf55                      	rjmp sound_driver_channel3_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel3_fx_Dxx:
001147 93b0 2821                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001149 cf52                      	rjmp sound_driver_channel3_main
                                 
                                 //VOLUME
                                 sound_driver_channel3_fx_Exx:
00114a 91b0 2813                 	lds r27, noise_param
00114c 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
00114d 2bba                      	or r27, r26 //move new VVVV bits into noise_param
00114e 93b0 2813                 	sts noise_param, r27
001150 cf4b                      	rjmp sound_driver_channel3_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel3_fx_Fxx:
001151 93a0 281e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001153 cf48                      	rjmp sound_driver_channel3_main
                                 
                                 //DELAY
                                 sound_driver_channel3_fx_Gxx:
001154 15a2                      	cp r26, zero
001155 f051                      	breq sound_driver_channel3_fx_Gxx_invalid
001156 91b0 281e                 	lds r27, song_speed
001158 17ab                      	cp r26, r27
001159 f430                      	brsh sound_driver_channel3_fx_Gxx_invalid
00115a 93a0 2947                 	sts noise_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
00115c e0b1                      	ldi r27, 0x01
00115d 93b0 290c                 	sts noise_pattern_delay_rows, r27
00115f c208                      	rjmp sound_driver_channel4
                                 sound_driver_channel3_fx_Gxx_invalid:
001160 cf3b                      	rjmp sound_driver_channel3_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel3_fx_Hxy: //hardware sweep up
001161 cf3a                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Ixy: //hardware sweep down
001162 cf39                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Hxx: //FDS modulation depth
001163 cf38                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Ixx: //FDS modulation speed
001164 cf37                      	rjmp sound_driver_channel3_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel3_fx_Pxx:
001165 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001166 937f                      	push r23
001167 2f6a                      	mov r22, r26
001168 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001169 0367                      	mulsu r22, r23
00116a 917f                      	pop r23
00116b 916f                      	pop r22
00116c 9416                      	lsr r1 //shift out the fractional bits
00116d 9407                      	ror r0
00116e 9416                      	lsr r1
00116f 9407                      	ror r0
001170 9416                      	lsr r1
001171 9407                      	ror r0
001172 9416                      	lsr r1
001173 9407                      	ror r0
001174 9200 2949                 	sts noise_fx_Pxx_total, r0
001176 9210 294a                 	sts noise_fx_Pxx_total+1, r1
001178 cf23                      	rjmp sound_driver_channel3_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel3_fx_Qxy:
                                 sound_driver_channel3_fx_Qxy_check_arpeggio_macro:
001179 91e0 2915                 	lds ZL, noise_arpeggio_macro
00117b 91f0 2916                 	lds ZH, noise_arpeggio_macro+1
00117d 9630                      	adiw Z, 0
00117e f009                      	breq sound_driver_channel3_fx_Qxy_check_pitch_macro
00117f cf1c                      	rjmp sound_driver_channel3_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Qxy_check_pitch_macro:
001180 91e0 291d                 	lds ZL, noise_pitch_macro
001182 91f0 291e                 	lds ZH, noise_pitch_macro+1
001184 9630                      	adiw Z, 0
001185 f009                      	breq sound_driver_channel3_fx_Qxy_check_hi_pitch_macro
001186 cf15                      	rjmp sound_driver_channel3_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Qxy_check_hi_pitch_macro:
001187 91e0 2923                 	lds ZL, noise_hi_pitch_macro
001189 91f0 2924                 	lds ZH, noise_hi_pitch_macro+1
00118b 9630                      	adiw Z, 0
00118c f009                      	breq sound_driver_channel3_fx_Qxy_process
00118d cf0e                      	rjmp sound_driver_channel3_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Qxy_process:
00118e 2fba                      	mov r27, r26 //copy fx parameters into r27
00118f 70bf                      	andi r27, 0x0F //mask note index offset
001190 91c0 2817                 	lds r28, noise_note //load current note index
001192 0fbc                      	add r27, r28
001193 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001194 f008                      	brlo sound_driver_channel3_fx_Qxy_process_continue
001195 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel3_fx_Qxy_process_continue:
001196 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001197 e0f0                      	ldi ZH, HIGH(note_table << 1)
001198 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001199 0feb                      	add ZL, r27 //add offset
00119a 1df2                      	adc ZH, zero
00119b 91c5                      	lpm r28, Z+ //load bytes
00119c 91d4                      	lpm r29, Z
00119d 93c0 294b                 	sts noise_fx_Qxy_target, r28 //load the LOW bits for the target period
00119f 93d0 294c                 	sts noise_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
0011a1 95a2                      	swap r26
0011a2 70af                      	andi r26, 0x0F //mask effect speed
0011a3 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0011a4 95a3                      	inc r26 //increment the speed by 1
                                 
0011a5 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0011a6 937f                      	push r23
0011a7 2f6a                      	mov r22, r26 //store the speed data into r27
0011a8 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0011a9 9f67                      	mul r22, r23
0011aa 917f                      	pop r23
0011ab 916f                      	pop r22
                                 
0011ac 9416                      	lsr r1 //shift out the fractional bits
0011ad 9407                      	ror r0
0011ae 9416                      	lsr r1
0011af 9407                      	ror r0
0011b0 9416                      	lsr r1
0011b1 9407                      	ror r0
0011b2 9416                      	lsr r1
0011b3 9407                      	ror r0
                                 
0011b4 9200 294d                 	sts noise_fx_Qxy_speed, r0 //store the effect speed
0011b6 9210 294e                 	sts noise_fx_Qxy_speed+1, r1
0011b8 9220 294f                 	sts noise_fx_Qxy_total_offset, zero
0011ba 9220 2950                 	sts noise_fx_Qxy_total_offset+1, zero
0011bc cedf                      	rjmp sound_driver_channel3_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel3_fx_Rxy:
                                 sound_driver_channel3_fx_Rxy_check_arpeggio_macro:
0011bd 91e0 2915                 	lds ZL, noise_arpeggio_macro
0011bf 91f0 2916                 	lds ZH, noise_arpeggio_macro+1
0011c1 9630                      	adiw Z, 0
0011c2 f009                      	breq sound_driver_channel3_fx_Rxy_check_pitch_macro
0011c3 ced8                      	rjmp sound_driver_channel3_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Rxy_check_pitch_macro:
0011c4 91e0 291d                 	lds ZL, noise_pitch_macro
0011c6 91f0 291e                 	lds ZH, noise_pitch_macro+1
0011c8 9630                      	adiw Z, 0
0011c9 f009                      	breq sound_driver_channel3_fx_Rxy_check_hi_pitch_macro
0011ca ced1                      	rjmp sound_driver_channel3_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Rxy_check_hi_pitch_macro:
0011cb 91e0 2923                 	lds ZL, noise_hi_pitch_macro
0011cd 91f0 2924                 	lds ZH, noise_hi_pitch_macro+1
0011cf 9630                      	adiw Z, 0
0011d0 f009                      	breq sound_driver_channel3_fx_Rxy_process
0011d1 ceca                      	rjmp sound_driver_channel3_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Rxy_process:
0011d2 2fba                      	mov r27, r26 //copy fx parameters into r27
0011d3 70bf                      	andi r27, 0x0F //mask note index offset
0011d4 91c0 2817                 	lds r28, noise_note //load current note index
0011d6 1bcb                      	sub r28, r27
0011d7 f408                      	brcc sound_driver_channel3_fx_Rxy_process_continue
0011d8 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel3_fx_Rxy_process_continue:
0011d9 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0011da e0f0                      	ldi ZH, HIGH(note_table << 1)
0011db 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
0011dc 0fec                      	add ZL, r28 //add offset
0011dd 1df2                      	adc ZH, zero
0011de 91c5                      	lpm r28, Z+ //load bytes
0011df 91d4                      	lpm r29, Z
0011e0 93c0 2951                 	sts noise_fx_Rxy_target, r28 //load the LOW bits for the target period
0011e2 93d0 2952                 	sts noise_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
0011e4 95a2                      	swap r26
0011e5 70af                      	andi r26, 0x0F //mask effect speed
0011e6 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0011e7 95a3                      	inc r26 //increment the speed by 1
                                 
0011e8 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0011e9 937f                      	push r23
0011ea 2f6a                      	mov r22, r26 //store the speed data into r27
0011eb eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0011ec 9f67                      	mul r22, r23
0011ed 917f                      	pop r23
0011ee 916f                      	pop r22
                                 
0011ef 9416                      	lsr r1 //shift out the fractional bits
0011f0 9407                      	ror r0
0011f1 9416                      	lsr r1
0011f2 9407                      	ror r0
0011f3 9416                      	lsr r1
0011f4 9407                      	ror r0
0011f5 9416                      	lsr r1
0011f6 9407                      	ror r0
                                 
0011f7 9200 2953                 	sts noise_fx_Rxy_speed, r0 //store the effect speed
0011f9 9210 2954                 	sts noise_fx_Rxy_speed+1, r1
0011fb 9220 2955                 	sts noise_fx_Rxy_total_offset, zero
0011fd 9220 2956                 	sts noise_fx_Rxy_total_offset+1, zero
0011ff ce9c                      	rjmp sound_driver_channel3_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel3_fx_Sxx:
001200 15a2                      	cp r26, zero
001201 f051                      	breq sound_driver_channel3_fx_Sxx_invalid
001202 91b0 281e                 	lds r27, song_speed
001204 17ab                      	cp r26, r27
001205 f430                      	brsh sound_driver_channel3_fx_Sxx_invalid
001206 93a0 2957                 	sts noise_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001208 e0b1                      	ldi r27, 0x01
001209 93b0 290c                 	sts noise_pattern_delay_rows, r27
00120b c15c                      	rjmp sound_driver_channel4
                                 sound_driver_channel3_fx_Sxx_invalid:
00120c ce8f                      	rjmp sound_driver_channel3_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel3_fx_Vxx:
00120d 95a6                      	lsr r26
00120e 95a7                      	ror r26 //move mode bit to bit 7
00120f 91b0 2814                 	lds r27, noise_period
001211 77bf                      	andi r27, 0b01111111
001212 2bba                      	or r27, r26 //store the new noise mode
001213 93b0 2813                 	sts noise_param, r27
                                 
001215 776f                      	andi noise_sequence_HIGH, 0b01111111
001216 2b6a                      	or noise_sequence_HIGH, r26
001217 ce84                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_Wxx: //DPCM sample speed
001218 ce83                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Xxx: //DPCM sample retrigger
001219 ce82                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Yxx: //DPCM sample offset
00121a ce81                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Zxx: //DPCM sample delta counter
00121b ce80                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 sound_driver_channel3_note:
00121c 93b0 2817                 	sts noise_note, r27 //store the note index
00121e e0a3                      	ldi r26, 0x03
00121f e0b2                      	ldi r27, 0x02
001220 93b0 2912                 	sts noise_volume_macro_offset, r27 //reset all macro offsets
001222 93a0 2917                 	sts noise_arpeggio_macro_offset, r26
001224 93b0 291f                 	sts noise_pitch_macro_offset, r27
001226 93b0 2925                 	sts noise_hi_pitch_macro_offset, r27
001228 93b0 292a                 	sts noise_duty_macro_offset, r27
00122a 9220 291b                 	sts noise_total_pitch_offset, zero //reset the pitch and hi pitch offset
00122c 9220 291c                 	sts noise_total_pitch_offset+1, zero
00122e 9220 2922                 	sts noise_total_hi_pitch_offset, zero
001230 9220 2931                 	sts noise_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001232 9220 2932                 	sts noise_fx_1xx_total+1, zero
001234 9220 2935                 	sts noise_fx_2xx_total, zero
001236 9220 2936                 	sts noise_fx_2xx_total+1, zero
001238 9220 293d                 	sts noise_fx_3xx_total_offset, zero //reset 3xx offset
00123a 9220 293e                 	sts noise_fx_3xx_total_offset+1, zero
00123c 91a0 0abc                 	lds r26, TCB3_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
00123e 91b0 0abd                 	lds r27, TCB3_CCMPH
001240 93a0 2937                 	sts noise_fx_3xx_start, r26
001242 93b0 2938                 	sts noise_fx_3xx_start+1, r27
001244 9220 294b                 	sts noise_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001246 9220 294c                 	sts noise_fx_Qxy_target+1, zero
001248 9220 294f                 	sts noise_fx_Qxy_total_offset, zero
00124a 9220 2950                 	sts noise_fx_Qxy_total_offset+1, zero
00124c 9220 2951                 	sts noise_fx_Rxy_target, zero
00124e 9220 2952                 	sts noise_fx_Rxy_target+1, zero
001250 9220 2955                 	sts noise_fx_Rxy_total_offset, zero
001252 9220 2956                 	sts noise_fx_Rxy_total_offset+1, zero
001254 d0fc                      	rcall sound_driver_channel3_increment_offset
001255 ce46                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_volume:
001256 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001257 91a0 2813                 	lds r26, noise_param
001259 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
00125a 2bab                      	or r26, r27 //move new VVVV bits into noise_param
00125b 93a0 2813                 	sts noise_param, r26
00125d d0f3                      	rcall sound_driver_channel3_increment_offset
00125e ce3d                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_delay:
00125f 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001260 93b0 290c                 	sts noise_pattern_delay_rows, r27
001262 d0ee                      	rcall sound_driver_channel3_increment_offset
001263 c104                      	rjmp sound_driver_channel4
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change:
001264 9220 2910                 	sts noise_volume_macro, zero //reset all macro addresses
001266 9220 2911                 	sts noise_volume_macro+1, zero
001268 9220 2915                 	sts noise_arpeggio_macro, zero
00126a 9220 2916                 	sts noise_arpeggio_macro+1, zero
00126c 9220 291d                 	sts noise_pitch_macro, zero
00126e 9220 291e                 	sts noise_pitch_macro+1, zero
001270 9220 2923                 	sts noise_hi_pitch_macro, zero
001272 9220 2924                 	sts noise_hi_pitch_macro+1, zero
001274 9220 2928                 	sts noise_duty_macro, zero
001276 9220 2929                 	sts noise_duty_macro+1, zero
001278 9220 291b                 	sts noise_total_pitch_offset, zero //reset the pitch offset
00127a 9220 291c                 	sts noise_total_pitch_offset+1, zero
00127c 9220 2922                 	sts noise_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
00127e 9631                      	adiw Z, 1 //point to the byte next to the flag
00127f 91b4                      	lpm r27, Z //store the instrument offset into r27
001280 edea                      	ldi ZL, LOW(instruments) //point Z to instruments table
001281 e0f1                      	ldi ZH, HIGH(instruments)
001282 0feb                      	add ZL, r27 //point Z to offsetted instrument
001283 1df2                      	adc ZH, zero
001284 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001285 1fff                      	rol ZH
001286 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001287 91b4                      	lpm r27, Z
                                 
001288 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001289 1fbb                      	rol r27
00128a 2fea                      	mov ZL, r26
00128b 2ffb                      	mov ZH, r27
00128c 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
00128d 9632                      	adiw Z, 2 //point Z to the address of the macro
00128e e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel3_instrument_change_macro_loop:
00128f 95aa                      	dec r26
001290 f019                      	breq sound_driver_channel3_instrument_change_exit
001291 95b6                      	lsr r27
001292 f078                      	brcs sound_driver_channel3_instrument_change_load_macro
001293 cffb                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_exit:
001294 e0a3                      	ldi r26, 0x03
001295 e0b2                      	ldi r27, 0x02
001296 93b0 2912                 	sts noise_volume_macro_offset, r27 //reset all macro offsets
001298 93a0 2917                 	sts noise_arpeggio_macro_offset, r26
00129a 93b0 291f                 	sts noise_pitch_macro_offset, r27
00129c 93b0 2925                 	sts noise_hi_pitch_macro_offset, r27
00129e 93b0 292a                 	sts noise_duty_macro_offset, r27
0012a0 d0ba                      	rcall sound_driver_channel3_increment_offset_twice
0012a1 cdfa                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_load_macro:
0012a2 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
0012a3 91d5                      	lpm r29, Z+
                                 
0012a4 30a5                      	cpi r26, 5
0012a5 f039                      	breq sound_driver_channel3_instrument_change_load_macro_volume
0012a6 30a4                      	cpi r26, 4
0012a7 f079                      	breq sound_driver_channel3_instrument_change_load_macro_arpeggio
0012a8 30a3                      	cpi r26, 3
0012a9 f0d9                      	breq sound_driver_channel3_instrument_change_load_macro_pitch
0012aa 30a2                      	cpi r26, 2
0012ab f159                      	breq sound_driver_channel3_instrument_change_load_macro_hi_pitch
0012ac c03c                      	rjmp sound_driver_channel3_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel3_instrument_change_load_macro_volume:
0012ad 93c0 2910                 	sts noise_volume_macro, r28
0012af 93d0 2911                 	sts noise_volume_macro+1, r29
0012b1 d041                      	rcall sound_driver_channel3_instrument_change_read_header
0012b2 93c0 2914                 	sts noise_volume_macro_release, r28
0012b4 93d0 2913                 	sts noise_volume_macro_loop, r29
0012b6 cfd8                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 	
                                 sound_driver_channel3_instrument_change_load_macro_arpeggio:
0012b7 93c0 2915                 	sts noise_arpeggio_macro, r28
0012b9 93d0 2916                 	sts noise_arpeggio_macro+1, r29
0012bb 9220 294b                 	sts noise_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0012bd 9220 294c                 	sts noise_fx_Qxy_target+1, zero
0012bf 9220 2951                 	sts noise_fx_Rxy_target, zero
0012c1 9220 2952                 	sts noise_fx_Rxy_target+1, zero
0012c3 d03a                      	rcall sound_driver_channel3_instrument_change_read_header_arpeggio
0012c4 cfca                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_pitch:
0012c5 93c0 291d                 	sts noise_pitch_macro, r28
0012c7 93d0 291e                 	sts noise_pitch_macro+1, r29
0012c9 9220 294b                 	sts noise_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0012cb 9220 294c                 	sts noise_fx_Qxy_target+1, zero
0012cd 9220 2951                 	sts noise_fx_Rxy_target, zero
0012cf 9220 2952                 	sts noise_fx_Rxy_target+1, zero
0012d1 d021                      	rcall sound_driver_channel3_instrument_change_read_header
0012d2 93c0 2921                 	sts noise_pitch_macro_release, r28
0012d4 93d0 2920                 	sts noise_pitch_macro_loop, r29
0012d6 cfb8                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_hi_pitch:
0012d7 93c0 2923                 	sts noise_hi_pitch_macro, r28
0012d9 93d0 2924                 	sts noise_hi_pitch_macro+1, r29
0012db 9220 294b                 	sts noise_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0012dd 9220 294c                 	sts noise_fx_Qxy_target+1, zero
0012df 9220 2951                 	sts noise_fx_Rxy_target, zero
0012e1 9220 2952                 	sts noise_fx_Rxy_target+1, zero
0012e3 d00f                      	rcall sound_driver_channel3_instrument_change_read_header
0012e4 93c0 2927                 	sts noise_hi_pitch_macro_release, r28
0012e6 93d0 2926                 	sts noise_hi_pitch_macro_loop, r29
0012e8 cfa6                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_duty:
0012e9 93c0 2928                 	sts noise_duty_macro, r28
0012eb 93d0 2929                 	sts noise_duty_macro+1, r29
0012ed d005                      	rcall sound_driver_channel3_instrument_change_read_header
0012ee 93c0 292c                 	sts noise_duty_macro_release, r28
0012f0 93d0 292b                 	sts noise_duty_macro_loop, r29
0012f2 cf9c                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_read_header:
0012f3 93ef                      	push ZL
0012f4 93ff                      	push ZH
0012f5 2fec                      	mov ZL, r28
0012f6 2ffd                      	mov ZH, r29
0012f7 0fee                      	lsl ZL
0012f8 1fff                      	rol ZH
0012f9 91c5                      	lpm r28, Z+
0012fa 91d4                      	lpm r29, Z
0012fb 91ff                      	pop ZH
0012fc 91ef                      	pop ZL
0012fd 9508                      	ret
                                 
                                 sound_driver_channel3_instrument_change_read_header_arpeggio:
0012fe 93ef                      	push ZL
0012ff 93ff                      	push ZH
001300 2fec                      	mov ZL, r28
001301 2ffd                      	mov ZH, r29
001302 0fee                      	lsl ZL
001303 1fff                      	rol ZH
001304 91c5                      	lpm r28, Z+
001305 91d5                      	lpm r29, Z+
001306 93c0 2919                 	sts noise_arpeggio_macro_release, r28
001308 93d0 2918                 	sts noise_arpeggio_macro_loop, r29
00130a 91c4                      	lpm r28, Z
00130b 93c0 291a                 	sts noise_arpeggio_macro_mode, r28
00130d 91ff                      	pop ZH
00130e 91ef                      	pop ZL
00130f 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel3_release:
                                 sound_driver_channel3_release_volume:
001310 91b0 2914                 	lds r27, noise_volume_macro_release
001312 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001313 f019                      	breq sound_driver_channel3_release_arpeggio //if the macro has no release flag, check the next macro
001314 95b3                      	inc r27
001315 93b0 2912                 	sts noise_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel3_release_arpeggio:
001317 91b0 2919                 	lds r27, noise_arpeggio_macro_release
001319 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
00131a f019                      	breq sound_driver_channel3_release_pitch
00131b 95b3                      	inc r27
00131c 93b0 2917                 	sts noise_arpeggio_macro_offset, r27
                                 sound_driver_channel3_release_pitch:
00131e 91b0 2921                 	lds r27, noise_pitch_macro_release
001320 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001321 f019                      	breq sound_driver_channel3_release_hi_pitch
001322 95b3                      	inc r27
001323 93b0 291f                 	sts noise_pitch_macro_offset, r27
                                 sound_driver_channel3_release_hi_pitch:
001325 91b0 2927                 	lds r27, noise_hi_pitch_macro_release
001327 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001328 f019                      	breq sound_driver_channel3_release_duty
001329 95b3                      	inc r27
00132a 93b0 2925                 	sts noise_hi_pitch_macro_offset, r27
                                 sound_driver_channel3_release_duty:
00132c 91b0 292c                 	lds r27, noise_duty_macro_release
00132e 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
00132f f019                      	breq sound_driver_channel3_release_exit
001330 95b3                      	inc r27
001331 93b0 292a                 	sts noise_duty_macro_offset, r27
                                 sound_driver_channel3_release_exit:
001333 d01d                      	rcall sound_driver_channel3_increment_offset
001334 cd67                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_next_pattern:
001335 91e0 2818                 	lds ZL, song_frames
001337 91f0 2819                 	lds ZH, song_frames+1
001339 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
00133b 91b0 281b                 	lds r27, song_frame_offset+1
00133d 93a0 281a                 	sts song_frame_offset, r26
00133f 93b0 281b                 	sts song_frame_offset+1, r27
001341 9616                      	adiw r27:r26, 6 //offset for channel 3
001342 0fea                      	add ZL, r26
001343 1ffb                      	adc ZH, r27
                                 
001344 91a5                      	lpm r26, Z+ //load the address of the next pattern
001345 91b4                      	lpm r27, Z
001346 0faa                      	lsl r26
001347 1fbb                      	rol r27
001348 93a0 290a                 	sts noise_pattern, r26
00134a 93b0 290b                 	sts noise_pattern+1, r27
                                 
00134c 9220 290e                 	sts noise_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
00134e 9220 290f                 	sts noise_pattern_offset+1, zero
001350 cd4b                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_increment_offset:
001351 91e0 290e                 	lds ZL, noise_pattern_offset //current offset in the pattern for noise
001353 91f0 290f                 	lds ZH, noise_pattern_offset+1
001355 9631                      	adiw Z, 1
001356 93e0 290e                 	sts noise_pattern_offset, ZL
001358 93f0 290f                 	sts noise_pattern_offset+1, ZH
00135a 9508                      	ret
                                 
                                 sound_driver_channel3_increment_offset_twice: //used for data that takes up 2 bytes worth of space
00135b 91e0 290e                 	lds ZL, noise_pattern_offset //current offset in the pattern for noise
00135d 91f0 290f                 	lds ZH, noise_pattern_offset+1
00135f 9632                      	adiw Z, 2 //increment the pointer twice
001360 93e0 290e                 	sts noise_pattern_offset, ZL
001362 93f0 290f                 	sts noise_pattern_offset+1, ZH
001364 9508                      	ret
                                 
                                 sound_driver_channel3_decrement_frame_delay:
001365 95ba                      	dec r27
001366 93b0 290d                 	sts noise_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel4:
                                 
                                 sound_driver_calculate_delays:
001368 91f0 281e                 	lds r31, song_speed
00136a 2fef                      	mov r30, r31
00136b 50e1                      	subi r30, 1
                                 sound_driver_calculate_delays_pulse1:
00136c 91a0 2825                 	lds r26, pulse1_pattern_delay_frames
00136e 11a2                      	cpse r26, zero
00136f c042                      	rjmp sound_driver_calculate_delays_pulse2
001370 c000                      	rjmp sound_driver_calculate_delays_pulse1_main
                                 
                                 sound_driver_calculate_delays_pulse1_main:
001371 2faf                      	mov r26, r31 //move the speed to r26
001372 91b0 2824                 	lds r27, pulse1_pattern_delay_rows //decrement the delay rows
001374 15b2                      	cp r27, zero
001375 f409                      	brne PC+2
001376 c03b                      	rjmp sound_driver_calculate_delays_pulse2
001377 95ba                      	dec r27
001378 93b0 2824                 	sts pulse1_pattern_delay_rows, r27
00137a 11b2                      	cpse r27, zero
00137b c034                      	rjmp sound_driver_calculate_delays_pulse1_store
00137c 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx:
00137d efbf                      	ldi r27, 0xFF
00137e 91c0 286f                 	lds r28, pulse1_fx_Sxx_pre
001380 91d0 2870                 	lds r29, pulse1_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse1_Sxx_check_pre:
001382 17cb                      	cp r28, r27
001383 f009                      	breq sound_driver_calculate_delays_pulse1_Sxx_check_post
001384 c00d                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_pre
                                 sound_driver_calculate_delays_pulse1_Sxx_check_post:
001385 17db                      	cp r29, r27
001386 f009                      	breq sound_driver_calculate_delays_pulse1_Gxx
001387 c015                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx:
001388 91c0 285f                 	lds r28, pulse1_fx_Gxx_pre
00138a 91d0 2860                 	lds r29, pulse1_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse1_Gxx_check_pre:
00138c 17cb                      	cp r28, r27
00138d f009                      	breq sound_driver_calculate_delays_pulse1_Gxx_check_post
00138e c012                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_pre
                                 sound_driver_calculate_delays_pulse1_Gxx_check_post:
00138f 17db                      	cp r29, r27
001390 f0f9                      	breq sound_driver_calculate_delays_pulse1_store
001391 c01a                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_pre:
001392 93b0 286f                 	sts pulse1_fx_Sxx_pre, r27
001394 1bec                      	sub r30, r28 //(song speed)-1-Sxx
001395 93e0 2870                 	sts pulse1_fx_Sxx_post, r30
001397 95ca                      	dec r28
001398 93c0 2825                 	sts pulse1_pattern_delay_frames, r28
00139a 2fef                      	mov r30, r31
00139b 50e1                      	subi r30, 1
00139c c015                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_post:
00139d 93b0 2870                 	sts pulse1_fx_Sxx_post, r27
00139f 2fad                      	mov r26, r29
0013a0 c00f                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx_pre:
0013a1 93b0 285f                 	sts pulse1_fx_Gxx_pre, r27
0013a3 1bec                      	sub r30, r28 //(song speed)-1-Sxx
0013a4 93e0 2860                 	sts pulse1_fx_Gxx_post, r30
0013a6 95ca                      	dec r28
0013a7 93c0 2825                 	sts pulse1_pattern_delay_frames, r28
0013a9 2fef                      	mov r30, r31
0013aa 50e1                      	subi r30, 1
0013ab c006                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse1_Gxx_post:
0013ac 93b0 2860                 	sts pulse1_fx_Gxx_post, r27
0013ae 2fad                      	mov r26, r29
0013af c000                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_store:
0013b0 93a0 2825                 	sts pulse1_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_pulse2:
0013b2 91a0 2874                 	lds r26, pulse2_pattern_delay_frames
0013b4 11a2                      	cpse r26, zero
0013b5 c042                      	rjmp sound_driver_calculate_delays_triangle
0013b6 c000                      	rjmp sound_driver_calculate_delays_pulse2_main
                                 
                                 sound_driver_calculate_delays_pulse2_main:
0013b7 2faf                      	mov r26, r31 //move the speed to r26
0013b8 91b0 2873                 	lds r27, pulse2_pattern_delay_rows //decrement the delay rows
0013ba 15b2                      	cp r27, zero
0013bb f409                      	brne PC+2
0013bc c03b                      	rjmp sound_driver_calculate_delays_triangle
0013bd 95ba                      	dec r27
0013be 93b0 2873                 	sts pulse2_pattern_delay_rows, r27
0013c0 11b2                      	cpse r27, zero
0013c1 c034                      	rjmp sound_driver_calculate_delays_pulse2_store
0013c2 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx:
0013c3 efbf                      	ldi r27, 0xFF
0013c4 91c0 28be                 	lds r28, pulse2_fx_Sxx_pre
0013c6 91d0 28bf                 	lds r29, pulse2_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse2_Sxx_check_pre:
0013c8 17cb                      	cp r28, r27
0013c9 f009                      	breq sound_driver_calculate_delays_pulse2_Sxx_check_post
0013ca c00d                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_pre
                                 sound_driver_calculate_delays_pulse2_Sxx_check_post:
0013cb 17db                      	cp r29, r27
0013cc f009                      	breq sound_driver_calculate_delays_pulse2_Gxx
0013cd c015                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx:
0013ce 91c0 28ae                 	lds r28, pulse2_fx_Gxx_pre
0013d0 91d0 28af                 	lds r29, pulse2_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse2_Gxx_check_pre:
0013d2 17cb                      	cp r28, r27
0013d3 f009                      	breq sound_driver_calculate_delays_pulse2_Gxx_check_post
0013d4 c012                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_pre
                                 sound_driver_calculate_delays_pulse2_Gxx_check_post:
0013d5 17db                      	cp r29, r27
0013d6 f0f9                      	breq sound_driver_calculate_delays_pulse2_store
0013d7 c01a                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_pre:
0013d8 93b0 28be                 	sts pulse2_fx_Sxx_pre, r27
0013da 1bec                      	sub r30, r28 //(song speed)-1-Sxx
0013db 93e0 28bf                 	sts pulse2_fx_Sxx_post, r30
0013dd 95ca                      	dec r28
0013de 93c0 2874                 	sts pulse2_pattern_delay_frames, r28
0013e0 2fef                      	mov r30, r31
0013e1 50e1                      	subi r30, 1
0013e2 cfcf                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_post:
0013e3 93b0 28bf                 	sts pulse2_fx_Sxx_post, r27
0013e5 2fad                      	mov r26, r29
0013e6 c00f                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx_pre:
0013e7 93b0 28ae                 	sts pulse2_fx_Gxx_pre, r27
0013e9 1bec                      	sub r30, r28 //(song speed)-1-Sxx
0013ea 93e0 28af                 	sts pulse2_fx_Gxx_post, r30
0013ec 95ca                      	dec r28
0013ed 93c0 2874                 	sts pulse2_pattern_delay_frames, r28
0013ef 2fef                      	mov r30, r31
0013f0 50e1                      	subi r30, 1
0013f1 cfc0                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse2_Gxx_post:
0013f2 93b0 28af                 	sts pulse2_fx_Gxx_post, r27
0013f4 2fad                      	mov r26, r29
0013f5 c000                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_store:
0013f6 93a0 2874                 	sts pulse2_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_triangle:
0013f8 91a0 28c3                 	lds r26, triangle_pattern_delay_frames
0013fa 11a2                      	cpse r26, zero
0013fb c042                      	rjmp sound_driver_calculate_delays_noise
0013fc c000                      	rjmp sound_driver_calculate_delays_triangle_main
                                 
                                 sound_driver_calculate_delays_triangle_main:
0013fd 2faf                      	mov r26, r31 //move the speed to r26
0013fe 91b0 28c2                 	lds r27, triangle_pattern_delay_rows //decrement the delay rows
001400 15b2                      	cp r27, zero
001401 f409                      	brne PC+2
001402 c03b                      	rjmp sound_driver_calculate_delays_noise
001403 95ba                      	dec r27
001404 93b0 28c2                 	sts triangle_pattern_delay_rows, r27
001406 11b2                      	cpse r27, zero
001407 c034                      	rjmp sound_driver_calculate_delays_triangle_store
001408 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_triangle_Sxx:
001409 efbf                      	ldi r27, 0xFF
00140a 91c0 2908                 	lds r28, triangle_fx_Sxx_pre
00140c 91d0 2909                 	lds r29, triangle_fx_Sxx_post
                                 sound_driver_calculate_delays_triangle_Sxx_check_pre:
00140e 17cb                      	cp r28, r27
00140f f009                      	breq sound_driver_calculate_delays_triangle_Sxx_check_post
001410 c00d                      	rjmp sound_driver_calculate_delays_triangle_Sxx_pre
                                 sound_driver_calculate_delays_triangle_Sxx_check_post:
001411 17db                      	cp r29, r27
001412 f009                      	breq sound_driver_calculate_delays_triangle_Gxx
001413 c015                      	rjmp sound_driver_calculate_delays_triangle_Sxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Gxx:
001414 91c0 28f8                 	lds r28, triangle_fx_Gxx_pre
001416 91d0 28f9                 	lds r29, triangle_fx_Gxx_post
                                 sound_driver_calculate_delays_triangle_Gxx_check_pre:
001418 17cb                      	cp r28, r27
001419 f009                      	breq sound_driver_calculate_delays_triangle_Gxx_check_post
00141a c012                      	rjmp sound_driver_calculate_delays_triangle_Gxx_pre
                                 sound_driver_calculate_delays_triangle_Gxx_check_post:
00141b 17db                      	cp r29, r27
00141c f0f9                      	breq sound_driver_calculate_delays_triangle_store
00141d c01a                      	rjmp sound_driver_calculate_delays_triangle_Gxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_pre:
00141e 93b0 2908                 	sts triangle_fx_Sxx_pre, r27
001420 1bec                      	sub r30, r28 //(song speed)-1-Sxx
001421 93e0 2909                 	sts triangle_fx_Sxx_post, r30
001423 95ca                      	dec r28
001424 93c0 28c3                 	sts triangle_pattern_delay_frames, r28
001426 2fef                      	mov r30, r31
001427 50e1                      	subi r30, 1
001428 c015                      	rjmp sound_driver_calculate_delays_noise
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_post:
001429 93b0 2909                 	sts triangle_fx_Sxx_post, r27
00142b 2fad                      	mov r26, r29
00142c c00f                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_Gxx_pre:
00142d 93b0 28f8                 	sts triangle_fx_Gxx_pre, r27
00142f 1bec                      	sub r30, r28 //(song speed)-1-Sxx
001430 93e0 28f9                 	sts triangle_fx_Gxx_post, r30
001432 95ca                      	dec r28
001433 93c0 28c3                 	sts triangle_pattern_delay_frames, r28
001435 2fef                      	mov r30, r31
001436 50e1                      	subi r30, 1
001437 c006                      	rjmp sound_driver_calculate_delays_noise
                                 	
                                 sound_driver_calculate_delays_triangle_Gxx_post:
001438 93b0 28f9                 	sts triangle_fx_Gxx_post, r27
00143a 2fad                      	mov r26, r29
00143b c000                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_store:
00143c 93a0 28c3                 	sts triangle_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_noise:
00143e 91a0 290d                 	lds r26, noise_pattern_delay_frames
001440 11a2                      	cpse r26, zero
001441 c042                      	rjmp sound_driver_calculate_delays_dpcm
001442 c000                      	rjmp sound_driver_calculate_delays_noise_main
                                 
                                 sound_driver_calculate_delays_noise_main:
001443 2faf                      	mov r26, r31 //move the speed to r26
001444 91b0 290c                 	lds r27, noise_pattern_delay_rows //decrement the delay rows
001446 15b2                      	cp r27, zero
001447 f409                      	brne PC+2
001448 c03b                      	rjmp sound_driver_calculate_delays_dpcm
001449 95ba                      	dec r27
00144a 93b0 290c                 	sts noise_pattern_delay_rows, r27
00144c 11b2                      	cpse r27, zero
00144d c034                      	rjmp sound_driver_calculate_delays_noise_store
00144e 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_noise_Sxx:
00144f efbf                      	ldi r27, 0xFF
001450 91c0 2957                 	lds r28, noise_fx_Sxx_pre
001452 91d0 2958                 	lds r29, noise_fx_Sxx_post
                                 sound_driver_calculate_delays_noise_Sxx_check_pre:
001454 17cb                      	cp r28, r27
001455 f009                      	breq sound_driver_calculate_delays_noise_Sxx_check_post
001456 c00d                      	rjmp sound_driver_calculate_delays_noise_Sxx_pre
                                 sound_driver_calculate_delays_noise_Sxx_check_post:
001457 17db                      	cp r29, r27
001458 f009                      	breq sound_driver_calculate_delays_noise_Gxx
001459 c015                      	rjmp sound_driver_calculate_delays_noise_Sxx_post
                                 
                                 sound_driver_calculate_delays_noise_Gxx:
00145a 91c0 2947                 	lds r28, noise_fx_Gxx_pre
00145c 91d0 2948                 	lds r29, noise_fx_Gxx_post
                                 sound_driver_calculate_delays_noise_Gxx_check_pre:
00145e 17cb                      	cp r28, r27
00145f f009                      	breq sound_driver_calculate_delays_noise_Gxx_check_post
001460 c012                      	rjmp sound_driver_calculate_delays_noise_Gxx_pre
                                 sound_driver_calculate_delays_noise_Gxx_check_post:
001461 17db                      	cp r29, r27
001462 f0f9                      	breq sound_driver_calculate_delays_noise_store
001463 c01a                      	rjmp sound_driver_calculate_delays_noise_Gxx_post
                                 
                                 sound_driver_calculate_delays_noise_Sxx_pre:
001464 93b0 2957                 	sts noise_fx_Sxx_pre, r27
001466 1bec                      	sub r30, r28 //(song speed)-1-Sxx
001467 93e0 2958                 	sts noise_fx_Sxx_post, r30
001469 95ca                      	dec r28
00146a 93c0 290d                 	sts noise_pattern_delay_frames, r28
00146c 2fef                      	mov r30, r31
00146d 50e1                      	subi r30, 1
00146e c015                      	rjmp sound_driver_calculate_delays_dpcm
                                 
                                 sound_driver_calculate_delays_noise_Sxx_post:
00146f 93b0 2958                 	sts noise_fx_Sxx_post, r27
001471 2fad                      	mov r26, r29
001472 c00f                      	rjmp sound_driver_calculate_delays_noise_store
                                 
                                 sound_driver_calculate_delays_noise_Gxx_pre:
001473 93b0 2947                 	sts noise_fx_Gxx_pre, r27
001475 1bec                      	sub r30, r28 //(song speed)-1-Sxx
001476 93e0 2948                 	sts noise_fx_Gxx_post, r30
001478 95ca                      	dec r28
001479 93c0 290d                 	sts noise_pattern_delay_frames, r28
00147b 2fef                      	mov r30, r31
00147c 50e1                      	subi r30, 1
00147d c006                      	rjmp sound_driver_calculate_delays_dpcm
                                 	
                                 sound_driver_calculate_delays_noise_Gxx_post:
00147e 93b0 2948                 	sts noise_fx_Gxx_post, r27
001480 2fad                      	mov r26, r29
001481 c000                      	rjmp sound_driver_calculate_delays_noise_store
                                 
                                 sound_driver_calculate_delays_noise_store:
001482 93a0 290d                 	sts noise_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_dpcm:
                                 
                                 sound_driver_instrument_fx_routine:
                                 sound_driver_instrument_routine_channel0_volume:
001484 91e0 2828                 	lds ZL, pulse1_volume_macro
001486 91f0 2829                 	lds ZH, pulse1_volume_macro+1
001488 9630                      	adiw Z, 0
001489 f1a1                      	breq sound_driver_instrument_routine_channel0_volume_default //if no volume macro is in use, use default multiplier of F
00148a 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
00148b 1fff                      	rol ZH
00148c 91a0 282a                 	lds r26, pulse1_volume_macro_offset
00148e 0fea                      	add ZL, r26
00148f 1df2                      	adc ZH, zero
                                 
001490 91b0 282c                 	lds r27, pulse1_volume_macro_release
001492 17ba                      	cp r27, r26
001493 f429                      	brne sound_driver_instrument_routine_channel0_volume_increment //if the current offset is not equal to the release index, increment the offset
001494 91a0 282b                 	lds r26, pulse1_volume_macro_loop
001496 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
001497 f010                      	brlo sound_driver_instrument_routine_channel0_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
001498 c003                      	rjmp sound_driver_instrument_routine_channel0_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_volume_increment:
001499 95a3                      	inc r26 //increment the macro offset
00149a 93a0 282a                 	sts pulse1_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_volume_read:
00149c 91b4                      	lpm r27, Z //load volume data into r27
00149d 3fbf                      	cpi r27, 0xFF //check for macro end flag
00149e f469                      	brne sound_driver_instrument_routine_channel0_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_release:
00149f 91b0 282c                 	lds r27, pulse1_volume_macro_release
0014a1 3fbf                      	cpi r27, 0xFF
0014a2 f429                      	brne sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_loop:
0014a3 91b0 282b                 	lds r27, pulse1_volume_macro_loop //load the loop index
0014a5 93b0 282a                 	sts pulse1_volume_macro_offset, r27 //store the loop index into the offset
0014a7 cfdc                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index:
0014a8 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
0014a9 93a0 282a                 	sts pulse1_volume_macro_offset, r26
0014ab cfd8                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_calculate:
0014ac e3ee                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
0014ad e4f3                      	ldi ZH, HIGH(volumes << 1)
0014ae 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
0014af 0feb                      	add ZL, r27 //add offset to the table
0014b0 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel0_volume_load:
0014b1 91b0 2800                 	lds r27, pulse1_param //load main volume
0014b3 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
0014b4 91a0 285d                 	lds r26, pulse1_fx_7xy_value
0014b6 30a0                      	cpi r26, 0x00
0014b7 f481                      	brne sound_driver_instrument_routine_channel0_volume_load_7xy
                                 
0014b8 0feb                      	add ZL, r27 //offset the volume table by the main volume
0014b9 1df2                      	adc ZH, zero
0014ba 91b4                      	lpm r27, Z
0014bb 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
0014bd c024                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default:
0014be 91b0 2800                 	lds r27, pulse1_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
0014c0 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
0014c1 91a0 285d                 	lds r26, pulse1_fx_7xy_value
0014c3 30a0                      	cpi r26, 0x00
0014c4 f4a1                      	brne sound_driver_instrument_routine_channel0_volume_default_7xy
0014c5 93b0 2806                 	sts pulse1_output_volume, r27
0014c7 c01a                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy:
0014c8 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
0014c9 f040                      	brcs sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
0014ca f039                      	breq sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
0014cb e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
                                 
0014cc 0feb                      	add ZL, r27 //offset the volume table by the main volume
0014cd 1df2                      	adc ZH, zero
0014ce 91b4                      	lpm r27, Z
0014cf 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
0014d1 c010                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy_overflow:
0014d2 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
0014d3 0feb                      	add ZL, r27 //offset the volume table by the main volume
0014d4 1df2                      	adc ZH, zero
0014d5 91b4                      	lpm r27, Z
0014d6 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
0014d8 c009                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default_7xy:
0014d9 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
0014da f020                      	brcs sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
0014db f019                      	breq sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
0014dc 93b0 2806                 	sts pulse1_output_volume, r27
0014de c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel0_volume_default_7xy_overflow:
0014df e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
0014e0 93b0 2806                 	sts pulse1_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
0014e2 91e0 282d                 	lds ZL, pulse1_arpeggio_macro
0014e4 91f0 282e                 	lds ZH, pulse1_arpeggio_macro+1
0014e6 9630                      	adiw Z, 0
0014e7 f1d9                      	breq sound_driver_instrument_routine_channel0_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
0014e8 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0014e9 1fff                      	rol ZH
0014ea 91a0 282f                 	lds r26, pulse1_arpeggio_macro_offset
0014ec 0fea                      	add ZL, r26
0014ed 1df2                      	adc ZH, zero
                                 
0014ee 91b0 2831                 	lds r27, pulse1_arpeggio_macro_release
0014f0 17ba                      	cp r27, r26
0014f1 f429                      	brne sound_driver_instrument_routine_channel0_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
0014f2 91a0 2830                 	lds r26, pulse1_arpeggio_macro_loop
0014f4 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0014f5 f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
0014f6 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_increment:
0014f7 95a3                      	inc r26 //increment the macro offset
0014f8 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_read:
0014fa 91b4                      	lpm r27, Z //load arpeggio data into r27
0014fb 38b0                      	cpi r27, 0x80 //check for macro end flag
0014fc f009                      	breq sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag
0014fd c041                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_check_mode:
0014fe 50a1                      	subi r26, 1 //keep the offset at the end flag
0014ff 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26
001501 91b0 2832                 	lds r27, pulse1_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
001503 30b1                      	cpi r27, 0x01
001504 f048                      	brlo sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_release:
001505 91b0 2831                 	lds r27, pulse1_arpeggio_macro_release
001507 3fbf                      	cpi r27, 0xFF
001508 f4d1                      	brne sound_driver_instrument_routine_channel0_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_loop:
001509 91b0 2830                 	lds r27, pulse1_arpeggio_macro_loop
00150b 3fbf                      	cpi r27, 0xFF
00150c f499                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
00150d c015                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute:
00150e 91b0 2831                 	lds r27, pulse1_arpeggio_macro_release
001510 3fbf                      	cpi r27, 0xFF
001511 f421                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_check_loop:
001512 91b0 2830                 	lds r27, pulse1_arpeggio_macro_loop //load the loop index
001514 3fbf                      	cpi r27, 0xFF //check if loop flag exists
001515 f451                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop:
001516 91c0 2845                 	lds r28, pulse1_fx_0xy_sequence //check for 0xy effect
001518 91d0 2846                 	lds r29, pulse1_fx_0xy_sequence+1
00151a 9620                      	adiw r29:r28, 0
00151b f469                      	brne sound_driver_instrument_routine_channel0_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
00151c 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
00151d 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26 //store the last valid index into the offset
00151f cfc2                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload:
001520 93b0 282f                 	sts pulse1_arpeggio_macro_offset, r27 //store the loop index into the offset
001522 cfbf                      	rjmp sound_driver_instrument_routine_channel0_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_default:
001523 91c0 2845                 	lds r28, pulse1_fx_0xy_sequence //load 0xy effect
001525 91d0 2846                 	lds r29, pulse1_fx_0xy_sequence+1
001527 9620                      	adiw r29:r28, 0 //check for 0xy effect
001528 f099                      	breq sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel0_arpeggio_default_xy:
001529 95d6                      	lsr r29
00152a 95c7                      	ror r28
00152b 95d7                      	ror r29
00152c 95c7                      	ror r28
00152d 95d7                      	ror r29
00152e 95c7                      	ror r28
00152f 95d7                      	ror r29
001530 95c7                      	ror r28
001531 95d7                      	ror r29
001532 95d2                      	swap r29
                                 
001533 93c0 2845                 	sts pulse1_fx_0xy_sequence, r28 //store the rolled sequence
001535 93d0 2846                 	sts pulse1_fx_0xy_sequence+1, r29
001537 70cf                      	andi r28, 0x0F //mask out the 4 LSB
001538 91a0 2807                 	lds r26, pulse1_note //load the current note index
00153a 0fac                      	add r26, r28 //add the note offset
00153b c02e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
00153c 91a0 2807                 	lds r26, pulse1_note //load the current note index
00153e c02b                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process:
00153f 9220 2833                 	sts pulse1_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
001541 9220 2834                 	sts pulse1_total_pitch_offset+1, zero
001543 9220 283a                 	sts pulse1_total_hi_pitch_offset, zero
001545 91a0 2832                 	lds r26, pulse1_arpeggio_macro_mode
001547 30a1                      	cpi r26, 0x01 //absolute mode
001548 f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_absolute
001549 f069                      	breq sound_driver_instrument_routine_channel0_arpeggio_process_fixed
00154a c00e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute:
00154b 91a0 2807                 	lds r26, pulse1_note //load the current note index
00154d 0fab                      	add r26, r27 //offset the note with the arpeggio data
00154e fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
00154f c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_add:
001550 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
001551 f0c0                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
001552 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
001553 c016                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract:
001554 fda7                      	sbrc r26, 7 //check if result is negative
001555 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
001556 c013                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_fixed:
001557 2fab                      	mov r26, r27 //move the arpeggio data into r26
001558 c011                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative:
001559 91a0 2807                 	lds r26, pulse1_note //load the current note index
00155b 0fab                      	add r26, r27 //offset the note with the arpeggio data
00155c fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
00155d c008                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_add:
00155e 93a0 2807                 	sts pulse1_note, r26 //NOTE: relative mode modifies the original note index
001560 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
001561 f040                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
001562 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
001563 93a0 2807                 	sts pulse1_note, r26
001565 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract:
001566 fda7                      	sbrc r26, 7 //check if result is negative
001567 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
001568 93a0 2807                 	sts pulse1_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_load:
00156a e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
00156b e0f0                      	ldi ZH, HIGH(note_table << 1)
00156c 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
00156d 0fea                      	add ZL, r26 //add offset
00156e 1df2                      	adc ZH, zero
00156f 91a5                      	lpm r26, Z+ //load bytes
001570 91b4                      	lpm r27, Z
001571 93a0 0a8c                 	sts TCB0_CCMPL, r26 //load the LOW bits for timer
001573 93b0 0a8d                 	sts TCB0_CCMPH, r27 //load the HIGH bits for timer
001575 93a0 2851                 	sts pulse1_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
001577 93b0 2852                 	sts pulse1_fx_3xx_target+1, r27
001579 c000                      	rjmp sound_driver_instrument_routine_channel0_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch:
00157a 91e0 2835                 	lds ZL, pulse1_pitch_macro
00157c 91f0 2836                 	lds ZH, pulse1_pitch_macro+1
00157e 9630                      	adiw Z, 0
00157f f409                      	brne sound_driver_instrument_routine_channel0_pitch_continue
001580 c023                      	rjmp sound_driver_instrument_routine_channel0_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel0_pitch_continue:
001581 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
001582 1fff                      	rol ZH
001583 91a0 2837                 	lds r26, pulse1_pitch_macro_offset
001585 0fea                      	add ZL, r26
001586 1df2                      	adc ZH, zero
                                 
001587 91b0 2839                 	lds r27, pulse1_pitch_macro_release
001589 17ba                      	cp r27, r26
00158a f429                      	brne sound_driver_instrument_routine_channel0_pitch_increment //if the current offset is not equal to the release index, increment the offset
00158b 91a0 2838                 	lds r26, pulse1_pitch_macro_loop
00158d 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00158e f010                      	brlo sound_driver_instrument_routine_channel0_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00158f c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_pitch_increment:
001590 95a3                      	inc r26 //increment the macro offset
001591 93a0 2837                 	sts pulse1_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_pitch_read:
001593 91b4                      	lpm r27, Z //load pitch data into r27
001594 38b0                      	cpi r27, 0x80 //check for macro end flag
001595 f479                      	brne sound_driver_instrument_routine_channel0_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_release:
001596 50a1                      	subi r26, 1 //keep the macro offset at the end flag
001597 93a0 2837                 	sts pulse1_pitch_macro_offset, r26
001599 91b0 2839                 	lds r27, pulse1_pitch_macro_release
00159b 3fbf                      	cpi r27, 0xFF
00159c f439                      	brne sound_driver_instrument_routine_channel0_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_loop:
00159d 91b0 2838                 	lds r27, pulse1_pitch_macro_loop //load the loop index
00159f 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0015a0 f019                      	breq sound_driver_instrument_routine_channel0_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
0015a1 93b0 2837                 	sts pulse1_pitch_macro_offset, r27 //store the loop index into the offset
0015a3 cfd6                      	rjmp sound_driver_instrument_routine_channel0_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_default:
0015a4 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel0_pitch_calculate:
0015a5 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0015a6 937f                      	push r23
0015a7 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
0015a8 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0015a9 0367                      	mulsu r22, r23
0015aa 917f                      	pop r23
0015ab 916f                      	pop r22
                                 
0015ac 9416                      	lsr r1 //shift out the fractional bits
0015ad 9407                      	ror r0
0015ae 9416                      	lsr r1
0015af 9407                      	ror r0
0015b0 9416                      	lsr r1
0015b1 9407                      	ror r0
0015b2 9416                      	lsr r1
0015b3 9407                      	ror r0
0015b4 fe13                      	sbrs r1, 3 //check if result was a negative number
0015b5 c002                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_negative:
0015b6 efb0                      	ldi r27, 0xF0
0015b7 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_offset:
0015b8 91a0 2833                 	lds r26, pulse1_total_pitch_offset
0015ba 91b0 2834                 	lds r27, pulse1_total_pitch_offset+1
0015bc 0e0a                      	add r0, r26
0015bd 1e1b                      	adc r1, r27
0015be 9200 2833                 	sts pulse1_total_pitch_offset, r0
0015c0 9210 2834                 	sts pulse1_total_pitch_offset+1, r1
0015c2 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
0015c4 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
0015c6 0da0                      	add r26, r0 //offset the timer values
0015c7 1db1                      	adc r27, r1
                                 	
0015c8 91c0 2849                 	lds r28, pulse1_fx_1xx_total
0015ca 91d0 284a                 	lds r29, pulse1_fx_1xx_total+1
0015cc 1bac                      	sub r26, r28
0015cd 0bbd                      	sbc r27, r29
0015ce 91c0 284d                 	lds r28, pulse1_fx_2xx_total
0015d0 91d0 284e                 	lds r29, pulse1_fx_2xx_total+1
0015d2 0fac                      	add r26, r28
0015d3 1fbd                      	adc r27, r29
0015d4 91c0 2861                 	lds r28, pulse1_fx_Pxx_total
0015d6 91d0 2862                 	lds r29, pulse1_fx_Pxx_total+1
0015d8 0fac                      	add r26, r28
0015d9 1fbd                      	adc r27, r29
0015da 91c0 2867                 	lds r28, pulse1_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
0015dc 91d0 2868                 	lds r29, pulse1_fx_Qxy_total_offset+1
0015de 1bac                      	sub r26, r28
0015df 0bbd                      	sbc r27, r29
0015e0 91c0 286d                 	lds r28, pulse1_fx_Rxy_total_offset
0015e2 91d0 286e                 	lds r29, pulse1_fx_Rxy_total_offset+1
0015e4 0fac                      	add r26, r28
0015e5 1fbd                      	adc r27, r29
                                 
0015e6 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
0015e8 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel0_hi_pitch:
0015ea 91e0 283b                 	lds ZL, pulse1_hi_pitch_macro
0015ec 91f0 283c                 	lds ZH, pulse1_hi_pitch_macro+1
0015ee 9630                      	adiw Z, 0
0015ef f409                      	brne sound_driver_instrument_routine_channel0_hi_pitch_continue
0015f0 c03c                      	rjmp sound_driver_instrument_routine_channel0_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel0_hi_pitch_continue:
0015f1 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0015f2 1fff                      	rol ZH
0015f3 91a0 283d                 	lds r26, pulse1_hi_pitch_macro_offset
0015f5 0fea                      	add ZL, r26
0015f6 1df2                      	adc ZH, zero
                                 
0015f7 91b0 283f                 	lds r27, pulse1_hi_pitch_macro_release
0015f9 17ba                      	cp r27, r26
0015fa f429                      	brne sound_driver_instrument_routine_channel0_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
0015fb 91a0 283e                 	lds r26, pulse1_hi_pitch_macro_loop
0015fd 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0015fe f010                      	brlo sound_driver_instrument_routine_channel0_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0015ff c003                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_increment:
001600 95a3                      	inc r26 //increment the macro offset
001601 93a0 283d                 	sts pulse1_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_hi_pitch_read:
001603 91b4                      	lpm r27, Z //load hi pitch data into r27
001604 38b0                      	cpi r27, 0x80 //check for macro end flag
001605 f489                      	brne sound_driver_instrument_routine_channel0_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_release:
001606 50a1                      	subi r26, 1 //keep the macro offset at the end flag
001607 93a0 283d                 	sts pulse1_hi_pitch_macro_offset, r26
001609 91b0 283f                 	lds r27, pulse1_hi_pitch_macro_release
00160b 3fbf                      	cpi r27, 0xFF
00160c f439                      	brne sound_driver_instrument_routine_channel0_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_loop:
00160d 91b0 283e                 	lds r27, pulse1_hi_pitch_macro_loop //load the loop index
00160f 3fbf                      	cpi r27, 0xFF //check if there is a loop index
001610 f019                      	breq sound_driver_instrument_routine_channel0_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
001611 93b0 283d                 	sts pulse1_hi_pitch_macro_offset, r27 //store the loop index into the offset
001613 cfd6                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_default:
001614 91b0 283a                 	lds r27, pulse1_total_hi_pitch_offset
001616 c005                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate:
001617 91a0 283a                 	lds r26, pulse1_total_hi_pitch_offset //load the total hi pitch offset to change
001619 0fba                      	add r27, r26
00161a 93b0 283a                 	sts pulse1_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply:
00161c 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00161d 937f                      	push r23
00161e 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
00161f eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001620 0367                      	mulsu r22, r23
001621 917f                      	pop r23
001622 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_offset:
001623 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
001625 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
001627 0da0                      	add r26, r0 //offset the timer values
001628 1db1                      	adc r27, r1
001629 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
00162b 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel0_duty:
00162d 91e0 2840                 	lds ZL, pulse1_duty_macro
00162f 91f0 2841                 	lds ZH, pulse1_duty_macro+1
001631 9630                      	adiw Z, 0
001632 f1b1                      	breq sound_driver_channel0_fx_routines //if no duty macro is in use, go to the next routine
001633 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
001634 1fff                      	rol ZH
001635 91a0 2842                 	lds r26, pulse1_duty_macro_offset
001637 0fea                      	add ZL, r26
001638 1df2                      	adc ZH, zero
                                 
001639 91b0 2844                 	lds r27, pulse1_duty_macro_release
00163b 17ba                      	cp r27, r26
00163c f429                      	brne sound_driver_instrument_routine_channel0_duty_increment //if the current offset is not equal to the release index, increment the offset
00163d 91a0 2843                 	lds r26, pulse1_duty_macro_loop
00163f 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
001640 f010                      	brlo sound_driver_instrument_routine_channel0_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
001641 c027                      	rjmp sound_driver_channel0_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel0_duty_increment:
001642 95a3                      	inc r26 //increment the macro offset
001643 93a0 2842                 	sts pulse1_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_duty_read:
001645 91b4                      	lpm r27, Z //load pitch data into r27
001646 3fbf                      	cpi r27, 0xFF //check for macro end flag
001647 f471                      	brne sound_driver_instrument_routine_channel0_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_release:
001648 50a1                      	subi r26, 1 //keep the macro offset at the end flag
001649 93a0 2842                 	sts pulse1_duty_macro_offset, r26
00164b 91b0 2844                 	lds r27, pulse1_duty_macro_release
00164d 3fbf                      	cpi r27, 0xFF
00164e f4d1                      	brne sound_driver_channel0_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_loop:
00164f 91b0 2843                 	lds r27, pulse1_duty_macro_loop //load the loop index
001651 3fbf                      	cpi r27, 0xFF //check if there is a loop index
001652 f0b1                      	breq sound_driver_channel0_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
001653 93b0 2842                 	sts pulse1_duty_macro_offset, r27 //store the loop index into the offset
001655 cfd7                      	rjmp sound_driver_instrument_routine_channel0_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_load:
001656 e6ea                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
001657 e4f2                      	ldi ZH, HIGH(sequences << 1)
001658 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
001659 1df2                      	adc ZH, zero
                                 
00165a 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
00165b 95b7                      	ror r27
00165c 95b7                      	ror r27
00165d 91a0 2800                 	lds r26, pulse1_param //load r26 with pulse1_param (register $4000)
00165f 2fca                      	mov r28, r26 //store a copy of pulse1_param into r28
001660 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
001661 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
001662 c001                      	rjmp sound_driver_instrument_routine_channel0_duty_load_store
001663 c005                      	rjmp sound_driver_channel0_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel0_duty_load_store:
001664 90a4                      	lpm pulse1_sequence, Z //store the sequence
                                 
001665 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
001666 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
001667 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_routines:
                                 sound_driver_channel0_fx_1xx_routine:
001669 91e0 2847                 	lds ZL, pulse1_fx_1xx
00166b 91f0 2848                 	lds ZH, pulse1_fx_1xx+1
00166d 9630                      	adiw Z, 0
00166e f051                      	breq sound_driver_channel0_fx_2xx_routine
                                 
00166f 91a0 2849                 	lds r26, pulse1_fx_1xx_total //load the rate to change the pitch by
001671 91b0 284a                 	lds r27, pulse1_fx_1xx_total+1
001673 0fae                      	add r26, ZL //increase the total offset by the rate
001674 1fbf                      	adc r27, ZH
001675 93a0 2849                 	sts pulse1_fx_1xx_total, r26
001677 93b0 284a                 	sts pulse1_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_2xx_routine:
001679 91e0 284b                 	lds ZL, pulse1_fx_2xx
00167b 91f0 284c                 	lds ZH, pulse1_fx_2xx+1
00167d 9630                      	adiw Z, 0
00167e f051                      	breq sound_driver_channel0_fx_3xx_routine
                                 
00167f 91a0 284d                 	lds r26, pulse1_fx_2xx_total //load the rate to change the pitch by
001681 91b0 284e                 	lds r27, pulse1_fx_2xx_total+1
001683 0fae                      	add r26, ZL //increase the total offset by the rate
001684 1fbf                      	adc r27, ZH
001685 93a0 284d                 	sts pulse1_fx_2xx_total, r26
001687 93b0 284e                 	sts pulse1_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_3xx_routine:
001689 91e0 2853                 	lds ZL, pulse1_fx_3xx_speed
00168b 91f0 2854                 	lds ZH, pulse1_fx_3xx_speed+1
00168d 9630                      	adiw Z, 0
00168e f409                      	brne sound_driver_channel0_fx_3xx_routine_check_start
00168f c048                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_check_start:
001690 91a0 284f                 	lds r26, pulse1_fx_3xx_start
001692 91b0 2850                 	lds r27, pulse1_fx_3xx_start+1
001694 9610                      	adiw r26:r27, 0
001695 f409                      	brne sound_driver_channel0_fx_3xx_routine_main
001696 c041                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_main:
001697 91c0 2851                 	lds r28, pulse1_fx_3xx_target
001699 91d0 2852                 	lds r29, pulse1_fx_3xx_target+1
                                 
00169b 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
00169c 07bd                      	cpc r27, r29
00169d f011                      	breq sound_driver_channel0_fx_3xx_routine_disable
00169e f030                      	brlo sound_driver_channel0_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
00169f c01f                      	rjmp sound_driver_channel0_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel0_fx_3xx_routine_disable:
0016a0 9220 284f                 	sts pulse1_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
0016a2 9220 2850                 	sts pulse1_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
0016a4 c033                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_subtract:
0016a5 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
0016a6 0bdb                      	sbc r29, r27
0016a7 91a0 2855                 	lds r26, pulse1_fx_3xx_total_offset
0016a9 91b0 2856                 	lds r27, pulse1_fx_3xx_total_offset+1
                                 
0016ab 0fae                      	add r26, ZL //add the speed to the total offset
0016ac 1fbf                      	adc r27, ZH
0016ad 1bca                      	sub r28, r26 //invert the total difference with the total offset
0016ae 0bdb                      	sbc r29, r27
0016af f380                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0016b0 93a0 2855                 	sts pulse1_fx_3xx_total_offset, r26 //store the new total offset
0016b2 93b0 2856                 	sts pulse1_fx_3xx_total_offset+1, r27
                                 
0016b4 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the current timer period
0016b6 91b0 0a8d                 	lds r27, TCB0_CCMPH
0016b8 1bac                      	sub r26, r28 //offset the current timer period with the total offset
0016b9 0bbd                      	sbc r27, r29
0016ba 93a0 0a8c                 	sts TCB0_CCMPL, r26
0016bc 93b0 0a8d                 	sts TCB0_CCMPH, r27
0016be c019                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_add:
0016bf 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
0016c0 0bbd                      	sbc r27, r29
0016c1 91c0 2855                 	lds r28, pulse1_fx_3xx_total_offset
0016c3 91d0 2856                 	lds r29, pulse1_fx_3xx_total_offset+1
                                 
0016c5 0fce                      	add r28, ZL //add the speed to the total offset
0016c6 1fdf                      	adc r29, ZH
0016c7 1bac                      	sub r26, r28 //invert the total difference with the total offset
0016c8 0bbd                      	sbc r27, r29
0016c9 f2b0                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0016ca 93c0 2855                 	sts pulse1_fx_3xx_total_offset, r28 //store the new total offset
0016cc 93d0 2856                 	sts pulse1_fx_3xx_total_offset+1, r29
                                 
0016ce 91c0 0a8c                 	lds r28, TCB0_CCMPL //load the current timer period
0016d0 91d0 0a8d                 	lds r29, TCB0_CCMPH
0016d2 0fca                      	add r28, r26 //offset the current timer period with the total offset
0016d3 1fdb                      	adc r29, r27
0016d4 93c0 0a8c                 	sts TCB0_CCMPL, r28
0016d6 93d0 0a8d                 	sts TCB0_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel0_fx_4xy_routine:
0016d8 91a0 2857                 	lds r26, pulse1_fx_4xy_speed
0016da 15a2                      	cp r26, zero
0016db f409                      	brne sound_driver_channel0_fx_4xy_routine_continue
0016dc c05c                      	rjmp sound_driver_channel0_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel0_fx_4xy_routine_continue:
0016dd 91b0 2858                 	lds r27, pulse1_fx_4xy_depth
0016df 91c0 2859                 	lds r28, pulse1_fx_4xy_phase
0016e1 0fca                      	add r28, r26 //increase the phase by the speed
0016e2 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
0016e3 f008                      	brlo sound_driver_channel0_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
0016e4 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase:
0016e5 93c0 2859                 	sts pulse1_fx_4xy_phase, r28 //store the new phase
0016e7 31c0                      	cpi r28, 16
0016e8 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_0
0016e9 32c0                      	cpi r28, 32
0016ea f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_1
0016eb 33c0                      	cpi r28, 48
0016ec f030                      	brlo sound_driver_channel0_fx_4xy_routine_phase_2
0016ed c007                      	rjmp sound_driver_channel0_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_0:
0016ee 70cf                      	andi r28, 0x0F //mask for values 0-15
0016ef c029                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_1:
0016f0 6fc0                      	ori r28, 0xF0
0016f1 95c0                      	com r28 //invert values 0-15
0016f2 c026                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_2:
0016f3 70cf                      	andi r28, 0x0F //mask for values 0-15
0016f4 c003                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_3:
0016f5 6fc0                      	ori r28, 0xF0
0016f6 95c0                      	com r28 //invert values 0-15
0016f7 c000                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_add:
0016f8 95b2                      	swap r27 //multiply depth by 16
0016f9 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0016fa e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0016fb e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0016fc 0fec                      	add ZL, r28 //offset the table by the depth+phase
0016fd 1df2                      	adc ZH, zero
0016fe 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
0016ff 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001700 937f                      	push r23
001701 2f6c                      	mov r22, r28 //store the vibrato value into r22
001702 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001703 9f67                      	mul r22, r23
001704 917f                      	pop r23
001705 916f                      	pop r22
                                 
001706 9416                      	lsr r1 //shift out the fractional bits
001707 9407                      	ror r0
001708 9416                      	lsr r1
001709 9407                      	ror r0
00170a 9416                      	lsr r1
00170b 9407                      	ror r0
00170c 9416                      	lsr r1
00170d 9407                      	ror r0
                                 	
00170e 91a0 0a8c                 	lds r26, TCB0_CCMPL
001710 91b0 0a8d                 	lds r27, TCB0_CCMPH
001712 0da0                      	add r26, r0
001713 1db1                      	adc r27, r1
001714 93a0 0a8c                 	sts TCB0_CCMPL, r26
001716 93b0 0a8d                 	sts TCB0_CCMPH, r27
001718 c020                      	rjmp sound_driver_channel0_fx_7xy_routine
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_subtract:
001719 95b2                      	swap r27 //multiply depth by 16
00171a 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
00171b e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00171c e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00171d 0fec                      	add ZL, r28 //offset the table by the depth+phase
00171e 1df2                      	adc ZH, zero
00171f 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
001720 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001721 937f                      	push r23
001722 2f6c                      	mov r22, r28 //store the vibrato value into r22
001723 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001724 9f67                      	mul r22, r23
001725 917f                      	pop r23
001726 916f                      	pop r22
                                 
001727 9416                      	lsr r1 //shift out the fractional bits
001728 9407                      	ror r0
001729 9416                      	lsr r1
00172a 9407                      	ror r0
00172b 9416                      	lsr r1
00172c 9407                      	ror r0
00172d 9416                      	lsr r1
00172e 9407                      	ror r0
                                 
00172f 91a0 0a8c                 	lds r26, TCB0_CCMPL
001731 91b0 0a8d                 	lds r27, TCB0_CCMPH
001733 19a0                      	sub r26, r0
001734 09b1                      	sbc r27, r1
001735 93a0 0a8c                 	sts TCB0_CCMPL, r26
001737 93b0 0a8d                 	sts TCB0_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_7xy_routine:
001739 91a0 285a                 	lds r26, pulse1_fx_7xy_speed
00173b 15a2                      	cp r26, zero
00173c f0f1                      	breq sound_driver_channel0_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
00173d 91b0 285b                 	lds r27, pulse1_fx_7xy_depth
00173f 91c0 285c                 	lds r28, pulse1_fx_7xy_phase
001741 0fca                      	add r28, r26 //increase the phase by the speed
001742 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
001743 f010                      	brlo sound_driver_channel0_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
001744 e0c0                      	ldi r28, 0x00
001745 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase:
001746 93c0 285c                 	sts pulse1_fx_7xy_phase, r28 //store the new phase
001748 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
001749 ffc4                      	sbrs r28, 4
00174a c001                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_0
00174b c002                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel0_fx_7xy_routine_phase_0:
00174c 70cf                      	andi r28, 0x0F //mask for values 0-15
00174d c003                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase_1:
00174e 6fc0                      	ori r28, 0xF0
00174f 95c0                      	com r28 //invert values 0-15
001750 c000                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_load:
001751 95b2                      	swap r27 //multiply depth by 16
001752 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
001753 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
001754 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
001755 0fec                      	add ZL, r28 //offset the table by the depth+phase
001756 1df2                      	adc ZH, zero
001757 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
001758 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
001759 93c0 285d                 	sts pulse1_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Axy_routine:
00175b 91b0 285e                 	lds r27, pulse1_fx_Axy
00175d 15b2                      	cp r27, zero
00175e f0e9                      	breq sound_driver_channel0_fx_Qxy_routine //0 means that the effect is not in use
                                 	
00175f 91a0 2805                 	lds r26, pulse1_fractional_volume //load fractional volume representation of the channel
001761 91c0 2800                 	lds r28, pulse1_param //load the integer volume representation of the channel
001763 2fda                      	mov r29, r26 //copy fractional volume into r29
001764 2fec                      	mov r30, r28 //copy the pulse1_param into r30
001765 95e2                      	swap r30
001766 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
001767 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
001768 17ed                      	cp r30, r29 //compare the fractional and integer volumes
001769 f009                      	breq sound_driver_channel0_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel0_fx_Axy_routine_reload:
00176a 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate:
00176b fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
00176c c004                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_addition:
00176d 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
00176e f428                      	brcc sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
00176f efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
001770 c003                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_subtraction:
001771 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
001772 f008                      	brcs sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
001773 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_store:
001774 93a0 2805                 	sts pulse1_fractional_volume, r26 //store the new fractional volume
001776 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
001777 95a2                      	swap r26
001778 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
001779 2bca                      	or r28, r26 //store the new volume back into pulse1_param
00177a 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel0_fx_Qxy_routine:
00177c 91e0 2863                 	lds ZL, pulse1_fx_Qxy_target
00177e 91f0 2864                 	lds ZH, pulse1_fx_Qxy_target+1
001780 9630                      	adiw Z, 0
001781 f139                      	breq sound_driver_channel0_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
001782 91a0 2867                 	lds r26, pulse1_fx_Qxy_total_offset
001784 91b0 2868                 	lds r27, pulse1_fx_Qxy_total_offset+1
001786 91c0 0a8c                 	lds r28, TCB0_CCMPL
001788 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
00178a 1bec                      	sub ZL, r28 //calculate the difference to the target
00178b 0bfd                      	sbc ZH, r29
00178c f408                      	brsh sound_driver_channel0_fx_Qxy_routine_end //if the target has been reached (or passed)
00178d f088                      	brlo sound_driver_channel0_fx_Qxy_routine_add
                                 
                                 sound_driver_channel0_fx_Qxy_routine_end:
00178e 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
00178f 0bbf                      	sbc r27, ZH
                                 
001790 91c0 2861                 	lds r28, pulse1_fx_Pxx_total
001792 91d0 2862                 	lds r29, pulse1_fx_Pxx_total+1
                                 
001794 0fac                      	add r26, r28
001795 1fbd                      	adc r27, r29
                                 
001796 93a0 2867                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
001798 93b0 2868                 	sts pulse1_fx_Qxy_total_offset+1, r27
00179a 9220 2863                 	sts pulse1_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
00179c 9220 2864                 	sts pulse1_fx_Qxy_target+1, zero
00179e c00a                      	rjmp sound_driver_channel0_fx_Rxy_routine
                                 
                                 sound_driver_channel0_fx_Qxy_routine_add:
00179f 91c0 2865                 	lds r28, pulse1_fx_Qxy_speed
0017a1 91d0 2866                 	lds r29, pulse1_fx_Qxy_speed+1
0017a3 0fac                      	add r26, r28 //increase the total offset by the speed
0017a4 1fbd                      	adc r27, r29
0017a5 93a0 2867                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
0017a7 93b0 2868                 	sts pulse1_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Rxy_routine:
0017a9 91e0 2869                 	lds ZL, pulse1_fx_Rxy_target
0017ab 91f0 286a                 	lds ZH, pulse1_fx_Rxy_target+1
0017ad 9630                      	adiw Z, 0
0017ae f139                      	breq sound_driver_instrument_routine_channel1_volume //if the effect is not enabled, skip the routine
                                 
0017af 91a0 286d                 	lds r26, pulse1_fx_Rxy_total_offset
0017b1 91b0 286e                 	lds r27, pulse1_fx_Rxy_total_offset+1
0017b3 91c0 0a8c                 	lds r28, TCB0_CCMPL
0017b5 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
0017b7 1bce                      	sub r28, ZL //calculate the difference to the target
0017b8 0bdf                      	sbc r29, ZH
0017b9 f408                      	brsh sound_driver_channel0_fx_Rxy_routine_end //if the target has been reached (or passed)
0017ba f088                      	brlo sound_driver_channel0_fx_Rxy_routine_add
                                 
                                 sound_driver_channel0_fx_Rxy_routine_end:
0017bb 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
0017bc 0bbd                      	sbc r27, r29
                                 
0017bd 91c0 2861                 	lds r28, pulse1_fx_Pxx_total
0017bf 91d0 2862                 	lds r29, pulse1_fx_Pxx_total+1
                                 
0017c1 0fac                      	add r26, r28
0017c2 1fbd                      	adc r27, r29
                                 
0017c3 93a0 286d                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
0017c5 93b0 286e                 	sts pulse1_fx_Rxy_total_offset+1, r27
0017c7 9220 2869                 	sts pulse1_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
0017c9 9220 286a                 	sts pulse1_fx_Rxy_target+1, zero
0017cb c00a                      	rjmp sound_driver_instrument_routine_channel1_volume
                                 
                                 sound_driver_channel0_fx_Rxy_routine_add:
0017cc 91c0 286b                 	lds r28, pulse1_fx_Rxy_speed
0017ce 91d0 286c                 	lds r29, pulse1_fx_Rxy_speed+1
0017d0 0fac                      	add r26, r28 //increase the total offset by the speed
0017d1 1fbd                      	adc r27, r29
0017d2 93a0 286d                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
0017d4 93b0 286e                 	sts pulse1_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume:
0017d6 91e0 2877                 	lds ZL, pulse2_volume_macro
0017d8 91f0 2878                 	lds ZH, pulse2_volume_macro+1
0017da 9630                      	adiw Z, 0
0017db f1a1                      	breq sound_driver_instrument_routine_channel1_volume_default //if no volume macro is in use, use default multiplier of F
0017dc 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0017dd 1fff                      	rol ZH
0017de 91a0 2879                 	lds r26, pulse2_volume_macro_offset
0017e0 0fea                      	add ZL, r26
0017e1 1df2                      	adc ZH, zero
                                 
0017e2 91b0 287b                 	lds r27, pulse2_volume_macro_release
0017e4 17ba                      	cp r27, r26
0017e5 f429                      	brne sound_driver_instrument_routine_channel1_volume_increment //if the current offset is not equal to the release index, increment the offset
0017e6 91a0 287a                 	lds r26, pulse2_volume_macro_loop
0017e8 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0017e9 f010                      	brlo sound_driver_instrument_routine_channel1_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0017ea c003                      	rjmp sound_driver_instrument_routine_channel1_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_volume_increment:
0017eb 95a3                      	inc r26 //increment the macro offset
0017ec 93a0 2879                 	sts pulse2_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_volume_read:
0017ee 91b4                      	lpm r27, Z //load volume data into r27
0017ef 3fbf                      	cpi r27, 0xFF //check for macro end flag
0017f0 f469                      	brne sound_driver_instrument_routine_channel1_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_release:
0017f1 91b0 287b                 	lds r27, pulse2_volume_macro_release
0017f3 3fbf                      	cpi r27, 0xFF
0017f4 f429                      	brne sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_loop:
0017f5 91b0 287a                 	lds r27, pulse2_volume_macro_loop //load the loop index
0017f7 93b0 2879                 	sts pulse2_volume_macro_offset, r27 //store the loop index into the offset
0017f9 cfdc                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index:
0017fa 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
0017fb 93a0 2879                 	sts pulse2_volume_macro_offset, r26
0017fd cfd8                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_calculate:
0017fe e3ee                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
0017ff e4f3                      	ldi ZH, HIGH(volumes << 1)
001800 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
001801 0feb                      	add ZL, r27 //add offset to the table
001802 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel1_volume_load:
001803 91b0 2808                 	lds r27, pulse2_param //load main volume
001805 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
001806 91a0 28ac                 	lds r26, pulse2_fx_7xy_value
001808 30a0                      	cpi r26, 0x00
001809 f481                      	brne sound_driver_instrument_routine_channel1_volume_load_7xy
                                 
00180a 0feb                      	add ZL, r27 //offset the volume table by the main volume
00180b 1df2                      	adc ZH, zero
00180c 91b4                      	lpm r27, Z
00180d 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
00180f c024                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default:
001810 91b0 2808                 	lds r27, pulse2_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
001812 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
001813 91a0 28ac                 	lds r26, pulse2_fx_7xy_value
001815 30a0                      	cpi r26, 0x00
001816 f4a1                      	brne sound_driver_instrument_routine_channel1_volume_default_7xy
001817 93b0 280e                 	sts pulse2_output_volume, r27
001819 c01a                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy:
00181a 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
00181b f040                      	brcs sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
00181c f039                      	breq sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
00181d e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
                                 
00181e 0feb                      	add ZL, r27 //offset the volume table by the main volume
00181f 1df2                      	adc ZH, zero
001820 91b4                      	lpm r27, Z
001821 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
001823 c010                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy_overflow:
001824 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
001825 0feb                      	add ZL, r27 //offset the volume table by the main volume
001826 1df2                      	adc ZH, zero
001827 91b4                      	lpm r27, Z
001828 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
00182a c009                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default_7xy:
00182b 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
00182c f020                      	brcs sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
00182d f019                      	breq sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
00182e 93b0 280e                 	sts pulse2_output_volume, r27
001830 c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel1_volume_default_7xy_overflow:
001831 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
001832 93b0 280e                 	sts pulse2_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
001834 91e0 287c                 	lds ZL, pulse2_arpeggio_macro
001836 91f0 287d                 	lds ZH, pulse2_arpeggio_macro+1
001838 9630                      	adiw Z, 0
001839 f1d9                      	breq sound_driver_instrument_routine_channel1_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
00183a 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
00183b 1fff                      	rol ZH
00183c 91a0 287e                 	lds r26, pulse2_arpeggio_macro_offset
00183e 0fea                      	add ZL, r26
00183f 1df2                      	adc ZH, zero
                                 
001840 91b0 2880                 	lds r27, pulse2_arpeggio_macro_release
001842 17ba                      	cp r27, r26
001843 f429                      	brne sound_driver_instrument_routine_channel1_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
001844 91a0 287f                 	lds r26, pulse2_arpeggio_macro_loop
001846 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
001847 f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
001848 c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_increment:
001849 95a3                      	inc r26 //increment the macro offset
00184a 93a0 287e                 	sts pulse2_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_read:
00184c 91b4                      	lpm r27, Z //load arpeggio data into r27
00184d 38b0                      	cpi r27, 0x80 //check for macro end flag
00184e f009                      	breq sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag
00184f c041                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_check_mode:
001850 50a1                      	subi r26, 1 //keep the offset at the end flag
001851 93a0 287e                 	sts pulse2_arpeggio_macro_offset, r26
001853 91b0 2881                 	lds r27, pulse2_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
001855 30b1                      	cpi r27, 0x01
001856 f048                      	brlo sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_release:
001857 91b0 2880                 	lds r27, pulse2_arpeggio_macro_release
001859 3fbf                      	cpi r27, 0xFF
00185a f4d1                      	brne sound_driver_instrument_routine_channel1_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_loop:
00185b 91b0 287f                 	lds r27, pulse2_arpeggio_macro_loop
00185d 3fbf                      	cpi r27, 0xFF
00185e f499                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
00185f c015                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute:
001860 91b0 2880                 	lds r27, pulse2_arpeggio_macro_release
001862 3fbf                      	cpi r27, 0xFF
001863 f421                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_check_loop:
001864 91b0 287f                 	lds r27, pulse2_arpeggio_macro_loop //load the loop index
001866 3fbf                      	cpi r27, 0xFF //check if loop flag exists
001867 f451                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop:
001868 91c0 2894                 	lds r28, pulse2_fx_0xy_sequence //check for 0xy effect
00186a 91d0 2895                 	lds r29, pulse2_fx_0xy_sequence+1
00186c 9620                      	adiw r29:r28, 0
00186d f469                      	brne sound_driver_instrument_routine_channel1_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
00186e 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
00186f 93a0 287e                 	sts pulse2_arpeggio_macro_offset, r26 //store the last valid index into the offset
001871 cfc2                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload:
001872 93b0 287e                 	sts pulse2_arpeggio_macro_offset, r27 //store the loop index into the offset
001874 cfbf                      	rjmp sound_driver_instrument_routine_channel1_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_default:
001875 91c0 2894                 	lds r28, pulse2_fx_0xy_sequence //load 0xy effect
001877 91d0 2895                 	lds r29, pulse2_fx_0xy_sequence+1
001879 9620                      	adiw r29:r28, 0 //check for 0xy effect
00187a f099                      	breq sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel1_arpeggio_default_xy:
00187b 95d6                      	lsr r29
00187c 95c7                      	ror r28
00187d 95d7                      	ror r29
00187e 95c7                      	ror r28
00187f 95d7                      	ror r29
001880 95c7                      	ror r28
001881 95d7                      	ror r29
001882 95c7                      	ror r28
001883 95d7                      	ror r29
001884 95d2                      	swap r29
                                 
001885 93c0 2894                 	sts pulse2_fx_0xy_sequence, r28 //store the rolled sequence
001887 93d0 2895                 	sts pulse2_fx_0xy_sequence+1, r29
001889 70cf                      	andi r28, 0x0F //mask out the 4 LSB
00188a 91a0 280f                 	lds r26, pulse2_note //load the current note index
00188c 0fac                      	add r26, r28 //add the note offset
00188d c02e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
00188e 91a0 280f                 	lds r26, pulse2_note //load the current note index
001890 c02b                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process:
001891 9220 2882                 	sts pulse2_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
001893 9220 2883                 	sts pulse2_total_pitch_offset+1, zero
001895 9220 2889                 	sts pulse2_total_hi_pitch_offset, zero
001897 91a0 2881                 	lds r26, pulse2_arpeggio_macro_mode
001899 30a1                      	cpi r26, 0x01 //absolute mode
00189a f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_absolute
00189b f069                      	breq sound_driver_instrument_routine_channel1_arpeggio_process_fixed
00189c c00e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute:
00189d 91a0 280f                 	lds r26, pulse2_note //load the current note index
00189f 0fab                      	add r26, r27 //offset the note with the arpeggio data
0018a0 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0018a1 c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_add:
0018a2 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0018a3 f0c0                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
0018a4 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0018a5 c016                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract:
0018a6 fda7                      	sbrc r26, 7 //check if result is negative
0018a7 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0018a8 c013                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_fixed:
0018a9 2fab                      	mov r26, r27 //move the arpeggio data into r26
0018aa c011                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative:
0018ab 91a0 280f                 	lds r26, pulse2_note //load the current note index
0018ad 0fab                      	add r26, r27 //offset the note with the arpeggio data
0018ae fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0018af c008                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_add:
0018b0 93a0 280f                 	sts pulse2_note, r26 //NOTE: relative mode modifies the original note index
0018b2 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0018b3 f040                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
0018b4 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0018b5 93a0 280f                 	sts pulse2_note, r26
0018b7 c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract:
0018b8 fda7                      	sbrc r26, 7 //check if result is negative
0018b9 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0018ba 93a0 280f                 	sts pulse2_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_load:
0018bc e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0018bd e0f0                      	ldi ZH, HIGH(note_table << 1)
0018be 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
0018bf 0fea                      	add ZL, r26 //add offset
0018c0 1df2                      	adc ZH, zero
0018c1 91a5                      	lpm r26, Z+ //load bytes
0018c2 91b4                      	lpm r27, Z
0018c3 93a0 0a9c                 	sts TCB1_CCMPL, r26 //load the LOW bits for timer
0018c5 93b0 0a9d                 	sts TCB1_CCMPH, r27 //load the HIGH bits for timer
0018c7 93a0 28a0                 	sts pulse2_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
0018c9 93b0 28a1                 	sts pulse2_fx_3xx_target+1, r27
0018cb c000                      	rjmp sound_driver_instrument_routine_channel1_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch:
0018cc 91e0 2884                 	lds ZL, pulse2_pitch_macro
0018ce 91f0 2885                 	lds ZH, pulse2_pitch_macro+1
0018d0 9630                      	adiw Z, 0
0018d1 f409                      	brne sound_driver_instrument_routine_channel1_pitch_continue
0018d2 c023                      	rjmp sound_driver_instrument_routine_channel1_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel1_pitch_continue:
0018d3 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0018d4 1fff                      	rol ZH
0018d5 91a0 2886                 	lds r26, pulse2_pitch_macro_offset
0018d7 0fea                      	add ZL, r26
0018d8 1df2                      	adc ZH, zero
                                 
0018d9 91b0 2888                 	lds r27, pulse2_pitch_macro_release
0018db 17ba                      	cp r27, r26
0018dc f429                      	brne sound_driver_instrument_routine_channel1_pitch_increment //if the current offset is not equal to the release index, increment the offset
0018dd 91a0 2887                 	lds r26, pulse2_pitch_macro_loop
0018df 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0018e0 f010                      	brlo sound_driver_instrument_routine_channel1_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0018e1 c003                      	rjmp sound_driver_instrument_routine_channel1_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_pitch_increment:
0018e2 95a3                      	inc r26 //increment the macro offset
0018e3 93a0 2886                 	sts pulse2_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_pitch_read:
0018e5 91b4                      	lpm r27, Z //load pitch data into r27
0018e6 38b0                      	cpi r27, 0x80 //check for macro end flag
0018e7 f479                      	brne sound_driver_instrument_routine_channel1_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_release:
0018e8 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0018e9 93a0 2886                 	sts pulse2_pitch_macro_offset, r26
0018eb 91b0 2888                 	lds r27, pulse2_pitch_macro_release
0018ed 3fbf                      	cpi r27, 0xFF
0018ee f439                      	brne sound_driver_instrument_routine_channel1_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_loop:
0018ef 91b0 2887                 	lds r27, pulse2_pitch_macro_loop //load the loop index
0018f1 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0018f2 f019                      	breq sound_driver_instrument_routine_channel1_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
0018f3 93b0 2886                 	sts pulse2_pitch_macro_offset, r27 //store the loop index into the offset
0018f5 cfd6                      	rjmp sound_driver_instrument_routine_channel1_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_default:
0018f6 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel1_pitch_calculate:
0018f7 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0018f8 937f                      	push r23
0018f9 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
0018fa eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0018fb 0367                      	mulsu r22, r23
0018fc 917f                      	pop r23
0018fd 916f                      	pop r22
                                 
0018fe 9416                      	lsr r1 //shift out the fractional bits
0018ff 9407                      	ror r0
001900 9416                      	lsr r1
001901 9407                      	ror r0
001902 9416                      	lsr r1
001903 9407                      	ror r0
001904 9416                      	lsr r1
001905 9407                      	ror r0
001906 fe13                      	sbrs r1, 3 //check if result was a negative number
001907 c002                      	rjmp sound_driver_instrument_routine_channel1_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_negative:
001908 efb0                      	ldi r27, 0xF0
001909 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_offset:
00190a 91a0 2882                 	lds r26, pulse2_total_pitch_offset
00190c 91b0 2883                 	lds r27, pulse2_total_pitch_offset+1
00190e 0e0a                      	add r0, r26
00190f 1e1b                      	adc r1, r27
001910 9200 2882                 	sts pulse2_total_pitch_offset, r0
001912 9210 2883                 	sts pulse2_total_pitch_offset+1, r1
001914 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
001916 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
001918 0da0                      	add r26, r0 //offset the timer values
001919 1db1                      	adc r27, r1
                                 	
00191a 91c0 2898                 	lds r28, pulse2_fx_1xx_total
00191c 91d0 2899                 	lds r29, pulse2_fx_1xx_total+1
00191e 1bac                      	sub r26, r28
00191f 0bbd                      	sbc r27, r29
001920 91c0 289c                 	lds r28, pulse2_fx_2xx_total
001922 91d0 289d                 	lds r29, pulse2_fx_2xx_total+1
001924 0fac                      	add r26, r28
001925 1fbd                      	adc r27, r29
001926 91c0 28b0                 	lds r28, pulse2_fx_Pxx_total
001928 91d0 28b1                 	lds r29, pulse2_fx_Pxx_total+1
00192a 0fac                      	add r26, r28
00192b 1fbd                      	adc r27, r29
00192c 91c0 28b6                 	lds r28, pulse2_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
00192e 91d0 28b7                 	lds r29, pulse2_fx_Qxy_total_offset+1
001930 1bac                      	sub r26, r28
001931 0bbd                      	sbc r27, r29
001932 91c0 28bc                 	lds r28, pulse2_fx_Rxy_total_offset
001934 91d0 28bd                 	lds r29, pulse2_fx_Rxy_total_offset+1
001936 0fac                      	add r26, r28
001937 1fbd                      	adc r27, r29
                                 
001938 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
00193a 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel1_hi_pitch:
00193c 91e0 288a                 	lds ZL, pulse2_hi_pitch_macro
00193e 91f0 288b                 	lds ZH, pulse2_hi_pitch_macro+1
001940 9630                      	adiw Z, 0
001941 f409                      	brne sound_driver_instrument_routine_channel1_hi_pitch_continue
001942 c03c                      	rjmp sound_driver_instrument_routine_channel1_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel1_hi_pitch_continue:
001943 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
001944 1fff                      	rol ZH
001945 91a0 288c                 	lds r26, pulse2_hi_pitch_macro_offset
001947 0fea                      	add ZL, r26
001948 1df2                      	adc ZH, zero
                                 
001949 91b0 288e                 	lds r27, pulse2_hi_pitch_macro_release
00194b 17ba                      	cp r27, r26
00194c f429                      	brne sound_driver_instrument_routine_channel1_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
00194d 91a0 288d                 	lds r26, pulse2_hi_pitch_macro_loop
00194f 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
001950 f010                      	brlo sound_driver_instrument_routine_channel1_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
001951 c003                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_increment:
001952 95a3                      	inc r26 //increment the macro offset
001953 93a0 288c                 	sts pulse2_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_hi_pitch_read:
001955 91b4                      	lpm r27, Z //load hi pitch data into r27
001956 38b0                      	cpi r27, 0x80 //check for macro end flag
001957 f489                      	brne sound_driver_instrument_routine_channel1_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_release:
001958 50a1                      	subi r26, 1 //keep the macro offset at the end flag
001959 93a0 288c                 	sts pulse2_hi_pitch_macro_offset, r26
00195b 91b0 288e                 	lds r27, pulse2_hi_pitch_macro_release
00195d 3fbf                      	cpi r27, 0xFF
00195e f439                      	brne sound_driver_instrument_routine_channel1_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_loop:
00195f 91b0 288d                 	lds r27, pulse2_hi_pitch_macro_loop //load the loop index
001961 3fbf                      	cpi r27, 0xFF //check if there is a loop index
001962 f019                      	breq sound_driver_instrument_routine_channel1_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
001963 93b0 288c                 	sts pulse2_hi_pitch_macro_offset, r27 //store the loop index into the offset
001965 cfd6                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_default:
001966 91b0 2889                 	lds r27, pulse2_total_hi_pitch_offset
001968 c005                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate:
001969 91a0 2889                 	lds r26, pulse2_total_hi_pitch_offset //load the total hi pitch offset to change
00196b 0fba                      	add r27, r26
00196c 93b0 2889                 	sts pulse2_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply:
00196e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00196f 937f                      	push r23
001970 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
001971 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001972 0367                      	mulsu r22, r23
001973 917f                      	pop r23
001974 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_offset:
001975 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
001977 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
001979 0da0                      	add r26, r0 //offset the timer values
00197a 1db1                      	adc r27, r1
00197b 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
00197d 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel1_duty:
00197f 91e0 288f                 	lds ZL, pulse2_duty_macro
001981 91f0 2890                 	lds ZH, pulse2_duty_macro+1
001983 9630                      	adiw Z, 0
001984 f1b1                      	breq sound_driver_channel1_fx_routines //if no duty macro is in use, go to the next routine
001985 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
001986 1fff                      	rol ZH
001987 91a0 2891                 	lds r26, pulse2_duty_macro_offset
001989 0fea                      	add ZL, r26
00198a 1df2                      	adc ZH, zero
                                 
00198b 91b0 2893                 	lds r27, pulse2_duty_macro_release
00198d 17ba                      	cp r27, r26
00198e f429                      	brne sound_driver_instrument_routine_channel1_duty_increment //if the current offset is not equal to the release index, increment the offset
00198f 91a0 2892                 	lds r26, pulse2_duty_macro_loop
001991 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
001992 f010                      	brlo sound_driver_instrument_routine_channel1_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
001993 c027                      	rjmp sound_driver_channel1_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel1_duty_increment:
001994 95a3                      	inc r26 //increment the macro offset
001995 93a0 2891                 	sts pulse2_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_duty_read:
001997 91b4                      	lpm r27, Z //load pitch data into r27
001998 3fbf                      	cpi r27, 0xFF //check for macro end flag
001999 f471                      	brne sound_driver_instrument_routine_channel1_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_release:
00199a 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00199b 93a0 2891                 	sts pulse2_duty_macro_offset, r26
00199d 91b0 2893                 	lds r27, pulse2_duty_macro_release
00199f 3fbf                      	cpi r27, 0xFF
0019a0 f4d1                      	brne sound_driver_channel1_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_loop:
0019a1 91b0 2892                 	lds r27, pulse2_duty_macro_loop //load the loop index
0019a3 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0019a4 f0b1                      	breq sound_driver_channel1_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
0019a5 93b0 2891                 	sts pulse2_duty_macro_offset, r27 //store the loop index into the offset
0019a7 cfd7                      	rjmp sound_driver_instrument_routine_channel1_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_load:
0019a8 e6ea                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
0019a9 e4f2                      	ldi ZH, HIGH(sequences << 1)
0019aa 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
0019ab 1df2                      	adc ZH, zero
                                 
0019ac 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
0019ad 95b7                      	ror r27
0019ae 95b7                      	ror r27
0019af 91a0 2808                 	lds r26, pulse2_param //load r26 with pulse2_param (register $4000)
0019b1 2fca                      	mov r28, r26 //store a copy of pulse2_param into r28
0019b2 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
0019b3 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
0019b4 c001                      	rjmp sound_driver_instrument_routine_channel1_duty_load_store
0019b5 c005                      	rjmp sound_driver_channel1_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel1_duty_load_store:
0019b6 90d4                      	lpm pulse2_sequence, Z //store the sequence
                                 
0019b7 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
0019b8 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
0019b9 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_routines:
                                 sound_driver_channel1_fx_1xx_routine:
0019bb 91e0 2896                 	lds ZL, pulse2_fx_1xx
0019bd 91f0 2897                 	lds ZH, pulse2_fx_1xx+1
0019bf 9630                      	adiw Z, 0
0019c0 f051                      	breq sound_driver_channel1_fx_2xx_routine
                                 
0019c1 91a0 2898                 	lds r26, pulse2_fx_1xx_total //load the rate to change the pitch by
0019c3 91b0 2899                 	lds r27, pulse2_fx_1xx_total+1
0019c5 0fae                      	add r26, ZL //increase the total offset by the rate
0019c6 1fbf                      	adc r27, ZH
0019c7 93a0 2898                 	sts pulse2_fx_1xx_total, r26
0019c9 93b0 2899                 	sts pulse2_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_2xx_routine:
0019cb 91e0 289a                 	lds ZL, pulse2_fx_2xx
0019cd 91f0 289b                 	lds ZH, pulse2_fx_2xx+1
0019cf 9630                      	adiw Z, 0
0019d0 f051                      	breq sound_driver_channel1_fx_3xx_routine
                                 
0019d1 91a0 289c                 	lds r26, pulse2_fx_2xx_total //load the rate to change the pitch by
0019d3 91b0 289d                 	lds r27, pulse2_fx_2xx_total+1
0019d5 0fae                      	add r26, ZL //increase the total offset by the rate
0019d6 1fbf                      	adc r27, ZH
0019d7 93a0 289c                 	sts pulse2_fx_2xx_total, r26
0019d9 93b0 289d                 	sts pulse2_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_3xx_routine:
0019db 91e0 28a2                 	lds ZL, pulse2_fx_3xx_speed
0019dd 91f0 28a3                 	lds ZH, pulse2_fx_3xx_speed+1
0019df 9630                      	adiw Z, 0
0019e0 f409                      	brne sound_driver_channel1_fx_3xx_routine_check_start
0019e1 c048                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_check_start:
0019e2 91a0 289e                 	lds r26, pulse2_fx_3xx_start
0019e4 91b0 289f                 	lds r27, pulse2_fx_3xx_start+1
0019e6 9610                      	adiw r26:r27, 0
0019e7 f409                      	brne sound_driver_channel1_fx_3xx_routine_main
0019e8 c041                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_main:
0019e9 91c0 28a0                 	lds r28, pulse2_fx_3xx_target
0019eb 91d0 28a1                 	lds r29, pulse2_fx_3xx_target+1
                                 
0019ed 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
0019ee 07bd                      	cpc r27, r29
0019ef f011                      	breq sound_driver_channel1_fx_3xx_routine_disable
0019f0 f030                      	brlo sound_driver_channel1_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
0019f1 c01f                      	rjmp sound_driver_channel1_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel1_fx_3xx_routine_disable:
0019f2 9220 289e                 	sts pulse2_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
0019f4 9220 289f                 	sts pulse2_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
0019f6 c033                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_subtract:
0019f7 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
0019f8 0bdb                      	sbc r29, r27
0019f9 91a0 28a4                 	lds r26, pulse2_fx_3xx_total_offset
0019fb 91b0 28a5                 	lds r27, pulse2_fx_3xx_total_offset+1
                                 
0019fd 0fae                      	add r26, ZL //add the speed to the total offset
0019fe 1fbf                      	adc r27, ZH
0019ff 1bca                      	sub r28, r26 //invert the total difference with the total offset
001a00 0bdb                      	sbc r29, r27
001a01 f380                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
001a02 93a0 28a4                 	sts pulse2_fx_3xx_total_offset, r26 //store the new total offset
001a04 93b0 28a5                 	sts pulse2_fx_3xx_total_offset+1, r27
                                 
001a06 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the current timer period
001a08 91b0 0a9d                 	lds r27, TCB1_CCMPH
001a0a 1bac                      	sub r26, r28 //offset the current timer period with the total offset
001a0b 0bbd                      	sbc r27, r29
001a0c 93a0 0a9c                 	sts TCB1_CCMPL, r26
001a0e 93b0 0a9d                 	sts TCB1_CCMPH, r27
001a10 c019                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_add:
001a11 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
001a12 0bbd                      	sbc r27, r29
001a13 91c0 28a4                 	lds r28, pulse2_fx_3xx_total_offset
001a15 91d0 28a5                 	lds r29, pulse2_fx_3xx_total_offset+1
                                 
001a17 0fce                      	add r28, ZL //add the speed to the total offset
001a18 1fdf                      	adc r29, ZH
001a19 1bac                      	sub r26, r28 //invert the total difference with the total offset
001a1a 0bbd                      	sbc r27, r29
001a1b f2b0                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
001a1c 93c0 28a4                 	sts pulse2_fx_3xx_total_offset, r28 //store the new total offset
001a1e 93d0 28a5                 	sts pulse2_fx_3xx_total_offset+1, r29
                                 
001a20 91c0 0a9c                 	lds r28, TCB1_CCMPL //load the current timer period
001a22 91d0 0a9d                 	lds r29, TCB1_CCMPH
001a24 0fca                      	add r28, r26 //offset the current timer period with the total offset
001a25 1fdb                      	adc r29, r27
001a26 93c0 0a9c                 	sts TCB1_CCMPL, r28
001a28 93d0 0a9d                 	sts TCB1_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel1_fx_4xy_routine:
001a2a 91a0 28a6                 	lds r26, pulse2_fx_4xy_speed
001a2c 15a2                      	cp r26, zero
001a2d f409                      	brne sound_driver_channel1_fx_4xy_routine_continue
001a2e c05c                      	rjmp sound_driver_channel1_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel1_fx_4xy_routine_continue:
001a2f 91b0 28a7                 	lds r27, pulse2_fx_4xy_depth
001a31 91c0 28a8                 	lds r28, pulse2_fx_4xy_phase
001a33 0fca                      	add r28, r26 //increase the phase by the speed
001a34 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
001a35 f008                      	brlo sound_driver_channel1_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
001a36 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase:
001a37 93c0 28a8                 	sts pulse2_fx_4xy_phase, r28 //store the new phase
001a39 31c0                      	cpi r28, 16
001a3a f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_0
001a3b 32c0                      	cpi r28, 32
001a3c f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_1
001a3d 33c0                      	cpi r28, 48
001a3e f030                      	brlo sound_driver_channel1_fx_4xy_routine_phase_2
001a3f c007                      	rjmp sound_driver_channel1_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_0:
001a40 70cf                      	andi r28, 0x0F //mask for values 0-15
001a41 c029                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_1:
001a42 6fc0                      	ori r28, 0xF0
001a43 95c0                      	com r28 //invert values 0-15
001a44 c026                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_2:
001a45 70cf                      	andi r28, 0x0F //mask for values 0-15
001a46 c003                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_3:
001a47 6fc0                      	ori r28, 0xF0
001a48 95c0                      	com r28 //invert values 0-15
001a49 c000                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_add:
001a4a 95b2                      	swap r27 //multiply depth by 16
001a4b 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
001a4c e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
001a4d e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
001a4e 0fec                      	add ZL, r28 //offset the table by the depth+phase
001a4f 1df2                      	adc ZH, zero
001a50 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
001a51 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001a52 937f                      	push r23
001a53 2f6c                      	mov r22, r28 //store the vibrato value into r22
001a54 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001a55 9f67                      	mul r22, r23
001a56 917f                      	pop r23
001a57 916f                      	pop r22
                                 
001a58 9416                      	lsr r1 //shift out the fractional bits
001a59 9407                      	ror r0
001a5a 9416                      	lsr r1
001a5b 9407                      	ror r0
001a5c 9416                      	lsr r1
001a5d 9407                      	ror r0
001a5e 9416                      	lsr r1
001a5f 9407                      	ror r0
                                 	
001a60 91a0 0a9c                 	lds r26, TCB1_CCMPL
001a62 91b0 0a9d                 	lds r27, TCB1_CCMPH
001a64 0da0                      	add r26, r0
001a65 1db1                      	adc r27, r1
001a66 93a0 0a9c                 	sts TCB1_CCMPL, r26
001a68 93b0 0a9d                 	sts TCB1_CCMPH, r27
001a6a c020                      	rjmp sound_driver_channel1_fx_7xy_routine
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_subtract:
001a6b 95b2                      	swap r27 //multiply depth by 16
001a6c 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
001a6d e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
001a6e e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
001a6f 0fec                      	add ZL, r28 //offset the table by the depth+phase
001a70 1df2                      	adc ZH, zero
001a71 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
001a72 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001a73 937f                      	push r23
001a74 2f6c                      	mov r22, r28 //store the vibrato value into r22
001a75 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001a76 9f67                      	mul r22, r23
001a77 917f                      	pop r23
001a78 916f                      	pop r22
                                 
001a79 9416                      	lsr r1 //shift out the fractional bits
001a7a 9407                      	ror r0
001a7b 9416                      	lsr r1
001a7c 9407                      	ror r0
001a7d 9416                      	lsr r1
001a7e 9407                      	ror r0
001a7f 9416                      	lsr r1
001a80 9407                      	ror r0
                                 
001a81 91a0 0a9c                 	lds r26, TCB1_CCMPL
001a83 91b0 0a9d                 	lds r27, TCB1_CCMPH
001a85 19a0                      	sub r26, r0
001a86 09b1                      	sbc r27, r1
001a87 93a0 0a9c                 	sts TCB1_CCMPL, r26
001a89 93b0 0a9d                 	sts TCB1_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_7xy_routine:
001a8b 91a0 28a9                 	lds r26, pulse2_fx_7xy_speed
001a8d 15a2                      	cp r26, zero
001a8e f0f1                      	breq sound_driver_channel1_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
001a8f 91b0 28aa                 	lds r27, pulse2_fx_7xy_depth
001a91 91c0 28ab                 	lds r28, pulse2_fx_7xy_phase
001a93 0fca                      	add r28, r26 //increase the phase by the speed
001a94 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
001a95 f010                      	brlo sound_driver_channel1_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
001a96 e0c0                      	ldi r28, 0x00
001a97 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase:
001a98 93c0 28ab                 	sts pulse2_fx_7xy_phase, r28 //store the new phase
001a9a 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
001a9b ffc4                      	sbrs r28, 4
001a9c c001                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_0
001a9d c002                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel1_fx_7xy_routine_phase_0:
001a9e 70cf                      	andi r28, 0x0F //mask for values 0-15
001a9f c003                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase_1:
001aa0 6fc0                      	ori r28, 0xF0
001aa1 95c0                      	com r28 //invert values 0-15
001aa2 c000                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_load:
001aa3 95b2                      	swap r27 //multiply depth by 16
001aa4 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
001aa5 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
001aa6 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
001aa7 0fec                      	add ZL, r28 //offset the table by the depth+phase
001aa8 1df2                      	adc ZH, zero
001aa9 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
001aaa 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
001aab 93c0 28ac                 	sts pulse2_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Axy_routine:
001aad 91b0 28ad                 	lds r27, pulse2_fx_Axy
001aaf 15b2                      	cp r27, zero
001ab0 f0e9                      	breq sound_driver_channel1_fx_Qxy_routine //0 means that the effect is not in use
                                 	
001ab1 91a0 280d                 	lds r26, pulse2_fractional_volume //load fractional volume representation of the channel
001ab3 91c0 2808                 	lds r28, pulse2_param //load the integer volume representation of the channel
001ab5 2fda                      	mov r29, r26 //copy fractional volume into r29
001ab6 2fec                      	mov r30, r28 //copy the pulse2_param into r30
001ab7 95e2                      	swap r30
001ab8 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
001ab9 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
001aba 17ed                      	cp r30, r29 //compare the fractional and integer volumes
001abb f009                      	breq sound_driver_channel1_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel1_fx_Axy_routine_reload:
001abc 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate:
001abd fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
001abe c004                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_addition:
001abf 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
001ac0 f428                      	brcc sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
001ac1 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
001ac2 c003                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_subtraction:
001ac3 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
001ac4 f008                      	brcs sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
001ac5 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_store:
001ac6 93a0 280d                 	sts pulse2_fractional_volume, r26 //store the new fractional volume
001ac8 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
001ac9 95a2                      	swap r26
001aca 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
001acb 2bca                      	or r28, r26 //store the new volume back into pulse2_param
001acc 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel1_fx_Qxy_routine:
001ace 91e0 28b2                 	lds ZL, pulse2_fx_Qxy_target
001ad0 91f0 28b3                 	lds ZH, pulse2_fx_Qxy_target+1
001ad2 9630                      	adiw Z, 0
001ad3 f139                      	breq sound_driver_channel1_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
001ad4 91a0 28b6                 	lds r26, pulse2_fx_Qxy_total_offset
001ad6 91b0 28b7                 	lds r27, pulse2_fx_Qxy_total_offset+1
001ad8 91c0 0a9c                 	lds r28, TCB1_CCMPL
001ada 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
001adc 1bec                      	sub ZL, r28 //calculate the difference to the target
001add 0bfd                      	sbc ZH, r29
001ade f408                      	brsh sound_driver_channel1_fx_Qxy_routine_end //if the target has been reached (or passed)
001adf f088                      	brlo sound_driver_channel1_fx_Qxy_routine_add
                                 
                                 sound_driver_channel1_fx_Qxy_routine_end:
001ae0 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
001ae1 0bbf                      	sbc r27, ZH
                                 
001ae2 91c0 28b0                 	lds r28, pulse2_fx_Pxx_total
001ae4 91d0 28b1                 	lds r29, pulse2_fx_Pxx_total+1
                                 
001ae6 0fac                      	add r26, r28
001ae7 1fbd                      	adc r27, r29
                                 
001ae8 93a0 28b6                 	sts pulse2_fx_Qxy_total_offset, r26 //store the total offset
001aea 93b0 28b7                 	sts pulse2_fx_Qxy_total_offset+1, r27
001aec 9220 28b2                 	sts pulse2_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
001aee 9220 28b3                 	sts pulse2_fx_Qxy_target+1, zero
001af0 c00a                      	rjmp sound_driver_channel1_fx_Rxy_routine
                                 
                                 sound_driver_channel1_fx_Qxy_routine_add:
001af1 91c0 28b4                 	lds r28, pulse2_fx_Qxy_speed
001af3 91d0 28b5                 	lds r29, pulse2_fx_Qxy_speed+1
001af5 0fac                      	add r26, r28 //increase the total offset by the speed
001af6 1fbd                      	adc r27, r29
001af7 93a0 28b6                 	sts pulse2_fx_Qxy_total_offset, r26 //store the total offset
001af9 93b0 28b7                 	sts pulse2_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Rxy_routine:
001afb 91e0 28b8                 	lds ZL, pulse2_fx_Rxy_target
001afd 91f0 28b9                 	lds ZH, pulse2_fx_Rxy_target+1
001aff 9630                      	adiw Z, 0
001b00 f139                      	breq sound_driver_instrument_routine_channel2_volume //if the effect is not enabled, skip the routine
                                 
001b01 91a0 28bc                 	lds r26, pulse2_fx_Rxy_total_offset
001b03 91b0 28bd                 	lds r27, pulse2_fx_Rxy_total_offset+1
001b05 91c0 0a9c                 	lds r28, TCB1_CCMPL
001b07 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
001b09 1bce                      	sub r28, ZL //calculate the difference to the target
001b0a 0bdf                      	sbc r29, ZH
001b0b f408                      	brsh sound_driver_channel1_fx_Rxy_routine_end //if the target has been reached (or passed)
001b0c f088                      	brlo sound_driver_channel1_fx_Rxy_routine_add
                                 
                                 sound_driver_channel1_fx_Rxy_routine_end:
001b0d 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
001b0e 0bbd                      	sbc r27, r29
                                 
001b0f 91c0 28b0                 	lds r28, pulse2_fx_Pxx_total
001b11 91d0 28b1                 	lds r29, pulse2_fx_Pxx_total+1
                                 
001b13 0fac                      	add r26, r28
001b14 1fbd                      	adc r27, r29
                                 
001b15 93a0 28bc                 	sts pulse2_fx_Rxy_total_offset, r26 //store the total offset
001b17 93b0 28bd                 	sts pulse2_fx_Rxy_total_offset+1, r27
001b19 9220 28b8                 	sts pulse2_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
001b1b 9220 28b9                 	sts pulse2_fx_Rxy_target+1, zero
001b1d c00a                      	rjmp sound_driver_instrument_routine_channel2_volume
                                 
                                 sound_driver_channel1_fx_Rxy_routine_add:
001b1e 91c0 28ba                 	lds r28, pulse2_fx_Rxy_speed
001b20 91d0 28bb                 	lds r29, pulse2_fx_Rxy_speed+1
001b22 0fac                      	add r26, r28 //increase the total offset by the speed
001b23 1fbd                      	adc r27, r29
001b24 93a0 28bc                 	sts pulse2_fx_Rxy_total_offset, r26 //store the total offset
001b26 93b0 28bd                 	sts pulse2_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume:
001b28 91e0 28c6                 	lds ZL, triangle_volume_macro
001b2a 91f0 28c7                 	lds ZH, triangle_volume_macro+1
001b2c 9630                      	adiw Z, 0
001b2d f199                      	breq sound_driver_instrument_routine_channel2_volume_default //if no volume macro is in use, do nothing
001b2e 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
001b2f 1fff                      	rol ZH
001b30 91a0 28c8                 	lds r26, triangle_volume_macro_offset
001b32 0fea                      	add ZL, r26
001b33 1df2                      	adc ZH, zero
                                 
001b34 91b0 28ca                 	lds r27, triangle_volume_macro_release
001b36 17ba                      	cp r27, r26
001b37 f429                      	brne sound_driver_instrument_routine_channel2_volume_increment //if the current offset is not equal to the release index, increment the offset
001b38 91a0 28c9                 	lds r26, triangle_volume_macro_loop
001b3a 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
001b3b f010                      	brlo sound_driver_instrument_routine_channel2_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
001b3c c003                      	rjmp sound_driver_instrument_routine_channel2_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_volume_increment:
001b3d 95a3                      	inc r26 //increment the macro offset
001b3e 93a0 28c8                 	sts triangle_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_volume_read:
001b40 91b4                      	lpm r27, Z //load volume data into r27
001b41 3fbf                      	cpi r27, 0xFF //check for macro end flag
001b42 f469                      	brne sound_driver_instrument_routine_channel2_volume_process //if the data was not the macro end flag
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_release:
001b43 91b0 28ca                 	lds r27, triangle_volume_macro_release
001b45 3fbf                      	cpi r27, 0xFF
001b46 f429                      	brne sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_loop:
001b47 91b0 28c9                 	lds r27, triangle_volume_macro_loop //load the loop index
001b49 93b0 28c8                 	sts triangle_volume_macro_offset, r27 //store the loop index into the offset
001b4b cfdc                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index:
001b4c 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
001b4d 93a0 28c8                 	sts triangle_volume_macro_offset, r26
001b4f cfd8                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_process:
001b50 15b2                      	cp r27, zero
001b51 f041                      	breq sound_driver_instrument_routine_channel2_volume_process_disable
                                 sound_driver_instrument_routine_channel2_volume_process_enable:
001b52 91b0 0aa5                 	lds r27, TCB2_INTCTRL
001b54 30b1                      	cpi r27, TCB_CAPT_bm
001b55 f459                      	brne sound_driver_instrument_routine_channel2_volume_default //if the channel has already been muted, don't enable it again
001b56 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001b57 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001b59 c007                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 sound_driver_instrument_routine_channel2_volume_process_disable:
001b5a 9220 0aa5                 	sts TCB2_INTCTRL, zero
001b5c 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
001b5e 9220 0aad                 	sts TCB2_CCMPH, zero
001b60 c000                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_volume_default:
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
001b61 91e0 28cb                 	lds ZL, triangle_arpeggio_macro
001b63 91f0 28cc                 	lds ZH, triangle_arpeggio_macro+1
001b65 9630                      	adiw Z, 0
001b66 f1d9                      	breq sound_driver_instrument_routine_channel2_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
001b67 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
001b68 1fff                      	rol ZH
001b69 91a0 28cd                 	lds r26, triangle_arpeggio_macro_offset
001b6b 0fea                      	add ZL, r26
001b6c 1df2                      	adc ZH, zero
                                 
001b6d 91b0 28cf                 	lds r27, triangle_arpeggio_macro_release
001b6f 17ba                      	cp r27, r26
001b70 f429                      	brne sound_driver_instrument_routine_channel2_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
001b71 91a0 28ce                 	lds r26, triangle_arpeggio_macro_loop
001b73 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
001b74 f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
001b75 c003                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_increment:
001b76 95a3                      	inc r26 //increment the macro offset
001b77 93a0 28cd                 	sts triangle_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_read:
001b79 91b4                      	lpm r27, Z //load arpeggio data into r27
001b7a 38b0                      	cpi r27, 0x80 //check for macro end flag
001b7b f009                      	breq sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag
001b7c c041                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_check_mode:
001b7d 50a1                      	subi r26, 1 //keep the offset at the end flag
001b7e 93a0 28cd                 	sts triangle_arpeggio_macro_offset, r26
001b80 91b0 28d0                 	lds r27, triangle_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
001b82 30b1                      	cpi r27, 0x01
001b83 f048                      	brlo sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_release:
001b84 91b0 28cf                 	lds r27, triangle_arpeggio_macro_release
001b86 3fbf                      	cpi r27, 0xFF
001b87 f4d1                      	brne sound_driver_instrument_routine_channel2_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_loop:
001b88 91b0 28ce                 	lds r27, triangle_arpeggio_macro_loop
001b8a 3fbf                      	cpi r27, 0xFF
001b8b f499                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
001b8c c015                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute:
001b8d 91b0 28cf                 	lds r27, triangle_arpeggio_macro_release
001b8f 3fbf                      	cpi r27, 0xFF
001b90 f421                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_check_loop:
001b91 91b0 28ce                 	lds r27, triangle_arpeggio_macro_loop //load the loop index
001b93 3fbf                      	cpi r27, 0xFF //check if loop flag exists
001b94 f451                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop:
001b95 91c0 28e3                 	lds r28, triangle_fx_0xy_sequence //check for 0xy effect
001b97 91d0 28e4                 	lds r29, triangle_fx_0xy_sequence+1
001b99 9620                      	adiw r29:r28, 0
001b9a f469                      	brne sound_driver_instrument_routine_channel2_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
001b9b 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
001b9c 93a0 28cd                 	sts triangle_arpeggio_macro_offset, r26 //store the last valid index into the offset
001b9e cfc2                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload:
001b9f 93b0 28cd                 	sts triangle_arpeggio_macro_offset, r27 //store the loop index into the offset
001ba1 cfbf                      	rjmp sound_driver_instrument_routine_channel2_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_default:
001ba2 91c0 28e3                 	lds r28, triangle_fx_0xy_sequence //load 0xy effect
001ba4 91d0 28e4                 	lds r29, triangle_fx_0xy_sequence+1
001ba6 9620                      	adiw r29:r28, 0 //check for 0xy effect
001ba7 f099                      	breq sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel2_arpeggio_default_xy:
001ba8 95d6                      	lsr r29
001ba9 95c7                      	ror r28
001baa 95d7                      	ror r29
001bab 95c7                      	ror r28
001bac 95d7                      	ror r29
001bad 95c7                      	ror r28
001bae 95d7                      	ror r29
001baf 95c7                      	ror r28
001bb0 95d7                      	ror r29
001bb1 95d2                      	swap r29
                                 
001bb2 93c0 28e3                 	sts triangle_fx_0xy_sequence, r28 //store the rolled sequence
001bb4 93d0 28e4                 	sts triangle_fx_0xy_sequence+1, r29
001bb6 70cf                      	andi r28, 0x0F //mask out the 4 LSB
001bb7 91a0 2812                 	lds r26, triangle_note //load the current note index
001bb9 0fac                      	add r26, r28 //add the note offset
001bba c02e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
001bbb 91a0 2812                 	lds r26, triangle_note //load the current note index
001bbd c02b                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process:
001bbe 9220 28d1                 	sts triangle_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
001bc0 9220 28d2                 	sts triangle_total_pitch_offset+1, zero
001bc2 9220 28d8                 	sts triangle_total_hi_pitch_offset, zero
001bc4 91a0 28d0                 	lds r26, triangle_arpeggio_macro_mode
001bc6 30a1                      	cpi r26, 0x01 //absolute mode
001bc7 f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_absolute
001bc8 f069                      	breq sound_driver_instrument_routine_channel2_arpeggio_process_fixed
001bc9 c00e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute:
001bca 91a0 2812                 	lds r26, triangle_note //load the current note index
001bcc 0fab                      	add r26, r27 //offset the note with the arpeggio data
001bcd fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
001bce c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_add:
001bcf 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
001bd0 f0c0                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
001bd1 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
001bd2 c016                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract:
001bd3 fda7                      	sbrc r26, 7 //check if result is negative
001bd4 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
001bd5 c013                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_fixed:
001bd6 2fab                      	mov r26, r27 //move the arpeggio data into r26
001bd7 c011                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative:
001bd8 91a0 2812                 	lds r26, triangle_note //load the current note index
001bda 0fab                      	add r26, r27 //offset the note with the arpeggio data
001bdb fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
001bdc c008                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_add:
001bdd 93a0 2812                 	sts triangle_note, r26 //NOTE: relative mode modifies the original note index
001bdf 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
001be0 f040                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
001be1 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
001be2 93a0 2812                 	sts triangle_note, r26
001be4 c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract:
001be5 fda7                      	sbrc r26, 7 //check if result is negative
001be6 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
001be7 93a0 2812                 	sts triangle_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_load:
001be9 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001bea e0f0                      	ldi ZH, HIGH(note_table << 1)
001beb 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
001bec 0fea                      	add ZL, r26 //add offset
001bed 1df2                      	adc ZH, zero
001bee 91a5                      	lpm r26, Z+ //load bytes
001bef 91b4                      	lpm r27, Z
001bf0 93a0 0aac                 	sts TCB2_CCMPL, r26 //load the LOW bits for timer
001bf2 93b0 0aad                 	sts TCB2_CCMPH, r27 //load the HIGH bits for timer
001bf4 93a0 28ef                 	sts triangle_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
001bf6 93b0 28f0                 	sts triangle_fx_3xx_target+1, r27
001bf8 c000                      	rjmp sound_driver_instrument_routine_channel2_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch:
001bf9 91e0 28d3                 	lds ZL, triangle_pitch_macro
001bfb 91f0 28d4                 	lds ZH, triangle_pitch_macro+1
001bfd 9630                      	adiw Z, 0
001bfe f409                      	brne sound_driver_instrument_routine_channel2_pitch_continue
001bff c023                      	rjmp sound_driver_instrument_routine_channel2_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel2_pitch_continue:
001c00 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
001c01 1fff                      	rol ZH
001c02 91a0 28d5                 	lds r26, triangle_pitch_macro_offset
001c04 0fea                      	add ZL, r26
001c05 1df2                      	adc ZH, zero
                                 
001c06 91b0 28d7                 	lds r27, triangle_pitch_macro_release
001c08 17ba                      	cp r27, r26
001c09 f429                      	brne sound_driver_instrument_routine_channel2_pitch_increment //if the current offset is not equal to the release index, increment the offset
001c0a 91a0 28d6                 	lds r26, triangle_pitch_macro_loop
001c0c 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
001c0d f010                      	brlo sound_driver_instrument_routine_channel2_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
001c0e c003                      	rjmp sound_driver_instrument_routine_channel2_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_pitch_increment:
001c0f 95a3                      	inc r26 //increment the macro offset
001c10 93a0 28d5                 	sts triangle_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_pitch_read:
001c12 91b4                      	lpm r27, Z //load pitch data into r27
001c13 38b0                      	cpi r27, 0x80 //check for macro end flag
001c14 f479                      	brne sound_driver_instrument_routine_channel2_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_release:
001c15 50a1                      	subi r26, 1 //keep the macro offset at the end flag
001c16 93a0 28d5                 	sts triangle_pitch_macro_offset, r26
001c18 91b0 28d7                 	lds r27, triangle_pitch_macro_release
001c1a 3fbf                      	cpi r27, 0xFF
001c1b f439                      	brne sound_driver_instrument_routine_channel2_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_loop:
001c1c 91b0 28d6                 	lds r27, triangle_pitch_macro_loop //load the loop index
001c1e 3fbf                      	cpi r27, 0xFF //check if there is a loop index
001c1f f019                      	breq sound_driver_instrument_routine_channel2_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
001c20 93b0 28d5                 	sts triangle_pitch_macro_offset, r27 //store the loop index into the offset
001c22 cfd6                      	rjmp sound_driver_instrument_routine_channel2_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_default:
001c23 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel2_pitch_calculate:
001c24 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001c25 937f                      	push r23
001c26 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
001c27 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001c28 0367                      	mulsu r22, r23
001c29 917f                      	pop r23
001c2a 916f                      	pop r22
                                 
001c2b 9416                      	lsr r1 //shift out the fractional bits
001c2c 9407                      	ror r0
001c2d 9416                      	lsr r1
001c2e 9407                      	ror r0
001c2f 9416                      	lsr r1
001c30 9407                      	ror r0
001c31 9416                      	lsr r1
001c32 9407                      	ror r0
001c33 fe13                      	sbrs r1, 3 //check if result was a negative number
001c34 c002                      	rjmp sound_driver_instrument_routine_channel2_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_negative:
001c35 efb0                      	ldi r27, 0xF0
001c36 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_offset:
001c37 91a0 28d1                 	lds r26, triangle_total_pitch_offset
001c39 91b0 28d2                 	lds r27, triangle_total_pitch_offset+1
001c3b 0e0a                      	add r0, r26
001c3c 1e1b                      	adc r1, r27
001c3d 9200 28d1                 	sts triangle_total_pitch_offset, r0
001c3f 9210 28d2                 	sts triangle_total_pitch_offset+1, r1
001c41 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
001c43 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
001c45 0da0                      	add r26, r0 //offset the timer values
001c46 1db1                      	adc r27, r1
                                 	
001c47 91c0 28e7                 	lds r28, triangle_fx_1xx_total
001c49 91d0 28e8                 	lds r29, triangle_fx_1xx_total+1
001c4b 1bac                      	sub r26, r28
001c4c 0bbd                      	sbc r27, r29
001c4d 91c0 28eb                 	lds r28, triangle_fx_2xx_total
001c4f 91d0 28ec                 	lds r29, triangle_fx_2xx_total+1
001c51 0fac                      	add r26, r28
001c52 1fbd                      	adc r27, r29
001c53 91c0 28fa                 	lds r28, triangle_fx_Pxx_total
001c55 91d0 28fb                 	lds r29, triangle_fx_Pxx_total+1
001c57 0fac                      	add r26, r28
001c58 1fbd                      	adc r27, r29
001c59 91c0 2900                 	lds r28, triangle_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
001c5b 91d0 2901                 	lds r29, triangle_fx_Qxy_total_offset+1
001c5d 1bac                      	sub r26, r28
001c5e 0bbd                      	sbc r27, r29
001c5f 91c0 2906                 	lds r28, triangle_fx_Rxy_total_offset
001c61 91d0 2907                 	lds r29, triangle_fx_Rxy_total_offset+1
001c63 0fac                      	add r26, r28
001c64 1fbd                      	adc r27, r29
                                 
001c65 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
001c67 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel2_hi_pitch:
001c69 91e0 28d9                 	lds ZL, triangle_hi_pitch_macro
001c6b 91f0 28da                 	lds ZH, triangle_hi_pitch_macro+1
001c6d 9630                      	adiw Z, 0
001c6e f409                      	brne sound_driver_instrument_routine_channel2_hi_pitch_continue
001c6f c03c                      	rjmp sound_driver_instrument_routine_channel2_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel2_hi_pitch_continue:
001c70 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
001c71 1fff                      	rol ZH
001c72 91a0 28db                 	lds r26, triangle_hi_pitch_macro_offset
001c74 0fea                      	add ZL, r26
001c75 1df2                      	adc ZH, zero
                                 
001c76 91b0 28dd                 	lds r27, triangle_hi_pitch_macro_release
001c78 17ba                      	cp r27, r26
001c79 f429                      	brne sound_driver_instrument_routine_channel2_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
001c7a 91a0 28dc                 	lds r26, triangle_hi_pitch_macro_loop
001c7c 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
001c7d f010                      	brlo sound_driver_instrument_routine_channel2_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
001c7e c003                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_increment:
001c7f 95a3                      	inc r26 //increment the macro offset
001c80 93a0 28db                 	sts triangle_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_hi_pitch_read:
001c82 91b4                      	lpm r27, Z //load hi pitch data into r27
001c83 38b0                      	cpi r27, 0x80 //check for macro end flag
001c84 f489                      	brne sound_driver_instrument_routine_channel2_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_release:
001c85 50a1                      	subi r26, 1 //keep the macro offset at the end flag
001c86 93a0 28db                 	sts triangle_hi_pitch_macro_offset, r26
001c88 91b0 28dd                 	lds r27, triangle_hi_pitch_macro_release
001c8a 3fbf                      	cpi r27, 0xFF
001c8b f439                      	brne sound_driver_instrument_routine_channel2_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_loop:
001c8c 91b0 28dc                 	lds r27, triangle_hi_pitch_macro_loop //load the loop index
001c8e 3fbf                      	cpi r27, 0xFF //check if there is a loop index
001c8f f019                      	breq sound_driver_instrument_routine_channel2_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
001c90 93b0 28db                 	sts triangle_hi_pitch_macro_offset, r27 //store the loop index into the offset
001c92 cfd6                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_default:
001c93 91b0 28d8                 	lds r27, triangle_total_hi_pitch_offset
001c95 c005                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate:
001c96 91a0 28d8                 	lds r26, triangle_total_hi_pitch_offset //load the total hi pitch offset to change
001c98 0fba                      	add r27, r26
001c99 93b0 28d8                 	sts triangle_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply:
001c9b 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001c9c 937f                      	push r23
001c9d 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
001c9e eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001c9f 0367                      	mulsu r22, r23
001ca0 917f                      	pop r23
001ca1 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_offset:
001ca2 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
001ca4 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
001ca6 0da0                      	add r26, r0 //offset the timer values
001ca7 1db1                      	adc r27, r1
001ca8 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
001caa 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: The triangle channel does not have a duty cycle
                                 sound_driver_instrument_routine_channel2_duty:
                                 
                                 
                                 
                                 sound_driver_channel2_fx_routines:
                                 sound_driver_channel2_fx_1xx_routine:
001cac 91e0 28e5                 	lds ZL, triangle_fx_1xx
001cae 91f0 28e6                 	lds ZH, triangle_fx_1xx+1
001cb0 9630                      	adiw Z, 0
001cb1 f051                      	breq sound_driver_channel2_fx_2xx_routine
                                 
001cb2 91a0 28e7                 	lds r26, triangle_fx_1xx_total //load the rate to change the pitch by
001cb4 91b0 28e8                 	lds r27, triangle_fx_1xx_total+1
001cb6 0fae                      	add r26, ZL //increase the total offset by the rate
001cb7 1fbf                      	adc r27, ZH
001cb8 93a0 28e7                 	sts triangle_fx_1xx_total, r26
001cba 93b0 28e8                 	sts triangle_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_2xx_routine:
001cbc 91e0 28e9                 	lds ZL, triangle_fx_2xx
001cbe 91f0 28ea                 	lds ZH, triangle_fx_2xx+1
001cc0 9630                      	adiw Z, 0
001cc1 f051                      	breq sound_driver_channel2_fx_3xx_routine
                                 
001cc2 91a0 28eb                 	lds r26, triangle_fx_2xx_total //load the rate to change the pitch by
001cc4 91b0 28ec                 	lds r27, triangle_fx_2xx_total+1
001cc6 0fae                      	add r26, ZL //increase the total offset by the rate
001cc7 1fbf                      	adc r27, ZH
001cc8 93a0 28eb                 	sts triangle_fx_2xx_total, r26
001cca 93b0 28ec                 	sts triangle_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_3xx_routine:
001ccc 91e0 28f1                 	lds ZL, triangle_fx_3xx_speed
001cce 91f0 28f2                 	lds ZH, triangle_fx_3xx_speed+1
001cd0 9630                      	adiw Z, 0
001cd1 f409                      	brne sound_driver_channel2_fx_3xx_routine_check_start
001cd2 c048                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_check_start:
001cd3 91a0 28ed                 	lds r26, triangle_fx_3xx_start
001cd5 91b0 28ee                 	lds r27, triangle_fx_3xx_start+1
001cd7 9610                      	adiw r26:r27, 0
001cd8 f409                      	brne sound_driver_channel2_fx_3xx_routine_main
001cd9 c041                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_main:
001cda 91c0 28ef                 	lds r28, triangle_fx_3xx_target
001cdc 91d0 28f0                 	lds r29, triangle_fx_3xx_target+1
                                 
001cde 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
001cdf 07bd                      	cpc r27, r29
001ce0 f011                      	breq sound_driver_channel2_fx_3xx_routine_disable
001ce1 f030                      	brlo sound_driver_channel2_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
001ce2 c01f                      	rjmp sound_driver_channel2_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel2_fx_3xx_routine_disable:
001ce3 9220 28ed                 	sts triangle_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
001ce5 9220 28ee                 	sts triangle_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
001ce7 c033                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_subtract:
001ce8 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
001ce9 0bdb                      	sbc r29, r27
001cea 91a0 28f3                 	lds r26, triangle_fx_3xx_total_offset
001cec 91b0 28f4                 	lds r27, triangle_fx_3xx_total_offset+1
                                 
001cee 0fae                      	add r26, ZL //add the speed to the total offset
001cef 1fbf                      	adc r27, ZH
001cf0 1bca                      	sub r28, r26 //invert the total difference with the total offset
001cf1 0bdb                      	sbc r29, r27
001cf2 f380                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
001cf3 93a0 28f3                 	sts triangle_fx_3xx_total_offset, r26 //store the new total offset
001cf5 93b0 28f4                 	sts triangle_fx_3xx_total_offset+1, r27
                                 
001cf7 91a0 0aac                 	lds r26, TCB2_CCMPL //load the current timer period
001cf9 91b0 0aad                 	lds r27, TCB2_CCMPH
001cfb 1bac                      	sub r26, r28 //offset the current timer period with the total offset
001cfc 0bbd                      	sbc r27, r29
001cfd 93a0 0aac                 	sts TCB2_CCMPL, r26
001cff 93b0 0aad                 	sts TCB2_CCMPH, r27
001d01 c019                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_add:
001d02 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
001d03 0bbd                      	sbc r27, r29
001d04 91c0 28f3                 	lds r28, triangle_fx_3xx_total_offset
001d06 91d0 28f4                 	lds r29, triangle_fx_3xx_total_offset+1
                                 
001d08 0fce                      	add r28, ZL //add the speed to the total offset
001d09 1fdf                      	adc r29, ZH
001d0a 1bac                      	sub r26, r28 //invert the total difference with the total offset
001d0b 0bbd                      	sbc r27, r29
001d0c f2b0                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
001d0d 93c0 28f3                 	sts triangle_fx_3xx_total_offset, r28 //store the new total offset
001d0f 93d0 28f4                 	sts triangle_fx_3xx_total_offset+1, r29
                                 
001d11 91c0 0aac                 	lds r28, TCB2_CCMPL //load the current timer period
001d13 91d0 0aad                 	lds r29, TCB2_CCMPH
001d15 0fca                      	add r28, r26 //offset the current timer period with the total offset
001d16 1fdb                      	adc r29, r27
001d17 93c0 0aac                 	sts TCB2_CCMPL, r28
001d19 93d0 0aad                 	sts TCB2_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel2_fx_4xy_routine:
001d1b 91a0 28f5                 	lds r26, triangle_fx_4xy_speed
001d1d 15a2                      	cp r26, zero
001d1e f409                      	brne sound_driver_channel2_fx_4xy_routine_continue
001d1f c05c                      	rjmp sound_driver_channel2_fx_Qxy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel2_fx_4xy_routine_continue:
001d20 91b0 28f6                 	lds r27, triangle_fx_4xy_depth
001d22 91c0 28f7                 	lds r28, triangle_fx_4xy_phase
001d24 0fca                      	add r28, r26 //increase the phase by the speed
001d25 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
001d26 f008                      	brlo sound_driver_channel2_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
001d27 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase:
001d28 93c0 28f7                 	sts triangle_fx_4xy_phase, r28 //store the new phase
001d2a 31c0                      	cpi r28, 16
001d2b f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_0
001d2c 32c0                      	cpi r28, 32
001d2d f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_1
001d2e 33c0                      	cpi r28, 48
001d2f f030                      	brlo sound_driver_channel2_fx_4xy_routine_phase_2
001d30 c007                      	rjmp sound_driver_channel2_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_0:
001d31 70cf                      	andi r28, 0x0F //mask for values 0-15
001d32 c029                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_1:
001d33 6fc0                      	ori r28, 0xF0
001d34 95c0                      	com r28 //invert values 0-15
001d35 c026                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_2:
001d36 70cf                      	andi r28, 0x0F //mask for values 0-15
001d37 c003                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_3:
001d38 6fc0                      	ori r28, 0xF0
001d39 95c0                      	com r28 //invert values 0-15
001d3a c000                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_add:
001d3b 95b2                      	swap r27 //multiply depth by 16
001d3c 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
001d3d e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
001d3e e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
001d3f 0fec                      	add ZL, r28 //offset the table by the depth+phase
001d40 1df2                      	adc ZH, zero
001d41 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
001d42 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001d43 937f                      	push r23
001d44 2f6c                      	mov r22, r28 //store the vibrato value into r22
001d45 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001d46 9f67                      	mul r22, r23
001d47 917f                      	pop r23
001d48 916f                      	pop r22
                                 
001d49 9416                      	lsr r1 //shift out the fractional bits
001d4a 9407                      	ror r0
001d4b 9416                      	lsr r1
001d4c 9407                      	ror r0
001d4d 9416                      	lsr r1
001d4e 9407                      	ror r0
001d4f 9416                      	lsr r1
001d50 9407                      	ror r0
                                 	
001d51 91a0 0aac                 	lds r26, TCB2_CCMPL
001d53 91b0 0aad                 	lds r27, TCB2_CCMPH
001d55 0da0                      	add r26, r0
001d56 1db1                      	adc r27, r1
001d57 93a0 0aac                 	sts TCB2_CCMPL, r26
001d59 93b0 0aad                 	sts TCB2_CCMPH, r27
001d5b c020                      	rjmp sound_driver_channel2_fx_Qxy_routine
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_subtract:
001d5c 95b2                      	swap r27 //multiply depth by 16
001d5d 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
001d5e e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
001d5f e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
001d60 0fec                      	add ZL, r28 //offset the table by the depth+phase
001d61 1df2                      	adc ZH, zero
001d62 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
001d63 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001d64 937f                      	push r23
001d65 2f6c                      	mov r22, r28 //store the vibrato value into r22
001d66 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001d67 9f67                      	mul r22, r23
001d68 917f                      	pop r23
001d69 916f                      	pop r22
                                 
001d6a 9416                      	lsr r1 //shift out the fractional bits
001d6b 9407                      	ror r0
001d6c 9416                      	lsr r1
001d6d 9407                      	ror r0
001d6e 9416                      	lsr r1
001d6f 9407                      	ror r0
001d70 9416                      	lsr r1
001d71 9407                      	ror r0
                                 
001d72 91a0 0aac                 	lds r26, TCB2_CCMPL
001d74 91b0 0aad                 	lds r27, TCB2_CCMPH
001d76 19a0                      	sub r26, r0
001d77 09b1                      	sbc r27, r1
001d78 93a0 0aac                 	sts TCB2_CCMPL, r26
001d7a 93b0 0aad                 	sts TCB2_CCMPH, r27
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel2_fx_Qxy_routine:
001d7c 91e0 28fc                 	lds ZL, triangle_fx_Qxy_target
001d7e 91f0 28fd                 	lds ZH, triangle_fx_Qxy_target+1
001d80 9630                      	adiw Z, 0
001d81 f139                      	breq sound_driver_channel2_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
001d82 91a0 2900                 	lds r26, triangle_fx_Qxy_total_offset
001d84 91b0 2901                 	lds r27, triangle_fx_Qxy_total_offset+1
001d86 91c0 0aac                 	lds r28, TCB2_CCMPL
001d88 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
001d8a 1bec                      	sub ZL, r28 //calculate the difference to the target
001d8b 0bfd                      	sbc ZH, r29
001d8c f408                      	brsh sound_driver_channel2_fx_Qxy_routine_end //if the target has been reached (or passed)
001d8d f088                      	brlo sound_driver_channel2_fx_Qxy_routine_add
                                 
                                 sound_driver_channel2_fx_Qxy_routine_end:
001d8e 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
001d8f 0bbf                      	sbc r27, ZH
                                 
001d90 91c0 28fa                 	lds r28, triangle_fx_Pxx_total
001d92 91d0 28fb                 	lds r29, triangle_fx_Pxx_total+1
                                 
001d94 0fac                      	add r26, r28
001d95 1fbd                      	adc r27, r29
                                 
001d96 93a0 2900                 	sts triangle_fx_Qxy_total_offset, r26 //store the total offset
001d98 93b0 2901                 	sts triangle_fx_Qxy_total_offset+1, r27
001d9a 9220 28fc                 	sts triangle_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
001d9c 9220 28fd                 	sts triangle_fx_Qxy_target+1, zero
001d9e c00a                      	rjmp sound_driver_channel2_fx_Rxy_routine
                                 
                                 sound_driver_channel2_fx_Qxy_routine_add:
001d9f 91c0 28fe                 	lds r28, triangle_fx_Qxy_speed
001da1 91d0 28ff                 	lds r29, triangle_fx_Qxy_speed+1
001da3 0fac                      	add r26, r28 //increase the total offset by the speed
001da4 1fbd                      	adc r27, r29
001da5 93a0 2900                 	sts triangle_fx_Qxy_total_offset, r26 //store the total offset
001da7 93b0 2901                 	sts triangle_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_Rxy_routine:
001da9 91e0 2902                 	lds ZL, triangle_fx_Rxy_target
001dab 91f0 2903                 	lds ZH, triangle_fx_Rxy_target+1
001dad 9630                      	adiw Z, 0
001dae f139                      	breq sound_driver_instrument_routine_channel3_volume //if the effect is not enabled, skip the routine
                                 
001daf 91a0 2906                 	lds r26, triangle_fx_Rxy_total_offset
001db1 91b0 2907                 	lds r27, triangle_fx_Rxy_total_offset+1
001db3 91c0 0aac                 	lds r28, TCB2_CCMPL
001db5 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
001db7 1bce                      	sub r28, ZL //calculate the difference to the target
001db8 0bdf                      	sbc r29, ZH
001db9 f408                      	brsh sound_driver_channel2_fx_Rxy_routine_end //if the target has been reached (or passed)
001dba f088                      	brlo sound_driver_channel2_fx_Rxy_routine_add
                                 
                                 sound_driver_channel2_fx_Rxy_routine_end:
001dbb 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
001dbc 0bbd                      	sbc r27, r29
                                 
001dbd 91c0 28fa                 	lds r28, triangle_fx_Pxx_total
001dbf 91d0 28fb                 	lds r29, triangle_fx_Pxx_total+1
                                 
001dc1 0fac                      	add r26, r28
001dc2 1fbd                      	adc r27, r29
                                 
001dc3 93a0 2906                 	sts triangle_fx_Rxy_total_offset, r26 //store the total offset
001dc5 93b0 2907                 	sts triangle_fx_Rxy_total_offset+1, r27
001dc7 9220 2902                 	sts triangle_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
001dc9 9220 2903                 	sts triangle_fx_Rxy_target+1, zero
001dcb c00a                      	rjmp sound_driver_instrument_routine_channel3_volume
                                 
                                 sound_driver_channel2_fx_Rxy_routine_add:
001dcc 91c0 2904                 	lds r28, triangle_fx_Rxy_speed
001dce 91d0 2905                 	lds r29, triangle_fx_Rxy_speed+1
001dd0 0fac                      	add r26, r28 //increase the total offset by the speed
001dd1 1fbd                      	adc r27, r29
001dd2 93a0 2906                 	sts triangle_fx_Rxy_total_offset, r26 //store the total offset
001dd4 93b0 2907                 	sts triangle_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume:
001dd6 91e0 2910                 	lds ZL, noise_volume_macro
001dd8 91f0 2911                 	lds ZH, noise_volume_macro+1
001dda 9630                      	adiw Z, 0
001ddb f1a1                      	breq sound_driver_instrument_routine_channel3_volume_default //if no volume macro is in use, use default multiplier of F
001ddc 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
001ddd 1fff                      	rol ZH
001dde 91a0 2912                 	lds r26, noise_volume_macro_offset
001de0 0fea                      	add ZL, r26
001de1 1df2                      	adc ZH, zero
                                 
001de2 91b0 2914                 	lds r27, noise_volume_macro_release
001de4 17ba                      	cp r27, r26
001de5 f429                      	brne sound_driver_instrument_routine_channel3_volume_increment //if the current offset is not equal to the release index, increment the offset
001de6 91a0 2913                 	lds r26, noise_volume_macro_loop
001de8 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
001de9 f010                      	brlo sound_driver_instrument_routine_channel3_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
001dea c003                      	rjmp sound_driver_instrument_routine_channel3_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_volume_increment:
001deb 95a3                      	inc r26 //increment the macro offset
001dec 93a0 2912                 	sts noise_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_volume_read:
001dee 91b4                      	lpm r27, Z //load volume data into r27
001def 3fbf                      	cpi r27, 0xFF //check for macro end flag
001df0 f469                      	brne sound_driver_instrument_routine_channel3_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_check_release:
001df1 91b0 2914                 	lds r27, noise_volume_macro_release
001df3 3fbf                      	cpi r27, 0xFF
001df4 f429                      	brne sound_driver_instrument_routine_channel3_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_check_loop:
001df5 91b0 2913                 	lds r27, noise_volume_macro_loop //load the loop index
001df7 93b0 2912                 	sts noise_volume_macro_offset, r27 //store the loop index into the offset
001df9 cfdc                      	rjmp sound_driver_instrument_routine_channel3_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_last_index:
001dfa 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
001dfb 93a0 2912                 	sts noise_volume_macro_offset, r26
001dfd cfd8                      	rjmp sound_driver_instrument_routine_channel3_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume_calculate:
001dfe e3ee                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
001dff e4f3                      	ldi ZH, HIGH(volumes << 1)
001e00 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
001e01 0feb                      	add ZL, r27 //add offset to the table
001e02 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel3_volume_load:
001e03 91b0 2813                 	lds r27, noise_param //load main volume
001e05 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
001e06 91a0 2945                 	lds r26, noise_fx_7xy_value
001e08 30a0                      	cpi r26, 0x00
001e09 f481                      	brne sound_driver_instrument_routine_channel3_volume_load_7xy
                                 
001e0a 0feb                      	add ZL, r27 //offset the volume table by the main volume
001e0b 1df2                      	adc ZH, zero
001e0c 91b4                      	lpm r27, Z
001e0d 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
001e0f c024                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_default:
001e10 91b0 2813                 	lds r27, noise_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
001e12 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
001e13 91a0 2945                 	lds r26, noise_fx_7xy_value
001e15 30a0                      	cpi r26, 0x00
001e16 f4a1                      	brne sound_driver_instrument_routine_channel3_volume_default_7xy
001e17 93b0 2816                 	sts noise_output_volume, r27
001e19 c01a                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_load_7xy:
001e1a 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
001e1b f040                      	brcs sound_driver_instrument_routine_channel3_volume_load_7xy_overflow
001e1c f039                      	breq sound_driver_instrument_routine_channel3_volume_load_7xy_overflow
001e1d e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
                                 
001e1e 0feb                      	add ZL, r27 //offset the volume table by the main volume
001e1f 1df2                      	adc ZH, zero
001e20 91b4                      	lpm r27, Z
001e21 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
001e23 c010                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_load_7xy_overflow:
001e24 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
001e25 0feb                      	add ZL, r27 //offset the volume table by the main volume
001e26 1df2                      	adc ZH, zero
001e27 91b4                      	lpm r27, Z
001e28 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
001e2a c009                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_default_7xy:
001e2b 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
001e2c f020                      	brcs sound_driver_instrument_routine_channel3_volume_default_7xy_overflow
001e2d f019                      	breq sound_driver_instrument_routine_channel3_volume_default_7xy_overflow
001e2e 93b0 2816                 	sts noise_output_volume, r27
001e30 c003                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel3_volume_default_7xy_overflow:
001e31 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
001e32 93b0 2816                 	sts noise_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
001e34 91e0 2915                 	lds ZL, noise_arpeggio_macro
001e36 91f0 2916                 	lds ZH, noise_arpeggio_macro+1
001e38 9630                      	adiw Z, 0
001e39 f1d9                      	breq sound_driver_instrument_routine_channel3_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
001e3a 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
001e3b 1fff                      	rol ZH
001e3c 91a0 2917                 	lds r26, noise_arpeggio_macro_offset
001e3e 0fea                      	add ZL, r26
001e3f 1df2                      	adc ZH, zero
                                 
001e40 91b0 2919                 	lds r27, noise_arpeggio_macro_release
001e42 17ba                      	cp r27, r26
001e43 f429                      	brne sound_driver_instrument_routine_channel3_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
001e44 91a0 2918                 	lds r26, noise_arpeggio_macro_loop
001e46 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
001e47 f010                      	brlo sound_driver_instrument_routine_channel3_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
001e48 c003                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_increment:
001e49 95a3                      	inc r26 //increment the macro offset
001e4a 93a0 2917                 	sts noise_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_arpeggio_read:
001e4c 91b4                      	lpm r27, Z //load arpeggio data into r27
001e4d 38b0                      	cpi r27, 0x80 //check for macro end flag
001e4e f009                      	breq sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag
001e4f c041                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_check_mode:
001e50 50a1                      	subi r26, 1 //keep the offset at the end flag
001e51 93a0 2917                 	sts noise_arpeggio_macro_offset, r26
001e53 91b0 291a                 	lds r27, noise_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
001e55 30b1                      	cpi r27, 0x01
001e56 f048                      	brlo sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_fixed_relative_check_release:
001e57 91b0 2919                 	lds r27, noise_arpeggio_macro_release
001e59 3fbf                      	cpi r27, 0xFF
001e5a f4d1                      	brne sound_driver_instrument_routine_channel3_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_fixed_relative_check_loop:
001e5b 91b0 2918                 	lds r27, noise_arpeggio_macro_loop
001e5d 3fbf                      	cpi r27, 0xFF
001e5e f499                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
001e5f c015                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute:
001e60 91b0 2919                 	lds r27, noise_arpeggio_macro_release
001e62 3fbf                      	cpi r27, 0xFF
001e63 f421                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_check_loop:
001e64 91b0 2918                 	lds r27, noise_arpeggio_macro_loop //load the loop index
001e66 3fbf                      	cpi r27, 0xFF //check if loop flag exists
001e67 f451                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_no_loop:
001e68 91c0 292d                 	lds r28, noise_fx_0xy_sequence //check for 0xy effect
001e6a 91d0 292e                 	lds r29, noise_fx_0xy_sequence+1
001e6c 9620                      	adiw r29:r28, 0
001e6d f469                      	brne sound_driver_instrument_routine_channel3_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
001e6e 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
001e6f 93a0 2917                 	sts noise_arpeggio_macro_offset, r26 //store the last valid index into the offset
001e71 cfc2                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload:
001e72 93b0 2917                 	sts noise_arpeggio_macro_offset, r27 //store the loop index into the offset
001e74 cfbf                      	rjmp sound_driver_instrument_routine_channel3_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_default:
001e75 91c0 292d                 	lds r28, noise_fx_0xy_sequence //load 0xy effect
001e77 91d0 292e                 	lds r29, noise_fx_0xy_sequence+1
001e79 9620                      	adiw r29:r28, 0 //check for 0xy effect
001e7a f099                      	breq sound_driver_instrument_routine_channel3_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel3_arpeggio_default_xy:
001e7b 95d6                      	lsr r29
001e7c 95c7                      	ror r28
001e7d 95d7                      	ror r29
001e7e 95c7                      	ror r28
001e7f 95d7                      	ror r29
001e80 95c7                      	ror r28
001e81 95d7                      	ror r29
001e82 95c7                      	ror r28
001e83 95d7                      	ror r29
001e84 95d2                      	swap r29
                                 
001e85 93c0 292d                 	sts noise_fx_0xy_sequence, r28 //store the rolled sequence
001e87 93d0 292e                 	sts noise_fx_0xy_sequence+1, r29
001e89 70cf                      	andi r28, 0x0F //mask out the 4 LSB
001e8a 91a0 2817                 	lds r26, noise_note //load the current note index
001e8c 0fac                      	add r26, r28 //add the note offset
001e8d c02e                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel3_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
001e8e 91a0 2817                 	lds r26, noise_note //load the current note index
001e90 c02b                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process:
001e91 9220 291b                 	sts noise_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
001e93 9220 291c                 	sts noise_total_pitch_offset+1, zero
001e95 9220 2922                 	sts noise_total_hi_pitch_offset, zero
001e97 91a0 291a                 	lds r26, noise_arpeggio_macro_mode
001e99 30a1                      	cpi r26, 0x01 //absolute mode
001e9a f010                      	brlo sound_driver_instrument_routine_channel3_arpeggio_process_absolute
001e9b f069                      	breq sound_driver_instrument_routine_channel3_arpeggio_process_fixed
001e9c c00e                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_absolute:
001e9d 91a0 2817                 	lds r26, noise_note //load the current note index
001e9f 0fab                      	add r26, r27 //offset the note with the arpeggio data
001ea0 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
001ea1 c004                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_absolute_add:
001ea2 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
001ea3 f0c0                      	brlo sound_driver_instrument_routine_channel3_arpeggio_process_load //if the result is valid, go load the new note
001ea4 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
001ea5 c016                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_absolute_subtract:
001ea6 fda7                      	sbrc r26, 7 //check if result is negative
001ea7 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
001ea8 c013                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_fixed:
001ea9 2fab                      	mov r26, r27 //move the arpeggio data into r26
001eaa c011                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_relative:
001eab 91a0 2817                 	lds r26, noise_note //load the current note index
001ead 0fab                      	add r26, r27 //offset the note with the arpeggio data
001eae fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
001eaf c008                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_relative_add:
001eb0 93a0 2817                 	sts noise_note, r26 //NOTE: relative mode modifies the original note index
001eb2 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
001eb3 f040                      	brlo sound_driver_instrument_routine_channel3_arpeggio_process_load //if the result is valid, go load the new note
001eb4 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
001eb5 93a0 2817                 	sts noise_note, r26
001eb7 c004                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_relative_subtract:
001eb8 fda7                      	sbrc r26, 7 //check if result is negative
001eb9 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
001eba 93a0 2817                 	sts noise_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_load:
001ebc e4e2                      	ldi ZL, LOW(noise_period_table << 1) //load in note table
001ebd e0f1                      	ldi ZH, HIGH(noise_period_table << 1)
001ebe 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
001ebf 0fea                      	add ZL, r26 //add offset
001ec0 1df2                      	adc ZH, zero
001ec1 91a5                      	lpm r26, Z+ //load bytes
001ec2 91b4                      	lpm r27, Z
001ec3 93a0 0abc                 	sts TCB3_CCMPL, r26 //load the LOW bits for timer
001ec5 93b0 0abd                 	sts TCB3_CCMPH, r27 //load the HIGH bits for timer
001ec7 93a0 2939                 	sts noise_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
001ec9 93b0 293a                 	sts noise_fx_3xx_target+1, r27
001ecb c000                      	rjmp sound_driver_instrument_routine_channel3_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch:
001ecc 91e0 291d                 	lds ZL, noise_pitch_macro
001ece 91f0 291e                 	lds ZH, noise_pitch_macro+1
001ed0 9630                      	adiw Z, 0
001ed1 f409                      	brne sound_driver_instrument_routine_channel3_pitch_continue
001ed2 c023                      	rjmp sound_driver_instrument_routine_channel3_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel3_pitch_continue:
001ed3 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
001ed4 1fff                      	rol ZH
001ed5 91a0 291f                 	lds r26, noise_pitch_macro_offset
001ed7 0fea                      	add ZL, r26
001ed8 1df2                      	adc ZH, zero
                                 
001ed9 91b0 2921                 	lds r27, noise_pitch_macro_release
001edb 17ba                      	cp r27, r26
001edc f429                      	brne sound_driver_instrument_routine_channel3_pitch_increment //if the current offset is not equal to the release index, increment the offset
001edd 91a0 2920                 	lds r26, noise_pitch_macro_loop
001edf 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
001ee0 f010                      	brlo sound_driver_instrument_routine_channel3_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
001ee1 c003                      	rjmp sound_driver_instrument_routine_channel3_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_pitch_increment:
001ee2 95a3                      	inc r26 //increment the macro offset
001ee3 93a0 291f                 	sts noise_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_pitch_read:
001ee5 91b4                      	lpm r27, Z //load pitch data into r27
001ee6 38b0                      	cpi r27, 0x80 //check for macro end flag
001ee7 f479                      	brne sound_driver_instrument_routine_channel3_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag_check_release:
001ee8 50a1                      	subi r26, 1 //keep the macro offset at the end flag
001ee9 93a0 291f                 	sts noise_pitch_macro_offset, r26
001eeb 91b0 2921                 	lds r27, noise_pitch_macro_release
001eed 3fbf                      	cpi r27, 0xFF
001eee f439                      	brne sound_driver_instrument_routine_channel3_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag_check_loop:
001eef 91b0 2920                 	lds r27, noise_pitch_macro_loop //load the loop index
001ef1 3fbf                      	cpi r27, 0xFF //check if there is a loop index
001ef2 f019                      	breq sound_driver_instrument_routine_channel3_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
001ef3 93b0 291f                 	sts noise_pitch_macro_offset, r27 //store the loop index into the offset
001ef5 cfd6                      	rjmp sound_driver_instrument_routine_channel3_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch_default:
001ef6 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel3_pitch_calculate:
001ef7 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001ef8 937f                      	push r23
001ef9 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
001efa eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001efb 0367                      	mulsu r22, r23
001efc 917f                      	pop r23
001efd 916f                      	pop r22
                                 
001efe 9416                      	lsr r1 //shift out the fractional bits
001eff 9407                      	ror r0
001f00 9416                      	lsr r1
001f01 9407                      	ror r0
001f02 9416                      	lsr r1
001f03 9407                      	ror r0
001f04 9416                      	lsr r1
001f05 9407                      	ror r0
001f06 fe13                      	sbrs r1, 3 //check if result was a negative number
001f07 c002                      	rjmp sound_driver_instrument_routine_channel3_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel3_pitch_calculate_negative:
001f08 efb0                      	ldi r27, 0xF0
001f09 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel3_pitch_calculate_offset:
001f0a 91a0 291b                 	lds r26, noise_total_pitch_offset
001f0c 91b0 291c                 	lds r27, noise_total_pitch_offset+1
001f0e 0e0a                      	add r0, r26
001f0f 1e1b                      	adc r1, r27
001f10 9200 291b                 	sts noise_total_pitch_offset, r0
001f12 9210 291c                 	sts noise_total_pitch_offset+1, r1
001f14 91a0 0abc                 	lds r26, TCB3_CCMPL //load the low bits for timer
001f16 91b0 0abd                 	lds r27, TCB3_CCMPH //load the high bits for timer
001f18 0da0                      	add r26, r0 //offset the timer values
001f19 1db1                      	adc r27, r1
                                 	
001f1a 91c0 2931                 	lds r28, noise_fx_1xx_total
001f1c 91d0 2932                 	lds r29, noise_fx_1xx_total+1
001f1e 1bac                      	sub r26, r28
001f1f 0bbd                      	sbc r27, r29
001f20 91c0 2935                 	lds r28, noise_fx_2xx_total
001f22 91d0 2936                 	lds r29, noise_fx_2xx_total+1
001f24 0fac                      	add r26, r28
001f25 1fbd                      	adc r27, r29
001f26 91c0 2949                 	lds r28, noise_fx_Pxx_total
001f28 91d0 294a                 	lds r29, noise_fx_Pxx_total+1
001f2a 0fac                      	add r26, r28
001f2b 1fbd                      	adc r27, r29
001f2c 91c0 294f                 	lds r28, noise_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
001f2e 91d0 2950                 	lds r29, noise_fx_Qxy_total_offset+1
001f30 1bac                      	sub r26, r28
001f31 0bbd                      	sbc r27, r29
001f32 91c0 2955                 	lds r28, noise_fx_Rxy_total_offset
001f34 91d0 2956                 	lds r29, noise_fx_Rxy_total_offset+1
001f36 0fac                      	add r26, r28
001f37 1fbd                      	adc r27, r29
                                 
001f38 93a0 0abc                 	sts TCB3_CCMPL, r26 //store the new low bits for timer
001f3a 93b0 0abd                 	sts TCB3_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel3_hi_pitch:
001f3c 91e0 2923                 	lds ZL, noise_hi_pitch_macro
001f3e 91f0 2924                 	lds ZH, noise_hi_pitch_macro+1
001f40 9630                      	adiw Z, 0
001f41 f409                      	brne sound_driver_instrument_routine_channel3_hi_pitch_continue
001f42 c03c                      	rjmp sound_driver_instrument_routine_channel3_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel3_hi_pitch_continue:
001f43 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
001f44 1fff                      	rol ZH
001f45 91a0 2925                 	lds r26, noise_hi_pitch_macro_offset
001f47 0fea                      	add ZL, r26
001f48 1df2                      	adc ZH, zero
                                 
001f49 91b0 2927                 	lds r27, noise_hi_pitch_macro_release
001f4b 17ba                      	cp r27, r26
001f4c f429                      	brne sound_driver_instrument_routine_channel3_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
001f4d 91a0 2926                 	lds r26, noise_hi_pitch_macro_loop
001f4f 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
001f50 f010                      	brlo sound_driver_instrument_routine_channel3_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
001f51 c003                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_increment:
001f52 95a3                      	inc r26 //increment the macro offset
001f53 93a0 2925                 	sts noise_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_hi_pitch_read:
001f55 91b4                      	lpm r27, Z //load hi pitch data into r27
001f56 38b0                      	cpi r27, 0x80 //check for macro end flag
001f57 f489                      	brne sound_driver_instrument_routine_channel3_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag_check_release:
001f58 50a1                      	subi r26, 1 //keep the macro offset at the end flag
001f59 93a0 2925                 	sts noise_hi_pitch_macro_offset, r26
001f5b 91b0 2927                 	lds r27, noise_hi_pitch_macro_release
001f5d 3fbf                      	cpi r27, 0xFF
001f5e f439                      	brne sound_driver_instrument_routine_channel3_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag_check_loop:
001f5f 91b0 2926                 	lds r27, noise_hi_pitch_macro_loop //load the loop index
001f61 3fbf                      	cpi r27, 0xFF //check if there is a loop index
001f62 f019                      	breq sound_driver_instrument_routine_channel3_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
001f63 93b0 2925                 	sts noise_hi_pitch_macro_offset, r27 //store the loop index into the offset
001f65 cfd6                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_default:
001f66 91b0 2922                 	lds r27, noise_total_hi_pitch_offset
001f68 c005                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate:
001f69 91a0 2922                 	lds r26, noise_total_hi_pitch_offset //load the total hi pitch offset to change
001f6b 0fba                      	add r27, r26
001f6c 93b0 2922                 	sts noise_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate_multiply:
001f6e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001f6f 937f                      	push r23
001f70 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
001f71 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001f72 0367                      	mulsu r22, r23
001f73 917f                      	pop r23
001f74 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate_offset:
001f75 91a0 0abc                 	lds r26, TCB3_CCMPL //load the low bits for timer
001f77 91b0 0abd                 	lds r27, TCB3_CCMPH //load the high bits for timer
001f79 0da0                      	add r26, r0 //offset the timer values
001f7a 1db1                      	adc r27, r1
001f7b 93a0 0abc                 	sts TCB3_CCMPL, r26 //store the new low bits for timer
001f7d 93b0 0abd                 	sts TCB3_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty:
001f7f 91e0 2928                 	lds ZL, noise_duty_macro
001f81 91f0 2929                 	lds ZH, noise_duty_macro+1
001f83 9630                      	adiw Z, 0
001f84 f169                      	breq sound_driver_channel3_fx_routines //if no duty macro is in use, go to the next routine
001f85 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
001f86 1fff                      	rol ZH
001f87 91a0 292a                 	lds r26, noise_duty_macro_offset
001f89 0fea                      	add ZL, r26
001f8a 1df2                      	adc ZH, zero
                                 
001f8b 91b0 292c                 	lds r27, noise_duty_macro_release
001f8d 17ba                      	cp r27, r26
001f8e f429                      	brne sound_driver_instrument_routine_channel3_duty_increment //if the current offset is not equal to the release index, increment the offset
001f8f 91a0 292b                 	lds r26, noise_duty_macro_loop
001f91 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
001f92 f010                      	brlo sound_driver_instrument_routine_channel3_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
001f93 c01e                      	rjmp sound_driver_channel3_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel3_duty_increment:
001f94 95a3                      	inc r26 //increment the macro offset
001f95 93a0 292a                 	sts noise_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_duty_read:
001f97 91b4                      	lpm r27, Z //load pitch data into r27
001f98 3fbf                      	cpi r27, 0xFF //check for macro end flag
001f99 f471                      	brne sound_driver_instrument_routine_channel3_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag_check_release:
001f9a 50a1                      	subi r26, 1 //keep the macro offset at the end flag
001f9b 93a0 292a                 	sts noise_duty_macro_offset, r26
001f9d 91b0 292c                 	lds r27, noise_duty_macro_release
001f9f 3fbf                      	cpi r27, 0xFF
001fa0 f489                      	brne sound_driver_channel3_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag_check_loop:
001fa1 91b0 292b                 	lds r27, noise_duty_macro_loop //load the loop index
001fa3 3fbf                      	cpi r27, 0xFF //check if there is a loop index
001fa4 f069                      	breq sound_driver_channel3_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
001fa5 93b0 292a                 	sts noise_duty_macro_offset, r27 //store the loop index into the offset
001fa7 cfd7                      	rjmp sound_driver_instrument_routine_channel3_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty_load:
001fa8 95b6                      	lsr r27
001fa9 95b7                      	ror r27 //move mode bit to bit 7
001faa 91c0 2814                 	lds r28, noise_period
001fac 77cf                      	andi r28, 0b01111111
001fad 2bcb                      	or r28, r27 //store the new noise mode
001fae 93c0 2813                 	sts noise_param, r28
                                 
001fb0 776f                      	andi noise_sequence_HIGH, 0b01111111
001fb1 2b6b                      	or noise_sequence_HIGH, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_routines:
                                 sound_driver_channel3_fx_1xx_routine:
001fb2 91e0 292f                 	lds ZL, noise_fx_1xx
001fb4 91f0 2930                 	lds ZH, noise_fx_1xx+1
001fb6 9630                      	adiw Z, 0
001fb7 f051                      	breq sound_driver_channel3_fx_2xx_routine
                                 
001fb8 91a0 2931                 	lds r26, noise_fx_1xx_total //load the rate to change the pitch by
001fba 91b0 2932                 	lds r27, noise_fx_1xx_total+1
001fbc 0fae                      	add r26, ZL //increase the total offset by the rate
001fbd 1fbf                      	adc r27, ZH
001fbe 93a0 2931                 	sts noise_fx_1xx_total, r26
001fc0 93b0 2932                 	sts noise_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_2xx_routine:
001fc2 91e0 2933                 	lds ZL, noise_fx_2xx
001fc4 91f0 2934                 	lds ZH, noise_fx_2xx+1
001fc6 9630                      	adiw Z, 0
001fc7 f051                      	breq sound_driver_channel3_fx_3xx_routine
                                 
001fc8 91a0 2935                 	lds r26, noise_fx_2xx_total //load the rate to change the pitch by
001fca 91b0 2936                 	lds r27, noise_fx_2xx_total+1
001fcc 0fae                      	add r26, ZL //increase the total offset by the rate
001fcd 1fbf                      	adc r27, ZH
001fce 93a0 2935                 	sts noise_fx_2xx_total, r26
001fd0 93b0 2936                 	sts noise_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_3xx_routine:
001fd2 91e0 293b                 	lds ZL, noise_fx_3xx_speed
001fd4 91f0 293c                 	lds ZH, noise_fx_3xx_speed+1
001fd6 9630                      	adiw Z, 0
001fd7 f409                      	brne sound_driver_channel3_fx_3xx_routine_check_start
001fd8 c048                      	rjmp sound_driver_channel3_fx_4xy_routine
                                 
                                 sound_driver_channel3_fx_3xx_routine_check_start:
001fd9 91a0 2937                 	lds r26, noise_fx_3xx_start
001fdb 91b0 2938                 	lds r27, noise_fx_3xx_start+1
001fdd 9610                      	adiw r26:r27, 0
001fde f409                      	brne sound_driver_channel3_fx_3xx_routine_main
001fdf c041                      	rjmp sound_driver_channel3_fx_4xy_routine
                                 
                                 sound_driver_channel3_fx_3xx_routine_main:
001fe0 91c0 2939                 	lds r28, noise_fx_3xx_target
001fe2 91d0 293a                 	lds r29, noise_fx_3xx_target+1
                                 
001fe4 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
001fe5 07bd                      	cpc r27, r29
001fe6 f011                      	breq sound_driver_channel3_fx_3xx_routine_disable
001fe7 f030                      	brlo sound_driver_channel3_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
001fe8 c01f                      	rjmp sound_driver_channel3_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel3_fx_3xx_routine_disable:
001fe9 9220 2937                 	sts noise_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
001feb 9220 2938                 	sts noise_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
001fed c033                      	rjmp sound_driver_channel3_fx_4xy_routine
                                 
                                 sound_driver_channel3_fx_3xx_routine_subtract:
001fee 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
001fef 0bdb                      	sbc r29, r27
001ff0 91a0 293d                 	lds r26, noise_fx_3xx_total_offset
001ff2 91b0 293e                 	lds r27, noise_fx_3xx_total_offset+1
                                 
001ff4 0fae                      	add r26, ZL //add the speed to the total offset
001ff5 1fbf                      	adc r27, ZH
001ff6 1bca                      	sub r28, r26 //invert the total difference with the total offset
001ff7 0bdb                      	sbc r29, r27
001ff8 f380                      	brlo sound_driver_channel3_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
001ff9 93a0 293d                 	sts noise_fx_3xx_total_offset, r26 //store the new total offset
001ffb 93b0 293e                 	sts noise_fx_3xx_total_offset+1, r27
                                 
001ffd 91a0 0abc                 	lds r26, TCB3_CCMPL //load the current timer period
001fff 91b0 0abd                 	lds r27, TCB3_CCMPH
002001 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002002 0bbd                      	sbc r27, r29
002003 93a0 0abc                 	sts TCB3_CCMPL, r26
002005 93b0 0abd                 	sts TCB3_CCMPH, r27
002007 c019                      	rjmp sound_driver_channel3_fx_4xy_routine
                                 
                                 sound_driver_channel3_fx_3xx_routine_add:
002008 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002009 0bbd                      	sbc r27, r29
00200a 91c0 293d                 	lds r28, noise_fx_3xx_total_offset
00200c 91d0 293e                 	lds r29, noise_fx_3xx_total_offset+1
                                 
00200e 0fce                      	add r28, ZL //add the speed to the total offset
00200f 1fdf                      	adc r29, ZH
002010 1bac                      	sub r26, r28 //invert the total difference with the total offset
002011 0bbd                      	sbc r27, r29
002012 f2b0                      	brlo sound_driver_channel3_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002013 93c0 293d                 	sts noise_fx_3xx_total_offset, r28 //store the new total offset
002015 93d0 293e                 	sts noise_fx_3xx_total_offset+1, r29
                                 
002017 91c0 0abc                 	lds r28, TCB3_CCMPL //load the current timer period
002019 91d0 0abd                 	lds r29, TCB3_CCMPH
00201b 0fca                      	add r28, r26 //offset the current timer period with the total offset
00201c 1fdb                      	adc r29, r27
00201d 93c0 0abc                 	sts TCB3_CCMPL, r28
00201f 93d0 0abd                 	sts TCB3_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel3_fx_4xy_routine:
002021 91a0 293f                 	lds r26, noise_fx_4xy_speed
002023 15a2                      	cp r26, zero
002024 f409                      	brne sound_driver_channel3_fx_4xy_routine_continue
002025 c05c                      	rjmp sound_driver_channel3_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel3_fx_4xy_routine_continue:
002026 91b0 2940                 	lds r27, noise_fx_4xy_depth
002028 91c0 2941                 	lds r28, noise_fx_4xy_phase
00202a 0fca                      	add r28, r26 //increase the phase by the speed
00202b 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
00202c f008                      	brlo sound_driver_channel3_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
00202d 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase:
00202e 93c0 2941                 	sts noise_fx_4xy_phase, r28 //store the new phase
002030 31c0                      	cpi r28, 16
002031 f028                      	brlo sound_driver_channel3_fx_4xy_routine_phase_0
002032 32c0                      	cpi r28, 32
002033 f028                      	brlo sound_driver_channel3_fx_4xy_routine_phase_1
002034 33c0                      	cpi r28, 48
002035 f030                      	brlo sound_driver_channel3_fx_4xy_routine_phase_2
002036 c007                      	rjmp sound_driver_channel3_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_0:
002037 70cf                      	andi r28, 0x0F //mask for values 0-15
002038 c029                      	rjmp sound_driver_channel3_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_1:
002039 6fc0                      	ori r28, 0xF0
00203a 95c0                      	com r28 //invert values 0-15
00203b c026                      	rjmp sound_driver_channel3_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_2:
00203c 70cf                      	andi r28, 0x0F //mask for values 0-15
00203d c003                      	rjmp sound_driver_channel3_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_3:
00203e 6fc0                      	ori r28, 0xF0
00203f 95c0                      	com r28 //invert values 0-15
002040 c000                      	rjmp sound_driver_channel3_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel3_fx_4xy_routine_load_add:
002041 95b2                      	swap r27 //multiply depth by 16
002042 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002043 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002044 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002045 0fec                      	add ZL, r28 //offset the table by the depth+phase
002046 1df2                      	adc ZH, zero
002047 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002048 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002049 937f                      	push r23
00204a 2f6c                      	mov r22, r28 //store the vibrato value into r22
00204b eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00204c 9f67                      	mul r22, r23
00204d 917f                      	pop r23
00204e 916f                      	pop r22
                                 
00204f 9416                      	lsr r1 //shift out the fractional bits
002050 9407                      	ror r0
002051 9416                      	lsr r1
002052 9407                      	ror r0
002053 9416                      	lsr r1
002054 9407                      	ror r0
002055 9416                      	lsr r1
002056 9407                      	ror r0
                                 	
002057 91a0 0abc                 	lds r26, TCB3_CCMPL
002059 91b0 0abd                 	lds r27, TCB3_CCMPH
00205b 0da0                      	add r26, r0
00205c 1db1                      	adc r27, r1
00205d 93a0 0abc                 	sts TCB3_CCMPL, r26
00205f 93b0 0abd                 	sts TCB3_CCMPH, r27
002061 c020                      	rjmp sound_driver_channel3_fx_7xy_routine
                                 
                                 sound_driver_channel3_fx_4xy_routine_load_subtract:
002062 95b2                      	swap r27 //multiply depth by 16
002063 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002064 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002065 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002066 0fec                      	add ZL, r28 //offset the table by the depth+phase
002067 1df2                      	adc ZH, zero
002068 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002069 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00206a 937f                      	push r23
00206b 2f6c                      	mov r22, r28 //store the vibrato value into r22
00206c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00206d 9f67                      	mul r22, r23
00206e 917f                      	pop r23
00206f 916f                      	pop r22
                                 
002070 9416                      	lsr r1 //shift out the fractional bits
002071 9407                      	ror r0
002072 9416                      	lsr r1
002073 9407                      	ror r0
002074 9416                      	lsr r1
002075 9407                      	ror r0
002076 9416                      	lsr r1
002077 9407                      	ror r0
                                 
002078 91a0 0abc                 	lds r26, TCB3_CCMPL
00207a 91b0 0abd                 	lds r27, TCB3_CCMPH
00207c 19a0                      	sub r26, r0
00207d 09b1                      	sbc r27, r1
00207e 93a0 0abc                 	sts TCB3_CCMPL, r26
002080 93b0 0abd                 	sts TCB3_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_7xy_routine:
002082 91a0 2942                 	lds r26, noise_fx_7xy_speed
002084 15a2                      	cp r26, zero
002085 f0f1                      	breq sound_driver_channel3_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
002086 91b0 2943                 	lds r27, noise_fx_7xy_depth
002088 91c0 2944                 	lds r28, noise_fx_7xy_phase
00208a 0fca                      	add r28, r26 //increase the phase by the speed
00208b 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
00208c f010                      	brlo sound_driver_channel3_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
00208d e0c0                      	ldi r28, 0x00
00208e 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel3_fx_7xy_routine_phase:
00208f 93c0 2944                 	sts noise_fx_7xy_phase, r28 //store the new phase
002091 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
002092 ffc4                      	sbrs r28, 4
002093 c001                      	rjmp sound_driver_channel3_fx_7xy_routine_phase_0
002094 c002                      	rjmp sound_driver_channel3_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel3_fx_7xy_routine_phase_0:
002095 70cf                      	andi r28, 0x0F //mask for values 0-15
002096 c003                      	rjmp sound_driver_channel3_fx_7xy_routine_load
                                 
                                 sound_driver_channel3_fx_7xy_routine_phase_1:
002097 6fc0                      	ori r28, 0xF0
002098 95c0                      	com r28 //invert values 0-15
002099 c000                      	rjmp sound_driver_channel3_fx_7xy_routine_load
                                 
                                 sound_driver_channel3_fx_7xy_routine_load:
00209a 95b2                      	swap r27 //multiply depth by 16
00209b 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
00209c e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00209d e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00209e 0fec                      	add ZL, r28 //offset the table by the depth+phase
00209f 1df2                      	adc ZH, zero
0020a0 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
0020a1 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
0020a2 93c0 2945                 	sts noise_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Axy_routine:
0020a4 91b0 2946                 	lds r27, noise_fx_Axy
0020a6 15b2                      	cp r27, zero
0020a7 f0e9                      	breq sound_driver_channel3_fx_Qxy_routine //0 means that the effect is not in use
                                 	
0020a8 91a0 2815                 	lds r26, noise_fractional_volume //load fractional volume representation of the channel
0020aa 91c0 2813                 	lds r28, noise_param //load the integer volume representation of the channel
0020ac 2fda                      	mov r29, r26 //copy fractional volume into r29
0020ad 2fec                      	mov r30, r28 //copy the noise_param into r30
0020ae 95e2                      	swap r30
0020af 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
0020b0 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
0020b1 17ed                      	cp r30, r29 //compare the fractional and integer volumes
0020b2 f009                      	breq sound_driver_channel3_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel3_fx_Axy_routine_reload:
0020b3 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate:
0020b4 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
0020b5 c004                      	rjmp sound_driver_channel3_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_addition:
0020b6 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0020b7 f428                      	brcc sound_driver_channel3_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0020b8 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
0020b9 c003                      	rjmp sound_driver_channel3_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_subtraction:
0020ba 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0020bb f008                      	brcs sound_driver_channel3_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0020bc e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_store:
0020bd 93a0 2815                 	sts noise_fractional_volume, r26 //store the new fractional volume
0020bf 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
0020c0 95a2                      	swap r26
0020c1 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
0020c2 2bca                      	or r28, r26 //store the new volume back into noise_param
0020c3 93c0 2813                 	sts noise_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel3_fx_Qxy_routine:
0020c5 91e0 294b                 	lds ZL, noise_fx_Qxy_target
0020c7 91f0 294c                 	lds ZH, noise_fx_Qxy_target+1
0020c9 9630                      	adiw Z, 0
0020ca f139                      	breq sound_driver_channel3_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
0020cb 91a0 294f                 	lds r26, noise_fx_Qxy_total_offset
0020cd 91b0 2950                 	lds r27, noise_fx_Qxy_total_offset+1
0020cf 91c0 0abc                 	lds r28, TCB3_CCMPL
0020d1 91d0 0abd                 	lds r29, TCB3_CCMPH
                                 
0020d3 1bec                      	sub ZL, r28 //calculate the difference to the target
0020d4 0bfd                      	sbc ZH, r29
0020d5 f408                      	brsh sound_driver_channel3_fx_Qxy_routine_end //if the target has been reached (or passed)
0020d6 f088                      	brlo sound_driver_channel3_fx_Qxy_routine_add
                                 
                                 sound_driver_channel3_fx_Qxy_routine_end:
0020d7 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
0020d8 0bbf                      	sbc r27, ZH
                                 
0020d9 91c0 2949                 	lds r28, noise_fx_Pxx_total
0020db 91d0 294a                 	lds r29, noise_fx_Pxx_total+1
                                 
0020dd 0fac                      	add r26, r28
0020de 1fbd                      	adc r27, r29
                                 
0020df 93a0 294f                 	sts noise_fx_Qxy_total_offset, r26 //store the total offset
0020e1 93b0 2950                 	sts noise_fx_Qxy_total_offset+1, r27
0020e3 9220 294b                 	sts noise_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
0020e5 9220 294c                 	sts noise_fx_Qxy_target+1, zero
0020e7 c00a                      	rjmp sound_driver_channel3_fx_Rxy_routine
                                 
                                 sound_driver_channel3_fx_Qxy_routine_add:
0020e8 91c0 294d                 	lds r28, noise_fx_Qxy_speed
0020ea 91d0 294e                 	lds r29, noise_fx_Qxy_speed+1
0020ec 0fac                      	add r26, r28 //increase the total offset by the speed
0020ed 1fbd                      	adc r27, r29
0020ee 93a0 294f                 	sts noise_fx_Qxy_total_offset, r26 //store the total offset
0020f0 93b0 2950                 	sts noise_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Rxy_routine:
0020f2 91e0 2951                 	lds ZL, noise_fx_Rxy_target
0020f4 91f0 2952                 	lds ZH, noise_fx_Rxy_target+1
0020f6 9630                      	adiw Z, 0
0020f7 f139                      	breq sound_driver_instrument_routine_channel4_volume //if the effect is not enabled, skip the routine
                                 
0020f8 91a0 2955                 	lds r26, noise_fx_Rxy_total_offset
0020fa 91b0 2956                 	lds r27, noise_fx_Rxy_total_offset+1
0020fc 91c0 0abc                 	lds r28, TCB3_CCMPL
0020fe 91d0 0abd                 	lds r29, TCB3_CCMPH
                                 
002100 1bce                      	sub r28, ZL //calculate the difference to the target
002101 0bdf                      	sbc r29, ZH
002102 f408                      	brsh sound_driver_channel3_fx_Rxy_routine_end //if the target has been reached (or passed)
002103 f088                      	brlo sound_driver_channel3_fx_Rxy_routine_add
                                 
                                 sound_driver_channel3_fx_Rxy_routine_end:
002104 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
002105 0bbd                      	sbc r27, r29
                                 
002106 91c0 2949                 	lds r28, noise_fx_Pxx_total
002108 91d0 294a                 	lds r29, noise_fx_Pxx_total+1
                                 
00210a 0fac                      	add r26, r28
00210b 1fbd                      	adc r27, r29
                                 
00210c 93a0 2955                 	sts noise_fx_Rxy_total_offset, r26 //store the total offset
00210e 93b0 2956                 	sts noise_fx_Rxy_total_offset+1, r27
002110 9220 2951                 	sts noise_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
002112 9220 2952                 	sts noise_fx_Rxy_target+1, zero
002114 c00a                      	rjmp sound_driver_instrument_routine_channel4_volume
                                 
                                 sound_driver_channel3_fx_Rxy_routine_add:
002115 91c0 2953                 	lds r28, noise_fx_Rxy_speed
002117 91d0 2954                 	lds r29, noise_fx_Rxy_speed+1
002119 0fac                      	add r26, r28 //increase the total offset by the speed
00211a 1fbd                      	adc r27, r29
00211b 93a0 2955                 	sts noise_fx_Rxy_total_offset, r26 //store the total offset
00211d 93b0 2956                 	sts noise_fx_Rxy_total_offset+1, r27
                                 
                                 sound_driver_instrument_routine_channel4_volume:
                                 
                                 sound_driver_exit:
00211f 91ff                      	pop r31
002120 91ef                      	pop r30
002121 91df                      	pop r29
002122 91cf                      	pop r28
002123 940c 05fe                 	jmp sequence_1_3 + 3 //+3 is to skip the stack instructions since we already pushed them
                                 
                                 
                                 
                                 //TABLES
002125 7f05
002126 010a
002127 0214
002128 0328
002129 0450
00212a 051e
00212b 0607
00212c 070d
00212d 0806
00212e 090c
00212f 0a18
002130 0b30
002131 0c60
002132 0d24
002133 0e08
002134 0f10                      length: .db $05, $7F, $0A, $01, $14, $02, $28, $03, $50, $04, $1E, $05, $07, $06, $0D, $07, $06, $08, $0C, $09, $18, $0A, $30, $0B, $60, $0C, $24, $0D, $08, $0E, $10, $0F
                                 
                                 //pulse sequences: 12.5%, 25%, 50%, 75%
002135 0301
002136 fc0f                      sequences: .db 0b00000001, 0b00000011, 0b00001111, 0b11111100
                                 
                                 //list of famitracker fx: http://famitracker.com/wiki/index.php?title=Effect_list
                                 channel0_fx:
002137 083a
002138 083f
002139 085b
00213a 0877
00213b 089a                      	.dw sound_driver_channel0_fx_0xy, sound_driver_channel0_fx_1xx, sound_driver_channel0_fx_2xx, sound_driver_channel0_fx_3xx, sound_driver_channel0_fx_4xy
00213c 08a5
00213d 08b2
00213e 08b5
00213f 08b8
002140 08bb                      	.dw sound_driver_channel0_fx_7xy, sound_driver_channel0_fx_Axy, sound_driver_channel0_fx_Bxx, sound_driver_channel0_fx_Cxx, sound_driver_channel0_fx_Dxx
002141 08be
002142 08c6
002143 08c9
002144 08d6
002145 08d7                      	.dw sound_driver_channel0_fx_Exx, sound_driver_channel0_fx_Fxx, sound_driver_channel0_fx_Gxx, sound_driver_channel0_fx_Hxy, sound_driver_channel0_fx_Ixy
002146 08d8
002147 08d9
002148 08da
002149 08ee
00214a 0932                      	.dw sound_driver_channel0_fx_Hxx, sound_driver_channel0_fx_Ixx, sound_driver_channel0_fx_Pxx, sound_driver_channel0_fx_Qxy, sound_driver_channel0_fx_Rxy
00214b 0975
00214c 0982
00214d 0996
00214e 0997
00214f 0998                      	.dw sound_driver_channel0_fx_Sxx, sound_driver_channel0_fx_Vxx, sound_driver_channel0_fx_Wxx, sound_driver_channel0_fx_Xxx, sound_driver_channel0_fx_Yxx
002150 0999                      	.dw sound_driver_channel0_fx_Zxx
                                 
                                 channel1_fx:
002151 0b24
002152 0b29
002153 0b45
002154 0b61
002155 0b84                      	.dw sound_driver_channel1_fx_0xy, sound_driver_channel1_fx_1xx, sound_driver_channel1_fx_2xx, sound_driver_channel1_fx_3xx, sound_driver_channel1_fx_4xy
002156 0b8f
002157 0b9c
002158 0b9f
002159 0ba2
00215a 0ba5                      	.dw sound_driver_channel1_fx_7xy, sound_driver_channel1_fx_Axy, sound_driver_channel1_fx_Bxx, sound_driver_channel1_fx_Cxx, sound_driver_channel1_fx_Dxx
00215b 0ba8
00215c 0bb0
00215d 0bb3
00215e 0bc0
00215f 0bc1                      	.dw sound_driver_channel1_fx_Exx, sound_driver_channel1_fx_Fxx, sound_driver_channel1_fx_Gxx, sound_driver_channel1_fx_Hxy, sound_driver_channel1_fx_Ixy
002160 0bc2
002161 0bc3
002162 0bc4
002163 0bd8
002164 0c1c                      	.dw sound_driver_channel1_fx_Hxx, sound_driver_channel1_fx_Ixx, sound_driver_channel1_fx_Pxx, sound_driver_channel1_fx_Qxy, sound_driver_channel1_fx_Rxy
002165 0c5f
002166 0c6c
002167 0c80
002168 0c81
002169 0c82                      	.dw sound_driver_channel1_fx_Sxx, sound_driver_channel1_fx_Vxx, sound_driver_channel1_fx_Wxx, sound_driver_channel1_fx_Xxx, sound_driver_channel1_fx_Yxx
00216a 0c83                      	.dw sound_driver_channel1_fx_Zxx
                                 
                                 channel2_fx:
00216b 0e01
00216c 0e06
00216d 0e22
00216e 0e3e
00216f 0e61                      	.dw sound_driver_channel2_fx_0xy, sound_driver_channel2_fx_1xx, sound_driver_channel2_fx_2xx, sound_driver_channel2_fx_3xx, sound_driver_channel2_fx_4xy
002170 0e6c
002171 0e6d
002172 0e6e
002173 0e71
002174 0e74                      	.dw sound_driver_channel2_fx_7xy, sound_driver_channel2_fx_Axy, sound_driver_channel2_fx_Bxx, sound_driver_channel2_fx_Cxx, sound_driver_channel2_fx_Dxx
002175 0e77
002176 0e84
002177 0e87
002178 0e94
002179 0e95                      	.dw sound_driver_channel2_fx_Exx, sound_driver_channel2_fx_Fxx, sound_driver_channel2_fx_Gxx, sound_driver_channel2_fx_Hxy, sound_driver_channel2_fx_Ixy
00217a 0e96
00217b 0e97
00217c 0e98
00217d 0eac
00217e 0ef0                      	.dw sound_driver_channel2_fx_Hxx, sound_driver_channel2_fx_Ixx, sound_driver_channel2_fx_Pxx, sound_driver_channel2_fx_Qxy, sound_driver_channel2_fx_Rxy
00217f 0f33
002180 0f40
002181 0f41
002182 0f42
002183 0f43                      	.dw sound_driver_channel2_fx_Sxx, sound_driver_channel2_fx_Vxx, sound_driver_channel2_fx_Wxx, sound_driver_channel2_fx_Xxx, sound_driver_channel2_fx_Yxx
002184 0f44                      	.dw sound_driver_channel2_fx_Zxx
                                 
                                 channel3_fx:
002185 10c6
002186 10cb
002187 10e7
002188 1103
002189 1126                      	.dw sound_driver_channel3_fx_0xy, sound_driver_channel3_fx_1xx, sound_driver_channel3_fx_2xx, sound_driver_channel3_fx_3xx, sound_driver_channel3_fx_4xy
00218a 1131
00218b 113e
00218c 1141
00218d 1144
00218e 1147                      	.dw sound_driver_channel3_fx_7xy, sound_driver_channel3_fx_Axy, sound_driver_channel3_fx_Bxx, sound_driver_channel3_fx_Cxx, sound_driver_channel3_fx_Dxx
00218f 114a
002190 1151
002191 1154
002192 1161
002193 1162                      	.dw sound_driver_channel3_fx_Exx, sound_driver_channel3_fx_Fxx, sound_driver_channel3_fx_Gxx, sound_driver_channel3_fx_Hxy, sound_driver_channel3_fx_Ixy
002194 1163
002195 1164
002196 1165
002197 1179
002198 11bd                      	.dw sound_driver_channel3_fx_Hxx, sound_driver_channel3_fx_Ixx, sound_driver_channel3_fx_Pxx, sound_driver_channel3_fx_Qxy, sound_driver_channel3_fx_Rxy
002199 1200
00219a 120d
00219b 1218
00219c 1219
00219d 121a                      	.dw sound_driver_channel3_fx_Sxx, sound_driver_channel3_fx_Vxx, sound_driver_channel3_fx_Wxx, sound_driver_channel3_fx_Xxx, sound_driver_channel3_fx_Yxx
00219e 121b                      	.dw sound_driver_channel3_fx_Zxx
                                 
                                 //famitracker volumes table: http://famitracker.com/wiki/index.php?title=Volume
                                 volumes:
00219f 0000
0021a0 0000
0021a1 0000
0021a2 0000
0021a3 0000
0021a4 0000
0021a5 0000
0021a6 0000                      	.db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
0021a7 0100
0021a8 0101
0021a9 0101
0021aa 0101
0021ab 0101
0021ac 0101
0021ad 0101
0021ae 0101                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
0021af 0100
0021b0 0101
0021b1 0101
0021b2 0101
0021b3 0101
0021b4 0101
0021b5 0101
0021b6 0201                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02
0021b7 0100
0021b8 0101
0021b9 0101
0021ba 0101
0021bb 0101
0021bc 0202
0021bd 0202
0021be 0302                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03
0021bf 0100
0021c0 0101
0021c1 0101
0021c2 0101
0021c3 0202
0021c4 0202
0021c5 0303
0021c6 0403                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04
0021c7 0100
0021c8 0101
0021c9 0101
0021ca 0202
0021cb 0302
0021cc 0303
0021cd 0404
0021ce 0504                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05
0021cf 0100
0021d0 0101
0021d1 0201
0021d2 0202
0021d3 0303
0021d4 0404
0021d5 0504
0021d6 0605                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x06
0021d7 0100
0021d8 0101
0021d9 0201
0021da 0302
0021db 0403
0021dc 0504
0021dd 0605
0021de 0706                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07
0021df 0100
0021e0 0101
0021e1 0202
0021e2 0303
0021e3 0404
0021e4 0505
0021e5 0606
0021e6 0807                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07, 0x08
0021e7 0100
0021e8 0101
0021e9 0302
0021ea 0403
0021eb 0504
0021ec 0606
0021ed 0707
0021ee 0908                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09
0021ef 0100
0021f0 0201
0021f1 0302
0021f2 0404
0021f3 0605
0021f4 0706
0021f5 0808
0021f6 0a09                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A
0021f7 0100
0021f8 0201
0021f9 0302
0021fa 0504
0021fb 0605
0021fc 0807
0021fd 0908
0021fe 0b0a                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B
0021ff 0100
002200 0201
002201 0403
002202 0504
002203 0706
002204 0808
002205 0a09
002206 0c0b                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B, 0x0C
002207 0100
002208 0201
002209 0403
00220a 0605
00220b 0706
00220c 0908
00220d 0b0a
00220e 0d0c                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D
00220f 0100
002210 0201
002211 0403
002212 0605
002213 0807
002214 0a09
002215 0c0b
002216 0e0d                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E
002217 0100
002218 0302
002219 0504
00221a 0706
00221b 0908
00221c 0b0a
00221d 0d0c


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega4809" register use summary:
x  :   0 y  :   0 z  : 248 r0 : 192 r1 : 200 r2 : 697 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   6 r11:   4 r12:   9 
r13:   6 r14:   4 r15:   9 r16:   7 r17:   6 r18:   7 r19:   6 r20:   4 
r21:   9 r22: 174 r23: 160 r24:   0 r25:  24 r26: 979 r27:1184 r28: 698 
r29: 376 r30: 378 r31: 337 
Registers used: 25 out of 35 (71.4%)

"ATmega4809" instruction use summary:
.lds  :   0 .sts  :   0 adc   : 148 add   : 195 adiw  : 106 and   :   0 
andi  :  95 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   7 brcs  :  13 break :   0 breq  : 169 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  81 brlt  :   0 brmi  :   0 
brne  : 121 brpl  :   0 brsh  :  31 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :   0 cbr   :   5 
clc   :   0 clh   :   0 cli   :   8 cln   :   0 clr   :   5 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :  16 cp    : 101 cpc   :  10 
cpi   : 168 cpse  :  20 dec   :  35 des   :   0 eor   :   2 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   4 in    :   7 inc   :  48 
jmp   :  11 ld    :   0 ldd   :   0 ldi   : 285 lds   : 727 lpm   : 260 
lsl   :  79 lsr   : 171 mov   : 139 movw  :   0 mul   :  28 muls  :   0 
mulsu :  12 neg   :   0 nop   :   0 or    :  22 ori   :  12 out   :   9 
pop   : 115 push  : 109 rcall :  50 ret   :  32 reti  :   7 rjmp  : 514 
rol   :  53 ror   : 192 sbc   :  48 sbci  :   0 sbi   :   0 sbic  :   0 
sbis  :   0 sbiw  :   0 sbr   :  12 sbrc  :  29 sbrs  :  16 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   :1397 sub   :  66 subi  :  52 swap  :  46 tst   :   0 wdr   :   0 

Instructions used: 52 out of 114 (45.6%)

"ATmega4809" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x00443e  15858   1500  17358   49152  35.3%
[.dseg] 0x002800 0x00295a      0    346    346    6144   5.6%
[.eseg] 0x000000 0x000000      0      0      0     256   0.0%

Assembly complete, 0 errors, 14 warnings
