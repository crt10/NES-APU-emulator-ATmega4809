
AVRASM ver. 2.2.8  C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm Sat May 22 20:28:42 2021

C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
                                 
                                 
                                 ; NES_APU_2a03.asm
                                 ;
                                 ; Created: 11/29/2020 1:44:10 AM
                                 ; Author : Tennyson Cheng
                                 ;
                                 
                                 .list
                                 
                                 .dseg
002800                           pulse1_param: .byte 1 //$4000 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002801                           pulse1_sweep_param: .byte 1 //$4001 EPPP.NSSS = Enable, Period, Negate, Shift
                                 //NOTE: In order to account for multiplier, we use 16 instead of 11 bits for the timer
002802                           pulse1_timerL: .byte 1 //$4002 LLLL.LLLL = Low 8 bits for timer
002803                           pulse1_timerH: .byte 1 //$4002 HHHH.HHHH = High 8 bits for timer
002804                           pulse1_length: .byte 1 //$4003 000l.llll = Length counter load
002805                           pulse1_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002806                           pulse1_output_volume: .byte 1 //this is the final output volume of pulse 1
002807                           pulse1_note: .byte 1 //the current note index in the note table
                                 
002808                           pulse2_param: .byte 1 //$4004 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002809                           pulse2_sweep_param: .byte 1 //$4005 EPPP.NSSS = Enable, Period, Negate, Shift
00280a                           pulse2_timerL: .byte 1 //$4006 LLLL.LLLL = Low 8 bits for timer
00280b                           pulse2_timerH: .byte 1 //$4006 HHHH.HHHH = High 8 bits for timer
00280c                           pulse2_length: .byte 1 //$4007 000l.llll = Length counter load
00280d                           pulse2_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
00280e                           pulse2_output_volume: .byte 1 //this is the final output volume of pulse 2
00280f                           pulse2_note: .byte 1 //the current note index in the note table
                                 
002810                           triangle_timerL: .byte 1 //$400A LLLL.LLLL = Low 8 bits for timer
002811                           triangle_timerH: .byte 1 //$400A HHHH.HHHH = High 8 bits for time
002812                           triangle_note: .byte 1 //the current note index in the note table
                                 
002813                           noise_param: .byte 1 //$400C 00lc.vvvv = Length counter halt/Loop flag, Constant volume flag, Volume
002814                           noise_period: .byte 1 //$400E M000.PPPP = Mode, Period
002815                           noise_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002816                           noise_output_volume: .byte 1 //this is the final output volume of pulse 2
002817                           noise_note: .byte 1 //the current note index in the period table
002818                           noise_adjusted_note: .byte 1 //the resultant note index after the arpeggio macro
                                 
002819                           song_frames: .byte 2
00281b                           song_frame_offset: .byte 2
00281d                           song_size: .byte 2
00281f                           song_speed: .byte 1
                                 //song_channel_delay_reload: .byte 1 //bit 0-4 represents channels 0-4. a set bit means that there is a delay that needs to be calculated for that channel.
002820                           song_fx_Bxx: .byte 1
002821                           song_fx_Cxx: .byte 1
002822                           song_fx_Dxx: .byte 1
                                 
                                 //PULSE 1
002823                           pulse1_pattern: .byte 2
002825                           pulse1_pattern_delay_rows: .byte 1
002826                           pulse1_pattern_delay_frames: .byte 1
002827                           pulse1_pattern_offset: .byte 2
                                 
002829                           pulse1_volume_macro: .byte 2
00282b                           pulse1_volume_macro_offset: .byte 1
00282c                           pulse1_volume_macro_loop: .byte 1
00282d                           pulse1_volume_macro_release: .byte 1
                                 
00282e                           pulse1_arpeggio_macro: .byte 2
002830                           pulse1_arpeggio_macro_offset: .byte 1
002831                           pulse1_arpeggio_macro_loop: .byte 1
002832                           pulse1_arpeggio_macro_release: .byte 1
002833                           pulse1_arpeggio_macro_mode: .byte 1
                                 
002834                           pulse1_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002836                           pulse1_pitch_macro: .byte 2
002838                           pulse1_pitch_macro_offset: .byte 1
002839                           pulse1_pitch_macro_loop: .byte 1
00283a                           pulse1_pitch_macro_release: .byte 1
                                 
00283b                           pulse1_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00283c                           pulse1_hi_pitch_macro: .byte 2
00283e                           pulse1_hi_pitch_macro_offset: .byte 1
00283f                           pulse1_hi_pitch_macro_loop: .byte 1
002840                           pulse1_hi_pitch_macro_release: .byte 1
                                 
002841                           pulse1_duty_macro: .byte 2
002843                           pulse1_duty_macro_offset: .byte 1
002844                           pulse1_duty_macro_loop: .byte 1
002845                           pulse1_duty_macro_release: .byte 1
                                 
002846                           pulse1_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002848                           pulse1_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
00284a                           pulse1_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00284c                           pulse1_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
00284e                           pulse1_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
002850                           pulse1_fx_3xx_start: .byte 2 //the starting note period
002852                           pulse1_fx_3xx_target: .byte 2 //target note period
002854                           pulse1_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
002856                           pulse1_fx_3xx_total_offset: .byte 2
002858                           pulse1_fx_4xy_speed: .byte 1
002859                           pulse1_fx_4xy_depth: .byte 1
00285a                           pulse1_fx_4xy_phase: .byte 1
00285b                           pulse1_fx_7xy_speed: .byte 1
00285c                           pulse1_fx_7xy_depth: .byte 1
00285d                           pulse1_fx_7xy_phase: .byte 1
00285e                           pulse1_fx_7xy_value: .byte 1 //value to offset the volume
00285f                           pulse1_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
002860                           pulse1_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002861                           pulse1_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002862                           pulse1_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
002864                           pulse1_fx_Qxy_target_note: .byte 1 //target note index
002865                           pulse1_fx_Qxy_target: .byte 2 //target note period
002867                           pulse1_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002869                           pulse1_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
00286b                           pulse1_fx_Rxy_target_note: .byte 1 //target note index
00286c                           pulse1_fx_Rxy_target: .byte 2 //target note period
00286e                           pulse1_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
002870                           pulse1_fx_Rxy_total_offset: .byte 2
002872                           pulse1_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002873                           pulse1_fx_Sxx_post: .byte 1
                                 
                                 //PULSE 2
002874                           pulse2_pattern: .byte 2
002876                           pulse2_pattern_delay_rows: .byte 1
002877                           pulse2_pattern_delay_frames: .byte 1
002878                           pulse2_pattern_offset: .byte 2
                                 
00287a                           pulse2_volume_macro: .byte 2
00287c                           pulse2_volume_macro_offset: .byte 1
00287d                           pulse2_volume_macro_loop: .byte 1
00287e                           pulse2_volume_macro_release: .byte 1
                                 
00287f                           pulse2_arpeggio_macro: .byte 2
002881                           pulse2_arpeggio_macro_offset: .byte 1
002882                           pulse2_arpeggio_macro_loop: .byte 1
002883                           pulse2_arpeggio_macro_release: .byte 1
002884                           pulse2_arpeggio_macro_mode: .byte 1
                                 
002885                           pulse2_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002887                           pulse2_pitch_macro: .byte 2
002889                           pulse2_pitch_macro_offset: .byte 1
00288a                           pulse2_pitch_macro_loop: .byte 1
00288b                           pulse2_pitch_macro_release: .byte 1
                                 
00288c                           pulse2_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00288d                           pulse2_hi_pitch_macro: .byte 2
00288f                           pulse2_hi_pitch_macro_offset: .byte 1
002890                           pulse2_hi_pitch_macro_loop: .byte 1
002891                           pulse2_hi_pitch_macro_release: .byte 1
                                 
002892                           pulse2_duty_macro: .byte 2
002894                           pulse2_duty_macro_offset: .byte 1
002895                           pulse2_duty_macro_loop: .byte 1
002896                           pulse2_duty_macro_release: .byte 1
                                 
002897                           pulse2_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002899                           pulse2_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
00289b                           pulse2_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00289d                           pulse2_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
00289f                           pulse2_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
0028a1                           pulse2_fx_3xx_start: .byte 2 //the starting note period
0028a3                           pulse2_fx_3xx_target: .byte 2 //target note period
0028a5                           pulse2_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028a7                           pulse2_fx_3xx_total_offset: .byte 2
0028a9                           pulse2_fx_4xy_speed: .byte 1
0028aa                           pulse2_fx_4xy_depth: .byte 1
0028ab                           pulse2_fx_4xy_phase: .byte 1
0028ac                           pulse2_fx_7xy_speed: .byte 1
0028ad                           pulse2_fx_7xy_depth: .byte 1
0028ae                           pulse2_fx_7xy_phase: .byte 1
0028af                           pulse2_fx_7xy_value: .byte 1 //value to offset the volume
0028b0                           pulse2_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
0028b1                           pulse2_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028b2                           pulse2_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028b3                           pulse2_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
0028b5                           pulse2_fx_Qxy_target_note: .byte 1 //target note index
0028b6                           pulse2_fx_Qxy_target: .byte 2 //target note period
0028b8                           pulse2_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
0028ba                           pulse2_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
0028bc                           pulse2_fx_Rxy_target_note: .byte 1 //target note index
0028bd                           pulse2_fx_Rxy_target: .byte 2 //target note period
0028bf                           pulse2_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
0028c1                           pulse2_fx_Rxy_total_offset: .byte 2
0028c3                           pulse2_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
0028c4                           pulse2_fx_Sxx_post: .byte 1
                                 
                                 //TRIANGLE
0028c5                           triangle_pattern: .byte 2
0028c7                           triangle_pattern_delay_rows: .byte 1
0028c8                           triangle_pattern_delay_frames: .byte 1
0028c9                           triangle_pattern_offset: .byte 2
                                 
0028cb                           triangle_volume_macro: .byte 2
0028cd                           triangle_volume_macro_offset: .byte 1
0028ce                           triangle_volume_macro_loop: .byte 1
0028cf                           triangle_volume_macro_release: .byte 1
                                 
0028d0                           triangle_arpeggio_macro: .byte 2
0028d2                           triangle_arpeggio_macro_offset: .byte 1
0028d3                           triangle_arpeggio_macro_loop: .byte 1
0028d4                           triangle_arpeggio_macro_release: .byte 1
0028d5                           triangle_arpeggio_macro_mode: .byte 1
                                 
0028d6                           triangle_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
0028d8                           triangle_pitch_macro: .byte 2
0028da                           triangle_pitch_macro_offset: .byte 1
0028db                           triangle_pitch_macro_loop: .byte 1
0028dc                           triangle_pitch_macro_release: .byte 1
                                 
0028dd                           triangle_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
0028de                           triangle_hi_pitch_macro: .byte 2
0028e0                           triangle_hi_pitch_macro_offset: .byte 1
0028e1                           triangle_hi_pitch_macro_loop: .byte 1
0028e2                           triangle_hi_pitch_macro_release: .byte 1
                                 
0028e3                           triangle_duty_macro: .byte 2
0028e5                           triangle_duty_macro_offset: .byte 1
0028e6                           triangle_duty_macro_loop: .byte 1
0028e7                           triangle_duty_macro_release: .byte 1
                                 
0028e8                           triangle_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
0028ea                           triangle_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
0028ec                           triangle_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
0028ee                           triangle_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
0028f0                           triangle_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
0028f2                           triangle_fx_3xx_start: .byte 2 //the starting note period
0028f4                           triangle_fx_3xx_target: .byte 2 //target note period
0028f6                           triangle_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028f8                           triangle_fx_3xx_total_offset: .byte 2
0028fa                           triangle_fx_4xy_speed: .byte 1
0028fb                           triangle_fx_4xy_depth: .byte 1
0028fc                           triangle_fx_4xy_phase: .byte 1
0028fd                           triangle_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028fe                           triangle_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028ff                           triangle_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
002901                           triangle_fx_Qxy_target_note: .byte 1 //target note index
002902                           triangle_fx_Qxy_target: .byte 2 //target note period
002904                           triangle_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002906                           triangle_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002908                           triangle_fx_Rxy_target_note: .byte 1 //target note index
002909                           triangle_fx_Rxy_target: .byte 2 //target note period
00290b                           triangle_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
00290d                           triangle_fx_Rxy_total_offset: .byte 2
00290f                           triangle_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002910                           triangle_fx_Sxx_post: .byte 1
                                 
                                 //NOISE
002911                           noise_pattern: .byte 2
002913                           noise_pattern_delay_rows: .byte 1
002914                           noise_pattern_delay_frames: .byte 1
002915                           noise_pattern_offset: .byte 2
                                 
002917                           noise_volume_macro: .byte 2
002919                           noise_volume_macro_offset: .byte 1
00291a                           noise_volume_macro_loop: .byte 1
00291b                           noise_volume_macro_release: .byte 1
                                 
00291c                           noise_arpeggio_macro: .byte 2
00291e                           noise_arpeggio_macro_offset: .byte 1
00291f                           noise_arpeggio_macro_loop: .byte 1
002920                           noise_arpeggio_macro_release: .byte 1
002921                           noise_arpeggio_macro_mode: .byte 1
                                 
002922                           noise_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002924                           noise_pitch_macro: .byte 2
002926                           noise_pitch_macro_offset: .byte 1
002927                           noise_pitch_macro_loop: .byte 1
002928                           noise_pitch_macro_release: .byte 1
                                 
002929                           noise_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00292a                           noise_hi_pitch_macro: .byte 2
00292c                           noise_hi_pitch_macro_offset: .byte 1
00292d                           noise_hi_pitch_macro_loop: .byte 1
00292e                           noise_hi_pitch_macro_release: .byte 1
                                 
00292f                           noise_duty_macro: .byte 2
002931                           noise_duty_macro_offset: .byte 1
002932                           noise_duty_macro_loop: .byte 1
002933                           noise_duty_macro_release: .byte 1
                                 
002934                           noise_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002936                           noise_fx_1xx: .byte 1 //refers to the rate in which to subtract the pitch from by the 1xx
002937                           noise_fx_1xx_total: .byte 1 //the total pitch offset for 1xx
002938                           noise_fx_2xx: .byte 1 //refers to the rate in which to add to the pitch by the 2xx
002939                           noise_fx_2xx_total: .byte 1 //the total pitch offset for 2xx
00293a                           noise_fx_4xy_speed: .byte 1
00293b                           noise_fx_4xy_depth: .byte 1
00293c                           noise_fx_4xy_phase: .byte 1
00293d                           noise_fx_4xy_offset: .byte 1
00293e                           noise_fx_7xy_speed: .byte 1
00293f                           noise_fx_7xy_depth: .byte 1
002940                           noise_fx_7xy_phase: .byte 1
002941                           noise_fx_7xy_value: .byte 1 //value to offset the volume
002942                           noise_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
002943                           noise_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002944                           noise_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002945                           noise_fx_Pxx_total: .byte 1 //refers to the fine pitch offset set by the Pxx effect
002946                           noise_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002947                           noise_fx_Sxx_post: .byte 1
                                 
                                 //DPCM
002948                           dpcm_pattern: .byte 2
00294a                           dpcm_pattern_delay_rows: .byte 1
00294b                           dpcm_pattern_delay_frames: .byte 1
00294c                           dpcm_pattern_offset: .byte 2
                                 
00294e                           dpcm_sample: .byte 2
002950                           dpcm_sample_offset: .byte 2
                                 
002952                           dpcm_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002953                           dpcm_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002954                           dpcm_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002955                           dpcm_fx_Sxx_post: .byte 1
                                 
                                 .cseg
                                 
                                 //NOTE: zero is defined in order to use the cp instruction without the need to load 0x00 into a register beforehand
                                 //NOTE: same idea with one
                                 .def zero = r2
                                 .def one = r3
                                 .def frame_sequence = r4
                                 .def pulse_channel_flags = r25 //[pulse1.pulse2] RSlc.RSlc = Reload, Start, Length halt/Loop, Constant volume
                                 .def pulse1_sequence = r7
                                 .def pulse1_length_counter = r8
                                 .def pulse1_sweep = r9 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse1_volume_divider = r16 //0000.PPPP = Period divider
                                 .def pulse1_volume_decay = r17 //0000.dddd = Decay
                                 .def pulse2_sequence = r10
                                 .def pulse2_length_counter = r11
                                 .def pulse2_sweep = r12 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse2_volume_divider = r18 //0000.PPPP = Period divider
                                 .def pulse2_volume_decay = r19 //0000.dddd = Decay
                                 .def triangle_sequence = r20
                                 .def noise_sequence_LOW = r21
                                 .def noise_sequence_HIGH = r22
                                 .def dpcm_shift = r13
                                 .def dpcm_bit_counter = r14
                                 .def dpcm_period = r15
                                 .def dpcm_length_LOW = r23
                                 .def dpcm_length_HIGH = r24
                                 
                                 
                                 reset:
000000 940c 1258                 	jmp init
                                 
                                 .org RTC_CNT_vect
000006 940c 15fc                 	jmp frame_counter_routine
                                 
                                 .org TCB0_INT_vect
000018 940c 1624                 	jmp pulse1_sequence_routine
                                 
                                 .org TCB1_INT_vect
00001a 940c 1671                 	jmp pulse2_sequence_routine
                                 
                                 .org TCB2_INT_vect
000032 940c 16be                 	jmp triangle_sequence_routine
                                 
                                 .org TCB3_INT_vect
000048 940c 16c9                 	jmp noise_sequence_routine
                                 
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(33): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(48): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(74): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(75): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(76): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(77): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(78): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(79): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(80): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(81): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(82): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(83): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(84): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(85): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(89): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(92): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(94): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(96): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(97): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(101): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(104): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(106): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(111): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(112): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(113): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(114): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(119): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(121): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(123): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(124): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(125): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(129): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(130): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(137): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(163): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(223): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(224): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(225): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(230): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(233): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(237): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(238): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(239): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(240): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(246): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(248): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(249): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(250): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(251): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(252): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
                                 .list
                                 
                                 init:
                                 	//MAIN CLOCK
001258 edc8                      	ldi r28, CPU_CCP_IOREG_gc //protected write
001259 93c0 0034                 	sts CPU_CCP, r28
00125b e0c0                      	ldi r28, 0 << CLKCTRL_PEN_bp //disable prescaler for 20 MHz on main clock
00125c 93c0 0061                 	sts CLKCTRL_MCLKCTRLB, r28
                                 
                                 	//ZERO
00125e 2422                      	clr zero
                                 	//ONE
00125f e0c1                      	ldi r28, 1
001260 2e3c                      	mov one, r28
                                 	//FRAME SEQUENCE
001261 2c42                      	mov frame_sequence, zero
                                 
                                 	//MEMORY
001262 e3c0                      	ldi r28, 0b00110000
001263 93c0 2800                 	sts pulse1_param, r28
001265 e8c0                      	ldi r28, 0b10000000
001266 93c0 2801                 	sts pulse1_sweep_param, r28
001268 efcf                      	ldi r28, 0xFF
001269 93c0 2802                 	sts pulse1_timerL, r28
00126b 93c0 2803                 	sts pulse1_timerH, r28
00126d 93c0 2804                 	sts pulse1_length, r28
                                 
00126f e3c0                      	ldi r28, 0b00110000
001270 93c0 2808                 	sts pulse2_param, r28
001272 e8c0                      	ldi r28, 0b10000000
001273 93c0 2809                 	sts pulse2_sweep_param, r28
001275 efcf                      	ldi r28, 0xFF
001276 93c0 280a                 	sts pulse2_timerL, r28
001278 93c0 280b                 	sts pulse2_timerH, r28
00127a 93c0 280c                 	sts pulse2_length, r28
                                 
00127c efcf                      	ldi r28, 0xFF
00127d 93c0 2810                 	sts triangle_timerL, r28
00127f 93c0 2811                 	sts triangle_timerH, r28
                                 
001281 e3c0                      	ldi r28, 0b00110000
001282 93c0 2813                 	sts noise_param, r28
001284 e0cf                      	ldi r28, 0b00001111
001285 93c0 2814                 	sts noise_period, r28
                                 
001287 e0c2                      	ldi r28, 0x02
001288 93c0 281b                 	sts song_frame_offset, r28
00128a 9220 281c                 	sts song_frame_offset+1, zero
00128c efcf                      	ldi r28, 0xFF
00128d 93c0 2820                 	sts song_fx_Bxx, r28
00128f 9220 2821                 	sts song_fx_Cxx, zero
001291 9220 2822                 	sts song_fx_Dxx, zero
001293 e4ee                      	ldi ZL, LOW(song0_frames << 1)
001294 e0f3                      	ldi ZH, HIGH(song0_frames << 1)
001295 93e0 2819                 	sts song_frames, ZL
001297 93f0 281a                 	sts song_frames+1, ZH
001299 91c5                      	lpm r28, Z+ //load the song size
00129a 91d5                      	lpm r29, Z+
00129b 93c0 281d                 	sts song_size, r28
00129d 93d0 281e                 	sts song_size+1, r29
00129f 9220 281f                 	sts song_speed, zero
                                 
                                 	//CHANNEL 0
0012a1 91c5                      	lpm r28, Z+
0012a2 91d5                      	lpm r29, Z+
0012a3 0fcc                      	lsl r28
0012a4 1fdd                      	rol r29
0012a5 93c0 2823                 	sts pulse1_pattern, r28
0012a7 93d0 2824                 	sts pulse1_pattern+1, r29
0012a9 9220 2825                 	sts pulse1_pattern_delay_rows, zero
0012ab 9230 2826                 	sts pulse1_pattern_delay_frames, one
0012ad 9220 2827                 	sts pulse1_pattern_offset, zero
0012af 9220 2828                 	sts pulse1_pattern_offset+1, zero
                                 
                                 	//CHANNEL 1
0012b1 91c5                      	lpm r28, Z+
0012b2 91d5                      	lpm r29, Z+
0012b3 0fcc                      	lsl r28
0012b4 1fdd                      	rol r29
0012b5 93c0 2874                 	sts pulse2_pattern, r28
0012b7 93d0 2875                 	sts pulse2_pattern+1, r29
0012b9 9220 2876                 	sts pulse2_pattern_delay_rows, zero
0012bb 9230 2877                 	sts pulse2_pattern_delay_frames, one
0012bd 9220 2878                 	sts pulse2_pattern_offset, zero
0012bf 9220 2879                 	sts pulse2_pattern_offset+1, zero
                                 
                                 	//CHANNEL 2
0012c1 91c5                      	lpm r28, Z+
0012c2 91d5                      	lpm r29, Z+
0012c3 0fcc                      	lsl r28
0012c4 1fdd                      	rol r29
0012c5 93c0 28c5                 	sts triangle_pattern, r28
0012c7 93d0 28c6                 	sts triangle_pattern+1, r29
0012c9 9220 28c7                 	sts triangle_pattern_delay_rows, zero
0012cb 9230 28c8                 	sts triangle_pattern_delay_frames, one
0012cd 9220 28c9                 	sts triangle_pattern_offset, zero
0012cf 9220 28ca                 	sts triangle_pattern_offset+1, zero
                                 
                                 	//CHANNEL 3
0012d1 91c5                      	lpm r28, Z+
0012d2 91d5                      	lpm r29, Z+
0012d3 0fcc                      	lsl r28
0012d4 1fdd                      	rol r29
0012d5 93c0 2911                 	sts noise_pattern, r28
0012d7 93d0 2912                 	sts noise_pattern+1, r29
0012d9 9220 2913                 	sts noise_pattern_delay_rows, zero
0012db 9230 2914                 	sts noise_pattern_delay_frames, one
0012dd 9220 2915                 	sts noise_pattern_offset, zero
0012df 9220 2916                 	sts noise_pattern_offset+1, zero
                                 
                                 	//CHANNEL 4
0012e1 91c5                      	lpm r28, Z+
0012e2 91d5                      	lpm r29, Z+
0012e3 0fcc                      	lsl r28
0012e4 1fdd                      	rol r29
0012e5 93c0 2948                 	sts dpcm_pattern, r28
0012e7 93d0 2949                 	sts dpcm_pattern+1, r29
0012e9 9220 294a                 	sts dpcm_pattern_delay_rows, zero
0012eb 9230 294b                 	sts dpcm_pattern_delay_frames, one
0012ed 9220 294c                 	sts dpcm_pattern_offset, zero
0012ef 9220 294d                 	sts dpcm_pattern_offset+1, zero
                                 
                                 	//CHANNEL 0 instrument macros
0012f1 efcf                      	ldi r28, 0xFF
0012f2 9220 282b                 	sts pulse1_volume_macro_offset, zero
0012f4 93c0 282c                 	sts pulse1_volume_macro_loop, r28
0012f6 93c0 282d                 	sts pulse1_volume_macro_release, r28
0012f8 9220 2830                 	sts pulse1_arpeggio_macro_offset, zero
0012fa 93c0 2831                 	sts pulse1_arpeggio_macro_loop, r28
0012fc 93c0 2832                 	sts pulse1_arpeggio_macro_release, r28
0012fe 93c0 2833                 	sts pulse1_arpeggio_macro_mode, r28
001300 9220 2838                 	sts pulse1_pitch_macro_offset, zero
001302 93c0 2839                 	sts pulse1_pitch_macro_loop, r28
001304 93c0 283a                 	sts pulse1_pitch_macro_release, r28
001306 9220 283e                 	sts pulse1_hi_pitch_macro_offset, zero
001308 93c0 283f                 	sts pulse1_hi_pitch_macro_loop, r28
00130a 93c0 2840                 	sts pulse1_hi_pitch_macro_release, r28
00130c 9220 2843                 	sts pulse1_duty_macro_offset, zero
00130e 93c0 2844                 	sts pulse1_duty_macro_loop, r28
001310 93c0 2845                 	sts pulse1_duty_macro_release, r28
                                 
001312 9220 2829                 	sts pulse1_volume_macro, zero
001314 9220 282a                 	sts pulse1_volume_macro+1, zero
001316 9220 282e                 	sts pulse1_arpeggio_macro, zero
001318 9220 282f                 	sts pulse1_arpeggio_macro+1, zero
00131a 9220 2834                 	sts pulse1_total_pitch_offset, zero
00131c 9220 2835                 	sts pulse1_total_pitch_offset+1, zero
00131e 9220 2836                 	sts pulse1_pitch_macro, zero
001320 9220 2837                 	sts pulse1_pitch_macro+1, zero
001322 9220 283b                 	sts pulse1_total_hi_pitch_offset, zero
001324 9220 283c                 	sts pulse1_hi_pitch_macro, zero
001326 9220 283d                 	sts pulse1_hi_pitch_macro+1, zero
001328 9220 2841                 	sts pulse1_duty_macro, zero
00132a 9220 2842                 	sts pulse1_duty_macro+1, zero
                                 
                                 	//CHANNEL 0 ENVELOPE
00132c e00f                      	ldi pulse1_volume_divider, 0x0F
00132d 9110 2800                 	lds pulse1_volume_decay, pulse1_param
00132f 701f                      	andi pulse1_volume_decay, 0x0F //mask for VVVV bits
001330 9190 2800                 	lds pulse_channel_flags, pulse1_param
001332 7390                      	andi pulse_channel_flags, 0b00110000
001333 6490                      	sbr pulse_channel_flags, 0b01000000 //set start flag
001334 9220 2806                 	sts pulse1_output_volume, zero
001336 93c0 2805                 	sts pulse1_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 0 LENGTH
001338 2e8c                      	mov pulse1_length_counter, r28
                                 
                                 	//CHANNEL 0 SEQUENCE
001339 e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
00133a 2e7c                      	mov pulse1_sequence, r28
                                 
                                 	//CHANNEL 0 SWEEP
00133b 9090 2801                 	lds pulse1_sweep, pulse1_sweep_param
00133d 9492                      	swap pulse1_sweep //swap data from high byte and low byte
00133e 6890                      	sbr pulse_channel_flags, 0b10000000 //set reload flag
                                 
                                 	//CHANNEL 0 FX
00133f efcf                      	ldi r28, 0xFF
001340 9220 2846                 	sts pulse1_fx_0xy_sequence, zero
001342 9220 2847                 	sts pulse1_fx_0xy_sequence+1, zero
001344 9220 2848                 	sts pulse1_fx_1xx, zero
001346 9220 2849                 	sts pulse1_fx_1xx+1, zero
001348 9220 284a                 	sts pulse1_fx_1xx_total, zero
00134a 9220 284b                 	sts pulse1_fx_1xx_total+1, zero
00134c 9220 284c                 	sts pulse1_fx_2xx, zero
00134e 9220 284d                 	sts pulse1_fx_2xx+1, zero
001350 9220 284e                 	sts pulse1_fx_2xx_total, zero
001352 9220 284f                 	sts pulse1_fx_2xx_total+1, zero
001354 9220 2850                 	sts pulse1_fx_3xx_start, zero
001356 9220 2851                 	sts pulse1_fx_3xx_start+1, zero
001358 9220 2852                 	sts pulse1_fx_3xx_target, zero
00135a 9220 2853                 	sts pulse1_fx_3xx_target+1, zero
00135c 9220 2854                 	sts pulse1_fx_3xx_speed, zero
00135e 9220 2855                 	sts pulse1_fx_3xx_speed+1, zero
001360 9220 2856                 	sts pulse1_fx_3xx_total_offset, zero
001362 9220 2857                 	sts pulse1_fx_3xx_total_offset+1, zero
001364 9220 2858                 	sts pulse1_fx_4xy_speed, zero
001366 9220 2859                 	sts pulse1_fx_4xy_depth, zero
001368 9220 285a                 	sts pulse1_fx_4xy_phase, zero
00136a 9220 285b                 	sts pulse1_fx_7xy_speed, zero
00136c 9220 285c                 	sts pulse1_fx_7xy_depth, zero
00136e 9220 285d                 	sts pulse1_fx_7xy_phase, zero
001370 9220 285e                 	sts pulse1_fx_7xy_value, zero
001372 9220 285f                 	sts pulse1_fx_Axy, zero
001374 93c0 2860                 	sts pulse1_fx_Gxx_pre, r28
001376 93c0 2861                 	sts pulse1_fx_Gxx_post, r28
001378 9220 2862                 	sts pulse1_fx_Pxx_total, zero
00137a 9220 2863                 	sts pulse1_fx_Pxx_total+1, zero
00137c 9220 2864                 	sts pulse1_fx_Qxy_target_note, zero
00137e 9220 2865                 	sts pulse1_fx_Qxy_target, zero
001380 9220 2866                 	sts pulse1_fx_Qxy_target+1, zero
001382 9220 2867                 	sts pulse1_fx_Qxy_speed, zero
001384 9220 2868                 	sts pulse1_fx_Qxy_speed+1, zero
001386 9220 2869                 	sts pulse1_fx_Qxy_total_offset, zero
001388 9220 286a                 	sts pulse1_fx_Qxy_total_offset+1, zero
00138a 9220 286b                 	sts pulse1_fx_Rxy_target_note, zero
00138c 9220 286c                 	sts pulse1_fx_Rxy_target, zero
00138e 9220 286d                 	sts pulse1_fx_Rxy_target+1, zero
001390 9220 286e                 	sts pulse1_fx_Rxy_speed, zero
001392 9220 286f                 	sts pulse1_fx_Rxy_speed+1, zero
001394 9220 2870                 	sts pulse1_fx_Rxy_total_offset, zero
001396 9220 2871                 	sts pulse1_fx_Rxy_total_offset+1, zero
001398 93c0 2872                 	sts pulse1_fx_Sxx_pre, r28
00139a 93c0 2873                 	sts pulse1_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 1 instrument macros
00139c efcf                      	ldi r28, 0xFF
00139d 9220 287c                 	sts pulse2_volume_macro_offset, zero
00139f 93c0 287d                 	sts pulse2_volume_macro_loop, r28
0013a1 93c0 287e                 	sts pulse2_volume_macro_release, r28
0013a3 9220 2881                 	sts pulse2_arpeggio_macro_offset, zero
0013a5 93c0 2882                 	sts pulse2_arpeggio_macro_loop, r28
0013a7 93c0 2883                 	sts pulse2_arpeggio_macro_release, r28
0013a9 93c0 2884                 	sts pulse2_arpeggio_macro_mode, r28
0013ab 9220 2889                 	sts pulse2_pitch_macro_offset, zero
0013ad 93c0 288a                 	sts pulse2_pitch_macro_loop, r28
0013af 93c0 288b                 	sts pulse2_pitch_macro_release, r28
0013b1 9220 288f                 	sts pulse2_hi_pitch_macro_offset, zero
0013b3 93c0 2890                 	sts pulse2_hi_pitch_macro_loop, r28
0013b5 93c0 2891                 	sts pulse2_hi_pitch_macro_release, r28
0013b7 9220 2894                 	sts pulse2_duty_macro_offset, zero
0013b9 93c0 2895                 	sts pulse2_duty_macro_loop, r28
0013bb 93c0 2896                 	sts pulse2_duty_macro_release, r28
                                 
0013bd 9220 287a                 	sts pulse2_volume_macro, zero
0013bf 9220 287b                 	sts pulse2_volume_macro+1, zero
0013c1 9220 287f                 	sts pulse2_arpeggio_macro, zero
0013c3 9220 2880                 	sts pulse2_arpeggio_macro+1, zero
0013c5 9220 2885                 	sts pulse2_total_pitch_offset, zero
0013c7 9220 2886                 	sts pulse2_total_pitch_offset+1, zero
0013c9 9220 2887                 	sts pulse2_pitch_macro, zero
0013cb 9220 2888                 	sts pulse2_pitch_macro+1, zero
0013cd 9220 288c                 	sts pulse2_total_hi_pitch_offset, zero
0013cf 9220 288d                 	sts pulse2_hi_pitch_macro, zero
0013d1 9220 288e                 	sts pulse2_hi_pitch_macro+1, zero
0013d3 9220 2892                 	sts pulse2_duty_macro, zero
0013d5 9220 2893                 	sts pulse2_duty_macro+1, zero
                                 
                                 	//CHANNEL 1 ENVELOPE
0013d7 e02f                      	ldi pulse2_volume_divider, 0x0F
0013d8 9130 2808                 	lds pulse2_volume_decay, pulse2_param
0013da 703f                      	andi pulse2_volume_decay, 0x0F //mask for VVVV bits
0013db 91d0 2808                 	lds r29, pulse2_param
0013dd 73d0                      	andi r29, 0b00110000
0013de 62d0                      	sbr r29, 0b0100000 //set start flag
0013df 95d2                      	swap r29
0013e0 2b9d                      	or pulse_channel_flags, r29
0013e1 9220 280e                 	sts pulse2_output_volume, zero
0013e3 93c0 280d                 	sts pulse2_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 1 LENGTH
0013e5 2ebc                      	mov pulse2_length_counter, r28
                                 
                                 	//CHANNEL 1 SEQUENCE
0013e6 e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
0013e7 2eac                      	mov pulse2_sequence, r28
                                 
                                 	//CHANNEL 1 SWEEP
0013e8 90c0 2809                 	lds pulse2_sweep, pulse2_sweep_param
0013ea 94c2                      	swap pulse2_sweep //swap data from high byte and low byte
0013eb 6098                      	sbr pulse_channel_flags, 0b00001000 //set reload flag
                                 
                                 	//CHANNEL 1 FX
0013ec efcf                      	ldi r28, 0xFF
0013ed 9220 2897                 	sts pulse2_fx_0xy_sequence, zero
0013ef 9220 2898                 	sts pulse2_fx_0xy_sequence+1, zero
0013f1 9220 2899                 	sts pulse2_fx_1xx, zero
0013f3 9220 289a                 	sts pulse2_fx_1xx+1, zero
0013f5 9220 289b                 	sts pulse2_fx_1xx_total, zero
0013f7 9220 289c                 	sts pulse2_fx_1xx_total+1, zero
0013f9 9220 289d                 	sts pulse2_fx_2xx, zero
0013fb 9220 289e                 	sts pulse2_fx_2xx+1, zero
0013fd 9220 289f                 	sts pulse2_fx_2xx_total, zero
0013ff 9220 28a0                 	sts pulse2_fx_2xx_total+1, zero
001401 9220 28a1                 	sts pulse2_fx_3xx_start, zero
001403 9220 28a2                 	sts pulse2_fx_3xx_start+1, zero
001405 9220 28a3                 	sts pulse2_fx_3xx_target, zero
001407 9220 28a4                 	sts pulse2_fx_3xx_target+1, zero
001409 9220 28a5                 	sts pulse2_fx_3xx_speed, zero
00140b 9220 28a6                 	sts pulse2_fx_3xx_speed+1, zero
00140d 9220 28a7                 	sts pulse2_fx_3xx_total_offset, zero
00140f 9220 28a8                 	sts pulse2_fx_3xx_total_offset+1, zero
001411 9220 28a9                 	sts pulse2_fx_4xy_speed, zero
001413 9220 28aa                 	sts pulse2_fx_4xy_depth, zero
001415 9220 28ab                 	sts pulse2_fx_4xy_phase, zero
001417 9220 28ac                 	sts pulse2_fx_7xy_speed, zero
001419 9220 28ad                 	sts pulse2_fx_7xy_depth, zero
00141b 9220 28ae                 	sts pulse2_fx_7xy_phase, zero
00141d 9220 28af                 	sts pulse2_fx_7xy_value, zero
00141f 9220 28b0                 	sts pulse2_fx_Axy, zero
001421 93c0 28b1                 	sts pulse2_fx_Gxx_pre, r28
001423 93c0 28b2                 	sts pulse2_fx_Gxx_post, r28
001425 9220 28b3                 	sts pulse2_fx_Pxx_total, zero
001427 9220 28b4                 	sts pulse2_fx_Pxx_total+1, zero
001429 9220 28b5                 	sts pulse2_fx_Qxy_target_note, zero
00142b 9220 28b6                 	sts pulse2_fx_Qxy_target, zero
00142d 9220 28b7                 	sts pulse2_fx_Qxy_target+1, zero
00142f 9220 28b8                 	sts pulse2_fx_Qxy_speed, zero
001431 9220 28b9                 	sts pulse2_fx_Qxy_speed+1, zero
001433 9220 28ba                 	sts pulse2_fx_Qxy_total_offset, zero
001435 9220 28bb                 	sts pulse2_fx_Qxy_total_offset+1, zero
001437 9220 28bc                 	sts pulse2_fx_Rxy_target_note, zero
001439 9220 28bd                 	sts pulse2_fx_Rxy_target, zero
00143b 9220 28be                 	sts pulse2_fx_Rxy_target+1, zero
00143d 9220 28bf                 	sts pulse2_fx_Rxy_speed, zero
00143f 9220 28c0                 	sts pulse2_fx_Rxy_speed+1, zero
001441 9220 28c1                 	sts pulse2_fx_Rxy_total_offset, zero
001443 9220 28c2                 	sts pulse2_fx_Rxy_total_offset+1, zero
001445 93c0 28c3                 	sts pulse2_fx_Sxx_pre, r28
001447 93c0 28c4                 	sts pulse2_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 2 instrument macros
001449 efcf                      	ldi r28, 0xFF
00144a 9220 28cd                 	sts triangle_volume_macro_offset, zero
00144c 93c0 28ce                 	sts triangle_volume_macro_loop, r28
00144e 93c0 28cf                 	sts triangle_volume_macro_release, r28
001450 9220 28d2                 	sts triangle_arpeggio_macro_offset, zero
001452 93c0 28d3                 	sts triangle_arpeggio_macro_loop, r28
001454 93c0 28d4                 	sts triangle_arpeggio_macro_release, r28
001456 93c0 28d5                 	sts triangle_arpeggio_macro_mode, r28
001458 9220 28da                 	sts triangle_pitch_macro_offset, zero
00145a 93c0 28db                 	sts triangle_pitch_macro_loop, r28
00145c 93c0 28dc                 	sts triangle_pitch_macro_release, r28
00145e 9220 28e0                 	sts triangle_hi_pitch_macro_offset, zero
001460 93c0 28e1                 	sts triangle_hi_pitch_macro_loop, r28
001462 93c0 28e2                 	sts triangle_hi_pitch_macro_release, r28
001464 9220 28e5                 	sts triangle_duty_macro_offset, zero
001466 93c0 28e6                 	sts triangle_duty_macro_loop, r28
001468 93c0 28e7                 	sts triangle_duty_macro_release, r28
                                 
00146a 9220 28cb                 	sts triangle_volume_macro, zero
00146c 9220 28cc                 	sts triangle_volume_macro+1, zero
00146e 9220 28d0                 	sts triangle_arpeggio_macro, zero
001470 9220 28d1                 	sts triangle_arpeggio_macro+1, zero
001472 9220 28d6                 	sts triangle_total_pitch_offset, zero
001474 9220 28d7                 	sts triangle_total_pitch_offset+1, zero
001476 9220 28d8                 	sts triangle_pitch_macro, zero
001478 9220 28d9                 	sts triangle_pitch_macro+1, zero
00147a 9220 28dd                 	sts triangle_total_hi_pitch_offset, zero
00147c 9220 28de                 	sts triangle_hi_pitch_macro, zero
00147e 9220 28df                 	sts triangle_hi_pitch_macro+1, zero
001480 9220 28e3                 	sts triangle_duty_macro, zero
001482 9220 28e4                 	sts triangle_duty_macro+1, zero
                                 
                                 	//CHANNEL 2 SEQUENCE
001484 e0c0                      	ldi r28, 0b00000000 //reset sequence to 0
001485 2f4c                      	mov triangle_sequence, r28
                                 
                                 	//CHANNEL 2 FX
001486 efcf                      	ldi r28, 0xFF
001487 9220 28e8                 	sts triangle_fx_0xy_sequence, zero
001489 9220 28e9                 	sts triangle_fx_0xy_sequence+1, zero
00148b 9220 28ea                 	sts triangle_fx_1xx, zero
00148d 9220 28eb                 	sts triangle_fx_1xx+1, zero
00148f 9220 28ec                 	sts triangle_fx_1xx_total, zero
001491 9220 28ed                 	sts triangle_fx_1xx_total+1, zero
001493 9220 28ee                 	sts triangle_fx_2xx, zero
001495 9220 28ef                 	sts triangle_fx_2xx+1, zero
001497 9220 28f0                 	sts triangle_fx_2xx_total, zero
001499 9220 28f1                 	sts triangle_fx_2xx_total+1, zero
00149b 9220 28f2                 	sts triangle_fx_3xx_start, zero
00149d 9220 28f3                 	sts triangle_fx_3xx_start+1, zero
00149f 9220 28f4                 	sts triangle_fx_3xx_target, zero
0014a1 9220 28f5                 	sts triangle_fx_3xx_target+1, zero
0014a3 9220 28f6                 	sts triangle_fx_3xx_speed, zero
0014a5 9220 28f7                 	sts triangle_fx_3xx_speed+1, zero
0014a7 9220 28f8                 	sts triangle_fx_3xx_total_offset, zero
0014a9 9220 28f9                 	sts triangle_fx_3xx_total_offset+1, zero
0014ab 9220 28fa                 	sts triangle_fx_4xy_speed, zero
0014ad 9220 28fb                 	sts triangle_fx_4xy_depth, zero
0014af 9220 28fc                 	sts triangle_fx_4xy_phase, zero
0014b1 93c0 28fd                 	sts triangle_fx_Gxx_pre, r28
0014b3 93c0 28fe                 	sts triangle_fx_Gxx_post, r28
0014b5 9220 28ff                 	sts triangle_fx_Pxx_total, zero
0014b7 9220 2900                 	sts triangle_fx_Pxx_total+1, zero
0014b9 9220 2901                 	sts triangle_fx_Qxy_target_note, zero
0014bb 9220 2902                 	sts triangle_fx_Qxy_target, zero
0014bd 9220 2903                 	sts triangle_fx_Qxy_target+1, zero
0014bf 9220 2904                 	sts triangle_fx_Qxy_speed, zero
0014c1 9220 2905                 	sts triangle_fx_Qxy_speed+1, zero
0014c3 9220 2906                 	sts triangle_fx_Qxy_total_offset, zero
0014c5 9220 2907                 	sts triangle_fx_Qxy_total_offset+1, zero
0014c7 9220 2908                 	sts triangle_fx_Rxy_target_note, zero
0014c9 9220 2909                 	sts triangle_fx_Rxy_target, zero
0014cb 9220 290a                 	sts triangle_fx_Rxy_target+1, zero
0014cd 9220 290b                 	sts triangle_fx_Rxy_speed, zero
0014cf 9220 290c                 	sts triangle_fx_Rxy_speed+1, zero
0014d1 9220 290d                 	sts triangle_fx_Rxy_total_offset, zero
0014d3 9220 290e                 	sts triangle_fx_Rxy_total_offset+1, zero
0014d5 93c0 290f                 	sts triangle_fx_Sxx_pre, r28
0014d7 93c0 2910                 	sts triangle_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 3 instrument macros
0014d9 efcf                      	ldi r28, 0xFF
0014da 9220 2919                 	sts noise_volume_macro_offset, zero
0014dc 93c0 291a                 	sts noise_volume_macro_loop, r28
0014de 93c0 291b                 	sts noise_volume_macro_release, r28
0014e0 9220 291e                 	sts noise_arpeggio_macro_offset, zero
0014e2 93c0 291f                 	sts noise_arpeggio_macro_loop, r28
0014e4 93c0 2920                 	sts noise_arpeggio_macro_release, r28
0014e6 93c0 2921                 	sts noise_arpeggio_macro_mode, r28
0014e8 9220 2926                 	sts noise_pitch_macro_offset, zero
0014ea 93c0 2927                 	sts noise_pitch_macro_loop, r28
0014ec 93c0 2928                 	sts noise_pitch_macro_release, r28
0014ee 9220 292c                 	sts noise_hi_pitch_macro_offset, zero
0014f0 93c0 292d                 	sts noise_hi_pitch_macro_loop, r28
0014f2 93c0 292e                 	sts noise_hi_pitch_macro_release, r28
0014f4 9220 2931                 	sts noise_duty_macro_offset, zero
0014f6 93c0 2932                 	sts noise_duty_macro_loop, r28
0014f8 93c0 2933                 	sts noise_duty_macro_release, r28
                                 
0014fa 9220 2917                 	sts noise_volume_macro, zero
0014fc 9220 2918                 	sts noise_volume_macro+1, zero
0014fe 9220 291c                 	sts noise_arpeggio_macro, zero
001500 9220 291d                 	sts noise_arpeggio_macro+1, zero
001502 9220 2922                 	sts noise_total_pitch_offset, zero
001504 9220 2923                 	sts noise_total_pitch_offset+1, zero
001506 9220 2924                 	sts noise_pitch_macro, zero
001508 9220 2925                 	sts noise_pitch_macro+1, zero
00150a 9220 2929                 	sts noise_total_hi_pitch_offset, zero
00150c 9220 292a                 	sts noise_hi_pitch_macro, zero
00150e 9220 292b                 	sts noise_hi_pitch_macro+1, zero
001510 9220 292f                 	sts noise_duty_macro, zero
001512 9220 2930                 	sts noise_duty_macro+1, zero
                                 
                                 	//CHANNEL 3 VOLUME
001514 9220 2816                 	sts noise_output_volume, zero
001516 93c0 2815                 	sts noise_fractional_volume, r28 //initialize fractional volume to max value
                                 
                                 	//CHANNEL 3 SEQUENCE
001518 e0c1                      	ldi r28, 0b00000001 //noise sequence is reset to 0x0001
001519 2f5c                      	mov noise_sequence_LOW, r28
00151a 2d62                      	mov noise_sequence_HIGH, zero
                                 
                                 	//CHANNEL 3 FX
00151b efcf                      	ldi r28, 0xFF
00151c 9220 2934                 	sts noise_fx_0xy_sequence, zero
00151e 9220 2935                 	sts noise_fx_0xy_sequence+1, zero
001520 9220 2936                 	sts noise_fx_1xx, zero
001522 9220 2937                 	sts noise_fx_1xx_total, zero
001524 9220 2938                 	sts noise_fx_2xx, zero
001526 9220 2939                 	sts noise_fx_2xx_total, zero
001528 9220 293a                 	sts noise_fx_4xy_speed, zero
00152a 9220 293b                 	sts noise_fx_4xy_depth, zero
00152c 9220 293c                 	sts noise_fx_4xy_phase, zero
00152e 9220 293d                 	sts noise_fx_4xy_offset, zero
001530 9220 293e                 	sts noise_fx_7xy_speed, zero
001532 9220 293f                 	sts noise_fx_7xy_depth, zero
001534 9220 2940                 	sts noise_fx_7xy_phase, zero
001536 9220 2941                 	sts noise_fx_7xy_value, zero
001538 9220 2942                 	sts noise_fx_Axy, zero
00153a 93c0 2943                 	sts noise_fx_Gxx_pre, r28
00153c 93c0 2944                 	sts noise_fx_Gxx_post, r28
00153e 9220 2945                 	sts noise_fx_Pxx_total, zero
001540 93c0 2946                 	sts noise_fx_Sxx_pre, r28
001542 93c0 2947                 	sts noise_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 4 SAMPLE
001544 9220 294e                 	sts dpcm_sample, zero
001546 9220 294f                 	sts dpcm_sample+1, zero
001548 9220 2950                 	sts dpcm_sample_offset, zero
00154a 9220 2951                 	sts dpcm_sample_offset+1, zero
00154c 2cd2                      	mov dpcm_shift, zero
00154d 2ce2                      	mov dpcm_bit_counter, zero
00154e 2cf2                      	mov dpcm_period, zero
00154f 2d72                      	mov dpcm_length_LOW, zero
001550 2d82                      	mov dpcm_length_HIGH, zero
                                 
                                 	//CHANNEL 4 FX
001551 93c0 2943                 	sts noise_fx_Gxx_pre, r28
001553 93c0 2944                 	sts noise_fx_Gxx_post, r28
001555 93c0 2946                 	sts noise_fx_Sxx_pre, r28
001557 93c0 2947                 	sts noise_fx_Sxx_post, r28
                                 
                                 	//PINS
001559 efcf                      	ldi r28, 0xFF
00155a b9c0                      	out VPORTA_DIR, r28 //set all pins in VPORTA to output
                                 
                                 	//TIMERS
                                 
                                 	//NOTE: Channel Timers are clocked (20/2)/(0.8948865) = 11.1746014718 times faster than the NES APU
                                 	//Because of this, we multiply all the NES timer values by 11.1746014718 beforehand
                                 	//Since we rotate the sequence when the timer goes from t-(t-1) to 0, instead of 0 to t like the NES, we add 1 to the NES timers before multiplying
                                 	//The ATmega4809 is configured to run at 20 MHz
                                 	//The /2 comes from the prescaler divider used
                                 	//0.8948865 MHz is the speed of the NTSC NES APU
                                 	//NOTE: This means that any offset to the pitch for the NES timers would be multiplied by 11.1746014718 aswell.
                                 	//Pulse 1
00155b e0c0                      	ldi r28, TCB_CNTMODE_INT_gc //interrupt mode
00155c 93c0 0a81                 	sts TCB0_CTRLB, r28
00155e e0c1                      	ldi r28, TCB_CAPT_bm //enable interrupts
00155f 93c0 0a85                 	sts TCB0_INTCTRL, r28
001561 91c0 2802                 	lds r28, pulse1_timerL //load the LOW bits for timer
001563 93c0 0a8c                 	sts TCB0_CCMPL, r28
001565 91c0 2803                 	lds r28, pulse1_timerH //load the HIGH bits for timer
001567 93c0 0a8d                 	sts TCB0_CCMPH, r28
001569 e0c3                      	ldi r28, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
00156a 93c0 0a80                 	sts TCB0_CTRLA, r28
                                 
                                 	//PULSE 2
00156c e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
00156d 93b0 0a91                 	sts TCB1_CTRLB, r27
00156f e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001570 93b0 0a95                 	sts TCB1_INTCTRL, r27
001572 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
001574 93b0 0a9c                 	sts TCB1_CCMPL, r27
001576 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
001578 93b0 0a9d                 	sts TCB1_CCMPH, r27
00157a e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
00157b 93b0 0a90                 	sts TCB1_CTRLA, r27
                                 
                                 	//NOTE: The triangle timer is clocked at the same speed as the NES CPU, aka twice the NES APU.
                                 	//Therefore, we won't be using a /2 clock divider like we did with the pulse timers.
                                 	//TRIANGLE
00157d e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
00157e 93b0 0aa1                 	sts TCB2_CTRLB, r27
001580 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
                                 	//sts TCB2_INTCTRL, r27 //keep interrupts disabled to mute channel since triangle doesn't have volume bits
001581 91b0 2810                 	lds r27, triangle_timerL //load the LOW bits for timer
001583 93b0 0aac                 	sts TCB2_CCMPL, r27
001585 91b0 2811                 	lds r27, triangle_timerH //load the HIGH bits for timer
001587 93b0 0aad                 	sts TCB2_CCMPH, r27
001589 e0b1                      	ldi r27, TCB_CLKSEL_CLKDIV1_gc | TCB_ENABLE_bm //use prescaler divider of 1 and enable timer
00158a 93b0 0aa0                 	sts TCB2_CTRLA, r27
00158c 9478                      	sei //global interrupt enable
                                 
                                 	//NOISE
00158d e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
00158e 93b0 0ab1                 	sts TCB3_CTRLB, r27
001590 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001591 93b0 0ab5                 	sts TCB3_INTCTRL, r27
001593 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
001595 93b0 0abc                 	sts TCB3_CCMPL, r27
001597 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
001599 93b0 0abd                 	sts TCB3_CCMPH, r27
00159b e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
00159c 93b0 0ab0                 	sts TCB3_CTRLA, r27
                                 
                                 	//DPCM
                                 /*	ldi r28, TCA_SINGLE_CMP0EN_bm | TCA_SINGLE_CMP1EN_bm | TCA_SINGLE_CMP2EN_bm | TCA_SINGLE_WGMODE_NORMAL_gc //interrupt mode
                                 	sts TCA0_SINGLE_CTRLB, r28
                                 	ldi r28, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP1_bm | TCA_SINGLE_CMP2_bm | TCA_SINGLE_OVF_bm //enable overflow and compare interrupts
                                 	sts TCA0_SINGLE_INTCTRL, r28
                                 	ldi r28, 0x15 //set the period for CMP0
                                 	sts TCA0_SINGLE_CMP0, r28
                                 	ldi r28, 0x05
                                 	sts TCA0_SINGLE_CMP0 + 1, r28
                                 	ldi r28, 0x2B //set the period for CMP1
                                 	sts TCA0_SINGLE_CMP1, r28
                                 	ldi r28, 0x0A
                                 	sts TCA0_SINGLE_CMP1 + 1, r28
                                 	ldi r28, 0x41 //set the period for CMP2
                                 	sts TCA0_SINGLE_CMP2, r28
                                 	ldi r28, 0x0F
                                 	sts TCA0_SINGLE_CMP2 + 1, r28
                                 	ldi r28, 0x57 //set the period for OVF
                                 	sts TCA0_SINGLE_PER, r28
                                 	ldi r28, 0x14
                                 	sts TCA0_SINGLE_PER + 1, r28
                                 	ldi r28, TCA_SINGLE_CLKSEL_DIV64_gc | TCA_SINGLE_ENABLE_bm //use prescale divider of 64 and enable timer
                                 	sts TCA0_SINGLE_CTRLA, r28*/
                                 
                                 	//RTC
                                 	//Frame Counter
                                 	//NOTE:The frame counter will be defaulted to NTSC mode (60 Hz, 120 Hz, 240 Hz)
                                 	//Interrupts will be setup to interrupt every 240 Hz clock
                                 	//The 4th consecutive interrupt will clock the sound driver every 60Hz, in which new audio data is read and written to the registers
                                 	//1st and 2nd interrupt will execute sequence 0 and 2. 3rd and 4th interrupt will execute sequence 1 and 3.
                                 	//Timer period Calculation: (0.00416666666 * 32768/8)-1 = 16.0666666394 = 0x0010
                                 	//The RTC timer is clocked at 32768 Hz
                                 	//0.00416666666 seconds is the period for 240 Hz
                                 	//The /8 comes from the prescaler divider used
00159e e0b0                      	ldi r27, RTC_CLKSEL_INT32K_gc //internal 32kHz oscillator
00159f 93b0 0147                 	sts RTC_CLKSEL, r27
0015a1 e1b0                      	ldi r27, 0x10
0015a2 e0c0                      	ldi r28, 0x00
0015a3 93b0 014a                 	sts RTC_PER, r27
0015a5 93c0 014b                 	sts RTC_PER + 1, r28
0015a7 e0b1                      	ldi r27, RTC_OVF_bm //overflow interrupts
0015a8 93b0 0142                 	sts RTC_INTCTRL, r27
0015aa e1b9                      	ldi r27, RTC_PRESCALER_DIV8_gc | RTC_PITEN_bm //use prescaler divider of 8 and enable RTC
0015ab 93b0 0140                 	sts RTC_CTRLA, r27
                                 
                                 
                                 
                                 //https://wiki.nesdev.com/w/index.php/APU_Mixer
                                 volume_mixer:
0015ad 91c0 2806                 	lds r28, pulse1_output_volume
0015af 91d0 280e                 	lds r29, pulse2_output_volume
                                 
                                 volume_mixer_pulse1:
0015b1 fe70                      	sbrs pulse1_sequence, 0 //if the sequence output is zero, return
0015b2 c015                      	rjmp volume_mixer_pulse1_off
                                 
0015b3 1482                      	cp pulse1_length_counter, zero //if length is zero, return
0015b4 f099                      	breq volume_mixer_pulse1_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
0015b5 91e0 0a8c                 	lds r30, TCB0_CCMPL
0015b7 e5f9                      	ldi r31, 0x59
0015b8 17ef                      	cp r30, r31
0015b9 91e0 0a8d                 	lds r30, TCB0_CCMPH
0015bb e0f0                      	ldi r31, 0x00
0015bc 07ef                      	cpc r30, r31
0015bd f050                      	brlo volume_mixer_pulse1_off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $595A
0015be 91e0 0a8c                 	lds r30, TCB0_CCMPL
0015c0 e5fa                      	ldi r31, 0x5A
0015c1 17ef                      	cp r30, r31
0015c2 91e0 0a8d                 	lds r30, TCB0_CCMPH
0015c4 e5f9                      	ldi r31, 0x59
0015c5 07ef                      	cpc r30, r31
0015c6 f408                      	brsh volume_mixer_pulse1_off
0015c7 c001                      	rjmp volume_mixer_pulse2 //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse1_off:
0015c8 27cc                      	clr r28
                                 
                                 volume_mixer_pulse2:
0015c9 fea0                      	sbrs pulse2_sequence, 0 //if the sequence output is zero, return
0015ca c015                      	rjmp volume_mixer_pulse2_off
                                 
0015cb 14b2                      	cp pulse2_length_counter, zero //if length is zero, return
0015cc f099                      	breq volume_mixer_pulse2_off
                                 
0015cd 91e0 0a9c                 	lds r30, TCB1_CCMPL
0015cf e5f9                      	ldi r31, 0x59
0015d0 17ef                      	cp r30, r31
0015d1 91e0 0a9d                 	lds r30, TCB1_CCMPH
0015d3 e0f0                      	ldi r31, 0x00
0015d4 07ef                      	cpc r30, r31
0015d5 f050                      	brlo volume_mixer_pulse2_off
                                 
0015d6 91e0 0a9c                 	lds r30, TCB1_CCMPL
0015d8 e5fa                      	ldi r31, 0x5A
0015d9 17ef                      	cp r30, r31
0015da 91e0 0a9d                 	lds r30, TCB1_CCMPH
0015dc e5f9                      	ldi r31, 0x59
0015dd 07ef                      	cpc r30, r31
0015de f408                      	brsh volume_mixer_pulse2_off
0015df c001                      	rjmp volume_mixer_pulse_out //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse2_off:
0015e0 27dd                      	clr r29
                                 
                                 volume_mixer_pulse_out:
0015e1 0fcd                      	add r28, r29
0015e2 e6e2                      	ldi ZL, LOW(pulse_volume_table << 1)
0015e3 e0f2                      	ldi ZH, HIGH(pulse_volume_table << 1)
0015e4 0fec                      	add ZL, r28
0015e5 1df2                      	adc ZH, zero
0015e6 91c4                      	lpm r28, Z
                                 
                                 volume_mixer_tnd_triangle:
0015e7 2fd4                      	mov r29, triangle_sequence
0015e8 fdd4                      	sbrc r29, 4 //check 5th bit
0015e9 95d0                      	com r29
0015ea 70df                      	andi r29, 0x0F
0015eb 2fed                      	mov r30, r29
0015ec 0fde                      	add r29, r30 //multiply the triangle volume by 3
0015ed 0fde                      	add r29, r30
                                 
                                 volume_mixer_tnd_noise:
0015ee ff50                      	sbrs noise_sequence_LOW, 0 //check 0th bit, skip if set
0015ef c004                      	rjmp volume_mixer_tnd_out
0015f0 91e0 2816                 	lds r30, noise_output_volume
0015f2 0fee                      	lsl r30 //multiply noise volume by 2
0015f3 0fde                      	add r29, r30
                                 
                                 volume_mixer_tnd_out:
0015f4 e8e2                      	ldi ZL, LOW(tnd_volume_table << 1)
0015f5 e0f2                      	ldi ZH, HIGH(tnd_volume_table << 1)
0015f6 0fed                      	add ZL, r29
0015f7 1df2                      	adc ZH, zero
0015f8 91d4                      	lpm r29, Z
                                 
                                 volume_mixer_output:
0015f9 0fcd                      	add r28, r29
0015fa b9c1                      	out VPORTA_OUT, r28
0015fb cfb1                      	rjmp volume_mixer
                                 
                                 
                                 
                                 //FRAME COUNTER/AUDIO SAMPLE ISR
                                 frame_counter_routine:
0015fc b7bf                      	in r27, CPU_SREG
0015fd 93bf                      	push r27
0015fe 94f8                      	cli
                                 
0015ff 2da4                      	mov r26, frame_sequence
001600 0c43                      	add frame_sequence, one
001601 30a0                      	cpi r26, 0x00
001602 f029                      	breq sequence_0_2
001603 30a1                      	cpi r26, 0x01
001604 f059                      	breq sequence_1_3
001605 30a2                      	cpi r26, 0x02
001606 f009                      	breq sequence_0_2
001607 c0f3                      	rjmp sound_driver
                                 
                                 sequence_0_2:
                                 	//ENVELOPE
001608 d050                      	rcall pulse1_envelope_routine
001609 d09c                      	rcall pulse2_envelope_routine
                                 
00160a e0b3                      	ldi r27, RTC_CMP_bm | RTC_OVF_bm //clear OVF flag
00160b 93b0 0143                 	sts RTC_INTFLAGS, r27
00160d 91bf                      	pop r27
00160e bfbf                      	out CPU_SREG, r27
00160f 9518                      	reti
                                 
                                 sequence_1_3:
                                 	//ENVELOPE
001610 d048                      	rcall pulse1_envelope_routine
001611 d094                      	rcall pulse2_envelope_routine
                                 
                                 	//SWEEP
001612 fc93                      	sbrc pulse1_sweep, 3 //check if the sweep enable bit is cleared
001613 d01b                      	rcall pulse1_sweep_routine
001614 fcc3                      	sbrc pulse2_sweep, 3
001615 d066                      	rcall pulse2_sweep_routine
                                 
                                 	//LENGTH
                                 	//NOTE: The length routine is relatively simple, so we will not be using clocks to rjmp and ret to a seperate lable
                                 sequence_1_3_pulse1_length:
001616 fd95                      	sbrc pulse_channel_flags, 5 //check if the length counter halt bit is cleared
001617 c002                      	rjmp sequence_1_3_pulse2_length
001618 1082                      	cpse pulse1_length_counter, zero //if length counter is already 0, don't decrement
001619 948a                      	dec pulse1_length_counter
                                 sequence_1_3_pulse2_length:
00161a fd91                      	sbrc pulse_channel_flags, 1 //check if the length counter halt bit is cleared
00161b c002                      	rjmp sequence_1_3_exit
00161c 10b2                      	cpse pulse2_length_counter, zero //if length counter is already 0, don't decrement
00161d 94ba                      	dec pulse2_length_counter
                                 
                                 sequence_1_3_exit:
00161e e0b1                      	ldi r27, RTC_OVF_bm //clear OVF flag
00161f 93b0 0143                 	sts RTC_INTFLAGS, r27
001621 91bf                      	pop r27
001622 bfbf                      	out CPU_SREG, r27
001623 9518                      	reti
                                 
                                 //PULSE 1 ROUTINES
                                 pulse1_sequence_routine:
001624 b7bf                      	in r27, CPU_SREG
001625 93bf                      	push r27
001626 94f8                      	cli
                                 
001627 0c77                      	lsl pulse1_sequence //shifts sequence to the left
001628 1c72                      	adc pulse1_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
001629 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
00162a 93b0 0a86                 	sts TCB0_INTFLAGS, r27
00162c 91bf                      	pop r27
00162d bfbf                      	out CPU_SREG, r27
00162e 9518                      	reti
                                 
                                 pulse1_sweep_routine:
00162f 2db9                      	mov r27, pulse1_sweep
001630 70b7                      	andi r27, 0x07 //mask for period divider bits
001631 f4f9                      	brne pulse1_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse1_sweep_routine_action: //if the divider is == 0, update the pulse timer period
001632 93df                      	push r29
001633 2dd9                      	mov r29, pulse1_sweep
001634 95d2                      	swap r29
001635 70d7                      	andi r29, 0x07 //mask for shift bits
001636 f411                      	brne pulse1_sweep_routine_action_main //shift != 0
001637 91df                      	pop r29
001638 c019                      	rjmp pulse1_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse1_sweep_routine_action_main:
001639 91a0 0a8c                 	lds r26, TCB0_CCMPL
00163b 91b0 0a8d                 	lds r27, TCB0_CCMPH
                                 pulse1_sweep_routine_action_main_loop:
00163d 95b6                      	lsr r27
00163e 95a7                      	ror r26
00163f 95da                      	dec r29
001640 f7e1                      	brne pulse1_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
001641 fe97                      	sbrs pulse1_sweep, 7 //check the negate flag
001642 c002                      	rjmp pulse1_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
001643 95a0                      	com r26 //pulse1 uses one's complement if the negate flag is set
001644 95b0                      	com r27
                                 
                                 pulse1_sweep_routine_action_main_add:
001645 91d0 0a8c                 	lds r29, TCB0_CCMPL //perform addition to get new timer period
001647 0fad                      	add r26, r29
001648 91d0 0a8d                 	lds r29, TCB0_CCMPH
00164a 1fbd                      	adc r27, r29
                                 
00164b 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new LOW bits for timer
00164d 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new HIGH bits for timer
                                 	
00164f 91df                      	pop r29
001650 c001                      	rjmp pulse1_sweep_routine_check_reload
                                 
                                 pulse1_sweep_routine_decrement_divider:
001651 949a                      	dec pulse1_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse1_sweep_routine_check_reload:
001652 ff97                      	sbrs pulse_channel_flags, 7 //if the reload flag is set, reload the sweep divider
001653 9508                      	ret
                                 
                                 pulse1_sweep_reload:
001654 9090 2801                 	lds pulse1_sweep, pulse1_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
001656 9492                      	swap pulse1_sweep //bring data from high byte to low byte
001657 779f                      	cbr pulse_channel_flags, 0b10000000 //clear reload flag
001658 9508                      	ret
                                 
                                 
                                 
                                 pulse1_envelope_routine:
001659 fd96                      	sbrc pulse_channel_flags, 6 //check if start flag is cleared
00165a c010                      	rjmp pulse1_envelope_routine_clear_start
                                 
00165b 3000                      	cpi pulse1_volume_divider, 0x00 //check if the divider is 0
00165c f011                      	breq PC+3 //if the divider == 0, check loop flag
00165d 950a                      	dec pulse1_volume_divider //if the divider != 0, decrement and return
00165e 9508                      	ret
                                 
00165f 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the divider == 0, reset the divider period
001661 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
001662 ff95                      	sbrs pulse_channel_flags, 5 //check if the loop flag is set
001663 c002                      	rjmp pulse1_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
001664 e01f                      	ldi pulse1_volume_decay, 0x0F //if the loop flag is set, reset decay and return
001665 9508                      	ret
                                 
                                 pulse1_envelope_routine_decrement_decay:
001666 3010                      	cpi pulse1_volume_decay, 0x00 //check if the decay is 0
001667 f409                      	brne PC+2 //if decay != 0, go decrement
001668 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
001669 951a                      	dec pulse1_volume_decay
00166a 9508                      	ret
                                 
                                 pulse1_envelope_routine_clear_start:
00166b 7b9f                      	cbr pulse_channel_flags, 0b01000000 //if the start flag is set, clear it
00166c 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the start flag is set, reset the divider period
00166e 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
00166f e01f                      	ldi pulse1_volume_decay, 0x0F //if the start flag is set, reset decay
001670 9508                      	ret
                                 
                                 //PULSE 2 ROUTINES
                                 pulse2_sequence_routine:
001671 b7bf                      	in r27, CPU_SREG
001672 93bf                      	push r27
001673 94f8                      	cli
                                 
001674 0caa                      	lsl pulse2_sequence //shifts sequence to the left
001675 1ca2                      	adc pulse2_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
001676 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
001677 93b0 0a96                 	sts TCB1_INTFLAGS, r27
001679 91bf                      	pop r27
00167a bfbf                      	out CPU_SREG, r27
00167b 9518                      	reti
                                 
                                 pulse2_sweep_routine:
00167c 2dbc                      	mov r27, pulse2_sweep
00167d 70b7                      	andi r27, 0x07 //mask for period divider bits
00167e f4f9                      	brne pulse2_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse2_sweep_routine_action: //if the divider is == 0, update the pulse timer period
00167f 93df                      	push r29
001680 2ddc                      	mov r29, pulse2_sweep
001681 95d2                      	swap r29
001682 70d7                      	andi r29, 0x07 //mask for shift bits
001683 f411                      	brne pulse2_sweep_routine_action_main //shift != 0
001684 91df                      	pop r29
001685 c019                      	rjmp pulse2_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse2_sweep_routine_action_main:
001686 91a0 0a9c                 	lds r26, TCB1_CCMPL
001688 91b0 0a9d                 	lds r27, TCB1_CCMPH
                                 pulse2_sweep_routine_action_main_loop:
00168a 95b6                      	lsr r27
00168b 95a7                      	ror r26
00168c 95da                      	dec r29
00168d f7e1                      	brne pulse2_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
00168e fec7                      	sbrs pulse2_sweep, 7 //check the negate flag
00168f c002                      	rjmp pulse2_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
001690 95a0                      	com r26 //pulse2 uses one's complement if the negate flag is set
001691 95b0                      	com r27
                                 
                                 pulse2_sweep_routine_action_main_add:
001692 91d0 0a9c                 	lds r29, TCB1_CCMPL //perform addition to get new timer period
001694 0fad                      	add r26, r29
001695 91d0 0a9d                 	lds r29, TCB1_CCMPH
001697 1fbd                      	adc r27, r29
                                 
001698 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new LOW bits for timer
00169a 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new HIGH bits for timer
                                 	
00169c 91df                      	pop r29
00169d c001                      	rjmp pulse2_sweep_routine_check_reload
                                 
                                 pulse2_sweep_routine_decrement_divider:
00169e 94ca                      	dec pulse2_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse2_sweep_routine_check_reload:
00169f ff93                      	sbrs pulse_channel_flags, 3 //if the reload flag is set, reload the sweep divider
0016a0 9508                      	ret
                                 
                                 pulse2_sweep_reload:
0016a1 90c0 2809                 	lds pulse2_sweep, pulse2_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
0016a3 94c2                      	swap pulse2_sweep //bring data from high byte to low byte
0016a4 7f97                      	cbr pulse_channel_flags, 0b00001000 //clear reload flag
0016a5 9508                      	ret
                                 
                                 
                                 
                                 pulse2_envelope_routine:
0016a6 fd92                      	sbrc pulse_channel_flags, 2 //check if start flag is cleared
0016a7 c010                      	rjmp pulse2_envelope_routine_clear_start
                                 
0016a8 3020                      	cpi pulse2_volume_divider, 0x00 //check if the divider is 0
0016a9 f011                      	breq PC+3 //if the divider == 0, check loop flag
0016aa 952a                      	dec pulse2_volume_divider //if the divider != 0, decrement and return
0016ab 9508                      	ret
                                 
0016ac 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the divider == 0, reset the divider period
0016ae 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
0016af ff91                      	sbrs pulse_channel_flags, 1 //check if the loop flag is set
0016b0 c002                      	rjmp pulse2_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
0016b1 e03f                      	ldi pulse2_volume_decay, 0x0F //if the loop flag is set, reset decay and return
0016b2 9508                      	ret
                                 
                                 pulse2_envelope_routine_decrement_decay:
0016b3 3030                      	cpi pulse2_volume_decay, 0x00 //check if the decay is 0
0016b4 f409                      	brne PC+2 //if decay != 0, go decrement
0016b5 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
0016b6 953a                      	dec pulse2_volume_decay
0016b7 9508                      	ret
                                 
                                 pulse2_envelope_routine_clear_start:
0016b8 7f9b                      	cbr pulse_channel_flags, 0b00000100 //if the start flag is set, clear it
0016b9 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the start flag is set, reset the divider period
0016bb 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
0016bc e03f                      	ldi pulse2_volume_decay, 0x0F //if the start flag is set, reset decay
0016bd 9508                      	ret
                                 
                                 //TRIANGLE ROUTINES
                                 triangle_sequence_routine:
0016be b7bf                      	in r27, CPU_SREG
0016bf 93bf                      	push r27
0016c0 94f8                      	cli
                                 
0016c1 5f4f                      	subi triangle_sequence, -1 //increment sequence by 1
0016c2 714f                      	andi triangle_sequence, 0b00011111 //mask out bits 5, 6 and 7 NOTE: the sequence only needs bits 0-4.
                                 
0016c3 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
0016c4 93b0 0aa6                 	sts TCB2_INTFLAGS, r27
0016c6 91bf                      	pop r27
0016c7 bfbf                      	out CPU_SREG, r27
0016c8 9518                      	reti
                                 
                                 //NOISE ROUTINES
                                 noise_sequence_routine:
0016c9 b7bf                      	in r27, CPU_SREG
0016ca 93bf                      	push r27
0016cb 94f8                      	cli
                                 
0016cc 2fa5                      	mov r26, noise_sequence_LOW
0016cd fd67                      	sbrc noise_sequence_HIGH, 7 //skip if MODE bit is clear
0016ce c00b                      	rjmp noise_sequence_routine_mode_set
                                 
                                 noise_sequence_routine_mode_clear:
0016cf 95a6                      	lsr r26 //move the 1th bit to the 0th bit place
0016d0 27a5                      	eor r26, noise_sequence_LOW
0016d1 fda0                      	sbrc r26, 0 //skip if the EOR of bit 0 and 1 is clear
0016d2 c003                      	rjmp noise_sequence_routine_mode_clear_EOR_set
                                 
                                 noise_sequence_routine_mode_clear_EOR_clear:
0016d3 9566                      	lsr noise_sequence_HIGH
0016d4 9557                      	ror noise_sequence_LOW
0016d5 c013                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_clear_EOR_set:
0016d6 9566                      	lsr noise_sequence_HIGH
0016d7 9557                      	ror noise_sequence_LOW
0016d8 6460                      	ori noise_sequence_HIGH, 0b01000000 //set the 14th bit
0016d9 c00f                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_set:
0016da 0faa                      	lsl r26
0016db 1faa                      	rol r26
0016dc 1faa                      	rol r26 //move the 6th bit to the 0th bit place
0016dd 27a5                      	eor r26, noise_sequence_LOW
0016de fda0                      	sbrc r26, 0 //skip if the EOR of bit 0 and 1 is clear
0016df c005                      	rjmp noise_sequence_routine_mode_set_EOR_set
                                 
                                 noise_sequence_routine_mode_set_EOR_clear:
0016e0 776f                      	cbr noise_sequence_HIGH, 0b10000000 //clear the MODE flag
0016e1 9566                      	lsr noise_sequence_HIGH
0016e2 9557                      	ror noise_sequence_LOW
0016e3 6860                      	sbr noise_sequence_HIGH, 0b10000000 //set the MODE flag
0016e4 c004                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_set_EOR_set:
0016e5 9566                      	lsr noise_sequence_HIGH
0016e6 9557                      	ror noise_sequence_LOW
0016e7 6860                      	sbr noise_sequence_HIGH, 0b10000000 //set the MODE flag
0016e8 c000                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_exit:
0016e9 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
0016ea 93b0 0ab6                 	sts TCB3_INTFLAGS, r27
0016ec 91bf                      	pop r27
0016ed bfbf                      	out CPU_SREG, r27
0016ee 9518                      	reti
                                 
                                 //CONVERTERS
                                 //converts and loads 5 bit length to corresponding 8 bit length value into r29
                                 length_converter:
0016ef e8e2                      	ldi ZL, LOW(length << 1)
0016f0 e6f1                      	ldi ZH, HIGH(length << 1)
0016f1 0fed                      	add ZL, r29
0016f2 1df2                      	adc ZH, zero
0016f3 91d4                      	lpm r29, Z
0016f4 9508                      	ret
                                 
                                 //loads pulse sequence into r29
                                 duty_cycle_sequences:
0016f5 eae2                      	ldi ZL, LOW(sequences << 1)
0016f6 e6f1                      	ldi ZH, HIGH(sequences << 1)
0016f7 0fed                      	add ZL, r29
0016f8 1df2                      	adc ZH, zero
0016f9 91d4                      	lpm r29, Z
0016fa 9508                      	ret
                                 
                                 
                                 
                                 //SOUND DRIVER
                                 sound_driver:
0016fb 2c42                      	mov frame_sequence, zero
0016fc 93cf                      	push r28
0016fd 93df                      	push r29
0016fe 93ef                      	push r30
0016ff 93ff                      	push r31
                                 
                                 	//SOUND DRIVER
001700 91a0 2820                 	lds r26, song_fx_Bxx
001702 3faf                      	cpi r26, 0xFF //0xFF means that the flag is disabled
001703 f4a9                      	brne sound_driver_fx_Bxx_routine
001704 91a0 2821                 	lds r26, song_fx_Cxx
001706 11a2                      	cpse r26, zero
001707 c0a3                      	rjmp sound_driver_fx_Cxx_routine
001708 91a0 2822                 	lds r26, song_fx_Dxx
00170a 11a2                      	cpse r26, zero
00170b c0ae                      	rjmp sound_driver_fx_Dxx_routine
                                 
00170c 91a0 281b                 	lds r26, song_frame_offset
00170e 91b0 281c                 	lds r27, song_frame_offset+1
001710 91c0 281d                 	lds r28, song_size
001712 91d0 281e                 	lds r29, song_size+1
001714 17ac                      	cp r26, r28
001715 07bd                      	cpc r27, r29
001716 f408                      	brsh sound_driver_fx_song_loop
001717 c131                      	rjmp sound_driver_channel0
                                 
                                 
                                 sound_driver_fx_song_loop:
001718 e0a0                      	ldi r26, 0x00
                                 sound_driver_fx_Bxx_routine:
001719 91e0 2819                 	lds ZL, song_frames
00171b 91f0 281a                 	lds ZH, song_frames+1
00171d 27cc                      	clr r28 //initialize r29:r28 to 0
00171e 27dd                      	clr r29
00171f 95a3                      	inc r26 //increment xx parameter by 1
                                 sound_driver_fx_Bxx_routine_loop:
001720 95aa                      	dec r26
001721 f011                      	breq sound_driver_fx_Bxx_routine_loop_exit //once r26 == 0, r29:r28 will hold Bxx*(5*2).
001722 962a                      	adiw r29:r28, 10 //increment the offset by 10 because 5 channels, and each address takes 2 bytes (5*2 = 10)
001723 cffc                      	rjmp sound_driver_fx_Bxx_routine_loop
                                 
                                 sound_driver_fx_Bxx_routine_loop_exit:
001724 9622                      	adiw r29:r28, 2 //add 2 to skip the first 2 bytes (first 2 bytes is the song size)
001725 93c0 281b                 	sts song_frame_offset, r28
001727 93d0 281c                 	sts song_frame_offset+1, r29
001729 0fec                      	add ZL, r28
00172a 1ffd                      	adc ZH, r29
                                 
00172b 91a5                      	lpm r26, Z+ //load the address of the frame(pattern)
00172c 91b5                      	lpm r27, Z+
00172d 0faa                      	lsl r26
00172e 1fbb                      	rol r27
00172f 93a0 2823                 	sts pulse1_pattern, r26
001731 93b0 2824                 	sts pulse1_pattern+1, r27
001733 91a5                      	lpm r26, Z+
001734 91b5                      	lpm r27, Z+
001735 0faa                      	lsl r26
001736 1fbb                      	rol r27
001737 93a0 2874                 	sts pulse2_pattern, r26
001739 93b0 2875                 	sts pulse2_pattern+1, r27
00173b 91a5                      	lpm r26, Z+
00173c 91b5                      	lpm r27, Z+
00173d 0faa                      	lsl r26
00173e 1fbb                      	rol r27
00173f 93a0 28c5                 	sts triangle_pattern, r26
001741 93b0 28c6                 	sts triangle_pattern+1, r27
001743 91a5                      	lpm r26, Z+
001744 91b5                      	lpm r27, Z+
001745 0faa                      	lsl r26
001746 1fbb                      	rol r27
001747 93a0 2911                 	sts noise_pattern, r26
001749 93b0 2912                 	sts noise_pattern+1, r27
00174b 91a5                      	lpm r26, Z+
00174c 91b5                      	lpm r27, Z+
00174d 0faa                      	lsl r26
00174e 1fbb                      	rol r27
00174f 93a0 2948                 	sts dpcm_pattern, r26
001751 93b0 2949                 	sts dpcm_pattern+1, r27
                                 
001753 9220 2827                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001755 9220 2828                 	sts pulse1_pattern_offset+1, zero
001757 9220 2825                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
001759 9230 2826                 	sts pulse1_pattern_delay_frames, one
00175b 9220 2878                 	sts pulse2_pattern_offset, zero
00175d 9220 2879                 	sts pulse2_pattern_offset+1, zero
00175f 9220 2876                 	sts pulse2_pattern_delay_rows, zero
001761 9230 2877                 	sts pulse2_pattern_delay_frames, one
001763 9220 28c9                 	sts triangle_pattern_offset, zero
001765 9220 28ca                 	sts triangle_pattern_offset+1, zero
001767 9220 28c7                 	sts triangle_pattern_delay_rows, zero
001769 9230 28c8                 	sts triangle_pattern_delay_frames, one
00176b 9220 2915                 	sts noise_pattern_offset, zero
00176d 9220 2916                 	sts noise_pattern_offset+1, zero
00176f 9220 2913                 	sts noise_pattern_delay_rows, zero
001771 9230 2914                 	sts noise_pattern_delay_frames, one
001773 9220 294c                 	sts dpcm_pattern_offset, zero
001775 9220 294c                 	sts dpcm_pattern_offset, zero
001777 9220 294a                 	sts dpcm_pattern_delay_rows, zero
001779 9230 294b                 	sts dpcm_pattern_delay_frames, one
                                 
00177b efaf                      	ldi r26, 0xFF
00177c 93a0 2860                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
00177e 93a0 2861                 	sts pulse1_fx_Gxx_post, r26
001780 93a0 2872                 	sts pulse1_fx_Sxx_pre, r26
001782 93a0 2873                 	sts pulse1_fx_Sxx_post, r26
001784 93a0 28b1                 	sts pulse2_fx_Gxx_pre, r26
001786 93a0 28b2                 	sts pulse2_fx_Gxx_post, r26
001788 93a0 28c3                 	sts pulse2_fx_Sxx_pre, r26
00178a 93a0 28c4                 	sts pulse2_fx_Sxx_post, r26
00178c 93a0 28fd                 	sts triangle_fx_Gxx_pre, r26
00178e 93a0 28fe                 	sts triangle_fx_Gxx_post, r26
001790 93a0 290f                 	sts triangle_fx_Sxx_pre, r26
001792 93a0 2910                 	sts triangle_fx_Sxx_post, r26
001794 93a0 2943                 	sts noise_fx_Gxx_pre, r26
001796 93a0 2944                 	sts noise_fx_Gxx_post, r26
001798 93a0 2946                 	sts noise_fx_Sxx_pre, r26
00179a 93a0 2947                 	sts noise_fx_Sxx_post, r26
00179c 93a0 2952                 	sts dpcm_fx_Gxx_pre, r26
00179e 93a0 2953                 	sts dpcm_fx_Gxx_post, r26
0017a0 93a0 2954                 	sts dpcm_fx_Sxx_pre, r26
0017a2 93a0 2955                 	sts dpcm_fx_Sxx_post, r26
                                 
0017a4 93a0 2820                 	sts song_fx_Bxx, r26 //reset all song effects
0017a6 9220 2821                 	sts song_fx_Cxx, zero
0017a8 9220 2822                 	sts song_fx_Dxx, zero
0017aa c09e                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_fx_Cxx_routine:
0017ab 91ff                      	pop r31
0017ac 91ef                      	pop r30
0017ad 91df                      	pop r29
0017ae 91cf                      	pop r28
0017af 91bf                      	pop r27
0017b0 bfbf                      	out CPU_SREG, r27
0017b1 94f8                      	cli //disable global interrupts
                                 		
0017b2 efaf                      	ldi r26, 0xFF
0017b3 93a0 2820                 	sts song_fx_Bxx, r26 //reset all song effects
0017b5 9220 2821                 	sts song_fx_Cxx, zero
0017b7 9220 2822                 	sts song_fx_Dxx, zero
0017b9 9518                      	reti
                                 
                                 sound_driver_fx_Dxx_routine:
0017ba 91e0 2819                 	lds ZL, song_frames
0017bc 91f0 281a                 	lds ZH, song_frames+1
0017be 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
0017c0 91b0 281c                 	lds r27, song_frame_offset+1
0017c2 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
0017c3 93a0 281b                 	sts song_frame_offset, r26
0017c5 93b0 281c                 	sts song_frame_offset+1, r27
0017c7 0fea                      	add ZL, r26
0017c8 1ffb                      	adc ZH, r27
                                 
0017c9 91a5                      	lpm r26, Z+ //load the address of the next pattern
0017ca 91b5                      	lpm r27, Z+
0017cb 0faa                      	lsl r26
0017cc 1fbb                      	rol r27
0017cd 93a0 2823                 	sts pulse1_pattern, r26
0017cf 93b0 2824                 	sts pulse1_pattern+1, r27
0017d1 91a5                      	lpm r26, Z+
0017d2 91b5                      	lpm r27, Z+
0017d3 0faa                      	lsl r26
0017d4 1fbb                      	rol r27
0017d5 93a0 2874                 	sts pulse2_pattern, r26
0017d7 93b0 2875                 	sts pulse2_pattern+1, r27
0017d9 91a5                      	lpm r26, Z+
0017da 91b5                      	lpm r27, Z+
0017db 0faa                      	lsl r26
0017dc 1fbb                      	rol r27
0017dd 93a0 28c5                 	sts triangle_pattern, r26
0017df 93b0 28c6                 	sts triangle_pattern+1, r27
0017e1 91a5                      	lpm r26, Z+
0017e2 91b5                      	lpm r27, Z+
0017e3 0faa                      	lsl r26
0017e4 1fbb                      	rol r27
0017e5 93a0 2911                 	sts noise_pattern, r26
0017e7 93b0 2912                 	sts noise_pattern+1, r27
0017e9 91a5                      	lpm r26, Z+
0017ea 91b5                      	lpm r27, Z+
0017eb 0faa                      	lsl r26
0017ec 1fbb                      	rol r27
0017ed 93a0 2948                 	sts dpcm_pattern, r26
0017ef 93b0 2949                 	sts dpcm_pattern+1, r27
                                 
0017f1 9220 2827                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
0017f3 9220 2828                 	sts pulse1_pattern_offset+1, zero
0017f5 9220 2825                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
0017f7 9230 2826                 	sts pulse1_pattern_delay_frames, one
0017f9 9220 2878                 	sts pulse2_pattern_offset, zero
0017fb 9220 2879                 	sts pulse2_pattern_offset+1, zero
0017fd 9220 2876                 	sts pulse2_pattern_delay_rows, zero
0017ff 9230 2877                 	sts pulse2_pattern_delay_frames, one
001801 9220 28c9                 	sts triangle_pattern_offset, zero
001803 9220 28ca                 	sts triangle_pattern_offset+1, zero
001805 9220 28c7                 	sts triangle_pattern_delay_rows, zero
001807 9230 28c8                 	sts triangle_pattern_delay_frames, one
001809 9220 2915                 	sts noise_pattern_offset, zero
00180b 9220 2916                 	sts noise_pattern_offset+1, zero
00180d 9220 2913                 	sts noise_pattern_delay_rows, zero
00180f 9230 2914                 	sts noise_pattern_delay_frames, one
001811 9220 294c                 	sts dpcm_pattern_offset, zero
001813 9220 294c                 	sts dpcm_pattern_offset, zero
001815 9220 294a                 	sts dpcm_pattern_delay_rows, zero
001817 9230 294b                 	sts dpcm_pattern_delay_frames, one
                                 
001819 efaf                      	ldi r26, 0xFF
00181a 93a0 2860                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
00181c 93a0 2861                 	sts pulse1_fx_Gxx_post, r26
00181e 93a0 2872                 	sts pulse1_fx_Sxx_pre, r26
001820 93a0 2873                 	sts pulse1_fx_Sxx_post, r26
001822 93a0 28b1                 	sts pulse2_fx_Gxx_pre, r26
001824 93a0 28b2                 	sts pulse2_fx_Gxx_post, r26
001826 93a0 28c3                 	sts pulse2_fx_Sxx_pre, r26
001828 93a0 28c4                 	sts pulse2_fx_Sxx_post, r26
00182a 93a0 28fd                 	sts triangle_fx_Gxx_pre, r26
00182c 93a0 28fe                 	sts triangle_fx_Gxx_post, r26
00182e 93a0 290f                 	sts triangle_fx_Sxx_pre, r26
001830 93a0 2910                 	sts triangle_fx_Sxx_post, r26
001832 93a0 2943                 	sts noise_fx_Gxx_pre, r26
001834 93a0 2944                 	sts noise_fx_Gxx_post, r26
001836 93a0 2946                 	sts noise_fx_Sxx_pre, r26
001838 93a0 2947                 	sts noise_fx_Sxx_post, r26
00183a 93a0 2952                 	sts dpcm_fx_Gxx_pre, r26
00183c 93a0 2953                 	sts dpcm_fx_Gxx_post, r26
00183e 93a0 2954                 	sts dpcm_fx_Sxx_pre, r26
001840 93a0 2955                 	sts dpcm_fx_Sxx_post, r26
                                 
001842 93a0 2820                 	sts song_fx_Bxx, r26 //reset all song effects
001844 9220 2821                 	sts song_fx_Cxx, zero
001846 9220 2822                 	sts song_fx_Dxx, zero
001848 c000                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0:
001849 91a0 2825                 	lds r26, pulse1_pattern_delay_rows
00184b 91b0 2826                 	lds r27, pulse1_pattern_delay_frames
                                 sound_driver_channel0_decrement_frame_delay:
00184d 95ba                      	dec r27
00184e 93b0 2826                 	sts pulse1_pattern_delay_frames, r27
                                 
001850 9610                      	adiw r27:r26, 0
001851 f009                      	breq sound_driver_channel0_main //if the pattern delay is 0, proceed with sound driver procedures
001852 c2e4                      	rjmp sound_driver_channel0_end //if the pattern delay is not 0, end routine
                                 
                                 sound_driver_channel0_main:
001853 91e0 2823                 	lds ZL, pulse1_pattern //current pattern for pulse 1
001855 91f0 2824                 	lds ZH, pulse1_pattern+1
001857 91a0 2827                 	lds r26, pulse1_pattern_offset //current offset in the pattern for pulse 1
001859 91b0 2828                 	lds r27, pulse1_pattern_offset+1
00185b 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
00185c 1ffb                      	adc ZH, r27
00185d 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel0_check_if_note: //check if data is a note (0x00 - 0x56)
00185e 35b7                      	cpi r27, 0x57
00185f f408                      	brsh sound_driver_channel0_check_if_volume
001860 c17c                      	rjmp sound_driver_channel0_note
                                 sound_driver_channel0_check_if_volume: //check if data is volume (0x57-0x66)
001861 36b7                      	cpi r27, 0x67
001862 f408                      	brsh sound_driver_channel0_check_if_delay
001863 c1ba                      	rjmp sound_driver_channel0_volume
                                 sound_driver_channel0_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001864 3eb3                      	cpi r27, 0xE3
001865 f408                      	brsh sound_driver_channel0_check_if_instrument
001866 c1c1                      	rjmp sound_driver_channel0_delay
                                 sound_driver_channel0_check_if_instrument: //check for instrument flag (0xE3)
001867 f409                      	brne sound_driver_channel0_check_if_release
001868 c1c4                      	rjmp sound_driver_channel0_instrument_change 
                                 sound_driver_channel0_check_if_release: //check for note release flag (0xE4)
001869 3eb4                      	cpi r27, 0xE4
00186a f409                      	brne sound_driver_channel0_check_if_end
00186b c26d                      	rjmp sound_driver_channel0_release
                                 sound_driver_channel0_check_if_end:
00186c 3fbf                      	cpi r27, 0xFF
00186d f409                      	brne sound_driver_channel0_check_if_fx
00186e c28f                      	rjmp sound_driver_channel0_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel0_check_if_fx: //fx flags (0xE5 - 0xFE)
00186f 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001870 91a4                      	lpm r26, Z //load the fx data into r26
001871 d2bb                      	rcall sound_driver_channel0_increment_offset_twice
                                 
001872 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001873 eae6                      	ldi ZL, LOW(channel0_fx << 1) //load in note table
001874 e6f1                      	ldi ZH, HIGH(channel0_fx << 1)
001875 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001876 0feb                      	add ZL, r27 //add offset
001877 1df2                      	adc ZH, zero
001878 91c5                      	lpm r28, Z+ //load address bytes
001879 91d4                      	lpm r29, Z
00187a 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
00187b 2ffd                      	mov ZH, r29
00187c 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel0_fx_0xy:
00187d 93a0 2846                 	sts pulse1_fx_0xy_sequence, r26
00187f 9220 2847                 	sts pulse1_fx_0xy_sequence+1, zero
001881 cfd1                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel0_fx_1xx:
001882 9220 284c                 	sts pulse1_fx_2xx, zero //turn off any 2xx pitch slide down
001884 9220 284d                 	sts pulse1_fx_2xx+1, zero
001886 9220 2846                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
001888 9220 2847                 	sts pulse1_fx_0xy_sequence+1, zero
00188a 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00188b 937f                      	push r23
00188c 2f6a                      	mov r22, r26 //store the rate into r22
00188d eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00188e 9f67                      	mul r22, r23
00188f 917f                      	pop r23
001890 916f                      	pop r22
                                 
001891 9416                      	lsr r1 //shift out the fractional bits
001892 9407                      	ror r0
001893 9416                      	lsr r1
001894 9407                      	ror r0
001895 9416                      	lsr r1
001896 9407                      	ror r0
001897 9416                      	lsr r1
001898 9407                      	ror r0
001899 9200 2848                 	sts pulse1_fx_1xx, r0
00189b 9210 2849                 	sts pulse1_fx_1xx+1, r1
00189d cfb5                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel0_fx_2xx:
00189e 9220 2848                 	sts pulse1_fx_1xx, zero //turn off any 1xx pitch slide down
0018a0 9220 2849                 	sts pulse1_fx_1xx+1, zero
0018a2 9220 2846                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
0018a4 9220 2847                 	sts pulse1_fx_0xy_sequence+1, zero
0018a6 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0018a7 937f                      	push r23
0018a8 2f6a                      	mov r22, r26 //store the rate into r22
0018a9 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0018aa 9f67                      	mul r22, r23
0018ab 917f                      	pop r23
0018ac 916f                      	pop r22
                                 
0018ad 9416                      	lsr r1 //shift out the fractional bits
0018ae 9407                      	ror r0
0018af 9416                      	lsr r1
0018b0 9407                      	ror r0
0018b1 9416                      	lsr r1
0018b2 9407                      	ror r0
0018b3 9416                      	lsr r1
0018b4 9407                      	ror r0
0018b5 9200 284c                 	sts pulse1_fx_2xx, r0
0018b7 9210 284d                 	sts pulse1_fx_2xx+1, r1
0018b9 cf99                      	rjmp sound_driver_channel0_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel0_fx_3xx:
0018ba 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0018bb 937f                      	push r23
0018bc 2f6a                      	mov r22, r26 //store the rate into r22
0018bd eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0018be 9f67                      	mul r22, r23
0018bf 917f                      	pop r23
0018c0 916f                      	pop r22
                                 
0018c1 9416                      	lsr r1 //shift out the fractional bits
0018c2 9407                      	ror r0
0018c3 9416                      	lsr r1
0018c4 9407                      	ror r0
0018c5 9416                      	lsr r1
0018c6 9407                      	ror r0
0018c7 9416                      	lsr r1
0018c8 9407                      	ror r0
0018c9 9200 2854                 	sts pulse1_fx_3xx_speed, r0
0018cb 9210 2855                 	sts pulse1_fx_3xx_speed+1, r1
                                 
0018cd 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
0018ce c001                      	rjmp sound_driver_channel0_fx_3xx_enabled
0018cf cf83                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_3xx_enabled:
0018d0 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
0018d2 91b0 0a8d                 	lds r27, TCB0_CCMPH
0018d4 93a0 2850                 	sts pulse1_fx_3xx_start, r26
0018d6 93b0 2851                 	sts pulse1_fx_3xx_start+1, r27
                                 
0018d8 9220 2856                 	sts pulse1_fx_3xx_total_offset, zero
0018da 9220 2857                 	sts pulse1_fx_3xx_total_offset+1, zero
0018dc cf76                      	rjmp sound_driver_channel0_main
                                 
                                 //VIBRATO
                                 sound_driver_channel0_fx_4xy:
0018dd 2fba                      	mov r27, r26
0018de 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
0018df 95a2                      	swap r26
0018e0 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0018e1 93a0 2858                 	sts pulse1_fx_4xy_speed, r26
0018e3 93b0 2859                 	sts pulse1_fx_4xy_depth, r27
0018e5 9220 285a                 	sts pulse1_fx_4xy_phase, zero //reset the phase to 0
0018e7 cf6b                      	rjmp sound_driver_channel0_main
                                 
                                 //TREMELO
                                 sound_driver_channel0_fx_7xy:
0018e8 2fba                      	mov r27, r26
0018e9 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
0018ea 95a2                      	swap r26
0018eb 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0018ec 93a0 285b                 	sts pulse1_fx_7xy_speed, r26
0018ee 93b0 285c                 	sts pulse1_fx_7xy_depth, r27
0018f0 9220 285d                 	sts pulse1_fx_7xy_phase, zero //reset the phase to 0
0018f2 9220 285e                 	sts pulse1_fx_7xy_value, zero //reset the tremelo value
0018f4 cf5e                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel0_fx_Axy:
0018f5 93a0 285f                 	sts pulse1_fx_Axy, r26
0018f7 cf5b                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel0_fx_Bxx:
0018f8 93a0 2820                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
0018fa cf58                      	rjmp sound_driver_channel0_main
                                 
                                 //HALT
                                 sound_driver_channel0_fx_Cxx:
0018fb 93b0 2821                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
0018fd cf55                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel0_fx_Dxx:
0018fe 93b0 2822                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001900 cf52                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME
                                 sound_driver_channel0_fx_Exx:
001901 91b0 2800                 	lds r27, pulse1_param
001903 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
001904 2bba                      	or r27, r26 //move new VVVV bits into pulse1_param
001905 93b0 2800                 	sts pulse1_param, r27
001907 6096                      	sbr pulse_channel_flags, 6
001908 cf4a                      	rjmp sound_driver_channel0_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel0_fx_Fxx:
001909 93a0 281f                 	sts song_speed, r26 //NOTE: only changes to speed are supported
00190b cf47                      	rjmp sound_driver_channel0_main
                                 
                                 //DELAY
                                 sound_driver_channel0_fx_Gxx:
00190c 15a2                      	cp r26, zero
00190d f051                      	breq sound_driver_channel0_fx_Gxx_invalid
00190e 91b0 281f                 	lds r27, song_speed
001910 17ab                      	cp r26, r27
001911 f430                      	brsh sound_driver_channel0_fx_Gxx_invalid
001912 93a0 2860                 	sts pulse1_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001914 e0b1                      	ldi r27, 0x01
001915 93b0 2825                 	sts pulse1_pattern_delay_rows, r27
001917 c22e                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Gxx_invalid:
001918 cf3a                      	rjmp sound_driver_channel0_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel0_fx_Hxy: //hardware sweep up
001919 cf39                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixy: //hardware sweep down
00191a cf38                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Hxx: //FDS modulation depth
00191b cf37                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixx: //FDS modulation speed
00191c cf36                      	rjmp sound_driver_channel0_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel0_fx_Pxx:
00191d 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00191e 937f                      	push r23
00191f 2f6a                      	mov r22, r26
001920 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001921 0367                      	mulsu r22, r23
001922 917f                      	pop r23
001923 916f                      	pop r22
001924 9416                      	lsr r1 //shift out the fractional bits
001925 9407                      	ror r0
001926 9416                      	lsr r1
001927 9407                      	ror r0
001928 9416                      	lsr r1
001929 9407                      	ror r0
00192a 9416                      	lsr r1
00192b 9407                      	ror r0
00192c fe13                      	sbrs r1, 3 //check if result was a negative number
00192d c002                      	rjmp sound_driver_channel0_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel0_fx_Pxx_negative:
00192e efb0                      	ldi r27, 0xF0
00192f 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel0_fx_Pxx_store:
001930 9200 2862                 	sts pulse1_fx_Pxx_total, r0
001932 9210 2863                 	sts pulse1_fx_Pxx_total+1, r1
001934 cf1e                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel0_fx_Qxy:
                                 sound_driver_channel0_fx_Qxy_check_arpeggio_macro:
001935 91e0 282e                 	lds ZL, pulse1_arpeggio_macro
001937 91f0 282f                 	lds ZH, pulse1_arpeggio_macro+1
001939 9630                      	adiw Z, 0
00193a f009                      	breq sound_driver_channel0_fx_Qxy_check_pitch_macro
00193b cf17                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_pitch_macro:
00193c 91e0 2836                 	lds ZL, pulse1_pitch_macro
00193e 91f0 2837                 	lds ZH, pulse1_pitch_macro+1
001940 9630                      	adiw Z, 0
001941 f009                      	breq sound_driver_channel0_fx_Qxy_check_hi_pitch_macro
001942 cf10                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_hi_pitch_macro:
001943 91e0 283c                 	lds ZL, pulse1_hi_pitch_macro
001945 91f0 283d                 	lds ZH, pulse1_hi_pitch_macro+1
001947 9630                      	adiw Z, 0
001948 f009                      	breq sound_driver_channel0_fx_Qxy_process
001949 cf09                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_process:
00194a 2fba                      	mov r27, r26 //copy fx parameters into r27
00194b 70bf                      	andi r27, 0x0F //mask note index offset
00194c 91c0 2864                 	lds r28, pulse1_fx_Qxy_target_note //load current note index
00194e 0fbc                      	add r27, r28
00194f 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001950 f008                      	brlo sound_driver_channel0_fx_Qxy_process_continue
001951 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel0_fx_Qxy_process_continue:
001952 93b0 2864                 	sts pulse1_fx_Qxy_target_note, r27
001954 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001955 e0f0                      	ldi ZH, HIGH(note_table << 1)
001956 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001957 0feb                      	add ZL, r27 //add offset
001958 1df2                      	adc ZH, zero
001959 91c5                      	lpm r28, Z+ //load bytes
00195a 91d4                      	lpm r29, Z
00195b 93c0 2865                 	sts pulse1_fx_Qxy_target, r28 //load the LOW bits for the target period
00195d 93d0 2866                 	sts pulse1_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel0_fx_Qxy_process_speed:
00195f 95a2                      	swap r26
001960 70af                      	andi r26, 0x0F //mask effect speed
001961 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001962 95a3                      	inc r26 //increment the speed by 1
                                 
001963 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001964 937f                      	push r23
001965 2f6a                      	mov r22, r26 //store the speed data into r27
001966 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001967 9f67                      	mul r22, r23
001968 917f                      	pop r23
001969 916f                      	pop r22
                                 
00196a 9416                      	lsr r1 //shift out the fractional bits
00196b 9407                      	ror r0
00196c 9416                      	lsr r1
00196d 9407                      	ror r0
00196e 9416                      	lsr r1
00196f 9407                      	ror r0
001970 9416                      	lsr r1
001971 9407                      	ror r0
                                 
001972 9200 2867                 	sts pulse1_fx_Qxy_speed, r0 //store the effect speed
001974 9210 2868                 	sts pulse1_fx_Qxy_speed+1, r1
001976 cedc                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel0_fx_Rxy:
                                 sound_driver_channel0_fx_Rxy_check_arpeggio_macro:
001977 91e0 282e                 	lds ZL, pulse1_arpeggio_macro
001979 91f0 282f                 	lds ZH, pulse1_arpeggio_macro+1
00197b 9630                      	adiw Z, 0
00197c f009                      	breq sound_driver_channel0_fx_Rxy_check_pitch_macro
00197d ced5                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_pitch_macro:
00197e 91e0 2836                 	lds ZL, pulse1_pitch_macro
001980 91f0 2837                 	lds ZH, pulse1_pitch_macro+1
001982 9630                      	adiw Z, 0
001983 f009                      	breq sound_driver_channel0_fx_Rxy_check_hi_pitch_macro
001984 cece                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_hi_pitch_macro:
001985 91e0 283c                 	lds ZL, pulse1_hi_pitch_macro
001987 91f0 283d                 	lds ZH, pulse1_hi_pitch_macro+1
001989 9630                      	adiw Z, 0
00198a f009                      	breq sound_driver_channel0_fx_Rxy_process
00198b cec7                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_process:
00198c 2fba                      	mov r27, r26 //copy fx parameters into r27
00198d 70bf                      	andi r27, 0x0F //mask note index offset
00198e 91c0 286b                 	lds r28, pulse1_fx_Rxy_target_note //load current note index
001990 1bcb                      	sub r28, r27
001991 f408                      	brcc sound_driver_channel0_fx_Rxy_process_continue
001992 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel0_fx_Rxy_process_continue:
001993 93c0 286b                 	sts pulse1_fx_Rxy_target_note, r28
001995 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001996 e0f0                      	ldi ZH, HIGH(note_table << 1)
001997 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001998 0fec                      	add ZL, r28 //add offset
001999 1df2                      	adc ZH, zero
00199a 91c5                      	lpm r28, Z+ //load bytes
00199b 91d4                      	lpm r29, Z
00199c 93c0 286c                 	sts pulse1_fx_Rxy_target, r28 //load the LOW bits for the target period
00199e 93d0 286d                 	sts pulse1_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel0_fx_Rxy_process_speed:
0019a0 95a2                      	swap r26
0019a1 70af                      	andi r26, 0x0F //mask effect speed
0019a2 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0019a3 95a3                      	inc r26 //increment the speed by 1
                                 
0019a4 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0019a5 937f                      	push r23
0019a6 2f6a                      	mov r22, r26 //store the speed data into r27
0019a7 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0019a8 9f67                      	mul r22, r23
0019a9 917f                      	pop r23
0019aa 916f                      	pop r22
                                 
0019ab 9416                      	lsr r1 //shift out the fractional bits
0019ac 9407                      	ror r0
0019ad 9416                      	lsr r1
0019ae 9407                      	ror r0
0019af 9416                      	lsr r1
0019b0 9407                      	ror r0
0019b1 9416                      	lsr r1
0019b2 9407                      	ror r0
                                 
0019b3 9200 286e                 	sts pulse1_fx_Rxy_speed, r0 //store the effect speed
0019b5 9210 286f                 	sts pulse1_fx_Rxy_speed+1, r1
0019b7 ce9b                      	rjmp sound_driver_channel0_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel0_fx_Sxx:
0019b8 15a2                      	cp r26, zero
0019b9 f051                      	breq sound_driver_channel0_fx_Sxx_invalid
0019ba 91b0 281f                 	lds r27, song_speed
0019bc 17ab                      	cp r26, r27
0019bd f430                      	brsh sound_driver_channel0_fx_Sxx_invalid
0019be 93a0 2872                 	sts pulse1_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
0019c0 e0b1                      	ldi r27, 0x01
0019c1 93b0 2825                 	sts pulse1_pattern_delay_rows, r27
0019c3 c182                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Sxx_invalid:
0019c4 ce8e                      	rjmp sound_driver_channel0_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel0_fx_Vxx:
0019c5 eae2                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
0019c6 e6f1                      	ldi ZH, HIGH(sequences << 1)
0019c7 0fea                      	add ZL, r26 //offset the pointer
0019c8 1df2                      	adc ZH, zero
                                 
0019c9 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
0019ca 95a7                      	ror r26
0019cb 95a7                      	ror r26
0019cc 91b0 2800                 	lds r27, pulse1_param //load r27 with pulse1_param (register $4000)
0019ce 2fcb                      	mov r28, r27 //store a copy of pulse1_param into r28
0019cf 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
0019d0 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
0019d1 c001                      	rjmp sound_driver_channel0_fx_Vxx_store
0019d2 ce80                      	rjmp sound_driver_channel0_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel0_fx_Vxx_store:
0019d3 9074                      	lpm pulse1_sequence, Z //store the sequence
                                 
0019d4 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
0019d5 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
0019d6 93c0 2800                 	sts pulse1_param, r28
0019d8 ce7a                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_Wxx: //DPCM sample speed
0019d9 ce79                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Xxx: //DPCM sample retrigger
0019da ce78                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Yxx: //DPCM sample offset
0019db ce77                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Zxx: //DPCM sample delta counter
0019dc ce76                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 sound_driver_channel0_note:
0019dd 93b0 2807                 	sts pulse1_note, r27 //store the note index
0019df 93b0 2864                 	sts pulse1_fx_Qxy_target_note, r27
0019e1 93b0 286b                 	sts pulse1_fx_Rxy_target_note, r27
0019e3 e0a3                      	ldi r26, 0x03
0019e4 e0b2                      	ldi r27, 0x02
0019e5 93b0 282b                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
0019e7 93a0 2830                 	sts pulse1_arpeggio_macro_offset, r26
0019e9 93b0 2838                 	sts pulse1_pitch_macro_offset, r27
0019eb 93b0 283e                 	sts pulse1_hi_pitch_macro_offset, r27
0019ed 93b0 2843                 	sts pulse1_duty_macro_offset, r27
0019ef 9220 2834                 	sts pulse1_total_pitch_offset, zero //reset the pitch and hi pitch offset
0019f1 9220 2835                 	sts pulse1_total_pitch_offset+1, zero
0019f3 9220 283b                 	sts pulse1_total_hi_pitch_offset, zero
0019f5 9220 284a                 	sts pulse1_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
0019f7 9220 284b                 	sts pulse1_fx_1xx_total+1, zero
0019f9 9220 284e                 	sts pulse1_fx_2xx_total, zero
0019fb 9220 284f                 	sts pulse1_fx_2xx_total+1, zero
0019fd 9220 2856                 	sts pulse1_fx_3xx_total_offset, zero //reset 3xx offset
0019ff 9220 2857                 	sts pulse1_fx_3xx_total_offset+1, zero
001a01 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001a03 91b0 0a8d                 	lds r27, TCB0_CCMPH
001a05 93a0 2850                 	sts pulse1_fx_3xx_start, r26
001a07 93b0 2851                 	sts pulse1_fx_3xx_start+1, r27
001a09 9220 2801                 	sts pulse1_sweep_param, zero //reset any sweep effect
001a0b 6097                      	sbr pulse_channel_flags, 7 //set reload flag
001a0c 9220 2865                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001a0e 9220 2866                 	sts pulse1_fx_Qxy_target+1, zero
001a10 9220 2869                 	sts pulse1_fx_Qxy_total_offset, zero
001a12 9220 286a                 	sts pulse1_fx_Qxy_total_offset+1, zero
001a14 9220 286c                 	sts pulse1_fx_Rxy_target, zero
001a16 9220 286d                 	sts pulse1_fx_Rxy_target+1, zero
001a18 9220 2870                 	sts pulse1_fx_Rxy_total_offset, zero
001a1a 9220 2871                 	sts pulse1_fx_Rxy_total_offset+1, zero
001a1c d106                      	rcall sound_driver_channel0_increment_offset
001a1d ce35                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_volume:
001a1e 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest note value, which is 0x56
001a1f 91a0 2800                 	lds r26, pulse1_param
001a21 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001a22 2bab                      	or r26, r27 //move new VVVV bits into pulse1_param
001a23 93a0 2800                 	sts pulse1_param, r26
001a25 6096                      	sbr pulse_channel_flags, 6
001a26 d0fc                      	rcall sound_driver_channel0_increment_offset
001a27 ce2b                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_delay:
001a28 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001a29 93b0 2825                 	sts pulse1_pattern_delay_rows, r27
001a2b d0f7                      	rcall sound_driver_channel0_increment_offset
001a2c c10a                      	rjmp sound_driver_channel0_end
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change:
001a2d 9220 2829                 	sts pulse1_volume_macro, zero //reset all macro addresses
001a2f 9220 282a                 	sts pulse1_volume_macro+1, zero
001a31 9220 282e                 	sts pulse1_arpeggio_macro, zero
001a33 9220 282f                 	sts pulse1_arpeggio_macro+1, zero
001a35 9220 2836                 	sts pulse1_pitch_macro, zero
001a37 9220 2837                 	sts pulse1_pitch_macro+1, zero
001a39 9220 283c                 	sts pulse1_hi_pitch_macro, zero
001a3b 9220 283d                 	sts pulse1_hi_pitch_macro+1, zero
001a3d 9220 2841                 	sts pulse1_duty_macro, zero
001a3f 9220 2842                 	sts pulse1_duty_macro+1, zero
001a41 9220 2834                 	sts pulse1_total_pitch_offset, zero //reset the pitch offset
001a43 9220 2835                 	sts pulse1_total_pitch_offset+1, zero
001a45 9220 283b                 	sts pulse1_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001a47 9631                      	adiw Z, 1 //point to the byte next to the flag
001a48 91b4                      	lpm r27, Z //store the instrument offset into r27
001a49 e9ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
001a4a e1f1                      	ldi ZH, HIGH(instruments)
001a4b 0feb                      	add ZL, r27 //point Z to offsetted instrument
001a4c 1df2                      	adc ZH, zero
001a4d 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001a4e 1fff                      	rol ZH
001a4f 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001a50 91b4                      	lpm r27, Z
                                 
001a51 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001a52 1fbb                      	rol r27
001a53 2fea                      	mov ZL, r26
001a54 2ffb                      	mov ZH, r27
001a55 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001a56 9632                      	adiw Z, 2 //point Z to the address of the macro
001a57 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel0_instrument_change_macro_loop:
001a58 95aa                      	dec r26
001a59 f019                      	breq sound_driver_channel0_instrument_change_exit
001a5a 95b6                      	lsr r27
001a5b f078                      	brcs sound_driver_channel0_instrument_change_load_macro
001a5c cffb                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_exit:
001a5d e0a3                      	ldi r26, 0x03
001a5e e0b2                      	ldi r27, 0x02
001a5f 93b0 282b                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
001a61 93a0 2830                 	sts pulse1_arpeggio_macro_offset, r26
001a63 93b0 2838                 	sts pulse1_pitch_macro_offset, r27
001a65 93b0 283e                 	sts pulse1_hi_pitch_macro_offset, r27
001a67 93b0 2843                 	sts pulse1_duty_macro_offset, r27
001a69 d0c3                      	rcall sound_driver_channel0_increment_offset_twice
001a6a cde8                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_load_macro:
001a6b 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001a6c 91d5                      	lpm r29, Z+
                                 
001a6d 30a5                      	cpi r26, 5
001a6e f039                      	breq sound_driver_channel0_instrument_change_load_macro_volume
001a6f 30a4                      	cpi r26, 4
001a70 f079                      	breq sound_driver_channel0_instrument_change_load_macro_arpeggio
001a71 30a3                      	cpi r26, 3
001a72 f0d9                      	breq sound_driver_channel0_instrument_change_load_macro_pitch
001a73 30a2                      	cpi r26, 2
001a74 f159                      	breq sound_driver_channel0_instrument_change_load_macro_hi_pitch
001a75 c03c                      	rjmp sound_driver_channel0_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel0_instrument_change_load_macro_volume:
001a76 93c0 2829                 	sts pulse1_volume_macro, r28
001a78 93d0 282a                 	sts pulse1_volume_macro+1, r29
001a7a d041                      	rcall sound_driver_channel0_instrument_change_read_header
001a7b 93c0 282d                 	sts pulse1_volume_macro_release, r28
001a7d 93d0 282c                 	sts pulse1_volume_macro_loop, r29
001a7f cfd8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 	
                                 sound_driver_channel0_instrument_change_load_macro_arpeggio:
001a80 93c0 282e                 	sts pulse1_arpeggio_macro, r28
001a82 93d0 282f                 	sts pulse1_arpeggio_macro+1, r29
001a84 9220 2865                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001a86 9220 2866                 	sts pulse1_fx_Qxy_target+1, zero
001a88 9220 286c                 	sts pulse1_fx_Rxy_target, zero
001a8a 9220 286d                 	sts pulse1_fx_Rxy_target+1, zero
001a8c d03a                      	rcall sound_driver_channel0_instrument_change_read_header_arpeggio
001a8d cfca                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_pitch:
001a8e 93c0 2836                 	sts pulse1_pitch_macro, r28
001a90 93d0 2837                 	sts pulse1_pitch_macro+1, r29
001a92 9220 2865                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001a94 9220 2866                 	sts pulse1_fx_Qxy_target+1, zero
001a96 9220 286c                 	sts pulse1_fx_Rxy_target, zero
001a98 9220 286d                 	sts pulse1_fx_Rxy_target+1, zero
001a9a d021                      	rcall sound_driver_channel0_instrument_change_read_header
001a9b 93c0 283a                 	sts pulse1_pitch_macro_release, r28
001a9d 93d0 2839                 	sts pulse1_pitch_macro_loop, r29
001a9f cfb8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_hi_pitch:
001aa0 93c0 283c                 	sts pulse1_hi_pitch_macro, r28
001aa2 93d0 283d                 	sts pulse1_hi_pitch_macro+1, r29
001aa4 9220 2865                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001aa6 9220 2866                 	sts pulse1_fx_Qxy_target+1, zero
001aa8 9220 286c                 	sts pulse1_fx_Rxy_target, zero
001aaa 9220 286d                 	sts pulse1_fx_Rxy_target+1, zero
001aac d00f                      	rcall sound_driver_channel0_instrument_change_read_header
001aad 93c0 2840                 	sts pulse1_hi_pitch_macro_release, r28
001aaf 93d0 283f                 	sts pulse1_hi_pitch_macro_loop, r29
001ab1 cfa6                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_duty:
001ab2 93c0 2841                 	sts pulse1_duty_macro, r28
001ab4 93d0 2842                 	sts pulse1_duty_macro+1, r29
001ab6 d005                      	rcall sound_driver_channel0_instrument_change_read_header
001ab7 93c0 2845                 	sts pulse1_duty_macro_release, r28
001ab9 93d0 2844                 	sts pulse1_duty_macro_loop, r29
001abb cf9c                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_read_header:
001abc 93ef                      	push ZL
001abd 93ff                      	push ZH
001abe 2fec                      	mov ZL, r28
001abf 2ffd                      	mov ZH, r29
001ac0 0fee                      	lsl ZL
001ac1 1fff                      	rol ZH
001ac2 91c5                      	lpm r28, Z+
001ac3 91d4                      	lpm r29, Z
001ac4 91ff                      	pop ZH
001ac5 91ef                      	pop ZL
001ac6 9508                      	ret
                                 
                                 sound_driver_channel0_instrument_change_read_header_arpeggio:
001ac7 93ef                      	push ZL
001ac8 93ff                      	push ZH
001ac9 2fec                      	mov ZL, r28
001aca 2ffd                      	mov ZH, r29
001acb 0fee                      	lsl ZL
001acc 1fff                      	rol ZH
001acd 91c5                      	lpm r28, Z+
001ace 91d5                      	lpm r29, Z+
001acf 93c0 2832                 	sts pulse1_arpeggio_macro_release, r28
001ad1 93d0 2831                 	sts pulse1_arpeggio_macro_loop, r29
001ad3 91c4                      	lpm r28, Z
001ad4 93c0 2833                 	sts pulse1_arpeggio_macro_mode, r28
001ad6 91ff                      	pop ZH
001ad7 91ef                      	pop ZL
001ad8 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel0_release:
                                 sound_driver_channel0_release_volume:
001ad9 91b0 282d                 	lds r27, pulse1_volume_macro_release
001adb 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001adc f019                      	breq sound_driver_channel0_release_arpeggio //if the macro has no release flag, check the next macro
001add 95b3                      	inc r27
001ade 93b0 282b                 	sts pulse1_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel0_release_arpeggio:
001ae0 91b0 2832                 	lds r27, pulse1_arpeggio_macro_release
001ae2 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001ae3 f019                      	breq sound_driver_channel0_release_pitch
001ae4 95b3                      	inc r27
001ae5 93b0 2830                 	sts pulse1_arpeggio_macro_offset, r27
                                 sound_driver_channel0_release_pitch:
001ae7 91b0 283a                 	lds r27, pulse1_pitch_macro_release
001ae9 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001aea f019                      	breq sound_driver_channel0_release_hi_pitch
001aeb 95b3                      	inc r27
001aec 93b0 2838                 	sts pulse1_pitch_macro_offset, r27
                                 sound_driver_channel0_release_hi_pitch:
001aee 91b0 2840                 	lds r27, pulse1_hi_pitch_macro_release
001af0 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001af1 f019                      	breq sound_driver_channel0_release_duty
001af2 95b3                      	inc r27
001af3 93b0 283e                 	sts pulse1_hi_pitch_macro_offset, r27
                                 sound_driver_channel0_release_duty:
001af5 91b0 2845                 	lds r27, pulse1_duty_macro_release
001af7 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001af8 f019                      	breq sound_driver_channel0_release_exit
001af9 95b3                      	inc r27
001afa 93b0 2843                 	sts pulse1_duty_macro_offset, r27
                                 sound_driver_channel0_release_exit:
001afc d026                      	rcall sound_driver_channel0_increment_offset
001afd cd55                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_next_pattern:
001afe 91e0 2819                 	lds ZL, song_frames
001b00 91f0 281a                 	lds ZH, song_frames+1
001b02 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001b04 91b0 281c                 	lds r27, song_frame_offset+1
001b06 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
001b07 93a0 281b                 	sts song_frame_offset, r26
001b09 93b0 281c                 	sts song_frame_offset+1, r27
                                 
001b0b 91c0 281d                 	lds r28, song_size
001b0d 91d0 281e                 	lds r29, song_size+1
001b0f 17ac                      	cp r26, r28
001b10 07bd                      	cpc r27, r29
001b11 f010                      	brlo sound_driver_channel0_next_pattern_exists
001b12 940c 30bb                 	jmp sound_driver_exit
                                 
                                 sound_driver_channel0_next_pattern_exists:
001b14 0fea                      	add ZL, r26
001b15 1ffb                      	adc ZH, r27
                                 
001b16 91a5                      	lpm r26, Z+ //load the address of the next pattern
001b17 91b4                      	lpm r27, Z
001b18 0faa                      	lsl r26
001b19 1fbb                      	rol r27
001b1a 93a0 2823                 	sts pulse1_pattern, r26
001b1c 93b0 2824                 	sts pulse1_pattern+1, r27
                                 
001b1e 9220 2827                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001b20 9220 2828                 	sts pulse1_pattern_offset+1, zero
001b22 cd30                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_increment_offset:
001b23 91e0 2827                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
001b25 91f0 2828                 	lds ZH, pulse1_pattern_offset+1
001b27 9631                      	adiw Z, 1
001b28 93e0 2827                 	sts pulse1_pattern_offset, ZL
001b2a 93f0 2828                 	sts pulse1_pattern_offset+1, ZH
001b2c 9508                      	ret
                                 
                                 sound_driver_channel0_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001b2d 91e0 2827                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
001b2f 91f0 2828                 	lds ZH, pulse1_pattern_offset+1
001b31 9632                      	adiw Z, 2 //increment the pointer twice
001b32 93e0 2827                 	sts pulse1_pattern_offset, ZL
001b34 93f0 2828                 	sts pulse1_pattern_offset+1, ZH
001b36 9508                      	ret
                                 
                                 sound_driver_channel0_end:
                                 sound_driver_channel0_check_Sxx_invalid:
001b37 efbf                      	ldi r27, 0xFF
001b38 91a0 2873                 	lds r26, pulse1_fx_Sxx_post
001b3a 15a2                      	cp r26, zero //check if routine was called from calculate_delays due to invalid Sxx/Gxx
001b3b f419                      	brne sound_driver_channel0_check_Gxx_invalid
001b3c 93b0 2873                 	sts pulse1_fx_Sxx_post, r27
001b3e 9508                      	ret
                                 sound_driver_channel0_check_Gxx_invalid:
001b3f 91a0 2861                 	lds r26, pulse1_fx_Gxx_post
001b41 15a2                      	cp r26, zero
001b42 f419                      	brne sound_driver_channel1
001b43 93b0 2861                 	sts pulse1_fx_Gxx_post, r27
001b45 9508                      	ret
                                 
                                 
                                 sound_driver_channel1:
001b46 91a0 2876                 	lds r26, pulse2_pattern_delay_rows
001b48 91b0 2877                 	lds r27, pulse2_pattern_delay_frames
                                 sound_driver_channel1_decrement_frame_delay:
001b4a 95ba                      	dec r27
001b4b 93b0 2877                 	sts pulse2_pattern_delay_frames, r27
                                 
001b4d 9610                      	adiw r27:r26, 0
001b4e f009                      	breq sound_driver_channel1_main //if the pattern delay is 0, proceed with sound driver procedures
001b4f c2d7                      	rjmp sound_driver_channel1_end //if the pattern delay is not 0, end routine
                                 
                                 sound_driver_channel1_main:
001b50 91e0 2874                 	lds ZL, pulse2_pattern //current pattern for pulse 2
001b52 91f0 2875                 	lds ZH, pulse2_pattern+1
001b54 91a0 2878                 	lds r26, pulse2_pattern_offset //current offset in the pattern for pulse 2
001b56 91b0 2879                 	lds r27, pulse2_pattern_offset+1
001b58 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001b59 1ffb                      	adc ZH, r27
001b5a 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel1_check_if_note: //check if data is a note (0x00 - 0x56)
001b5b 35b7                      	cpi r27, 0x57
001b5c f408                      	brsh sound_driver_channel1_check_if_volume
001b5d c17c                      	rjmp sound_driver_channel1_note
                                 sound_driver_channel1_check_if_volume: //check if data is volume (0x57-0x66)
001b5e 36b7                      	cpi r27, 0x67
001b5f f408                      	brsh sound_driver_channel1_check_if_delay
001b60 c1ba                      	rjmp sound_driver_channel1_volume
                                 sound_driver_channel1_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001b61 3eb3                      	cpi r27, 0xE3
001b62 f408                      	brsh sound_driver_channel1_check_if_instrument
001b63 c1c1                      	rjmp sound_driver_channel1_delay
                                 sound_driver_channel1_check_if_instrument: //check for instrument flag (0xE3)
001b64 f409                      	brne sound_driver_channel1_check_if_release
001b65 c1c4                      	rjmp sound_driver_channel1_instrument_change 
                                 sound_driver_channel1_check_if_release: //check for note release flag (0xE4)
001b66 3eb4                      	cpi r27, 0xE4
001b67 f409                      	brne sound_driver_channel1_check_if_end
001b68 c26d                      	rjmp sound_driver_channel1_release
                                 sound_driver_channel1_check_if_end:
001b69 3fbf                      	cpi r27, 0xFF
001b6a f409                      	brne sound_driver_channel1_check_if_fx
001b6b c28f                      	rjmp sound_driver_channel1_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel1_check_if_fx: //fx flags (0xE5 - 0xFE)
001b6c 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001b6d 91a4                      	lpm r26, Z //load the fx data into r26
001b6e d2ae                      	rcall sound_driver_channel1_increment_offset_twice
                                 
001b6f 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001b70 edea                      	ldi ZL, LOW(channel1_fx << 1) //load in note table
001b71 e6f1                      	ldi ZH, HIGH(channel1_fx << 1)
001b72 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001b73 0feb                      	add ZL, r27 //add offset
001b74 1df2                      	adc ZH, zero
001b75 91c5                      	lpm r28, Z+ //load address bytes
001b76 91d4                      	lpm r29, Z
001b77 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001b78 2ffd                      	mov ZH, r29
001b79 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel1_fx_0xy:
001b7a 93a0 2897                 	sts pulse2_fx_0xy_sequence, r26
001b7c 9220 2898                 	sts pulse2_fx_0xy_sequence+1, zero
001b7e cfd1                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel1_fx_1xx:
001b7f 9220 289d                 	sts pulse2_fx_2xx, zero //turn off any 2xx pitch slide down
001b81 9220 289e                 	sts pulse2_fx_2xx+1, zero
001b83 9220 2897                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
001b85 9220 2898                 	sts pulse2_fx_0xy_sequence+1, zero
001b87 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001b88 937f                      	push r23
001b89 2f6a                      	mov r22, r26 //store the rate into r22
001b8a eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001b8b 9f67                      	mul r22, r23
001b8c 917f                      	pop r23
001b8d 916f                      	pop r22
                                 
001b8e 9416                      	lsr r1 //shift out the fractional bits
001b8f 9407                      	ror r0
001b90 9416                      	lsr r1
001b91 9407                      	ror r0
001b92 9416                      	lsr r1
001b93 9407                      	ror r0
001b94 9416                      	lsr r1
001b95 9407                      	ror r0
001b96 9200 2899                 	sts pulse2_fx_1xx, r0
001b98 9210 289a                 	sts pulse2_fx_1xx+1, r1
001b9a cfb5                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel1_fx_2xx:
001b9b 9220 2899                 	sts pulse2_fx_1xx, zero //turn off any 1xx pitch slide down
001b9d 9220 289a                 	sts pulse2_fx_1xx+1, zero
001b9f 9220 2897                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
001ba1 9220 2898                 	sts pulse2_fx_0xy_sequence+1, zero
001ba3 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001ba4 937f                      	push r23
001ba5 2f6a                      	mov r22, r26 //store the rate into r22
001ba6 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001ba7 9f67                      	mul r22, r23
001ba8 917f                      	pop r23
001ba9 916f                      	pop r22
                                 
001baa 9416                      	lsr r1 //shift out the fractional bits
001bab 9407                      	ror r0
001bac 9416                      	lsr r1
001bad 9407                      	ror r0
001bae 9416                      	lsr r1
001baf 9407                      	ror r0
001bb0 9416                      	lsr r1
001bb1 9407                      	ror r0
001bb2 9200 289d                 	sts pulse2_fx_2xx, r0
001bb4 9210 289e                 	sts pulse2_fx_2xx+1, r1
001bb6 cf99                      	rjmp sound_driver_channel1_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel1_fx_3xx:
001bb7 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001bb8 937f                      	push r23
001bb9 2f6a                      	mov r22, r26 //store the rate into r22
001bba eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001bbb 9f67                      	mul r22, r23
001bbc 917f                      	pop r23
001bbd 916f                      	pop r22
                                 
001bbe 9416                      	lsr r1 //shift out the fractional bits
001bbf 9407                      	ror r0
001bc0 9416                      	lsr r1
001bc1 9407                      	ror r0
001bc2 9416                      	lsr r1
001bc3 9407                      	ror r0
001bc4 9416                      	lsr r1
001bc5 9407                      	ror r0
001bc6 9200 28a5                 	sts pulse2_fx_3xx_speed, r0
001bc8 9210 28a6                 	sts pulse2_fx_3xx_speed+1, r1
                                 
001bca 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001bcb c001                      	rjmp sound_driver_channel1_fx_3xx_enabled
001bcc cf83                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_3xx_enabled:
001bcd 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001bcf 91b0 0a9d                 	lds r27, TCB1_CCMPH
001bd1 93a0 28a1                 	sts pulse2_fx_3xx_start, r26
001bd3 93b0 28a2                 	sts pulse2_fx_3xx_start+1, r27
                                 
001bd5 9220 28a7                 	sts pulse2_fx_3xx_total_offset, zero
001bd7 9220 28a8                 	sts pulse2_fx_3xx_total_offset+1, zero
001bd9 cf76                      	rjmp sound_driver_channel1_main
                                 
                                 //VIBRATO
                                 sound_driver_channel1_fx_4xy:
001bda 2fba                      	mov r27, r26
001bdb 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001bdc 95a2                      	swap r26
001bdd 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001bde 93a0 28a9                 	sts pulse2_fx_4xy_speed, r26
001be0 93b0 28aa                 	sts pulse2_fx_4xy_depth, r27
001be2 9220 28ab                 	sts pulse2_fx_4xy_phase, zero //reset the phase to 0
001be4 cf6b                      	rjmp sound_driver_channel1_main
                                 
                                 //TREMELO
                                 sound_driver_channel1_fx_7xy:
001be5 2fba                      	mov r27, r26
001be6 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001be7 95a2                      	swap r26
001be8 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001be9 93a0 28ac                 	sts pulse2_fx_7xy_speed, r26
001beb 93b0 28ad                 	sts pulse2_fx_7xy_depth, r27
001bed 9220 28ae                 	sts pulse2_fx_7xy_phase, zero //reset the phase to 0
001bef 9220 28af                 	sts pulse2_fx_7xy_value, zero //reset the tremelo value
001bf1 cf5e                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel1_fx_Axy:
001bf2 93a0 28b0                 	sts pulse2_fx_Axy, r26
001bf4 cf5b                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel1_fx_Bxx:
001bf5 93a0 2820                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001bf7 cf58                      	rjmp sound_driver_channel1_main
                                 
                                 //HALT
                                 sound_driver_channel1_fx_Cxx:
001bf8 93b0 2821                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001bfa cf55                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel1_fx_Dxx:
001bfb 93b0 2822                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001bfd cf52                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME
                                 sound_driver_channel1_fx_Exx:
001bfe 91b0 2808                 	lds r27, pulse2_param
001c00 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
001c01 2bba                      	or r27, r26 //move new VVVV bits into pulse2_param
001c02 93b0 2808                 	sts pulse2_param, r27
001c04 6092                      	sbr pulse_channel_flags, 2
001c05 cf4a                      	rjmp sound_driver_channel1_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel1_fx_Fxx:
001c06 93a0 281f                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001c08 cf47                      	rjmp sound_driver_channel1_main
                                 
                                 //DELAY
                                 sound_driver_channel1_fx_Gxx:
001c09 15a2                      	cp r26, zero
001c0a f051                      	breq sound_driver_channel1_fx_Gxx_invalid
001c0b 91b0 281f                 	lds r27, song_speed
001c0d 17ab                      	cp r26, r27
001c0e f430                      	brsh sound_driver_channel1_fx_Gxx_invalid
001c0f 93a0 28b1                 	sts pulse2_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001c11 e0b1                      	ldi r27, 0x01
001c12 93b0 2876                 	sts pulse2_pattern_delay_rows, r27
001c14 c221                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Gxx_invalid:
001c15 cf3a                      	rjmp sound_driver_channel1_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel1_fx_Hxy: //hardware sweep up
001c16 cf39                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixy: //hardware sweep down
001c17 cf38                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Hxx: //FDS modulation depth
001c18 cf37                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixx: //FDS modulation speed
001c19 cf36                      	rjmp sound_driver_channel1_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel1_fx_Pxx:
001c1a 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001c1b 937f                      	push r23
001c1c 2f6a                      	mov r22, r26
001c1d eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001c1e 0367                      	mulsu r22, r23
001c1f 917f                      	pop r23
001c20 916f                      	pop r22
001c21 9416                      	lsr r1 //shift out the fractional bits
001c22 9407                      	ror r0
001c23 9416                      	lsr r1
001c24 9407                      	ror r0
001c25 9416                      	lsr r1
001c26 9407                      	ror r0
001c27 9416                      	lsr r1
001c28 9407                      	ror r0
001c29 fe13                      	sbrs r1, 3 //check if result was a negative number
001c2a c002                      	rjmp sound_driver_channel1_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel1_fx_Pxx_negative:
001c2b efb0                      	ldi r27, 0xF0
001c2c 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel1_fx_Pxx_store:
001c2d 9200 28b3                 	sts pulse2_fx_Pxx_total, r0
001c2f 9210 28b4                 	sts pulse2_fx_Pxx_total+1, r1
001c31 cf1e                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel1_fx_Qxy:
                                 sound_driver_channel1_fx_Qxy_check_arpeggio_macro:
001c32 91e0 287f                 	lds ZL, pulse2_arpeggio_macro
001c34 91f0 2880                 	lds ZH, pulse2_arpeggio_macro+1
001c36 9630                      	adiw Z, 0
001c37 f009                      	breq sound_driver_channel1_fx_Qxy_check_pitch_macro
001c38 cf17                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_pitch_macro:
001c39 91e0 2887                 	lds ZL, pulse2_pitch_macro
001c3b 91f0 2888                 	lds ZH, pulse2_pitch_macro+1
001c3d 9630                      	adiw Z, 0
001c3e f009                      	breq sound_driver_channel1_fx_Qxy_check_hi_pitch_macro
001c3f cf10                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_hi_pitch_macro:
001c40 91e0 288d                 	lds ZL, pulse2_hi_pitch_macro
001c42 91f0 288e                 	lds ZH, pulse2_hi_pitch_macro+1
001c44 9630                      	adiw Z, 0
001c45 f009                      	breq sound_driver_channel1_fx_Qxy_process
001c46 cf09                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_process:
001c47 2fba                      	mov r27, r26 //copy fx parameters into r27
001c48 70bf                      	andi r27, 0x0F //mask note index offset
001c49 91c0 28b5                 	lds r28, pulse2_fx_Qxy_target_note //load current note index
001c4b 0fbc                      	add r27, r28
001c4c 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001c4d f008                      	brlo sound_driver_channel1_fx_Qxy_process_continue
001c4e e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel1_fx_Qxy_process_continue:
001c4f 93b0 28b5                 	sts pulse2_fx_Qxy_target_note, r27
001c51 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001c52 e0f0                      	ldi ZH, HIGH(note_table << 1)
001c53 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001c54 0feb                      	add ZL, r27 //add offset
001c55 1df2                      	adc ZH, zero
001c56 91c5                      	lpm r28, Z+ //load bytes
001c57 91d4                      	lpm r29, Z
001c58 93c0 28b6                 	sts pulse2_fx_Qxy_target, r28 //load the LOW bits for the target period
001c5a 93d0 28b7                 	sts pulse2_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel1_fx_Qxy_process_speed:
001c5c 95a2                      	swap r26
001c5d 70af                      	andi r26, 0x0F //mask effect speed
001c5e 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001c5f 95a3                      	inc r26 //increment the speed by 1
                                 
001c60 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001c61 937f                      	push r23
001c62 2f6a                      	mov r22, r26 //store the speed data into r27
001c63 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001c64 9f67                      	mul r22, r23
001c65 917f                      	pop r23
001c66 916f                      	pop r22
                                 
001c67 9416                      	lsr r1 //shift out the fractional bits
001c68 9407                      	ror r0
001c69 9416                      	lsr r1
001c6a 9407                      	ror r0
001c6b 9416                      	lsr r1
001c6c 9407                      	ror r0
001c6d 9416                      	lsr r1
001c6e 9407                      	ror r0
                                 
001c6f 9200 28b8                 	sts pulse2_fx_Qxy_speed, r0 //store the effect speed
001c71 9210 28b9                 	sts pulse2_fx_Qxy_speed+1, r1
001c73 cedc                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel1_fx_Rxy:
                                 sound_driver_channel1_fx_Rxy_check_arpeggio_macro:
001c74 91e0 287f                 	lds ZL, pulse2_arpeggio_macro
001c76 91f0 2880                 	lds ZH, pulse2_arpeggio_macro+1
001c78 9630                      	adiw Z, 0
001c79 f009                      	breq sound_driver_channel1_fx_Rxy_check_pitch_macro
001c7a ced5                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_pitch_macro:
001c7b 91e0 2887                 	lds ZL, pulse2_pitch_macro
001c7d 91f0 2888                 	lds ZH, pulse2_pitch_macro+1
001c7f 9630                      	adiw Z, 0
001c80 f009                      	breq sound_driver_channel1_fx_Rxy_check_hi_pitch_macro
001c81 cece                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_hi_pitch_macro:
001c82 91e0 288d                 	lds ZL, pulse2_hi_pitch_macro
001c84 91f0 288e                 	lds ZH, pulse2_hi_pitch_macro+1
001c86 9630                      	adiw Z, 0
001c87 f009                      	breq sound_driver_channel1_fx_Rxy_process
001c88 cec7                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_process:
001c89 2fba                      	mov r27, r26 //copy fx parameters into r27
001c8a 70bf                      	andi r27, 0x0F //mask note index offset
001c8b 91c0 28bc                 	lds r28, pulse2_fx_Rxy_target_note //load current note index
001c8d 1bcb                      	sub r28, r27
001c8e f408                      	brcc sound_driver_channel1_fx_Rxy_process_continue
001c8f e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel1_fx_Rxy_process_continue:
001c90 93c0 28bc                 	sts pulse2_fx_Rxy_target_note, r28
001c92 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001c93 e0f0                      	ldi ZH, HIGH(note_table << 1)
001c94 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001c95 0fec                      	add ZL, r28 //add offset
001c96 1df2                      	adc ZH, zero
001c97 91c5                      	lpm r28, Z+ //load bytes
001c98 91d4                      	lpm r29, Z
001c99 93c0 28bd                 	sts pulse2_fx_Rxy_target, r28 //load the LOW bits for the target period
001c9b 93d0 28be                 	sts pulse2_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel1_fx_Rxy_process_speed:
001c9d 95a2                      	swap r26
001c9e 70af                      	andi r26, 0x0F //mask effect speed
001c9f 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001ca0 95a3                      	inc r26 //increment the speed by 1
                                 
001ca1 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001ca2 937f                      	push r23
001ca3 2f6a                      	mov r22, r26 //store the speed data into r27
001ca4 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001ca5 9f67                      	mul r22, r23
001ca6 917f                      	pop r23
001ca7 916f                      	pop r22
                                 
001ca8 9416                      	lsr r1 //shift out the fractional bits
001ca9 9407                      	ror r0
001caa 9416                      	lsr r1
001cab 9407                      	ror r0
001cac 9416                      	lsr r1
001cad 9407                      	ror r0
001cae 9416                      	lsr r1
001caf 9407                      	ror r0
                                 
001cb0 9200 28bf                 	sts pulse2_fx_Rxy_speed, r0 //store the effect speed
001cb2 9210 28c0                 	sts pulse2_fx_Rxy_speed+1, r1
001cb4 ce9b                      	rjmp sound_driver_channel1_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel1_fx_Sxx:
001cb5 15a2                      	cp r26, zero
001cb6 f051                      	breq sound_driver_channel1_fx_Sxx_invalid
001cb7 91b0 281f                 	lds r27, song_speed
001cb9 17ab                      	cp r26, r27
001cba f430                      	brsh sound_driver_channel1_fx_Sxx_invalid
001cbb 93a0 28c3                 	sts pulse2_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001cbd e0b1                      	ldi r27, 0x01
001cbe 93b0 2876                 	sts pulse2_pattern_delay_rows, r27
001cc0 c175                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Sxx_invalid:
001cc1 ce8e                      	rjmp sound_driver_channel1_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel1_fx_Vxx:
001cc2 eae2                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
001cc3 e6f1                      	ldi ZH, HIGH(sequences << 1)
001cc4 0fea                      	add ZL, r26 //offset the pointer
001cc5 1df2                      	adc ZH, zero
                                 
001cc6 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
001cc7 95a7                      	ror r26
001cc8 95a7                      	ror r26
001cc9 91b0 2808                 	lds r27, pulse2_param //load r27 with pulse2_param (register $4000)
001ccb 2fcb                      	mov r28, r27 //store a copy of pulse2_param into r28
001ccc 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
001ccd 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
001cce c001                      	rjmp sound_driver_channel1_fx_Vxx_store
001ccf ce80                      	rjmp sound_driver_channel1_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel1_fx_Vxx_store:
001cd0 90a4                      	lpm pulse2_sequence, Z //store the sequence
                                 
001cd1 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
001cd2 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
001cd3 93c0 2808                 	sts pulse2_param, r28
001cd5 ce7a                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_Wxx: //DPCM sample speed
001cd6 ce79                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Xxx: //DPCM sample retrigger
001cd7 ce78                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Yxx: //DPCM sample offset
001cd8 ce77                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Zxx: //DPCM sample delta counter
001cd9 ce76                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 sound_driver_channel1_note:
001cda 93b0 280f                 	sts pulse2_note, r27 //store the note index
001cdc 93b0 28b5                 	sts pulse2_fx_Qxy_target_note, r27
001cde 93b0 28bc                 	sts pulse2_fx_Rxy_target_note, r27
001ce0 e0a3                      	ldi r26, 0x03
001ce1 e0b2                      	ldi r27, 0x02
001ce2 93b0 287c                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
001ce4 93a0 2881                 	sts pulse2_arpeggio_macro_offset, r26
001ce6 93b0 2889                 	sts pulse2_pitch_macro_offset, r27
001ce8 93b0 288f                 	sts pulse2_hi_pitch_macro_offset, r27
001cea 93b0 2894                 	sts pulse2_duty_macro_offset, r27
001cec 9220 2885                 	sts pulse2_total_pitch_offset, zero //reset the pitch and hi pitch offset
001cee 9220 2886                 	sts pulse2_total_pitch_offset+1, zero
001cf0 9220 288c                 	sts pulse2_total_hi_pitch_offset, zero
001cf2 9220 289b                 	sts pulse2_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001cf4 9220 289c                 	sts pulse2_fx_1xx_total+1, zero
001cf6 9220 289f                 	sts pulse2_fx_2xx_total, zero
001cf8 9220 28a0                 	sts pulse2_fx_2xx_total+1, zero
001cfa 9220 28a7                 	sts pulse2_fx_3xx_total_offset, zero //reset 3xx offset
001cfc 9220 28a8                 	sts pulse2_fx_3xx_total_offset+1, zero
001cfe 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001d00 91b0 0a9d                 	lds r27, TCB1_CCMPH
001d02 93a0 28a1                 	sts pulse2_fx_3xx_start, r26
001d04 93b0 28a2                 	sts pulse2_fx_3xx_start+1, r27
001d06 9220 2809                 	sts pulse2_sweep_param, zero //reset any sweep effect
001d08 6093                      	sbr pulse_channel_flags, 3 //set reload flag
001d09 9220 28b6                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001d0b 9220 28b7                 	sts pulse2_fx_Qxy_target+1, zero
001d0d 9220 28ba                 	sts pulse2_fx_Qxy_total_offset, zero
001d0f 9220 28bb                 	sts pulse2_fx_Qxy_total_offset+1, zero
001d11 9220 28bd                 	sts pulse2_fx_Rxy_target, zero
001d13 9220 28be                 	sts pulse2_fx_Rxy_target+1, zero
001d15 9220 28c1                 	sts pulse2_fx_Rxy_total_offset, zero
001d17 9220 28c2                 	sts pulse2_fx_Rxy_total_offset+1, zero
001d19 d0f9                      	rcall sound_driver_channel1_increment_offset
001d1a ce35                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_volume:
001d1b 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest note value, which is 0x56
001d1c 91a0 2808                 	lds r26, pulse2_param
001d1e 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001d1f 2bab                      	or r26, r27 //move new VVVV bits into pulse2_param
001d20 93a0 2808                 	sts pulse2_param, r26
001d22 6092                      	sbr pulse_channel_flags, 2
001d23 d0ef                      	rcall sound_driver_channel1_increment_offset
001d24 ce2b                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_delay:
001d25 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001d26 93b0 2876                 	sts pulse2_pattern_delay_rows, r27
001d28 d0ea                      	rcall sound_driver_channel1_increment_offset
001d29 c0fd                      	rjmp sound_driver_channel1_end
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change:
001d2a 9220 287a                 	sts pulse2_volume_macro, zero //reset all macro addresses
001d2c 9220 287b                 	sts pulse2_volume_macro+1, zero
001d2e 9220 287f                 	sts pulse2_arpeggio_macro, zero
001d30 9220 2880                 	sts pulse2_arpeggio_macro+1, zero
001d32 9220 2887                 	sts pulse2_pitch_macro, zero
001d34 9220 2888                 	sts pulse2_pitch_macro+1, zero
001d36 9220 288d                 	sts pulse2_hi_pitch_macro, zero
001d38 9220 288e                 	sts pulse2_hi_pitch_macro+1, zero
001d3a 9220 2892                 	sts pulse2_duty_macro, zero
001d3c 9220 2893                 	sts pulse2_duty_macro+1, zero
001d3e 9220 2885                 	sts pulse2_total_pitch_offset, zero //reset the pitch offset
001d40 9220 2886                 	sts pulse2_total_pitch_offset+1, zero
001d42 9220 288c                 	sts pulse2_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001d44 9631                      	adiw Z, 1 //point to the byte next to the flag
001d45 91b4                      	lpm r27, Z //store the instrument offset into r27
001d46 e9ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
001d47 e1f1                      	ldi ZH, HIGH(instruments)
001d48 0feb                      	add ZL, r27 //point Z to offsetted instrument
001d49 1df2                      	adc ZH, zero
001d4a 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001d4b 1fff                      	rol ZH
001d4c 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001d4d 91b4                      	lpm r27, Z
                                 
001d4e 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001d4f 1fbb                      	rol r27
001d50 2fea                      	mov ZL, r26
001d51 2ffb                      	mov ZH, r27
001d52 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001d53 9632                      	adiw Z, 2 //point Z to the address of the macro
001d54 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel1_instrument_change_macro_loop:
001d55 95aa                      	dec r26
001d56 f019                      	breq sound_driver_channel1_instrument_change_exit
001d57 95b6                      	lsr r27
001d58 f078                      	brcs sound_driver_channel1_instrument_change_load_macro
001d59 cffb                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_exit:
001d5a e0a3                      	ldi r26, 0x03
001d5b e0b2                      	ldi r27, 0x02
001d5c 93b0 287c                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
001d5e 93a0 2881                 	sts pulse2_arpeggio_macro_offset, r26
001d60 93b0 2889                 	sts pulse2_pitch_macro_offset, r27
001d62 93b0 288f                 	sts pulse2_hi_pitch_macro_offset, r27
001d64 93b0 2894                 	sts pulse2_duty_macro_offset, r27
001d66 d0b6                      	rcall sound_driver_channel1_increment_offset_twice
001d67 cde8                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_load_macro:
001d68 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001d69 91d5                      	lpm r29, Z+
                                 
001d6a 30a5                      	cpi r26, 5
001d6b f039                      	breq sound_driver_channel1_instrument_change_load_macro_volume
001d6c 30a4                      	cpi r26, 4
001d6d f079                      	breq sound_driver_channel1_instrument_change_load_macro_arpeggio
001d6e 30a3                      	cpi r26, 3
001d6f f0d9                      	breq sound_driver_channel1_instrument_change_load_macro_pitch
001d70 30a2                      	cpi r26, 2
001d71 f159                      	breq sound_driver_channel1_instrument_change_load_macro_hi_pitch
001d72 c03c                      	rjmp sound_driver_channel1_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel1_instrument_change_load_macro_volume:
001d73 93c0 287a                 	sts pulse2_volume_macro, r28
001d75 93d0 287b                 	sts pulse2_volume_macro+1, r29
001d77 d041                      	rcall sound_driver_channel1_instrument_change_read_header
001d78 93c0 287e                 	sts pulse2_volume_macro_release, r28
001d7a 93d0 287d                 	sts pulse2_volume_macro_loop, r29
001d7c cfd8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 	
                                 sound_driver_channel1_instrument_change_load_macro_arpeggio:
001d7d 93c0 287f                 	sts pulse2_arpeggio_macro, r28
001d7f 93d0 2880                 	sts pulse2_arpeggio_macro+1, r29
001d81 9220 28b6                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001d83 9220 28b7                 	sts pulse2_fx_Qxy_target+1, zero
001d85 9220 28bd                 	sts pulse2_fx_Rxy_target, zero
001d87 9220 28be                 	sts pulse2_fx_Rxy_target+1, zero
001d89 d03a                      	rcall sound_driver_channel1_instrument_change_read_header_arpeggio
001d8a cfca                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_pitch:
001d8b 93c0 2887                 	sts pulse2_pitch_macro, r28
001d8d 93d0 2888                 	sts pulse2_pitch_macro+1, r29
001d8f 9220 28b6                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001d91 9220 28b7                 	sts pulse2_fx_Qxy_target+1, zero
001d93 9220 28bd                 	sts pulse2_fx_Rxy_target, zero
001d95 9220 28be                 	sts pulse2_fx_Rxy_target+1, zero
001d97 d021                      	rcall sound_driver_channel1_instrument_change_read_header
001d98 93c0 288b                 	sts pulse2_pitch_macro_release, r28
001d9a 93d0 288a                 	sts pulse2_pitch_macro_loop, r29
001d9c cfb8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_hi_pitch:
001d9d 93c0 288d                 	sts pulse2_hi_pitch_macro, r28
001d9f 93d0 288e                 	sts pulse2_hi_pitch_macro+1, r29
001da1 9220 28b6                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001da3 9220 28b7                 	sts pulse2_fx_Qxy_target+1, zero
001da5 9220 28bd                 	sts pulse2_fx_Rxy_target, zero
001da7 9220 28be                 	sts pulse2_fx_Rxy_target+1, zero
001da9 d00f                      	rcall sound_driver_channel1_instrument_change_read_header
001daa 93c0 2891                 	sts pulse2_hi_pitch_macro_release, r28
001dac 93d0 2890                 	sts pulse2_hi_pitch_macro_loop, r29
001dae cfa6                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_duty:
001daf 93c0 2892                 	sts pulse2_duty_macro, r28
001db1 93d0 2893                 	sts pulse2_duty_macro+1, r29
001db3 d005                      	rcall sound_driver_channel1_instrument_change_read_header
001db4 93c0 2896                 	sts pulse2_duty_macro_release, r28
001db6 93d0 2895                 	sts pulse2_duty_macro_loop, r29
001db8 cf9c                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_read_header:
001db9 93ef                      	push ZL
001dba 93ff                      	push ZH
001dbb 2fec                      	mov ZL, r28
001dbc 2ffd                      	mov ZH, r29
001dbd 0fee                      	lsl ZL
001dbe 1fff                      	rol ZH
001dbf 91c5                      	lpm r28, Z+
001dc0 91d4                      	lpm r29, Z
001dc1 91ff                      	pop ZH
001dc2 91ef                      	pop ZL
001dc3 9508                      	ret
                                 
                                 sound_driver_channel1_instrument_change_read_header_arpeggio:
001dc4 93ef                      	push ZL
001dc5 93ff                      	push ZH
001dc6 2fec                      	mov ZL, r28
001dc7 2ffd                      	mov ZH, r29
001dc8 0fee                      	lsl ZL
001dc9 1fff                      	rol ZH
001dca 91c5                      	lpm r28, Z+
001dcb 91d5                      	lpm r29, Z+
001dcc 93c0 2883                 	sts pulse2_arpeggio_macro_release, r28
001dce 93d0 2882                 	sts pulse2_arpeggio_macro_loop, r29
001dd0 91c4                      	lpm r28, Z
001dd1 93c0 2884                 	sts pulse2_arpeggio_macro_mode, r28
001dd3 91ff                      	pop ZH
001dd4 91ef                      	pop ZL
001dd5 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel1_release:
                                 sound_driver_channel1_release_volume:
001dd6 91b0 287e                 	lds r27, pulse2_volume_macro_release
001dd8 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001dd9 f019                      	breq sound_driver_channel1_release_arpeggio //if the macro has no release flag, check the next macro
001dda 95b3                      	inc r27
001ddb 93b0 287c                 	sts pulse2_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel1_release_arpeggio:
001ddd 91b0 2883                 	lds r27, pulse2_arpeggio_macro_release
001ddf 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001de0 f019                      	breq sound_driver_channel1_release_pitch
001de1 95b3                      	inc r27
001de2 93b0 2881                 	sts pulse2_arpeggio_macro_offset, r27
                                 sound_driver_channel1_release_pitch:
001de4 91b0 288b                 	lds r27, pulse2_pitch_macro_release
001de6 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001de7 f019                      	breq sound_driver_channel1_release_hi_pitch
001de8 95b3                      	inc r27
001de9 93b0 2889                 	sts pulse2_pitch_macro_offset, r27
                                 sound_driver_channel1_release_hi_pitch:
001deb 91b0 2891                 	lds r27, pulse2_hi_pitch_macro_release
001ded 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001dee f019                      	breq sound_driver_channel1_release_duty
001def 95b3                      	inc r27
001df0 93b0 288f                 	sts pulse2_hi_pitch_macro_offset, r27
                                 sound_driver_channel1_release_duty:
001df2 91b0 2896                 	lds r27, pulse2_duty_macro_release
001df4 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001df5 f019                      	breq sound_driver_channel1_release_exit
001df6 95b3                      	inc r27
001df7 93b0 2894                 	sts pulse2_duty_macro_offset, r27
                                 sound_driver_channel1_release_exit:
001df9 d019                      	rcall sound_driver_channel1_increment_offset
001dfa cd55                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_next_pattern:
001dfb 91e0 2819                 	lds ZL, song_frames
001dfd 91f0 281a                 	lds ZH, song_frames+1
001dff 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001e01 91b0 281c                 	lds r27, song_frame_offset+1
001e03 9612                      	adiw r27:r26, 2 //offset for channel 1
001e04 0fea                      	add ZL, r26
001e05 1ffb                      	adc ZH, r27
                                 
001e06 91a5                      	lpm r26, Z+ //load the address of the next pattern
001e07 91b4                      	lpm r27, Z
001e08 0faa                      	lsl r26
001e09 1fbb                      	rol r27
001e0a 93a0 2874                 	sts pulse2_pattern, r26
001e0c 93b0 2875                 	sts pulse2_pattern+1, r27
                                 
001e0e 9220 2878                 	sts pulse2_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001e10 9220 2879                 	sts pulse2_pattern_offset+1, zero
001e12 cd3d                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_increment_offset:
001e13 91e0 2878                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001e15 91f0 2879                 	lds ZH, pulse2_pattern_offset+1
001e17 9631                      	adiw Z, 1
001e18 93e0 2878                 	sts pulse2_pattern_offset, ZL
001e1a 93f0 2879                 	sts pulse2_pattern_offset+1, ZH
001e1c 9508                      	ret
                                 
                                 sound_driver_channel1_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001e1d 91e0 2878                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001e1f 91f0 2879                 	lds ZH, pulse2_pattern_offset+1
001e21 9632                      	adiw Z, 2 //increment the pointer twice
001e22 93e0 2878                 	sts pulse2_pattern_offset, ZL
001e24 93f0 2879                 	sts pulse2_pattern_offset+1, ZH
001e26 9508                      	ret
                                 
                                 sound_driver_channel1_end:
                                 sound_driver_channel1_check_Sxx_invalid:
001e27 efbf                      	ldi r27, 0xFF
001e28 91a0 28c4                 	lds r26, pulse2_fx_Sxx_post
001e2a 15a2                      	cp r26, zero //check if routine was called from calculate_delays due to invalid Sxx/Gxx
001e2b f419                      	brne sound_driver_channel1_check_Gxx_invalid
001e2c 93b0 28c4                 	sts pulse2_fx_Sxx_post, r27
001e2e 9508                      	ret
                                 sound_driver_channel1_check_Gxx_invalid:
001e2f 91a0 28b2                 	lds r26, pulse2_fx_Gxx_post
001e31 15a2                      	cp r26, zero
001e32 f419                      	brne sound_driver_channel2
001e33 93b0 28b2                 	sts pulse2_fx_Gxx_post, r27
001e35 9508                      	ret
                                 
                                 
                                 sound_driver_channel2:
001e36 91a0 28c7                 	lds r26, triangle_pattern_delay_rows
001e38 91b0 28c8                 	lds r27, triangle_pattern_delay_frames
                                 sound_driver_channel2_decrement_frame_delay:
001e3a 95ba                      	dec r27
001e3b 93b0 28c8                 	sts triangle_pattern_delay_frames, r27
                                 
001e3d 9610                      	adiw r27:r26, 0
001e3e f009                      	breq sound_driver_channel2_main //if the pattern delay is 0, proceed with sound driver procedures
001e3f c2bf                      	rjmp sound_driver_channel2_end //if the pattern delay is not 0, end routine
                                 
                                 sound_driver_channel2_main:
001e40 91e0 28c5                 	lds ZL, triangle_pattern //current pattern for triangle
001e42 91f0 28c6                 	lds ZH, triangle_pattern+1
001e44 91a0 28c9                 	lds r26, triangle_pattern_offset //current offset in the pattern for triangle
001e46 91b0 28ca                 	lds r27, triangle_pattern_offset+1
001e48 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001e49 1ffb                      	adc ZH, r27
001e4a 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel2_check_if_note: //check if data is a note (0x00 - 0x56)
001e4b 35b7                      	cpi r27, 0x57
001e4c f408                      	brsh sound_driver_channel2_check_if_volume
001e4d c160                      	rjmp sound_driver_channel2_note
                                 sound_driver_channel2_check_if_volume: //check if data is volume (0x57-0x66)
001e4e 36b7                      	cpi r27, 0x67
001e4f f408                      	brsh sound_driver_channel2_check_if_delay
001e50 c19e                      	rjmp sound_driver_channel2_volume
                                 sound_driver_channel2_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001e51 3eb3                      	cpi r27, 0xE3
001e52 f408                      	brsh sound_driver_channel2_check_if_instrument
001e53 c1a9                      	rjmp sound_driver_channel2_delay
                                 sound_driver_channel2_check_if_instrument: //check for instrument flag (0xE3)
001e54 f409                      	brne sound_driver_channel2_check_if_release
001e55 c1ac                      	rjmp sound_driver_channel2_instrument_change 
                                 sound_driver_channel2_check_if_release: //check for note release flag (0xE4)
001e56 3eb4                      	cpi r27, 0xE4
001e57 f409                      	brne sound_driver_channel2_check_if_end
001e58 c255                      	rjmp sound_driver_channel2_release
                                 sound_driver_channel2_check_if_end:
001e59 3fbf                      	cpi r27, 0xFF
001e5a f409                      	brne sound_driver_channel2_check_if_fx
001e5b c277                      	rjmp sound_driver_channel2_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel2_check_if_fx: //fx flags (0xE5 - 0xFE)
001e5c 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001e5d 91a4                      	lpm r26, Z //load the fx data into r26
001e5e d296                      	rcall sound_driver_channel2_increment_offset_twice
                                 
001e5f 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001e60 e0ee                      	ldi ZL, LOW(channel2_fx << 1) //load in note table
001e61 e6f2                      	ldi ZH, HIGH(channel2_fx << 1)
001e62 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001e63 0feb                      	add ZL, r27 //add offset
001e64 1df2                      	adc ZH, zero
001e65 91c5                      	lpm r28, Z+ //load address bytes
001e66 91d4                      	lpm r29, Z
001e67 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001e68 2ffd                      	mov ZH, r29
001e69 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel2_fx_0xy:
001e6a 93a0 28e8                 	sts triangle_fx_0xy_sequence, r26
001e6c 9220 28e9                 	sts triangle_fx_0xy_sequence+1, zero
001e6e cfd1                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel2_fx_1xx:
001e6f 9220 28ee                 	sts triangle_fx_2xx, zero //turn off any 2xx pitch slide down
001e71 9220 28ef                 	sts triangle_fx_2xx+1, zero
001e73 9220 28e8                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001e75 9220 28e9                 	sts triangle_fx_0xy_sequence+1, zero
001e77 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001e78 937f                      	push r23
001e79 2f6a                      	mov r22, r26 //store the rate into r22
001e7a eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001e7b 9f67                      	mul r22, r23
001e7c 917f                      	pop r23
001e7d 916f                      	pop r22
                                 
001e7e 9416                      	lsr r1 //shift out the fractional bits
001e7f 9407                      	ror r0
001e80 9416                      	lsr r1
001e81 9407                      	ror r0
001e82 9416                      	lsr r1
001e83 9407                      	ror r0
001e84 9416                      	lsr r1
001e85 9407                      	ror r0
001e86 9200 28ea                 	sts triangle_fx_1xx, r0
001e88 9210 28eb                 	sts triangle_fx_1xx+1, r1
001e8a cfb5                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel2_fx_2xx:
001e8b 9220 28ea                 	sts triangle_fx_1xx, zero //turn off any 1xx pitch slide down
001e8d 9220 28eb                 	sts triangle_fx_1xx+1, zero
001e8f 9220 28e8                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001e91 9220 28e9                 	sts triangle_fx_0xy_sequence+1, zero
001e93 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001e94 937f                      	push r23
001e95 2f6a                      	mov r22, r26 //store the rate into r22
001e96 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001e97 9f67                      	mul r22, r23
001e98 917f                      	pop r23
001e99 916f                      	pop r22
                                 
001e9a 9416                      	lsr r1 //shift out the fractional bits
001e9b 9407                      	ror r0
001e9c 9416                      	lsr r1
001e9d 9407                      	ror r0
001e9e 9416                      	lsr r1
001e9f 9407                      	ror r0
001ea0 9416                      	lsr r1
001ea1 9407                      	ror r0
001ea2 9200 28ee                 	sts triangle_fx_2xx, r0
001ea4 9210 28ef                 	sts triangle_fx_2xx+1, r1
001ea6 cf99                      	rjmp sound_driver_channel2_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel2_fx_3xx:
001ea7 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001ea8 937f                      	push r23
001ea9 2f6a                      	mov r22, r26 //store the rate into r22
001eaa eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001eab 9f67                      	mul r22, r23
001eac 917f                      	pop r23
001ead 916f                      	pop r22
                                 
001eae 9416                      	lsr r1 //shift out the fractional bits
001eaf 9407                      	ror r0
001eb0 9416                      	lsr r1
001eb1 9407                      	ror r0
001eb2 9416                      	lsr r1
001eb3 9407                      	ror r0
001eb4 9416                      	lsr r1
001eb5 9407                      	ror r0
001eb6 9200 28f6                 	sts triangle_fx_3xx_speed, r0
001eb8 9210 28f7                 	sts triangle_fx_3xx_speed+1, r1
                                 
001eba 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001ebb c001                      	rjmp sound_driver_channel2_fx_3xx_enabled
001ebc cf83                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_3xx_enabled:
001ebd 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001ebf 91b0 0aad                 	lds r27, TCB2_CCMPH
001ec1 93a0 28f2                 	sts triangle_fx_3xx_start, r26
001ec3 93b0 28f3                 	sts triangle_fx_3xx_start+1, r27
                                 
001ec5 9220 28f8                 	sts triangle_fx_3xx_total_offset, zero
001ec7 9220 28f9                 	sts triangle_fx_3xx_total_offset+1, zero
001ec9 cf76                      	rjmp sound_driver_channel2_main
                                 
                                 //VIBRATO
                                 sound_driver_channel2_fx_4xy:
001eca 2fba                      	mov r27, r26
001ecb 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001ecc 95a2                      	swap r26
001ecd 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001ece 93a0 28fa                 	sts triangle_fx_4xy_speed, r26
001ed0 93b0 28fb                 	sts triangle_fx_4xy_depth, r27
001ed2 9220 28fc                 	sts triangle_fx_4xy_phase, zero //reset the phase to 0
001ed4 cf6b                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_7xy: //tremelo
001ed5 cf6a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Axy: //volume slide
001ed6 cf69                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel2_fx_Bxx:
001ed7 93a0 2820                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001ed9 cf66                      	rjmp sound_driver_channel2_main
                                 
                                 //HALT
                                 sound_driver_channel2_fx_Cxx:
001eda 93b0 2821                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001edc cf63                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel2_fx_Dxx:
001edd 93b0 2822                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001edf cf60                      	rjmp sound_driver_channel2_main
                                 
                                 //VOLUME
                                 sound_driver_channel2_fx_Exx:
001ee0 15a2                      	cp r26, zero
001ee1 f021                      	breq sound_driver_channel2_fx_Exx_disable
                                 sound_driver_channel2_fx_Exx_enable:
001ee2 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001ee3 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001ee5 cf5a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Exx_disable:
001ee6 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
001ee8 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
001eea 9220 0aad                 	sts TCB2_CCMPH, zero
001eec cf53                      	rjmp sound_driver_channel2_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel2_fx_Fxx:
001eed 93a0 281f                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001eef cf50                      	rjmp sound_driver_channel2_main
                                 
                                 //DELAY
                                 sound_driver_channel2_fx_Gxx:
001ef0 15a2                      	cp r26, zero
001ef1 f051                      	breq sound_driver_channel2_fx_Gxx_invalid
001ef2 91b0 281f                 	lds r27, song_speed
001ef4 17ab                      	cp r26, r27
001ef5 f430                      	brsh sound_driver_channel2_fx_Gxx_invalid
001ef6 93a0 28fd                 	sts triangle_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001ef8 e0b1                      	ldi r27, 0x01
001ef9 93b0 28c7                 	sts triangle_pattern_delay_rows, r27
001efb c212                      	rjmp sound_driver_channel3
                                 sound_driver_channel2_fx_Gxx_invalid:
001efc cf43                      	rjmp sound_driver_channel2_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Hxy: //hardware sweep up
001efd cf42                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixy: //hardware sweep down
001efe cf41                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Hxx: //FDS modulation depth
001eff cf40                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixx: //FDS modulation speed
001f00 cf3f                      	rjmp sound_driver_channel2_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel2_fx_Pxx:
001f01 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001f02 937f                      	push r23
001f03 2f6a                      	mov r22, r26
001f04 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001f05 0367                      	mulsu r22, r23
001f06 917f                      	pop r23
001f07 916f                      	pop r22
001f08 9416                      	lsr r1 //shift out the fractional bits
001f09 9407                      	ror r0
001f0a 9416                      	lsr r1
001f0b 9407                      	ror r0
001f0c 9416                      	lsr r1
001f0d 9407                      	ror r0
001f0e 9416                      	lsr r1
001f0f 9407                      	ror r0
001f10 fe13                      	sbrs r1, 3 //check if result was a negative number
001f11 c002                      	rjmp sound_driver_channel2_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel2_fx_Pxx_negative:
001f12 efb0                      	ldi r27, 0xF0
001f13 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel2_fx_Pxx_store:
001f14 9200 28ff                 	sts triangle_fx_Pxx_total, r0
001f16 9210 2900                 	sts triangle_fx_Pxx_total+1, r1
001f18 cf27                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel2_fx_Qxy:
                                 sound_driver_channel2_fx_Qxy_check_arpeggio_macro:
001f19 91e0 28d0                 	lds ZL, triangle_arpeggio_macro
001f1b 91f0 28d1                 	lds ZH, triangle_arpeggio_macro+1
001f1d 9630                      	adiw Z, 0
001f1e f009                      	breq sound_driver_channel2_fx_Qxy_check_pitch_macro
001f1f cf20                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_pitch_macro:
001f20 91e0 28d8                 	lds ZL, triangle_pitch_macro
001f22 91f0 28d9                 	lds ZH, triangle_pitch_macro+1
001f24 9630                      	adiw Z, 0
001f25 f009                      	breq sound_driver_channel2_fx_Qxy_check_hi_pitch_macro
001f26 cf19                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_hi_pitch_macro:
001f27 91e0 28de                 	lds ZL, triangle_hi_pitch_macro
001f29 91f0 28df                 	lds ZH, triangle_hi_pitch_macro+1
001f2b 9630                      	adiw Z, 0
001f2c f009                      	breq sound_driver_channel2_fx_Qxy_process
001f2d cf12                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_process:
001f2e 2fba                      	mov r27, r26 //copy fx parameters into r27
001f2f 70bf                      	andi r27, 0x0F //mask note index offset
001f30 91c0 2901                 	lds r28, triangle_fx_Qxy_target_note //load current note index
001f32 0fbc                      	add r27, r28
001f33 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001f34 f008                      	brlo sound_driver_channel2_fx_Qxy_process_continue
001f35 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel2_fx_Qxy_process_continue:
001f36 93b0 2901                 	sts triangle_fx_Qxy_target_note, r27
001f38 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001f39 e0f0                      	ldi ZH, HIGH(note_table << 1)
001f3a 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001f3b 0feb                      	add ZL, r27 //add offset
001f3c 1df2                      	adc ZH, zero
001f3d 91c5                      	lpm r28, Z+ //load bytes
001f3e 91d4                      	lpm r29, Z
001f3f 93c0 2902                 	sts triangle_fx_Qxy_target, r28 //load the LOW bits for the target period
001f41 93d0 2903                 	sts triangle_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel2_fx_Qxy_process_speed:
001f43 95a2                      	swap r26
001f44 70af                      	andi r26, 0x0F //mask effect speed
001f45 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001f46 95a3                      	inc r26 //increment the speed by 1
                                 
001f47 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001f48 937f                      	push r23
001f49 2f6a                      	mov r22, r26 //store the speed data into r27
001f4a eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001f4b 9f67                      	mul r22, r23
001f4c 917f                      	pop r23
001f4d 916f                      	pop r22
                                 
001f4e 9416                      	lsr r1 //shift out the fractional bits
001f4f 9407                      	ror r0
001f50 9416                      	lsr r1
001f51 9407                      	ror r0
001f52 9416                      	lsr r1
001f53 9407                      	ror r0
001f54 9416                      	lsr r1
001f55 9407                      	ror r0
                                 
001f56 9200 2904                 	sts triangle_fx_Qxy_speed, r0 //store the effect speed
001f58 9210 2905                 	sts triangle_fx_Qxy_speed+1, r1
001f5a cee5                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel2_fx_Rxy:
                                 sound_driver_channel2_fx_Rxy_check_arpeggio_macro:
001f5b 91e0 28d0                 	lds ZL, triangle_arpeggio_macro
001f5d 91f0 28d1                 	lds ZH, triangle_arpeggio_macro+1
001f5f 9630                      	adiw Z, 0
001f60 f009                      	breq sound_driver_channel2_fx_Rxy_check_pitch_macro
001f61 cede                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_pitch_macro:
001f62 91e0 28d8                 	lds ZL, triangle_pitch_macro
001f64 91f0 28d9                 	lds ZH, triangle_pitch_macro+1
001f66 9630                      	adiw Z, 0
001f67 f009                      	breq sound_driver_channel2_fx_Rxy_check_hi_pitch_macro
001f68 ced7                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_hi_pitch_macro:
001f69 91e0 28de                 	lds ZL, triangle_hi_pitch_macro
001f6b 91f0 28df                 	lds ZH, triangle_hi_pitch_macro+1
001f6d 9630                      	adiw Z, 0
001f6e f009                      	breq sound_driver_channel2_fx_Rxy_process
001f6f ced0                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_process:
001f70 2fba                      	mov r27, r26 //copy fx parameters into r27
001f71 70bf                      	andi r27, 0x0F //mask note index offset
001f72 91c0 2908                 	lds r28, triangle_fx_Rxy_target_note //load current note index
001f74 1bcb                      	sub r28, r27
001f75 f408                      	brcc sound_driver_channel2_fx_Rxy_process_continue
001f76 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel2_fx_Rxy_process_continue:
001f77 93c0 2908                 	sts triangle_fx_Rxy_target_note, r28
001f79 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001f7a e0f0                      	ldi ZH, HIGH(note_table << 1)
001f7b 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001f7c 0fec                      	add ZL, r28 //add offset
001f7d 1df2                      	adc ZH, zero
001f7e 91c5                      	lpm r28, Z+ //load bytes
001f7f 91d4                      	lpm r29, Z
001f80 93c0 2909                 	sts triangle_fx_Rxy_target, r28 //load the LOW bits for the target period
001f82 93d0 290a                 	sts triangle_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel2_fx_Rxy_process_speed:
001f84 95a2                      	swap r26
001f85 70af                      	andi r26, 0x0F //mask effect speed
001f86 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001f87 95a3                      	inc r26 //increment the speed by 1
                                 
001f88 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001f89 937f                      	push r23
001f8a 2f6a                      	mov r22, r26 //store the speed data into r27
001f8b eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001f8c 9f67                      	mul r22, r23
001f8d 917f                      	pop r23
001f8e 916f                      	pop r22
                                 
001f8f 9416                      	lsr r1 //shift out the fractional bits
001f90 9407                      	ror r0
001f91 9416                      	lsr r1
001f92 9407                      	ror r0
001f93 9416                      	lsr r1
001f94 9407                      	ror r0
001f95 9416                      	lsr r1
001f96 9407                      	ror r0
                                 
001f97 9200 290b                 	sts triangle_fx_Rxy_speed, r0 //store the effect speed
001f99 9210 290c                 	sts triangle_fx_Rxy_speed+1, r1
001f9b cea4                      	rjmp sound_driver_channel2_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel2_fx_Sxx:
001f9c 15a2                      	cp r26, zero
001f9d f051                      	breq sound_driver_channel2_fx_Sxx_invalid
001f9e 91b0 281f                 	lds r27, song_speed
001fa0 17ab                      	cp r26, r27
001fa1 f430                      	brsh sound_driver_channel2_fx_Sxx_invalid
001fa2 93a0 290f                 	sts triangle_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001fa4 e0b1                      	ldi r27, 0x01
001fa5 93b0 28c7                 	sts triangle_pattern_delay_rows, r27
001fa7 c166                      	rjmp sound_driver_channel3
                                 sound_driver_channel2_fx_Sxx_invalid:
001fa8 ce97                      	rjmp sound_driver_channel2_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Vxx: //duty
001fa9 ce96                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Wxx: //DPCM sample speed
001faa ce95                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Xxx: //DPCM sample retrigger
001fab ce94                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Yxx: //DPCM sample offset
001fac ce93                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Zxx: //DPCM sample delta counter
001fad ce92                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 sound_driver_channel2_note:
001fae 93b0 2812                 	sts triangle_note, r27 //store the note index
001fb0 93b0 2901                 	sts triangle_fx_Qxy_target_note, r27
001fb2 93b0 2908                 	sts triangle_fx_Rxy_target_note, r27
001fb4 e0a3                      	ldi r26, 0x03
001fb5 e0b2                      	ldi r27, 0x02
001fb6 93b0 28cd                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
001fb8 93a0 28d2                 	sts triangle_arpeggio_macro_offset, r26
001fba 93b0 28da                 	sts triangle_pitch_macro_offset, r27
001fbc 93b0 28e0                 	sts triangle_hi_pitch_macro_offset, r27
001fbe 93b0 28e5                 	sts triangle_duty_macro_offset, r27
001fc0 9220 28d6                 	sts triangle_total_pitch_offset, zero //reset the pitch and hi pitch offset
001fc2 9220 28d7                 	sts triangle_total_pitch_offset+1, zero
001fc4 9220 28dd                 	sts triangle_total_hi_pitch_offset, zero
001fc6 9220 28ec                 	sts triangle_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001fc8 9220 28ed                 	sts triangle_fx_1xx_total+1, zero
001fca 9220 28f0                 	sts triangle_fx_2xx_total, zero
001fcc 9220 28f1                 	sts triangle_fx_2xx_total+1, zero
001fce 9220 28f8                 	sts triangle_fx_3xx_total_offset, zero //reset 3xx offset
001fd0 9220 28f9                 	sts triangle_fx_3xx_total_offset+1, zero
001fd2 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001fd4 91b0 0aad                 	lds r27, TCB2_CCMPH
001fd6 93a0 28f2                 	sts triangle_fx_3xx_start, r26
001fd8 93b0 28f3                 	sts triangle_fx_3xx_start+1, r27
001fda 9220 2902                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001fdc 9220 2903                 	sts triangle_fx_Qxy_target+1, zero
001fde 9220 2906                 	sts triangle_fx_Qxy_total_offset, zero
001fe0 9220 2907                 	sts triangle_fx_Qxy_total_offset+1, zero
001fe2 9220 2909                 	sts triangle_fx_Rxy_target, zero
001fe4 9220 290a                 	sts triangle_fx_Rxy_target+1, zero
001fe6 9220 290d                 	sts triangle_fx_Rxy_total_offset, zero
001fe8 9220 290e                 	sts triangle_fx_Rxy_total_offset+1, zero
001fea e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001feb 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001fed d0fd                      	rcall sound_driver_channel2_increment_offset
001fee ce51                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_volume:
001fef d0fb                      	rcall sound_driver_channel2_increment_offset
001ff0 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest note value, which is 0x56
001ff1 f021                      	breq sound_driver_channel2_volume_disable
                                 sound_driver_channel2_volume_enable:
001ff2 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001ff3 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001ff5 ce4a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_volume_disable:
001ff6 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
001ff8 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
001ffa 9220 0aad                 	sts TCB2_CCMPH, zero
001ffc ce43                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_delay:
001ffd 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001ffe 93b0 28c7                 	sts triangle_pattern_delay_rows, r27
002000 d0ea                      	rcall sound_driver_channel2_increment_offset
002001 c0fd                      	rjmp sound_driver_channel2_end
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change:
002002 9220 28cb                 	sts triangle_volume_macro, zero //reset all macro addresses
002004 9220 28cc                 	sts triangle_volume_macro+1, zero
002006 9220 28d0                 	sts triangle_arpeggio_macro, zero
002008 9220 28d1                 	sts triangle_arpeggio_macro+1, zero
00200a 9220 28d8                 	sts triangle_pitch_macro, zero
00200c 9220 28d9                 	sts triangle_pitch_macro+1, zero
00200e 9220 28de                 	sts triangle_hi_pitch_macro, zero
002010 9220 28df                 	sts triangle_hi_pitch_macro+1, zero
002012 9220 28e3                 	sts triangle_duty_macro, zero
002014 9220 28e4                 	sts triangle_duty_macro+1, zero
002016 9220 28d6                 	sts triangle_total_pitch_offset, zero //reset the pitch offset
002018 9220 28d7                 	sts triangle_total_pitch_offset+1, zero
00201a 9220 28dd                 	sts triangle_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
00201c 9631                      	adiw Z, 1 //point to the byte next to the flag
00201d 91b4                      	lpm r27, Z //store the instrument offset into r27
00201e e9ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
00201f e1f1                      	ldi ZH, HIGH(instruments)
002020 0feb                      	add ZL, r27 //point Z to offsetted instrument
002021 1df2                      	adc ZH, zero
002022 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
002023 1fff                      	rol ZH
002024 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
002025 91b4                      	lpm r27, Z
                                 
002026 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
002027 1fbb                      	rol r27
002028 2fea                      	mov ZL, r26
002029 2ffb                      	mov ZH, r27
00202a 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
00202b 9632                      	adiw Z, 2 //point Z to the address of the macro
00202c e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel2_instrument_change_macro_loop:
00202d 95aa                      	dec r26
00202e f019                      	breq sound_driver_channel2_instrument_change_exit
00202f 95b6                      	lsr r27
002030 f078                      	brcs sound_driver_channel2_instrument_change_load_macro
002031 cffb                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_exit:
002032 e0a3                      	ldi r26, 0x03
002033 e0b2                      	ldi r27, 0x02
002034 93b0 28cd                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
002036 93a0 28d2                 	sts triangle_arpeggio_macro_offset, r26
002038 93b0 28da                 	sts triangle_pitch_macro_offset, r27
00203a 93b0 28e0                 	sts triangle_hi_pitch_macro_offset, r27
00203c 93b0 28e5                 	sts triangle_duty_macro_offset, r27
00203e d0b6                      	rcall sound_driver_channel2_increment_offset_twice
00203f ce00                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_load_macro:
002040 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
002041 91d5                      	lpm r29, Z+
                                 
002042 30a5                      	cpi r26, 5
002043 f039                      	breq sound_driver_channel2_instrument_change_load_macro_volume
002044 30a4                      	cpi r26, 4
002045 f079                      	breq sound_driver_channel2_instrument_change_load_macro_arpeggio
002046 30a3                      	cpi r26, 3
002047 f0d9                      	breq sound_driver_channel2_instrument_change_load_macro_pitch
002048 30a2                      	cpi r26, 2
002049 f159                      	breq sound_driver_channel2_instrument_change_load_macro_hi_pitch
00204a c03c                      	rjmp sound_driver_channel2_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel2_instrument_change_load_macro_volume:
00204b 93c0 28cb                 	sts triangle_volume_macro, r28
00204d 93d0 28cc                 	sts triangle_volume_macro+1, r29
00204f d041                      	rcall sound_driver_channel2_instrument_change_read_header
002050 93c0 28cf                 	sts triangle_volume_macro_release, r28
002052 93d0 28ce                 	sts triangle_volume_macro_loop, r29
002054 cfd8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 	
                                 sound_driver_channel2_instrument_change_load_macro_arpeggio:
002055 93c0 28d0                 	sts triangle_arpeggio_macro, r28
002057 93d0 28d1                 	sts triangle_arpeggio_macro+1, r29
002059 9220 2902                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00205b 9220 2903                 	sts triangle_fx_Qxy_target+1, zero
00205d 9220 2909                 	sts triangle_fx_Rxy_target, zero
00205f 9220 290a                 	sts triangle_fx_Rxy_target+1, zero
002061 d03a                      	rcall sound_driver_channel2_instrument_change_read_header_arpeggio
002062 cfca                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_pitch:
002063 93c0 28d8                 	sts triangle_pitch_macro, r28
002065 93d0 28d9                 	sts triangle_pitch_macro+1, r29
002067 9220 2902                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
002069 9220 2903                 	sts triangle_fx_Qxy_target+1, zero
00206b 9220 2909                 	sts triangle_fx_Rxy_target, zero
00206d 9220 290a                 	sts triangle_fx_Rxy_target+1, zero
00206f d021                      	rcall sound_driver_channel2_instrument_change_read_header
002070 93c0 28dc                 	sts triangle_pitch_macro_release, r28
002072 93d0 28db                 	sts triangle_pitch_macro_loop, r29
002074 cfb8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_hi_pitch:
002075 93c0 28de                 	sts triangle_hi_pitch_macro, r28
002077 93d0 28df                 	sts triangle_hi_pitch_macro+1, r29
002079 9220 2902                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00207b 9220 2903                 	sts triangle_fx_Qxy_target+1, zero
00207d 9220 2909                 	sts triangle_fx_Rxy_target, zero
00207f 9220 290a                 	sts triangle_fx_Rxy_target+1, zero
002081 d00f                      	rcall sound_driver_channel2_instrument_change_read_header
002082 93c0 28e2                 	sts triangle_hi_pitch_macro_release, r28
002084 93d0 28e1                 	sts triangle_hi_pitch_macro_loop, r29
002086 cfa6                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_duty:
002087 93c0 28e3                 	sts triangle_duty_macro, r28
002089 93d0 28e4                 	sts triangle_duty_macro+1, r29
00208b d005                      	rcall sound_driver_channel2_instrument_change_read_header
00208c 93c0 28e7                 	sts triangle_duty_macro_release, r28
00208e 93d0 28e6                 	sts triangle_duty_macro_loop, r29
002090 cf9c                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_read_header:
002091 93ef                      	push ZL
002092 93ff                      	push ZH
002093 2fec                      	mov ZL, r28
002094 2ffd                      	mov ZH, r29
002095 0fee                      	lsl ZL
002096 1fff                      	rol ZH
002097 91c5                      	lpm r28, Z+
002098 91d4                      	lpm r29, Z
002099 91ff                      	pop ZH
00209a 91ef                      	pop ZL
00209b 9508                      	ret
                                 
                                 sound_driver_channel2_instrument_change_read_header_arpeggio:
00209c 93ef                      	push ZL
00209d 93ff                      	push ZH
00209e 2fec                      	mov ZL, r28
00209f 2ffd                      	mov ZH, r29
0020a0 0fee                      	lsl ZL
0020a1 1fff                      	rol ZH
0020a2 91c5                      	lpm r28, Z+
0020a3 91d5                      	lpm r29, Z+
0020a4 93c0 28d4                 	sts triangle_arpeggio_macro_release, r28
0020a6 93d0 28d3                 	sts triangle_arpeggio_macro_loop, r29
0020a8 91c4                      	lpm r28, Z
0020a9 93c0 28d5                 	sts triangle_arpeggio_macro_mode, r28
0020ab 91ff                      	pop ZH
0020ac 91ef                      	pop ZL
0020ad 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel2_release:
                                 sound_driver_channel2_release_volume:
0020ae 91b0 28cf                 	lds r27, triangle_volume_macro_release
0020b0 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
0020b1 f019                      	breq sound_driver_channel2_release_arpeggio //if the macro has no release flag, check the next macro
0020b2 95b3                      	inc r27
0020b3 93b0 28cd                 	sts triangle_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel2_release_arpeggio:
0020b5 91b0 28d4                 	lds r27, triangle_arpeggio_macro_release
0020b7 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
0020b8 f019                      	breq sound_driver_channel2_release_pitch
0020b9 95b3                      	inc r27
0020ba 93b0 28d2                 	sts triangle_arpeggio_macro_offset, r27
                                 sound_driver_channel2_release_pitch:
0020bc 91b0 28dc                 	lds r27, triangle_pitch_macro_release
0020be 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
0020bf f019                      	breq sound_driver_channel2_release_hi_pitch
0020c0 95b3                      	inc r27
0020c1 93b0 28da                 	sts triangle_pitch_macro_offset, r27
                                 sound_driver_channel2_release_hi_pitch:
0020c3 91b0 28e2                 	lds r27, triangle_hi_pitch_macro_release
0020c5 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
0020c6 f019                      	breq sound_driver_channel2_release_duty
0020c7 95b3                      	inc r27
0020c8 93b0 28e0                 	sts triangle_hi_pitch_macro_offset, r27
                                 sound_driver_channel2_release_duty:
0020ca 91b0 28e7                 	lds r27, triangle_duty_macro_release
0020cc 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
0020cd f019                      	breq sound_driver_channel2_release_exit
0020ce 95b3                      	inc r27
0020cf 93b0 28e5                 	sts triangle_duty_macro_offset, r27
                                 sound_driver_channel2_release_exit:
0020d1 d019                      	rcall sound_driver_channel2_increment_offset
0020d2 cd6d                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_next_pattern:
0020d3 91e0 2819                 	lds ZL, song_frames
0020d5 91f0 281a                 	lds ZH, song_frames+1
0020d7 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
0020d9 91b0 281c                 	lds r27, song_frame_offset+1
0020db 9614                      	adiw r27:r26, 4 //offset for channel 2
0020dc 0fea                      	add ZL, r26
0020dd 1ffb                      	adc ZH, r27
                                 
0020de 91a5                      	lpm r26, Z+ //load the address of the next pattern
0020df 91b4                      	lpm r27, Z
0020e0 0faa                      	lsl r26
0020e1 1fbb                      	rol r27
0020e2 93a0 28c5                 	sts triangle_pattern, r26
0020e4 93b0 28c6                 	sts triangle_pattern+1, r27
                                 
0020e6 9220 28c9                 	sts triangle_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
0020e8 9220 28ca                 	sts triangle_pattern_offset+1, zero
0020ea cd55                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_increment_offset:
0020eb 91e0 28c9                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
0020ed 91f0 28ca                 	lds ZH, triangle_pattern_offset+1
0020ef 9631                      	adiw Z, 1
0020f0 93e0 28c9                 	sts triangle_pattern_offset, ZL
0020f2 93f0 28ca                 	sts triangle_pattern_offset+1, ZH
0020f4 9508                      	ret
                                 
                                 sound_driver_channel2_increment_offset_twice: //used for data that takes up 2 bytes worth of space
0020f5 91e0 28c9                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
0020f7 91f0 28ca                 	lds ZH, triangle_pattern_offset+1
0020f9 9632                      	adiw Z, 2 //increment the pointer twice
0020fa 93e0 28c9                 	sts triangle_pattern_offset, ZL
0020fc 93f0 28ca                 	sts triangle_pattern_offset+1, ZH
0020fe 9508                      	ret
                                 
                                 sound_driver_channel2_end:
                                 sound_driver_channel2_check_Sxx_invalid:
0020ff efbf                      	ldi r27, 0xFF
002100 91a0 2910                 	lds r26, triangle_fx_Sxx_post
002102 15a2                      	cp r26, zero //check if routine was called from calculate_delays due to invalid Sxx/Gxx
002103 f419                      	brne sound_driver_channel2_check_Gxx_invalid
002104 93b0 2910                 	sts triangle_fx_Sxx_post, r27
002106 9508                      	ret
                                 sound_driver_channel2_check_Gxx_invalid:
002107 91a0 28fe                 	lds r26, triangle_fx_Gxx_post
002109 15a2                      	cp r26, zero
00210a f419                      	brne sound_driver_channel3
00210b 93b0 28fe                 	sts triangle_fx_Gxx_post, r27
00210d 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel3:
00210e 91a0 2913                 	lds r26, noise_pattern_delay_rows
002110 91b0 2914                 	lds r27, noise_pattern_delay_frames
                                 sound_driver_channel3_decrement_frame_delay:
002112 95ba                      	dec r27
002113 93b0 2914                 	sts noise_pattern_delay_frames, r27
                                 
002115 9610                      	adiw r27:r26, 0
002116 f009                      	breq sound_driver_channel3_main //if the pattern delay is 0, proceed with sound driver procedures
002117 c1b9                      	rjmp sound_driver_channel3_end //if the pattern delay is not 0, end routine
                                 
                                 sound_driver_channel3_main:
002118 91e0 2911                 	lds ZL, noise_pattern //current pattern for noise
00211a 91f0 2912                 	lds ZH, noise_pattern+1
00211c 91a0 2915                 	lds r26, noise_pattern_offset //current offset in the pattern for noise
00211e 91b0 2916                 	lds r27, noise_pattern_offset+1
002120 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
002121 1ffb                      	adc ZH, r27
002122 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel3_check_if_note: //check if data is a note (0x00 - 0x56)
002123 35b7                      	cpi r27, 0x57
002124 f408                      	brsh sound_driver_channel3_check_if_volume
002125 c096                      	rjmp sound_driver_channel3_note
                                 sound_driver_channel3_check_if_volume: //check if data is volume (0x57-0x66)
002126 36b7                      	cpi r27, 0x67
002127 f408                      	brsh sound_driver_channel3_check_if_delay
002128 c0b1                      	rjmp sound_driver_channel3_volume
                                 sound_driver_channel3_check_if_delay: //check if data is a delay (0x67 - 0xE2)
002129 3eb3                      	cpi r27, 0xE3
00212a f408                      	brsh sound_driver_channel3_check_if_instrument
00212b c0b7                      	rjmp sound_driver_channel3_delay
                                 sound_driver_channel3_check_if_instrument: //check for instrument flag (0xE3)
00212c f409                      	brne sound_driver_channel3_check_if_release
00212d c0ba                      	rjmp sound_driver_channel3_instrument_change 
                                 sound_driver_channel3_check_if_release: //check for note release flag (0xE4)
00212e 3eb4                      	cpi r27, 0xE4
00212f f409                      	brne sound_driver_channel3_check_if_end
002130 c14b                      	rjmp sound_driver_channel3_release
                                 sound_driver_channel3_check_if_end:
002131 3fbf                      	cpi r27, 0xFF
002132 f409                      	brne sound_driver_channel3_check_if_fx
002133 c16d                      	rjmp sound_driver_channel3_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel3_check_if_fx: //fx flags (0xE5 - 0xFE)
002134 9631                      	adiw Z, 1 //point Z to the byte next to the flag
002135 91a4                      	lpm r26, Z //load the fx data into r26
002136 d190                      	rcall sound_driver_channel3_increment_offset_twice
                                 
002137 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
002138 e4e2                      	ldi ZL, LOW(channel3_fx << 1) //load in note table
002139 e6f2                      	ldi ZH, HIGH(channel3_fx << 1)
00213a 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
00213b 0feb                      	add ZL, r27 //add offset
00213c 1df2                      	adc ZH, zero
00213d 91c5                      	lpm r28, Z+ //load address bytes
00213e 91d4                      	lpm r29, Z
00213f 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
002140 2ffd                      	mov ZH, r29
002141 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel3_fx_0xy:
002142 93a0 2934                 	sts noise_fx_0xy_sequence, r26
002144 9220 2935                 	sts noise_fx_0xy_sequence+1, zero
002146 cfd1                      	rjmp sound_driver_channel3_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel3_fx_1xx:
002147 9220 2938                 	sts noise_fx_2xx, zero //turn off any 2xx pitch slide down
002149 9220 2934                 	sts noise_fx_0xy_sequence, zero //disable any 0xy effect
00214b 9220 2935                 	sts noise_fx_0xy_sequence+1, zero
00214d 93a0 2936                 	sts noise_fx_1xx, r26
00214f cfc8                      	rjmp sound_driver_channel3_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel3_fx_2xx:
002150 9220 2936                 	sts noise_fx_1xx, zero //turn off any 1xx pitch slide down
002152 9220 2934                 	sts noise_fx_0xy_sequence, zero //disable any 0xy effect
002154 9220 2935                 	sts noise_fx_0xy_sequence+1, zero
002156 93a0 2938                 	sts noise_fx_2xx, r26
002158 cfbf                      	rjmp sound_driver_channel3_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel3_fx_3xx:
002159 cfbe                      	rjmp sound_driver_channel3_main
                                 
                                 //VIBRATO
                                 sound_driver_channel3_fx_4xy:
00215a 2fba                      	mov r27, r26
00215b 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
00215c 95a2                      	swap r26
00215d 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
00215e 93a0 293a                 	sts noise_fx_4xy_speed, r26
002160 93b0 293b                 	sts noise_fx_4xy_depth, r27
002162 9220 293c                 	sts noise_fx_4xy_phase, zero //reset the phase to 0
002164 9220 293d                 	sts noise_fx_4xy_offset, zero
002166 cfb1                      	rjmp sound_driver_channel3_main
                                 
                                 //TREMELO
                                 sound_driver_channel3_fx_7xy:
002167 2fba                      	mov r27, r26
002168 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
002169 95a2                      	swap r26
00216a 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
00216b 93a0 293e                 	sts noise_fx_7xy_speed, r26
00216d 93b0 293f                 	sts noise_fx_7xy_depth, r27
00216f 9220 2940                 	sts noise_fx_7xy_phase, zero //reset the phase to 0
002171 9220 2941                 	sts noise_fx_7xy_value, zero //reset the tremelo value
002173 cfa4                      	rjmp sound_driver_channel3_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel3_fx_Axy:
002174 93a0 2942                 	sts noise_fx_Axy, r26
002176 cfa1                      	rjmp sound_driver_channel3_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel3_fx_Bxx:
002177 93a0 2820                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
002179 cf9e                      	rjmp sound_driver_channel3_main
                                 
                                 //HALT
                                 sound_driver_channel3_fx_Cxx:
00217a 93b0 2821                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
00217c cf9b                      	rjmp sound_driver_channel3_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel3_fx_Dxx:
00217d 93b0 2822                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
00217f cf98                      	rjmp sound_driver_channel3_main
                                 
                                 //VOLUME
                                 sound_driver_channel3_fx_Exx:
002180 91b0 2813                 	lds r27, noise_param
002182 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
002183 2bba                      	or r27, r26 //move new VVVV bits into noise_param
002184 93b0 2813                 	sts noise_param, r27
002186 cf91                      	rjmp sound_driver_channel3_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel3_fx_Fxx:
002187 93a0 281f                 	sts song_speed, r26 //NOTE: only changes to speed are supported
002189 cf8e                      	rjmp sound_driver_channel3_main
                                 
                                 //DELAY
                                 sound_driver_channel3_fx_Gxx:
00218a 15a2                      	cp r26, zero
00218b f051                      	breq sound_driver_channel3_fx_Gxx_invalid
00218c 91b0 281f                 	lds r27, song_speed
00218e 17ab                      	cp r26, r27
00218f f430                      	brsh sound_driver_channel3_fx_Gxx_invalid
002190 93a0 2943                 	sts noise_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
002192 e0b1                      	ldi r27, 0x01
002193 93b0 2913                 	sts noise_pattern_delay_rows, r27
002195 c14a                      	rjmp sound_driver_channel4
                                 sound_driver_channel3_fx_Gxx_invalid:
002196 cf81                      	rjmp sound_driver_channel3_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel3_fx_Hxy: //hardware sweep up
002197 cf80                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Ixy: //hardware sweep down
002198 cf7f                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Hxx: //FDS modulation depth
002199 cf7e                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Ixx: //FDS modulation speed
00219a cf7d                      	rjmp sound_driver_channel3_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel3_fx_Pxx:
00219b 93a0 2945                 	sts noise_fx_Pxx_total, r26
00219d cf7a                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_Qxy: //note slide up
00219e cf79                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Rxy: //note slide down
00219f cf78                      	rjmp sound_driver_channel3_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel3_fx_Sxx:
0021a0 15a2                      	cp r26, zero
0021a1 f051                      	breq sound_driver_channel3_fx_Sxx_invalid
0021a2 91b0 281f                 	lds r27, song_speed
0021a4 17ab                      	cp r26, r27
0021a5 f430                      	brsh sound_driver_channel3_fx_Sxx_invalid
0021a6 93a0 2946                 	sts noise_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
0021a8 e0b1                      	ldi r27, 0x01
0021a9 93b0 2913                 	sts noise_pattern_delay_rows, r27
0021ab c134                      	rjmp sound_driver_channel4
                                 sound_driver_channel3_fx_Sxx_invalid:
0021ac cf6b                      	rjmp sound_driver_channel3_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel3_fx_Vxx:
0021ad 95a6                      	lsr r26
0021ae 95a7                      	ror r26 //move mode bit to bit 7
0021af 91b0 2814                 	lds r27, noise_period
0021b1 77bf                      	andi r27, 0b01111111
0021b2 2bba                      	or r27, r26 //store the new noise mode
0021b3 93b0 2813                 	sts noise_param, r27
                                 
0021b5 776f                      	andi noise_sequence_HIGH, 0b01111111
0021b6 2b6a                      	or noise_sequence_HIGH, r26
0021b7 cf60                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_Wxx: //DPCM sample speed
0021b8 cf5f                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Xxx: //DPCM sample retrigger
0021b9 cf5e                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Yxx: //DPCM sample offset
0021ba cf5d                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Zxx: //DPCM sample delta counter
0021bb cf5c                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 sound_driver_channel3_note:
0021bc 93b0 2817                 	sts noise_note, r27
0021be 93b0 2818                 	sts noise_adjusted_note, r27
0021c0 e0a3                      	ldi r26, 0x03
0021c1 e0b2                      	ldi r27, 0x02
0021c2 93b0 2919                 	sts noise_volume_macro_offset, r27 //reset all macro offsets
0021c4 93a0 291e                 	sts noise_arpeggio_macro_offset, r26
0021c6 93b0 2926                 	sts noise_pitch_macro_offset, r27
0021c8 93b0 292c                 	sts noise_hi_pitch_macro_offset, r27
0021ca 93b0 2931                 	sts noise_duty_macro_offset, r27
0021cc 9220 2922                 	sts noise_total_pitch_offset, zero //reset the pitch and hi pitch offset
0021ce 9220 2923                 	sts noise_total_pitch_offset+1, zero
0021d0 9220 2929                 	sts noise_total_hi_pitch_offset, zero
0021d2 9220 2937                 	sts noise_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
0021d4 9220 2939                 	sts noise_fx_2xx_total, zero
0021d6 9220 293d                 	sts noise_fx_4xy_offset, zero
0021d8 d0e4                      	rcall sound_driver_channel3_increment_offset
0021d9 cf3e                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_volume:
0021da 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest note value, which is 0x56
0021db 91a0 2813                 	lds r26, noise_param
0021dd 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
0021de 2bab                      	or r26, r27 //move new VVVV bits into noise_param
0021df 93a0 2813                 	sts noise_param, r26
0021e1 d0db                      	rcall sound_driver_channel3_increment_offset
0021e2 cf35                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_delay:
0021e3 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
0021e4 93b0 2913                 	sts noise_pattern_delay_rows, r27
0021e6 d0d6                      	rcall sound_driver_channel3_increment_offset
0021e7 c0e9                      	rjmp sound_driver_channel3_end
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change:
0021e8 9220 2917                 	sts noise_volume_macro, zero //reset all macro addresses
0021ea 9220 2918                 	sts noise_volume_macro+1, zero
0021ec 9220 291c                 	sts noise_arpeggio_macro, zero
0021ee 9220 291d                 	sts noise_arpeggio_macro+1, zero
0021f0 9220 2924                 	sts noise_pitch_macro, zero
0021f2 9220 2925                 	sts noise_pitch_macro+1, zero
0021f4 9220 292a                 	sts noise_hi_pitch_macro, zero
0021f6 9220 292b                 	sts noise_hi_pitch_macro+1, zero
0021f8 9220 292f                 	sts noise_duty_macro, zero
0021fa 9220 2930                 	sts noise_duty_macro+1, zero
0021fc 9220 2922                 	sts noise_total_pitch_offset, zero //reset the pitch offset
0021fe 9220 2923                 	sts noise_total_pitch_offset+1, zero
002200 9220 2929                 	sts noise_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
002202 9631                      	adiw Z, 1 //point to the byte next to the flag
002203 91b4                      	lpm r27, Z //store the instrument offset into r27
002204 e9ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
002205 e1f1                      	ldi ZH, HIGH(instruments)
002206 0feb                      	add ZL, r27 //point Z to offsetted instrument
002207 1df2                      	adc ZH, zero
002208 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
002209 1fff                      	rol ZH
00220a 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
00220b 91b4                      	lpm r27, Z
                                 
00220c 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
00220d 1fbb                      	rol r27
00220e 2fea                      	mov ZL, r26
00220f 2ffb                      	mov ZH, r27
002210 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
002211 9632                      	adiw Z, 2 //point Z to the address of the macro
002212 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel3_instrument_change_macro_loop:
002213 95aa                      	dec r26
002214 f019                      	breq sound_driver_channel3_instrument_change_exit
002215 95b6                      	lsr r27
002216 f078                      	brcs sound_driver_channel3_instrument_change_load_macro
002217 cffb                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_exit:
002218 e0a3                      	ldi r26, 0x03
002219 e0b2                      	ldi r27, 0x02
00221a 93b0 2919                 	sts noise_volume_macro_offset, r27 //reset all macro offsets
00221c 93a0 291e                 	sts noise_arpeggio_macro_offset, r26
00221e 93b0 2926                 	sts noise_pitch_macro_offset, r27
002220 93b0 292c                 	sts noise_hi_pitch_macro_offset, r27
002222 93b0 2931                 	sts noise_duty_macro_offset, r27
002224 d0a2                      	rcall sound_driver_channel3_increment_offset_twice
002225 cef2                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_load_macro:
002226 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
002227 91d5                      	lpm r29, Z+
                                 
002228 30a5                      	cpi r26, 5
002229 f039                      	breq sound_driver_channel3_instrument_change_load_macro_volume
00222a 30a4                      	cpi r26, 4
00222b f079                      	breq sound_driver_channel3_instrument_change_load_macro_arpeggio
00222c 30a3                      	cpi r26, 3
00222d f099                      	breq sound_driver_channel3_instrument_change_load_macro_pitch
00222e 30a2                      	cpi r26, 2
00222f f0d9                      	breq sound_driver_channel3_instrument_change_load_macro_hi_pitch
002230 c024                      	rjmp sound_driver_channel3_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel3_instrument_change_load_macro_volume:
002231 93c0 2917                 	sts noise_volume_macro, r28
002233 93d0 2918                 	sts noise_volume_macro+1, r29
002235 d029                      	rcall sound_driver_channel3_instrument_change_read_header
002236 93c0 291b                 	sts noise_volume_macro_release, r28
002238 93d0 291a                 	sts noise_volume_macro_loop, r29
00223a cfd8                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 	
                                 sound_driver_channel3_instrument_change_load_macro_arpeggio:
00223b 93c0 291c                 	sts noise_arpeggio_macro, r28
00223d 93d0 291d                 	sts noise_arpeggio_macro+1, r29
00223f d02a                      	rcall sound_driver_channel3_instrument_change_read_header_arpeggio
002240 cfd2                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_pitch:
002241 93c0 2924                 	sts noise_pitch_macro, r28
002243 93d0 2925                 	sts noise_pitch_macro+1, r29
002245 d019                      	rcall sound_driver_channel3_instrument_change_read_header
002246 93c0 2928                 	sts noise_pitch_macro_release, r28
002248 93d0 2927                 	sts noise_pitch_macro_loop, r29
00224a cfc8                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_hi_pitch:
00224b 93c0 292a                 	sts noise_hi_pitch_macro, r28
00224d 93d0 292b                 	sts noise_hi_pitch_macro+1, r29
00224f d00f                      	rcall sound_driver_channel3_instrument_change_read_header
002250 93c0 292e                 	sts noise_hi_pitch_macro_release, r28
002252 93d0 292d                 	sts noise_hi_pitch_macro_loop, r29
002254 cfbe                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_duty:
002255 93c0 292f                 	sts noise_duty_macro, r28
002257 93d0 2930                 	sts noise_duty_macro+1, r29
002259 d005                      	rcall sound_driver_channel3_instrument_change_read_header
00225a 93c0 2933                 	sts noise_duty_macro_release, r28
00225c 93d0 2932                 	sts noise_duty_macro_loop, r29
00225e cfb4                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_read_header:
00225f 93ef                      	push ZL
002260 93ff                      	push ZH
002261 2fec                      	mov ZL, r28
002262 2ffd                      	mov ZH, r29
002263 0fee                      	lsl ZL
002264 1fff                      	rol ZH
002265 91c5                      	lpm r28, Z+
002266 91d4                      	lpm r29, Z
002267 91ff                      	pop ZH
002268 91ef                      	pop ZL
002269 9508                      	ret
                                 
                                 sound_driver_channel3_instrument_change_read_header_arpeggio:
00226a 93ef                      	push ZL
00226b 93ff                      	push ZH
00226c 2fec                      	mov ZL, r28
00226d 2ffd                      	mov ZH, r29
00226e 0fee                      	lsl ZL
00226f 1fff                      	rol ZH
002270 91c5                      	lpm r28, Z+
002271 91d5                      	lpm r29, Z+
002272 93c0 2920                 	sts noise_arpeggio_macro_release, r28
002274 93d0 291f                 	sts noise_arpeggio_macro_loop, r29
002276 91c4                      	lpm r28, Z
002277 93c0 2921                 	sts noise_arpeggio_macro_mode, r28
002279 91ff                      	pop ZH
00227a 91ef                      	pop ZL
00227b 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel3_release:
                                 sound_driver_channel3_release_volume:
00227c 91b0 291b                 	lds r27, noise_volume_macro_release
00227e 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
00227f f019                      	breq sound_driver_channel3_release_arpeggio //if the macro has no release flag, check the next macro
002280 95b3                      	inc r27
002281 93b0 2919                 	sts noise_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel3_release_arpeggio:
002283 91b0 2920                 	lds r27, noise_arpeggio_macro_release
002285 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
002286 f019                      	breq sound_driver_channel3_release_pitch
002287 95b3                      	inc r27
002288 93b0 291e                 	sts noise_arpeggio_macro_offset, r27
                                 sound_driver_channel3_release_pitch:
00228a 91b0 2928                 	lds r27, noise_pitch_macro_release
00228c 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
00228d f019                      	breq sound_driver_channel3_release_hi_pitch
00228e 95b3                      	inc r27
00228f 93b0 2926                 	sts noise_pitch_macro_offset, r27
                                 sound_driver_channel3_release_hi_pitch:
002291 91b0 292e                 	lds r27, noise_hi_pitch_macro_release
002293 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
002294 f019                      	breq sound_driver_channel3_release_duty
002295 95b3                      	inc r27
002296 93b0 292c                 	sts noise_hi_pitch_macro_offset, r27
                                 sound_driver_channel3_release_duty:
002298 91b0 2933                 	lds r27, noise_duty_macro_release
00229a 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
00229b f019                      	breq sound_driver_channel3_release_exit
00229c 95b3                      	inc r27
00229d 93b0 2931                 	sts noise_duty_macro_offset, r27
                                 sound_driver_channel3_release_exit:
00229f d01d                      	rcall sound_driver_channel3_increment_offset
0022a0 ce77                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_next_pattern:
0022a1 91e0 2819                 	lds ZL, song_frames
0022a3 91f0 281a                 	lds ZH, song_frames+1
0022a5 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
0022a7 91b0 281c                 	lds r27, song_frame_offset+1
0022a9 93a0 281b                 	sts song_frame_offset, r26
0022ab 93b0 281c                 	sts song_frame_offset+1, r27
0022ad 9616                      	adiw r27:r26, 6 //offset for channel 3
0022ae 0fea                      	add ZL, r26
0022af 1ffb                      	adc ZH, r27
                                 
0022b0 91a5                      	lpm r26, Z+ //load the address of the next pattern
0022b1 91b4                      	lpm r27, Z
0022b2 0faa                      	lsl r26
0022b3 1fbb                      	rol r27
0022b4 93a0 2911                 	sts noise_pattern, r26
0022b6 93b0 2912                 	sts noise_pattern+1, r27
                                 
0022b8 9220 2915                 	sts noise_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
0022ba 9220 2916                 	sts noise_pattern_offset+1, zero
0022bc ce5b                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_increment_offset:
0022bd 91e0 2915                 	lds ZL, noise_pattern_offset //current offset in the pattern for noise
0022bf 91f0 2916                 	lds ZH, noise_pattern_offset+1
0022c1 9631                      	adiw Z, 1
0022c2 93e0 2915                 	sts noise_pattern_offset, ZL
0022c4 93f0 2916                 	sts noise_pattern_offset+1, ZH
0022c6 9508                      	ret
                                 
                                 sound_driver_channel3_increment_offset_twice: //used for data that takes up 2 bytes worth of space
0022c7 91e0 2915                 	lds ZL, noise_pattern_offset //current offset in the pattern for noise
0022c9 91f0 2916                 	lds ZH, noise_pattern_offset+1
0022cb 9632                      	adiw Z, 2 //increment the pointer twice
0022cc 93e0 2915                 	sts noise_pattern_offset, ZL
0022ce 93f0 2916                 	sts noise_pattern_offset+1, ZH
0022d0 9508                      	ret
                                 
                                 sound_driver_channel3_end:
                                 sound_driver_channel3_check_Sxx_invalid:
0022d1 efbf                      	ldi r27, 0xFF
0022d2 91a0 2947                 	lds r26, noise_fx_Sxx_post
0022d4 15a2                      	cp r26, zero //check if routine was called from calculate_delays due to invalid Sxx/Gxx
0022d5 f419                      	brne sound_driver_channel3_check_Gxx_invalid
0022d6 93b0 2947                 	sts noise_fx_Sxx_post, r27
0022d8 9508                      	ret
                                 sound_driver_channel3_check_Gxx_invalid:
0022d9 91a0 2944                 	lds r26, noise_fx_Gxx_post
0022db 15a2                      	cp r26, zero
0022dc f419                      	brne sound_driver_channel4
0022dd 93b0 2944                 	sts noise_fx_Gxx_post, r27
0022df 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel4:
0022e0 91a0 294a                 	lds r26, dpcm_pattern_delay_rows
0022e2 91b0 294b                 	lds r27, dpcm_pattern_delay_frames
                                 sound_driver_channel4_decrement_frame_delay:
0022e4 95ba                      	dec r27
0022e5 93b0 294b                 	sts dpcm_pattern_delay_frames, r27
                                 
0022e7 9610                      	adiw r27:r26, 0
0022e8 f009                      	breq sound_driver_channel4_main //if the pattern delay is 0, proceed with sound driver procedures
0022e9 c0bd                      	rjmp sound_driver_channel4_end //if the pattern delay is not 0, end routine
                                 
                                 sound_driver_channel4_main:
0022ea 91e0 2948                 	lds ZL, dpcm_pattern //current pattern for dpcm
0022ec 91f0 2949                 	lds ZH, dpcm_pattern+1
0022ee 91a0 294c                 	lds r26, dpcm_pattern_offset //current offset in the pattern for dpcm
0022f0 91b0 294d                 	lds r27, dpcm_pattern_offset+1
0022f2 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
0022f3 1ffb                      	adc ZH, r27
0022f4 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel4_check_if_note: //check if data is a note (0x00 - 0x56)
0022f5 35b7                      	cpi r27, 0x57
0022f6 f408                      	brsh sound_driver_channel4_check_if_volume
0022f7 c056                      	rjmp sound_driver_channel4_note
                                 sound_driver_channel4_check_if_volume: //check if data is volume (0x57-0x66)
0022f8 36b7                      	cpi r27, 0x67
0022f9 f408                      	brsh sound_driver_channel4_check_if_delay
0022fa c071                      	rjmp sound_driver_channel4_volume
                                 sound_driver_channel4_check_if_delay: //check if data is a delay (0x67 - 0xE2)
0022fb 3eb3                      	cpi r27, 0xE3
0022fc f408                      	brsh sound_driver_channel4_check_if_instrument
0022fd c070                      	rjmp sound_driver_channel4_delay
                                 sound_driver_channel4_check_if_instrument: //check for instrument flag (0xE3)
0022fe f409                      	brne sound_driver_channel4_check_if_release
0022ff c073                      	rjmp sound_driver_channel4_instrument_change 
                                 sound_driver_channel4_check_if_release: //check for note release flag (0xE4)
002300 3eb4                      	cpi r27, 0xE4
002301 f409                      	brne sound_driver_channel4_check_if_end
002302 c072                      	rjmp sound_driver_channel4_release
                                 sound_driver_channel4_check_if_end:
002303 3fbf                      	cpi r27, 0xFF
002304 f409                      	brne sound_driver_channel4_check_if_fx
002305 c071                      	rjmp sound_driver_channel4_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel4_check_if_fx: //fx flags (0xE5 - 0xFE)
002306 9631                      	adiw Z, 1 //point Z to the byte next to the flag
002307 91a4                      	lpm r26, Z //load the fx data into r26
002308 d094                      	rcall sound_driver_channel4_increment_offset_twice
                                 
002309 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
00230a e7e6                      	ldi ZL, LOW(channel4_fx << 1) //load in note table
00230b e6f2                      	ldi ZH, HIGH(channel4_fx << 1)
00230c 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
00230d 0feb                      	add ZL, r27 //add offset
00230e 1df2                      	adc ZH, zero
00230f 91c5                      	lpm r28, Z+ //load address bytes
002310 91d4                      	lpm r29, Z
002311 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
002312 2ffd                      	mov ZH, r29
002313 9409                      	ijmp
                                 
                                 
                                 
                                 sound_driver_channel4_fx_0xy: //arpeggio
002314 cfd5                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_1xx: //pitch slide up
002315 cfd4                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_2xx: //pitch slide down
002316 cfd3                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_3xx: //automatic portamento
002317 cfd2                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_4xy: //vibrato
002318 cfd1                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_7xy: //tremelo
002319 cfd0                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Axy: //volume slide
00231a cfcf                      	rjmp sound_driver_channel4_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel4_fx_Bxx:
00231b 93a0 2820                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
00231d cfcc                      	rjmp sound_driver_channel4_main
                                 
                                 //HALT
                                 sound_driver_channel4_fx_Cxx:
00231e 93b0 2821                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
002320 cfc9                      	rjmp sound_driver_channel4_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel4_fx_Dxx:
002321 93b0 2822                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
002323 cfc6                      	rjmp sound_driver_channel4_main
                                 
                                 sound_driver_channel4_fx_Exx: //volume
002324 cfc5                      	rjmp sound_driver_channel4_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel4_fx_Fxx:
002325 93a0 281f                 	sts song_speed, r26 //NOTE: only changes to speed are supported
002327 cfc2                      	rjmp sound_driver_channel4_main
                                 
                                 //DELAY
                                 sound_driver_channel4_fx_Gxx:
002328 15a2                      	cp r26, zero
002329 f051                      	breq sound_driver_channel4_fx_Gxx_invalid
00232a 91b0 281f                 	lds r27, song_speed
00232c 17ab                      	cp r26, r27
00232d f430                      	brsh sound_driver_channel4_fx_Gxx_invalid
00232e 93a0 2952                 	sts dpcm_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
002330 e0b1                      	ldi r27, 0x01
002331 93b0 294a                 	sts dpcm_pattern_delay_rows, r27
002333 c082                      	rjmp sound_driver_calculate_delays
                                 sound_driver_channel4_fx_Gxx_invalid:
002334 cfb5                      	rjmp sound_driver_channel4_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel4_fx_Hxy: //hardware sweep up
002335 cfb4                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Ixy: //hardware sweep down
002336 cfb3                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Hxx: //FDS modulation depth
002337 cfb2                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Ixx: //FDS modulation speed
002338 cfb1                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Pxx: //fine pitch
002339 cfb0                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Qxy: //note slide up
00233a cfaf                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Rxy: //note slide down
00233b cfae                      	rjmp sound_driver_channel4_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel4_fx_Sxx:
00233c 15a2                      	cp r26, zero
00233d f051                      	breq sound_driver_channel4_fx_Sxx_invalid
00233e 91b0 281f                 	lds r27, song_speed
002340 17ab                      	cp r26, r27
002341 f430                      	brsh sound_driver_channel4_fx_Sxx_invalid
002342 93a0 2954                 	sts dpcm_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
002344 e0b1                      	ldi r27, 0x01
002345 93b0 294a                 	sts dpcm_pattern_delay_rows, r27
002347 c06e                      	rjmp sound_driver_calculate_delays
                                 sound_driver_channel4_fx_Sxx_invalid:
002348 cfa1                      	rjmp sound_driver_channel4_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel4_fx_Vxx: //duty
002349 cfa0                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Wxx: //DPCM sample speed
00234a cf9f                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Xxx: //DPCM sample retrigger
00234b cf9e                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Yxx: //DPCM sample offset
00234c cf9d                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Zxx: //DPCM sample delta counter
00234d cf9c                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_note:
00234e 9631                      	adiw Z, 1 //point to the byte next to the flag
00234f 90f4                      	lpm dpcm_period, Z //store the DPCM sample rate
002350 e3eb                      	ldi ZL, LOW(dpcm_samples) //point Z to dpcm_samples table
002351 e1f0                      	ldi ZH, HIGH(dpcm_samples)
002352 0feb                      	add ZL, r27 //point Z to offsetted sample
002353 1df2                      	adc ZH, zero
002354 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the samples's address
002355 1fff                      	rol ZH
002356 91a5                      	lpm r26, Z+ //r26:r27 now points to the sample
002357 91b4                      	lpm r27, Z
                                 
002358 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the sample's data
002359 1fbb                      	rol r27
00235a 2fea                      	mov ZL, r26
00235b 2ffb                      	mov ZH, r27
00235c 91b4                      	lpm r27, Z //get sample length
00235d ef70                      	ldi dpcm_length_LOW, 0b11110000
00235e e08f                      	ldi dpcm_length_HIGH, 0b00001111
00235f 95b2                      	swap r27
002360 237b                      	and dpcm_length_LOW, r27
002361 238b                      	and dpcm_length_HIGH, r27
                                 
002362 93e0 294e                 	sts dpcm_sample, ZL //store address to sample
002364 93f0 294f                 	sts dpcm_sample+1, ZH
002366 9230 2950                 	sts dpcm_sample_offset, one //start sample offset at 1 (0th byte was used for sample length)
002368 9220 2951                 	sts dpcm_sample_offset+1, zero
                                 
00236a d032                      	rcall sound_driver_channel4_increment_offset_twice
00236b cf7e                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_volume:
00236c d026                      	rcall sound_driver_channel4_increment_offset
00236d cf7c                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_delay:
00236e 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
00236f 93b0 294a                 	sts dpcm_pattern_delay_rows, r27
002371 d021                      	rcall sound_driver_channel4_increment_offset
002372 c034                      	rjmp sound_driver_channel4_end
                                 
                                 
                                 
                                 sound_driver_channel4_instrument_change:
002373 d029                      	rcall sound_driver_channel4_increment_offset_twice
002374 cf75                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_release:
002375 d01d                      	rcall sound_driver_channel4_increment_offset
002376 cf73                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_next_pattern:
002377 91e0 2819                 	lds ZL, song_frames
002379 91f0 281a                 	lds ZH, song_frames+1
00237b 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
00237d 91b0 281c                 	lds r27, song_frame_offset+1
00237f 93a0 281b                 	sts song_frame_offset, r26
002381 93b0 281c                 	sts song_frame_offset+1, r27
002383 9618                      	adiw r27:r26, 8 //offset for channel 4
002384 0fea                      	add ZL, r26
002385 1ffb                      	adc ZH, r27
                                 
002386 91a5                      	lpm r26, Z+ //load the address of the next pattern
002387 91b4                      	lpm r27, Z
002388 0faa                      	lsl r26
002389 1fbb                      	rol r27
00238a 93a0 2948                 	sts dpcm_pattern, r26
00238c 93b0 2949                 	sts dpcm_pattern+1, r27
                                 
00238e 9220 294c                 	sts dpcm_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
002390 9220 294d                 	sts dpcm_pattern_offset+1, zero
002392 cf57                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_increment_offset:
002393 91e0 294c                 	lds ZL, dpcm_pattern_offset //current offset in the pattern for dpcm
002395 91f0 294d                 	lds ZH, dpcm_pattern_offset+1
002397 9631                      	adiw Z, 1
002398 93e0 294c                 	sts dpcm_pattern_offset, ZL
00239a 93f0 294d                 	sts dpcm_pattern_offset+1, ZH
00239c 9508                      	ret
                                 
                                 sound_driver_channel4_increment_offset_twice: //used for data that takes up 2 bytes worth of space
00239d 91e0 294c                 	lds ZL, dpcm_pattern_offset //current offset in the pattern for dpcm
00239f 91f0 294d                 	lds ZH, dpcm_pattern_offset+1
0023a1 9632                      	adiw Z, 2 //increment the pointer twice
0023a2 93e0 294c                 	sts dpcm_pattern_offset, ZL
0023a4 93f0 294d                 	sts dpcm_pattern_offset+1, ZH
0023a6 9508                      	ret
                                 
                                 sound_driver_channel4_end:
                                 sound_driver_channel4_check_Sxx_invalid:
0023a7 efbf                      	ldi r27, 0xFF
0023a8 91a0 2955                 	lds r26, dpcm_fx_Sxx_post
0023aa 15a2                      	cp r26, zero //check if routine was called from calculate_delays due to invalid Sxx/Gxx
0023ab f419                      	brne sound_driver_channel4_check_Gxx_invalid
0023ac 93b0 2955                 	sts dpcm_fx_Sxx_post, r27
0023ae 9508                      	ret
                                 sound_driver_channel4_check_Gxx_invalid:
0023af 91a0 2953                 	lds r26, dpcm_fx_Gxx_post
0023b1 15a2                      	cp r26, zero
0023b2 f419                      	brne sound_driver_calculate_delays
0023b3 93b0 2953                 	sts dpcm_fx_Gxx_post, r27
0023b5 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_calculate_delays:
0023b6 91f0 281f                 	lds r31, song_speed
                                 
                                 sound_driver_calculate_delays_pulse1:
0023b8 91a0 2826                 	lds r26, pulse1_pattern_delay_frames
0023ba 11a2                      	cpse r26, zero
0023bb c044                      	rjmp sound_driver_calculate_delays_pulse2
0023bc c000                      	rjmp sound_driver_calculate_delays_pulse1_main
                                 
                                 sound_driver_calculate_delays_pulse1_main:
0023bd 2faf                      	mov r26, r31 //move speed into r26
0023be 91b0 2825                 	lds r27, pulse1_pattern_delay_rows //decrement the delay rows
0023c0 15b2                      	cp r27, zero
0023c1 f409                      	brne PC+2
0023c2 c03d                      	rjmp sound_driver_calculate_delays_pulse2
0023c3 95ba                      	dec r27
0023c4 93b0 2825                 	sts pulse1_pattern_delay_rows, r27
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx:
0023c6 efbf                      	ldi r27, 0xFF
0023c7 91c0 2872                 	lds r28, pulse1_fx_Sxx_pre
0023c9 91d0 2873                 	lds r29, pulse1_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse1_Sxx_check_pre:
0023cb 17cb                      	cp r28, r27
0023cc f009                      	breq sound_driver_calculate_delays_pulse1_Sxx_check_post
0023cd c00d                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_pre
                                 sound_driver_calculate_delays_pulse1_Sxx_check_post:
0023ce 17db                      	cp r29, r27
0023cf f009                      	breq sound_driver_calculate_delays_pulse1_Gxx
0023d0 c014                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx:
0023d1 91c0 2860                 	lds r28, pulse1_fx_Gxx_pre
0023d3 91d0 2861                 	lds r29, pulse1_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse1_Gxx_check_pre:
0023d5 17cb                      	cp r28, r27
0023d6 f009                      	breq sound_driver_calculate_delays_pulse1_Gxx_check_post
0023d7 c011                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_pre
                                 sound_driver_calculate_delays_pulse1_Gxx_check_post:
0023d8 17db                      	cp r29, r27
0023d9 f121                      	breq sound_driver_calculate_delays_pulse1_store
0023da c018                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_pre:
0023db 93b0 2872                 	sts pulse1_fx_Sxx_pre, r27
0023dd 1bac                      	sub r26, r28 //(song speed)-Sxx
0023de 93a0 2873                 	sts pulse1_fx_Sxx_post, r26
0023e0 93c0 2826                 	sts pulse1_pattern_delay_frames, r28
0023e2 11a2                      	cpse r26, zero
0023e3 c01c                      	rjmp sound_driver_calculate_delays_pulse2
0023e4 c012                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_Gxx_invalid
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_post:
0023e5 93b0 2873                 	sts pulse1_fx_Sxx_post, r27
0023e7 2fad                      	mov r26, r29
0023e8 c015                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx_pre:
0023e9 93b0 2860                 	sts pulse1_fx_Gxx_pre, r27
0023eb 1bac                      	sub r26, r28 //(song speed)-Gxx
0023ec 93a0 2861                 	sts pulse1_fx_Gxx_post, r26
0023ee 93c0 2826                 	sts pulse1_pattern_delay_frames, r28
0023f0 11a2                      	cpse r26, zero
0023f1 c00e                      	rjmp sound_driver_calculate_delays_pulse2
0023f2 c004                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_Gxx_invalid
                                 	
                                 sound_driver_calculate_delays_pulse1_Gxx_post:
0023f3 93b0 2861                 	sts pulse1_fx_Gxx_post, r27
0023f5 2fad                      	mov r26, r29
0023f6 c007                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_Gxx_invalid:
0023f7 9220 2826                 	sts pulse1_pattern_delay_frames, zero
0023f9 940e 1853                 	call sound_driver_channel0_main
0023fb 91f0 281f                 	lds r31, song_speed
0023fd cfba                      	rjmp sound_driver_calculate_delays_pulse1
                                 
                                 sound_driver_calculate_delays_pulse1_store:
0023fe 93a0 2826                 	sts pulse1_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_pulse2:
002400 91a0 2877                 	lds r26, pulse2_pattern_delay_frames
002402 11a2                      	cpse r26, zero
002403 c044                      	rjmp sound_driver_calculate_delays_triangle
002404 c000                      	rjmp sound_driver_calculate_delays_pulse2_main
                                 
                                 sound_driver_calculate_delays_pulse2_main:
002405 2faf                      	mov r26, r31 //move the speed to r26
002406 91b0 2876                 	lds r27, pulse2_pattern_delay_rows //decrement the delay rows
002408 15b2                      	cp r27, zero
002409 f409                      	brne PC+2
00240a c03d                      	rjmp sound_driver_calculate_delays_triangle
00240b 95ba                      	dec r27
00240c 93b0 2876                 	sts pulse2_pattern_delay_rows, r27
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx:
00240e efbf                      	ldi r27, 0xFF
00240f 91c0 28c3                 	lds r28, pulse2_fx_Sxx_pre
002411 91d0 28c4                 	lds r29, pulse2_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse2_Sxx_check_pre:
002413 17cb                      	cp r28, r27
002414 f009                      	breq sound_driver_calculate_delays_pulse2_Sxx_check_post
002415 c00d                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_pre
                                 sound_driver_calculate_delays_pulse2_Sxx_check_post:
002416 17db                      	cp r29, r27
002417 f009                      	breq sound_driver_calculate_delays_pulse2_Gxx
002418 c014                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx:
002419 91c0 28b1                 	lds r28, pulse2_fx_Gxx_pre
00241b 91d0 28b2                 	lds r29, pulse2_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse2_Gxx_check_pre:
00241d 17cb                      	cp r28, r27
00241e f009                      	breq sound_driver_calculate_delays_pulse2_Gxx_check_post
00241f c011                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_pre
                                 sound_driver_calculate_delays_pulse2_Gxx_check_post:
002420 17db                      	cp r29, r27
002421 f121                      	breq sound_driver_calculate_delays_pulse2_store
002422 c018                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_pre:
002423 93b0 28c3                 	sts pulse2_fx_Sxx_pre, r27
002425 1bac                      	sub r26, r28 //(song speed)-Sxx
002426 93a0 28c4                 	sts pulse2_fx_Sxx_post, r26
002428 93c0 2877                 	sts pulse2_pattern_delay_frames, r28
00242a 11a2                      	cpse r26, zero
00242b c01c                      	rjmp sound_driver_calculate_delays_triangle
00242c c012                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_Gxx_invalid
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_post:
00242d 93b0 28c4                 	sts pulse2_fx_Sxx_post, r27
00242f 2fad                      	mov r26, r29
002430 c015                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx_pre:
002431 93b0 28b1                 	sts pulse2_fx_Gxx_pre, r27
002433 1bac                      	sub r26, r28 //(song speed)-1-Gxx
002434 93a0 28b2                 	sts pulse2_fx_Gxx_post, r26
002436 93c0 2877                 	sts pulse2_pattern_delay_frames, r28
002438 11a2                      	cpse r26, zero
002439 c00e                      	rjmp sound_driver_calculate_delays_triangle
00243a c004                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_Gxx_invalid
                                 	
                                 sound_driver_calculate_delays_pulse2_Gxx_post:
00243b 93b0 28b2                 	sts pulse2_fx_Gxx_post, r27
00243d 2fad                      	mov r26, r29
00243e c007                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_Gxx_invalid:
00243f 9220 2877                 	sts pulse2_pattern_delay_frames, zero
002441 940e 1b50                 	call sound_driver_channel1_main
002443 91f0 281f                 	lds r31, song_speed
002445 cfba                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse2_store:
002446 93a0 2877                 	sts pulse2_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_triangle:
002448 91a0 28c8                 	lds r26, triangle_pattern_delay_frames
00244a 11a2                      	cpse r26, zero
00244b c044                      	rjmp sound_driver_calculate_delays_noise
00244c c000                      	rjmp sound_driver_calculate_delays_triangle_main
                                 
                                 sound_driver_calculate_delays_triangle_main:
00244d 2faf                      	mov r26, r31 //move the speed to r26
00244e 91b0 28c7                 	lds r27, triangle_pattern_delay_rows //decrement the delay rows
002450 15b2                      	cp r27, zero
002451 f409                      	brne PC+2
002452 c03d                      	rjmp sound_driver_calculate_delays_noise
002453 95ba                      	dec r27
002454 93b0 28c7                 	sts triangle_pattern_delay_rows, r27
                                 
                                 sound_driver_calculate_delays_triangle_Sxx:
002456 efbf                      	ldi r27, 0xFF
002457 91c0 290f                 	lds r28, triangle_fx_Sxx_pre
002459 91d0 2910                 	lds r29, triangle_fx_Sxx_post
                                 sound_driver_calculate_delays_triangle_Sxx_check_pre:
00245b 17cb                      	cp r28, r27
00245c f009                      	breq sound_driver_calculate_delays_triangle_Sxx_check_post
00245d c00d                      	rjmp sound_driver_calculate_delays_triangle_Sxx_pre
                                 sound_driver_calculate_delays_triangle_Sxx_check_post:
00245e 17db                      	cp r29, r27
00245f f009                      	breq sound_driver_calculate_delays_triangle_Gxx
002460 c014                      	rjmp sound_driver_calculate_delays_triangle_Sxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Gxx:
002461 91c0 28fd                 	lds r28, triangle_fx_Gxx_pre
002463 91d0 28fe                 	lds r29, triangle_fx_Gxx_post
                                 sound_driver_calculate_delays_triangle_Gxx_check_pre:
002465 17cb                      	cp r28, r27
002466 f009                      	breq sound_driver_calculate_delays_triangle_Gxx_check_post
002467 c011                      	rjmp sound_driver_calculate_delays_triangle_Gxx_pre
                                 sound_driver_calculate_delays_triangle_Gxx_check_post:
002468 17db                      	cp r29, r27
002469 f121                      	breq sound_driver_calculate_delays_triangle_store
00246a c018                      	rjmp sound_driver_calculate_delays_triangle_Gxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_pre:
00246b 93b0 290f                 	sts triangle_fx_Sxx_pre, r27
00246d 1bac                      	sub r26, r28 //(song speed)-Sxx
00246e 93a0 2910                 	sts triangle_fx_Sxx_post, r26
002470 93c0 28c8                 	sts triangle_pattern_delay_frames, r28
002472 11a2                      	cpse r26, zero
002473 c01c                      	rjmp sound_driver_calculate_delays_noise
002474 c012                      	rjmp sound_driver_calculate_delays_triangle_Sxx_Gxx_invalid
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_post:
002475 93b0 2910                 	sts triangle_fx_Sxx_post, r27
002477 2fad                      	mov r26, r29
002478 c015                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_Gxx_pre:
002479 93b0 28fd                 	sts triangle_fx_Gxx_pre, r27
00247b 1bac                      	sub r26, r28 //(song speed)-Gxx
00247c 93a0 28fe                 	sts triangle_fx_Gxx_post, r26
00247e 93c0 28c8                 	sts triangle_pattern_delay_frames, r28
002480 11a2                      	cpse r26, zero
002481 c00e                      	rjmp sound_driver_calculate_delays_noise
002482 c004                      	rjmp sound_driver_calculate_delays_triangle_Sxx_Gxx_invalid
                                 	
                                 sound_driver_calculate_delays_triangle_Gxx_post:
002483 93b0 28fe                 	sts triangle_fx_Gxx_post, r27
002485 2fad                      	mov r26, r29
002486 c007                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_Gxx_invalid:
002487 9220 28c8                 	sts triangle_pattern_delay_frames, zero
002489 940e 1e40                 	call sound_driver_channel2_main
00248b 91f0 281f                 	lds r31, song_speed
00248d cfba                      	rjmp sound_driver_calculate_delays_triangle
                                 
                                 sound_driver_calculate_delays_triangle_store:
00248e 93a0 28c8                 	sts triangle_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_noise:
002490 91a0 2914                 	lds r26, noise_pattern_delay_frames
002492 11a2                      	cpse r26, zero
002493 c044                      	rjmp sound_driver_calculate_delays_dpcm
002494 c000                      	rjmp sound_driver_calculate_delays_noise_main
                                 
                                 sound_driver_calculate_delays_noise_main:
002495 2faf                      	mov r26, r31 //move the speed to r26
002496 91b0 2913                 	lds r27, noise_pattern_delay_rows //decrement the delay rows
002498 15b2                      	cp r27, zero
002499 f409                      	brne PC+2
00249a c03d                      	rjmp sound_driver_calculate_delays_dpcm
00249b 95ba                      	dec r27
00249c 93b0 2913                 	sts noise_pattern_delay_rows, r27
                                 
                                 sound_driver_calculate_delays_noise_Sxx:
00249e efbf                      	ldi r27, 0xFF
00249f 91c0 2946                 	lds r28, noise_fx_Sxx_pre
0024a1 91d0 2947                 	lds r29, noise_fx_Sxx_post
                                 sound_driver_calculate_delays_noise_Sxx_check_pre:
0024a3 17cb                      	cp r28, r27
0024a4 f009                      	breq sound_driver_calculate_delays_noise_Sxx_check_post
0024a5 c00d                      	rjmp sound_driver_calculate_delays_noise_Sxx_pre
                                 sound_driver_calculate_delays_noise_Sxx_check_post:
0024a6 17db                      	cp r29, r27
0024a7 f009                      	breq sound_driver_calculate_delays_noise_Gxx
0024a8 c014                      	rjmp sound_driver_calculate_delays_noise_Sxx_post
                                 
                                 sound_driver_calculate_delays_noise_Gxx:
0024a9 91c0 2943                 	lds r28, noise_fx_Gxx_pre
0024ab 91d0 2944                 	lds r29, noise_fx_Gxx_post
                                 sound_driver_calculate_delays_noise_Gxx_check_pre:
0024ad 17cb                      	cp r28, r27
0024ae f009                      	breq sound_driver_calculate_delays_noise_Gxx_check_post
0024af c011                      	rjmp sound_driver_calculate_delays_noise_Gxx_pre
                                 sound_driver_calculate_delays_noise_Gxx_check_post:
0024b0 17db                      	cp r29, r27
0024b1 f121                      	breq sound_driver_calculate_delays_noise_store
0024b2 c018                      	rjmp sound_driver_calculate_delays_noise_Gxx_post
                                 
                                 sound_driver_calculate_delays_noise_Sxx_pre:
0024b3 93b0 2946                 	sts noise_fx_Sxx_pre, r27
0024b5 1bac                      	sub r26, r28 //(song speed)-Sxx
0024b6 93a0 2947                 	sts noise_fx_Sxx_post, r26
0024b8 93c0 2914                 	sts noise_pattern_delay_frames, r28
0024ba 11a2                      	cpse r26, zero
0024bb c01c                      	rjmp sound_driver_calculate_delays_dpcm
0024bc c012                      	rjmp sound_driver_calculate_delays_noise_Sxx_Gxx_invalid
                                 
                                 sound_driver_calculate_delays_noise_Sxx_post:
0024bd 93b0 2947                 	sts noise_fx_Sxx_post, r27
0024bf 2fad                      	mov r26, r29
0024c0 c015                      	rjmp sound_driver_calculate_delays_noise_store
                                 
                                 sound_driver_calculate_delays_noise_Gxx_pre:
0024c1 93b0 2943                 	sts noise_fx_Gxx_pre, r27
0024c3 1bac                      	sub r26, r28 //(song speed)-Gxx
0024c4 93a0 2944                 	sts noise_fx_Gxx_post, r26
0024c6 93c0 2914                 	sts noise_pattern_delay_frames, r28
0024c8 11a2                      	cpse r26, zero
0024c9 c00e                      	rjmp sound_driver_calculate_delays_dpcm
0024ca c004                      	rjmp sound_driver_calculate_delays_noise_Sxx_Gxx_invalid
                                 	
                                 sound_driver_calculate_delays_noise_Gxx_post:
0024cb 93b0 2944                 	sts noise_fx_Gxx_post, r27
0024cd 2fad                      	mov r26, r29
0024ce c007                      	rjmp sound_driver_calculate_delays_noise_store
                                 
                                 sound_driver_calculate_delays_noise_Sxx_Gxx_invalid:
0024cf 9220 2914                 	sts noise_pattern_delay_frames, zero
0024d1 940e 2118                 	call sound_driver_channel3_main
0024d3 91f0 281f                 	lds r31, song_speed
0024d5 cfba                      	rjmp sound_driver_calculate_delays_noise
                                 
                                 sound_driver_calculate_delays_noise_store:
0024d6 93a0 2914                 	sts noise_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_dpcm:
0024d8 91a0 294b                 	lds r26, dpcm_pattern_delay_frames
0024da 11a2                      	cpse r26, zero
0024db c044                      	rjmp sound_driver_instrument_fx_routine
0024dc c000                      	rjmp sound_driver_calculate_delays_dpcm_main
                                 
                                 sound_driver_calculate_delays_dpcm_main:
0024dd 2faf                      	mov r26, r31 //move the speed to r26
0024de 91b0 294a                 	lds r27, dpcm_pattern_delay_rows //decrement the delay rows
0024e0 15b2                      	cp r27, zero
0024e1 f409                      	brne PC+2
0024e2 c03d                      	rjmp sound_driver_instrument_fx_routine
0024e3 95ba                      	dec r27
0024e4 93b0 294a                 	sts dpcm_pattern_delay_rows, r27
                                 
                                 sound_driver_calculate_delays_dpcm_Sxx:
0024e6 efbf                      	ldi r27, 0xFF
0024e7 91c0 2954                 	lds r28, dpcm_fx_Sxx_pre
0024e9 91d0 2955                 	lds r29, dpcm_fx_Sxx_post
                                 sound_driver_calculate_delays_dpcm_Sxx_check_pre:
0024eb 17cb                      	cp r28, r27
0024ec f009                      	breq sound_driver_calculate_delays_dpcm_Sxx_check_post
0024ed c00d                      	rjmp sound_driver_calculate_delays_dpcm_Sxx_pre
                                 sound_driver_calculate_delays_dpcm_Sxx_check_post:
0024ee 17db                      	cp r29, r27
0024ef f009                      	breq sound_driver_calculate_delays_dpcm_Gxx
0024f0 c014                      	rjmp sound_driver_calculate_delays_dpcm_Sxx_post
                                 
                                 sound_driver_calculate_delays_dpcm_Gxx:
0024f1 91c0 2952                 	lds r28, dpcm_fx_Gxx_pre
0024f3 91d0 2953                 	lds r29, dpcm_fx_Gxx_post
                                 sound_driver_calculate_delays_dpcm_Gxx_check_pre:
0024f5 17cb                      	cp r28, r27
0024f6 f009                      	breq sound_driver_calculate_delays_dpcm_Gxx_check_post
0024f7 c011                      	rjmp sound_driver_calculate_delays_dpcm_Gxx_pre
                                 sound_driver_calculate_delays_dpcm_Gxx_check_post:
0024f8 17db                      	cp r29, r27
0024f9 f121                      	breq sound_driver_calculate_delays_dpcm_store
0024fa c018                      	rjmp sound_driver_calculate_delays_dpcm_Gxx_post
                                 
                                 sound_driver_calculate_delays_dpcm_Sxx_pre:
0024fb 93b0 2954                 	sts dpcm_fx_Sxx_pre, r27
0024fd 1bac                      	sub r26, r28 //(song speed)-Sxx
0024fe 93a0 2955                 	sts dpcm_fx_Sxx_post, r26
002500 93c0 294b                 	sts dpcm_pattern_delay_frames, r28
002502 11a2                      	cpse r26, zero
002503 c01c                      	rjmp sound_driver_instrument_fx_routine
002504 c012                      	rjmp sound_driver_calculate_delays_dpcm_Sxx_Gxx_invalid
                                 
                                 sound_driver_calculate_delays_dpcm_Sxx_post:
002505 93b0 2955                 	sts dpcm_fx_Sxx_post, r27
002507 2fad                      	mov r26, r29
002508 c015                      	rjmp sound_driver_calculate_delays_dpcm_store
                                 
                                 sound_driver_calculate_delays_dpcm_Gxx_pre:
002509 93b0 2952                 	sts dpcm_fx_Gxx_pre, r27
00250b 1bac                      	sub r26, r28 //(song speed)-Gxx
00250c 93a0 2953                 	sts dpcm_fx_Gxx_post, r26
00250e 93c0 294b                 	sts dpcm_pattern_delay_frames, r28
002510 11a2                      	cpse r26, zero
002511 c00e                      	rjmp sound_driver_instrument_fx_routine
002512 c004                      	rjmp sound_driver_calculate_delays_dpcm_Sxx_Gxx_invalid
                                 	
                                 sound_driver_calculate_delays_dpcm_Gxx_post:
002513 93b0 2953                 	sts dpcm_fx_Gxx_post, r27
002515 2fad                      	mov r26, r29
002516 c007                      	rjmp sound_driver_calculate_delays_dpcm_store
                                 
                                 sound_driver_calculate_delays_dpcm_Sxx_Gxx_invalid:
002517 9220 294b                 	sts dpcm_pattern_delay_frames, zero
002519 940e 22ea                 	call sound_driver_channel4_main
00251b 91f0 281f                 	lds r31, song_speed
00251d cfba                      	rjmp sound_driver_calculate_delays_dpcm
                                 
                                 sound_driver_calculate_delays_dpcm_store:
00251e 93a0 294b                 	sts dpcm_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_instrument_fx_routine:
                                 sound_driver_instrument_routine_channel0_volume:
002520 91e0 2829                 	lds ZL, pulse1_volume_macro
002522 91f0 282a                 	lds ZH, pulse1_volume_macro+1
002524 9630                      	adiw Z, 0
002525 f1a1                      	breq sound_driver_instrument_routine_channel0_volume_default //if no volume macro is in use, use default multiplier of F
002526 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002527 1fff                      	rol ZH
002528 91a0 282b                 	lds r26, pulse1_volume_macro_offset
00252a 0fea                      	add ZL, r26
00252b 1df2                      	adc ZH, zero
                                 
00252c 91b0 282d                 	lds r27, pulse1_volume_macro_release
00252e 17ba                      	cp r27, r26
00252f f429                      	brne sound_driver_instrument_routine_channel0_volume_increment //if the current offset is not equal to the release index, increment the offset
002530 91a0 282c                 	lds r26, pulse1_volume_macro_loop
002532 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002533 f010                      	brlo sound_driver_instrument_routine_channel0_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002534 c003                      	rjmp sound_driver_instrument_routine_channel0_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_volume_increment:
002535 95a3                      	inc r26 //increment the macro offset
002536 93a0 282b                 	sts pulse1_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_volume_read:
002538 91b4                      	lpm r27, Z //load volume data into r27
002539 3fbf                      	cpi r27, 0xFF //check for macro end flag
00253a f469                      	brne sound_driver_instrument_routine_channel0_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_release:
00253b 91b0 282d                 	lds r27, pulse1_volume_macro_release
00253d 3fbf                      	cpi r27, 0xFF
00253e f429                      	brne sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_loop:
00253f 91b0 282c                 	lds r27, pulse1_volume_macro_loop //load the loop index
002541 93b0 282b                 	sts pulse1_volume_macro_offset, r27 //store the loop index into the offset
002543 cfdc                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index:
002544 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002545 93a0 282b                 	sts pulse1_volume_macro_offset, r26
002547 cfd8                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_calculate:
002548 eaea                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
002549 e6f2                      	ldi ZH, HIGH(volumes << 1)
00254a 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
00254b 0feb                      	add ZL, r27 //add offset to the table
00254c 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel0_volume_load:
00254d 91b0 2800                 	lds r27, pulse1_param //load main volume
00254f 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002550 91a0 285e                 	lds r26, pulse1_fx_7xy_value
002552 30a0                      	cpi r26, 0x00
002553 f481                      	brne sound_driver_instrument_routine_channel0_volume_load_7xy
                                 
002554 0feb                      	add ZL, r27 //offset the volume table by the main volume
002555 1df2                      	adc ZH, zero
002556 91b4                      	lpm r27, Z
002557 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
002559 c023                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default:
00255a 91b0 2800                 	lds r27, pulse1_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
00255c 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
00255d 91a0 285e                 	lds r26, pulse1_fx_7xy_value
00255f 30a0                      	cpi r26, 0x00
002560 f499                      	brne sound_driver_instrument_routine_channel0_volume_default_7xy
002561 93b0 2806                 	sts pulse1_output_volume, r27
002563 c019                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy:
002564 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002565 f038                      	brcs sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
002566 f031                      	breq sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
                                 
002567 0feb                      	add ZL, r27 //offset the volume table by the main volume
002568 1df2                      	adc ZH, zero
002569 91b4                      	lpm r27, Z
00256a 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
00256c c010                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy_overflow:
00256d e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
00256e 0feb                      	add ZL, r27 //offset the volume table by the main volume
00256f 1df2                      	adc ZH, zero
002570 91b4                      	lpm r27, Z
002571 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
002573 c009                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default_7xy:
002574 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002575 f020                      	brcs sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
002576 f019                      	breq sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
002577 93b0 2806                 	sts pulse1_output_volume, r27
002579 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel0_volume_default_7xy_overflow:
00257a e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
00257b 93b0 2806                 	sts pulse1_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
00257d 91e0 282e                 	lds ZL, pulse1_arpeggio_macro
00257f 91f0 282f                 	lds ZH, pulse1_arpeggio_macro+1
002581 9630                      	adiw Z, 0
002582 f1d9                      	breq sound_driver_instrument_routine_channel0_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002583 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002584 1fff                      	rol ZH
002585 91a0 2830                 	lds r26, pulse1_arpeggio_macro_offset
002587 0fea                      	add ZL, r26
002588 1df2                      	adc ZH, zero
                                 
002589 91b0 2832                 	lds r27, pulse1_arpeggio_macro_release
00258b 17ba                      	cp r27, r26
00258c f429                      	brne sound_driver_instrument_routine_channel0_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
00258d 91a0 2831                 	lds r26, pulse1_arpeggio_macro_loop
00258f 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002590 f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002591 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_increment:
002592 95a3                      	inc r26 //increment the macro offset
002593 93a0 2830                 	sts pulse1_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_read:
002595 91b4                      	lpm r27, Z //load arpeggio data into r27
002596 38b0                      	cpi r27, 0x80 //check for macro end flag
002597 f009                      	breq sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag
002598 c041                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_check_mode:
002599 50a1                      	subi r26, 1 //keep the offset at the end flag
00259a 93a0 2830                 	sts pulse1_arpeggio_macro_offset, r26
00259c 91b0 2833                 	lds r27, pulse1_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
00259e 30b1                      	cpi r27, 0x01
00259f f048                      	brlo sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_release:
0025a0 91b0 2832                 	lds r27, pulse1_arpeggio_macro_release
0025a2 3fbf                      	cpi r27, 0xFF
0025a3 f4d1                      	brne sound_driver_instrument_routine_channel0_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_loop:
0025a4 91b0 2831                 	lds r27, pulse1_arpeggio_macro_loop
0025a6 3fbf                      	cpi r27, 0xFF
0025a7 f499                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
0025a8 c015                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute:
0025a9 91b0 2832                 	lds r27, pulse1_arpeggio_macro_release
0025ab 3fbf                      	cpi r27, 0xFF
0025ac f421                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_check_loop:
0025ad 91b0 2831                 	lds r27, pulse1_arpeggio_macro_loop //load the loop index
0025af 3fbf                      	cpi r27, 0xFF //check if loop flag exists
0025b0 f451                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop:
0025b1 91c0 2846                 	lds r28, pulse1_fx_0xy_sequence //check for 0xy effect
0025b3 91d0 2847                 	lds r29, pulse1_fx_0xy_sequence+1
0025b5 9620                      	adiw r29:r28, 0
0025b6 f469                      	brne sound_driver_instrument_routine_channel0_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
0025b7 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
0025b8 93a0 2830                 	sts pulse1_arpeggio_macro_offset, r26 //store the last valid index into the offset
0025ba cfc2                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload:
0025bb 93b0 2830                 	sts pulse1_arpeggio_macro_offset, r27 //store the loop index into the offset
0025bd cfbf                      	rjmp sound_driver_instrument_routine_channel0_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_default:
0025be 91c0 2846                 	lds r28, pulse1_fx_0xy_sequence //load 0xy effect
0025c0 91d0 2847                 	lds r29, pulse1_fx_0xy_sequence+1
0025c2 9620                      	adiw r29:r28, 0 //check for 0xy effect
0025c3 f099                      	breq sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel0_arpeggio_default_0xy:
0025c4 95d6                      	lsr r29
0025c5 95c7                      	ror r28
0025c6 95d7                      	ror r29
0025c7 95c7                      	ror r28
0025c8 95d7                      	ror r29
0025c9 95c7                      	ror r28
0025ca 95d7                      	ror r29
0025cb 95c7                      	ror r28
0025cc 95d7                      	ror r29
0025cd 95d2                      	swap r29
                                 
0025ce 93c0 2846                 	sts pulse1_fx_0xy_sequence, r28 //store the rolled sequence
0025d0 93d0 2847                 	sts pulse1_fx_0xy_sequence+1, r29
0025d2 70cf                      	andi r28, 0x0F //mask out the 4 LSB
0025d3 91a0 2807                 	lds r26, pulse1_note //load the current note index
0025d5 0fac                      	add r26, r28 //add the note offset
0025d6 c02e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
0025d7 91a0 2807                 	lds r26, pulse1_note //load the current note index
0025d9 c02b                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process:
0025da 9220 2834                 	sts pulse1_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
0025dc 9220 2835                 	sts pulse1_total_pitch_offset+1, zero
0025de 9220 283b                 	sts pulse1_total_hi_pitch_offset, zero
0025e0 91a0 2833                 	lds r26, pulse1_arpeggio_macro_mode
0025e2 30a1                      	cpi r26, 0x01 //absolute mode
0025e3 f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_absolute
0025e4 f069                      	breq sound_driver_instrument_routine_channel0_arpeggio_process_fixed
0025e5 c00e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute:
0025e6 91a0 2807                 	lds r26, pulse1_note //load the current note index
0025e8 0fab                      	add r26, r27 //offset the note with the arpeggio data
0025e9 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0025ea c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_add:
0025eb 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0025ec f0c0                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
0025ed e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0025ee c016                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract:
0025ef fda7                      	sbrc r26, 7 //check if result is negative
0025f0 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0025f1 c013                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_fixed:
0025f2 2fab                      	mov r26, r27 //move the arpeggio data into r26
0025f3 c011                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative:
0025f4 91a0 2807                 	lds r26, pulse1_note //load the current note index
0025f6 0fab                      	add r26, r27 //offset the note with the arpeggio data
0025f7 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0025f8 c008                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_add:
0025f9 93a0 2807                 	sts pulse1_note, r26 //NOTE: relative mode modifies the original note index
0025fb 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0025fc f040                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
0025fd e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0025fe 93a0 2807                 	sts pulse1_note, r26
002600 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract:
002601 fda7                      	sbrc r26, 7 //check if result is negative
002602 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002603 93a0 2807                 	sts pulse1_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_load:
002605 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
002606 e0f0                      	ldi ZH, HIGH(note_table << 1)
002607 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002608 0fea                      	add ZL, r26 //add offset
002609 1df2                      	adc ZH, zero
00260a 91a5                      	lpm r26, Z+ //load bytes
00260b 91b4                      	lpm r27, Z
00260c 93a0 0a8c                 	sts TCB0_CCMPL, r26 //load the LOW bits for timer
00260e 93b0 0a8d                 	sts TCB0_CCMPH, r27 //load the HIGH bits for timer
002610 93a0 2852                 	sts pulse1_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002612 93b0 2853                 	sts pulse1_fx_3xx_target+1, r27
002614 c000                      	rjmp sound_driver_instrument_routine_channel0_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch:
002615 91e0 2836                 	lds ZL, pulse1_pitch_macro
002617 91f0 2837                 	lds ZH, pulse1_pitch_macro+1
002619 9630                      	adiw Z, 0
00261a f409                      	brne sound_driver_instrument_routine_channel0_pitch_continue
00261b c023                      	rjmp sound_driver_instrument_routine_channel0_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel0_pitch_continue:
00261c 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00261d 1fff                      	rol ZH
00261e 91a0 2838                 	lds r26, pulse1_pitch_macro_offset
002620 0fea                      	add ZL, r26
002621 1df2                      	adc ZH, zero
                                 
002622 91b0 283a                 	lds r27, pulse1_pitch_macro_release
002624 17ba                      	cp r27, r26
002625 f429                      	brne sound_driver_instrument_routine_channel0_pitch_increment //if the current offset is not equal to the release index, increment the offset
002626 91a0 2839                 	lds r26, pulse1_pitch_macro_loop
002628 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002629 f010                      	brlo sound_driver_instrument_routine_channel0_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00262a c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_pitch_increment:
00262b 95a3                      	inc r26 //increment the macro offset
00262c 93a0 2838                 	sts pulse1_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_pitch_read:
00262e 91b4                      	lpm r27, Z //load pitch data into r27
00262f 38b0                      	cpi r27, 0x80 //check for macro end flag
002630 f479                      	brne sound_driver_instrument_routine_channel0_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_release:
002631 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002632 93a0 2838                 	sts pulse1_pitch_macro_offset, r26
002634 91b0 283a                 	lds r27, pulse1_pitch_macro_release
002636 3fbf                      	cpi r27, 0xFF
002637 f439                      	brne sound_driver_instrument_routine_channel0_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_loop:
002638 91b0 2839                 	lds r27, pulse1_pitch_macro_loop //load the loop index
00263a 3fbf                      	cpi r27, 0xFF //check if there is a loop index
00263b f019                      	breq sound_driver_instrument_routine_channel0_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
00263c 93b0 2838                 	sts pulse1_pitch_macro_offset, r27 //store the loop index into the offset
00263e cfd6                      	rjmp sound_driver_instrument_routine_channel0_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_default:
00263f e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel0_pitch_calculate:
002640 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002641 937f                      	push r23
002642 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
002643 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002644 0367                      	mulsu r22, r23
002645 917f                      	pop r23
002646 916f                      	pop r22
                                 
002647 9416                      	lsr r1 //shift out the fractional bits
002648 9407                      	ror r0
002649 9416                      	lsr r1
00264a 9407                      	ror r0
00264b 9416                      	lsr r1
00264c 9407                      	ror r0
00264d 9416                      	lsr r1
00264e 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_check_negative:
00264f fe13                      	sbrs r1, 3 //check if result was a negative number
002650 c007                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_negative:
002651 efc0                      	ldi r28, 0xF0
002652 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_check_divisible_8:
002653 70b7                      	andi r27, 0b00000111
002654 f019                      	breq sound_driver_instrument_routine_channel0_pitch_calculate_offset
                                 
002655 e0b1                      	ldi r27, 0x01
002656 0e0b                      	add r0, r27
002657 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_offset:
002658 91a0 2834                 	lds r26, pulse1_total_pitch_offset
00265a 91b0 2835                 	lds r27, pulse1_total_pitch_offset+1
00265c 0e0a                      	add r0, r26
00265d 1e1b                      	adc r1, r27
00265e 9200 2834                 	sts pulse1_total_pitch_offset, r0
002660 9210 2835                 	sts pulse1_total_pitch_offset+1, r1
002662 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
002664 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
002666 0da0                      	add r26, r0 //offset the timer values
002667 1db1                      	adc r27, r1
                                 	
002668 91c0 284a                 	lds r28, pulse1_fx_1xx_total
00266a 91d0 284b                 	lds r29, pulse1_fx_1xx_total+1
00266c 1bac                      	sub r26, r28
00266d 0bbd                      	sbc r27, r29
00266e 91c0 284e                 	lds r28, pulse1_fx_2xx_total
002670 91d0 284f                 	lds r29, pulse1_fx_2xx_total+1
002672 0fac                      	add r26, r28
002673 1fbd                      	adc r27, r29
002674 91c0 2862                 	lds r28, pulse1_fx_Pxx_total
002676 91d0 2863                 	lds r29, pulse1_fx_Pxx_total+1
002678 0fac                      	add r26, r28
002679 1fbd                      	adc r27, r29
00267a 91c0 2869                 	lds r28, pulse1_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
00267c 91d0 286a                 	lds r29, pulse1_fx_Qxy_total_offset+1
00267e 1bac                      	sub r26, r28
00267f 0bbd                      	sbc r27, r29
002680 91c0 2870                 	lds r28, pulse1_fx_Rxy_total_offset
002682 91d0 2871                 	lds r29, pulse1_fx_Rxy_total_offset+1
002684 0fac                      	add r26, r28
002685 1fbd                      	adc r27, r29
                                 
002686 e5c9                      	ldi r28, 0x59
002687 e0d0                      	ldi r29, 0x00
002688 17ac                      	cp r26, r28
002689 07bd                      	cpc r27, r29
00268a f030                      	brlo sound_driver_instrument_routine_channel0_pitch_min
                                 
00268b e5ca                      	ldi r28, 0x5A
00268c e5d9                      	ldi r29, 0x59
00268d 17ac                      	cp r26, r28
00268e 07bd                      	cpc r27, r29
00268f f420                      	brsh sound_driver_instrument_routine_channel0_pitch_max
002690 c006                      	rjmp sound_driver_instrument_routine_channel0_pitch_store
                                 
                                 sound_driver_instrument_routine_channel0_pitch_min:
002691 e5c9                      	ldi r28, 0x59
002692 e0d0                      	ldi r29, 0x00
002693 c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_store
                                 
                                 sound_driver_instrument_routine_channel0_pitch_max:
002694 e5c9                      	ldi r28, 0x59
002695 e5d9                      	ldi r29, 0x59
002696 c000                      	rjmp sound_driver_instrument_routine_channel0_pitch_store
                                 
                                 sound_driver_instrument_routine_channel0_pitch_store:
002697 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
002699 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel0_hi_pitch:
00269b 91e0 283c                 	lds ZL, pulse1_hi_pitch_macro
00269d 91f0 283d                 	lds ZH, pulse1_hi_pitch_macro+1
00269f 9630                      	adiw Z, 0
0026a0 f409                      	brne sound_driver_instrument_routine_channel0_hi_pitch_continue
0026a1 c03c                      	rjmp sound_driver_instrument_routine_channel0_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel0_hi_pitch_continue:
0026a2 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0026a3 1fff                      	rol ZH
0026a4 91a0 283e                 	lds r26, pulse1_hi_pitch_macro_offset
0026a6 0fea                      	add ZL, r26
0026a7 1df2                      	adc ZH, zero
                                 
0026a8 91b0 2840                 	lds r27, pulse1_hi_pitch_macro_release
0026aa 17ba                      	cp r27, r26
0026ab f429                      	brne sound_driver_instrument_routine_channel0_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
0026ac 91a0 283f                 	lds r26, pulse1_hi_pitch_macro_loop
0026ae 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0026af f010                      	brlo sound_driver_instrument_routine_channel0_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0026b0 c003                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_increment:
0026b1 95a3                      	inc r26 //increment the macro offset
0026b2 93a0 283e                 	sts pulse1_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_hi_pitch_read:
0026b4 91b4                      	lpm r27, Z //load hi pitch data into r27
0026b5 38b0                      	cpi r27, 0x80 //check for macro end flag
0026b6 f489                      	brne sound_driver_instrument_routine_channel0_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_release:
0026b7 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0026b8 93a0 283e                 	sts pulse1_hi_pitch_macro_offset, r26
0026ba 91b0 2840                 	lds r27, pulse1_hi_pitch_macro_release
0026bc 3fbf                      	cpi r27, 0xFF
0026bd f439                      	brne sound_driver_instrument_routine_channel0_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_loop:
0026be 91b0 283f                 	lds r27, pulse1_hi_pitch_macro_loop //load the loop index
0026c0 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0026c1 f019                      	breq sound_driver_instrument_routine_channel0_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
0026c2 93b0 283e                 	sts pulse1_hi_pitch_macro_offset, r27 //store the loop index into the offset
0026c4 cfd6                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_default:
0026c5 91b0 283b                 	lds r27, pulse1_total_hi_pitch_offset
0026c7 c005                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate:
0026c8 91a0 283b                 	lds r26, pulse1_total_hi_pitch_offset //load the total hi pitch offset to change
0026ca 0fba                      	add r27, r26
0026cb 93b0 283b                 	sts pulse1_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply:
0026cd 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0026ce 937f                      	push r23
0026cf 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
0026d0 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0026d1 0367                      	mulsu r22, r23
0026d2 917f                      	pop r23
0026d3 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_offset:
0026d4 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
0026d6 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
0026d8 0da0                      	add r26, r0 //offset the timer values
0026d9 1db1                      	adc r27, r1
0026da 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
0026dc 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel0_duty:
0026de 91e0 2841                 	lds ZL, pulse1_duty_macro
0026e0 91f0 2842                 	lds ZH, pulse1_duty_macro+1
0026e2 9630                      	adiw Z, 0
0026e3 f1b1                      	breq sound_driver_channel0_fx_routines //if no duty macro is in use, go to the next routine
0026e4 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0026e5 1fff                      	rol ZH
0026e6 91a0 2843                 	lds r26, pulse1_duty_macro_offset
0026e8 0fea                      	add ZL, r26
0026e9 1df2                      	adc ZH, zero
                                 
0026ea 91b0 2845                 	lds r27, pulse1_duty_macro_release
0026ec 17ba                      	cp r27, r26
0026ed f429                      	brne sound_driver_instrument_routine_channel0_duty_increment //if the current offset is not equal to the release index, increment the offset
0026ee 91a0 2844                 	lds r26, pulse1_duty_macro_loop
0026f0 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0026f1 f010                      	brlo sound_driver_instrument_routine_channel0_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0026f2 c027                      	rjmp sound_driver_channel0_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel0_duty_increment:
0026f3 95a3                      	inc r26 //increment the macro offset
0026f4 93a0 2843                 	sts pulse1_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_duty_read:
0026f6 91b4                      	lpm r27, Z //load pitch data into r27
0026f7 3fbf                      	cpi r27, 0xFF //check for macro end flag
0026f8 f471                      	brne sound_driver_instrument_routine_channel0_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_release:
0026f9 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0026fa 93a0 2843                 	sts pulse1_duty_macro_offset, r26
0026fc 91b0 2845                 	lds r27, pulse1_duty_macro_release
0026fe 3fbf                      	cpi r27, 0xFF
0026ff f4d1                      	brne sound_driver_channel0_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_loop:
002700 91b0 2844                 	lds r27, pulse1_duty_macro_loop //load the loop index
002702 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002703 f0b1                      	breq sound_driver_channel0_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
002704 93b0 2843                 	sts pulse1_duty_macro_offset, r27 //store the loop index into the offset
002706 cfd7                      	rjmp sound_driver_instrument_routine_channel0_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_load:
002707 eae2                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
002708 e6f1                      	ldi ZH, HIGH(sequences << 1)
002709 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
00270a 1df2                      	adc ZH, zero
                                 
00270b 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
00270c 95b7                      	ror r27
00270d 95b7                      	ror r27
00270e 91a0 2800                 	lds r26, pulse1_param //load r26 with pulse1_param (register $4000)
002710 2fca                      	mov r28, r26 //store a copy of pulse1_param into r28
002711 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
002712 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
002713 c001                      	rjmp sound_driver_instrument_routine_channel0_duty_load_store
002714 c005                      	rjmp sound_driver_channel0_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel0_duty_load_store:
002715 9074                      	lpm pulse1_sequence, Z //store the sequence
                                 
002716 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
002717 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
002718 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_routines:
                                 sound_driver_channel0_fx_1xx_routine:
00271a 91e0 2848                 	lds ZL, pulse1_fx_1xx
00271c 91f0 2849                 	lds ZH, pulse1_fx_1xx+1
00271e 9630                      	adiw Z, 0
00271f f051                      	breq sound_driver_channel0_fx_2xx_routine
                                 
002720 91a0 284a                 	lds r26, pulse1_fx_1xx_total //load the rate to change the pitch by
002722 91b0 284b                 	lds r27, pulse1_fx_1xx_total+1
002724 0fae                      	add r26, ZL //increase the total offset by the rate
002725 1fbf                      	adc r27, ZH
002726 93a0 284a                 	sts pulse1_fx_1xx_total, r26
002728 93b0 284b                 	sts pulse1_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_2xx_routine:
00272a 91e0 284c                 	lds ZL, pulse1_fx_2xx
00272c 91f0 284d                 	lds ZH, pulse1_fx_2xx+1
00272e 9630                      	adiw Z, 0
00272f f051                      	breq sound_driver_channel0_fx_3xx_routine
                                 
002730 91a0 284e                 	lds r26, pulse1_fx_2xx_total //load the rate to change the pitch by
002732 91b0 284f                 	lds r27, pulse1_fx_2xx_total+1
002734 0fae                      	add r26, ZL //increase the total offset by the rate
002735 1fbf                      	adc r27, ZH
002736 93a0 284e                 	sts pulse1_fx_2xx_total, r26
002738 93b0 284f                 	sts pulse1_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_3xx_routine:
00273a 91e0 2854                 	lds ZL, pulse1_fx_3xx_speed
00273c 91f0 2855                 	lds ZH, pulse1_fx_3xx_speed+1
00273e 9630                      	adiw Z, 0
00273f f409                      	brne sound_driver_channel0_fx_3xx_routine_check_start
002740 c048                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_check_start:
002741 91a0 2850                 	lds r26, pulse1_fx_3xx_start
002743 91b0 2851                 	lds r27, pulse1_fx_3xx_start+1
002745 9610                      	adiw r26:r27, 0
002746 f409                      	brne sound_driver_channel0_fx_3xx_routine_main
002747 c041                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_main:
002748 91c0 2852                 	lds r28, pulse1_fx_3xx_target
00274a 91d0 2853                 	lds r29, pulse1_fx_3xx_target+1
                                 
00274c 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
00274d 07bd                      	cpc r27, r29
00274e f011                      	breq sound_driver_channel0_fx_3xx_routine_disable
00274f f030                      	brlo sound_driver_channel0_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002750 c01f                      	rjmp sound_driver_channel0_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel0_fx_3xx_routine_disable:
002751 9220 2850                 	sts pulse1_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002753 9220 2851                 	sts pulse1_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002755 c033                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_subtract:
002756 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002757 0bdb                      	sbc r29, r27
002758 91a0 2856                 	lds r26, pulse1_fx_3xx_total_offset
00275a 91b0 2857                 	lds r27, pulse1_fx_3xx_total_offset+1
                                 
00275c 0fae                      	add r26, ZL //add the speed to the total offset
00275d 1fbf                      	adc r27, ZH
00275e 1bca                      	sub r28, r26 //invert the total difference with the total offset
00275f 0bdb                      	sbc r29, r27
002760 f380                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002761 93a0 2856                 	sts pulse1_fx_3xx_total_offset, r26 //store the new total offset
002763 93b0 2857                 	sts pulse1_fx_3xx_total_offset+1, r27
                                 
002765 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the current timer period
002767 91b0 0a8d                 	lds r27, TCB0_CCMPH
002769 1bac                      	sub r26, r28 //offset the current timer period with the total offset
00276a 0bbd                      	sbc r27, r29
00276b 93a0 0a8c                 	sts TCB0_CCMPL, r26
00276d 93b0 0a8d                 	sts TCB0_CCMPH, r27
00276f c019                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_add:
002770 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002771 0bbd                      	sbc r27, r29
002772 91c0 2856                 	lds r28, pulse1_fx_3xx_total_offset
002774 91d0 2857                 	lds r29, pulse1_fx_3xx_total_offset+1
                                 
002776 0fce                      	add r28, ZL //add the speed to the total offset
002777 1fdf                      	adc r29, ZH
002778 1bac                      	sub r26, r28 //invert the total difference with the total offset
002779 0bbd                      	sbc r27, r29
00277a f2b0                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
00277b 93c0 2856                 	sts pulse1_fx_3xx_total_offset, r28 //store the new total offset
00277d 93d0 2857                 	sts pulse1_fx_3xx_total_offset+1, r29
                                 
00277f 91c0 0a8c                 	lds r28, TCB0_CCMPL //load the current timer period
002781 91d0 0a8d                 	lds r29, TCB0_CCMPH
002783 0fca                      	add r28, r26 //offset the current timer period with the total offset
002784 1fdb                      	adc r29, r27
002785 93c0 0a8c                 	sts TCB0_CCMPL, r28
002787 93d0 0a8d                 	sts TCB0_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel0_fx_4xy_routine:
002789 91a0 2858                 	lds r26, pulse1_fx_4xy_speed
00278b 15a2                      	cp r26, zero
00278c f409                      	brne sound_driver_channel0_fx_4xy_routine_continue
00278d c05c                      	rjmp sound_driver_channel0_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel0_fx_4xy_routine_continue:
00278e 91b0 2859                 	lds r27, pulse1_fx_4xy_depth
002790 91c0 285a                 	lds r28, pulse1_fx_4xy_phase
002792 0fca                      	add r28, r26 //increase the phase by the speed
002793 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002794 f008                      	brlo sound_driver_channel0_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002795 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase:
002796 93c0 285a                 	sts pulse1_fx_4xy_phase, r28 //store the new phase
002798 31c0                      	cpi r28, 16
002799 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_0
00279a 32c0                      	cpi r28, 32
00279b f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_1
00279c 33c0                      	cpi r28, 48
00279d f030                      	brlo sound_driver_channel0_fx_4xy_routine_phase_2
00279e c007                      	rjmp sound_driver_channel0_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_0:
00279f 70cf                      	andi r28, 0x0F //mask for values 0-15
0027a0 c029                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_1:
0027a1 6fc0                      	ori r28, 0xF0
0027a2 95c0                      	com r28 //invert values 0-15
0027a3 c026                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_2:
0027a4 70cf                      	andi r28, 0x0F //mask for values 0-15
0027a5 c003                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_3:
0027a6 6fc0                      	ori r28, 0xF0
0027a7 95c0                      	com r28 //invert values 0-15
0027a8 c000                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_add:
0027a9 95b2                      	swap r27 //multiply depth by 16
0027aa 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0027ab e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0027ac e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0027ad 0fec                      	add ZL, r28 //offset the table by the depth+phase
0027ae 1df2                      	adc ZH, zero
0027af 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
0027b0 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0027b1 937f                      	push r23
0027b2 2f6c                      	mov r22, r28 //store the vibrato value into r22
0027b3 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0027b4 9f67                      	mul r22, r23
0027b5 917f                      	pop r23
0027b6 916f                      	pop r22
                                 
0027b7 9416                      	lsr r1 //shift out the fractional bits
0027b8 9407                      	ror r0
0027b9 9416                      	lsr r1
0027ba 9407                      	ror r0
0027bb 9416                      	lsr r1
0027bc 9407                      	ror r0
0027bd 9416                      	lsr r1
0027be 9407                      	ror r0
                                 	
0027bf 91a0 0a8c                 	lds r26, TCB0_CCMPL
0027c1 91b0 0a8d                 	lds r27, TCB0_CCMPH
0027c3 0da0                      	add r26, r0
0027c4 1db1                      	adc r27, r1
0027c5 93a0 0a8c                 	sts TCB0_CCMPL, r26
0027c7 93b0 0a8d                 	sts TCB0_CCMPH, r27
0027c9 c020                      	rjmp sound_driver_channel0_fx_7xy_routine
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_subtract:
0027ca 95b2                      	swap r27 //multiply depth by 16
0027cb 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
0027cc e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0027cd e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0027ce 0fec                      	add ZL, r28 //offset the table by the depth+phase
0027cf 1df2                      	adc ZH, zero
0027d0 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
0027d1 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0027d2 937f                      	push r23
0027d3 2f6c                      	mov r22, r28 //store the vibrato value into r22
0027d4 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0027d5 9f67                      	mul r22, r23
0027d6 917f                      	pop r23
0027d7 916f                      	pop r22
                                 
0027d8 9416                      	lsr r1 //shift out the fractional bits
0027d9 9407                      	ror r0
0027da 9416                      	lsr r1
0027db 9407                      	ror r0
0027dc 9416                      	lsr r1
0027dd 9407                      	ror r0
0027de 9416                      	lsr r1
0027df 9407                      	ror r0
                                 
0027e0 91a0 0a8c                 	lds r26, TCB0_CCMPL
0027e2 91b0 0a8d                 	lds r27, TCB0_CCMPH
0027e4 19a0                      	sub r26, r0
0027e5 09b1                      	sbc r27, r1
0027e6 93a0 0a8c                 	sts TCB0_CCMPL, r26
0027e8 93b0 0a8d                 	sts TCB0_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_7xy_routine:
0027ea 91a0 285b                 	lds r26, pulse1_fx_7xy_speed
0027ec 15a2                      	cp r26, zero
0027ed f0e9                      	breq sound_driver_channel0_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
0027ee 91b0 285c                 	lds r27, pulse1_fx_7xy_depth
0027f0 91c0 285d                 	lds r28, pulse1_fx_7xy_phase
0027f2 0fca                      	add r28, r26 //increase the phase by the speed
0027f3 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
0027f4 f008                      	brlo sound_driver_channel0_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
0027f5 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase:
0027f6 93c0 285d                 	sts pulse1_fx_7xy_phase, r28 //store the new phase
0027f8 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
0027f9 ffc4                      	sbrs r28, 4
0027fa c001                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_0
0027fb c002                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel0_fx_7xy_routine_phase_0:
0027fc 70cf                      	andi r28, 0x0F //mask for values 0-15
0027fd c003                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase_1:
0027fe 6fc0                      	ori r28, 0xF0
0027ff 95c0                      	com r28 //invert values 0-15
002800 c000                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_load:
002801 95b2                      	swap r27 //multiply depth by 16
002802 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002803 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002804 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002805 0fec                      	add ZL, r28 //offset the table by the depth+phase
002806 1df2                      	adc ZH, zero
002807 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002808 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
002809 93c0 285e                 	sts pulse1_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Axy_routine:
00280b 91b0 285f                 	lds r27, pulse1_fx_Axy
00280d 15b2                      	cp r27, zero
00280e f0e9                      	breq sound_driver_channel0_fx_Qxy_routine //0 means that the effect is not in use
                                 	
00280f 91a0 2805                 	lds r26, pulse1_fractional_volume //load fractional volume representation of the channel
002811 91c0 2800                 	lds r28, pulse1_param //load the integer volume representation of the channel
002813 2fda                      	mov r29, r26 //copy fractional volume into r29
002814 2fec                      	mov r30, r28 //copy the pulse1_param into r30
002815 95e2                      	swap r30
002816 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
002817 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
002818 17ed                      	cp r30, r29 //compare the fractional and integer volumes
002819 f009                      	breq sound_driver_channel0_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel0_fx_Axy_routine_reload:
00281a 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate:
00281b fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
00281c c004                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_addition:
00281d 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
00281e f428                      	brcc sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
00281f efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
002820 c003                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_subtraction:
002821 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002822 f008                      	brcs sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002823 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_store:
002824 93a0 2805                 	sts pulse1_fractional_volume, r26 //store the new fractional volume
002826 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
002827 95a2                      	swap r26
002828 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
002829 2bca                      	or r28, r26 //store the new volume back into pulse1_param
00282a 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel0_fx_Qxy_routine:
00282c 91e0 2865                 	lds ZL, pulse1_fx_Qxy_target
00282e 91f0 2866                 	lds ZH, pulse1_fx_Qxy_target+1
002830 9630                      	adiw Z, 0
002831 f119                      	breq sound_driver_channel0_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002832 91a0 2869                 	lds r26, pulse1_fx_Qxy_total_offset
002834 91b0 286a                 	lds r27, pulse1_fx_Qxy_total_offset+1
002836 91c0 0a8c                 	lds r28, TCB0_CCMPL
002838 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
00283a 1bec                      	sub ZL, r28 //calculate the difference to the target
00283b 0bfd                      	sbc ZH, r29
00283c f408                      	brsh sound_driver_channel0_fx_Qxy_routine_end //if the target has been reached (or passed)
00283d f068                      	brlo sound_driver_channel0_fx_Qxy_routine_add
                                 
                                 sound_driver_channel0_fx_Qxy_routine_end:
00283e 9220 2869                 	sts pulse1_fx_Qxy_total_offset, zero //turn off the effect
002840 9220 286a                 	sts pulse1_fx_Qxy_total_offset+1, zero
002842 9220 2865                 	sts pulse1_fx_Qxy_target, zero
002844 9220 2866                 	sts pulse1_fx_Qxy_target+1, zero
002846 91b0 2864                 	lds r27, pulse1_fx_Qxy_target_note
002848 93b0 2807                 	sts pulse1_note, r27 //replace the note with the final target note
00284a c00a                      	rjmp sound_driver_channel0_fx_Rxy_routine
                                 
                                 sound_driver_channel0_fx_Qxy_routine_add:
00284b 91c0 2867                 	lds r28, pulse1_fx_Qxy_speed
00284d 91d0 2868                 	lds r29, pulse1_fx_Qxy_speed+1
00284f 0fac                      	add r26, r28 //increase the total offset by the speed
002850 1fbd                      	adc r27, r29
002851 93a0 2869                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
002853 93b0 286a                 	sts pulse1_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Rxy_routine:
002855 91e0 286c                 	lds ZL, pulse1_fx_Rxy_target
002857 91f0 286d                 	lds ZH, pulse1_fx_Rxy_target+1
002859 9630                      	adiw Z, 0
00285a f119                      	breq sound_driver_instrument_routine_channel1_volume //if the effect is not enabled, skip the routine
                                 
00285b 91a0 2870                 	lds r26, pulse1_fx_Rxy_total_offset
00285d 91b0 2871                 	lds r27, pulse1_fx_Rxy_total_offset+1
00285f 91c0 0a8c                 	lds r28, TCB0_CCMPL
002861 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
002863 1bce                      	sub r28, ZL //calculate the difference to the target
002864 0bdf                      	sbc r29, ZH
002865 f408                      	brsh sound_driver_channel0_fx_Rxy_routine_end //if the target has been reached (or passed)
002866 f068                      	brlo sound_driver_channel0_fx_Rxy_routine_add
                                 
                                 sound_driver_channel0_fx_Rxy_routine_end:
002867 9220 2870                 	sts pulse1_fx_Rxy_total_offset, zero //disable the effect
002869 9220 2871                 	sts pulse1_fx_Rxy_total_offset+1, zero
00286b 9220 286c                 	sts pulse1_fx_Rxy_target, zero
00286d 9220 286d                 	sts pulse1_fx_Rxy_target+1, zero
00286f 91b0 286b                 	lds r27, pulse1_fx_Rxy_target_note
002871 93b0 2807                 	sts pulse1_note, r27 //replace the note with the final target note
002873 c00a                      	rjmp sound_driver_instrument_routine_channel1_volume
                                 
                                 sound_driver_channel0_fx_Rxy_routine_add:
002874 91c0 286e                 	lds r28, pulse1_fx_Rxy_speed
002876 91d0 286f                 	lds r29, pulse1_fx_Rxy_speed+1
002878 0fac                      	add r26, r28 //increase the total offset by the speed
002879 1fbd                      	adc r27, r29
00287a 93a0 2870                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
00287c 93b0 2871                 	sts pulse1_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume:
00287e 91e0 287a                 	lds ZL, pulse2_volume_macro
002880 91f0 287b                 	lds ZH, pulse2_volume_macro+1
002882 9630                      	adiw Z, 0
002883 f1a1                      	breq sound_driver_instrument_routine_channel1_volume_default //if no volume macro is in use, use default multiplier of F
002884 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002885 1fff                      	rol ZH
002886 91a0 287c                 	lds r26, pulse2_volume_macro_offset
002888 0fea                      	add ZL, r26
002889 1df2                      	adc ZH, zero
                                 
00288a 91b0 287e                 	lds r27, pulse2_volume_macro_release
00288c 17ba                      	cp r27, r26
00288d f429                      	brne sound_driver_instrument_routine_channel1_volume_increment //if the current offset is not equal to the release index, increment the offset
00288e 91a0 287d                 	lds r26, pulse2_volume_macro_loop
002890 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002891 f010                      	brlo sound_driver_instrument_routine_channel1_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002892 c003                      	rjmp sound_driver_instrument_routine_channel1_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_volume_increment:
002893 95a3                      	inc r26 //increment the macro offset
002894 93a0 287c                 	sts pulse2_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_volume_read:
002896 91b4                      	lpm r27, Z //load volume data into r27
002897 3fbf                      	cpi r27, 0xFF //check for macro end flag
002898 f469                      	brne sound_driver_instrument_routine_channel1_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_release:
002899 91b0 287e                 	lds r27, pulse2_volume_macro_release
00289b 3fbf                      	cpi r27, 0xFF
00289c f429                      	brne sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_loop:
00289d 91b0 287d                 	lds r27, pulse2_volume_macro_loop //load the loop index
00289f 93b0 287c                 	sts pulse2_volume_macro_offset, r27 //store the loop index into the offset
0028a1 cfdc                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index:
0028a2 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
0028a3 93a0 287c                 	sts pulse2_volume_macro_offset, r26
0028a5 cfd8                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_calculate:
0028a6 eaea                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
0028a7 e6f2                      	ldi ZH, HIGH(volumes << 1)
0028a8 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
0028a9 0feb                      	add ZL, r27 //add offset to the table
0028aa 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel1_volume_load:
0028ab 91b0 2808                 	lds r27, pulse2_param //load main volume
0028ad 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
0028ae 91a0 28af                 	lds r26, pulse2_fx_7xy_value
0028b0 30a0                      	cpi r26, 0x00
0028b1 f481                      	brne sound_driver_instrument_routine_channel1_volume_load_7xy
                                 
0028b2 0feb                      	add ZL, r27 //offset the volume table by the main volume
0028b3 1df2                      	adc ZH, zero
0028b4 91b4                      	lpm r27, Z
0028b5 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
0028b7 c023                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default:
0028b8 91b0 2808                 	lds r27, pulse2_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
0028ba 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
0028bb 91a0 28af                 	lds r26, pulse2_fx_7xy_value
0028bd 30a0                      	cpi r26, 0x00
0028be f499                      	brne sound_driver_instrument_routine_channel1_volume_default_7xy
0028bf 93b0 280e                 	sts pulse2_output_volume, r27
0028c1 c019                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy:
0028c2 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
0028c3 f038                      	brcs sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
0028c4 f031                      	breq sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
                                 
0028c5 0feb                      	add ZL, r27 //offset the volume table by the main volume
0028c6 1df2                      	adc ZH, zero
0028c7 91b4                      	lpm r27, Z
0028c8 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
0028ca c010                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy_overflow:
0028cb e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
0028cc 0feb                      	add ZL, r27 //offset the volume table by the main volume
0028cd 1df2                      	adc ZH, zero
0028ce 91b4                      	lpm r27, Z
0028cf 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
0028d1 c009                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default_7xy:
0028d2 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
0028d3 f020                      	brcs sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
0028d4 f019                      	breq sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
0028d5 93b0 280e                 	sts pulse2_output_volume, r27
0028d7 c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel1_volume_default_7xy_overflow:
0028d8 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
0028d9 93b0 280e                 	sts pulse2_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
0028db 91e0 287f                 	lds ZL, pulse2_arpeggio_macro
0028dd 91f0 2880                 	lds ZH, pulse2_arpeggio_macro+1
0028df 9630                      	adiw Z, 0
0028e0 f1d9                      	breq sound_driver_instrument_routine_channel1_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
0028e1 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0028e2 1fff                      	rol ZH
0028e3 91a0 2881                 	lds r26, pulse2_arpeggio_macro_offset
0028e5 0fea                      	add ZL, r26
0028e6 1df2                      	adc ZH, zero
                                 
0028e7 91b0 2883                 	lds r27, pulse2_arpeggio_macro_release
0028e9 17ba                      	cp r27, r26
0028ea f429                      	brne sound_driver_instrument_routine_channel1_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
0028eb 91a0 2882                 	lds r26, pulse2_arpeggio_macro_loop
0028ed 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0028ee f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
0028ef c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_increment:
0028f0 95a3                      	inc r26 //increment the macro offset
0028f1 93a0 2881                 	sts pulse2_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_read:
0028f3 91b4                      	lpm r27, Z //load arpeggio data into r27
0028f4 38b0                      	cpi r27, 0x80 //check for macro end flag
0028f5 f009                      	breq sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag
0028f6 c041                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_check_mode:
0028f7 50a1                      	subi r26, 1 //keep the offset at the end flag
0028f8 93a0 2881                 	sts pulse2_arpeggio_macro_offset, r26
0028fa 91b0 2884                 	lds r27, pulse2_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
0028fc 30b1                      	cpi r27, 0x01
0028fd f048                      	brlo sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_release:
0028fe 91b0 2883                 	lds r27, pulse2_arpeggio_macro_release
002900 3fbf                      	cpi r27, 0xFF
002901 f4d1                      	brne sound_driver_instrument_routine_channel1_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_loop:
002902 91b0 2882                 	lds r27, pulse2_arpeggio_macro_loop
002904 3fbf                      	cpi r27, 0xFF
002905 f499                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002906 c015                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute:
002907 91b0 2883                 	lds r27, pulse2_arpeggio_macro_release
002909 3fbf                      	cpi r27, 0xFF
00290a f421                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_check_loop:
00290b 91b0 2882                 	lds r27, pulse2_arpeggio_macro_loop //load the loop index
00290d 3fbf                      	cpi r27, 0xFF //check if loop flag exists
00290e f451                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop:
00290f 91c0 2897                 	lds r28, pulse2_fx_0xy_sequence //check for 0xy effect
002911 91d0 2898                 	lds r29, pulse2_fx_0xy_sequence+1
002913 9620                      	adiw r29:r28, 0
002914 f469                      	brne sound_driver_instrument_routine_channel1_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002915 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002916 93a0 2881                 	sts pulse2_arpeggio_macro_offset, r26 //store the last valid index into the offset
002918 cfc2                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload:
002919 93b0 2881                 	sts pulse2_arpeggio_macro_offset, r27 //store the loop index into the offset
00291b cfbf                      	rjmp sound_driver_instrument_routine_channel1_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_default:
00291c 91c0 2897                 	lds r28, pulse2_fx_0xy_sequence //load 0xy effect
00291e 91d0 2898                 	lds r29, pulse2_fx_0xy_sequence+1
002920 9620                      	adiw r29:r28, 0 //check for 0xy effect
002921 f099                      	breq sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel1_arpeggio_default_0xy:
002922 95d6                      	lsr r29
002923 95c7                      	ror r28
002924 95d7                      	ror r29
002925 95c7                      	ror r28
002926 95d7                      	ror r29
002927 95c7                      	ror r28
002928 95d7                      	ror r29
002929 95c7                      	ror r28
00292a 95d7                      	ror r29
00292b 95d2                      	swap r29
                                 
00292c 93c0 2897                 	sts pulse2_fx_0xy_sequence, r28 //store the rolled sequence
00292e 93d0 2898                 	sts pulse2_fx_0xy_sequence+1, r29
002930 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002931 91a0 280f                 	lds r26, pulse2_note //load the current note index
002933 0fac                      	add r26, r28 //add the note offset
002934 c02e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002935 91a0 280f                 	lds r26, pulse2_note //load the current note index
002937 c02b                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process:
002938 9220 2885                 	sts pulse2_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
00293a 9220 2886                 	sts pulse2_total_pitch_offset+1, zero
00293c 9220 288c                 	sts pulse2_total_hi_pitch_offset, zero
00293e 91a0 2884                 	lds r26, pulse2_arpeggio_macro_mode
002940 30a1                      	cpi r26, 0x01 //absolute mode
002941 f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_absolute
002942 f069                      	breq sound_driver_instrument_routine_channel1_arpeggio_process_fixed
002943 c00e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute:
002944 91a0 280f                 	lds r26, pulse2_note //load the current note index
002946 0fab                      	add r26, r27 //offset the note with the arpeggio data
002947 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002948 c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_add:
002949 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
00294a f0c0                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
00294b e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
00294c c016                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract:
00294d fda7                      	sbrc r26, 7 //check if result is negative
00294e e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
00294f c013                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_fixed:
002950 2fab                      	mov r26, r27 //move the arpeggio data into r26
002951 c011                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative:
002952 91a0 280f                 	lds r26, pulse2_note //load the current note index
002954 0fab                      	add r26, r27 //offset the note with the arpeggio data
002955 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002956 c008                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_add:
002957 93a0 280f                 	sts pulse2_note, r26 //NOTE: relative mode modifies the original note index
002959 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
00295a f040                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
00295b e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
00295c 93a0 280f                 	sts pulse2_note, r26
00295e c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract:
00295f fda7                      	sbrc r26, 7 //check if result is negative
002960 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002961 93a0 280f                 	sts pulse2_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_load:
002963 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
002964 e0f0                      	ldi ZH, HIGH(note_table << 1)
002965 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002966 0fea                      	add ZL, r26 //add offset
002967 1df2                      	adc ZH, zero
002968 91a5                      	lpm r26, Z+ //load bytes
002969 91b4                      	lpm r27, Z
00296a 93a0 0a9c                 	sts TCB1_CCMPL, r26 //load the LOW bits for timer
00296c 93b0 0a9d                 	sts TCB1_CCMPH, r27 //load the HIGH bits for timer
00296e 93a0 28a3                 	sts pulse2_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002970 93b0 28a4                 	sts pulse2_fx_3xx_target+1, r27
002972 c000                      	rjmp sound_driver_instrument_routine_channel1_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch:
002973 91e0 2887                 	lds ZL, pulse2_pitch_macro
002975 91f0 2888                 	lds ZH, pulse2_pitch_macro+1
002977 9630                      	adiw Z, 0
002978 f409                      	brne sound_driver_instrument_routine_channel1_pitch_continue
002979 c023                      	rjmp sound_driver_instrument_routine_channel1_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel1_pitch_continue:
00297a 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00297b 1fff                      	rol ZH
00297c 91a0 2889                 	lds r26, pulse2_pitch_macro_offset
00297e 0fea                      	add ZL, r26
00297f 1df2                      	adc ZH, zero
                                 
002980 91b0 288b                 	lds r27, pulse2_pitch_macro_release
002982 17ba                      	cp r27, r26
002983 f429                      	brne sound_driver_instrument_routine_channel1_pitch_increment //if the current offset is not equal to the release index, increment the offset
002984 91a0 288a                 	lds r26, pulse2_pitch_macro_loop
002986 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002987 f010                      	brlo sound_driver_instrument_routine_channel1_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002988 c003                      	rjmp sound_driver_instrument_routine_channel1_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_pitch_increment:
002989 95a3                      	inc r26 //increment the macro offset
00298a 93a0 2889                 	sts pulse2_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_pitch_read:
00298c 91b4                      	lpm r27, Z //load pitch data into r27
00298d 38b0                      	cpi r27, 0x80 //check for macro end flag
00298e f479                      	brne sound_driver_instrument_routine_channel1_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_release:
00298f 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002990 93a0 2889                 	sts pulse2_pitch_macro_offset, r26
002992 91b0 288b                 	lds r27, pulse2_pitch_macro_release
002994 3fbf                      	cpi r27, 0xFF
002995 f439                      	brne sound_driver_instrument_routine_channel1_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_loop:
002996 91b0 288a                 	lds r27, pulse2_pitch_macro_loop //load the loop index
002998 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002999 f019                      	breq sound_driver_instrument_routine_channel1_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
00299a 93b0 2889                 	sts pulse2_pitch_macro_offset, r27 //store the loop index into the offset
00299c cfd6                      	rjmp sound_driver_instrument_routine_channel1_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_default:
00299d e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel1_pitch_calculate:
00299e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00299f 937f                      	push r23
0029a0 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
0029a1 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0029a2 0367                      	mulsu r22, r23
0029a3 917f                      	pop r23
0029a4 916f                      	pop r22
                                 
0029a5 9416                      	lsr r1 //shift out the fractional bits
0029a6 9407                      	ror r0
0029a7 9416                      	lsr r1
0029a8 9407                      	ror r0
0029a9 9416                      	lsr r1
0029aa 9407                      	ror r0
0029ab 9416                      	lsr r1
0029ac 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_check_negative:
0029ad fe13                      	sbrs r1, 3 //check if result was a negative number
0029ae c007                      	rjmp sound_driver_instrument_routine_channel1_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_negative:
0029af efc0                      	ldi r28, 0xF0
0029b0 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_check_divisible_8:
0029b1 70b7                      	andi r27, 0b00000111
0029b2 f019                      	breq sound_driver_instrument_routine_channel1_pitch_calculate_offset
                                 
0029b3 e0b1                      	ldi r27, 0x01
0029b4 0e0b                      	add r0, r27
0029b5 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_offset:
0029b6 91a0 2885                 	lds r26, pulse2_total_pitch_offset
0029b8 91b0 2886                 	lds r27, pulse2_total_pitch_offset+1
0029ba 0e0a                      	add r0, r26
0029bb 1e1b                      	adc r1, r27
0029bc 9200 2885                 	sts pulse2_total_pitch_offset, r0
0029be 9210 2886                 	sts pulse2_total_pitch_offset+1, r1
0029c0 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
0029c2 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
0029c4 0da0                      	add r26, r0 //offset the timer values
0029c5 1db1                      	adc r27, r1
                                 	
0029c6 91c0 289b                 	lds r28, pulse2_fx_1xx_total
0029c8 91d0 289c                 	lds r29, pulse2_fx_1xx_total+1
0029ca 1bac                      	sub r26, r28
0029cb 0bbd                      	sbc r27, r29
0029cc 91c0 289f                 	lds r28, pulse2_fx_2xx_total
0029ce 91d0 28a0                 	lds r29, pulse2_fx_2xx_total+1
0029d0 0fac                      	add r26, r28
0029d1 1fbd                      	adc r27, r29
0029d2 91c0 28b3                 	lds r28, pulse2_fx_Pxx_total
0029d4 91d0 28b4                 	lds r29, pulse2_fx_Pxx_total+1
0029d6 0fac                      	add r26, r28
0029d7 1fbd                      	adc r27, r29
0029d8 91c0 28ba                 	lds r28, pulse2_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
0029da 91d0 28bb                 	lds r29, pulse2_fx_Qxy_total_offset+1
0029dc 1bac                      	sub r26, r28
0029dd 0bbd                      	sbc r27, r29
0029de 91c0 28c1                 	lds r28, pulse2_fx_Rxy_total_offset
0029e0 91d0 28c2                 	lds r29, pulse2_fx_Rxy_total_offset+1
0029e2 0fac                      	add r26, r28
0029e3 1fbd                      	adc r27, r29
                                 
0029e4 e5c9                      	ldi r28, 0x59
0029e5 e0d0                      	ldi r29, 0x00
0029e6 17ac                      	cp r26, r28
0029e7 07bd                      	cpc r27, r29
0029e8 f030                      	brlo sound_driver_instrument_routine_channel1_pitch_min
                                 
0029e9 e5ca                      	ldi r28, 0x5A
0029ea e5d9                      	ldi r29, 0x59
0029eb 17ac                      	cp r26, r28
0029ec 07bd                      	cpc r27, r29
0029ed f420                      	brsh sound_driver_instrument_routine_channel1_pitch_max
0029ee c006                      	rjmp sound_driver_instrument_routine_channel1_pitch_store
                                 
                                 sound_driver_instrument_routine_channel1_pitch_min:
0029ef e5c9                      	ldi r28, 0x59
0029f0 e0d0                      	ldi r29, 0x00
0029f1 c003                      	rjmp sound_driver_instrument_routine_channel1_pitch_store
                                 
                                 sound_driver_instrument_routine_channel1_pitch_max:
0029f2 e5c9                      	ldi r28, 0x59
0029f3 e5d9                      	ldi r29, 0x59
0029f4 c000                      	rjmp sound_driver_instrument_routine_channel1_pitch_store
                                 
                                 sound_driver_instrument_routine_channel1_pitch_store:
0029f5 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
0029f7 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel1_hi_pitch:
0029f9 91e0 288d                 	lds ZL, pulse2_hi_pitch_macro
0029fb 91f0 288e                 	lds ZH, pulse2_hi_pitch_macro+1
0029fd 9630                      	adiw Z, 0
0029fe f409                      	brne sound_driver_instrument_routine_channel1_hi_pitch_continue
0029ff c03c                      	rjmp sound_driver_instrument_routine_channel1_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel1_hi_pitch_continue:
002a00 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002a01 1fff                      	rol ZH
002a02 91a0 288f                 	lds r26, pulse2_hi_pitch_macro_offset
002a04 0fea                      	add ZL, r26
002a05 1df2                      	adc ZH, zero
                                 
002a06 91b0 2891                 	lds r27, pulse2_hi_pitch_macro_release
002a08 17ba                      	cp r27, r26
002a09 f429                      	brne sound_driver_instrument_routine_channel1_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002a0a 91a0 2890                 	lds r26, pulse2_hi_pitch_macro_loop
002a0c 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002a0d f010                      	brlo sound_driver_instrument_routine_channel1_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002a0e c003                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_increment:
002a0f 95a3                      	inc r26 //increment the macro offset
002a10 93a0 288f                 	sts pulse2_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_hi_pitch_read:
002a12 91b4                      	lpm r27, Z //load hi pitch data into r27
002a13 38b0                      	cpi r27, 0x80 //check for macro end flag
002a14 f489                      	brne sound_driver_instrument_routine_channel1_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_release:
002a15 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002a16 93a0 288f                 	sts pulse2_hi_pitch_macro_offset, r26
002a18 91b0 2891                 	lds r27, pulse2_hi_pitch_macro_release
002a1a 3fbf                      	cpi r27, 0xFF
002a1b f439                      	brne sound_driver_instrument_routine_channel1_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_loop:
002a1c 91b0 2890                 	lds r27, pulse2_hi_pitch_macro_loop //load the loop index
002a1e 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002a1f f019                      	breq sound_driver_instrument_routine_channel1_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002a20 93b0 288f                 	sts pulse2_hi_pitch_macro_offset, r27 //store the loop index into the offset
002a22 cfd6                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_default:
002a23 91b0 288c                 	lds r27, pulse2_total_hi_pitch_offset
002a25 c005                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate:
002a26 91a0 288c                 	lds r26, pulse2_total_hi_pitch_offset //load the total hi pitch offset to change
002a28 0fba                      	add r27, r26
002a29 93b0 288c                 	sts pulse2_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply:
002a2b 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002a2c 937f                      	push r23
002a2d 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002a2e eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002a2f 0367                      	mulsu r22, r23
002a30 917f                      	pop r23
002a31 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_offset:
002a32 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
002a34 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
002a36 0da0                      	add r26, r0 //offset the timer values
002a37 1db1                      	adc r27, r1
002a38 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
002a3a 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel1_duty:
002a3c 91e0 2892                 	lds ZL, pulse2_duty_macro
002a3e 91f0 2893                 	lds ZH, pulse2_duty_macro+1
002a40 9630                      	adiw Z, 0
002a41 f1b1                      	breq sound_driver_channel1_fx_routines //if no duty macro is in use, go to the next routine
002a42 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002a43 1fff                      	rol ZH
002a44 91a0 2894                 	lds r26, pulse2_duty_macro_offset
002a46 0fea                      	add ZL, r26
002a47 1df2                      	adc ZH, zero
                                 
002a48 91b0 2896                 	lds r27, pulse2_duty_macro_release
002a4a 17ba                      	cp r27, r26
002a4b f429                      	brne sound_driver_instrument_routine_channel1_duty_increment //if the current offset is not equal to the release index, increment the offset
002a4c 91a0 2895                 	lds r26, pulse2_duty_macro_loop
002a4e 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002a4f f010                      	brlo sound_driver_instrument_routine_channel1_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002a50 c027                      	rjmp sound_driver_channel1_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel1_duty_increment:
002a51 95a3                      	inc r26 //increment the macro offset
002a52 93a0 2894                 	sts pulse2_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_duty_read:
002a54 91b4                      	lpm r27, Z //load pitch data into r27
002a55 3fbf                      	cpi r27, 0xFF //check for macro end flag
002a56 f471                      	brne sound_driver_instrument_routine_channel1_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_release:
002a57 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002a58 93a0 2894                 	sts pulse2_duty_macro_offset, r26
002a5a 91b0 2896                 	lds r27, pulse2_duty_macro_release
002a5c 3fbf                      	cpi r27, 0xFF
002a5d f4d1                      	brne sound_driver_channel1_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_loop:
002a5e 91b0 2895                 	lds r27, pulse2_duty_macro_loop //load the loop index
002a60 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002a61 f0b1                      	breq sound_driver_channel1_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
002a62 93b0 2894                 	sts pulse2_duty_macro_offset, r27 //store the loop index into the offset
002a64 cfd7                      	rjmp sound_driver_instrument_routine_channel1_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_load:
002a65 eae2                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
002a66 e6f1                      	ldi ZH, HIGH(sequences << 1)
002a67 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
002a68 1df2                      	adc ZH, zero
                                 
002a69 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
002a6a 95b7                      	ror r27
002a6b 95b7                      	ror r27
002a6c 91a0 2808                 	lds r26, pulse2_param //load r26 with pulse2_param (register $4000)
002a6e 2fca                      	mov r28, r26 //store a copy of pulse2_param into r28
002a6f 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
002a70 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
002a71 c001                      	rjmp sound_driver_instrument_routine_channel1_duty_load_store
002a72 c005                      	rjmp sound_driver_channel1_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel1_duty_load_store:
002a73 90a4                      	lpm pulse2_sequence, Z //store the sequence
                                 
002a74 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
002a75 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
002a76 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_routines:
                                 sound_driver_channel1_fx_1xx_routine:
002a78 91e0 2899                 	lds ZL, pulse2_fx_1xx
002a7a 91f0 289a                 	lds ZH, pulse2_fx_1xx+1
002a7c 9630                      	adiw Z, 0
002a7d f051                      	breq sound_driver_channel1_fx_2xx_routine
                                 
002a7e 91a0 289b                 	lds r26, pulse2_fx_1xx_total //load the rate to change the pitch by
002a80 91b0 289c                 	lds r27, pulse2_fx_1xx_total+1
002a82 0fae                      	add r26, ZL //increase the total offset by the rate
002a83 1fbf                      	adc r27, ZH
002a84 93a0 289b                 	sts pulse2_fx_1xx_total, r26
002a86 93b0 289c                 	sts pulse2_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_2xx_routine:
002a88 91e0 289d                 	lds ZL, pulse2_fx_2xx
002a8a 91f0 289e                 	lds ZH, pulse2_fx_2xx+1
002a8c 9630                      	adiw Z, 0
002a8d f051                      	breq sound_driver_channel1_fx_3xx_routine
                                 
002a8e 91a0 289f                 	lds r26, pulse2_fx_2xx_total //load the rate to change the pitch by
002a90 91b0 28a0                 	lds r27, pulse2_fx_2xx_total+1
002a92 0fae                      	add r26, ZL //increase the total offset by the rate
002a93 1fbf                      	adc r27, ZH
002a94 93a0 289f                 	sts pulse2_fx_2xx_total, r26
002a96 93b0 28a0                 	sts pulse2_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_3xx_routine:
002a98 91e0 28a5                 	lds ZL, pulse2_fx_3xx_speed
002a9a 91f0 28a6                 	lds ZH, pulse2_fx_3xx_speed+1
002a9c 9630                      	adiw Z, 0
002a9d f409                      	brne sound_driver_channel1_fx_3xx_routine_check_start
002a9e c048                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_check_start:
002a9f 91a0 28a1                 	lds r26, pulse2_fx_3xx_start
002aa1 91b0 28a2                 	lds r27, pulse2_fx_3xx_start+1
002aa3 9610                      	adiw r26:r27, 0
002aa4 f409                      	brne sound_driver_channel1_fx_3xx_routine_main
002aa5 c041                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_main:
002aa6 91c0 28a3                 	lds r28, pulse2_fx_3xx_target
002aa8 91d0 28a4                 	lds r29, pulse2_fx_3xx_target+1
                                 
002aaa 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
002aab 07bd                      	cpc r27, r29
002aac f011                      	breq sound_driver_channel1_fx_3xx_routine_disable
002aad f030                      	brlo sound_driver_channel1_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002aae c01f                      	rjmp sound_driver_channel1_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel1_fx_3xx_routine_disable:
002aaf 9220 28a1                 	sts pulse2_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002ab1 9220 28a2                 	sts pulse2_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002ab3 c033                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_subtract:
002ab4 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002ab5 0bdb                      	sbc r29, r27
002ab6 91a0 28a7                 	lds r26, pulse2_fx_3xx_total_offset
002ab8 91b0 28a8                 	lds r27, pulse2_fx_3xx_total_offset+1
                                 
002aba 0fae                      	add r26, ZL //add the speed to the total offset
002abb 1fbf                      	adc r27, ZH
002abc 1bca                      	sub r28, r26 //invert the total difference with the total offset
002abd 0bdb                      	sbc r29, r27
002abe f380                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002abf 93a0 28a7                 	sts pulse2_fx_3xx_total_offset, r26 //store the new total offset
002ac1 93b0 28a8                 	sts pulse2_fx_3xx_total_offset+1, r27
                                 
002ac3 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the current timer period
002ac5 91b0 0a9d                 	lds r27, TCB1_CCMPH
002ac7 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002ac8 0bbd                      	sbc r27, r29
002ac9 93a0 0a9c                 	sts TCB1_CCMPL, r26
002acb 93b0 0a9d                 	sts TCB1_CCMPH, r27
002acd c019                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_add:
002ace 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002acf 0bbd                      	sbc r27, r29
002ad0 91c0 28a7                 	lds r28, pulse2_fx_3xx_total_offset
002ad2 91d0 28a8                 	lds r29, pulse2_fx_3xx_total_offset+1
                                 
002ad4 0fce                      	add r28, ZL //add the speed to the total offset
002ad5 1fdf                      	adc r29, ZH
002ad6 1bac                      	sub r26, r28 //invert the total difference with the total offset
002ad7 0bbd                      	sbc r27, r29
002ad8 f2b0                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002ad9 93c0 28a7                 	sts pulse2_fx_3xx_total_offset, r28 //store the new total offset
002adb 93d0 28a8                 	sts pulse2_fx_3xx_total_offset+1, r29
                                 
002add 91c0 0a9c                 	lds r28, TCB1_CCMPL //load the current timer period
002adf 91d0 0a9d                 	lds r29, TCB1_CCMPH
002ae1 0fca                      	add r28, r26 //offset the current timer period with the total offset
002ae2 1fdb                      	adc r29, r27
002ae3 93c0 0a9c                 	sts TCB1_CCMPL, r28
002ae5 93d0 0a9d                 	sts TCB1_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel1_fx_4xy_routine:
002ae7 91a0 28a9                 	lds r26, pulse2_fx_4xy_speed
002ae9 15a2                      	cp r26, zero
002aea f409                      	brne sound_driver_channel1_fx_4xy_routine_continue
002aeb c05c                      	rjmp sound_driver_channel1_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel1_fx_4xy_routine_continue:
002aec 91b0 28aa                 	lds r27, pulse2_fx_4xy_depth
002aee 91c0 28ab                 	lds r28, pulse2_fx_4xy_phase
002af0 0fca                      	add r28, r26 //increase the phase by the speed
002af1 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002af2 f008                      	brlo sound_driver_channel1_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002af3 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase:
002af4 93c0 28ab                 	sts pulse2_fx_4xy_phase, r28 //store the new phase
002af6 31c0                      	cpi r28, 16
002af7 f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_0
002af8 32c0                      	cpi r28, 32
002af9 f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_1
002afa 33c0                      	cpi r28, 48
002afb f030                      	brlo sound_driver_channel1_fx_4xy_routine_phase_2
002afc c007                      	rjmp sound_driver_channel1_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_0:
002afd 70cf                      	andi r28, 0x0F //mask for values 0-15
002afe c029                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_1:
002aff 6fc0                      	ori r28, 0xF0
002b00 95c0                      	com r28 //invert values 0-15
002b01 c026                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_2:
002b02 70cf                      	andi r28, 0x0F //mask for values 0-15
002b03 c003                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_3:
002b04 6fc0                      	ori r28, 0xF0
002b05 95c0                      	com r28 //invert values 0-15
002b06 c000                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_add:
002b07 95b2                      	swap r27 //multiply depth by 16
002b08 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002b09 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002b0a e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002b0b 0fec                      	add ZL, r28 //offset the table by the depth+phase
002b0c 1df2                      	adc ZH, zero
002b0d 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002b0e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002b0f 937f                      	push r23
002b10 2f6c                      	mov r22, r28 //store the vibrato value into r22
002b11 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002b12 9f67                      	mul r22, r23
002b13 917f                      	pop r23
002b14 916f                      	pop r22
                                 
002b15 9416                      	lsr r1 //shift out the fractional bits
002b16 9407                      	ror r0
002b17 9416                      	lsr r1
002b18 9407                      	ror r0
002b19 9416                      	lsr r1
002b1a 9407                      	ror r0
002b1b 9416                      	lsr r1
002b1c 9407                      	ror r0
                                 	
002b1d 91a0 0a9c                 	lds r26, TCB1_CCMPL
002b1f 91b0 0a9d                 	lds r27, TCB1_CCMPH
002b21 0da0                      	add r26, r0
002b22 1db1                      	adc r27, r1
002b23 93a0 0a9c                 	sts TCB1_CCMPL, r26
002b25 93b0 0a9d                 	sts TCB1_CCMPH, r27
002b27 c020                      	rjmp sound_driver_channel1_fx_7xy_routine
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_subtract:
002b28 95b2                      	swap r27 //multiply depth by 16
002b29 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002b2a e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002b2b e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002b2c 0fec                      	add ZL, r28 //offset the table by the depth+phase
002b2d 1df2                      	adc ZH, zero
002b2e 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002b2f 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002b30 937f                      	push r23
002b31 2f6c                      	mov r22, r28 //store the vibrato value into r22
002b32 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002b33 9f67                      	mul r22, r23
002b34 917f                      	pop r23
002b35 916f                      	pop r22
                                 
002b36 9416                      	lsr r1 //shift out the fractional bits
002b37 9407                      	ror r0
002b38 9416                      	lsr r1
002b39 9407                      	ror r0
002b3a 9416                      	lsr r1
002b3b 9407                      	ror r0
002b3c 9416                      	lsr r1
002b3d 9407                      	ror r0
                                 
002b3e 91a0 0a9c                 	lds r26, TCB1_CCMPL
002b40 91b0 0a9d                 	lds r27, TCB1_CCMPH
002b42 19a0                      	sub r26, r0
002b43 09b1                      	sbc r27, r1
002b44 93a0 0a9c                 	sts TCB1_CCMPL, r26
002b46 93b0 0a9d                 	sts TCB1_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_7xy_routine:
002b48 91a0 28ac                 	lds r26, pulse2_fx_7xy_speed
002b4a 15a2                      	cp r26, zero
002b4b f0e9                      	breq sound_driver_channel1_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
002b4c 91b0 28ad                 	lds r27, pulse2_fx_7xy_depth
002b4e 91c0 28ae                 	lds r28, pulse2_fx_7xy_phase
002b50 0fca                      	add r28, r26 //increase the phase by the speed
002b51 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002b52 f008                      	brlo sound_driver_channel1_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
002b53 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase:
002b54 93c0 28ae                 	sts pulse2_fx_7xy_phase, r28 //store the new phase
002b56 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
002b57 ffc4                      	sbrs r28, 4
002b58 c001                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_0
002b59 c002                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel1_fx_7xy_routine_phase_0:
002b5a 70cf                      	andi r28, 0x0F //mask for values 0-15
002b5b c003                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase_1:
002b5c 6fc0                      	ori r28, 0xF0
002b5d 95c0                      	com r28 //invert values 0-15
002b5e c000                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_load:
002b5f 95b2                      	swap r27 //multiply depth by 16
002b60 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002b61 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002b62 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002b63 0fec                      	add ZL, r28 //offset the table by the depth+phase
002b64 1df2                      	adc ZH, zero
002b65 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002b66 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
002b67 93c0 28af                 	sts pulse2_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Axy_routine:
002b69 91b0 28b0                 	lds r27, pulse2_fx_Axy
002b6b 15b2                      	cp r27, zero
002b6c f0e9                      	breq sound_driver_channel1_fx_Qxy_routine //0 means that the effect is not in use
                                 	
002b6d 91a0 280d                 	lds r26, pulse2_fractional_volume //load fractional volume representation of the channel
002b6f 91c0 2808                 	lds r28, pulse2_param //load the integer volume representation of the channel
002b71 2fda                      	mov r29, r26 //copy fractional volume into r29
002b72 2fec                      	mov r30, r28 //copy the pulse2_param into r30
002b73 95e2                      	swap r30
002b74 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
002b75 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
002b76 17ed                      	cp r30, r29 //compare the fractional and integer volumes
002b77 f009                      	breq sound_driver_channel1_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel1_fx_Axy_routine_reload:
002b78 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate:
002b79 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
002b7a c004                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_addition:
002b7b 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002b7c f428                      	brcc sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002b7d efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
002b7e c003                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_subtraction:
002b7f 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002b80 f008                      	brcs sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002b81 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_store:
002b82 93a0 280d                 	sts pulse2_fractional_volume, r26 //store the new fractional volume
002b84 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
002b85 95a2                      	swap r26
002b86 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
002b87 2bca                      	or r28, r26 //store the new volume back into pulse2_param
002b88 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel1_fx_Qxy_routine:
002b8a 91e0 28b6                 	lds ZL, pulse2_fx_Qxy_target
002b8c 91f0 28b7                 	lds ZH, pulse2_fx_Qxy_target+1
002b8e 9630                      	adiw Z, 0
002b8f f119                      	breq sound_driver_channel1_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002b90 91a0 28ba                 	lds r26, pulse2_fx_Qxy_total_offset
002b92 91b0 28bb                 	lds r27, pulse2_fx_Qxy_total_offset+1
002b94 91c0 0a9c                 	lds r28, TCB1_CCMPL
002b96 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
002b98 1bec                      	sub ZL, r28 //calculate the difference to the target
002b99 0bfd                      	sbc ZH, r29
002b9a f408                      	brsh sound_driver_channel1_fx_Qxy_routine_end //if the target has been reached (or passed)
002b9b f068                      	brlo sound_driver_channel1_fx_Qxy_routine_add
                                 
                                 sound_driver_channel1_fx_Qxy_routine_end:
002b9c 9220 28ba                 	sts pulse2_fx_Qxy_total_offset, zero //turn off the effect
002b9e 9220 28bb                 	sts pulse2_fx_Qxy_total_offset+1, zero
002ba0 9220 28b6                 	sts pulse2_fx_Qxy_target, zero
002ba2 9220 28b7                 	sts pulse2_fx_Qxy_target+1, zero
002ba4 91b0 28b5                 	lds r27, pulse2_fx_Qxy_target_note
002ba6 93b0 280f                 	sts pulse2_note, r27 //replace the note with the final target note
002ba8 c00a                      	rjmp sound_driver_channel1_fx_Rxy_routine
                                 
                                 sound_driver_channel1_fx_Qxy_routine_add:
002ba9 91c0 28b8                 	lds r28, pulse2_fx_Qxy_speed
002bab 91d0 28b9                 	lds r29, pulse2_fx_Qxy_speed+1
002bad 0fac                      	add r26, r28 //increase the total offset by the speed
002bae 1fbd                      	adc r27, r29
002baf 93a0 28ba                 	sts pulse2_fx_Qxy_total_offset, r26 //store the total offset
002bb1 93b0 28bb                 	sts pulse2_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Rxy_routine:
002bb3 91e0 28bd                 	lds ZL, pulse2_fx_Rxy_target
002bb5 91f0 28be                 	lds ZH, pulse2_fx_Rxy_target+1
002bb7 9630                      	adiw Z, 0
002bb8 f119                      	breq sound_driver_instrument_routine_channel2_volume //if the effect is not enabled, skip the routine
                                 
002bb9 91a0 28c1                 	lds r26, pulse2_fx_Rxy_total_offset
002bbb 91b0 28c2                 	lds r27, pulse2_fx_Rxy_total_offset+1
002bbd 91c0 0a9c                 	lds r28, TCB1_CCMPL
002bbf 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
002bc1 1bce                      	sub r28, ZL //calculate the difference to the target
002bc2 0bdf                      	sbc r29, ZH
002bc3 f408                      	brsh sound_driver_channel1_fx_Rxy_routine_end //if the target has been reached (or passed)
002bc4 f068                      	brlo sound_driver_channel1_fx_Rxy_routine_add
                                 
                                 sound_driver_channel1_fx_Rxy_routine_end:
002bc5 9220 28c1                 	sts pulse2_fx_Rxy_total_offset, zero //disable the effect
002bc7 9220 28c2                 	sts pulse2_fx_Rxy_total_offset+1, zero
002bc9 9220 28bd                 	sts pulse2_fx_Rxy_target, zero
002bcb 9220 28be                 	sts pulse2_fx_Rxy_target+1, zero
002bcd 91b0 28bc                 	lds r27, pulse2_fx_Rxy_target_note
002bcf 93b0 280f                 	sts pulse2_note, r27 //replace the note with the final target note
002bd1 c00a                      	rjmp sound_driver_instrument_routine_channel2_volume
                                 
                                 sound_driver_channel1_fx_Rxy_routine_add:
002bd2 91c0 28bf                 	lds r28, pulse2_fx_Rxy_speed
002bd4 91d0 28c0                 	lds r29, pulse2_fx_Rxy_speed+1
002bd6 0fac                      	add r26, r28 //increase the total offset by the speed
002bd7 1fbd                      	adc r27, r29
002bd8 93a0 28c1                 	sts pulse2_fx_Rxy_total_offset, r26 //store the total offset
002bda 93b0 28c2                 	sts pulse2_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume:
002bdc 91e0 28cb                 	lds ZL, triangle_volume_macro
002bde 91f0 28cc                 	lds ZH, triangle_volume_macro+1
002be0 9630                      	adiw Z, 0
002be1 f199                      	breq sound_driver_instrument_routine_channel2_volume_default //if no volume macro is in use, do nothing
002be2 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002be3 1fff                      	rol ZH
002be4 91a0 28cd                 	lds r26, triangle_volume_macro_offset
002be6 0fea                      	add ZL, r26
002be7 1df2                      	adc ZH, zero
                                 
002be8 91b0 28cf                 	lds r27, triangle_volume_macro_release
002bea 17ba                      	cp r27, r26
002beb f429                      	brne sound_driver_instrument_routine_channel2_volume_increment //if the current offset is not equal to the release index, increment the offset
002bec 91a0 28ce                 	lds r26, triangle_volume_macro_loop
002bee 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002bef f010                      	brlo sound_driver_instrument_routine_channel2_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002bf0 c003                      	rjmp sound_driver_instrument_routine_channel2_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_volume_increment:
002bf1 95a3                      	inc r26 //increment the macro offset
002bf2 93a0 28cd                 	sts triangle_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_volume_read:
002bf4 91b4                      	lpm r27, Z //load volume data into r27
002bf5 3fbf                      	cpi r27, 0xFF //check for macro end flag
002bf6 f469                      	brne sound_driver_instrument_routine_channel2_volume_process //if the data was not the macro end flag
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_release:
002bf7 91b0 28cf                 	lds r27, triangle_volume_macro_release
002bf9 3fbf                      	cpi r27, 0xFF
002bfa f429                      	brne sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_loop:
002bfb 91b0 28ce                 	lds r27, triangle_volume_macro_loop //load the loop index
002bfd 93b0 28cd                 	sts triangle_volume_macro_offset, r27 //store the loop index into the offset
002bff cfdc                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index:
002c00 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002c01 93a0 28cd                 	sts triangle_volume_macro_offset, r26
002c03 cfd8                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_process:
002c04 15b2                      	cp r27, zero
002c05 f041                      	breq sound_driver_instrument_routine_channel2_volume_process_disable
                                 sound_driver_instrument_routine_channel2_volume_process_enable:
002c06 91b0 0aa5                 	lds r27, TCB2_INTCTRL
002c08 30b1                      	cpi r27, TCB_CAPT_bm
002c09 f459                      	brne sound_driver_instrument_routine_channel2_volume_default //if the channel has already been muted, don't enable it again
002c0a e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
002c0b 93b0 0aa5                 	sts TCB2_INTCTRL, r27
002c0d c007                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 sound_driver_instrument_routine_channel2_volume_process_disable:
002c0e 9220 0aa5                 	sts TCB2_INTCTRL, zero
002c10 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
002c12 9220 0aad                 	sts TCB2_CCMPH, zero
002c14 c000                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_volume_default:
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002c15 91e0 28d0                 	lds ZL, triangle_arpeggio_macro
002c17 91f0 28d1                 	lds ZH, triangle_arpeggio_macro+1
002c19 9630                      	adiw Z, 0
002c1a f1d9                      	breq sound_driver_instrument_routine_channel2_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002c1b 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002c1c 1fff                      	rol ZH
002c1d 91a0 28d2                 	lds r26, triangle_arpeggio_macro_offset
002c1f 0fea                      	add ZL, r26
002c20 1df2                      	adc ZH, zero
                                 
002c21 91b0 28d4                 	lds r27, triangle_arpeggio_macro_release
002c23 17ba                      	cp r27, r26
002c24 f429                      	brne sound_driver_instrument_routine_channel2_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002c25 91a0 28d3                 	lds r26, triangle_arpeggio_macro_loop
002c27 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002c28 f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002c29 c003                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_increment:
002c2a 95a3                      	inc r26 //increment the macro offset
002c2b 93a0 28d2                 	sts triangle_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_read:
002c2d 91b4                      	lpm r27, Z //load arpeggio data into r27
002c2e 38b0                      	cpi r27, 0x80 //check for macro end flag
002c2f f009                      	breq sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag
002c30 c041                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_check_mode:
002c31 50a1                      	subi r26, 1 //keep the offset at the end flag
002c32 93a0 28d2                 	sts triangle_arpeggio_macro_offset, r26
002c34 91b0 28d5                 	lds r27, triangle_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002c36 30b1                      	cpi r27, 0x01
002c37 f048                      	brlo sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_release:
002c38 91b0 28d4                 	lds r27, triangle_arpeggio_macro_release
002c3a 3fbf                      	cpi r27, 0xFF
002c3b f4d1                      	brne sound_driver_instrument_routine_channel2_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_loop:
002c3c 91b0 28d3                 	lds r27, triangle_arpeggio_macro_loop
002c3e 3fbf                      	cpi r27, 0xFF
002c3f f499                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002c40 c015                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute:
002c41 91b0 28d4                 	lds r27, triangle_arpeggio_macro_release
002c43 3fbf                      	cpi r27, 0xFF
002c44 f421                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_check_loop:
002c45 91b0 28d3                 	lds r27, triangle_arpeggio_macro_loop //load the loop index
002c47 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002c48 f451                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop:
002c49 91c0 28e8                 	lds r28, triangle_fx_0xy_sequence //check for 0xy effect
002c4b 91d0 28e9                 	lds r29, triangle_fx_0xy_sequence+1
002c4d 9620                      	adiw r29:r28, 0
002c4e f469                      	brne sound_driver_instrument_routine_channel2_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002c4f 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002c50 93a0 28d2                 	sts triangle_arpeggio_macro_offset, r26 //store the last valid index into the offset
002c52 cfc2                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload:
002c53 93b0 28d2                 	sts triangle_arpeggio_macro_offset, r27 //store the loop index into the offset
002c55 cfbf                      	rjmp sound_driver_instrument_routine_channel2_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_default:
002c56 91c0 28e8                 	lds r28, triangle_fx_0xy_sequence //load 0xy effect
002c58 91d0 28e9                 	lds r29, triangle_fx_0xy_sequence+1
002c5a 9620                      	adiw r29:r28, 0 //check for 0xy effect
002c5b f099                      	breq sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel2_arpeggio_default_0xy:
002c5c 95d6                      	lsr r29
002c5d 95c7                      	ror r28
002c5e 95d7                      	ror r29
002c5f 95c7                      	ror r28
002c60 95d7                      	ror r29
002c61 95c7                      	ror r28
002c62 95d7                      	ror r29
002c63 95c7                      	ror r28
002c64 95d7                      	ror r29
002c65 95d2                      	swap r29
                                 
002c66 93c0 28e8                 	sts triangle_fx_0xy_sequence, r28 //store the rolled sequence
002c68 93d0 28e9                 	sts triangle_fx_0xy_sequence+1, r29
002c6a 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002c6b 91a0 2812                 	lds r26, triangle_note //load the current note index
002c6d 0fac                      	add r26, r28 //add the note offset
002c6e c02e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002c6f 91a0 2812                 	lds r26, triangle_note //load the current note index
002c71 c02b                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process:
002c72 9220 28d6                 	sts triangle_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002c74 9220 28d7                 	sts triangle_total_pitch_offset+1, zero
002c76 9220 28dd                 	sts triangle_total_hi_pitch_offset, zero
002c78 91a0 28d5                 	lds r26, triangle_arpeggio_macro_mode
002c7a 30a1                      	cpi r26, 0x01 //absolute mode
002c7b f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_absolute
002c7c f069                      	breq sound_driver_instrument_routine_channel2_arpeggio_process_fixed
002c7d c00e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute:
002c7e 91a0 2812                 	lds r26, triangle_note //load the current note index
002c80 0fab                      	add r26, r27 //offset the note with the arpeggio data
002c81 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002c82 c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_add:
002c83 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002c84 f0c0                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
002c85 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002c86 c016                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract:
002c87 fda7                      	sbrc r26, 7 //check if result is negative
002c88 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002c89 c013                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_fixed:
002c8a 2fab                      	mov r26, r27 //move the arpeggio data into r26
002c8b c011                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative:
002c8c 91a0 2812                 	lds r26, triangle_note //load the current note index
002c8e 0fab                      	add r26, r27 //offset the note with the arpeggio data
002c8f fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002c90 c008                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_add:
002c91 93a0 2812                 	sts triangle_note, r26 //NOTE: relative mode modifies the original note index
002c93 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002c94 f040                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
002c95 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002c96 93a0 2812                 	sts triangle_note, r26
002c98 c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract:
002c99 fda7                      	sbrc r26, 7 //check if result is negative
002c9a e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002c9b 93a0 2812                 	sts triangle_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_load:
002c9d e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
002c9e e0f0                      	ldi ZH, HIGH(note_table << 1)
002c9f 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002ca0 0fea                      	add ZL, r26 //add offset
002ca1 1df2                      	adc ZH, zero
002ca2 91a5                      	lpm r26, Z+ //load bytes
002ca3 91b4                      	lpm r27, Z
002ca4 93a0 0aac                 	sts TCB2_CCMPL, r26 //load the LOW bits for timer
002ca6 93b0 0aad                 	sts TCB2_CCMPH, r27 //load the HIGH bits for timer
002ca8 93a0 28f4                 	sts triangle_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002caa 93b0 28f5                 	sts triangle_fx_3xx_target+1, r27
002cac c000                      	rjmp sound_driver_instrument_routine_channel2_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch:
002cad 91e0 28d8                 	lds ZL, triangle_pitch_macro
002caf 91f0 28d9                 	lds ZH, triangle_pitch_macro+1
002cb1 9630                      	adiw Z, 0
002cb2 f409                      	brne sound_driver_instrument_routine_channel2_pitch_continue
002cb3 c023                      	rjmp sound_driver_instrument_routine_channel2_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel2_pitch_continue:
002cb4 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002cb5 1fff                      	rol ZH
002cb6 91a0 28da                 	lds r26, triangle_pitch_macro_offset
002cb8 0fea                      	add ZL, r26
002cb9 1df2                      	adc ZH, zero
                                 
002cba 91b0 28dc                 	lds r27, triangle_pitch_macro_release
002cbc 17ba                      	cp r27, r26
002cbd f429                      	brne sound_driver_instrument_routine_channel2_pitch_increment //if the current offset is not equal to the release index, increment the offset
002cbe 91a0 28db                 	lds r26, triangle_pitch_macro_loop
002cc0 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002cc1 f010                      	brlo sound_driver_instrument_routine_channel2_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002cc2 c003                      	rjmp sound_driver_instrument_routine_channel2_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_pitch_increment:
002cc3 95a3                      	inc r26 //increment the macro offset
002cc4 93a0 28da                 	sts triangle_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_pitch_read:
002cc6 91b4                      	lpm r27, Z //load pitch data into r27
002cc7 38b0                      	cpi r27, 0x80 //check for macro end flag
002cc8 f479                      	brne sound_driver_instrument_routine_channel2_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_release:
002cc9 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002cca 93a0 28da                 	sts triangle_pitch_macro_offset, r26
002ccc 91b0 28dc                 	lds r27, triangle_pitch_macro_release
002cce 3fbf                      	cpi r27, 0xFF
002ccf f439                      	brne sound_driver_instrument_routine_channel2_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_loop:
002cd0 91b0 28db                 	lds r27, triangle_pitch_macro_loop //load the loop index
002cd2 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002cd3 f019                      	breq sound_driver_instrument_routine_channel2_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002cd4 93b0 28da                 	sts triangle_pitch_macro_offset, r27 //store the loop index into the offset
002cd6 cfd6                      	rjmp sound_driver_instrument_routine_channel2_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_default:
002cd7 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel2_pitch_calculate:
002cd8 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002cd9 937f                      	push r23
002cda 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
002cdb eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002cdc 0367                      	mulsu r22, r23
002cdd 917f                      	pop r23
002cde 916f                      	pop r22
                                 
002cdf 9416                      	lsr r1 //shift out the fractional bits
002ce0 9407                      	ror r0
002ce1 9416                      	lsr r1
002ce2 9407                      	ror r0
002ce3 9416                      	lsr r1
002ce4 9407                      	ror r0
002ce5 9416                      	lsr r1
002ce6 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_check_negative:
002ce7 fe13                      	sbrs r1, 3 //check if result was a negative number
002ce8 c007                      	rjmp sound_driver_instrument_routine_channel2_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_negative:
002ce9 efc0                      	ldi r28, 0xF0
002cea 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_check_divisible_8:
002ceb 70b7                      	andi r27, 0b00000111
002cec f019                      	breq sound_driver_instrument_routine_channel2_pitch_calculate_offset
                                 
002ced e0b1                      	ldi r27, 0x01
002cee 0e0b                      	add r0, r27
002cef 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_offset:
002cf0 91a0 28d6                 	lds r26, triangle_total_pitch_offset
002cf2 91b0 28d7                 	lds r27, triangle_total_pitch_offset+1
002cf4 0e0a                      	add r0, r26
002cf5 1e1b                      	adc r1, r27
002cf6 9200 28d6                 	sts triangle_total_pitch_offset, r0
002cf8 9210 28d7                 	sts triangle_total_pitch_offset+1, r1
002cfa 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
002cfc 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
002cfe 0da0                      	add r26, r0 //offset the timer values
002cff 1db1                      	adc r27, r1
                                 	
002d00 91c0 28ec                 	lds r28, triangle_fx_1xx_total
002d02 91d0 28ed                 	lds r29, triangle_fx_1xx_total+1
002d04 1bac                      	sub r26, r28
002d05 0bbd                      	sbc r27, r29
002d06 91c0 28f0                 	lds r28, triangle_fx_2xx_total
002d08 91d0 28f1                 	lds r29, triangle_fx_2xx_total+1
002d0a 0fac                      	add r26, r28
002d0b 1fbd                      	adc r27, r29
002d0c 91c0 28ff                 	lds r28, triangle_fx_Pxx_total
002d0e 91d0 2900                 	lds r29, triangle_fx_Pxx_total+1
002d10 0fac                      	add r26, r28
002d11 1fbd                      	adc r27, r29
002d12 91c0 2906                 	lds r28, triangle_fx_Qxy_total_offset
002d14 91d0 2907                 	lds r29, triangle_fx_Qxy_total_offset+1
002d16 1bac                      	sub r26, r28
002d17 0bbd                      	sbc r27, r29
002d18 91c0 290d                 	lds r28, triangle_fx_Rxy_total_offset
002d1a 91d0 290e                 	lds r29, triangle_fx_Rxy_total_offset+1
002d1c 0fac                      	add r26, r28
002d1d 1fbd                      	adc r27, r29
                                 
002d1e e5c9                      	ldi r28, 0x59
002d1f e0d0                      	ldi r29, 0x00
002d20 17ac                      	cp r26, r28
002d21 07bd                      	cpc r27, r29
002d22 f030                      	brlo sound_driver_instrument_routine_channel2_pitch_min
                                 
002d23 e5ca                      	ldi r28, 0x5A
002d24 e5d9                      	ldi r29, 0x59
002d25 17ac                      	cp r26, r28
002d26 07bd                      	cpc r27, r29
002d27 f420                      	brsh sound_driver_instrument_routine_channel2_pitch_max
002d28 c006                      	rjmp sound_driver_instrument_routine_channel2_pitch_store
                                 
                                 sound_driver_instrument_routine_channel2_pitch_min:
002d29 e5c9                      	ldi r28, 0x59
002d2a e0d0                      	ldi r29, 0x00
002d2b c003                      	rjmp sound_driver_instrument_routine_channel2_pitch_store
                                 
                                 sound_driver_instrument_routine_channel2_pitch_max:
002d2c e5c9                      	ldi r28, 0x59
002d2d e5d9                      	ldi r29, 0x59
002d2e c000                      	rjmp sound_driver_instrument_routine_channel2_pitch_store
                                 
                                 sound_driver_instrument_routine_channel2_pitch_store:
002d2f 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
002d31 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel2_hi_pitch:
002d33 91e0 28de                 	lds ZL, triangle_hi_pitch_macro
002d35 91f0 28df                 	lds ZH, triangle_hi_pitch_macro+1
002d37 9630                      	adiw Z, 0
002d38 f409                      	brne sound_driver_instrument_routine_channel2_hi_pitch_continue
002d39 c03c                      	rjmp sound_driver_instrument_routine_channel2_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel2_hi_pitch_continue:
002d3a 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002d3b 1fff                      	rol ZH
002d3c 91a0 28e0                 	lds r26, triangle_hi_pitch_macro_offset
002d3e 0fea                      	add ZL, r26
002d3f 1df2                      	adc ZH, zero
                                 
002d40 91b0 28e2                 	lds r27, triangle_hi_pitch_macro_release
002d42 17ba                      	cp r27, r26
002d43 f429                      	brne sound_driver_instrument_routine_channel2_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002d44 91a0 28e1                 	lds r26, triangle_hi_pitch_macro_loop
002d46 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002d47 f010                      	brlo sound_driver_instrument_routine_channel2_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002d48 c003                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_increment:
002d49 95a3                      	inc r26 //increment the macro offset
002d4a 93a0 28e0                 	sts triangle_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_hi_pitch_read:
002d4c 91b4                      	lpm r27, Z //load hi pitch data into r27
002d4d 38b0                      	cpi r27, 0x80 //check for macro end flag
002d4e f489                      	brne sound_driver_instrument_routine_channel2_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_release:
002d4f 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002d50 93a0 28e0                 	sts triangle_hi_pitch_macro_offset, r26
002d52 91b0 28e2                 	lds r27, triangle_hi_pitch_macro_release
002d54 3fbf                      	cpi r27, 0xFF
002d55 f439                      	brne sound_driver_instrument_routine_channel2_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_loop:
002d56 91b0 28e1                 	lds r27, triangle_hi_pitch_macro_loop //load the loop index
002d58 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002d59 f019                      	breq sound_driver_instrument_routine_channel2_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002d5a 93b0 28e0                 	sts triangle_hi_pitch_macro_offset, r27 //store the loop index into the offset
002d5c cfd6                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_default:
002d5d 91b0 28dd                 	lds r27, triangle_total_hi_pitch_offset
002d5f c005                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate:
002d60 91a0 28dd                 	lds r26, triangle_total_hi_pitch_offset //load the total hi pitch offset to change
002d62 0fba                      	add r27, r26
002d63 93b0 28dd                 	sts triangle_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply:
002d65 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002d66 937f                      	push r23
002d67 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002d68 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002d69 0367                      	mulsu r22, r23
002d6a 917f                      	pop r23
002d6b 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_offset:
002d6c 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
002d6e 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
002d70 0da0                      	add r26, r0 //offset the timer values
002d71 1db1                      	adc r27, r1
002d72 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
002d74 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: The triangle channel does not have a duty cycle
                                 sound_driver_instrument_routine_channel2_duty:
                                 
                                 
                                 
                                 sound_driver_channel2_fx_routines:
                                 sound_driver_channel2_fx_1xx_routine:
002d76 91e0 28ea                 	lds ZL, triangle_fx_1xx
002d78 91f0 28eb                 	lds ZH, triangle_fx_1xx+1
002d7a 9630                      	adiw Z, 0
002d7b f051                      	breq sound_driver_channel2_fx_2xx_routine
                                 
002d7c 91a0 28ec                 	lds r26, triangle_fx_1xx_total //load the rate to change the pitch by
002d7e 91b0 28ed                 	lds r27, triangle_fx_1xx_total+1
002d80 0fae                      	add r26, ZL //increase the total offset by the rate
002d81 1fbf                      	adc r27, ZH
002d82 93a0 28ec                 	sts triangle_fx_1xx_total, r26
002d84 93b0 28ed                 	sts triangle_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_2xx_routine:
002d86 91e0 28ee                 	lds ZL, triangle_fx_2xx
002d88 91f0 28ef                 	lds ZH, triangle_fx_2xx+1
002d8a 9630                      	adiw Z, 0
002d8b f051                      	breq sound_driver_channel2_fx_3xx_routine
                                 
002d8c 91a0 28f0                 	lds r26, triangle_fx_2xx_total //load the rate to change the pitch by
002d8e 91b0 28f1                 	lds r27, triangle_fx_2xx_total+1
002d90 0fae                      	add r26, ZL //increase the total offset by the rate
002d91 1fbf                      	adc r27, ZH
002d92 93a0 28f0                 	sts triangle_fx_2xx_total, r26
002d94 93b0 28f1                 	sts triangle_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_3xx_routine:
002d96 91e0 28f6                 	lds ZL, triangle_fx_3xx_speed
002d98 91f0 28f7                 	lds ZH, triangle_fx_3xx_speed+1
002d9a 9630                      	adiw Z, 0
002d9b f409                      	brne sound_driver_channel2_fx_3xx_routine_check_start
002d9c c048                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_check_start:
002d9d 91a0 28f2                 	lds r26, triangle_fx_3xx_start
002d9f 91b0 28f3                 	lds r27, triangle_fx_3xx_start+1
002da1 9610                      	adiw r26:r27, 0
002da2 f409                      	brne sound_driver_channel2_fx_3xx_routine_main
002da3 c041                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_main:
002da4 91c0 28f4                 	lds r28, triangle_fx_3xx_target
002da6 91d0 28f5                 	lds r29, triangle_fx_3xx_target+1
                                 
002da8 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
002da9 07bd                      	cpc r27, r29
002daa f011                      	breq sound_driver_channel2_fx_3xx_routine_disable
002dab f030                      	brlo sound_driver_channel2_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002dac c01f                      	rjmp sound_driver_channel2_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel2_fx_3xx_routine_disable:
002dad 9220 28f2                 	sts triangle_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002daf 9220 28f3                 	sts triangle_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002db1 c033                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_subtract:
002db2 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002db3 0bdb                      	sbc r29, r27
002db4 91a0 28f8                 	lds r26, triangle_fx_3xx_total_offset
002db6 91b0 28f9                 	lds r27, triangle_fx_3xx_total_offset+1
                                 
002db8 0fae                      	add r26, ZL //add the speed to the total offset
002db9 1fbf                      	adc r27, ZH
002dba 1bca                      	sub r28, r26 //invert the total difference with the total offset
002dbb 0bdb                      	sbc r29, r27
002dbc f380                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002dbd 93a0 28f8                 	sts triangle_fx_3xx_total_offset, r26 //store the new total offset
002dbf 93b0 28f9                 	sts triangle_fx_3xx_total_offset+1, r27
                                 
002dc1 91a0 0aac                 	lds r26, TCB2_CCMPL //load the current timer period
002dc3 91b0 0aad                 	lds r27, TCB2_CCMPH
002dc5 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002dc6 0bbd                      	sbc r27, r29
002dc7 93a0 0aac                 	sts TCB2_CCMPL, r26
002dc9 93b0 0aad                 	sts TCB2_CCMPH, r27
002dcb c019                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_add:
002dcc 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002dcd 0bbd                      	sbc r27, r29
002dce 91c0 28f8                 	lds r28, triangle_fx_3xx_total_offset
002dd0 91d0 28f9                 	lds r29, triangle_fx_3xx_total_offset+1
                                 
002dd2 0fce                      	add r28, ZL //add the speed to the total offset
002dd3 1fdf                      	adc r29, ZH
002dd4 1bac                      	sub r26, r28 //invert the total difference with the total offset
002dd5 0bbd                      	sbc r27, r29
002dd6 f2b0                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002dd7 93c0 28f8                 	sts triangle_fx_3xx_total_offset, r28 //store the new total offset
002dd9 93d0 28f9                 	sts triangle_fx_3xx_total_offset+1, r29
                                 
002ddb 91c0 0aac                 	lds r28, TCB2_CCMPL //load the current timer period
002ddd 91d0 0aad                 	lds r29, TCB2_CCMPH
002ddf 0fca                      	add r28, r26 //offset the current timer period with the total offset
002de0 1fdb                      	adc r29, r27
002de1 93c0 0aac                 	sts TCB2_CCMPL, r28
002de3 93d0 0aad                 	sts TCB2_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel2_fx_4xy_routine:
002de5 91a0 28fa                 	lds r26, triangle_fx_4xy_speed
002de7 15a2                      	cp r26, zero
002de8 f409                      	brne sound_driver_channel2_fx_4xy_routine_continue
002de9 c05c                      	rjmp sound_driver_channel2_fx_Qxy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel2_fx_4xy_routine_continue:
002dea 91b0 28fb                 	lds r27, triangle_fx_4xy_depth
002dec 91c0 28fc                 	lds r28, triangle_fx_4xy_phase
002dee 0fca                      	add r28, r26 //increase the phase by the speed
002def 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002df0 f008                      	brlo sound_driver_channel2_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002df1 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase:
002df2 93c0 28fc                 	sts triangle_fx_4xy_phase, r28 //store the new phase
002df4 31c0                      	cpi r28, 16
002df5 f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_0
002df6 32c0                      	cpi r28, 32
002df7 f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_1
002df8 33c0                      	cpi r28, 48
002df9 f030                      	brlo sound_driver_channel2_fx_4xy_routine_phase_2
002dfa c007                      	rjmp sound_driver_channel2_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_0:
002dfb 70cf                      	andi r28, 0x0F //mask for values 0-15
002dfc c029                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_1:
002dfd 6fc0                      	ori r28, 0xF0
002dfe 95c0                      	com r28 //invert values 0-15
002dff c026                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_2:
002e00 70cf                      	andi r28, 0x0F //mask for values 0-15
002e01 c003                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_3:
002e02 6fc0                      	ori r28, 0xF0
002e03 95c0                      	com r28 //invert values 0-15
002e04 c000                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_add:
002e05 95b2                      	swap r27 //multiply depth by 16
002e06 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002e07 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002e08 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002e09 0fec                      	add ZL, r28 //offset the table by the depth+phase
002e0a 1df2                      	adc ZH, zero
002e0b 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002e0c 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002e0d 937f                      	push r23
002e0e 2f6c                      	mov r22, r28 //store the vibrato value into r22
002e0f eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002e10 9f67                      	mul r22, r23
002e11 917f                      	pop r23
002e12 916f                      	pop r22
                                 
002e13 9416                      	lsr r1 //shift out the fractional bits
002e14 9407                      	ror r0
002e15 9416                      	lsr r1
002e16 9407                      	ror r0
002e17 9416                      	lsr r1
002e18 9407                      	ror r0
002e19 9416                      	lsr r1
002e1a 9407                      	ror r0
                                 	
002e1b 91a0 0aac                 	lds r26, TCB2_CCMPL
002e1d 91b0 0aad                 	lds r27, TCB2_CCMPH
002e1f 0da0                      	add r26, r0
002e20 1db1                      	adc r27, r1
002e21 93a0 0aac                 	sts TCB2_CCMPL, r26
002e23 93b0 0aad                 	sts TCB2_CCMPH, r27
002e25 c020                      	rjmp sound_driver_channel2_fx_Qxy_routine
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_subtract:
002e26 95b2                      	swap r27 //multiply depth by 16
002e27 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002e28 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002e29 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002e2a 0fec                      	add ZL, r28 //offset the table by the depth+phase
002e2b 1df2                      	adc ZH, zero
002e2c 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002e2d 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002e2e 937f                      	push r23
002e2f 2f6c                      	mov r22, r28 //store the vibrato value into r22
002e30 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002e31 9f67                      	mul r22, r23
002e32 917f                      	pop r23
002e33 916f                      	pop r22
                                 
002e34 9416                      	lsr r1 //shift out the fractional bits
002e35 9407                      	ror r0
002e36 9416                      	lsr r1
002e37 9407                      	ror r0
002e38 9416                      	lsr r1
002e39 9407                      	ror r0
002e3a 9416                      	lsr r1
002e3b 9407                      	ror r0
                                 
002e3c 91a0 0aac                 	lds r26, TCB2_CCMPL
002e3e 91b0 0aad                 	lds r27, TCB2_CCMPH
002e40 19a0                      	sub r26, r0
002e41 09b1                      	sbc r27, r1
002e42 93a0 0aac                 	sts TCB2_CCMPL, r26
002e44 93b0 0aad                 	sts TCB2_CCMPH, r27
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel2_fx_Qxy_routine:
002e46 91e0 2902                 	lds ZL, triangle_fx_Qxy_target
002e48 91f0 2903                 	lds ZH, triangle_fx_Qxy_target+1
002e4a 9630                      	adiw Z, 0
002e4b f119                      	breq sound_driver_channel2_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002e4c 91a0 2906                 	lds r26, triangle_fx_Qxy_total_offset
002e4e 91b0 2907                 	lds r27, triangle_fx_Qxy_total_offset+1
002e50 91c0 0aac                 	lds r28, TCB2_CCMPL
002e52 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
002e54 1bec                      	sub ZL, r28 //calculate the difference to the target
002e55 0bfd                      	sbc ZH, r29
002e56 f408                      	brsh sound_driver_channel2_fx_Qxy_routine_end //if the target has been reached (or passed)
002e57 f068                      	brlo sound_driver_channel2_fx_Qxy_routine_add
                                 
                                 sound_driver_channel2_fx_Qxy_routine_end:
002e58 9220 2906                 	sts triangle_fx_Qxy_total_offset, zero //turn off the effect
002e5a 9220 2907                 	sts triangle_fx_Qxy_total_offset+1, zero
002e5c 9220 2902                 	sts triangle_fx_Qxy_target, zero
002e5e 9220 2903                 	sts triangle_fx_Qxy_target+1, zero
002e60 91b0 2901                 	lds r27, triangle_fx_Qxy_target_note
002e62 93b0 2812                 	sts triangle_note, r27 //replace the note with the final target note
002e64 c00a                      	rjmp sound_driver_channel2_fx_Rxy_routine
                                 
                                 sound_driver_channel2_fx_Qxy_routine_add:
002e65 91c0 2904                 	lds r28, triangle_fx_Qxy_speed
002e67 91d0 2905                 	lds r29, triangle_fx_Qxy_speed+1
002e69 0fac                      	add r26, r28 //increase the total offset by the speed
002e6a 1fbd                      	adc r27, r29
002e6b 93a0 2906                 	sts triangle_fx_Qxy_total_offset, r26 //store the total offset
002e6d 93b0 2907                 	sts triangle_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_Rxy_routine:
002e6f 91e0 2909                 	lds ZL, triangle_fx_Rxy_target
002e71 91f0 290a                 	lds ZH, triangle_fx_Rxy_target+1
002e73 9630                      	adiw Z, 0
002e74 f119                      	breq sound_driver_instrument_routine_channel3_volume //if the effect is not enabled, skip the routine
                                 
002e75 91a0 290d                 	lds r26, triangle_fx_Rxy_total_offset
002e77 91b0 290e                 	lds r27, triangle_fx_Rxy_total_offset+1
002e79 91c0 0aac                 	lds r28, TCB2_CCMPL
002e7b 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
002e7d 1bce                      	sub r28, ZL //calculate the difference to the target
002e7e 0bdf                      	sbc r29, ZH
002e7f f408                      	brsh sound_driver_channel2_fx_Rxy_routine_end //if the target has been reached (or passed)
002e80 f068                      	brlo sound_driver_channel2_fx_Rxy_routine_add
                                 
                                 sound_driver_channel2_fx_Rxy_routine_end:
002e81 9220 290d                 	sts triangle_fx_Rxy_total_offset, zero //disable the effect
002e83 9220 290e                 	sts triangle_fx_Rxy_total_offset+1, zero
002e85 9220 2909                 	sts triangle_fx_Rxy_target, zero
002e87 9220 290a                 	sts triangle_fx_Rxy_target+1, zero
002e89 91b0 2908                 	lds r27, triangle_fx_Rxy_target_note
002e8b 93b0 2812                 	sts triangle_note, r27 //replace the note with the final target note
002e8d c00a                      	rjmp sound_driver_instrument_routine_channel3_volume
                                 
                                 sound_driver_channel2_fx_Rxy_routine_add:
002e8e 91c0 290b                 	lds r28, triangle_fx_Rxy_speed
002e90 91d0 290c                 	lds r29, triangle_fx_Rxy_speed+1
002e92 0fac                      	add r26, r28 //increase the total offset by the speed
002e93 1fbd                      	adc r27, r29
002e94 93a0 290d                 	sts triangle_fx_Rxy_total_offset, r26 //store the total offset
002e96 93b0 290e                 	sts triangle_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume:
002e98 91e0 2917                 	lds ZL, noise_volume_macro
002e9a 91f0 2918                 	lds ZH, noise_volume_macro+1
002e9c 9630                      	adiw Z, 0
002e9d f1a1                      	breq sound_driver_instrument_routine_channel3_volume_default //if no volume macro is in use, use default multiplier of F
002e9e 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002e9f 1fff                      	rol ZH
002ea0 91a0 2919                 	lds r26, noise_volume_macro_offset
002ea2 0fea                      	add ZL, r26
002ea3 1df2                      	adc ZH, zero
                                 
002ea4 91b0 291b                 	lds r27, noise_volume_macro_release
002ea6 17ba                      	cp r27, r26
002ea7 f429                      	brne sound_driver_instrument_routine_channel3_volume_increment //if the current offset is not equal to the release index, increment the offset
002ea8 91a0 291a                 	lds r26, noise_volume_macro_loop
002eaa 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002eab f010                      	brlo sound_driver_instrument_routine_channel3_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002eac c003                      	rjmp sound_driver_instrument_routine_channel3_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_volume_increment:
002ead 95a3                      	inc r26 //increment the macro offset
002eae 93a0 2919                 	sts noise_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_volume_read:
002eb0 91b4                      	lpm r27, Z //load volume data into r27
002eb1 3fbf                      	cpi r27, 0xFF //check for macro end flag
002eb2 f469                      	brne sound_driver_instrument_routine_channel3_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_check_release:
002eb3 91b0 291b                 	lds r27, noise_volume_macro_release
002eb5 3fbf                      	cpi r27, 0xFF
002eb6 f429                      	brne sound_driver_instrument_routine_channel3_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_check_loop:
002eb7 91b0 291a                 	lds r27, noise_volume_macro_loop //load the loop index
002eb9 93b0 2919                 	sts noise_volume_macro_offset, r27 //store the loop index into the offset
002ebb cfdc                      	rjmp sound_driver_instrument_routine_channel3_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_last_index:
002ebc 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002ebd 93a0 2919                 	sts noise_volume_macro_offset, r26
002ebf cfd8                      	rjmp sound_driver_instrument_routine_channel3_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume_calculate:
002ec0 eaea                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
002ec1 e6f2                      	ldi ZH, HIGH(volumes << 1)
002ec2 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
002ec3 0feb                      	add ZL, r27 //add offset to the table
002ec4 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel3_volume_load:
002ec5 91b0 2813                 	lds r27, noise_param //load main volume
002ec7 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002ec8 91a0 2941                 	lds r26, noise_fx_7xy_value
002eca 30a0                      	cpi r26, 0x00
002ecb f481                      	brne sound_driver_instrument_routine_channel3_volume_load_7xy
                                 
002ecc 0feb                      	add ZL, r27 //offset the volume table by the main volume
002ecd 1df2                      	adc ZH, zero
002ece 91b4                      	lpm r27, Z
002ecf 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002ed1 c023                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_default:
002ed2 91b0 2813                 	lds r27, noise_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
002ed4 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002ed5 91a0 2941                 	lds r26, noise_fx_7xy_value
002ed7 30a0                      	cpi r26, 0x00
002ed8 f499                      	brne sound_driver_instrument_routine_channel3_volume_default_7xy
002ed9 93b0 2816                 	sts noise_output_volume, r27
002edb c019                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_load_7xy:
002edc 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002edd f038                      	brcs sound_driver_instrument_routine_channel3_volume_load_7xy_overflow
002ede f031                      	breq sound_driver_instrument_routine_channel3_volume_load_7xy_overflow
                                 
002edf 0feb                      	add ZL, r27 //offset the volume table by the main volume
002ee0 1df2                      	adc ZH, zero
002ee1 91b4                      	lpm r27, Z
002ee2 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002ee4 c010                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_load_7xy_overflow:
002ee5 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002ee6 0feb                      	add ZL, r27 //offset the volume table by the main volume
002ee7 1df2                      	adc ZH, zero
002ee8 91b4                      	lpm r27, Z
002ee9 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002eeb c009                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_default_7xy:
002eec 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002eed f020                      	brcs sound_driver_instrument_routine_channel3_volume_default_7xy_overflow
002eee f019                      	breq sound_driver_instrument_routine_channel3_volume_default_7xy_overflow
002eef 93b0 2816                 	sts noise_output_volume, r27
002ef1 c003                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel3_volume_default_7xy_overflow:
002ef2 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002ef3 93b0 2816                 	sts noise_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002ef5 91e0 291c                 	lds ZL, noise_arpeggio_macro
002ef7 91f0 291d                 	lds ZH, noise_arpeggio_macro+1
002ef9 9630                      	adiw Z, 0
002efa f1d9                      	breq sound_driver_instrument_routine_channel3_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002efb 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002efc 1fff                      	rol ZH
002efd 91a0 291e                 	lds r26, noise_arpeggio_macro_offset
002eff 0fea                      	add ZL, r26
002f00 1df2                      	adc ZH, zero
                                 
002f01 91b0 2920                 	lds r27, noise_arpeggio_macro_release
002f03 17ba                      	cp r27, r26
002f04 f429                      	brne sound_driver_instrument_routine_channel3_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002f05 91a0 291f                 	lds r26, noise_arpeggio_macro_loop
002f07 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002f08 f010                      	brlo sound_driver_instrument_routine_channel3_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002f09 c003                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_increment:
002f0a 95a3                      	inc r26 //increment the macro offset
002f0b 93a0 291e                 	sts noise_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_arpeggio_read:
002f0d 91b4                      	lpm r27, Z //load arpeggio data into r27
002f0e 38b0                      	cpi r27, 0x80 //check for macro end flag
002f0f f009                      	breq sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag
002f10 c041                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_check_mode:
002f11 50a1                      	subi r26, 1 //keep the offset at the end flag
002f12 93a0 291e                 	sts noise_arpeggio_macro_offset, r26
002f14 91b0 2921                 	lds r27, noise_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002f16 30b1                      	cpi r27, 0x01
002f17 f048                      	brlo sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_fixed_relative_check_release:
002f18 91b0 2920                 	lds r27, noise_arpeggio_macro_release
002f1a 3fbf                      	cpi r27, 0xFF
002f1b f4d1                      	brne sound_driver_instrument_routine_channel3_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_fixed_relative_check_loop:
002f1c 91b0 291f                 	lds r27, noise_arpeggio_macro_loop
002f1e 3fbf                      	cpi r27, 0xFF
002f1f f499                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002f20 c015                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute:
002f21 91b0 2920                 	lds r27, noise_arpeggio_macro_release
002f23 3fbf                      	cpi r27, 0xFF
002f24 f421                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_check_loop:
002f25 91b0 291f                 	lds r27, noise_arpeggio_macro_loop //load the loop index
002f27 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002f28 f451                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_no_loop:
002f29 91c0 2934                 	lds r28, noise_fx_0xy_sequence //check for 0xy effect
002f2b 91d0 2935                 	lds r29, noise_fx_0xy_sequence+1
002f2d 9620                      	adiw r29:r28, 0
002f2e f469                      	brne sound_driver_instrument_routine_channel3_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002f2f 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002f30 93a0 291e                 	sts noise_arpeggio_macro_offset, r26 //store the last valid index into the offset
002f32 cfc2                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload:
002f33 93b0 291e                 	sts noise_arpeggio_macro_offset, r27 //store the loop index into the offset
002f35 cfbf                      	rjmp sound_driver_instrument_routine_channel3_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_default:
002f36 91c0 2934                 	lds r28, noise_fx_0xy_sequence //load 0xy effect
002f38 91d0 2935                 	lds r29, noise_fx_0xy_sequence+1
002f3a 9620                      	adiw r29:r28, 0 //check for 0xy effect
002f3b f099                      	breq sound_driver_instrument_routine_channel3_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel3_arpeggio_default_0xy:
002f3c 95d6                      	lsr r29
002f3d 95c7                      	ror r28
002f3e 95d7                      	ror r29
002f3f 95c7                      	ror r28
002f40 95d7                      	ror r29
002f41 95c7                      	ror r28
002f42 95d7                      	ror r29
002f43 95c7                      	ror r28
002f44 95d7                      	ror r29
002f45 95d2                      	swap r29
                                 
002f46 93c0 2934                 	sts noise_fx_0xy_sequence, r28 //store the rolled sequence
002f48 93d0 2935                 	sts noise_fx_0xy_sequence+1, r29
002f4a 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002f4b 91a0 2817                 	lds r26, noise_note //load the current note index
002f4d 0fac                      	add r26, r28 //add the note offset
002f4e c01c                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel3_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002f4f 91a0 2817                 	lds r26, noise_note //load the current note index
002f51 c019                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process:
002f52 9220 2922                 	sts noise_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002f54 9220 2923                 	sts noise_total_pitch_offset+1, zero
002f56 9220 2929                 	sts noise_total_hi_pitch_offset, zero
002f58 91a0 2921                 	lds r26, noise_arpeggio_macro_mode
002f5a 30a1                      	cpi r26, 0x01 //absolute mode
002f5b f010                      	brlo sound_driver_instrument_routine_channel3_arpeggio_process_absolute
002f5c f031                      	breq sound_driver_instrument_routine_channel3_arpeggio_process_fixed
002f5d c007                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_absolute:
002f5e 91a0 2817                 	lds r26, noise_note //load the current note index
002f60 0fab                      	add r26, r27 //offset the note with the arpeggio data
002f61 70af                      	andi r26, 0x0F //keep only bits 0-3 in case there was overflow
002f62 c008                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_fixed:
002f63 2fab                      	mov r26, r27 //move the arpeggio data into r26
002f64 c006                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_relative:
002f65 91a0 2817                 	lds r26, noise_note //load the current note index
002f67 0fab                      	add r26, r27 //offset the note with the arpeggio data
002f68 70af                      	andi r26, 0x0F //keep only bits 0-3 in case there was overflow
002f69 93a0 2817                 	sts noise_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_load:
002f6b 93a0 2818                 	sts noise_adjusted_note, r26
002f6d c000                      	rjmp sound_driver_instrument_routine_channel3_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch:
002f6e 91e0 2924                 	lds ZL, noise_pitch_macro
002f70 91f0 2925                 	lds ZH, noise_pitch_macro+1
002f72 9630                      	adiw Z, 0
002f73 f409                      	brne sound_driver_instrument_routine_channel3_pitch_continue
002f74 c023                      	rjmp sound_driver_instrument_routine_channel3_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel3_pitch_continue:
002f75 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002f76 1fff                      	rol ZH
002f77 91a0 2926                 	lds r26, noise_pitch_macro_offset
002f79 0fea                      	add ZL, r26
002f7a 1df2                      	adc ZH, zero
                                 
002f7b 91b0 2928                 	lds r27, noise_pitch_macro_release
002f7d 17ba                      	cp r27, r26
002f7e f429                      	brne sound_driver_instrument_routine_channel3_pitch_increment //if the current offset is not equal to the release index, increment the offset
002f7f 91a0 2927                 	lds r26, noise_pitch_macro_loop
002f81 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002f82 f010                      	brlo sound_driver_instrument_routine_channel3_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002f83 c003                      	rjmp sound_driver_instrument_routine_channel3_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_pitch_increment:
002f84 95a3                      	inc r26 //increment the macro offset
002f85 93a0 2926                 	sts noise_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_pitch_read:
002f87 91b4                      	lpm r27, Z //load pitch data into r27
002f88 38b0                      	cpi r27, 0x80 //check for macro end flag
002f89 f479                      	brne sound_driver_instrument_routine_channel3_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag_check_release:
002f8a 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002f8b 93a0 2926                 	sts noise_pitch_macro_offset, r26
002f8d 91b0 2928                 	lds r27, noise_pitch_macro_release
002f8f 3fbf                      	cpi r27, 0xFF
002f90 f439                      	brne sound_driver_instrument_routine_channel3_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag_check_loop:
002f91 91b0 2927                 	lds r27, noise_pitch_macro_loop //load the loop index
002f93 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002f94 f019                      	breq sound_driver_instrument_routine_channel3_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002f95 93b0 2926                 	sts noise_pitch_macro_offset, r27 //store the loop index into the offset
002f97 cfd6                      	rjmp sound_driver_instrument_routine_channel3_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch_default:
002f98 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel3_pitch_calculate:
                                 sound_driver_instrument_routine_channel3_pitch_calculate_offset:
002f99 91a0 2922                 	lds r26, noise_total_pitch_offset
002f9b 0fba                      	add r27, r26
002f9c 93b0 2922                 	sts noise_total_pitch_offset, r27
002f9e 91a0 2818                 	lds r26, noise_adjusted_note
002fa0 1bab                      	sub r26, r27
                                 	
002fa1 91b0 2937                 	lds r27, noise_fx_1xx_total
002fa3 0fab                      	add r26, r27
002fa4 91b0 2939                 	lds r27, noise_fx_2xx_total
002fa6 1bab                      	sub r26, r27
002fa7 91b0 293d                 	lds r27, noise_fx_4xy_offset
002fa9 1bab                      	sub r26, r27
002faa 91b0 2945                 	lds r27, noise_fx_Pxx_total
002fac 1bab                      	sub r26, r27
                                 
002fad 70af                      	andi r26, 0x0F
                                 
002fae e4e2                      	ldi ZL, LOW(noise_period_table << 1) //load in note table
002faf e0f1                      	ldi ZH, HIGH(noise_period_table << 1)
002fb0 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002fb1 0fea                      	add ZL, r26 //add offset
002fb2 1df2                      	adc ZH, zero
002fb3 91a5                      	lpm r26, Z+ //load bytes
002fb4 91b4                      	lpm r27, Z
002fb5 93a0 0abc                 	sts TCB3_CCMPL, r26 //load the LOW bits for timer
002fb7 93b0 0abd                 	sts TCB3_CCMPH, r27 //load the HIGH bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel3_hi_pitch:
002fb9 91e0 292a                 	lds ZL, noise_hi_pitch_macro
002fbb 91f0 292b                 	lds ZH, noise_hi_pitch_macro+1
002fbd 9630                      	adiw Z, 0
002fbe f409                      	brne sound_driver_instrument_routine_channel3_hi_pitch_continue
002fbf c03c                      	rjmp sound_driver_instrument_routine_channel3_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel3_hi_pitch_continue:
002fc0 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002fc1 1fff                      	rol ZH
002fc2 91a0 292c                 	lds r26, noise_hi_pitch_macro_offset
002fc4 0fea                      	add ZL, r26
002fc5 1df2                      	adc ZH, zero
                                 
002fc6 91b0 292e                 	lds r27, noise_hi_pitch_macro_release
002fc8 17ba                      	cp r27, r26
002fc9 f429                      	brne sound_driver_instrument_routine_channel3_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002fca 91a0 292d                 	lds r26, noise_hi_pitch_macro_loop
002fcc 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002fcd f010                      	brlo sound_driver_instrument_routine_channel3_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002fce c003                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_increment:
002fcf 95a3                      	inc r26 //increment the macro offset
002fd0 93a0 292c                 	sts noise_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_hi_pitch_read:
002fd2 91b4                      	lpm r27, Z //load hi pitch data into r27
002fd3 38b0                      	cpi r27, 0x80 //check for macro end flag
002fd4 f489                      	brne sound_driver_instrument_routine_channel3_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag_check_release:
002fd5 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002fd6 93a0 292c                 	sts noise_hi_pitch_macro_offset, r26
002fd8 91b0 292e                 	lds r27, noise_hi_pitch_macro_release
002fda 3fbf                      	cpi r27, 0xFF
002fdb f439                      	brne sound_driver_instrument_routine_channel3_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag_check_loop:
002fdc 91b0 292d                 	lds r27, noise_hi_pitch_macro_loop //load the loop index
002fde 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002fdf f019                      	breq sound_driver_instrument_routine_channel3_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002fe0 93b0 292c                 	sts noise_hi_pitch_macro_offset, r27 //store the loop index into the offset
002fe2 cfd6                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_default:
002fe3 91b0 2929                 	lds r27, noise_total_hi_pitch_offset
002fe5 c005                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate:
002fe6 91a0 2929                 	lds r26, noise_total_hi_pitch_offset //load the total hi pitch offset to change
002fe8 0fba                      	add r27, r26
002fe9 93b0 2929                 	sts noise_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate_multiply:
002feb 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002fec 937f                      	push r23
002fed 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002fee eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002fef 0367                      	mulsu r22, r23
002ff0 917f                      	pop r23
002ff1 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate_offset:
002ff2 91a0 0abc                 	lds r26, TCB3_CCMPL //load the low bits for timer
002ff4 91b0 0abd                 	lds r27, TCB3_CCMPH //load the high bits for timer
002ff6 0da0                      	add r26, r0 //offset the timer values
002ff7 1db1                      	adc r27, r1
002ff8 93a0 0abc                 	sts TCB3_CCMPL, r26 //store the new low bits for timer
002ffa 93b0 0abd                 	sts TCB3_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty:
002ffc 91e0 292f                 	lds ZL, noise_duty_macro
002ffe 91f0 2930                 	lds ZH, noise_duty_macro+1
003000 9630                      	adiw Z, 0
003001 f169                      	breq sound_driver_channel3_fx_routines //if no duty macro is in use, go to the next routine
003002 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
003003 1fff                      	rol ZH
003004 91a0 2931                 	lds r26, noise_duty_macro_offset
003006 0fea                      	add ZL, r26
003007 1df2                      	adc ZH, zero
                                 
003008 91b0 2933                 	lds r27, noise_duty_macro_release
00300a 17ba                      	cp r27, r26
00300b f429                      	brne sound_driver_instrument_routine_channel3_duty_increment //if the current offset is not equal to the release index, increment the offset
00300c 91a0 2932                 	lds r26, noise_duty_macro_loop
00300e 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00300f f010                      	brlo sound_driver_instrument_routine_channel3_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
003010 c01e                      	rjmp sound_driver_channel3_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel3_duty_increment:
003011 95a3                      	inc r26 //increment the macro offset
003012 93a0 2931                 	sts noise_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_duty_read:
003014 91b4                      	lpm r27, Z //load pitch data into r27
003015 3fbf                      	cpi r27, 0xFF //check for macro end flag
003016 f471                      	brne sound_driver_instrument_routine_channel3_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag_check_release:
003017 50a1                      	subi r26, 1 //keep the macro offset at the end flag
003018 93a0 2931                 	sts noise_duty_macro_offset, r26
00301a 91b0 2933                 	lds r27, noise_duty_macro_release
00301c 3fbf                      	cpi r27, 0xFF
00301d f489                      	brne sound_driver_channel3_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag_check_loop:
00301e 91b0 2932                 	lds r27, noise_duty_macro_loop //load the loop index
003020 3fbf                      	cpi r27, 0xFF //check if there is a loop index
003021 f069                      	breq sound_driver_channel3_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
003022 93b0 2931                 	sts noise_duty_macro_offset, r27 //store the loop index into the offset
003024 cfd7                      	rjmp sound_driver_instrument_routine_channel3_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty_load:
003025 95b6                      	lsr r27
003026 95b7                      	ror r27 //move mode bit to bit 7
003027 91c0 2814                 	lds r28, noise_period
003029 77cf                      	andi r28, 0b01111111
00302a 2bcb                      	or r28, r27 //store the new noise mode
00302b 93c0 2814                 	sts noise_period, r28
                                 
00302d 776f                      	andi noise_sequence_HIGH, 0b01111111
00302e 2b6b                      	or noise_sequence_HIGH, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_routines:
                                 sound_driver_channel3_fx_1xx_routine:
00302f 91e0 2936                 	lds ZL, noise_fx_1xx
003031 30e0                      	cpi ZL, 0
003032 f029                      	breq sound_driver_channel3_fx_2xx_routine
                                 
003033 91a0 2937                 	lds r26, noise_fx_1xx_total //load the rate to change the pitch by
003035 0fae                      	add r26, ZL //increase the total offset by the rate
003036 93a0 2937                 	sts noise_fx_1xx_total, r26
                                 
                                 
                                 
                                 sound_driver_channel3_fx_2xx_routine:
003038 91e0 2938                 	lds ZL, noise_fx_2xx
00303a 30e0                      	cpi ZL, 0
00303b f029                      	breq sound_driver_channel3_fx_3xx_routine
                                 
00303c 91a0 2939                 	lds r26, noise_fx_2xx_total //load the rate to change the pitch by
00303e 0fae                      	add r26, ZL //increase the total offset by the rate
00303f 93a0 2939                 	sts noise_fx_2xx_total, r26
                                 
                                 
                                 
                                 sound_driver_channel3_fx_3xx_routine:
                                 
                                 
                                 
                                 sound_driver_channel3_fx_4xy_routine:
003041 91a0 293a                 	lds r26, noise_fx_4xy_speed
003043 15a2                      	cp r26, zero
003044 f409                      	brne sound_driver_channel3_fx_4xy_routine_continue
003045 c033                      	rjmp sound_driver_channel3_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel3_fx_4xy_routine_continue:
003046 91b0 293b                 	lds r27, noise_fx_4xy_depth
003048 91c0 293c                 	lds r28, noise_fx_4xy_phase
00304a 0fca                      	add r28, r26 //increase the phase by the speed
00304b 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
00304c f008                      	brlo sound_driver_channel3_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
00304d e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase:
00304e 93c0 293c                 	sts noise_fx_4xy_phase, r28 //store the new phase
003050 31c0                      	cpi r28, 16
003051 f028                      	brlo sound_driver_channel3_fx_4xy_routine_phase_0
003052 32c0                      	cpi r28, 32
003053 f028                      	brlo sound_driver_channel3_fx_4xy_routine_phase_1
003054 33c0                      	cpi r28, 48
003055 f030                      	brlo sound_driver_channel3_fx_4xy_routine_phase_2
003056 c007                      	rjmp sound_driver_channel3_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_0:
003057 70cf                      	andi r28, 0x0F //mask for values 0-15
003058 c014                      	rjmp sound_driver_channel3_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_1:
003059 6fc0                      	ori r28, 0xF0
00305a 95c0                      	com r28 //invert values 0-15
00305b c011                      	rjmp sound_driver_channel3_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_2:
00305c 70cf                      	andi r28, 0x0F //mask for values 0-15
00305d c003                      	rjmp sound_driver_channel3_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_3:
00305e 6fc0                      	ori r28, 0xF0
00305f 95c0                      	com r28 //invert values 0-15
003060 c000                      	rjmp sound_driver_channel3_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel3_fx_4xy_routine_load_add:
003061 95b2                      	swap r27 //multiply depth by 16
003062 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
003063 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
003064 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
003065 0fec                      	add ZL, r28 //offset the table by the depth+phase
003066 1df2                      	adc ZH, zero
003067 91c4                      	lpm r28, Z //load the tremelo value into r28
003068 95c2                      	swap r28
003069 70cf                      	andi r28, 0x0F
                                 
00306a 93c0 293d                 	sts noise_fx_4xy_offset, r28
00306c c00c                      	rjmp sound_driver_channel3_fx_7xy_routine
                                 
                                 sound_driver_channel3_fx_4xy_routine_load_subtract:
00306d 95b2                      	swap r27 //multiply depth by 16
00306e 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
00306f e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
003070 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
003071 0fec                      	add ZL, r28 //offset the table by the depth+phase
003072 1df2                      	adc ZH, zero
003073 91c4                      	lpm r28, Z //load the vibrato value into r28
003074 95c2                      	swap r28
003075 70cf                      	andi r28, 0x0F
                                 
003076 95c1                      	neg r28
003077 93c0 293d                 	sts noise_fx_4xy_offset, r28
                                 
                                 
                                 
                                 sound_driver_channel3_fx_7xy_routine:
003079 91a0 293e                 	lds r26, noise_fx_7xy_speed
00307b 15a2                      	cp r26, zero
00307c f0e9                      	breq sound_driver_channel3_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
00307d 91b0 293f                 	lds r27, noise_fx_7xy_depth
00307f 91c0 2940                 	lds r28, noise_fx_7xy_phase
003081 0fca                      	add r28, r26 //increase the phase by the speed
003082 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
003083 f008                      	brlo sound_driver_channel3_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
003084 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel3_fx_7xy_routine_phase:
003085 93c0 2940                 	sts noise_fx_7xy_phase, r28 //store the new phase
003087 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
003088 ffc4                      	sbrs r28, 4
003089 c001                      	rjmp sound_driver_channel3_fx_7xy_routine_phase_0
00308a c002                      	rjmp sound_driver_channel3_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel3_fx_7xy_routine_phase_0:
00308b 70cf                      	andi r28, 0x0F //mask for values 0-15
00308c c003                      	rjmp sound_driver_channel3_fx_7xy_routine_load
                                 
                                 sound_driver_channel3_fx_7xy_routine_phase_1:
00308d 6fc0                      	ori r28, 0xF0
00308e 95c0                      	com r28 //invert values 0-15
00308f c000                      	rjmp sound_driver_channel3_fx_7xy_routine_load
                                 
                                 sound_driver_channel3_fx_7xy_routine_load:
003090 95b2                      	swap r27 //multiply depth by 16
003091 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
003092 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
003093 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
003094 0fec                      	add ZL, r28 //offset the table by the depth+phase
003095 1df2                      	adc ZH, zero
003096 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
003097 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
003098 93c0 2941                 	sts noise_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Axy_routine:
00309a 91b0 2942                 	lds r27, noise_fx_Axy
00309c 15b2                      	cp r27, zero
00309d f0e9                      	breq sound_driver_channel3_fx_Qxy_routine //0 means that the effect is not in use
                                 	
00309e 91a0 2815                 	lds r26, noise_fractional_volume //load fractional volume representation of the channel
0030a0 91c0 2813                 	lds r28, noise_param //load the integer volume representation of the channel
0030a2 2fda                      	mov r29, r26 //copy fractional volume into r29
0030a3 2fec                      	mov r30, r28 //copy the noise_param into r30
0030a4 95e2                      	swap r30
0030a5 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
0030a6 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
0030a7 17ed                      	cp r30, r29 //compare the fractional and integer volumes
0030a8 f009                      	breq sound_driver_channel3_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel3_fx_Axy_routine_reload:
0030a9 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate:
0030aa fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
0030ab c004                      	rjmp sound_driver_channel3_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_addition:
0030ac 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0030ad f428                      	brcc sound_driver_channel3_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0030ae efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
0030af c003                      	rjmp sound_driver_channel3_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_subtraction:
0030b0 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0030b1 f008                      	brcs sound_driver_channel3_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0030b2 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_store:
0030b3 93a0 2815                 	sts noise_fractional_volume, r26 //store the new fractional volume
0030b5 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
0030b6 95a2                      	swap r26
0030b7 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
0030b8 2bca                      	or r28, r26 //store the new volume back into noise_param
0030b9 93c0 2813                 	sts noise_param, r28
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Qxy_routine:
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Rxy_routine:
                                 
                                 
                                 
                                 sound_driver_exit:
0030bb 91ff                      	pop r31
0030bc 91ef                      	pop r30
0030bd 91df                      	pop r29
0030be 91cf                      	pop r28
0030bf 940c 1613                 	jmp sequence_1_3 + 3 //+3 is to skip the stack instructions since we already pushed them
                                 
                                 
                                 
                                 //TABLES
0030c1 7f05
0030c2 010a
0030c3 0214
0030c4 0328
0030c5 0450
0030c6 051e
0030c7 0607
0030c8 070d
0030c9 0806
0030ca 090c
0030cb 0a18
0030cc 0b30
0030cd 0c60
0030ce 0d24
0030cf 0e08
0030d0 0f10                      length: .db $05, $7F, $0A, $01, $14, $02, $28, $03, $50, $04, $1E, $05, $07, $06, $0D, $07, $06, $08, $0C, $09, $18, $0A, $30, $0B, $60, $0C, $24, $0D, $08, $0E, $10, $0F
                                 
                                 //pulse sequences: 12.5%, 25%, 50%, 75%
0030d1 0301
0030d2 fc0f                      sequences: .db 0b00000001, 0b00000011, 0b00001111, 0b11111100
                                 
                                 //list of famitracker fx: http://famitracker.com/wiki/index.php?title=Effect_list
                                 channel0_fx:
0030d3 187d
0030d4 1882
0030d5 189e
0030d6 18ba
0030d7 18dd                      	.dw sound_driver_channel0_fx_0xy, sound_driver_channel0_fx_1xx, sound_driver_channel0_fx_2xx, sound_driver_channel0_fx_3xx, sound_driver_channel0_fx_4xy
0030d8 18e8
0030d9 18f5
0030da 18f8
0030db 18fb
0030dc 18fe                      	.dw sound_driver_channel0_fx_7xy, sound_driver_channel0_fx_Axy, sound_driver_channel0_fx_Bxx, sound_driver_channel0_fx_Cxx, sound_driver_channel0_fx_Dxx
0030dd 1901
0030de 1909
0030df 190c
0030e0 1919
0030e1 191a                      	.dw sound_driver_channel0_fx_Exx, sound_driver_channel0_fx_Fxx, sound_driver_channel0_fx_Gxx, sound_driver_channel0_fx_Hxy, sound_driver_channel0_fx_Ixy
0030e2 191b
0030e3 191c
0030e4 191d
0030e5 1935
0030e6 1977                      	.dw sound_driver_channel0_fx_Hxx, sound_driver_channel0_fx_Ixx, sound_driver_channel0_fx_Pxx, sound_driver_channel0_fx_Qxy, sound_driver_channel0_fx_Rxy
0030e7 19b8
0030e8 19c5
0030e9 19d9
0030ea 19da
0030eb 19db                      	.dw sound_driver_channel0_fx_Sxx, sound_driver_channel0_fx_Vxx, sound_driver_channel0_fx_Wxx, sound_driver_channel0_fx_Xxx, sound_driver_channel0_fx_Yxx
0030ec 19dc                      	.dw sound_driver_channel0_fx_Zxx
                                 
                                 channel1_fx:
0030ed 1b7a
0030ee 1b7f
0030ef 1b9b
0030f0 1bb7
0030f1 1bda                      	.dw sound_driver_channel1_fx_0xy, sound_driver_channel1_fx_1xx, sound_driver_channel1_fx_2xx, sound_driver_channel1_fx_3xx, sound_driver_channel1_fx_4xy
0030f2 1be5
0030f3 1bf2
0030f4 1bf5
0030f5 1bf8
0030f6 1bfb                      	.dw sound_driver_channel1_fx_7xy, sound_driver_channel1_fx_Axy, sound_driver_channel1_fx_Bxx, sound_driver_channel1_fx_Cxx, sound_driver_channel1_fx_Dxx
0030f7 1bfe
0030f8 1c06
0030f9 1c09
0030fa 1c16
0030fb 1c17                      	.dw sound_driver_channel1_fx_Exx, sound_driver_channel1_fx_Fxx, sound_driver_channel1_fx_Gxx, sound_driver_channel1_fx_Hxy, sound_driver_channel1_fx_Ixy
0030fc 1c18
0030fd 1c19
0030fe 1c1a
0030ff 1c32
003100 1c74                      	.dw sound_driver_channel1_fx_Hxx, sound_driver_channel1_fx_Ixx, sound_driver_channel1_fx_Pxx, sound_driver_channel1_fx_Qxy, sound_driver_channel1_fx_Rxy
003101 1cb5
003102 1cc2
003103 1cd6
003104 1cd7
003105 1cd8                      	.dw sound_driver_channel1_fx_Sxx, sound_driver_channel1_fx_Vxx, sound_driver_channel1_fx_Wxx, sound_driver_channel1_fx_Xxx, sound_driver_channel1_fx_Yxx
003106 1cd9                      	.dw sound_driver_channel1_fx_Zxx
                                 
                                 channel2_fx:
003107 1e6a
003108 1e6f
003109 1e8b
00310a 1ea7
00310b 1eca                      	.dw sound_driver_channel2_fx_0xy, sound_driver_channel2_fx_1xx, sound_driver_channel2_fx_2xx, sound_driver_channel2_fx_3xx, sound_driver_channel2_fx_4xy
00310c 1ed5
00310d 1ed6
00310e 1ed7
00310f 1eda
003110 1edd                      	.dw sound_driver_channel2_fx_7xy, sound_driver_channel2_fx_Axy, sound_driver_channel2_fx_Bxx, sound_driver_channel2_fx_Cxx, sound_driver_channel2_fx_Dxx
003111 1ee0
003112 1eed
003113 1ef0
003114 1efd
003115 1efe                      	.dw sound_driver_channel2_fx_Exx, sound_driver_channel2_fx_Fxx, sound_driver_channel2_fx_Gxx, sound_driver_channel2_fx_Hxy, sound_driver_channel2_fx_Ixy
003116 1eff
003117 1f00
003118 1f01
003119 1f19
00311a 1f5b                      	.dw sound_driver_channel2_fx_Hxx, sound_driver_channel2_fx_Ixx, sound_driver_channel2_fx_Pxx, sound_driver_channel2_fx_Qxy, sound_driver_channel2_fx_Rxy
00311b 1f9c
00311c 1fa9
00311d 1faa
00311e 1fab
00311f 1fac                      	.dw sound_driver_channel2_fx_Sxx, sound_driver_channel2_fx_Vxx, sound_driver_channel2_fx_Wxx, sound_driver_channel2_fx_Xxx, sound_driver_channel2_fx_Yxx
003120 1fad                      	.dw sound_driver_channel2_fx_Zxx
                                 
                                 channel3_fx:
003121 2142
003122 2147
003123 2150
003124 2159
003125 215a                      	.dw sound_driver_channel3_fx_0xy, sound_driver_channel3_fx_1xx, sound_driver_channel3_fx_2xx, sound_driver_channel3_fx_3xx, sound_driver_channel3_fx_4xy
003126 2167
003127 2174
003128 2177
003129 217a
00312a 217d                      	.dw sound_driver_channel3_fx_7xy, sound_driver_channel3_fx_Axy, sound_driver_channel3_fx_Bxx, sound_driver_channel3_fx_Cxx, sound_driver_channel3_fx_Dxx
00312b 2180
00312c 2187
00312d 218a
00312e 2197
00312f 2198                      	.dw sound_driver_channel3_fx_Exx, sound_driver_channel3_fx_Fxx, sound_driver_channel3_fx_Gxx, sound_driver_channel3_fx_Hxy, sound_driver_channel3_fx_Ixy
003130 2199
003131 219a
003132 219b
003133 219e
003134 219f                      	.dw sound_driver_channel3_fx_Hxx, sound_driver_channel3_fx_Ixx, sound_driver_channel3_fx_Pxx, sound_driver_channel3_fx_Qxy, sound_driver_channel3_fx_Rxy
003135 21a0
003136 21ad
003137 21b8
003138 21b9
003139 21ba                      	.dw sound_driver_channel3_fx_Sxx, sound_driver_channel3_fx_Vxx, sound_driver_channel3_fx_Wxx, sound_driver_channel3_fx_Xxx, sound_driver_channel3_fx_Yxx
00313a 21bb                      	.dw sound_driver_channel3_fx_Zxx
                                 
                                 channel4_fx:
00313b 2314
00313c 2315
00313d 2316
00313e 2317
00313f 2318                      	.dw sound_driver_channel4_fx_0xy, sound_driver_channel4_fx_1xx, sound_driver_channel4_fx_2xx, sound_driver_channel4_fx_3xx, sound_driver_channel4_fx_4xy
003140 2319
003141 231a
003142 231b
003143 231e
003144 2321                      	.dw sound_driver_channel4_fx_7xy, sound_driver_channel4_fx_Axy, sound_driver_channel4_fx_Bxx, sound_driver_channel4_fx_Cxx, sound_driver_channel4_fx_Dxx
003145 2324
003146 2325
003147 2328
003148 2335
003149 2336                      	.dw sound_driver_channel4_fx_Exx, sound_driver_channel4_fx_Fxx, sound_driver_channel4_fx_Gxx, sound_driver_channel4_fx_Hxy, sound_driver_channel4_fx_Ixy
00314a 2337
00314b 2338
00314c 2339
00314d 233a
00314e 233b                      	.dw sound_driver_channel4_fx_Hxx, sound_driver_channel4_fx_Ixx, sound_driver_channel4_fx_Pxx, sound_driver_channel4_fx_Qxy, sound_driver_channel4_fx_Rxy
00314f 233c
003150 2349
003151 234a
003152 234b
003153 234c                      	.dw sound_driver_channel4_fx_Sxx, sound_driver_channel4_fx_Vxx, sound_driver_channel4_fx_Wxx, sound_driver_channel4_fx_Xxx, sound_driver_channel4_fx_Yxx
003154 234d                      	.dw sound_driver_channel4_fx_Zxx
                                 
                                 //famitracker volumes table: http://famitracker.com/wiki/index.php?title=Volume
                                 volumes:
003155 0000
003156 0000
003157 0000
003158 0000
003159 0000
00315a 0000
00315b 0000
00315c 0000                      	.db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
00315d 0100
00315e 0101
00315f 0101
003160 0101
003161 0101
003162 0101
003163 0101
003164 0101                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
003165 0100
003166 0101
003167 0101
003168 0101
003169 0101
00316a 0101
00316b 0101
00316c 0201                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02
00316d 0100
00316e 0101
00316f 0101
003170 0101
003171 0101
003172 0202
003173 0202
003174 0302                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03
003175 0100
003176 0101
003177 0101
003178 0101
003179 0202
00317a 0202
00317b 0303
00317c 0403                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04
00317d 0100
00317e 0101
00317f 0101
003180 0202
003181 0302
003182 0303
003183 0404
003184 0504                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05
003185 0100
003186 0101
003187 0201
003188 0202
003189 0303
00318a 0404
00318b 0504
00318c 0605                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x06
00318d 0100
00318e 0101
00318f 0201
003190 0302
003191 0403
003192 0504
003193 0605
003194 0706                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07
003195 0100
003196 0101
003197 0202
003198 0303
003199 0404
00319a 0505
00319b 0606
00319c 0807                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07, 0x08
00319d 0100
00319e 0101
00319f 0302
0031a0 0403
0031a1 0504
0031a2 0606
0031a3 0707
0031a4 0908                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09
0031a5 0100
0031a6 0201
0031a7 0302
0031a8 0404
0031a9 0605
0031aa 0706
0031ab 0808
0031ac 0a09                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A
0031ad 0100
0031ae 0201
0031af 0302
0031b0 0504
0031b1 0605
0031b2 0807
0031b3 0908
0031b4 0b0a                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B
0031b5 0100
0031b6 0201
0031b7 0403
0031b8 0504
0031b9 0706
0031ba 0808
0031bb 0a09
0031bc 0c0b                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B, 0x0C
0031bd 0100
0031be 0201
0031bf 0403
0031c0 0605
0031c1 0706
0031c2 0908
0031c3 0b0a
0031c4 0d0c                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D
0031c5 0100
0031c6 0201
0031c7 0403
0031c8 0605
0031c9 0807
0031ca 0a09
0031cb 0c0b
0031cc 0e0d                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E
0031cd 0100
0031ce 0302
0031cf 0504
0031d0 0706
0031d1 0908
0031d2 0b0a
0031d3 0d0c


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega4809" register use summary:
x  :   0 y  :   0 z  : 253 r0 : 148 r1 : 160 r2 : 681 r3 :  18 r4 :   4 
r5 :   0 r6 :   0 r7 :   6 r8 :   4 r9 :   9 r10:   6 r11:   4 r12:   9 
r13:   1 r14:   1 r15:   2 r16:   7 r17:   6 r18:   7 r19:   6 r20:   4 
r21:   9 r22: 138 r23: 127 r24:   3 r25:  24 r26:1001 r27:1219 r28: 656 
r29: 350 r30: 341 r31: 325 
Registers used: 31 out of 35 (88.6%)

"ATmega4809" instruction use summary:
.lds  :   0 .sts  :   0 adc   : 132 add   : 183 adiw  : 100 and   :   2 
andi  :  99 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   6 brcs  :  13 break :   0 breq  : 173 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  76 brlt  :   0 brmi  :   0 
brne  : 133 brpl  :   0 brsh  :  37 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   5 cbi   :   0 cbr   :   5 
clc   :   0 clh   :   0 cli   :   6 cln   :   0 clr   :   5 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :  16 cp    : 125 cpc   :  15 
cpi   : 175 cpse  :  26 dec   :  25 des   :   0 eor   :   2 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   5 in    :   5 inc   :  46 
jmp   :   8 ld    :   0 ldd   :   0 ldi   : 305 lds   : 690 lpm   : 277 
lsl   :  82 lsr   : 135 mov   : 135 movw  :   0 mul   :  21 muls  :   0 
mulsu :  10 neg   :   1 nop   :   0 or    :  24 ori   :  12 out   :   9 
pop   :  97 push  :  89 rcall :  56 ret   :  44 reti  :   7 rjmp  : 570 
rol   :  59 ror   : 156 sbc   :  30 sbci  :   0 sbi   :   0 sbic  :   0 
sbis  :   0 sbiw  :   0 sbr   :  12 sbrc  :  25 sbrs  :  18 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   :1384 sub   :  53 subi  :  38 swap  :  47 tst   :   0 wdr   :   0 

Instructions used: 55 out of 114 (48.2%)

"ATmega4809" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x0063aa  15594   9796  25390   49152  51.7%
[.dseg] 0x002800 0x002956      0    342    342    6144   5.6%
[.eseg] 0x000000 0x000000      0      0      0     256   0.0%

Assembly complete, 0 errors, 50 warnings
