
AVRASM ver. 2.2.8  C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm Fri Dec 11 21:21:31 2020

C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
                                 
                                 
                                 ; NES_APU_2a03.asm
                                 ;
                                 ; Created: 11/29/2020 1:44:10 AM
                                 ; Author : Tennyson Cheng
                                 ;
                                 
                                 .list
                                 
                                 .dseg
002800                           pulse1_param: .byte 1 //$4000 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002801                           pulse1_sweep_param: .byte 1 //$4001 EPPP.NSSS = Enable, Period, Negate, Shift
                                 //NOTE: In order to account for multiplier, we use 16 instead of 11 bits for the timer
002802                           pulse1_timerL: .byte 1 //$4002 LLLL.LLLL = Low 8 bits for timer
002803                           pulse1_timerH: .byte 1 //$4002 HHHH.HHHH = High 8 bits for timer
002804                           pulse1_length: .byte 1 //$4002 000l.llll = Length counter load
                                 
                                 .cseg
                                 //NOTE: r30 and r31 are reserved for conversion routines, since lpm can only be used with the Z register
                                 //r28 and r29 are reserved for non-interrupt routines
                                 //r26 and r27 are reserved for interrupt routines, but interrupt routines may use r28 and r29
                                 //If an interrupt uses r28 and r29, then they must be pushed and popped (this should be limited as much as possible)
                                 //This was done in order to save clock cycles due to constantly pushing/popping registers
                                 //NOTE: zero is defined in order to use the cp instruction without the need to load 0x00 into a register beforehand
                                 .def zero = r0
                                 .def sample_delayL = r1
                                 .def sample_delayH = r2
                                 .def frame_counter_clock = r3
                                 .def channel_flags = r25 //[pulse1.pulse2] RSlc.0000 = Reload, Start, Length halt/Loop, Constant volume
                                 .def pulse1_sequence = r13
                                 .def pulse1_length_counter = r14
                                 .def pulse1_sweep = r15 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse1_volume_divider = r16 //0000.PPPP = Period divider
                                 .def pulse1_volume_decay = r17 //0000.dddd = Decay (This is the output volume of the channel)
                                 
                                 reset:
000000 940c 001a                 	jmp init
                                 
                                 .org TCA0_OVF_vect
00000e 940c 00b4                 	jmp sequence_1_3
                                 
                                 .org TCA0_CMP0_vect
000012 940c 009a                 	jmp sequence_0_2
                                 
                                 .org TCA0_CMP1_vect
000014 940c 00b4                 	jmp sequence_1_3
                                 
                                 .org TCA0_CMP2_vect
000016 940c 009a                 	jmp sequence_0_2
                                 
                                 .org TCB0_INT_vect
000018 940c 00d5                 	jmp pulse1_sequence_routine
                                 
                                 init:
                                 	//MAIN CLOCK
00001a edb8                      	ldi r27, CPU_CCP_IOREG_gc //protected write
00001b 93b0 0034                 	sts CPU_CCP, r27
00001d e0b0                      	ldi r27, 0 << CLKCTRL_PEN_bp //disable prescaler for 20 MHz on main clock
00001e 93b0 0061                 	sts CLKCTRL_MCLKCTRLB, r27
                                 
                                 	//TEST FOR C4, 1 SECOND, 50% DD
000020 e9a7                      	ldi r26, 0x97
000021 e1b2                      	ldi r27, 0x12
                                 /*	ldi r26, 0x15
                                 	ldi r27, 0x09*/
000022 93a0 2802                 	sts pulse1_timerL, r26
000024 93b0 2803                 	sts pulse1_timerH, r27
000026 ebbf                      	ldi r27, 0b10111111
000027 93b0 2800                 	sts pulse1_param, r27
000029 e0b1                      	ldi r27, 0x01
00002a 93b0 2804                 	sts pulse1_length, r27
                                 	//TEST FOR SWEEP UP
00002c efbf                      	ldi r27, 0b11111111
00002d 93b0 2801                 	sts pulse1_sweep_param, r27
                                 	
                                 	//ZERO
00002f 2400                      	clr zero
                                 
                                 	//PINS
000030 efbf                      	ldi r27, 0xFF //set all pins in VPORTD to output
000031 b9bc                      	out VPORTD_DIR, r27
                                 
                                 	//ENVELOPE
000032 e00f                      	ldi pulse1_volume_divider, 0x0F
000033 9110 2800                 	lds pulse1_volume_decay, pulse1_param
000035 701f                      	andi pulse1_volume_decay, 0x0F //mask for VVVV bits
000036 9190 2800                 	lds channel_flags, pulse1_param
000038 7390                      	andi channel_flags, 0b00110000
000039 6490                      	sbr channel_flags, 0b01000000 //set start flag
                                 	
                                 	//LENGTH
00003a 91d0 2804                 	lds r29, pulse1_length
00003c d0f2                      	rcall length_converter
00003d 2eed                      	mov pulse1_length_counter, r29
                                 
                                 	//SEQUENCE
00003e 91d0 2800                 	lds r29, pulse1_param //load param for sequence table
000040 0fdd                      	lsl r29 //shift duty cycle bits to LSB
000041 1fdd                      	rol r29
000042 1fdd                      	rol r29
000043 70d3                      	andi r29, 0b00000011 //mask duty cycle bits
000044 d100                      	rcall duty_cycle_sequences
000045 2edd                      	mov pulse1_sequence, r29
                                 
                                 	//SWEEP
000046 90f0 2801                 	lds pulse1_sweep, pulse1_sweep_param
000048 94f2                      	swap pulse1_sweep //swap data from high byte and low byte
000049 6890                      	sbr channel_flags, 0b10000000 //set reload flag
                                 
                                 	//TIMERS
                                 	//Frame Counter/Audio Sampler (.vgm)
                                 	//NOTE:The frame counter will be defaulted to NTSC mode (60 Hz, 120 Hz, 240 Hz)
                                 	//For our implementation, the sampling for .vgm samples and frame counter will be shared on TCA0
                                 	//Each interrupt will be setup to interrupt every 44100 Hz clock
                                 	//CMP0 = sequence 0, CMP1 = sequence 1, CMP2 = sequence 2, OVF = sequence 4
                                 	//During each interrupt, a clock cycle counter for the audio sampler (44100 Hz) will be decremented
                                 	//When the clock cycle counter for the audio sampler is 0, then a new audio sample will be read
                                 	//During each interrupt, another clock cycle counter for the frame counter (240 Hz) will be decremented
                                 	//When the clock cycle counter for the frame counter is 0,
                                 	//then the sequence routine, corresponding to the interrupt called, will be executed
                                 	//The clock cycle counter for the frame counter will also be reset to 184 clocks (0xE6)
                                 	//This corresponds to how many 21500 Hz clocks pass, for a single 240 Hz clock: (44100/240 = 183.75) + 1 offset = 184 = 0xB8
                                 	//Timer period Calculation: (0.00002267573 * 20000000/64)-1 = 6.086165625 = 0x06
                                 	//The ATmega4809 is cofigured to run at 20000000 Hz
                                 	//0.00002267573 seconds is the period for 44100 Hz
                                 	//The /16 comes from the prescaler divider used
00004a e0b0                      	ldi r27, 0x00
00004b 2e1b                      	mov sample_delayL, r27
00004c 2e2b                      	mov sample_delayH, r27
00004d ebb8                      	ldi r27, 0xB8
00004e 2e3b                      	mov frame_counter_clock, r27
                                 
00004f e7b0                      	ldi r27, TCA_SINGLE_CMP0EN_bm | TCA_SINGLE_CMP1EN_bm | TCA_SINGLE_CMP2EN_bm | TCA_SINGLE_WGMODE_NORMAL_gc //interrupt mode
000050 93b0 0a01                 	sts TCA0_SINGLE_CTRLB, r27
000052 e7b1                      	ldi r27, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP1_bm | TCA_SINGLE_CMP2_bm | TCA_SINGLE_OVF_bm //enable overflow and compare interrupts
000053 93b0 0a0a                 	sts TCA0_SINGLE_INTCTRL, r27
000055 e0b6                      	ldi r27, 0x06 //set the period for CMP0
000056 93b0 0a28                 	sts TCA0_SINGLE_CMP0, r27
000058 e0b0                      	ldi r27, 0x00
000059 93b0 0a29                 	sts TCA0_SINGLE_CMP0 + 1, r27
00005b e0bd                      	ldi r27, 0x0D //set the period for CMP1
00005c 93b0 0a2a                 	sts TCA0_SINGLE_CMP1, r27
00005e e0b0                      	ldi r27, 0x00
00005f 93b0 0a2b                 	sts TCA0_SINGLE_CMP1 + 1, r27
000061 e1b4                      	ldi r27, 0x14 //set the period for CMP2
000062 93b0 0a2c                 	sts TCA0_SINGLE_CMP2, r27
000064 e0b0                      	ldi r27, 0x00
000065 93b0 0a2d                 	sts TCA0_SINGLE_CMP2 + 1, r27
000067 e1bb                      	ldi r27, 0x1B //set the period for OVF
000068 93b0 0a26                 	sts TCA0_SINGLE_PER, r27
00006a e0b0                      	ldi r27, 0x00
00006b 93b0 0a27                 	sts TCA0_SINGLE_PER + 1, r27
00006d e0bb                      	ldi r27, TCA_SINGLE_CLKSEL_DIV64_gc | TCA_SINGLE_ENABLE_bm //use prescale divider of 64 and enable timer
00006e 93b0 0a00                 	sts TCA0_SINGLE_CTRLA, r27
                                 
                                 	//NOTE: Channel Timers are clocked (20/2)/(0.8948865) = 11.1746014718 times faster than the NES APU
                                 	//Because of this, we multiply all the NES timer values by 11.1746014718 beforehand 
                                 	//Since we rotate the sequence when the timer goes from t-(t-1) to 0, instead of 0 to t like the NES, we add 1 to the NES timers before multiplying
                                 	//The ATmega4809 is configured to run at 20 MHz
                                 	//The /2 comes from the prescaler divider used
                                 	//0.8948865 MHz is the speed of the NTSC NES APU
                                 	//Pulse 1
000070 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
000071 93b0 0a81                 	sts TCB0_CTRLB, r27
000073 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
000074 93b0 0a85                 	sts TCB0_INTCTRL, r27
000076 91b0 2802                 	lds r27, pulse1_timerL //load the LOW bits for timer
000078 93b0 0a8c                 	sts TCB0_CCMPL, r27
00007a 91b0 2803                 	lds r27, pulse1_timerH //load the HIGH bits for timer
00007c 93b0 0a8d                 	sts TCB0_CCMPH, r27
00007e e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
00007f 93b0 0a80                 	sts TCB0_CTRLA, r27
000081 9478                      	sei //global interrupt enable
                                 
                                 pulse1:
000082 fed0                      	sbrs pulse1_sequence, 0 //if the sequence output is zero, return
000083 c012                      	rjmp pulse1_off
                                 
000084 14e0                      	cp pulse1_length_counter, zero //if length is zero, return
000085 f081                      	breq pulse1_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
000086 91c0 0a8c                 	lds r28, TCB0_CCMPL
000088 91d0 0a8d                 	lds r29, TCB0_CCMPH
00008a 30d1                      	cpi r29, 0x01 //check timer HIGH period
00008b f008                      	brlo PC+2 //if the timer HIGH period is $00, check the LOW period
00008c c002                      	rjmp PC+3 //if the timer HIGH period is > $01, check > $07FF condition
00008d 35c9                      	cpi r28, 0x59 //check timer LOW period
00008e f038                      	brlo pulse1_off //if the HIGH period == $00 && LOW period <= $59, pulse off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $5965
00008f 35d9                      	cpi r29, 0x59 //check timer HIGH period
000090 f038                      	brlo pulse1_on //if the HIGH period is < $59, then all conditions have passed and pulse is not muted
000091 f009                      	breq PC+2 //if the HIGH period is == $59, we go check if the LOW period is < $65
000092 c003                      	rjmp pulse1_off //pulse off if HIGH period is > $59
000093 36c5                      	cpi r28, 0x65 //check timer LOW period
000094 f408                      	brsh pulse1_off //if the HIGH period == $59 && LOW period >= $65, pulse off
000095 c002                      	rjmp pulse1_on //if the HIGH period == $59 && LOW period < $65, pulse on
                                 
                                 
                                 pulse1_off:
000096 9868                      	cbi VPORTD_OUT, 0
000097 cfea                      	rjmp pulse1
                                 
                                 pulse1_on:
000098 9a68                      	sbi VPORTD_OUT, 0
000099 cfe8                      	rjmp pulse1
                                 
                                 //FRAME COUNTER/AUDIO SAMPLE ISR
                                 sequence_0_2:
00009a b7bf                      	in r27, CPU_SREG
00009b 93bf                      	push r27
00009c 94f8                      	cli
                                 
                                 	//SAMPLE
00009d 1410                      	cp sample_delayL, zero //check if LOW bits of sample delay == 0
00009e f011                      	breq PC+3 //if LOW bits of sample delay == 0, go check if HIGH bits of sample delay == 0
00009f 941a                      	dec sample_delayL
0000a0 c006                      	rjmp PC+7 //if LOW bits of sample delay != 0, go check frame counter clock
                                 
0000a1 1420                      	cp sample_delayH, zero //check if HIGH bits of sample delay == 0
0000a2 f019                      	breq PC+4 //if LOW and HIGH bits of sample delay == 0, then go sample new audio
0000a3 942a                      	dec sample_delayH //if LOW bits of sample delay == 0 and HIGH bits of sample delay != 0, decrement HIGH bits and LOW bits
0000a4 941a                      	dec sample_delayL
0000a5 c001                      	rjmp PC+2
                                 
0000a6 d02d                      	rcall sample_audio
                                 
                                 	//FRAME COUNTER CLOCK
0000a7 1430                      	cp frame_counter_clock, zero //check if frame counter clock == 0
0000a8 f011                      	breq PC+3 //if frame counter clock == 0, go execute the frame routine
0000a9 943a                      	dec frame_counter_clock //if frame counter clock != 0, decrement and exit the interrupt
0000aa c003                      	rjmp PC+4
                                 
                                 	//FRAME ROUTINE
0000ab ebba                      	ldi r27, 0xBA
0000ac 2e3b                      	mov frame_counter_clock, r27
                                 
                                 	//ENVELOPE
0000ad d03b                      	rcall pulse1_envelope_routine
                                 
0000ae e5b0                      	ldi r27, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP2_bm //clear OVF flag
0000af 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
0000b1 91bf                      	pop r27
0000b2 bfbf                      	out CPU_SREG, r27
0000b3 9518                      	reti
                                 
                                 sequence_1_3:
0000b4 b7bf                      	in r27, CPU_SREG
0000b5 93bf                      	push r27
0000b6 94f8                      	cli
                                 
                                 	//SAMPLE
0000b7 1410                      	cp sample_delayL, zero //check if LOW bits of sample delay == 0
0000b8 f011                      	breq PC+3 //if LOW bits of sample delay == 0, go check if HIGH bits of sample delay == 0
0000b9 941a                      	dec sample_delayL
0000ba c006                      	rjmp PC+7 //if LOW bits of sample delay != 0, go check frame counter clock
                                 
0000bb 1420                      	cp sample_delayH, zero //check if HIGH bits of sample delay == 0
0000bc f019                      	breq PC+4 //if LOW and HIGH bits of sample delay == 0, then go sample new audio
0000bd 942a                      	dec sample_delayH //if LOW bits of sample delay == 0 and HIGH bits of sample delay != 0, decrement HIGH bits and LOW bits
0000be 941a                      	dec sample_delayL
0000bf c001                      	rjmp PC+2
                                 
0000c0 d013                      	rcall sample_audio
                                 
                                 	//FRAME COUNTER CLOCK
0000c1 1430                      	cp frame_counter_clock, zero //check if frame counter clock == 0
0000c2 f011                      	breq PC+3 //if frame counter clock == 0, go execute the frame routine
0000c3 943a                      	dec frame_counter_clock //if frame counter clock != 0, decrement and exit the interrupt
0000c4 c009                      	rjmp PC+10
                                 
                                 	//FRAME ROUTINE
0000c5 ebba                      	ldi r27, 0xBA
0000c6 2e3b                      	mov frame_counter_clock, r27
                                 
                                 	//ENVELOPE
0000c7 d021                      	rcall pulse1_envelope_routine
                                 
                                 	//SWEEP
0000c8 fcf3                      	sbrc pulse1_sweep, 3 //check if the sweep enable bit is cleared
0000c9 d016                      	rcall pulse1_sweep_routine
                                 
                                 	//LENGTH
                                 	//NOTE: The length routine is relatively simple, so we will not be using clocks to rjmp and ret to a seperate lable
0000ca fd95                      	sbrc channel_flags, 5 //check if the length counter halt bit is cleared
0000cb c002                      	rjmp PC+3
0000cc 10e0                      	cpse pulse1_length_counter, zero //if length counter is already 0, don't decrement
0000cd 94ea                      	dec pulse1_length_counter
                                 
0000ce e2b1                      	ldi r27, TCA_SINGLE_CMP1_bm | TCA_SINGLE_OVF_bm //clear OVF flag
0000cf 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
0000d1 91bf                      	pop r27
0000d2 bfbf                      	out CPU_SREG, r27
0000d3 9518                      	reti
                                 
                                 //AUDIO SAMPLE ROUTINE
                                 sample_audio:
0000d4 9508                      	ret
                                 
                                 //PULSE 1 ISR
                                 pulse1_sequence_routine:
0000d5 b7bf                      	in r27, CPU_SREG
0000d6 93bf                      	push r27
0000d7 94f8                      	cli
                                 
0000d8 0cdd                      	lsl pulse1_sequence //shifts sequence to the left
0000d9 1cd0                      	adc pulse1_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
0000da e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
0000db 93b0 0a86                 	sts TCB0_INTFLAGS, r27
0000dd 91bf                      	pop r27
0000de bfbf                      	out CPU_SREG, r27
0000df 9518                      	reti
                                 
                                 pulse1_sweep_routine:
0000e0 2dbf                      	mov r27, pulse1_sweep
0000e1 70b7                      	andi r27, 0x07 //mask for period divider bits
0000e2 f411                      	brne PC+3 //check if divider == 0
                                 
0000e3 d01d                      	rcall pulse1_sweep_action //if the divider is == 0, update the pulse timer period
0000e4 c001                      	rjmp PC+2
                                 
0000e5 94fa                      	dec pulse1_sweep //if the divider != 0, decrement the divider
                                 
0000e6 fd97                      	sbrc channel_flags, 7 //if the reload flag is set, reload the sweep divider
0000e7 d042                      	rcall pulse1_sweep_reload
0000e8 9508                      	ret
                                 
                                 pulse1_envelope_routine:
0000e9 fd96                      	sbrc channel_flags, 6 //check if start flag is cleared
0000ea c010                      	rjmp PC+17
                                 
0000eb 3000                      	cpi pulse1_volume_divider, 0x00 //check if the divider is 0
0000ec f011                      	breq PC+3 //if the divider == 0, check loop flag
0000ed 950a                      	dec pulse1_volume_divider //if the divider != 0, decrement and return
0000ee 9508                      	ret
                                 
0000ef 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the divider == 0, reset the divider period
0000f1 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
0000f2 ff95                      	sbrs channel_flags, 5 //check if the loop flag is set
0000f3 c002                      	rjmp PC+3 //if the loop flag is not set, check the decay
0000f4 e01f                      	ldi pulse1_volume_decay, 0x0F //if the loop flag is set, reset decay and return
0000f5 9508                      	ret
                                 
0000f6 3010                      	cpi pulse1_volume_decay, 0x00 //check if the decay is 0
0000f7 f409                      	brne PC+2 //if decay != 0, go decrement
0000f8 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
0000f9 951a                      	dec pulse1_volume_decay
0000fa 9508                      	ret
                                 
0000fb 7b9f                      	cbr channel_flags, 0b01000000 //if the start flag is set, clear it
0000fc 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the start flag is set, reset the divider period
0000fe 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
0000ff e01f                      	ldi pulse1_volume_decay, 0x0F //if the start flag is set, reset decay
000100 9508                      	ret
                                 	
                                 //PULSE 1 HELPER METHODS
                                 pulse1_sweep_action:
000101 93df                      	push r29
000102 2ddf                      	mov r29, pulse1_sweep
000103 95d2                      	swap r29
000104 70d7                      	andi r29, 0x07 //mask for shift bits
000105 f409                      	brne PC+2 //check of shift == 0
                                 	//rjmp PC+23 //if the shift == 0, do nothing and return
000106 c021                      	rjmp PC+34
                                 
000107 91a0 0a8c                 	lds r26, TCB0_CCMPL
000109 91b0 0a8d                 	lds r27, TCB0_CCMPH
00010b 95b6                      	lsr r27
00010c 95a7                      	ror r26
00010d 95da                      	dec r29
00010e f7e1                      	brne PC-3 //keep looping/shifting until shift count is 0
                                 
00010f fef7                      	sbrs pulse1_sweep, 7 //check the negate flag
000110 c002                      	rjmp PC+3 //if negate flag was clear, go straight to addition
                                 
000111 95a0                      	com r26 //pulse1 uses one's complement if the negate flag is set
000112 95b0                      	com r27
                                 
000113 91d0 0a8c                 	lds r29, TCB0_CCMPL //perform addition to get new timer period
000115 0fad                      	add r26, r29
000116 91d0 0a8d                 	lds r29, TCB0_CCMPH
000118 1fbd                      	adc r27, r29
                                 
000119 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new LOW bits for timer
00011b 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new HIGH bits for timer
                                 
                                 	//sts pulse1_timerL, r26
                                 	//sts pulse1_timerH, r27
                                 
                                 	//Sweep Test
00011d 2ddf                      	mov r29, pulse1_sweep //invert the negate bit
00011e e8b0                      	ldi r27, 0b10000000
00011f 27db                      	eor r29, r27
000120 67df                      	ori r29, 0b01111111
                                 
000121 91b0 2801                 	lds r27, pulse1_sweep_param //reload the pulse sweep divider params
000123 95b2                      	swap r27
000124 68b0                      	ori r27, 0b10000000
000125 23bd                      	and r27, r29
000126 2efb                      	mov pulse1_sweep, r27
000127 6890                      	sbr channel_flags, 0b10000000
                                 	
000128 91df                      	pop r29
000129 9508                      	ret
                                 	
                                 pulse1_sweep_reload:
00012a 90f0 2801                 	lds pulse1_sweep, pulse1_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
00012c 94f2                      	swap pulse1_sweep //bring data from high byte to low byte
00012d 779f                      	cbr channel_flags, 0b10000000 //clear ready flag
00012e 9508                      	ret
                                 
                                 //CONVERTERS
                                 //converts and loads 5 bit length to corresponding 8 bit length value into r29
                                 length_converter:
00012f e0f2                      	ldi ZH, HIGH(length << 1)
000130 e6ea                      	ldi ZL, LOW(length << 1)
000131 0fed                      	add ZL, r29
000132 1df0                      	adc ZH, zero
000133 91d4                      	lpm r29, Z
000134 9508                      	ret
                                 
000135 7f05
000136 010a
000137 0214
000138 0328
000139 0450
00013a 051e
00013b 0607
00013c 070d
00013d 0806
00013e 090c
00013f 0a18
000140 0b30
000141 0c60
000142 0d24
000143 0e08
000144 0f10                      length: .db $05, $7F, $0A, $01, $14, $02, $28, $03, $50, $04, $1E, $05, $07, $06, $0D, $07, $06, $08, $0C, $09, $18, $0A, $30, $0B, $60, $0C, $24, $0D, $08, $0E, $10, $0F
                                 
                                 //loads pulse sequence into r29
                                 duty_cycle_sequences:
000145 e0f2                      	ldi ZH, HIGH(sequences << 1)
000146 e9e6                      	ldi ZL, LOW(sequences << 1)
000147 0fed                      	add ZL, r29
000148 1df0                      	adc ZH, zero
000149 91d4                      	lpm r29, Z
00014a 9508                      	ret
                                 
                                 //pulse sequences: 12.5%, 25%, 50%, 75%
00014b 0301


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega4809" register use summary:
x  :   0 y  :   0 z  :   2 r0 :  12 r1 :   7 r2 :   5 r3 :   7 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 
r13:   4 r14:   4 r15:  11 r16:   7 r17:   6 r18:   0 r19:   0 r20:   0 
r21:   0 r22:   0 r23:   0 r24:   0 r25:  11 r26:   7 r27:  87 r28:   3 
r29:  29 r30:   4 r31:   4 
Registers used: 17 out of 35 (48.6%)

"ATmega4809" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   4 add   :   3 adiw  :   0 and   :   1 
andi  :   7 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   0 brcs  :   0 break :   0 breq  :   9 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   3 brlt  :   0 brmi  :   0 
brne  :   4 brpl  :   0 brsh  :   1 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :   1 cbr   :   2 
clc   :   0 clh   :   0 cli   :   3 cln   :   0 clr   :   1 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :   2 cp    :   7 cpc   :   0 
cpi   :   6 cpse  :   1 dec   :  13 des   :   0 eor   :   1 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   0 in    :   3 inc   :   0 
jmp   :   6 ld    :   0 ldd   :   0 ldi   :  37 lds   :  17 lpm   :   4 
lsl   :   2 lsr   :   1 mov   :  11 movw  :   0 mul   :   0 muls  :   0 
mulsu :   0 neg   :   0 nop   :   0 or    :   0 ori   :   2 out   :   4 
pop   :   4 push  :   4 rcall :   9 ret   :  11 reti  :   3 rjmp  :  18 
rol   :   2 ror   :   1 sbc   :   0 sbci  :   0 sbi   :   1 sbic  :   0 
sbis  :   0 sbiw  :   0 sbr   :   3 sbrc  :   4 sbrs  :   3 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   :  28 sub   :   0 subi  :   0 swap  :   4 tst   :   0 wdr   :   0 

Instructions used: 43 out of 114 (37.7%)

"ATmega4809" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x00029a    602     36    638   49152   1.3%
[.dseg] 0x002800 0x002805      0      5      5    6144   0.1%
[.eseg] 0x000000 0x000000      0      0      0     256   0.0%

Assembly complete, 0 errors, 0 warnings
