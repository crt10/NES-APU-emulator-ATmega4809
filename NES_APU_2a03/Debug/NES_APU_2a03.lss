
AVRASM ver. 2.2.8  C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm Wed May 19 18:31:23 2021

C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
                                 
                                 
                                 ; NES_APU_2a03.asm
                                 ;
                                 ; Created: 11/29/2020 1:44:10 AM
                                 ; Author : Tennyson Cheng
                                 ;
                                 
                                 .list
                                 
                                 .dseg
002800                           pulse1_param: .byte 1 //$4000 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002801                           pulse1_sweep_param: .byte 1 //$4001 EPPP.NSSS = Enable, Period, Negate, Shift
                                 //NOTE: In order to account for multiplier, we use 16 instead of 11 bits for the timer
002802                           pulse1_timerL: .byte 1 //$4002 LLLL.LLLL = Low 8 bits for timer
002803                           pulse1_timerH: .byte 1 //$4002 HHHH.HHHH = High 8 bits for timer
002804                           pulse1_length: .byte 1 //$4003 000l.llll = Length counter load
002805                           pulse1_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002806                           pulse1_output_volume: .byte 1 //this is the final output volume of pulse 1
002807                           pulse1_note: .byte 1 //the current note index in the note table
                                 
002808                           pulse2_param: .byte 1 //$4004 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002809                           pulse2_sweep_param: .byte 1 //$4005 EPPP.NSSS = Enable, Period, Negate, Shift
00280a                           pulse2_timerL: .byte 1 //$4006 LLLL.LLLL = Low 8 bits for timer
00280b                           pulse2_timerH: .byte 1 //$4006 HHHH.HHHH = High 8 bits for timer
00280c                           pulse2_length: .byte 1 //$4007 000l.llll = Length counter load
00280d                           pulse2_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
00280e                           pulse2_output_volume: .byte 1 //this is the final output volume of pulse 2
00280f                           pulse2_note: .byte 1 //the current note index in the note table
                                 
002810                           triangle_timerL: .byte 1 //$400A LLLL.LLLL = Low 8 bits for timer
002811                           triangle_timerH: .byte 1 //$400A HHHH.HHHH = High 8 bits for time
002812                           triangle_note: .byte 1 //the current note index in the note table
                                 
002813                           noise_param: .byte 1 //$400C 00lc.vvvv = Length counter halt/Loop flag, Constant volume flag, Volume
002814                           noise_period: .byte 1 //$400E M000.PPPP = Mode, Period
002815                           noise_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002816                           noise_output_volume: .byte 1 //this is the final output volume of pulse 2
002817                           noise_note: .byte 1 //the current note index in the period table
002818                           noise_adjusted_note: .byte 1 //the resultant note index after the arpeggio macro
                                 
002819                           song_frames: .byte 2
00281b                           song_frame_offset: .byte 2
00281d                           song_size: .byte 2
00281f                           song_speed: .byte 1
                                 //song_channel_delay_reload: .byte 1 //bit 0-4 represents channels 0-4. a set bit means that there is a delay that needs to be calculated for that channel.
002820                           song_fx_Bxx: .byte 1
002821                           song_fx_Cxx: .byte 1
002822                           song_fx_Dxx: .byte 1
                                 
                                 //PULSE 1
002823                           pulse1_pattern: .byte 2
002825                           pulse1_pattern_delay_rows: .byte 1
002826                           pulse1_pattern_delay_frames: .byte 1
002827                           pulse1_pattern_offset: .byte 2
                                 
002829                           pulse1_volume_macro: .byte 2
00282b                           pulse1_volume_macro_offset: .byte 1
00282c                           pulse1_volume_macro_loop: .byte 1
00282d                           pulse1_volume_macro_release: .byte 1
                                 
00282e                           pulse1_arpeggio_macro: .byte 2
002830                           pulse1_arpeggio_macro_offset: .byte 1
002831                           pulse1_arpeggio_macro_loop: .byte 1
002832                           pulse1_arpeggio_macro_release: .byte 1
002833                           pulse1_arpeggio_macro_mode: .byte 1
                                 
002834                           pulse1_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002836                           pulse1_pitch_macro: .byte 2
002838                           pulse1_pitch_macro_offset: .byte 1
002839                           pulse1_pitch_macro_loop: .byte 1
00283a                           pulse1_pitch_macro_release: .byte 1
                                 
00283b                           pulse1_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00283c                           pulse1_hi_pitch_macro: .byte 2
00283e                           pulse1_hi_pitch_macro_offset: .byte 1
00283f                           pulse1_hi_pitch_macro_loop: .byte 1
002840                           pulse1_hi_pitch_macro_release: .byte 1
                                 
002841                           pulse1_duty_macro: .byte 2
002843                           pulse1_duty_macro_offset: .byte 1
002844                           pulse1_duty_macro_loop: .byte 1
002845                           pulse1_duty_macro_release: .byte 1
                                 
002846                           pulse1_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002848                           pulse1_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
00284a                           pulse1_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00284c                           pulse1_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
00284e                           pulse1_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
002850                           pulse1_fx_3xx_start: .byte 2 //the starting note period
002852                           pulse1_fx_3xx_target: .byte 2 //target note period
002854                           pulse1_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
002856                           pulse1_fx_3xx_total_offset: .byte 2
002858                           pulse1_fx_4xy_speed: .byte 1
002859                           pulse1_fx_4xy_depth: .byte 1
00285a                           pulse1_fx_4xy_phase: .byte 1
00285b                           pulse1_fx_7xy_speed: .byte 1
00285c                           pulse1_fx_7xy_depth: .byte 1
00285d                           pulse1_fx_7xy_phase: .byte 1
00285e                           pulse1_fx_7xy_value: .byte 1 //value to offset the volume
00285f                           pulse1_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
002860                           pulse1_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002861                           pulse1_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002862                           pulse1_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
002864                           pulse1_fx_Qxy_target_note: .byte 1 //target note index
002865                           pulse1_fx_Qxy_target: .byte 2 //target note period
002867                           pulse1_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002869                           pulse1_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
00286b                           pulse1_fx_Rxy_target_note: .byte 1 //target note index
00286c                           pulse1_fx_Rxy_target: .byte 2 //target note period
00286e                           pulse1_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
002870                           pulse1_fx_Rxy_total_offset: .byte 2
002872                           pulse1_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002873                           pulse1_fx_Sxx_post: .byte 1
                                 
                                 //PULSE 2
002874                           pulse2_pattern: .byte 2
002876                           pulse2_pattern_delay_rows: .byte 1
002877                           pulse2_pattern_delay_frames: .byte 1
002878                           pulse2_pattern_offset: .byte 2
                                 
00287a                           pulse2_volume_macro: .byte 2
00287c                           pulse2_volume_macro_offset: .byte 1
00287d                           pulse2_volume_macro_loop: .byte 1
00287e                           pulse2_volume_macro_release: .byte 1
                                 
00287f                           pulse2_arpeggio_macro: .byte 2
002881                           pulse2_arpeggio_macro_offset: .byte 1
002882                           pulse2_arpeggio_macro_loop: .byte 1
002883                           pulse2_arpeggio_macro_release: .byte 1
002884                           pulse2_arpeggio_macro_mode: .byte 1
                                 
002885                           pulse2_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002887                           pulse2_pitch_macro: .byte 2
002889                           pulse2_pitch_macro_offset: .byte 1
00288a                           pulse2_pitch_macro_loop: .byte 1
00288b                           pulse2_pitch_macro_release: .byte 1
                                 
00288c                           pulse2_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00288d                           pulse2_hi_pitch_macro: .byte 2
00288f                           pulse2_hi_pitch_macro_offset: .byte 1
002890                           pulse2_hi_pitch_macro_loop: .byte 1
002891                           pulse2_hi_pitch_macro_release: .byte 1
                                 
002892                           pulse2_duty_macro: .byte 2
002894                           pulse2_duty_macro_offset: .byte 1
002895                           pulse2_duty_macro_loop: .byte 1
002896                           pulse2_duty_macro_release: .byte 1
                                 
002897                           pulse2_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002899                           pulse2_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
00289b                           pulse2_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00289d                           pulse2_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
00289f                           pulse2_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
0028a1                           pulse2_fx_3xx_start: .byte 2 //the starting note period
0028a3                           pulse2_fx_3xx_target: .byte 2 //target note period
0028a5                           pulse2_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028a7                           pulse2_fx_3xx_total_offset: .byte 2
0028a9                           pulse2_fx_4xy_speed: .byte 1
0028aa                           pulse2_fx_4xy_depth: .byte 1
0028ab                           pulse2_fx_4xy_phase: .byte 1
0028ac                           pulse2_fx_7xy_speed: .byte 1
0028ad                           pulse2_fx_7xy_depth: .byte 1
0028ae                           pulse2_fx_7xy_phase: .byte 1
0028af                           pulse2_fx_7xy_value: .byte 1 //value to offset the volume
0028b0                           pulse2_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
0028b1                           pulse2_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028b2                           pulse2_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028b3                           pulse2_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
0028b5                           pulse2_fx_Qxy_target_note: .byte 1 //target note index
0028b6                           pulse2_fx_Qxy_target: .byte 2 //target note period
0028b8                           pulse2_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
0028ba                           pulse2_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
0028bc                           pulse2_fx_Rxy_target_note: .byte 1 //target note index
0028bd                           pulse2_fx_Rxy_target: .byte 2 //target note period
0028bf                           pulse2_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
0028c1                           pulse2_fx_Rxy_total_offset: .byte 2
0028c3                           pulse2_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
0028c4                           pulse2_fx_Sxx_post: .byte 1
                                 
                                 //TRIANGLE
0028c5                           triangle_pattern: .byte 2
0028c7                           triangle_pattern_delay_rows: .byte 1
0028c8                           triangle_pattern_delay_frames: .byte 1
0028c9                           triangle_pattern_offset: .byte 2
                                 
0028cb                           triangle_volume_macro: .byte 2
0028cd                           triangle_volume_macro_offset: .byte 1
0028ce                           triangle_volume_macro_loop: .byte 1
0028cf                           triangle_volume_macro_release: .byte 1
                                 
0028d0                           triangle_arpeggio_macro: .byte 2
0028d2                           triangle_arpeggio_macro_offset: .byte 1
0028d3                           triangle_arpeggio_macro_loop: .byte 1
0028d4                           triangle_arpeggio_macro_release: .byte 1
0028d5                           triangle_arpeggio_macro_mode: .byte 1
                                 
0028d6                           triangle_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
0028d8                           triangle_pitch_macro: .byte 2
0028da                           triangle_pitch_macro_offset: .byte 1
0028db                           triangle_pitch_macro_loop: .byte 1
0028dc                           triangle_pitch_macro_release: .byte 1
                                 
0028dd                           triangle_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
0028de                           triangle_hi_pitch_macro: .byte 2
0028e0                           triangle_hi_pitch_macro_offset: .byte 1
0028e1                           triangle_hi_pitch_macro_loop: .byte 1
0028e2                           triangle_hi_pitch_macro_release: .byte 1
                                 
0028e3                           triangle_duty_macro: .byte 2
0028e5                           triangle_duty_macro_offset: .byte 1
0028e6                           triangle_duty_macro_loop: .byte 1
0028e7                           triangle_duty_macro_release: .byte 1
                                 
0028e8                           triangle_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
0028ea                           triangle_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
0028ec                           triangle_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
0028ee                           triangle_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
0028f0                           triangle_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
0028f2                           triangle_fx_3xx_start: .byte 2 //the starting note period
0028f4                           triangle_fx_3xx_target: .byte 2 //target note period
0028f6                           triangle_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028f8                           triangle_fx_3xx_total_offset: .byte 2
0028fa                           triangle_fx_4xy_speed: .byte 1
0028fb                           triangle_fx_4xy_depth: .byte 1
0028fc                           triangle_fx_4xy_phase: .byte 1
0028fd                           triangle_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028fe                           triangle_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028ff                           triangle_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
002901                           triangle_fx_Qxy_target_note: .byte 1 //target note index
002902                           triangle_fx_Qxy_target: .byte 2 //target note period
002904                           triangle_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002906                           triangle_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002908                           triangle_fx_Rxy_target_note: .byte 1 //target note index
002909                           triangle_fx_Rxy_target: .byte 2 //target note period
00290b                           triangle_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
00290d                           triangle_fx_Rxy_total_offset: .byte 2
00290f                           triangle_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002910                           triangle_fx_Sxx_post: .byte 1
                                 
                                 //NOISE
002911                           noise_pattern: .byte 2
002913                           noise_pattern_delay_rows: .byte 1
002914                           noise_pattern_delay_frames: .byte 1
002915                           noise_pattern_offset: .byte 2
                                 
002917                           noise_volume_macro: .byte 2
002919                           noise_volume_macro_offset: .byte 1
00291a                           noise_volume_macro_loop: .byte 1
00291b                           noise_volume_macro_release: .byte 1
                                 
00291c                           noise_arpeggio_macro: .byte 2
00291e                           noise_arpeggio_macro_offset: .byte 1
00291f                           noise_arpeggio_macro_loop: .byte 1
002920                           noise_arpeggio_macro_release: .byte 1
002921                           noise_arpeggio_macro_mode: .byte 1
                                 
002922                           noise_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002924                           noise_pitch_macro: .byte 2
002926                           noise_pitch_macro_offset: .byte 1
002927                           noise_pitch_macro_loop: .byte 1
002928                           noise_pitch_macro_release: .byte 1
                                 
002929                           noise_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00292a                           noise_hi_pitch_macro: .byte 2
00292c                           noise_hi_pitch_macro_offset: .byte 1
00292d                           noise_hi_pitch_macro_loop: .byte 1
00292e                           noise_hi_pitch_macro_release: .byte 1
                                 
00292f                           noise_duty_macro: .byte 2
002931                           noise_duty_macro_offset: .byte 1
002932                           noise_duty_macro_loop: .byte 1
002933                           noise_duty_macro_release: .byte 1
                                 
002934                           noise_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002936                           noise_fx_1xx: .byte 1 //refers to the rate in which to subtract the pitch from by the 1xx
002937                           noise_fx_1xx_total: .byte 1 //the total pitch offset for 1xx
002938                           noise_fx_2xx: .byte 1 //refers to the rate in which to add to the pitch by the 2xx
002939                           noise_fx_2xx_total: .byte 1 //the total pitch offset for 2xx
00293a                           noise_fx_4xy_speed: .byte 1
00293b                           noise_fx_4xy_depth: .byte 1
00293c                           noise_fx_4xy_phase: .byte 1
00293d                           noise_fx_4xy_offset: .byte 1
00293e                           noise_fx_7xy_speed: .byte 1
00293f                           noise_fx_7xy_depth: .byte 1
002940                           noise_fx_7xy_phase: .byte 1
002941                           noise_fx_7xy_value: .byte 1 //value to offset the volume
002942                           noise_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
002943                           noise_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002944                           noise_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002945                           noise_fx_Pxx_total: .byte 1 //refers to the fine pitch offset set by the Pxx effect
002946                           noise_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002947                           noise_fx_Sxx_post: .byte 1
                                 
                                 //DPCM
002948                           dpcm_pattern: .byte 2
00294a                           dpcm_pattern_delay_rows: .byte 1
00294b                           dpcm_pattern_delay_frames: .byte 1
00294c                           dpcm_pattern_offset: .byte 2
                                 
00294e                           dpcm_sample: .byte 2
002950                           dpcm_sample_offset: .byte 2
                                 
002952                           dpcm_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002953                           dpcm_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002954                           dpcm_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002955                           dpcm_fx_Sxx_post: .byte 1
                                 
                                 .cseg
                                 
                                 //NOTE: zero is defined in order to use the cp instruction without the need to load 0x00 into a register beforehand
                                 //NOTE: same idea with one
                                 .def zero = r2
                                 .def one = r3
                                 .def pulse_channel_flags = r25 //[pulse1.pulse2] RSlc.RSlc = Reload, Start, Length halt/Loop, Constant volume
                                 .def pulse1_sequence = r7
                                 .def pulse1_length_counter = r8
                                 .def pulse1_sweep = r9 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse1_volume_divider = r16 //0000.PPPP = Period divider
                                 .def pulse1_volume_decay = r17 //0000.dddd = Decay
                                 .def pulse2_sequence = r10
                                 .def pulse2_length_counter = r11
                                 .def pulse2_sweep = r12 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse2_volume_divider = r18 //0000.PPPP = Period divider
                                 .def pulse2_volume_decay = r19 //0000.dddd = Decay
                                 .def triangle_sequence = r20
                                 .def noise_sequence_LOW = r21
                                 .def noise_sequence_HIGH = r22
                                 .def dpcm_shift = r13
                                 .def dpcm_bit_counter = r14
                                 .def dpcm_period = r15
                                 .def dpcm_length_LOW = r23
                                 .def dpcm_length_HIGH = r24
                                 
                                 
                                 reset:
000000 940c 1258                 	jmp init
                                 
                                 .org TCA0_OVF_vect
00000e 940c 1706                 	jmp sound_driver
                                 
                                 .org TCA0_CMP0_vect
000012 940c 160d                 	jmp sequence_0_2
                                 
                                 .org TCA0_CMP1_vect
000014 940c 1618                 	jmp sequence_1_3
                                 
                                 .org TCA0_CMP2_vect
000016 940c 160d                 	jmp sequence_0_2
                                 
                                 .org TCB0_INT_vect
000018 940c 162f                 	jmp pulse1_sequence_routine
                                 
                                 .org TCB1_INT_vect
00001a 940c 167c                 	jmp pulse2_sequence_routine
                                 
                                 .org TCB2_INT_vect
000032 940c 16c9                 	jmp triangle_sequence_routine
                                 
                                 .org TCB3_INT_vect
000048 940c 16d4                 	jmp noise_sequence_routine
                                 
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(33): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(48): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(74): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(75): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(76): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(77): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(78): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(79): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(80): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(81): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(82): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(83): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(84): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(85): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(88): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(89): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(92): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(94): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(96): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(97): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(101): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(104): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(106): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(111): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(112): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(113): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(114): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(118): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(119): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(121): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(123): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(124): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(125): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(129): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(130): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(137): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(163): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(223): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(224): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(225): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(230): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(233): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(237): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(238): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(239): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(240): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(246): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(248): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(249): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(250): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(251): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(252): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(365): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
                                 .list
                                 
                                 init:
                                 	//MAIN CLOCK
001258 edc8                      	ldi r28, CPU_CCP_IOREG_gc //protected write
001259 93c0 0034                 	sts CPU_CCP, r28
00125b e0c0                      	ldi r28, 0 << CLKCTRL_PEN_bp //disable prescaler for 20 MHz on main clock
00125c 93c0 0061                 	sts CLKCTRL_MCLKCTRLB, r28
                                 
                                 	//ZERO
00125e 2422                      	clr zero
                                 	//ONE
00125f e0c1                      	ldi r28, 1
001260 2e3c                      	mov one, r28
                                 
                                 	//MEMORY
001261 e3c0                      	ldi r28, 0b00110000
001262 93c0 2800                 	sts pulse1_param, r28
001264 e8c0                      	ldi r28, 0b10000000
001265 93c0 2801                 	sts pulse1_sweep_param, r28
001267 efcf                      	ldi r28, 0xFF
001268 93c0 2802                 	sts pulse1_timerL, r28
00126a 93c0 2803                 	sts pulse1_timerH, r28
00126c 93c0 2804                 	sts pulse1_length, r28
                                 
00126e e3c0                      	ldi r28, 0b00110000
00126f 93c0 2808                 	sts pulse2_param, r28
001271 e8c0                      	ldi r28, 0b10000000
001272 93c0 2809                 	sts pulse2_sweep_param, r28
001274 efcf                      	ldi r28, 0xFF
001275 93c0 280a                 	sts pulse2_timerL, r28
001277 93c0 280b                 	sts pulse2_timerH, r28
001279 93c0 280c                 	sts pulse2_length, r28
                                 
00127b efcf                      	ldi r28, 0xFF
00127c 93c0 2810                 	sts triangle_timerL, r28
00127e 93c0 2811                 	sts triangle_timerH, r28
                                 
001280 e3c0                      	ldi r28, 0b00110000
001281 93c0 2813                 	sts noise_param, r28
001283 e0cf                      	ldi r28, 0b00001111
001284 93c0 2814                 	sts noise_period, r28
                                 
001286 e0c2                      	ldi r28, 0x02
001287 93c0 281b                 	sts song_frame_offset, r28
001289 9220 281c                 	sts song_frame_offset+1, zero
00128b efcf                      	ldi r28, 0xFF
00128c 93c0 2820                 	sts song_fx_Bxx, r28
00128e 9220 2821                 	sts song_fx_Cxx, zero
001290 9220 2822                 	sts song_fx_Dxx, zero
001292 e4ee                      	ldi ZL, LOW(song0_frames << 1)
001293 e0f3                      	ldi ZH, HIGH(song0_frames << 1)
001294 93e0 2819                 	sts song_frames, ZL
001296 93f0 281a                 	sts song_frames+1, ZH
001298 91c5                      	lpm r28, Z+ //load the song size
001299 91d5                      	lpm r29, Z+
00129a 93c0 281d                 	sts song_size, r28
00129c 93d0 281e                 	sts song_size+1, r29
00129e 9220 281f                 	sts song_speed, zero
                                 
                                 	//CHANNEL 0
0012a0 91c5                      	lpm r28, Z+
0012a1 91d5                      	lpm r29, Z+
0012a2 0fcc                      	lsl r28
0012a3 1fdd                      	rol r29
0012a4 93c0 2823                 	sts pulse1_pattern, r28
0012a6 93d0 2824                 	sts pulse1_pattern+1, r29
0012a8 9220 2825                 	sts pulse1_pattern_delay_rows, zero
0012aa 9220 2826                 	sts pulse1_pattern_delay_frames, zero
0012ac 9220 2827                 	sts pulse1_pattern_offset, zero
0012ae 9220 2828                 	sts pulse1_pattern_offset+1, zero
                                 
                                 	//CHANNEL 1
0012b0 91c5                      	lpm r28, Z+
0012b1 91d5                      	lpm r29, Z+
0012b2 0fcc                      	lsl r28
0012b3 1fdd                      	rol r29
0012b4 93c0 2874                 	sts pulse2_pattern, r28
0012b6 93d0 2875                 	sts pulse2_pattern+1, r29
0012b8 9220 2876                 	sts pulse2_pattern_delay_rows, zero
0012ba 9220 2877                 	sts pulse2_pattern_delay_frames, zero
0012bc 9220 2878                 	sts pulse2_pattern_offset, zero
0012be 9220 2879                 	sts pulse2_pattern_offset+1, zero
                                 
                                 	//CHANNEL 2
0012c0 91c5                      	lpm r28, Z+
0012c1 91d5                      	lpm r29, Z+
0012c2 0fcc                      	lsl r28
0012c3 1fdd                      	rol r29
0012c4 93c0 28c5                 	sts triangle_pattern, r28
0012c6 93d0 28c6                 	sts triangle_pattern+1, r29
0012c8 9220 28c7                 	sts triangle_pattern_delay_rows, zero
0012ca 9220 28c8                 	sts triangle_pattern_delay_frames, zero
0012cc 9220 28c9                 	sts triangle_pattern_offset, zero
0012ce 9220 28ca                 	sts triangle_pattern_offset+1, zero
                                 
                                 	//CHANNEL 3
0012d0 91c5                      	lpm r28, Z+
0012d1 91d5                      	lpm r29, Z+
0012d2 0fcc                      	lsl r28
0012d3 1fdd                      	rol r29
0012d4 93c0 2911                 	sts noise_pattern, r28
0012d6 93d0 2912                 	sts noise_pattern+1, r29
0012d8 9220 2913                 	sts noise_pattern_delay_rows, zero
0012da 9220 2914                 	sts noise_pattern_delay_frames, zero
0012dc 9220 2915                 	sts noise_pattern_offset, zero
0012de 9220 2916                 	sts noise_pattern_offset+1, zero
                                 
                                 	//CHANNEL 4
0012e0 91c5                      	lpm r28, Z+
0012e1 91d5                      	lpm r29, Z+
0012e2 0fcc                      	lsl r28
0012e3 1fdd                      	rol r29
0012e4 93c0 2948                 	sts dpcm_pattern, r28
0012e6 93d0 2949                 	sts dpcm_pattern+1, r29
0012e8 9220 294a                 	sts dpcm_pattern_delay_rows, zero
0012ea 9220 294b                 	sts dpcm_pattern_delay_frames, zero
0012ec 9220 294c                 	sts dpcm_pattern_offset, zero
0012ee 9220 294d                 	sts dpcm_pattern_offset+1, zero
                                 
                                 	//CHANNEL 0 instrument macros
0012f0 efcf                      	ldi r28, 0xFF
0012f1 9220 282b                 	sts pulse1_volume_macro_offset, zero
0012f3 93c0 282c                 	sts pulse1_volume_macro_loop, r28
0012f5 93c0 282d                 	sts pulse1_volume_macro_release, r28
0012f7 9220 2830                 	sts pulse1_arpeggio_macro_offset, zero
0012f9 93c0 2831                 	sts pulse1_arpeggio_macro_loop, r28
0012fb 93c0 2832                 	sts pulse1_arpeggio_macro_release, r28
0012fd 93c0 2833                 	sts pulse1_arpeggio_macro_mode, r28
0012ff 9220 2838                 	sts pulse1_pitch_macro_offset, zero
001301 93c0 2839                 	sts pulse1_pitch_macro_loop, r28
001303 93c0 283a                 	sts pulse1_pitch_macro_release, r28
001305 9220 283e                 	sts pulse1_hi_pitch_macro_offset, zero
001307 93c0 283f                 	sts pulse1_hi_pitch_macro_loop, r28
001309 93c0 2840                 	sts pulse1_hi_pitch_macro_release, r28
00130b 9220 2843                 	sts pulse1_duty_macro_offset, zero
00130d 93c0 2844                 	sts pulse1_duty_macro_loop, r28
00130f 93c0 2845                 	sts pulse1_duty_macro_release, r28
                                 
001311 9220 2829                 	sts pulse1_volume_macro, zero
001313 9220 282a                 	sts pulse1_volume_macro+1, zero
001315 9220 282e                 	sts pulse1_arpeggio_macro, zero
001317 9220 282f                 	sts pulse1_arpeggio_macro+1, zero
001319 9220 2834                 	sts pulse1_total_pitch_offset, zero
00131b 9220 2835                 	sts pulse1_total_pitch_offset+1, zero
00131d 9220 2836                 	sts pulse1_pitch_macro, zero
00131f 9220 2837                 	sts pulse1_pitch_macro+1, zero
001321 9220 283b                 	sts pulse1_total_hi_pitch_offset, zero
001323 9220 283c                 	sts pulse1_hi_pitch_macro, zero
001325 9220 283d                 	sts pulse1_hi_pitch_macro+1, zero
001327 9220 2841                 	sts pulse1_duty_macro, zero
001329 9220 2842                 	sts pulse1_duty_macro+1, zero
                                 
                                 	//CHANNEL 0 ENVELOPE
00132b e00f                      	ldi pulse1_volume_divider, 0x0F
00132c 9110 2800                 	lds pulse1_volume_decay, pulse1_param
00132e 701f                      	andi pulse1_volume_decay, 0x0F //mask for VVVV bits
00132f 9190 2800                 	lds pulse_channel_flags, pulse1_param
001331 7390                      	andi pulse_channel_flags, 0b00110000
001332 6490                      	sbr pulse_channel_flags, 0b01000000 //set start flag
001333 9220 2806                 	sts pulse1_output_volume, zero
001335 93c0 2805                 	sts pulse1_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 0 LENGTH
001337 2e8c                      	mov pulse1_length_counter, r28
                                 
                                 	//CHANNEL 0 SEQUENCE
001338 e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
001339 2e7c                      	mov pulse1_sequence, r28
                                 
                                 	//CHANNEL 0 SWEEP
00133a 9090 2801                 	lds pulse1_sweep, pulse1_sweep_param
00133c 9492                      	swap pulse1_sweep //swap data from high byte and low byte
00133d 6890                      	sbr pulse_channel_flags, 0b10000000 //set reload flag
                                 
                                 	//CHANNEL 0 FX
00133e efcf                      	ldi r28, 0xFF
00133f 9220 2846                 	sts pulse1_fx_0xy_sequence, zero
001341 9220 2847                 	sts pulse1_fx_0xy_sequence+1, zero
001343 9220 2848                 	sts pulse1_fx_1xx, zero
001345 9220 2849                 	sts pulse1_fx_1xx+1, zero
001347 9220 284a                 	sts pulse1_fx_1xx_total, zero
001349 9220 284b                 	sts pulse1_fx_1xx_total+1, zero
00134b 9220 284c                 	sts pulse1_fx_2xx, zero
00134d 9220 284d                 	sts pulse1_fx_2xx+1, zero
00134f 9220 284e                 	sts pulse1_fx_2xx_total, zero
001351 9220 284f                 	sts pulse1_fx_2xx_total+1, zero
001353 9220 2850                 	sts pulse1_fx_3xx_start, zero
001355 9220 2851                 	sts pulse1_fx_3xx_start+1, zero
001357 9220 2852                 	sts pulse1_fx_3xx_target, zero
001359 9220 2853                 	sts pulse1_fx_3xx_target+1, zero
00135b 9220 2854                 	sts pulse1_fx_3xx_speed, zero
00135d 9220 2855                 	sts pulse1_fx_3xx_speed+1, zero
00135f 9220 2856                 	sts pulse1_fx_3xx_total_offset, zero
001361 9220 2857                 	sts pulse1_fx_3xx_total_offset+1, zero
001363 9220 2858                 	sts pulse1_fx_4xy_speed, zero
001365 9220 2859                 	sts pulse1_fx_4xy_depth, zero
001367 9220 285a                 	sts pulse1_fx_4xy_phase, zero
001369 9220 285b                 	sts pulse1_fx_7xy_speed, zero
00136b 9220 285c                 	sts pulse1_fx_7xy_depth, zero
00136d 9220 285d                 	sts pulse1_fx_7xy_phase, zero
00136f 9220 285e                 	sts pulse1_fx_7xy_value, zero
001371 9220 285f                 	sts pulse1_fx_Axy, zero
001373 93c0 2860                 	sts pulse1_fx_Gxx_pre, r28
001375 93c0 2861                 	sts pulse1_fx_Gxx_post, r28
001377 9220 2862                 	sts pulse1_fx_Pxx_total, zero
001379 9220 2863                 	sts pulse1_fx_Pxx_total+1, zero
00137b 9220 2864                 	sts pulse1_fx_Qxy_target_note, zero
00137d 9220 2865                 	sts pulse1_fx_Qxy_target, zero
00137f 9220 2866                 	sts pulse1_fx_Qxy_target+1, zero
001381 9220 2867                 	sts pulse1_fx_Qxy_speed, zero
001383 9220 2868                 	sts pulse1_fx_Qxy_speed+1, zero
001385 9220 2869                 	sts pulse1_fx_Qxy_total_offset, zero
001387 9220 286a                 	sts pulse1_fx_Qxy_total_offset+1, zero
001389 9220 286b                 	sts pulse1_fx_Rxy_target_note, zero
00138b 9220 286c                 	sts pulse1_fx_Rxy_target, zero
00138d 9220 286d                 	sts pulse1_fx_Rxy_target+1, zero
00138f 9220 286e                 	sts pulse1_fx_Rxy_speed, zero
001391 9220 286f                 	sts pulse1_fx_Rxy_speed+1, zero
001393 9220 2870                 	sts pulse1_fx_Rxy_total_offset, zero
001395 9220 2871                 	sts pulse1_fx_Rxy_total_offset+1, zero
001397 93c0 2872                 	sts pulse1_fx_Sxx_pre, r28
001399 93c0 2873                 	sts pulse1_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 1 instrument macros
00139b efcf                      	ldi r28, 0xFF
00139c 9220 287c                 	sts pulse2_volume_macro_offset, zero
00139e 93c0 287d                 	sts pulse2_volume_macro_loop, r28
0013a0 93c0 287e                 	sts pulse2_volume_macro_release, r28
0013a2 9220 2881                 	sts pulse2_arpeggio_macro_offset, zero
0013a4 93c0 2882                 	sts pulse2_arpeggio_macro_loop, r28
0013a6 93c0 2883                 	sts pulse2_arpeggio_macro_release, r28
0013a8 93c0 2884                 	sts pulse2_arpeggio_macro_mode, r28
0013aa 9220 2889                 	sts pulse2_pitch_macro_offset, zero
0013ac 93c0 288a                 	sts pulse2_pitch_macro_loop, r28
0013ae 93c0 288b                 	sts pulse2_pitch_macro_release, r28
0013b0 9220 288f                 	sts pulse2_hi_pitch_macro_offset, zero
0013b2 93c0 2890                 	sts pulse2_hi_pitch_macro_loop, r28
0013b4 93c0 2891                 	sts pulse2_hi_pitch_macro_release, r28
0013b6 9220 2894                 	sts pulse2_duty_macro_offset, zero
0013b8 93c0 2895                 	sts pulse2_duty_macro_loop, r28
0013ba 93c0 2896                 	sts pulse2_duty_macro_release, r28
                                 
0013bc 9220 287a                 	sts pulse2_volume_macro, zero
0013be 9220 287b                 	sts pulse2_volume_macro+1, zero
0013c0 9220 287f                 	sts pulse2_arpeggio_macro, zero
0013c2 9220 2880                 	sts pulse2_arpeggio_macro+1, zero
0013c4 9220 2885                 	sts pulse2_total_pitch_offset, zero
0013c6 9220 2886                 	sts pulse2_total_pitch_offset+1, zero
0013c8 9220 2887                 	sts pulse2_pitch_macro, zero
0013ca 9220 2888                 	sts pulse2_pitch_macro+1, zero
0013cc 9220 288c                 	sts pulse2_total_hi_pitch_offset, zero
0013ce 9220 288d                 	sts pulse2_hi_pitch_macro, zero
0013d0 9220 288e                 	sts pulse2_hi_pitch_macro+1, zero
0013d2 9220 2892                 	sts pulse2_duty_macro, zero
0013d4 9220 2893                 	sts pulse2_duty_macro+1, zero
                                 
                                 	//CHANNEL 1 ENVELOPE
0013d6 e02f                      	ldi pulse2_volume_divider, 0x0F
0013d7 9130 2808                 	lds pulse2_volume_decay, pulse2_param
0013d9 703f                      	andi pulse2_volume_decay, 0x0F //mask for VVVV bits
0013da 91d0 2808                 	lds r29, pulse2_param
0013dc 73d0                      	andi r29, 0b00110000
0013dd 62d0                      	sbr r29, 0b0100000 //set start flag
0013de 95d2                      	swap r29
0013df 2b9d                      	or pulse_channel_flags, r29
0013e0 9220 280e                 	sts pulse2_output_volume, zero
0013e2 93c0 280d                 	sts pulse2_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 1 LENGTH
0013e4 2ebc                      	mov pulse2_length_counter, r28
                                 
                                 	//CHANNEL 1 SEQUENCE
0013e5 e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
0013e6 2eac                      	mov pulse2_sequence, r28
                                 
                                 	//CHANNEL 1 SWEEP
0013e7 90c0 2809                 	lds pulse2_sweep, pulse2_sweep_param
0013e9 94c2                      	swap pulse2_sweep //swap data from high byte and low byte
0013ea 6098                      	sbr pulse_channel_flags, 0b00001000 //set reload flag
                                 
                                 	//CHANNEL 1 FX
0013eb efcf                      	ldi r28, 0xFF
0013ec 9220 2897                 	sts pulse2_fx_0xy_sequence, zero
0013ee 9220 2898                 	sts pulse2_fx_0xy_sequence+1, zero
0013f0 9220 2899                 	sts pulse2_fx_1xx, zero
0013f2 9220 289a                 	sts pulse2_fx_1xx+1, zero
0013f4 9220 289b                 	sts pulse2_fx_1xx_total, zero
0013f6 9220 289c                 	sts pulse2_fx_1xx_total+1, zero
0013f8 9220 289d                 	sts pulse2_fx_2xx, zero
0013fa 9220 289e                 	sts pulse2_fx_2xx+1, zero
0013fc 9220 289f                 	sts pulse2_fx_2xx_total, zero
0013fe 9220 28a0                 	sts pulse2_fx_2xx_total+1, zero
001400 9220 28a1                 	sts pulse2_fx_3xx_start, zero
001402 9220 28a2                 	sts pulse2_fx_3xx_start+1, zero
001404 9220 28a3                 	sts pulse2_fx_3xx_target, zero
001406 9220 28a4                 	sts pulse2_fx_3xx_target+1, zero
001408 9220 28a5                 	sts pulse2_fx_3xx_speed, zero
00140a 9220 28a6                 	sts pulse2_fx_3xx_speed+1, zero
00140c 9220 28a7                 	sts pulse2_fx_3xx_total_offset, zero
00140e 9220 28a8                 	sts pulse2_fx_3xx_total_offset+1, zero
001410 9220 28a9                 	sts pulse2_fx_4xy_speed, zero
001412 9220 28aa                 	sts pulse2_fx_4xy_depth, zero
001414 9220 28ab                 	sts pulse2_fx_4xy_phase, zero
001416 9220 28ac                 	sts pulse2_fx_7xy_speed, zero
001418 9220 28ad                 	sts pulse2_fx_7xy_depth, zero
00141a 9220 28ae                 	sts pulse2_fx_7xy_phase, zero
00141c 9220 28af                 	sts pulse2_fx_7xy_value, zero
00141e 9220 28b0                 	sts pulse2_fx_Axy, zero
001420 93c0 28b1                 	sts pulse2_fx_Gxx_pre, r28
001422 93c0 28b2                 	sts pulse2_fx_Gxx_post, r28
001424 9220 28b3                 	sts pulse2_fx_Pxx_total, zero
001426 9220 28b4                 	sts pulse2_fx_Pxx_total+1, zero
001428 9220 28b5                 	sts pulse2_fx_Qxy_target_note, zero
00142a 9220 28b6                 	sts pulse2_fx_Qxy_target, zero
00142c 9220 28b7                 	sts pulse2_fx_Qxy_target+1, zero
00142e 9220 28b8                 	sts pulse2_fx_Qxy_speed, zero
001430 9220 28b9                 	sts pulse2_fx_Qxy_speed+1, zero
001432 9220 28ba                 	sts pulse2_fx_Qxy_total_offset, zero
001434 9220 28bb                 	sts pulse2_fx_Qxy_total_offset+1, zero
001436 9220 28bc                 	sts pulse2_fx_Rxy_target_note, zero
001438 9220 28bd                 	sts pulse2_fx_Rxy_target, zero
00143a 9220 28be                 	sts pulse2_fx_Rxy_target+1, zero
00143c 9220 28bf                 	sts pulse2_fx_Rxy_speed, zero
00143e 9220 28c0                 	sts pulse2_fx_Rxy_speed+1, zero
001440 9220 28c1                 	sts pulse2_fx_Rxy_total_offset, zero
001442 9220 28c2                 	sts pulse2_fx_Rxy_total_offset+1, zero
001444 93c0 28c3                 	sts pulse2_fx_Sxx_pre, r28
001446 93c0 28c4                 	sts pulse2_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 2 instrument macros
001448 efcf                      	ldi r28, 0xFF
001449 9220 28cd                 	sts triangle_volume_macro_offset, zero
00144b 93c0 28ce                 	sts triangle_volume_macro_loop, r28
00144d 93c0 28cf                 	sts triangle_volume_macro_release, r28
00144f 9220 28d2                 	sts triangle_arpeggio_macro_offset, zero
001451 93c0 28d3                 	sts triangle_arpeggio_macro_loop, r28
001453 93c0 28d4                 	sts triangle_arpeggio_macro_release, r28
001455 93c0 28d5                 	sts triangle_arpeggio_macro_mode, r28
001457 9220 28da                 	sts triangle_pitch_macro_offset, zero
001459 93c0 28db                 	sts triangle_pitch_macro_loop, r28
00145b 93c0 28dc                 	sts triangle_pitch_macro_release, r28
00145d 9220 28e0                 	sts triangle_hi_pitch_macro_offset, zero
00145f 93c0 28e1                 	sts triangle_hi_pitch_macro_loop, r28
001461 93c0 28e2                 	sts triangle_hi_pitch_macro_release, r28
001463 9220 28e5                 	sts triangle_duty_macro_offset, zero
001465 93c0 28e6                 	sts triangle_duty_macro_loop, r28
001467 93c0 28e7                 	sts triangle_duty_macro_release, r28
                                 
001469 9220 28cb                 	sts triangle_volume_macro, zero
00146b 9220 28cc                 	sts triangle_volume_macro+1, zero
00146d 9220 28d0                 	sts triangle_arpeggio_macro, zero
00146f 9220 28d1                 	sts triangle_arpeggio_macro+1, zero
001471 9220 28d6                 	sts triangle_total_pitch_offset, zero
001473 9220 28d7                 	sts triangle_total_pitch_offset+1, zero
001475 9220 28d8                 	sts triangle_pitch_macro, zero
001477 9220 28d9                 	sts triangle_pitch_macro+1, zero
001479 9220 28dd                 	sts triangle_total_hi_pitch_offset, zero
00147b 9220 28de                 	sts triangle_hi_pitch_macro, zero
00147d 9220 28df                 	sts triangle_hi_pitch_macro+1, zero
00147f 9220 28e3                 	sts triangle_duty_macro, zero
001481 9220 28e4                 	sts triangle_duty_macro+1, zero
                                 
                                 	//CHANNEL 2 SEQUENCE
001483 e0c0                      	ldi r28, 0b00000000 //reset sequence to 0
001484 2f4c                      	mov triangle_sequence, r28
                                 
                                 	//CHANNEL 2 FX
001485 efcf                      	ldi r28, 0xFF
001486 9220 28e8                 	sts triangle_fx_0xy_sequence, zero
001488 9220 28e9                 	sts triangle_fx_0xy_sequence+1, zero
00148a 9220 28ea                 	sts triangle_fx_1xx, zero
00148c 9220 28eb                 	sts triangle_fx_1xx+1, zero
00148e 9220 28ec                 	sts triangle_fx_1xx_total, zero
001490 9220 28ed                 	sts triangle_fx_1xx_total+1, zero
001492 9220 28ee                 	sts triangle_fx_2xx, zero
001494 9220 28ef                 	sts triangle_fx_2xx+1, zero
001496 9220 28f0                 	sts triangle_fx_2xx_total, zero
001498 9220 28f1                 	sts triangle_fx_2xx_total+1, zero
00149a 9220 28f2                 	sts triangle_fx_3xx_start, zero
00149c 9220 28f3                 	sts triangle_fx_3xx_start+1, zero
00149e 9220 28f4                 	sts triangle_fx_3xx_target, zero
0014a0 9220 28f5                 	sts triangle_fx_3xx_target+1, zero
0014a2 9220 28f6                 	sts triangle_fx_3xx_speed, zero
0014a4 9220 28f7                 	sts triangle_fx_3xx_speed+1, zero
0014a6 9220 28f8                 	sts triangle_fx_3xx_total_offset, zero
0014a8 9220 28f9                 	sts triangle_fx_3xx_total_offset+1, zero
0014aa 9220 28fa                 	sts triangle_fx_4xy_speed, zero
0014ac 9220 28fb                 	sts triangle_fx_4xy_depth, zero
0014ae 9220 28fc                 	sts triangle_fx_4xy_phase, zero
0014b0 93c0 28fd                 	sts triangle_fx_Gxx_pre, r28
0014b2 93c0 28fe                 	sts triangle_fx_Gxx_post, r28
0014b4 9220 28ff                 	sts triangle_fx_Pxx_total, zero
0014b6 9220 2900                 	sts triangle_fx_Pxx_total+1, zero
0014b8 9220 2901                 	sts triangle_fx_Qxy_target_note, zero
0014ba 9220 2902                 	sts triangle_fx_Qxy_target, zero
0014bc 9220 2903                 	sts triangle_fx_Qxy_target+1, zero
0014be 9220 2904                 	sts triangle_fx_Qxy_speed, zero
0014c0 9220 2905                 	sts triangle_fx_Qxy_speed+1, zero
0014c2 9220 2906                 	sts triangle_fx_Qxy_total_offset, zero
0014c4 9220 2907                 	sts triangle_fx_Qxy_total_offset+1, zero
0014c6 9220 2908                 	sts triangle_fx_Rxy_target_note, zero
0014c8 9220 2909                 	sts triangle_fx_Rxy_target, zero
0014ca 9220 290a                 	sts triangle_fx_Rxy_target+1, zero
0014cc 9220 290b                 	sts triangle_fx_Rxy_speed, zero
0014ce 9220 290c                 	sts triangle_fx_Rxy_speed+1, zero
0014d0 9220 290d                 	sts triangle_fx_Rxy_total_offset, zero
0014d2 9220 290e                 	sts triangle_fx_Rxy_total_offset+1, zero
0014d4 93c0 290f                 	sts triangle_fx_Sxx_pre, r28
0014d6 93c0 2910                 	sts triangle_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 3 instrument macros
0014d8 efcf                      	ldi r28, 0xFF
0014d9 9220 2919                 	sts noise_volume_macro_offset, zero
0014db 93c0 291a                 	sts noise_volume_macro_loop, r28
0014dd 93c0 291b                 	sts noise_volume_macro_release, r28
0014df 9220 291e                 	sts noise_arpeggio_macro_offset, zero
0014e1 93c0 291f                 	sts noise_arpeggio_macro_loop, r28
0014e3 93c0 2920                 	sts noise_arpeggio_macro_release, r28
0014e5 93c0 2921                 	sts noise_arpeggio_macro_mode, r28
0014e7 9220 2926                 	sts noise_pitch_macro_offset, zero
0014e9 93c0 2927                 	sts noise_pitch_macro_loop, r28
0014eb 93c0 2928                 	sts noise_pitch_macro_release, r28
0014ed 9220 292c                 	sts noise_hi_pitch_macro_offset, zero
0014ef 93c0 292d                 	sts noise_hi_pitch_macro_loop, r28
0014f1 93c0 292e                 	sts noise_hi_pitch_macro_release, r28
0014f3 9220 2931                 	sts noise_duty_macro_offset, zero
0014f5 93c0 2932                 	sts noise_duty_macro_loop, r28
0014f7 93c0 2933                 	sts noise_duty_macro_release, r28
                                 
0014f9 9220 2917                 	sts noise_volume_macro, zero
0014fb 9220 2918                 	sts noise_volume_macro+1, zero
0014fd 9220 291c                 	sts noise_arpeggio_macro, zero
0014ff 9220 291d                 	sts noise_arpeggio_macro+1, zero
001501 9220 2922                 	sts noise_total_pitch_offset, zero
001503 9220 2923                 	sts noise_total_pitch_offset+1, zero
001505 9220 2924                 	sts noise_pitch_macro, zero
001507 9220 2925                 	sts noise_pitch_macro+1, zero
001509 9220 2929                 	sts noise_total_hi_pitch_offset, zero
00150b 9220 292a                 	sts noise_hi_pitch_macro, zero
00150d 9220 292b                 	sts noise_hi_pitch_macro+1, zero
00150f 9220 292f                 	sts noise_duty_macro, zero
001511 9220 2930                 	sts noise_duty_macro+1, zero
                                 
                                 	//CHANNEL 3 VOLUME
001513 9220 2816                 	sts noise_output_volume, zero
001515 93c0 2815                 	sts noise_fractional_volume, r28 //initialize fractional volume to max value
                                 
                                 	//CHANNEL 3 SEQUENCE
001517 e0c1                      	ldi r28, 0b00000001 //noise sequence is reset to 0x0001
001518 2f5c                      	mov noise_sequence_LOW, r28
001519 2d62                      	mov noise_sequence_HIGH, zero
                                 
                                 	//CHANNEL 3 FX
00151a efcf                      	ldi r28, 0xFF
00151b 9220 2934                 	sts noise_fx_0xy_sequence, zero
00151d 9220 2935                 	sts noise_fx_0xy_sequence+1, zero
00151f 9220 2936                 	sts noise_fx_1xx, zero
001521 9220 2937                 	sts noise_fx_1xx_total, zero
001523 9220 2938                 	sts noise_fx_2xx, zero
001525 9220 2939                 	sts noise_fx_2xx_total, zero
001527 9220 293a                 	sts noise_fx_4xy_speed, zero
001529 9220 293b                 	sts noise_fx_4xy_depth, zero
00152b 9220 293c                 	sts noise_fx_4xy_phase, zero
00152d 9220 293d                 	sts noise_fx_4xy_offset, zero
00152f 9220 293e                 	sts noise_fx_7xy_speed, zero
001531 9220 293f                 	sts noise_fx_7xy_depth, zero
001533 9220 2940                 	sts noise_fx_7xy_phase, zero
001535 9220 2941                 	sts noise_fx_7xy_value, zero
001537 9220 2942                 	sts noise_fx_Axy, zero
001539 93c0 2943                 	sts noise_fx_Gxx_pre, r28
00153b 93c0 2944                 	sts noise_fx_Gxx_post, r28
00153d 9220 2945                 	sts noise_fx_Pxx_total, zero
00153f 93c0 2946                 	sts noise_fx_Sxx_pre, r28
001541 93c0 2947                 	sts noise_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 4 SAMPLE
001543 9220 294e                 	sts dpcm_sample, zero
001545 9220 294f                 	sts dpcm_sample+1, zero
001547 9220 2950                 	sts dpcm_sample_offset, zero
001549 9220 2951                 	sts dpcm_sample_offset+1, zero
00154b 2cd2                      	mov dpcm_shift, zero
00154c 2ce2                      	mov dpcm_bit_counter, zero
00154d 2cf2                      	mov dpcm_period, zero
00154e 2d72                      	mov dpcm_length_LOW, zero
00154f 2d82                      	mov dpcm_length_HIGH, zero
                                 
                                 	//CHANNEL 4 FX
001550 93c0 2943                 	sts noise_fx_Gxx_pre, r28
001552 93c0 2944                 	sts noise_fx_Gxx_post, r28
001554 93c0 2946                 	sts noise_fx_Sxx_pre, r28
001556 93c0 2947                 	sts noise_fx_Sxx_post, r28
                                 
                                 	//PINS
001558 efcf                      	ldi r28, 0xFF
001559 b9c0                      	out VPORTA_DIR, r28 //set all pins in VPORTA to output
                                 
                                 	//TIMERS
                                 	//Frame Counter
                                 	//NOTE:The frame counter will be defaulted to NTSC mode (60 Hz, 120 Hz, 240 Hz)
                                 	//Each interrupt will be setup to interrupt every 240 Hz clock
                                 	//CMP0 = sequence 0, CMP1 = sequence 1, CMP2 = sequence 2, OVF = sequence 3/sound driver
                                 	//Sequence 3 will clock the sound driver every 60Hz, in which new audio data is read and written to the registers
                                 	//Timer period Calculation: (0.00416666666 * 20000000/64)-1 = 1301.08333125 = 0x0515
                                 	//The ATmega4809 is cofigured to run at 20000000 Hz
                                 	//0.00416666666 seconds is the period for 240 Hz
                                 	//The /64 comes from the prescaler divider used
00155a e7c0                      	ldi r28, TCA_SINGLE_CMP0EN_bm | TCA_SINGLE_CMP1EN_bm | TCA_SINGLE_CMP2EN_bm | TCA_SINGLE_WGMODE_NORMAL_gc //interrupt mode
00155b 93c0 0a01                 	sts TCA0_SINGLE_CTRLB, r28
00155d e7c1                      	ldi r28, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP1_bm | TCA_SINGLE_CMP2_bm | TCA_SINGLE_OVF_bm //enable overflow and compare interrupts
00155e 93c0 0a0a                 	sts TCA0_SINGLE_INTCTRL, r28
001560 e1c5                      	ldi r28, 0x15 //set the period for CMP0
001561 93c0 0a28                 	sts TCA0_SINGLE_CMP0, r28
001563 e0c5                      	ldi r28, 0x05
001564 93c0 0a29                 	sts TCA0_SINGLE_CMP0 + 1, r28
001566 e2cb                      	ldi r28, 0x2B //set the period for CMP1
001567 93c0 0a2a                 	sts TCA0_SINGLE_CMP1, r28
001569 e0ca                      	ldi r28, 0x0A
00156a 93c0 0a2b                 	sts TCA0_SINGLE_CMP1 + 1, r28
00156c e4c1                      	ldi r28, 0x41 //set the period for CMP2
00156d 93c0 0a2c                 	sts TCA0_SINGLE_CMP2, r28
00156f e0cf                      	ldi r28, 0x0F
001570 93c0 0a2d                 	sts TCA0_SINGLE_CMP2 + 1, r28
001572 e5c7                      	ldi r28, 0x57 //set the period for OVF
001573 93c0 0a26                 	sts TCA0_SINGLE_PER, r28
001575 e1c4                      	ldi r28, 0x14
001576 93c0 0a27                 	sts TCA0_SINGLE_PER + 1, r28
001578 e0cb                      	ldi r28, TCA_SINGLE_CLKSEL_DIV64_gc | TCA_SINGLE_ENABLE_bm //use prescale divider of 64 and enable timer
001579 93c0 0a00                 	sts TCA0_SINGLE_CTRLA, r28
                                 
                                 	//NOTE: Channel Timers are clocked (20/2)/(0.8948865) = 11.1746014718 times faster than the NES APU
                                 	//Because of this, we multiply all the NES timer values by 11.1746014718 beforehand
                                 	//Since we rotate the sequence when the timer goes from t-(t-1) to 0, instead of 0 to t like the NES, we add 1 to the NES timers before multiplying
                                 	//The ATmega4809 is configured to run at 20 MHz
                                 	//The /2 comes from the prescaler divider used
                                 	//0.8948865 MHz is the speed of the NTSC NES APU
                                 	//NOTE: This means that any offset to the pitch for the NES timers would be multiplied by 11.1746014718 aswell.
                                 	//Pulse 1
00157b e0c0                      	ldi r28, TCB_CNTMODE_INT_gc //interrupt mode
00157c 93c0 0a81                 	sts TCB0_CTRLB, r28
00157e e0c1                      	ldi r28, TCB_CAPT_bm //enable interrupts
00157f 93c0 0a85                 	sts TCB0_INTCTRL, r28
001581 91c0 2802                 	lds r28, pulse1_timerL //load the LOW bits for timer
001583 93c0 0a8c                 	sts TCB0_CCMPL, r28
001585 91c0 2803                 	lds r28, pulse1_timerH //load the HIGH bits for timer
001587 93c0 0a8d                 	sts TCB0_CCMPH, r28
001589 e0c3                      	ldi r28, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
00158a 93c0 0a80                 	sts TCB0_CTRLA, r28
                                 
                                 	//PULSE 2
00158c e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
00158d 93b0 0a91                 	sts TCB1_CTRLB, r27
00158f e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001590 93b0 0a95                 	sts TCB1_INTCTRL, r27
001592 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
001594 93b0 0a9c                 	sts TCB1_CCMPL, r27
001596 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
001598 93b0 0a9d                 	sts TCB1_CCMPH, r27
00159a e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
00159b 93b0 0a90                 	sts TCB1_CTRLA, r27
                                 
                                 	//NOTE: The triangle timer is clocked at the same speed as the NES CPU, aka twice the NES APU.
                                 	//Therefore, we won't be using a /2 clock divider like we did with the pulse timers.
                                 	//TRIANGLE
00159d e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
00159e 93b0 0aa1                 	sts TCB2_CTRLB, r27
0015a0 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
                                 	//sts TCB2_INTCTRL, r27 //keep interrupts disabled to mute channel since triangle doesn't have volume bits
0015a1 91b0 2810                 	lds r27, triangle_timerL //load the LOW bits for timer
0015a3 93b0 0aac                 	sts TCB2_CCMPL, r27
0015a5 91b0 2811                 	lds r27, triangle_timerH //load the HIGH bits for timer
0015a7 93b0 0aad                 	sts TCB2_CCMPH, r27
0015a9 e0b1                      	ldi r27, TCB_CLKSEL_CLKDIV1_gc | TCB_ENABLE_bm //use prescaler divider of 1 and enable timer
0015aa 93b0 0aa0                 	sts TCB2_CTRLA, r27
0015ac 9478                      	sei //global interrupt enable
                                 
                                 	//NOISE
0015ad e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
0015ae 93b0 0ab1                 	sts TCB3_CTRLB, r27
0015b0 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
0015b1 93b0 0ab5                 	sts TCB3_INTCTRL, r27
0015b3 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
0015b5 93b0 0abc                 	sts TCB3_CCMPL, r27
0015b7 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
0015b9 93b0 0abd                 	sts TCB3_CCMPH, r27
0015bb e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
0015bc 93b0 0ab0                 	sts TCB3_CTRLA, r27
                                 
                                 
                                 
                                 //https://wiki.nesdev.com/w/index.php/APU_Mixer
                                 volume_mixer:
0015be 91c0 2806                 	lds r28, pulse1_output_volume
0015c0 91d0 280e                 	lds r29, pulse2_output_volume
                                 
                                 volume_mixer_pulse1:
0015c2 fe70                      	sbrs pulse1_sequence, 0 //if the sequence output is zero, return
0015c3 c015                      	rjmp volume_mixer_pulse1_off
                                 
0015c4 1482                      	cp pulse1_length_counter, zero //if length is zero, return
0015c5 f099                      	breq volume_mixer_pulse1_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
0015c6 91e0 0a8c                 	lds r30, TCB0_CCMPL
0015c8 e5f9                      	ldi r31, 0x59
0015c9 17ef                      	cp r30, r31
0015ca 91e0 0a8d                 	lds r30, TCB0_CCMPH
0015cc e0f0                      	ldi r31, 0x00
0015cd 07ef                      	cpc r30, r31
0015ce f050                      	brlo volume_mixer_pulse1_off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $595A
0015cf 91e0 0a8c                 	lds r30, TCB0_CCMPL
0015d1 e5fa                      	ldi r31, 0x5A
0015d2 17ef                      	cp r30, r31
0015d3 91e0 0a8d                 	lds r30, TCB0_CCMPH
0015d5 e5f9                      	ldi r31, 0x59
0015d6 07ef                      	cpc r30, r31
0015d7 f408                      	brsh volume_mixer_pulse1_off
0015d8 c001                      	rjmp volume_mixer_pulse2 //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse1_off:
0015d9 27cc                      	clr r28
                                 
                                 volume_mixer_pulse2:
0015da fea0                      	sbrs pulse2_sequence, 0 //if the sequence output is zero, return
0015db c015                      	rjmp volume_mixer_pulse2_off
                                 
0015dc 14b2                      	cp pulse2_length_counter, zero //if length is zero, return
0015dd f099                      	breq volume_mixer_pulse2_off
                                 
0015de 91e0 0a9c                 	lds r30, TCB1_CCMPL
0015e0 e5f9                      	ldi r31, 0x59
0015e1 17ef                      	cp r30, r31
0015e2 91e0 0a9d                 	lds r30, TCB1_CCMPH
0015e4 e0f0                      	ldi r31, 0x00
0015e5 07ef                      	cpc r30, r31
0015e6 f050                      	brlo volume_mixer_pulse2_off
                                 
0015e7 91e0 0a9c                 	lds r30, TCB1_CCMPL
0015e9 e5fa                      	ldi r31, 0x5A
0015ea 17ef                      	cp r30, r31
0015eb 91e0 0a9d                 	lds r30, TCB1_CCMPH
0015ed e5f9                      	ldi r31, 0x59
0015ee 07ef                      	cpc r30, r31
0015ef f408                      	brsh volume_mixer_pulse2_off
0015f0 c001                      	rjmp volume_mixer_pulse_out //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse2_off:
0015f1 27dd                      	clr r29
                                 
                                 volume_mixer_pulse_out:
0015f2 0fcd                      	add r28, r29
0015f3 e6e2                      	ldi ZL, LOW(pulse_volume_table << 1)
0015f4 e0f2                      	ldi ZH, HIGH(pulse_volume_table << 1)
0015f5 0fec                      	add ZL, r28
0015f6 1df2                      	adc ZH, zero
0015f7 91c4                      	lpm r28, Z
                                 
                                 volume_mixer_tnd_triangle:
0015f8 2fd4                      	mov r29, triangle_sequence
0015f9 fdd4                      	sbrc r29, 4 //check 5th bit
0015fa 95d0                      	com r29
0015fb 70df                      	andi r29, 0x0F
0015fc 2fed                      	mov r30, r29
0015fd 0fde                      	add r29, r30 //multiply the triangle volume by 3
0015fe 0fde                      	add r29, r30
                                 
                                 volume_mixer_tnd_noise:
0015ff ff50                      	sbrs noise_sequence_LOW, 0 //check 0th bit, skip if set
001600 c004                      	rjmp volume_mixer_tnd_out
001601 91e0 2816                 	lds r30, noise_output_volume
001603 0fee                      	lsl r30 //multiply noise volume by 2
001604 0fde                      	add r29, r30
                                 
                                 volume_mixer_tnd_out:
001605 e8e2                      	ldi ZL, LOW(tnd_volume_table << 1)
001606 e0f2                      	ldi ZH, HIGH(tnd_volume_table << 1)
001607 0fed                      	add ZL, r29
001608 1df2                      	adc ZH, zero
001609 91d4                      	lpm r29, Z
                                 
                                 volume_mixer_output:
00160a 0fcd                      	add r28, r29
00160b b9c1                      	out VPORTA_OUT, r28
00160c cfb1                      	rjmp volume_mixer
                                 
                                 
                                 
                                 //FRAME COUNTER/AUDIO SAMPLE ISR
                                 sequence_0_2:
00160d b7bf                      	in r27, CPU_SREG
00160e 93bf                      	push r27
00160f 94f8                      	cli
                                 
                                 	//ENVELOPE
001610 d053                      	rcall pulse1_envelope_routine
001611 d09f                      	rcall pulse2_envelope_routine
                                 
001612 e5b0                      	ldi r27, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP2_bm //clear OVF flag
001613 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
001615 91bf                      	pop r27
001616 bfbf                      	out CPU_SREG, r27
001617 9518                      	reti
                                 
                                 sequence_1_3:
001618 b7bf                      	in r27, CPU_SREG
001619 93bf                      	push r27
00161a 94f8                      	cli
                                 
                                 	//ENVELOPE
00161b d048                      	rcall pulse1_envelope_routine
00161c d094                      	rcall pulse2_envelope_routine
                                 
                                 	//SWEEP
00161d fc93                      	sbrc pulse1_sweep, 3 //check if the sweep enable bit is cleared
00161e d01b                      	rcall pulse1_sweep_routine
00161f fcc3                      	sbrc pulse2_sweep, 3
001620 d066                      	rcall pulse2_sweep_routine
                                 
                                 	//LENGTH
                                 	//NOTE: The length routine is relatively simple, so we will not be using clocks to rjmp and ret to a seperate lable
                                 sequence_1_3_pulse1_length:
001621 fd95                      	sbrc pulse_channel_flags, 5 //check if the length counter halt bit is cleared
001622 c002                      	rjmp sequence_1_3_pulse2_length
001623 1082                      	cpse pulse1_length_counter, zero //if length counter is already 0, don't decrement
001624 948a                      	dec pulse1_length_counter
                                 sequence_1_3_pulse2_length:
001625 fd91                      	sbrc pulse_channel_flags, 1 //check if the length counter halt bit is cleared
001626 c002                      	rjmp sequence_1_3_exit
001627 10b2                      	cpse pulse2_length_counter, zero //if length counter is already 0, don't decrement
001628 94ba                      	dec pulse2_length_counter
                                 
                                 sequence_1_3_exit:
001629 e2b1                      	ldi r27, TCA_SINGLE_CMP1_bm | TCA_SINGLE_OVF_bm //clear OVF flag
00162a 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
00162c 91bf                      	pop r27
00162d bfbf                      	out CPU_SREG, r27
00162e 9518                      	reti
                                 
                                 //PULSE 1 ROUTINES
                                 pulse1_sequence_routine:
00162f b7bf                      	in r27, CPU_SREG
001630 93bf                      	push r27
001631 94f8                      	cli
                                 
001632 0c77                      	lsl pulse1_sequence //shifts sequence to the left
001633 1c72                      	adc pulse1_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
001634 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
001635 93b0 0a86                 	sts TCB0_INTFLAGS, r27
001637 91bf                      	pop r27
001638 bfbf                      	out CPU_SREG, r27
001639 9518                      	reti
                                 
                                 pulse1_sweep_routine:
00163a 2db9                      	mov r27, pulse1_sweep
00163b 70b7                      	andi r27, 0x07 //mask for period divider bits
00163c f4f9                      	brne pulse1_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse1_sweep_routine_action: //if the divider is == 0, update the pulse timer period
00163d 93df                      	push r29
00163e 2dd9                      	mov r29, pulse1_sweep
00163f 95d2                      	swap r29
001640 70d7                      	andi r29, 0x07 //mask for shift bits
001641 f411                      	brne pulse1_sweep_routine_action_main //shift != 0
001642 91df                      	pop r29
001643 c019                      	rjmp pulse1_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse1_sweep_routine_action_main:
001644 91a0 0a8c                 	lds r26, TCB0_CCMPL
001646 91b0 0a8d                 	lds r27, TCB0_CCMPH
                                 pulse1_sweep_routine_action_main_loop:
001648 95b6                      	lsr r27
001649 95a7                      	ror r26
00164a 95da                      	dec r29
00164b f7e1                      	brne pulse1_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
00164c fe97                      	sbrs pulse1_sweep, 7 //check the negate flag
00164d c002                      	rjmp pulse1_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
00164e 95a0                      	com r26 //pulse1 uses one's complement if the negate flag is set
00164f 95b0                      	com r27
                                 
                                 pulse1_sweep_routine_action_main_add:
001650 91d0 0a8c                 	lds r29, TCB0_CCMPL //perform addition to get new timer period
001652 0fad                      	add r26, r29
001653 91d0 0a8d                 	lds r29, TCB0_CCMPH
001655 1fbd                      	adc r27, r29
                                 
001656 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new LOW bits for timer
001658 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new HIGH bits for timer
                                 	
00165a 91df                      	pop r29
00165b c001                      	rjmp pulse1_sweep_routine_check_reload
                                 
                                 pulse1_sweep_routine_decrement_divider:
00165c 949a                      	dec pulse1_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse1_sweep_routine_check_reload:
00165d ff97                      	sbrs pulse_channel_flags, 7 //if the reload flag is set, reload the sweep divider
00165e 9508                      	ret
                                 
                                 pulse1_sweep_reload:
00165f 9090 2801                 	lds pulse1_sweep, pulse1_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
001661 9492                      	swap pulse1_sweep //bring data from high byte to low byte
001662 779f                      	cbr pulse_channel_flags, 0b10000000 //clear reload flag
001663 9508                      	ret
                                 
                                 
                                 
                                 pulse1_envelope_routine:
001664 fd96                      	sbrc pulse_channel_flags, 6 //check if start flag is cleared
001665 c010                      	rjmp pulse1_envelope_routine_clear_start
                                 
001666 3000                      	cpi pulse1_volume_divider, 0x00 //check if the divider is 0
001667 f011                      	breq PC+3 //if the divider == 0, check loop flag
001668 950a                      	dec pulse1_volume_divider //if the divider != 0, decrement and return
001669 9508                      	ret
                                 
00166a 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the divider == 0, reset the divider period
00166c 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
00166d ff95                      	sbrs pulse_channel_flags, 5 //check if the loop flag is set
00166e c002                      	rjmp pulse1_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
00166f e01f                      	ldi pulse1_volume_decay, 0x0F //if the loop flag is set, reset decay and return
001670 9508                      	ret
                                 
                                 pulse1_envelope_routine_decrement_decay:
001671 3010                      	cpi pulse1_volume_decay, 0x00 //check if the decay is 0
001672 f409                      	brne PC+2 //if decay != 0, go decrement
001673 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
001674 951a                      	dec pulse1_volume_decay
001675 9508                      	ret
                                 
                                 pulse1_envelope_routine_clear_start:
001676 7b9f                      	cbr pulse_channel_flags, 0b01000000 //if the start flag is set, clear it
001677 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the start flag is set, reset the divider period
001679 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
00167a e01f                      	ldi pulse1_volume_decay, 0x0F //if the start flag is set, reset decay
00167b 9508                      	ret
                                 
                                 //PULSE 2 ROUTINES
                                 pulse2_sequence_routine:
00167c b7bf                      	in r27, CPU_SREG
00167d 93bf                      	push r27
00167e 94f8                      	cli
                                 
00167f 0caa                      	lsl pulse2_sequence //shifts sequence to the left
001680 1ca2                      	adc pulse2_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
001681 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
001682 93b0 0a96                 	sts TCB1_INTFLAGS, r27
001684 91bf                      	pop r27
001685 bfbf                      	out CPU_SREG, r27
001686 9518                      	reti
                                 
                                 pulse2_sweep_routine:
001687 2dbc                      	mov r27, pulse2_sweep
001688 70b7                      	andi r27, 0x07 //mask for period divider bits
001689 f4f9                      	brne pulse2_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse2_sweep_routine_action: //if the divider is == 0, update the pulse timer period
00168a 93df                      	push r29
00168b 2ddc                      	mov r29, pulse2_sweep
00168c 95d2                      	swap r29
00168d 70d7                      	andi r29, 0x07 //mask for shift bits
00168e f411                      	brne pulse2_sweep_routine_action_main //shift != 0
00168f 91df                      	pop r29
001690 c019                      	rjmp pulse2_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse2_sweep_routine_action_main:
001691 91a0 0a9c                 	lds r26, TCB1_CCMPL
001693 91b0 0a9d                 	lds r27, TCB1_CCMPH
                                 pulse2_sweep_routine_action_main_loop:
001695 95b6                      	lsr r27
001696 95a7                      	ror r26
001697 95da                      	dec r29
001698 f7e1                      	brne pulse2_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
001699 fec7                      	sbrs pulse2_sweep, 7 //check the negate flag
00169a c002                      	rjmp pulse2_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
00169b 95a0                      	com r26 //pulse2 uses one's complement if the negate flag is set
00169c 95b0                      	com r27
                                 
                                 pulse2_sweep_routine_action_main_add:
00169d 91d0 0a9c                 	lds r29, TCB1_CCMPL //perform addition to get new timer period
00169f 0fad                      	add r26, r29
0016a0 91d0 0a9d                 	lds r29, TCB1_CCMPH
0016a2 1fbd                      	adc r27, r29
                                 
0016a3 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new LOW bits for timer
0016a5 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new HIGH bits for timer
                                 	
0016a7 91df                      	pop r29
0016a8 c001                      	rjmp pulse2_sweep_routine_check_reload
                                 
                                 pulse2_sweep_routine_decrement_divider:
0016a9 94ca                      	dec pulse2_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse2_sweep_routine_check_reload:
0016aa ff93                      	sbrs pulse_channel_flags, 3 //if the reload flag is set, reload the sweep divider
0016ab 9508                      	ret
                                 
                                 pulse2_sweep_reload:
0016ac 90c0 2809                 	lds pulse2_sweep, pulse2_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
0016ae 94c2                      	swap pulse2_sweep //bring data from high byte to low byte
0016af 7f97                      	cbr pulse_channel_flags, 0b00001000 //clear reload flag
0016b0 9508                      	ret
                                 
                                 
                                 
                                 pulse2_envelope_routine:
0016b1 fd92                      	sbrc pulse_channel_flags, 2 //check if start flag is cleared
0016b2 c010                      	rjmp pulse2_envelope_routine_clear_start
                                 
0016b3 3020                      	cpi pulse2_volume_divider, 0x00 //check if the divider is 0
0016b4 f011                      	breq PC+3 //if the divider == 0, check loop flag
0016b5 952a                      	dec pulse2_volume_divider //if the divider != 0, decrement and return
0016b6 9508                      	ret
                                 
0016b7 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the divider == 0, reset the divider period
0016b9 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
0016ba ff91                      	sbrs pulse_channel_flags, 1 //check if the loop flag is set
0016bb c002                      	rjmp pulse2_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
0016bc e03f                      	ldi pulse2_volume_decay, 0x0F //if the loop flag is set, reset decay and return
0016bd 9508                      	ret
                                 
                                 pulse2_envelope_routine_decrement_decay:
0016be 3030                      	cpi pulse2_volume_decay, 0x00 //check if the decay is 0
0016bf f409                      	brne PC+2 //if decay != 0, go decrement
0016c0 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
0016c1 953a                      	dec pulse2_volume_decay
0016c2 9508                      	ret
                                 
                                 pulse2_envelope_routine_clear_start:
0016c3 7f9b                      	cbr pulse_channel_flags, 0b00000100 //if the start flag is set, clear it
0016c4 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the start flag is set, reset the divider period
0016c6 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
0016c7 e03f                      	ldi pulse2_volume_decay, 0x0F //if the start flag is set, reset decay
0016c8 9508                      	ret
                                 
                                 //TRIANGLE ROUTINES
                                 triangle_sequence_routine:
0016c9 b7bf                      	in r27, CPU_SREG
0016ca 93bf                      	push r27
0016cb 94f8                      	cli
                                 
0016cc 5f4f                      	subi triangle_sequence, -1 //increment sequence by 1
0016cd 714f                      	andi triangle_sequence, 0b00011111 //mask out bits 5, 6 and 7 NOTE: the sequence only needs bits 0-4.
                                 
0016ce e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
0016cf 93b0 0aa6                 	sts TCB2_INTFLAGS, r27
0016d1 91bf                      	pop r27
0016d2 bfbf                      	out CPU_SREG, r27
0016d3 9518                      	reti
                                 
                                 //NOISE ROUTINES
                                 noise_sequence_routine:
0016d4 b7bf                      	in r27, CPU_SREG
0016d5 93bf                      	push r27
0016d6 94f8                      	cli
                                 
0016d7 2fa5                      	mov r26, noise_sequence_LOW
0016d8 fd67                      	sbrc noise_sequence_HIGH, 7 //skip if MODE bit is clear
0016d9 c00b                      	rjmp noise_sequence_routine_mode_set
                                 
                                 noise_sequence_routine_mode_clear:
0016da 95a6                      	lsr r26 //move the 1th bit to the 0th bit place
0016db 27a5                      	eor r26, noise_sequence_LOW
0016dc fda0                      	sbrc r26, 0 //skip if the EOR of bit 0 and 1 is clear
0016dd c003                      	rjmp noise_sequence_routine_mode_clear_EOR_set
                                 
                                 noise_sequence_routine_mode_clear_EOR_clear:
0016de 9566                      	lsr noise_sequence_HIGH
0016df 9557                      	ror noise_sequence_LOW
0016e0 c013                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_clear_EOR_set:
0016e1 9566                      	lsr noise_sequence_HIGH
0016e2 9557                      	ror noise_sequence_LOW
0016e3 6460                      	ori noise_sequence_HIGH, 0b01000000 //set the 14th bit
0016e4 c00f                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_set:
0016e5 0faa                      	lsl r26
0016e6 1faa                      	rol r26
0016e7 1faa                      	rol r26 //move the 6th bit to the 0th bit place
0016e8 27a5                      	eor r26, noise_sequence_LOW
0016e9 fda0                      	sbrc r26, 0 //skip if the EOR of bit 0 and 1 is clear
0016ea c005                      	rjmp noise_sequence_routine_mode_set_EOR_set
                                 
                                 noise_sequence_routine_mode_set_EOR_clear:
0016eb 776f                      	cbr noise_sequence_HIGH, 0b10000000 //clear the MODE flag
0016ec 9566                      	lsr noise_sequence_HIGH
0016ed 9557                      	ror noise_sequence_LOW
0016ee 6860                      	sbr noise_sequence_HIGH, 0b10000000 //set the MODE flag
0016ef c004                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_set_EOR_set:
0016f0 9566                      	lsr noise_sequence_HIGH
0016f1 9557                      	ror noise_sequence_LOW
0016f2 6860                      	sbr noise_sequence_HIGH, 0b10000000 //set the MODE flag
0016f3 c000                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_exit:
0016f4 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
0016f5 93b0 0ab6                 	sts TCB3_INTFLAGS, r27
0016f7 91bf                      	pop r27
0016f8 bfbf                      	out CPU_SREG, r27
0016f9 9518                      	reti
                                 
                                 //CONVERTERS
                                 //converts and loads 5 bit length to corresponding 8 bit length value into r29
                                 length_converter:
0016fa e9e6                      	ldi ZL, LOW(length << 1)
0016fb e6f0                      	ldi ZH, HIGH(length << 1)
0016fc 0fed                      	add ZL, r29
0016fd 1df2                      	adc ZH, zero
0016fe 91d4                      	lpm r29, Z
0016ff 9508                      	ret
                                 
                                 //loads pulse sequence into r29
                                 duty_cycle_sequences:
001700 ebe6                      	ldi ZL, LOW(sequences << 1)
001701 e6f0                      	ldi ZH, HIGH(sequences << 1)
001702 0fed                      	add ZL, r29
001703 1df2                      	adc ZH, zero
001704 91d4                      	lpm r29, Z
001705 9508                      	ret
                                 
                                 
                                 
                                 //SOUND DRIVER
                                 sound_driver:
001706 b7bf                      	in r27, CPU_SREG
001707 93bf                      	push r27
001708 94f8                      	cli
001709 93cf                      	push r28
00170a 93df                      	push r29
00170b 93ef                      	push r30
00170c 93ff                      	push r31
                                 
                                 	//SOUND DRIVER
00170d 91a0 2820                 	lds r26, song_fx_Bxx
00170f 3faf                      	cpi r26, 0xFF //0xFF means that the flag is disabled
001710 f4a9                      	brne sound_driver_fx_Bxx_routine
001711 91a0 2821                 	lds r26, song_fx_Cxx
001713 11a2                      	cpse r26, zero
001714 c08b                      	rjmp sound_driver_fx_Cxx_routine
001715 91a0 2822                 	lds r26, song_fx_Dxx
001717 11a2                      	cpse r26, zero
001718 c096                      	rjmp sound_driver_fx_Dxx_routine
                                 
001719 91a0 281b                 	lds r26, song_frame_offset
00171b 91b0 281c                 	lds r27, song_frame_offset+1
00171d 91c0 281d                 	lds r28, song_size
00171f 91d0 281e                 	lds r29, song_size+1
001721 17ac                      	cp r26, r28
001722 07bd                      	cpc r27, r29
001723 f408                      	brsh sound_driver_fx_song_loop
001724 c101                      	rjmp sound_driver_channel0
                                 
                                 
                                 sound_driver_fx_song_loop:
001725 e0a0                      	ldi r26, 0x00
                                 sound_driver_fx_Bxx_routine:
001726 91e0 2819                 	lds ZL, song_frames
001728 91f0 281a                 	lds ZH, song_frames+1
00172a 27cc                      	clr r28 //initialize r29:r28 to 0
00172b 27dd                      	clr r29
00172c 95a3                      	inc r26 //increment xx parameter by 1
                                 sound_driver_fx_Bxx_routine_loop:
00172d 95aa                      	dec r26
00172e f011                      	breq sound_driver_fx_Bxx_routine_loop_exit //once r26 == 0, r29:r28 will hold Bxx*(5*2).
00172f 962a                      	adiw r29:r28, 10 //increment the offset by 10 because 5 channels, and each address takes 2 bytes (5*2 = 10)
001730 cffc                      	rjmp sound_driver_fx_Bxx_routine_loop
                                 
                                 sound_driver_fx_Bxx_routine_loop_exit:
001731 9622                      	adiw r29:r28, 2 //add 2 to skip the first 2 bytes (first 2 bytes is the song size)
001732 93c0 281b                 	sts song_frame_offset, r28
001734 93d0 281c                 	sts song_frame_offset+1, r29
001736 0fec                      	add ZL, r28
001737 1ffd                      	adc ZH, r29
                                 
001738 91a5                      	lpm r26, Z+ //load the address of the frame(pattern)
001739 91b5                      	lpm r27, Z+
00173a 0faa                      	lsl r26
00173b 1fbb                      	rol r27
00173c 93a0 2823                 	sts pulse1_pattern, r26
00173e 93b0 2824                 	sts pulse1_pattern+1, r27
001740 91a5                      	lpm r26, Z+
001741 91b5                      	lpm r27, Z+
001742 0faa                      	lsl r26
001743 1fbb                      	rol r27
001744 93a0 2874                 	sts pulse2_pattern, r26
001746 93b0 2875                 	sts pulse2_pattern+1, r27
001748 91a5                      	lpm r26, Z+
001749 91b5                      	lpm r27, Z+
00174a 0faa                      	lsl r26
00174b 1fbb                      	rol r27
00174c 93a0 28c5                 	sts triangle_pattern, r26
00174e 93b0 28c6                 	sts triangle_pattern+1, r27
001750 91a5                      	lpm r26, Z+
001751 91b5                      	lpm r27, Z+
001752 0faa                      	lsl r26
001753 1fbb                      	rol r27
001754 93a0 2911                 	sts noise_pattern, r26
001756 93b0 2912                 	sts noise_pattern+1, r27
                                 
001758 9220 2827                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
00175a 9220 2828                 	sts pulse1_pattern_offset+1, zero
00175c 9220 2825                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
00175e 9220 2826                 	sts pulse1_pattern_delay_frames, zero
001760 9220 2878                 	sts pulse2_pattern_offset, zero
001762 9220 2879                 	sts pulse2_pattern_offset+1, zero
001764 9220 2876                 	sts pulse2_pattern_delay_rows, zero
001766 9220 2877                 	sts pulse2_pattern_delay_frames, zero
001768 9220 28c9                 	sts triangle_pattern_offset, zero
00176a 9220 28ca                 	sts triangle_pattern_offset+1, zero
00176c 9220 28c7                 	sts triangle_pattern_delay_rows, zero
00176e 9220 28c8                 	sts triangle_pattern_delay_frames, zero
001770 9220 2915                 	sts noise_pattern_offset, zero
001772 9220 2916                 	sts noise_pattern_offset+1, zero
001774 9220 2913                 	sts noise_pattern_delay_rows, zero
001776 9220 2914                 	sts noise_pattern_delay_frames, zero
                                 
001778 efaf                      	ldi r26, 0xFF
001779 93a0 2860                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
00177b 93a0 2861                 	sts pulse1_fx_Gxx_post, r26
00177d 93a0 2872                 	sts pulse1_fx_Sxx_pre, r26
00177f 93a0 2873                 	sts pulse1_fx_Sxx_post, r26
001781 93a0 28b1                 	sts pulse2_fx_Gxx_pre, r26
001783 93a0 28b2                 	sts pulse2_fx_Gxx_post, r26
001785 93a0 28c3                 	sts pulse2_fx_Sxx_pre, r26
001787 93a0 28c4                 	sts pulse2_fx_Sxx_post, r26
001789 93a0 28fd                 	sts triangle_fx_Gxx_pre, r26
00178b 93a0 28fe                 	sts triangle_fx_Gxx_post, r26
00178d 93a0 290f                 	sts triangle_fx_Sxx_pre, r26
00178f 93a0 2910                 	sts triangle_fx_Sxx_post, r26
001791 93a0 2943                 	sts noise_fx_Gxx_pre, r26
001793 93a0 2944                 	sts noise_fx_Gxx_post, r26
001795 93a0 2946                 	sts noise_fx_Sxx_pre, r26
001797 93a0 2947                 	sts noise_fx_Sxx_post, r26
                                 
001799 93a0 2820                 	sts song_fx_Bxx, r26 //reset all song effects
00179b 9220 2821                 	sts song_fx_Cxx, zero
00179d 9220 2822                 	sts song_fx_Dxx, zero
00179f c086                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_fx_Cxx_routine:
0017a0 91ff                      	pop r31
0017a1 91ef                      	pop r30
0017a2 91df                      	pop r29
0017a3 91cf                      	pop r28
0017a4 91bf                      	pop r27
0017a5 bfbf                      	out CPU_SREG, r27
0017a6 94f8                      	cli //disable global interrupts
                                 		
0017a7 efaf                      	ldi r26, 0xFF
0017a8 93a0 2820                 	sts song_fx_Bxx, r26 //reset all song effects
0017aa 9220 2821                 	sts song_fx_Cxx, zero
0017ac 9220 2822                 	sts song_fx_Dxx, zero
0017ae 9518                      	reti
                                 
                                 sound_driver_fx_Dxx_routine:
0017af 91e0 2819                 	lds ZL, song_frames
0017b1 91f0 281a                 	lds ZH, song_frames+1
0017b3 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
0017b5 91b0 281c                 	lds r27, song_frame_offset+1
0017b7 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
0017b8 93a0 281b                 	sts song_frame_offset, r26
0017ba 93b0 281c                 	sts song_frame_offset+1, r27
0017bc 0fea                      	add ZL, r26
0017bd 1ffb                      	adc ZH, r27
                                 
0017be 91a5                      	lpm r26, Z+ //load the address of the next pattern
0017bf 91b5                      	lpm r27, Z+
0017c0 0faa                      	lsl r26
0017c1 1fbb                      	rol r27
0017c2 93a0 2823                 	sts pulse1_pattern, r26
0017c4 93b0 2824                 	sts pulse1_pattern+1, r27
0017c6 91a5                      	lpm r26, Z+
0017c7 91b5                      	lpm r27, Z+
0017c8 0faa                      	lsl r26
0017c9 1fbb                      	rol r27
0017ca 93a0 2874                 	sts pulse2_pattern, r26
0017cc 93b0 2875                 	sts pulse2_pattern+1, r27
0017ce 91a5                      	lpm r26, Z+
0017cf 91b5                      	lpm r27, Z+
0017d0 0faa                      	lsl r26
0017d1 1fbb                      	rol r27
0017d2 93a0 28c5                 	sts triangle_pattern, r26
0017d4 93b0 28c6                 	sts triangle_pattern+1, r27
0017d6 91a5                      	lpm r26, Z+
0017d7 91b5                      	lpm r27, Z+
0017d8 0faa                      	lsl r26
0017d9 1fbb                      	rol r27
0017da 93a0 2911                 	sts noise_pattern, r26
0017dc 93b0 2912                 	sts noise_pattern+1, r27
                                 
0017de 9220 2827                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
0017e0 9220 2828                 	sts pulse1_pattern_offset+1, zero
0017e2 9220 2825                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
0017e4 9220 2826                 	sts pulse1_pattern_delay_frames, zero
0017e6 9220 2878                 	sts pulse2_pattern_offset, zero
0017e8 9220 2879                 	sts pulse2_pattern_offset+1, zero
0017ea 9220 2876                 	sts pulse2_pattern_delay_rows, zero
0017ec 9220 2877                 	sts pulse2_pattern_delay_frames, zero
0017ee 9220 28c9                 	sts triangle_pattern_offset, zero
0017f0 9220 28ca                 	sts triangle_pattern_offset+1, zero
0017f2 9220 28c7                 	sts triangle_pattern_delay_rows, zero
0017f4 9220 28c8                 	sts triangle_pattern_delay_frames, zero
0017f6 9220 2915                 	sts noise_pattern_offset, zero
0017f8 9220 2916                 	sts noise_pattern_offset+1, zero
0017fa 9220 2913                 	sts noise_pattern_delay_rows, zero
0017fc 9220 2914                 	sts noise_pattern_delay_frames, zero
                                 
0017fe efaf                      	ldi r26, 0xFF
0017ff 93a0 2860                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
001801 93a0 2861                 	sts pulse1_fx_Gxx_post, r26
001803 93a0 2872                 	sts pulse1_fx_Sxx_pre, r26
001805 93a0 2873                 	sts pulse1_fx_Sxx_post, r26
001807 93a0 28b1                 	sts pulse2_fx_Gxx_pre, r26
001809 93a0 28b2                 	sts pulse2_fx_Gxx_post, r26
00180b 93a0 28c3                 	sts pulse2_fx_Sxx_pre, r26
00180d 93a0 28c4                 	sts pulse2_fx_Sxx_post, r26
00180f 93a0 28fd                 	sts triangle_fx_Gxx_pre, r26
001811 93a0 28fe                 	sts triangle_fx_Gxx_post, r26
001813 93a0 290f                 	sts triangle_fx_Sxx_pre, r26
001815 93a0 2910                 	sts triangle_fx_Sxx_post, r26
001817 93a0 2943                 	sts noise_fx_Gxx_pre, r26
001819 93a0 2944                 	sts noise_fx_Gxx_post, r26
00181b 93a0 2946                 	sts noise_fx_Sxx_pre, r26
00181d 93a0 2947                 	sts noise_fx_Sxx_post, r26
                                 
00181f 93a0 2820                 	sts song_fx_Bxx, r26 //reset all song effects
001821 9220 2821                 	sts song_fx_Cxx, zero
001823 9220 2822                 	sts song_fx_Dxx, zero
001825 c000                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0:
001826 91a0 2825                 	lds r26, pulse1_pattern_delay_rows
001828 91b0 2826                 	lds r27, pulse1_pattern_delay_frames
00182a 9610                      	adiw r27:r26, 0
00182b f009                      	breq sound_driver_channel0_main //if the pattern delay is 0, proceed with sound driver procedures
00182c c2e4                      	rjmp sound_driver_channel0_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel0_main:
00182d 91e0 2823                 	lds ZL, pulse1_pattern //current pattern for pulse 1
00182f 91f0 2824                 	lds ZH, pulse1_pattern+1
001831 91a0 2827                 	lds r26, pulse1_pattern_offset //current offset in the pattern for pulse 1
001833 91b0 2828                 	lds r27, pulse1_pattern_offset+1
001835 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001836 1ffb                      	adc ZH, r27
001837 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel0_check_if_note: //check if data is a note (0x00 - 0x56)
001838 35b7                      	cpi r27, 0x57
001839 f408                      	brsh sound_driver_channel0_check_if_volume
00183a c17c                      	rjmp sound_driver_channel0_note
                                 sound_driver_channel0_check_if_volume: //check if data is volume (0x57-0x66)
00183b 36b7                      	cpi r27, 0x67
00183c f408                      	brsh sound_driver_channel0_check_if_delay
00183d c1ba                      	rjmp sound_driver_channel0_volume
                                 sound_driver_channel0_check_if_delay: //check if data is a delay (0x67 - 0xE2)
00183e 3eb3                      	cpi r27, 0xE3
00183f f408                      	brsh sound_driver_channel0_check_if_instrument
001840 c1c1                      	rjmp sound_driver_channel0_delay
                                 sound_driver_channel0_check_if_instrument: //check for instrument flag (0xE3)
001841 f409                      	brne sound_driver_channel0_check_if_release
001842 c1c4                      	rjmp sound_driver_channel0_instrument_change 
                                 sound_driver_channel0_check_if_release: //check for note release flag (0xE4)
001843 3eb4                      	cpi r27, 0xE4
001844 f409                      	brne sound_driver_channel0_check_if_end
001845 c26d                      	rjmp sound_driver_channel0_release
                                 sound_driver_channel0_check_if_end:
001846 3fbf                      	cpi r27, 0xFF
001847 f409                      	brne sound_driver_channel0_check_if_fx
001848 c28f                      	rjmp sound_driver_channel0_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel0_check_if_fx: //fx flags (0xE5 - 0xFE)
001849 9631                      	adiw Z, 1 //point Z to the byte next to the flag
00184a 91a4                      	lpm r26, Z //load the fx data into r26
00184b d2bb                      	rcall sound_driver_channel0_increment_offset_twice
                                 
00184c 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
00184d ebea                      	ldi ZL, LOW(channel0_fx << 1) //load in note table
00184e e6f0                      	ldi ZH, HIGH(channel0_fx << 1)
00184f 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001850 0feb                      	add ZL, r27 //add offset
001851 1df2                      	adc ZH, zero
001852 91c5                      	lpm r28, Z+ //load address bytes
001853 91d4                      	lpm r29, Z
001854 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001855 2ffd                      	mov ZH, r29
001856 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel0_fx_0xy:
001857 93a0 2846                 	sts pulse1_fx_0xy_sequence, r26
001859 9220 2847                 	sts pulse1_fx_0xy_sequence+1, zero
00185b cfd1                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel0_fx_1xx:
00185c 9220 284c                 	sts pulse1_fx_2xx, zero //turn off any 2xx pitch slide down
00185e 9220 284d                 	sts pulse1_fx_2xx+1, zero
001860 9220 2846                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
001862 9220 2847                 	sts pulse1_fx_0xy_sequence+1, zero
001864 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001865 937f                      	push r23
001866 2f6a                      	mov r22, r26 //store the rate into r22
001867 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001868 9f67                      	mul r22, r23
001869 917f                      	pop r23
00186a 916f                      	pop r22
                                 
00186b 9416                      	lsr r1 //shift out the fractional bits
00186c 9407                      	ror r0
00186d 9416                      	lsr r1
00186e 9407                      	ror r0
00186f 9416                      	lsr r1
001870 9407                      	ror r0
001871 9416                      	lsr r1
001872 9407                      	ror r0
001873 9200 2848                 	sts pulse1_fx_1xx, r0
001875 9210 2849                 	sts pulse1_fx_1xx+1, r1
001877 cfb5                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel0_fx_2xx:
001878 9220 2848                 	sts pulse1_fx_1xx, zero //turn off any 1xx pitch slide down
00187a 9220 2849                 	sts pulse1_fx_1xx+1, zero
00187c 9220 2846                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
00187e 9220 2847                 	sts pulse1_fx_0xy_sequence+1, zero
001880 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001881 937f                      	push r23
001882 2f6a                      	mov r22, r26 //store the rate into r22
001883 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001884 9f67                      	mul r22, r23
001885 917f                      	pop r23
001886 916f                      	pop r22
                                 
001887 9416                      	lsr r1 //shift out the fractional bits
001888 9407                      	ror r0
001889 9416                      	lsr r1
00188a 9407                      	ror r0
00188b 9416                      	lsr r1
00188c 9407                      	ror r0
00188d 9416                      	lsr r1
00188e 9407                      	ror r0
00188f 9200 284c                 	sts pulse1_fx_2xx, r0
001891 9210 284d                 	sts pulse1_fx_2xx+1, r1
001893 cf99                      	rjmp sound_driver_channel0_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel0_fx_3xx:
001894 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001895 937f                      	push r23
001896 2f6a                      	mov r22, r26 //store the rate into r22
001897 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001898 9f67                      	mul r22, r23
001899 917f                      	pop r23
00189a 916f                      	pop r22
                                 
00189b 9416                      	lsr r1 //shift out the fractional bits
00189c 9407                      	ror r0
00189d 9416                      	lsr r1
00189e 9407                      	ror r0
00189f 9416                      	lsr r1
0018a0 9407                      	ror r0
0018a1 9416                      	lsr r1
0018a2 9407                      	ror r0
0018a3 9200 2854                 	sts pulse1_fx_3xx_speed, r0
0018a5 9210 2855                 	sts pulse1_fx_3xx_speed+1, r1
                                 
0018a7 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
0018a8 c001                      	rjmp sound_driver_channel0_fx_3xx_enabled
0018a9 cf83                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_3xx_enabled:
0018aa 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
0018ac 91b0 0a8d                 	lds r27, TCB0_CCMPH
0018ae 93a0 2850                 	sts pulse1_fx_3xx_start, r26
0018b0 93b0 2851                 	sts pulse1_fx_3xx_start+1, r27
                                 
0018b2 9220 2856                 	sts pulse1_fx_3xx_total_offset, zero
0018b4 9220 2857                 	sts pulse1_fx_3xx_total_offset+1, zero
0018b6 cf76                      	rjmp sound_driver_channel0_main
                                 
                                 //VIBRATO
                                 sound_driver_channel0_fx_4xy:
0018b7 2fba                      	mov r27, r26
0018b8 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
0018b9 95a2                      	swap r26
0018ba 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0018bb 93a0 2858                 	sts pulse1_fx_4xy_speed, r26
0018bd 93b0 2859                 	sts pulse1_fx_4xy_depth, r27
0018bf 9220 285a                 	sts pulse1_fx_4xy_phase, zero //reset the phase to 0
0018c1 cf6b                      	rjmp sound_driver_channel0_main
                                 
                                 //TREMELO
                                 sound_driver_channel0_fx_7xy:
0018c2 2fba                      	mov r27, r26
0018c3 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
0018c4 95a2                      	swap r26
0018c5 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0018c6 93a0 285b                 	sts pulse1_fx_7xy_speed, r26
0018c8 93b0 285c                 	sts pulse1_fx_7xy_depth, r27
0018ca 9220 285d                 	sts pulse1_fx_7xy_phase, zero //reset the phase to 0
0018cc 9220 285e                 	sts pulse1_fx_7xy_value, zero //reset the tremelo value
0018ce cf5e                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel0_fx_Axy:
0018cf 93a0 285f                 	sts pulse1_fx_Axy, r26
0018d1 cf5b                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel0_fx_Bxx:
0018d2 93a0 2820                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
0018d4 cf58                      	rjmp sound_driver_channel0_main
                                 
                                 //HALT
                                 sound_driver_channel0_fx_Cxx:
0018d5 93b0 2821                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
0018d7 cf55                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel0_fx_Dxx:
0018d8 93b0 2822                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
0018da cf52                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME
                                 sound_driver_channel0_fx_Exx:
0018db 91b0 2800                 	lds r27, pulse1_param
0018dd 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
0018de 2bba                      	or r27, r26 //move new VVVV bits into pulse1_param
0018df 93b0 2800                 	sts pulse1_param, r27
0018e1 6096                      	sbr pulse_channel_flags, 6
0018e2 cf4a                      	rjmp sound_driver_channel0_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel0_fx_Fxx:
0018e3 93a0 281f                 	sts song_speed, r26 //NOTE: only changes to speed are supported
0018e5 cf47                      	rjmp sound_driver_channel0_main
                                 
                                 //DELAY
                                 sound_driver_channel0_fx_Gxx:
0018e6 15a2                      	cp r26, zero
0018e7 f051                      	breq sound_driver_channel0_fx_Gxx_invalid
0018e8 91b0 281f                 	lds r27, song_speed
0018ea 17ab                      	cp r26, r27
0018eb f430                      	brsh sound_driver_channel0_fx_Gxx_invalid
0018ec 93a0 2860                 	sts pulse1_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
0018ee e0b1                      	ldi r27, 0x01
0018ef 93b0 2825                 	sts pulse1_pattern_delay_rows, r27
0018f1 c222                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Gxx_invalid:
0018f2 cf3a                      	rjmp sound_driver_channel0_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel0_fx_Hxy: //hardware sweep up
0018f3 cf39                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixy: //hardware sweep down
0018f4 cf38                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Hxx: //FDS modulation depth
0018f5 cf37                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixx: //FDS modulation speed
0018f6 cf36                      	rjmp sound_driver_channel0_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel0_fx_Pxx:
0018f7 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0018f8 937f                      	push r23
0018f9 2f6a                      	mov r22, r26
0018fa eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0018fb 0367                      	mulsu r22, r23
0018fc 917f                      	pop r23
0018fd 916f                      	pop r22
0018fe 9416                      	lsr r1 //shift out the fractional bits
0018ff 9407                      	ror r0
001900 9416                      	lsr r1
001901 9407                      	ror r0
001902 9416                      	lsr r1
001903 9407                      	ror r0
001904 9416                      	lsr r1
001905 9407                      	ror r0
001906 fe13                      	sbrs r1, 3 //check if result was a negative number
001907 c002                      	rjmp sound_driver_channel0_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel0_fx_Pxx_negative:
001908 efb0                      	ldi r27, 0xF0
001909 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel0_fx_Pxx_store:
00190a 9200 2862                 	sts pulse1_fx_Pxx_total, r0
00190c 9210 2863                 	sts pulse1_fx_Pxx_total+1, r1
00190e cf1e                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel0_fx_Qxy:
                                 sound_driver_channel0_fx_Qxy_check_arpeggio_macro:
00190f 91e0 282e                 	lds ZL, pulse1_arpeggio_macro
001911 91f0 282f                 	lds ZH, pulse1_arpeggio_macro+1
001913 9630                      	adiw Z, 0
001914 f009                      	breq sound_driver_channel0_fx_Qxy_check_pitch_macro
001915 cf17                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_pitch_macro:
001916 91e0 2836                 	lds ZL, pulse1_pitch_macro
001918 91f0 2837                 	lds ZH, pulse1_pitch_macro+1
00191a 9630                      	adiw Z, 0
00191b f009                      	breq sound_driver_channel0_fx_Qxy_check_hi_pitch_macro
00191c cf10                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_hi_pitch_macro:
00191d 91e0 283c                 	lds ZL, pulse1_hi_pitch_macro
00191f 91f0 283d                 	lds ZH, pulse1_hi_pitch_macro+1
001921 9630                      	adiw Z, 0
001922 f009                      	breq sound_driver_channel0_fx_Qxy_process
001923 cf09                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_process:
001924 2fba                      	mov r27, r26 //copy fx parameters into r27
001925 70bf                      	andi r27, 0x0F //mask note index offset
001926 91c0 2864                 	lds r28, pulse1_fx_Qxy_target_note //load current note index
001928 0fbc                      	add r27, r28
001929 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
00192a f008                      	brlo sound_driver_channel0_fx_Qxy_process_continue
00192b e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel0_fx_Qxy_process_continue:
00192c 93b0 2864                 	sts pulse1_fx_Qxy_target_note, r27
00192e e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
00192f e0f0                      	ldi ZH, HIGH(note_table << 1)
001930 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001931 0feb                      	add ZL, r27 //add offset
001932 1df2                      	adc ZH, zero
001933 91c5                      	lpm r28, Z+ //load bytes
001934 91d4                      	lpm r29, Z
001935 93c0 2865                 	sts pulse1_fx_Qxy_target, r28 //load the LOW bits for the target period
001937 93d0 2866                 	sts pulse1_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel0_fx_Qxy_process_speed:
001939 95a2                      	swap r26
00193a 70af                      	andi r26, 0x0F //mask effect speed
00193b 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
00193c 95a3                      	inc r26 //increment the speed by 1
                                 
00193d 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00193e 937f                      	push r23
00193f 2f6a                      	mov r22, r26 //store the speed data into r27
001940 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001941 9f67                      	mul r22, r23
001942 917f                      	pop r23
001943 916f                      	pop r22
                                 
001944 9416                      	lsr r1 //shift out the fractional bits
001945 9407                      	ror r0
001946 9416                      	lsr r1
001947 9407                      	ror r0
001948 9416                      	lsr r1
001949 9407                      	ror r0
00194a 9416                      	lsr r1
00194b 9407                      	ror r0
                                 
00194c 9200 2867                 	sts pulse1_fx_Qxy_speed, r0 //store the effect speed
00194e 9210 2868                 	sts pulse1_fx_Qxy_speed+1, r1
001950 cedc                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel0_fx_Rxy:
                                 sound_driver_channel0_fx_Rxy_check_arpeggio_macro:
001951 91e0 282e                 	lds ZL, pulse1_arpeggio_macro
001953 91f0 282f                 	lds ZH, pulse1_arpeggio_macro+1
001955 9630                      	adiw Z, 0
001956 f009                      	breq sound_driver_channel0_fx_Rxy_check_pitch_macro
001957 ced5                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_pitch_macro:
001958 91e0 2836                 	lds ZL, pulse1_pitch_macro
00195a 91f0 2837                 	lds ZH, pulse1_pitch_macro+1
00195c 9630                      	adiw Z, 0
00195d f009                      	breq sound_driver_channel0_fx_Rxy_check_hi_pitch_macro
00195e cece                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_hi_pitch_macro:
00195f 91e0 283c                 	lds ZL, pulse1_hi_pitch_macro
001961 91f0 283d                 	lds ZH, pulse1_hi_pitch_macro+1
001963 9630                      	adiw Z, 0
001964 f009                      	breq sound_driver_channel0_fx_Rxy_process
001965 cec7                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_process:
001966 2fba                      	mov r27, r26 //copy fx parameters into r27
001967 70bf                      	andi r27, 0x0F //mask note index offset
001968 91c0 286b                 	lds r28, pulse1_fx_Rxy_target_note //load current note index
00196a 1bcb                      	sub r28, r27
00196b f408                      	brcc sound_driver_channel0_fx_Rxy_process_continue
00196c e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel0_fx_Rxy_process_continue:
00196d 93c0 286b                 	sts pulse1_fx_Rxy_target_note, r28
00196f e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001970 e0f0                      	ldi ZH, HIGH(note_table << 1)
001971 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001972 0fec                      	add ZL, r28 //add offset
001973 1df2                      	adc ZH, zero
001974 91c5                      	lpm r28, Z+ //load bytes
001975 91d4                      	lpm r29, Z
001976 93c0 286c                 	sts pulse1_fx_Rxy_target, r28 //load the LOW bits for the target period
001978 93d0 286d                 	sts pulse1_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel0_fx_Rxy_process_speed:
00197a 95a2                      	swap r26
00197b 70af                      	andi r26, 0x0F //mask effect speed
00197c 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
00197d 95a3                      	inc r26 //increment the speed by 1
                                 
00197e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00197f 937f                      	push r23
001980 2f6a                      	mov r22, r26 //store the speed data into r27
001981 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001982 9f67                      	mul r22, r23
001983 917f                      	pop r23
001984 916f                      	pop r22
                                 
001985 9416                      	lsr r1 //shift out the fractional bits
001986 9407                      	ror r0
001987 9416                      	lsr r1
001988 9407                      	ror r0
001989 9416                      	lsr r1
00198a 9407                      	ror r0
00198b 9416                      	lsr r1
00198c 9407                      	ror r0
                                 
00198d 9200 286e                 	sts pulse1_fx_Rxy_speed, r0 //store the effect speed
00198f 9210 286f                 	sts pulse1_fx_Rxy_speed+1, r1
001991 ce9b                      	rjmp sound_driver_channel0_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel0_fx_Sxx:
001992 15a2                      	cp r26, zero
001993 f051                      	breq sound_driver_channel0_fx_Sxx_invalid
001994 91b0 281f                 	lds r27, song_speed
001996 17ab                      	cp r26, r27
001997 f430                      	brsh sound_driver_channel0_fx_Sxx_invalid
001998 93a0 2872                 	sts pulse1_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
00199a e0b1                      	ldi r27, 0x01
00199b 93b0 2825                 	sts pulse1_pattern_delay_rows, r27
00199d c176                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Sxx_invalid:
00199e ce8e                      	rjmp sound_driver_channel0_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel0_fx_Vxx:
00199f ebe6                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
0019a0 e6f0                      	ldi ZH, HIGH(sequences << 1)
0019a1 0fea                      	add ZL, r26 //offset the pointer
0019a2 1df2                      	adc ZH, zero
                                 
0019a3 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
0019a4 95a7                      	ror r26
0019a5 95a7                      	ror r26
0019a6 91b0 2800                 	lds r27, pulse1_param //load r27 with pulse1_param (register $4000)
0019a8 2fcb                      	mov r28, r27 //store a copy of pulse1_param into r28
0019a9 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
0019aa 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
0019ab c001                      	rjmp sound_driver_channel0_fx_Vxx_store
0019ac ce80                      	rjmp sound_driver_channel0_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel0_fx_Vxx_store:
0019ad 9074                      	lpm pulse1_sequence, Z //store the sequence
                                 
0019ae 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
0019af 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
0019b0 93c0 2800                 	sts pulse1_param, r28
0019b2 ce7a                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_Wxx: //DPCM sample speed
0019b3 ce79                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Xxx: //DPCM sample retrigger
0019b4 ce78                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Yxx: //DPCM sample offset
0019b5 ce77                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Zxx: //DPCM sample delta counter
0019b6 ce76                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 sound_driver_channel0_note:
0019b7 93b0 2807                 	sts pulse1_note, r27 //store the note index
0019b9 93b0 2864                 	sts pulse1_fx_Qxy_target_note, r27
0019bb 93b0 286b                 	sts pulse1_fx_Rxy_target_note, r27
0019bd e0a3                      	ldi r26, 0x03
0019be e0b2                      	ldi r27, 0x02
0019bf 93b0 282b                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
0019c1 93a0 2830                 	sts pulse1_arpeggio_macro_offset, r26
0019c3 93b0 2838                 	sts pulse1_pitch_macro_offset, r27
0019c5 93b0 283e                 	sts pulse1_hi_pitch_macro_offset, r27
0019c7 93b0 2843                 	sts pulse1_duty_macro_offset, r27
0019c9 9220 2834                 	sts pulse1_total_pitch_offset, zero //reset the pitch and hi pitch offset
0019cb 9220 2835                 	sts pulse1_total_pitch_offset+1, zero
0019cd 9220 283b                 	sts pulse1_total_hi_pitch_offset, zero
0019cf 9220 284a                 	sts pulse1_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
0019d1 9220 284b                 	sts pulse1_fx_1xx_total+1, zero
0019d3 9220 284e                 	sts pulse1_fx_2xx_total, zero
0019d5 9220 284f                 	sts pulse1_fx_2xx_total+1, zero
0019d7 9220 2856                 	sts pulse1_fx_3xx_total_offset, zero //reset 3xx offset
0019d9 9220 2857                 	sts pulse1_fx_3xx_total_offset+1, zero
0019db 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
0019dd 91b0 0a8d                 	lds r27, TCB0_CCMPH
0019df 93a0 2850                 	sts pulse1_fx_3xx_start, r26
0019e1 93b0 2851                 	sts pulse1_fx_3xx_start+1, r27
0019e3 9220 2801                 	sts pulse1_sweep_param, zero //reset any sweep effect
0019e5 6097                      	sbr pulse_channel_flags, 7 //set reload flag
0019e6 9220 2865                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0019e8 9220 2866                 	sts pulse1_fx_Qxy_target+1, zero
0019ea 9220 2869                 	sts pulse1_fx_Qxy_total_offset, zero
0019ec 9220 286a                 	sts pulse1_fx_Qxy_total_offset+1, zero
0019ee 9220 286c                 	sts pulse1_fx_Rxy_target, zero
0019f0 9220 286d                 	sts pulse1_fx_Rxy_target+1, zero
0019f2 9220 2870                 	sts pulse1_fx_Rxy_total_offset, zero
0019f4 9220 2871                 	sts pulse1_fx_Rxy_total_offset+1, zero
0019f6 d106                      	rcall sound_driver_channel0_increment_offset
0019f7 ce35                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_volume:
0019f8 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
0019f9 91a0 2800                 	lds r26, pulse1_param
0019fb 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
0019fc 2bab                      	or r26, r27 //move new VVVV bits into pulse1_param
0019fd 93a0 2800                 	sts pulse1_param, r26
0019ff 6096                      	sbr pulse_channel_flags, 6
001a00 d0fc                      	rcall sound_driver_channel0_increment_offset
001a01 ce2b                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_delay:
001a02 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001a03 93b0 2825                 	sts pulse1_pattern_delay_rows, r27
001a05 d0f7                      	rcall sound_driver_channel0_increment_offset
001a06 c10d                      	rjmp sound_driver_channel1
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change:
001a07 9220 2829                 	sts pulse1_volume_macro, zero //reset all macro addresses
001a09 9220 282a                 	sts pulse1_volume_macro+1, zero
001a0b 9220 282e                 	sts pulse1_arpeggio_macro, zero
001a0d 9220 282f                 	sts pulse1_arpeggio_macro+1, zero
001a0f 9220 2836                 	sts pulse1_pitch_macro, zero
001a11 9220 2837                 	sts pulse1_pitch_macro+1, zero
001a13 9220 283c                 	sts pulse1_hi_pitch_macro, zero
001a15 9220 283d                 	sts pulse1_hi_pitch_macro+1, zero
001a17 9220 2841                 	sts pulse1_duty_macro, zero
001a19 9220 2842                 	sts pulse1_duty_macro+1, zero
001a1b 9220 2834                 	sts pulse1_total_pitch_offset, zero //reset the pitch offset
001a1d 9220 2835                 	sts pulse1_total_pitch_offset+1, zero
001a1f 9220 283b                 	sts pulse1_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001a21 9631                      	adiw Z, 1 //point to the byte next to the flag
001a22 91b4                      	lpm r27, Z //store the instrument offset into r27
001a23 e9ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
001a24 e1f1                      	ldi ZH, HIGH(instruments)
001a25 0feb                      	add ZL, r27 //point Z to offsetted instrument
001a26 1df2                      	adc ZH, zero
001a27 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001a28 1fff                      	rol ZH
001a29 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001a2a 91b4                      	lpm r27, Z
                                 
001a2b 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001a2c 1fbb                      	rol r27
001a2d 2fea                      	mov ZL, r26
001a2e 2ffb                      	mov ZH, r27
001a2f 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001a30 9632                      	adiw Z, 2 //point Z to the address of the macro
001a31 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel0_instrument_change_macro_loop:
001a32 95aa                      	dec r26
001a33 f019                      	breq sound_driver_channel0_instrument_change_exit
001a34 95b6                      	lsr r27
001a35 f078                      	brcs sound_driver_channel0_instrument_change_load_macro
001a36 cffb                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_exit:
001a37 e0a3                      	ldi r26, 0x03
001a38 e0b2                      	ldi r27, 0x02
001a39 93b0 282b                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
001a3b 93a0 2830                 	sts pulse1_arpeggio_macro_offset, r26
001a3d 93b0 2838                 	sts pulse1_pitch_macro_offset, r27
001a3f 93b0 283e                 	sts pulse1_hi_pitch_macro_offset, r27
001a41 93b0 2843                 	sts pulse1_duty_macro_offset, r27
001a43 d0c3                      	rcall sound_driver_channel0_increment_offset_twice
001a44 cde8                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_load_macro:
001a45 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001a46 91d5                      	lpm r29, Z+
                                 
001a47 30a5                      	cpi r26, 5
001a48 f039                      	breq sound_driver_channel0_instrument_change_load_macro_volume
001a49 30a4                      	cpi r26, 4
001a4a f079                      	breq sound_driver_channel0_instrument_change_load_macro_arpeggio
001a4b 30a3                      	cpi r26, 3
001a4c f0d9                      	breq sound_driver_channel0_instrument_change_load_macro_pitch
001a4d 30a2                      	cpi r26, 2
001a4e f159                      	breq sound_driver_channel0_instrument_change_load_macro_hi_pitch
001a4f c03c                      	rjmp sound_driver_channel0_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel0_instrument_change_load_macro_volume:
001a50 93c0 2829                 	sts pulse1_volume_macro, r28
001a52 93d0 282a                 	sts pulse1_volume_macro+1, r29
001a54 d041                      	rcall sound_driver_channel0_instrument_change_read_header
001a55 93c0 282d                 	sts pulse1_volume_macro_release, r28
001a57 93d0 282c                 	sts pulse1_volume_macro_loop, r29
001a59 cfd8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 	
                                 sound_driver_channel0_instrument_change_load_macro_arpeggio:
001a5a 93c0 282e                 	sts pulse1_arpeggio_macro, r28
001a5c 93d0 282f                 	sts pulse1_arpeggio_macro+1, r29
001a5e 9220 2865                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001a60 9220 2866                 	sts pulse1_fx_Qxy_target+1, zero
001a62 9220 286c                 	sts pulse1_fx_Rxy_target, zero
001a64 9220 286d                 	sts pulse1_fx_Rxy_target+1, zero
001a66 d03a                      	rcall sound_driver_channel0_instrument_change_read_header_arpeggio
001a67 cfca                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_pitch:
001a68 93c0 2836                 	sts pulse1_pitch_macro, r28
001a6a 93d0 2837                 	sts pulse1_pitch_macro+1, r29
001a6c 9220 2865                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001a6e 9220 2866                 	sts pulse1_fx_Qxy_target+1, zero
001a70 9220 286c                 	sts pulse1_fx_Rxy_target, zero
001a72 9220 286d                 	sts pulse1_fx_Rxy_target+1, zero
001a74 d021                      	rcall sound_driver_channel0_instrument_change_read_header
001a75 93c0 283a                 	sts pulse1_pitch_macro_release, r28
001a77 93d0 2839                 	sts pulse1_pitch_macro_loop, r29
001a79 cfb8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_hi_pitch:
001a7a 93c0 283c                 	sts pulse1_hi_pitch_macro, r28
001a7c 93d0 283d                 	sts pulse1_hi_pitch_macro+1, r29
001a7e 9220 2865                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001a80 9220 2866                 	sts pulse1_fx_Qxy_target+1, zero
001a82 9220 286c                 	sts pulse1_fx_Rxy_target, zero
001a84 9220 286d                 	sts pulse1_fx_Rxy_target+1, zero
001a86 d00f                      	rcall sound_driver_channel0_instrument_change_read_header
001a87 93c0 2840                 	sts pulse1_hi_pitch_macro_release, r28
001a89 93d0 283f                 	sts pulse1_hi_pitch_macro_loop, r29
001a8b cfa6                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_duty:
001a8c 93c0 2841                 	sts pulse1_duty_macro, r28
001a8e 93d0 2842                 	sts pulse1_duty_macro+1, r29
001a90 d005                      	rcall sound_driver_channel0_instrument_change_read_header
001a91 93c0 2845                 	sts pulse1_duty_macro_release, r28
001a93 93d0 2844                 	sts pulse1_duty_macro_loop, r29
001a95 cf9c                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_read_header:
001a96 93ef                      	push ZL
001a97 93ff                      	push ZH
001a98 2fec                      	mov ZL, r28
001a99 2ffd                      	mov ZH, r29
001a9a 0fee                      	lsl ZL
001a9b 1fff                      	rol ZH
001a9c 91c5                      	lpm r28, Z+
001a9d 91d4                      	lpm r29, Z
001a9e 91ff                      	pop ZH
001a9f 91ef                      	pop ZL
001aa0 9508                      	ret
                                 
                                 sound_driver_channel0_instrument_change_read_header_arpeggio:
001aa1 93ef                      	push ZL
001aa2 93ff                      	push ZH
001aa3 2fec                      	mov ZL, r28
001aa4 2ffd                      	mov ZH, r29
001aa5 0fee                      	lsl ZL
001aa6 1fff                      	rol ZH
001aa7 91c5                      	lpm r28, Z+
001aa8 91d5                      	lpm r29, Z+
001aa9 93c0 2832                 	sts pulse1_arpeggio_macro_release, r28
001aab 93d0 2831                 	sts pulse1_arpeggio_macro_loop, r29
001aad 91c4                      	lpm r28, Z
001aae 93c0 2833                 	sts pulse1_arpeggio_macro_mode, r28
001ab0 91ff                      	pop ZH
001ab1 91ef                      	pop ZL
001ab2 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel0_release:
                                 sound_driver_channel0_release_volume:
001ab3 91b0 282d                 	lds r27, pulse1_volume_macro_release
001ab5 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001ab6 f019                      	breq sound_driver_channel0_release_arpeggio //if the macro has no release flag, check the next macro
001ab7 95b3                      	inc r27
001ab8 93b0 282b                 	sts pulse1_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel0_release_arpeggio:
001aba 91b0 2832                 	lds r27, pulse1_arpeggio_macro_release
001abc 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001abd f019                      	breq sound_driver_channel0_release_pitch
001abe 95b3                      	inc r27
001abf 93b0 2830                 	sts pulse1_arpeggio_macro_offset, r27
                                 sound_driver_channel0_release_pitch:
001ac1 91b0 283a                 	lds r27, pulse1_pitch_macro_release
001ac3 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001ac4 f019                      	breq sound_driver_channel0_release_hi_pitch
001ac5 95b3                      	inc r27
001ac6 93b0 2838                 	sts pulse1_pitch_macro_offset, r27
                                 sound_driver_channel0_release_hi_pitch:
001ac8 91b0 2840                 	lds r27, pulse1_hi_pitch_macro_release
001aca 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001acb f019                      	breq sound_driver_channel0_release_duty
001acc 95b3                      	inc r27
001acd 93b0 283e                 	sts pulse1_hi_pitch_macro_offset, r27
                                 sound_driver_channel0_release_duty:
001acf 91b0 2845                 	lds r27, pulse1_duty_macro_release
001ad1 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001ad2 f019                      	breq sound_driver_channel0_release_exit
001ad3 95b3                      	inc r27
001ad4 93b0 2843                 	sts pulse1_duty_macro_offset, r27
                                 sound_driver_channel0_release_exit:
001ad6 d026                      	rcall sound_driver_channel0_increment_offset
001ad7 cd55                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_next_pattern:
001ad8 91e0 2819                 	lds ZL, song_frames
001ada 91f0 281a                 	lds ZH, song_frames+1
001adc 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001ade 91b0 281c                 	lds r27, song_frame_offset+1
001ae0 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
001ae1 93a0 281b                 	sts song_frame_offset, r26
001ae3 93b0 281c                 	sts song_frame_offset+1, r27
                                 
001ae5 91c0 281d                 	lds r28, song_size
001ae7 91d0 281e                 	lds r29, song_size+1
001ae9 17ac                      	cp r26, r28
001aea 07bd                      	cpc r27, r29
001aeb f010                      	brlo sound_driver_channel0_next_pattern_exists
001aec 940c 3045                 	jmp sound_driver_exit
                                 
                                 sound_driver_channel0_next_pattern_exists:
001aee 0fea                      	add ZL, r26
001aef 1ffb                      	adc ZH, r27
                                 
001af0 91a5                      	lpm r26, Z+ //load the address of the next pattern
001af1 91b4                      	lpm r27, Z
001af2 0faa                      	lsl r26
001af3 1fbb                      	rol r27
001af4 93a0 2823                 	sts pulse1_pattern, r26
001af6 93b0 2824                 	sts pulse1_pattern+1, r27
                                 
001af8 9220 2827                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001afa 9220 2828                 	sts pulse1_pattern_offset+1, zero
001afc cd30                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_increment_offset:
001afd 91e0 2827                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
001aff 91f0 2828                 	lds ZH, pulse1_pattern_offset+1
001b01 9631                      	adiw Z, 1
001b02 93e0 2827                 	sts pulse1_pattern_offset, ZL
001b04 93f0 2828                 	sts pulse1_pattern_offset+1, ZH
001b06 9508                      	ret
                                 
                                 sound_driver_channel0_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001b07 91e0 2827                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
001b09 91f0 2828                 	lds ZH, pulse1_pattern_offset+1
001b0b 9632                      	adiw Z, 2 //increment the pointer twice
001b0c 93e0 2827                 	sts pulse1_pattern_offset, ZL
001b0e 93f0 2828                 	sts pulse1_pattern_offset+1, ZH
001b10 9508                      	ret
                                 
                                 sound_driver_channel0_decrement_frame_delay:
001b11 95ba                      	dec r27
001b12 93b0 2826                 	sts pulse1_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel1:
001b14 91a0 2876                 	lds r26, pulse2_pattern_delay_rows
001b16 91b0 2877                 	lds r27, pulse2_pattern_delay_frames
001b18 9610                      	adiw r27:r26, 0
001b19 f009                      	breq sound_driver_channel1_main //if the pattern delay is 0, proceed with sound driver procedures
001b1a c2d7                      	rjmp sound_driver_channel1_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel1_main:
001b1b 91e0 2874                 	lds ZL, pulse2_pattern //current pattern for pulse 2
001b1d 91f0 2875                 	lds ZH, pulse2_pattern+1
001b1f 91a0 2878                 	lds r26, pulse2_pattern_offset //current offset in the pattern for pulse 2
001b21 91b0 2879                 	lds r27, pulse2_pattern_offset+1
001b23 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001b24 1ffb                      	adc ZH, r27
001b25 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel1_check_if_note: //check if data is a note (0x00 - 0x56)
001b26 35b7                      	cpi r27, 0x57
001b27 f408                      	brsh sound_driver_channel1_check_if_volume
001b28 c17c                      	rjmp sound_driver_channel1_note
                                 sound_driver_channel1_check_if_volume: //check if data is volume (0x57-0x66)
001b29 36b7                      	cpi r27, 0x67
001b2a f408                      	brsh sound_driver_channel1_check_if_delay
001b2b c1ba                      	rjmp sound_driver_channel1_volume
                                 sound_driver_channel1_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001b2c 3eb3                      	cpi r27, 0xE3
001b2d f408                      	brsh sound_driver_channel1_check_if_instrument
001b2e c1c1                      	rjmp sound_driver_channel1_delay
                                 sound_driver_channel1_check_if_instrument: //check for instrument flag (0xE3)
001b2f f409                      	brne sound_driver_channel1_check_if_release
001b30 c1c4                      	rjmp sound_driver_channel1_instrument_change 
                                 sound_driver_channel1_check_if_release: //check for note release flag (0xE4)
001b31 3eb4                      	cpi r27, 0xE4
001b32 f409                      	brne sound_driver_channel1_check_if_end
001b33 c26d                      	rjmp sound_driver_channel1_release
                                 sound_driver_channel1_check_if_end:
001b34 3fbf                      	cpi r27, 0xFF
001b35 f409                      	brne sound_driver_channel1_check_if_fx
001b36 c28f                      	rjmp sound_driver_channel1_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel1_check_if_fx: //fx flags (0xE5 - 0xFE)
001b37 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001b38 91a4                      	lpm r26, Z //load the fx data into r26
001b39 d2ae                      	rcall sound_driver_channel1_increment_offset_twice
                                 
001b3a 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001b3b eeee                      	ldi ZL, LOW(channel1_fx << 1) //load in note table
001b3c e6f0                      	ldi ZH, HIGH(channel1_fx << 1)
001b3d 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001b3e 0feb                      	add ZL, r27 //add offset
001b3f 1df2                      	adc ZH, zero
001b40 91c5                      	lpm r28, Z+ //load address bytes
001b41 91d4                      	lpm r29, Z
001b42 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001b43 2ffd                      	mov ZH, r29
001b44 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel1_fx_0xy:
001b45 93a0 2897                 	sts pulse2_fx_0xy_sequence, r26
001b47 9220 2898                 	sts pulse2_fx_0xy_sequence+1, zero
001b49 cfd1                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel1_fx_1xx:
001b4a 9220 289d                 	sts pulse2_fx_2xx, zero //turn off any 2xx pitch slide down
001b4c 9220 289e                 	sts pulse2_fx_2xx+1, zero
001b4e 9220 2897                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
001b50 9220 2898                 	sts pulse2_fx_0xy_sequence+1, zero
001b52 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001b53 937f                      	push r23
001b54 2f6a                      	mov r22, r26 //store the rate into r22
001b55 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001b56 9f67                      	mul r22, r23
001b57 917f                      	pop r23
001b58 916f                      	pop r22
                                 
001b59 9416                      	lsr r1 //shift out the fractional bits
001b5a 9407                      	ror r0
001b5b 9416                      	lsr r1
001b5c 9407                      	ror r0
001b5d 9416                      	lsr r1
001b5e 9407                      	ror r0
001b5f 9416                      	lsr r1
001b60 9407                      	ror r0
001b61 9200 2899                 	sts pulse2_fx_1xx, r0
001b63 9210 289a                 	sts pulse2_fx_1xx+1, r1
001b65 cfb5                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel1_fx_2xx:
001b66 9220 2899                 	sts pulse2_fx_1xx, zero //turn off any 1xx pitch slide down
001b68 9220 289a                 	sts pulse2_fx_1xx+1, zero
001b6a 9220 2897                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
001b6c 9220 2898                 	sts pulse2_fx_0xy_sequence+1, zero
001b6e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001b6f 937f                      	push r23
001b70 2f6a                      	mov r22, r26 //store the rate into r22
001b71 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001b72 9f67                      	mul r22, r23
001b73 917f                      	pop r23
001b74 916f                      	pop r22
                                 
001b75 9416                      	lsr r1 //shift out the fractional bits
001b76 9407                      	ror r0
001b77 9416                      	lsr r1
001b78 9407                      	ror r0
001b79 9416                      	lsr r1
001b7a 9407                      	ror r0
001b7b 9416                      	lsr r1
001b7c 9407                      	ror r0
001b7d 9200 289d                 	sts pulse2_fx_2xx, r0
001b7f 9210 289e                 	sts pulse2_fx_2xx+1, r1
001b81 cf99                      	rjmp sound_driver_channel1_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel1_fx_3xx:
001b82 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001b83 937f                      	push r23
001b84 2f6a                      	mov r22, r26 //store the rate into r22
001b85 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001b86 9f67                      	mul r22, r23
001b87 917f                      	pop r23
001b88 916f                      	pop r22
                                 
001b89 9416                      	lsr r1 //shift out the fractional bits
001b8a 9407                      	ror r0
001b8b 9416                      	lsr r1
001b8c 9407                      	ror r0
001b8d 9416                      	lsr r1
001b8e 9407                      	ror r0
001b8f 9416                      	lsr r1
001b90 9407                      	ror r0
001b91 9200 28a5                 	sts pulse2_fx_3xx_speed, r0
001b93 9210 28a6                 	sts pulse2_fx_3xx_speed+1, r1
                                 
001b95 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001b96 c001                      	rjmp sound_driver_channel1_fx_3xx_enabled
001b97 cf83                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_3xx_enabled:
001b98 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001b9a 91b0 0a9d                 	lds r27, TCB1_CCMPH
001b9c 93a0 28a1                 	sts pulse2_fx_3xx_start, r26
001b9e 93b0 28a2                 	sts pulse2_fx_3xx_start+1, r27
                                 
001ba0 9220 28a7                 	sts pulse2_fx_3xx_total_offset, zero
001ba2 9220 28a8                 	sts pulse2_fx_3xx_total_offset+1, zero
001ba4 cf76                      	rjmp sound_driver_channel1_main
                                 
                                 //VIBRATO
                                 sound_driver_channel1_fx_4xy:
001ba5 2fba                      	mov r27, r26
001ba6 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001ba7 95a2                      	swap r26
001ba8 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001ba9 93a0 28a9                 	sts pulse2_fx_4xy_speed, r26
001bab 93b0 28aa                 	sts pulse2_fx_4xy_depth, r27
001bad 9220 28ab                 	sts pulse2_fx_4xy_phase, zero //reset the phase to 0
001baf cf6b                      	rjmp sound_driver_channel1_main
                                 
                                 //TREMELO
                                 sound_driver_channel1_fx_7xy:
001bb0 2fba                      	mov r27, r26
001bb1 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001bb2 95a2                      	swap r26
001bb3 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001bb4 93a0 28ac                 	sts pulse2_fx_7xy_speed, r26
001bb6 93b0 28ad                 	sts pulse2_fx_7xy_depth, r27
001bb8 9220 28ae                 	sts pulse2_fx_7xy_phase, zero //reset the phase to 0
001bba 9220 28af                 	sts pulse2_fx_7xy_value, zero //reset the tremelo value
001bbc cf5e                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel1_fx_Axy:
001bbd 93a0 28b0                 	sts pulse2_fx_Axy, r26
001bbf cf5b                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel1_fx_Bxx:
001bc0 93a0 2820                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001bc2 cf58                      	rjmp sound_driver_channel1_main
                                 
                                 //HALT
                                 sound_driver_channel1_fx_Cxx:
001bc3 93b0 2821                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001bc5 cf55                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel1_fx_Dxx:
001bc6 93b0 2822                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001bc8 cf52                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME
                                 sound_driver_channel1_fx_Exx:
001bc9 91b0 2808                 	lds r27, pulse2_param
001bcb 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
001bcc 2bba                      	or r27, r26 //move new VVVV bits into pulse2_param
001bcd 93b0 2808                 	sts pulse2_param, r27
001bcf 6092                      	sbr pulse_channel_flags, 2
001bd0 cf4a                      	rjmp sound_driver_channel1_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel1_fx_Fxx:
001bd1 93a0 281f                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001bd3 cf47                      	rjmp sound_driver_channel1_main
                                 
                                 //DELAY
                                 sound_driver_channel1_fx_Gxx:
001bd4 15a2                      	cp r26, zero
001bd5 f051                      	breq sound_driver_channel1_fx_Gxx_invalid
001bd6 91b0 281f                 	lds r27, song_speed
001bd8 17ab                      	cp r26, r27
001bd9 f430                      	brsh sound_driver_channel1_fx_Gxx_invalid
001bda 93a0 28b1                 	sts pulse2_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001bdc e0b1                      	ldi r27, 0x01
001bdd 93b0 2876                 	sts pulse2_pattern_delay_rows, r27
001bdf c215                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Gxx_invalid:
001be0 cf3a                      	rjmp sound_driver_channel1_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel1_fx_Hxy: //hardware sweep up
001be1 cf39                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixy: //hardware sweep down
001be2 cf38                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Hxx: //FDS modulation depth
001be3 cf37                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixx: //FDS modulation speed
001be4 cf36                      	rjmp sound_driver_channel1_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel1_fx_Pxx:
001be5 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001be6 937f                      	push r23
001be7 2f6a                      	mov r22, r26
001be8 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001be9 0367                      	mulsu r22, r23
001bea 917f                      	pop r23
001beb 916f                      	pop r22
001bec 9416                      	lsr r1 //shift out the fractional bits
001bed 9407                      	ror r0
001bee 9416                      	lsr r1
001bef 9407                      	ror r0
001bf0 9416                      	lsr r1
001bf1 9407                      	ror r0
001bf2 9416                      	lsr r1
001bf3 9407                      	ror r0
001bf4 fe13                      	sbrs r1, 3 //check if result was a negative number
001bf5 c002                      	rjmp sound_driver_channel1_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel1_fx_Pxx_negative:
001bf6 efb0                      	ldi r27, 0xF0
001bf7 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel1_fx_Pxx_store:
001bf8 9200 28b3                 	sts pulse2_fx_Pxx_total, r0
001bfa 9210 28b4                 	sts pulse2_fx_Pxx_total+1, r1
001bfc cf1e                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel1_fx_Qxy:
                                 sound_driver_channel1_fx_Qxy_check_arpeggio_macro:
001bfd 91e0 287f                 	lds ZL, pulse2_arpeggio_macro
001bff 91f0 2880                 	lds ZH, pulse2_arpeggio_macro+1
001c01 9630                      	adiw Z, 0
001c02 f009                      	breq sound_driver_channel1_fx_Qxy_check_pitch_macro
001c03 cf17                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_pitch_macro:
001c04 91e0 2887                 	lds ZL, pulse2_pitch_macro
001c06 91f0 2888                 	lds ZH, pulse2_pitch_macro+1
001c08 9630                      	adiw Z, 0
001c09 f009                      	breq sound_driver_channel1_fx_Qxy_check_hi_pitch_macro
001c0a cf10                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_hi_pitch_macro:
001c0b 91e0 288d                 	lds ZL, pulse2_hi_pitch_macro
001c0d 91f0 288e                 	lds ZH, pulse2_hi_pitch_macro+1
001c0f 9630                      	adiw Z, 0
001c10 f009                      	breq sound_driver_channel1_fx_Qxy_process
001c11 cf09                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_process:
001c12 2fba                      	mov r27, r26 //copy fx parameters into r27
001c13 70bf                      	andi r27, 0x0F //mask note index offset
001c14 91c0 28b5                 	lds r28, pulse2_fx_Qxy_target_note //load current note index
001c16 0fbc                      	add r27, r28
001c17 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001c18 f008                      	brlo sound_driver_channel1_fx_Qxy_process_continue
001c19 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel1_fx_Qxy_process_continue:
001c1a 93b0 28b5                 	sts pulse2_fx_Qxy_target_note, r27
001c1c e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001c1d e0f0                      	ldi ZH, HIGH(note_table << 1)
001c1e 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001c1f 0feb                      	add ZL, r27 //add offset
001c20 1df2                      	adc ZH, zero
001c21 91c5                      	lpm r28, Z+ //load bytes
001c22 91d4                      	lpm r29, Z
001c23 93c0 28b6                 	sts pulse2_fx_Qxy_target, r28 //load the LOW bits for the target period
001c25 93d0 28b7                 	sts pulse2_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel1_fx_Qxy_process_speed:
001c27 95a2                      	swap r26
001c28 70af                      	andi r26, 0x0F //mask effect speed
001c29 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001c2a 95a3                      	inc r26 //increment the speed by 1
                                 
001c2b 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001c2c 937f                      	push r23
001c2d 2f6a                      	mov r22, r26 //store the speed data into r27
001c2e eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001c2f 9f67                      	mul r22, r23
001c30 917f                      	pop r23
001c31 916f                      	pop r22
                                 
001c32 9416                      	lsr r1 //shift out the fractional bits
001c33 9407                      	ror r0
001c34 9416                      	lsr r1
001c35 9407                      	ror r0
001c36 9416                      	lsr r1
001c37 9407                      	ror r0
001c38 9416                      	lsr r1
001c39 9407                      	ror r0
                                 
001c3a 9200 28b8                 	sts pulse2_fx_Qxy_speed, r0 //store the effect speed
001c3c 9210 28b9                 	sts pulse2_fx_Qxy_speed+1, r1
001c3e cedc                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel1_fx_Rxy:
                                 sound_driver_channel1_fx_Rxy_check_arpeggio_macro:
001c3f 91e0 287f                 	lds ZL, pulse2_arpeggio_macro
001c41 91f0 2880                 	lds ZH, pulse2_arpeggio_macro+1
001c43 9630                      	adiw Z, 0
001c44 f009                      	breq sound_driver_channel1_fx_Rxy_check_pitch_macro
001c45 ced5                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_pitch_macro:
001c46 91e0 2887                 	lds ZL, pulse2_pitch_macro
001c48 91f0 2888                 	lds ZH, pulse2_pitch_macro+1
001c4a 9630                      	adiw Z, 0
001c4b f009                      	breq sound_driver_channel1_fx_Rxy_check_hi_pitch_macro
001c4c cece                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_hi_pitch_macro:
001c4d 91e0 288d                 	lds ZL, pulse2_hi_pitch_macro
001c4f 91f0 288e                 	lds ZH, pulse2_hi_pitch_macro+1
001c51 9630                      	adiw Z, 0
001c52 f009                      	breq sound_driver_channel1_fx_Rxy_process
001c53 cec7                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_process:
001c54 2fba                      	mov r27, r26 //copy fx parameters into r27
001c55 70bf                      	andi r27, 0x0F //mask note index offset
001c56 91c0 28bc                 	lds r28, pulse2_fx_Rxy_target_note //load current note index
001c58 1bcb                      	sub r28, r27
001c59 f408                      	brcc sound_driver_channel1_fx_Rxy_process_continue
001c5a e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel1_fx_Rxy_process_continue:
001c5b 93c0 28bc                 	sts pulse2_fx_Rxy_target_note, r28
001c5d e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001c5e e0f0                      	ldi ZH, HIGH(note_table << 1)
001c5f 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001c60 0fec                      	add ZL, r28 //add offset
001c61 1df2                      	adc ZH, zero
001c62 91c5                      	lpm r28, Z+ //load bytes
001c63 91d4                      	lpm r29, Z
001c64 93c0 28bd                 	sts pulse2_fx_Rxy_target, r28 //load the LOW bits for the target period
001c66 93d0 28be                 	sts pulse2_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel1_fx_Rxy_process_speed:
001c68 95a2                      	swap r26
001c69 70af                      	andi r26, 0x0F //mask effect speed
001c6a 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001c6b 95a3                      	inc r26 //increment the speed by 1
                                 
001c6c 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001c6d 937f                      	push r23
001c6e 2f6a                      	mov r22, r26 //store the speed data into r27
001c6f eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001c70 9f67                      	mul r22, r23
001c71 917f                      	pop r23
001c72 916f                      	pop r22
                                 
001c73 9416                      	lsr r1 //shift out the fractional bits
001c74 9407                      	ror r0
001c75 9416                      	lsr r1
001c76 9407                      	ror r0
001c77 9416                      	lsr r1
001c78 9407                      	ror r0
001c79 9416                      	lsr r1
001c7a 9407                      	ror r0
                                 
001c7b 9200 28bf                 	sts pulse2_fx_Rxy_speed, r0 //store the effect speed
001c7d 9210 28c0                 	sts pulse2_fx_Rxy_speed+1, r1
001c7f ce9b                      	rjmp sound_driver_channel1_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel1_fx_Sxx:
001c80 15a2                      	cp r26, zero
001c81 f051                      	breq sound_driver_channel1_fx_Sxx_invalid
001c82 91b0 281f                 	lds r27, song_speed
001c84 17ab                      	cp r26, r27
001c85 f430                      	brsh sound_driver_channel1_fx_Sxx_invalid
001c86 93a0 28c3                 	sts pulse2_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001c88 e0b1                      	ldi r27, 0x01
001c89 93b0 2876                 	sts pulse2_pattern_delay_rows, r27
001c8b c169                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Sxx_invalid:
001c8c ce8e                      	rjmp sound_driver_channel1_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel1_fx_Vxx:
001c8d ebe6                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
001c8e e6f0                      	ldi ZH, HIGH(sequences << 1)
001c8f 0fea                      	add ZL, r26 //offset the pointer
001c90 1df2                      	adc ZH, zero
                                 
001c91 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
001c92 95a7                      	ror r26
001c93 95a7                      	ror r26
001c94 91b0 2808                 	lds r27, pulse2_param //load r27 with pulse2_param (register $4000)
001c96 2fcb                      	mov r28, r27 //store a copy of pulse2_param into r28
001c97 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
001c98 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
001c99 c001                      	rjmp sound_driver_channel1_fx_Vxx_store
001c9a ce80                      	rjmp sound_driver_channel1_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel1_fx_Vxx_store:
001c9b 90a4                      	lpm pulse2_sequence, Z //store the sequence
                                 
001c9c 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
001c9d 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
001c9e 93c0 2808                 	sts pulse2_param, r28
001ca0 ce7a                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_Wxx: //DPCM sample speed
001ca1 ce79                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Xxx: //DPCM sample retrigger
001ca2 ce78                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Yxx: //DPCM sample offset
001ca3 ce77                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Zxx: //DPCM sample delta counter
001ca4 ce76                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 sound_driver_channel1_note:
001ca5 93b0 280f                 	sts pulse2_note, r27 //store the note index
001ca7 93b0 28b5                 	sts pulse2_fx_Qxy_target_note, r27
001ca9 93b0 28bc                 	sts pulse2_fx_Rxy_target_note, r27
001cab e0a3                      	ldi r26, 0x03
001cac e0b2                      	ldi r27, 0x02
001cad 93b0 287c                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
001caf 93a0 2881                 	sts pulse2_arpeggio_macro_offset, r26
001cb1 93b0 2889                 	sts pulse2_pitch_macro_offset, r27
001cb3 93b0 288f                 	sts pulse2_hi_pitch_macro_offset, r27
001cb5 93b0 2894                 	sts pulse2_duty_macro_offset, r27
001cb7 9220 2885                 	sts pulse2_total_pitch_offset, zero //reset the pitch and hi pitch offset
001cb9 9220 2886                 	sts pulse2_total_pitch_offset+1, zero
001cbb 9220 288c                 	sts pulse2_total_hi_pitch_offset, zero
001cbd 9220 289b                 	sts pulse2_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001cbf 9220 289c                 	sts pulse2_fx_1xx_total+1, zero
001cc1 9220 289f                 	sts pulse2_fx_2xx_total, zero
001cc3 9220 28a0                 	sts pulse2_fx_2xx_total+1, zero
001cc5 9220 28a7                 	sts pulse2_fx_3xx_total_offset, zero //reset 3xx offset
001cc7 9220 28a8                 	sts pulse2_fx_3xx_total_offset+1, zero
001cc9 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001ccb 91b0 0a9d                 	lds r27, TCB1_CCMPH
001ccd 93a0 28a1                 	sts pulse2_fx_3xx_start, r26
001ccf 93b0 28a2                 	sts pulse2_fx_3xx_start+1, r27
001cd1 9220 2809                 	sts pulse2_sweep_param, zero //reset any sweep effect
001cd3 6093                      	sbr pulse_channel_flags, 3 //set reload flag
001cd4 9220 28b6                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001cd6 9220 28b7                 	sts pulse2_fx_Qxy_target+1, zero
001cd8 9220 28ba                 	sts pulse2_fx_Qxy_total_offset, zero
001cda 9220 28bb                 	sts pulse2_fx_Qxy_total_offset+1, zero
001cdc 9220 28bd                 	sts pulse2_fx_Rxy_target, zero
001cde 9220 28be                 	sts pulse2_fx_Rxy_target+1, zero
001ce0 9220 28c1                 	sts pulse2_fx_Rxy_total_offset, zero
001ce2 9220 28c2                 	sts pulse2_fx_Rxy_total_offset+1, zero
001ce4 d0f9                      	rcall sound_driver_channel1_increment_offset
001ce5 ce35                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_volume:
001ce6 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001ce7 91a0 2808                 	lds r26, pulse2_param
001ce9 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001cea 2bab                      	or r26, r27 //move new VVVV bits into pulse2_param
001ceb 93a0 2808                 	sts pulse2_param, r26
001ced 6092                      	sbr pulse_channel_flags, 2
001cee d0ef                      	rcall sound_driver_channel1_increment_offset
001cef ce2b                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_delay:
001cf0 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001cf1 93b0 2876                 	sts pulse2_pattern_delay_rows, r27
001cf3 d0ea                      	rcall sound_driver_channel1_increment_offset
001cf4 c100                      	rjmp sound_driver_channel2
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change:
001cf5 9220 287a                 	sts pulse2_volume_macro, zero //reset all macro addresses
001cf7 9220 287b                 	sts pulse2_volume_macro+1, zero
001cf9 9220 287f                 	sts pulse2_arpeggio_macro, zero
001cfb 9220 2880                 	sts pulse2_arpeggio_macro+1, zero
001cfd 9220 2887                 	sts pulse2_pitch_macro, zero
001cff 9220 2888                 	sts pulse2_pitch_macro+1, zero
001d01 9220 288d                 	sts pulse2_hi_pitch_macro, zero
001d03 9220 288e                 	sts pulse2_hi_pitch_macro+1, zero
001d05 9220 2892                 	sts pulse2_duty_macro, zero
001d07 9220 2893                 	sts pulse2_duty_macro+1, zero
001d09 9220 2885                 	sts pulse2_total_pitch_offset, zero //reset the pitch offset
001d0b 9220 2886                 	sts pulse2_total_pitch_offset+1, zero
001d0d 9220 288c                 	sts pulse2_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001d0f 9631                      	adiw Z, 1 //point to the byte next to the flag
001d10 91b4                      	lpm r27, Z //store the instrument offset into r27
001d11 e9ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
001d12 e1f1                      	ldi ZH, HIGH(instruments)
001d13 0feb                      	add ZL, r27 //point Z to offsetted instrument
001d14 1df2                      	adc ZH, zero
001d15 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001d16 1fff                      	rol ZH
001d17 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001d18 91b4                      	lpm r27, Z
                                 
001d19 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001d1a 1fbb                      	rol r27
001d1b 2fea                      	mov ZL, r26
001d1c 2ffb                      	mov ZH, r27
001d1d 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001d1e 9632                      	adiw Z, 2 //point Z to the address of the macro
001d1f e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel1_instrument_change_macro_loop:
001d20 95aa                      	dec r26
001d21 f019                      	breq sound_driver_channel1_instrument_change_exit
001d22 95b6                      	lsr r27
001d23 f078                      	brcs sound_driver_channel1_instrument_change_load_macro
001d24 cffb                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_exit:
001d25 e0a3                      	ldi r26, 0x03
001d26 e0b2                      	ldi r27, 0x02
001d27 93b0 287c                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
001d29 93a0 2881                 	sts pulse2_arpeggio_macro_offset, r26
001d2b 93b0 2889                 	sts pulse2_pitch_macro_offset, r27
001d2d 93b0 288f                 	sts pulse2_hi_pitch_macro_offset, r27
001d2f 93b0 2894                 	sts pulse2_duty_macro_offset, r27
001d31 d0b6                      	rcall sound_driver_channel1_increment_offset_twice
001d32 cde8                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_load_macro:
001d33 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001d34 91d5                      	lpm r29, Z+
                                 
001d35 30a5                      	cpi r26, 5
001d36 f039                      	breq sound_driver_channel1_instrument_change_load_macro_volume
001d37 30a4                      	cpi r26, 4
001d38 f079                      	breq sound_driver_channel1_instrument_change_load_macro_arpeggio
001d39 30a3                      	cpi r26, 3
001d3a f0d9                      	breq sound_driver_channel1_instrument_change_load_macro_pitch
001d3b 30a2                      	cpi r26, 2
001d3c f159                      	breq sound_driver_channel1_instrument_change_load_macro_hi_pitch
001d3d c03c                      	rjmp sound_driver_channel1_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel1_instrument_change_load_macro_volume:
001d3e 93c0 287a                 	sts pulse2_volume_macro, r28
001d40 93d0 287b                 	sts pulse2_volume_macro+1, r29
001d42 d041                      	rcall sound_driver_channel1_instrument_change_read_header
001d43 93c0 287e                 	sts pulse2_volume_macro_release, r28
001d45 93d0 287d                 	sts pulse2_volume_macro_loop, r29
001d47 cfd8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 	
                                 sound_driver_channel1_instrument_change_load_macro_arpeggio:
001d48 93c0 287f                 	sts pulse2_arpeggio_macro, r28
001d4a 93d0 2880                 	sts pulse2_arpeggio_macro+1, r29
001d4c 9220 28b6                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001d4e 9220 28b7                 	sts pulse2_fx_Qxy_target+1, zero
001d50 9220 28bd                 	sts pulse2_fx_Rxy_target, zero
001d52 9220 28be                 	sts pulse2_fx_Rxy_target+1, zero
001d54 d03a                      	rcall sound_driver_channel1_instrument_change_read_header_arpeggio
001d55 cfca                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_pitch:
001d56 93c0 2887                 	sts pulse2_pitch_macro, r28
001d58 93d0 2888                 	sts pulse2_pitch_macro+1, r29
001d5a 9220 28b6                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001d5c 9220 28b7                 	sts pulse2_fx_Qxy_target+1, zero
001d5e 9220 28bd                 	sts pulse2_fx_Rxy_target, zero
001d60 9220 28be                 	sts pulse2_fx_Rxy_target+1, zero
001d62 d021                      	rcall sound_driver_channel1_instrument_change_read_header
001d63 93c0 288b                 	sts pulse2_pitch_macro_release, r28
001d65 93d0 288a                 	sts pulse2_pitch_macro_loop, r29
001d67 cfb8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_hi_pitch:
001d68 93c0 288d                 	sts pulse2_hi_pitch_macro, r28
001d6a 93d0 288e                 	sts pulse2_hi_pitch_macro+1, r29
001d6c 9220 28b6                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001d6e 9220 28b7                 	sts pulse2_fx_Qxy_target+1, zero
001d70 9220 28bd                 	sts pulse2_fx_Rxy_target, zero
001d72 9220 28be                 	sts pulse2_fx_Rxy_target+1, zero
001d74 d00f                      	rcall sound_driver_channel1_instrument_change_read_header
001d75 93c0 2891                 	sts pulse2_hi_pitch_macro_release, r28
001d77 93d0 2890                 	sts pulse2_hi_pitch_macro_loop, r29
001d79 cfa6                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_duty:
001d7a 93c0 2892                 	sts pulse2_duty_macro, r28
001d7c 93d0 2893                 	sts pulse2_duty_macro+1, r29
001d7e d005                      	rcall sound_driver_channel1_instrument_change_read_header
001d7f 93c0 2896                 	sts pulse2_duty_macro_release, r28
001d81 93d0 2895                 	sts pulse2_duty_macro_loop, r29
001d83 cf9c                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_read_header:
001d84 93ef                      	push ZL
001d85 93ff                      	push ZH
001d86 2fec                      	mov ZL, r28
001d87 2ffd                      	mov ZH, r29
001d88 0fee                      	lsl ZL
001d89 1fff                      	rol ZH
001d8a 91c5                      	lpm r28, Z+
001d8b 91d4                      	lpm r29, Z
001d8c 91ff                      	pop ZH
001d8d 91ef                      	pop ZL
001d8e 9508                      	ret
                                 
                                 sound_driver_channel1_instrument_change_read_header_arpeggio:
001d8f 93ef                      	push ZL
001d90 93ff                      	push ZH
001d91 2fec                      	mov ZL, r28
001d92 2ffd                      	mov ZH, r29
001d93 0fee                      	lsl ZL
001d94 1fff                      	rol ZH
001d95 91c5                      	lpm r28, Z+
001d96 91d5                      	lpm r29, Z+
001d97 93c0 2883                 	sts pulse2_arpeggio_macro_release, r28
001d99 93d0 2882                 	sts pulse2_arpeggio_macro_loop, r29
001d9b 91c4                      	lpm r28, Z
001d9c 93c0 2884                 	sts pulse2_arpeggio_macro_mode, r28
001d9e 91ff                      	pop ZH
001d9f 91ef                      	pop ZL
001da0 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel1_release:
                                 sound_driver_channel1_release_volume:
001da1 91b0 287e                 	lds r27, pulse2_volume_macro_release
001da3 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001da4 f019                      	breq sound_driver_channel1_release_arpeggio //if the macro has no release flag, check the next macro
001da5 95b3                      	inc r27
001da6 93b0 287c                 	sts pulse2_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel1_release_arpeggio:
001da8 91b0 2883                 	lds r27, pulse2_arpeggio_macro_release
001daa 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001dab f019                      	breq sound_driver_channel1_release_pitch
001dac 95b3                      	inc r27
001dad 93b0 2881                 	sts pulse2_arpeggio_macro_offset, r27
                                 sound_driver_channel1_release_pitch:
001daf 91b0 288b                 	lds r27, pulse2_pitch_macro_release
001db1 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001db2 f019                      	breq sound_driver_channel1_release_hi_pitch
001db3 95b3                      	inc r27
001db4 93b0 2889                 	sts pulse2_pitch_macro_offset, r27
                                 sound_driver_channel1_release_hi_pitch:
001db6 91b0 2891                 	lds r27, pulse2_hi_pitch_macro_release
001db8 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001db9 f019                      	breq sound_driver_channel1_release_duty
001dba 95b3                      	inc r27
001dbb 93b0 288f                 	sts pulse2_hi_pitch_macro_offset, r27
                                 sound_driver_channel1_release_duty:
001dbd 91b0 2896                 	lds r27, pulse2_duty_macro_release
001dbf 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001dc0 f019                      	breq sound_driver_channel1_release_exit
001dc1 95b3                      	inc r27
001dc2 93b0 2894                 	sts pulse2_duty_macro_offset, r27
                                 sound_driver_channel1_release_exit:
001dc4 d019                      	rcall sound_driver_channel1_increment_offset
001dc5 cd55                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_next_pattern:
001dc6 91e0 2819                 	lds ZL, song_frames
001dc8 91f0 281a                 	lds ZH, song_frames+1
001dca 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001dcc 91b0 281c                 	lds r27, song_frame_offset+1
001dce 9612                      	adiw r27:r26, 2 //offset for channel 1
001dcf 0fea                      	add ZL, r26
001dd0 1ffb                      	adc ZH, r27
                                 
001dd1 91a5                      	lpm r26, Z+ //load the address of the next pattern
001dd2 91b4                      	lpm r27, Z
001dd3 0faa                      	lsl r26
001dd4 1fbb                      	rol r27
001dd5 93a0 2874                 	sts pulse2_pattern, r26
001dd7 93b0 2875                 	sts pulse2_pattern+1, r27
                                 
001dd9 9220 2878                 	sts pulse2_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001ddb 9220 2879                 	sts pulse2_pattern_offset+1, zero
001ddd cd3d                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_increment_offset:
001dde 91e0 2878                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001de0 91f0 2879                 	lds ZH, pulse2_pattern_offset+1
001de2 9631                      	adiw Z, 1
001de3 93e0 2878                 	sts pulse2_pattern_offset, ZL
001de5 93f0 2879                 	sts pulse2_pattern_offset+1, ZH
001de7 9508                      	ret
                                 
                                 sound_driver_channel1_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001de8 91e0 2878                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001dea 91f0 2879                 	lds ZH, pulse2_pattern_offset+1
001dec 9632                      	adiw Z, 2 //increment the pointer twice
001ded 93e0 2878                 	sts pulse2_pattern_offset, ZL
001def 93f0 2879                 	sts pulse2_pattern_offset+1, ZH
001df1 9508                      	ret
                                 
                                 sound_driver_channel1_decrement_frame_delay:
001df2 95ba                      	dec r27
001df3 93b0 2877                 	sts pulse2_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel2:
001df5 91a0 28c7                 	lds r26, triangle_pattern_delay_rows
001df7 91b0 28c8                 	lds r27, triangle_pattern_delay_frames
001df9 9610                      	adiw r27:r26, 0
001dfa f009                      	breq sound_driver_channel2_main //if the pattern delay is 0, proceed with sound driver procedures
001dfb c2bf                      	rjmp sound_driver_channel2_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel2_main:
001dfc 91e0 28c5                 	lds ZL, triangle_pattern //current pattern for triangle
001dfe 91f0 28c6                 	lds ZH, triangle_pattern+1
001e00 91a0 28c9                 	lds r26, triangle_pattern_offset //current offset in the pattern for triangle
001e02 91b0 28ca                 	lds r27, triangle_pattern_offset+1
001e04 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001e05 1ffb                      	adc ZH, r27
001e06 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel2_check_if_note: //check if data is a note (0x00 - 0x56)
001e07 35b7                      	cpi r27, 0x57
001e08 f408                      	brsh sound_driver_channel2_check_if_volume
001e09 c160                      	rjmp sound_driver_channel2_note
                                 sound_driver_channel2_check_if_volume: //check if data is volume (0x57-0x66)
001e0a 36b7                      	cpi r27, 0x67
001e0b f408                      	brsh sound_driver_channel2_check_if_delay
001e0c c19e                      	rjmp sound_driver_channel2_volume
                                 sound_driver_channel2_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001e0d 3eb3                      	cpi r27, 0xE3
001e0e f408                      	brsh sound_driver_channel2_check_if_instrument
001e0f c1a9                      	rjmp sound_driver_channel2_delay
                                 sound_driver_channel2_check_if_instrument: //check for instrument flag (0xE3)
001e10 f409                      	brne sound_driver_channel2_check_if_release
001e11 c1ac                      	rjmp sound_driver_channel2_instrument_change 
                                 sound_driver_channel2_check_if_release: //check for note release flag (0xE4)
001e12 3eb4                      	cpi r27, 0xE4
001e13 f409                      	brne sound_driver_channel2_check_if_end
001e14 c255                      	rjmp sound_driver_channel2_release
                                 sound_driver_channel2_check_if_end:
001e15 3fbf                      	cpi r27, 0xFF
001e16 f409                      	brne sound_driver_channel2_check_if_fx
001e17 c277                      	rjmp sound_driver_channel2_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel2_check_if_fx: //fx flags (0xE5 - 0xFE)
001e18 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001e19 91a4                      	lpm r26, Z //load the fx data into r26
001e1a d296                      	rcall sound_driver_channel2_increment_offset_twice
                                 
001e1b 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001e1c e2e2                      	ldi ZL, LOW(channel2_fx << 1) //load in note table
001e1d e6f1                      	ldi ZH, HIGH(channel2_fx << 1)
001e1e 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001e1f 0feb                      	add ZL, r27 //add offset
001e20 1df2                      	adc ZH, zero
001e21 91c5                      	lpm r28, Z+ //load address bytes
001e22 91d4                      	lpm r29, Z
001e23 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001e24 2ffd                      	mov ZH, r29
001e25 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel2_fx_0xy:
001e26 93a0 28e8                 	sts triangle_fx_0xy_sequence, r26
001e28 9220 28e9                 	sts triangle_fx_0xy_sequence+1, zero
001e2a cfd1                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel2_fx_1xx:
001e2b 9220 28ee                 	sts triangle_fx_2xx, zero //turn off any 2xx pitch slide down
001e2d 9220 28ef                 	sts triangle_fx_2xx+1, zero
001e2f 9220 28e8                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001e31 9220 28e9                 	sts triangle_fx_0xy_sequence+1, zero
001e33 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001e34 937f                      	push r23
001e35 2f6a                      	mov r22, r26 //store the rate into r22
001e36 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001e37 9f67                      	mul r22, r23
001e38 917f                      	pop r23
001e39 916f                      	pop r22
                                 
001e3a 9416                      	lsr r1 //shift out the fractional bits
001e3b 9407                      	ror r0
001e3c 9416                      	lsr r1
001e3d 9407                      	ror r0
001e3e 9416                      	lsr r1
001e3f 9407                      	ror r0
001e40 9416                      	lsr r1
001e41 9407                      	ror r0
001e42 9200 28ea                 	sts triangle_fx_1xx, r0
001e44 9210 28eb                 	sts triangle_fx_1xx+1, r1
001e46 cfb5                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel2_fx_2xx:
001e47 9220 28ea                 	sts triangle_fx_1xx, zero //turn off any 1xx pitch slide down
001e49 9220 28eb                 	sts triangle_fx_1xx+1, zero
001e4b 9220 28e8                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001e4d 9220 28e9                 	sts triangle_fx_0xy_sequence+1, zero
001e4f 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001e50 937f                      	push r23
001e51 2f6a                      	mov r22, r26 //store the rate into r22
001e52 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001e53 9f67                      	mul r22, r23
001e54 917f                      	pop r23
001e55 916f                      	pop r22
                                 
001e56 9416                      	lsr r1 //shift out the fractional bits
001e57 9407                      	ror r0
001e58 9416                      	lsr r1
001e59 9407                      	ror r0
001e5a 9416                      	lsr r1
001e5b 9407                      	ror r0
001e5c 9416                      	lsr r1
001e5d 9407                      	ror r0
001e5e 9200 28ee                 	sts triangle_fx_2xx, r0
001e60 9210 28ef                 	sts triangle_fx_2xx+1, r1
001e62 cf99                      	rjmp sound_driver_channel2_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel2_fx_3xx:
001e63 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001e64 937f                      	push r23
001e65 2f6a                      	mov r22, r26 //store the rate into r22
001e66 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001e67 9f67                      	mul r22, r23
001e68 917f                      	pop r23
001e69 916f                      	pop r22
                                 
001e6a 9416                      	lsr r1 //shift out the fractional bits
001e6b 9407                      	ror r0
001e6c 9416                      	lsr r1
001e6d 9407                      	ror r0
001e6e 9416                      	lsr r1
001e6f 9407                      	ror r0
001e70 9416                      	lsr r1
001e71 9407                      	ror r0
001e72 9200 28f6                 	sts triangle_fx_3xx_speed, r0
001e74 9210 28f7                 	sts triangle_fx_3xx_speed+1, r1
                                 
001e76 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001e77 c001                      	rjmp sound_driver_channel2_fx_3xx_enabled
001e78 cf83                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_3xx_enabled:
001e79 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001e7b 91b0 0aad                 	lds r27, TCB2_CCMPH
001e7d 93a0 28f2                 	sts triangle_fx_3xx_start, r26
001e7f 93b0 28f3                 	sts triangle_fx_3xx_start+1, r27
                                 
001e81 9220 28f8                 	sts triangle_fx_3xx_total_offset, zero
001e83 9220 28f9                 	sts triangle_fx_3xx_total_offset+1, zero
001e85 cf76                      	rjmp sound_driver_channel2_main
                                 
                                 //VIBRATO
                                 sound_driver_channel2_fx_4xy:
001e86 2fba                      	mov r27, r26
001e87 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001e88 95a2                      	swap r26
001e89 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001e8a 93a0 28fa                 	sts triangle_fx_4xy_speed, r26
001e8c 93b0 28fb                 	sts triangle_fx_4xy_depth, r27
001e8e 9220 28fc                 	sts triangle_fx_4xy_phase, zero //reset the phase to 0
001e90 cf6b                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_7xy: //tremelo
001e91 cf6a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Axy: //volume slide
001e92 cf69                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel2_fx_Bxx:
001e93 93a0 2820                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001e95 cf66                      	rjmp sound_driver_channel2_main
                                 
                                 //HALT
                                 sound_driver_channel2_fx_Cxx:
001e96 93b0 2821                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001e98 cf63                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel2_fx_Dxx:
001e99 93b0 2822                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001e9b cf60                      	rjmp sound_driver_channel2_main
                                 
                                 //VOLUME
                                 sound_driver_channel2_fx_Exx:
001e9c 15a2                      	cp r26, zero
001e9d f021                      	breq sound_driver_channel2_fx_Exx_disable
                                 sound_driver_channel2_fx_Exx_enable:
001e9e e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001e9f 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001ea1 cf5a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Exx_disable:
001ea2 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
001ea4 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
001ea6 9220 0aad                 	sts TCB2_CCMPH, zero
001ea8 cf53                      	rjmp sound_driver_channel2_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel2_fx_Fxx:
001ea9 93a0 281f                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001eab cf50                      	rjmp sound_driver_channel2_main
                                 
                                 //DELAY
                                 sound_driver_channel2_fx_Gxx:
001eac 15a2                      	cp r26, zero
001ead f051                      	breq sound_driver_channel2_fx_Gxx_invalid
001eae 91b0 281f                 	lds r27, song_speed
001eb0 17ab                      	cp r26, r27
001eb1 f430                      	brsh sound_driver_channel2_fx_Gxx_invalid
001eb2 93a0 28fd                 	sts triangle_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001eb4 e0b1                      	ldi r27, 0x01
001eb5 93b0 28c7                 	sts triangle_pattern_delay_rows, r27
001eb7 c206                      	rjmp sound_driver_channel3
                                 sound_driver_channel2_fx_Gxx_invalid:
001eb8 cf43                      	rjmp sound_driver_channel2_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Hxy: //hardware sweep up
001eb9 cf42                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixy: //hardware sweep down
001eba cf41                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Hxx: //FDS modulation depth
001ebb cf40                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixx: //FDS modulation speed
001ebc cf3f                      	rjmp sound_driver_channel2_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel2_fx_Pxx:
001ebd 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001ebe 937f                      	push r23
001ebf 2f6a                      	mov r22, r26
001ec0 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001ec1 0367                      	mulsu r22, r23
001ec2 917f                      	pop r23
001ec3 916f                      	pop r22
001ec4 9416                      	lsr r1 //shift out the fractional bits
001ec5 9407                      	ror r0
001ec6 9416                      	lsr r1
001ec7 9407                      	ror r0
001ec8 9416                      	lsr r1
001ec9 9407                      	ror r0
001eca 9416                      	lsr r1
001ecb 9407                      	ror r0
001ecc fe13                      	sbrs r1, 3 //check if result was a negative number
001ecd c002                      	rjmp sound_driver_channel2_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel2_fx_Pxx_negative:
001ece efb0                      	ldi r27, 0xF0
001ecf 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel2_fx_Pxx_store:
001ed0 9200 28ff                 	sts triangle_fx_Pxx_total, r0
001ed2 9210 2900                 	sts triangle_fx_Pxx_total+1, r1
001ed4 cf27                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel2_fx_Qxy:
                                 sound_driver_channel2_fx_Qxy_check_arpeggio_macro:
001ed5 91e0 28d0                 	lds ZL, triangle_arpeggio_macro
001ed7 91f0 28d1                 	lds ZH, triangle_arpeggio_macro+1
001ed9 9630                      	adiw Z, 0
001eda f009                      	breq sound_driver_channel2_fx_Qxy_check_pitch_macro
001edb cf20                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_pitch_macro:
001edc 91e0 28d8                 	lds ZL, triangle_pitch_macro
001ede 91f0 28d9                 	lds ZH, triangle_pitch_macro+1
001ee0 9630                      	adiw Z, 0
001ee1 f009                      	breq sound_driver_channel2_fx_Qxy_check_hi_pitch_macro
001ee2 cf19                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_hi_pitch_macro:
001ee3 91e0 28de                 	lds ZL, triangle_hi_pitch_macro
001ee5 91f0 28df                 	lds ZH, triangle_hi_pitch_macro+1
001ee7 9630                      	adiw Z, 0
001ee8 f009                      	breq sound_driver_channel2_fx_Qxy_process
001ee9 cf12                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_process:
001eea 2fba                      	mov r27, r26 //copy fx parameters into r27
001eeb 70bf                      	andi r27, 0x0F //mask note index offset
001eec 91c0 2901                 	lds r28, triangle_fx_Qxy_target_note //load current note index
001eee 0fbc                      	add r27, r28
001eef 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001ef0 f008                      	brlo sound_driver_channel2_fx_Qxy_process_continue
001ef1 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel2_fx_Qxy_process_continue:
001ef2 93b0 2901                 	sts triangle_fx_Qxy_target_note, r27
001ef4 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001ef5 e0f0                      	ldi ZH, HIGH(note_table << 1)
001ef6 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001ef7 0feb                      	add ZL, r27 //add offset
001ef8 1df2                      	adc ZH, zero
001ef9 91c5                      	lpm r28, Z+ //load bytes
001efa 91d4                      	lpm r29, Z
001efb 93c0 2902                 	sts triangle_fx_Qxy_target, r28 //load the LOW bits for the target period
001efd 93d0 2903                 	sts triangle_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel2_fx_Qxy_process_speed:
001eff 95a2                      	swap r26
001f00 70af                      	andi r26, 0x0F //mask effect speed
001f01 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001f02 95a3                      	inc r26 //increment the speed by 1
                                 
001f03 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001f04 937f                      	push r23
001f05 2f6a                      	mov r22, r26 //store the speed data into r27
001f06 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001f07 9f67                      	mul r22, r23
001f08 917f                      	pop r23
001f09 916f                      	pop r22
                                 
001f0a 9416                      	lsr r1 //shift out the fractional bits
001f0b 9407                      	ror r0
001f0c 9416                      	lsr r1
001f0d 9407                      	ror r0
001f0e 9416                      	lsr r1
001f0f 9407                      	ror r0
001f10 9416                      	lsr r1
001f11 9407                      	ror r0
                                 
001f12 9200 2904                 	sts triangle_fx_Qxy_speed, r0 //store the effect speed
001f14 9210 2905                 	sts triangle_fx_Qxy_speed+1, r1
001f16 cee5                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel2_fx_Rxy:
                                 sound_driver_channel2_fx_Rxy_check_arpeggio_macro:
001f17 91e0 28d0                 	lds ZL, triangle_arpeggio_macro
001f19 91f0 28d1                 	lds ZH, triangle_arpeggio_macro+1
001f1b 9630                      	adiw Z, 0
001f1c f009                      	breq sound_driver_channel2_fx_Rxy_check_pitch_macro
001f1d cede                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_pitch_macro:
001f1e 91e0 28d8                 	lds ZL, triangle_pitch_macro
001f20 91f0 28d9                 	lds ZH, triangle_pitch_macro+1
001f22 9630                      	adiw Z, 0
001f23 f009                      	breq sound_driver_channel2_fx_Rxy_check_hi_pitch_macro
001f24 ced7                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_hi_pitch_macro:
001f25 91e0 28de                 	lds ZL, triangle_hi_pitch_macro
001f27 91f0 28df                 	lds ZH, triangle_hi_pitch_macro+1
001f29 9630                      	adiw Z, 0
001f2a f009                      	breq sound_driver_channel2_fx_Rxy_process
001f2b ced0                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_process:
001f2c 2fba                      	mov r27, r26 //copy fx parameters into r27
001f2d 70bf                      	andi r27, 0x0F //mask note index offset
001f2e 91c0 2908                 	lds r28, triangle_fx_Rxy_target_note //load current note index
001f30 1bcb                      	sub r28, r27
001f31 f408                      	brcc sound_driver_channel2_fx_Rxy_process_continue
001f32 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel2_fx_Rxy_process_continue:
001f33 93c0 2908                 	sts triangle_fx_Rxy_target_note, r28
001f35 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001f36 e0f0                      	ldi ZH, HIGH(note_table << 1)
001f37 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001f38 0fec                      	add ZL, r28 //add offset
001f39 1df2                      	adc ZH, zero
001f3a 91c5                      	lpm r28, Z+ //load bytes
001f3b 91d4                      	lpm r29, Z
001f3c 93c0 2909                 	sts triangle_fx_Rxy_target, r28 //load the LOW bits for the target period
001f3e 93d0 290a                 	sts triangle_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel2_fx_Rxy_process_speed:
001f40 95a2                      	swap r26
001f41 70af                      	andi r26, 0x0F //mask effect speed
001f42 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001f43 95a3                      	inc r26 //increment the speed by 1
                                 
001f44 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001f45 937f                      	push r23
001f46 2f6a                      	mov r22, r26 //store the speed data into r27
001f47 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001f48 9f67                      	mul r22, r23
001f49 917f                      	pop r23
001f4a 916f                      	pop r22
                                 
001f4b 9416                      	lsr r1 //shift out the fractional bits
001f4c 9407                      	ror r0
001f4d 9416                      	lsr r1
001f4e 9407                      	ror r0
001f4f 9416                      	lsr r1
001f50 9407                      	ror r0
001f51 9416                      	lsr r1
001f52 9407                      	ror r0
                                 
001f53 9200 290b                 	sts triangle_fx_Rxy_speed, r0 //store the effect speed
001f55 9210 290c                 	sts triangle_fx_Rxy_speed+1, r1
001f57 cea4                      	rjmp sound_driver_channel2_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel2_fx_Sxx:
001f58 15a2                      	cp r26, zero
001f59 f051                      	breq sound_driver_channel2_fx_Sxx_invalid
001f5a 91b0 281f                 	lds r27, song_speed
001f5c 17ab                      	cp r26, r27
001f5d f430                      	brsh sound_driver_channel2_fx_Sxx_invalid
001f5e 93a0 290f                 	sts triangle_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001f60 e0b1                      	ldi r27, 0x01
001f61 93b0 28c7                 	sts triangle_pattern_delay_rows, r27
001f63 c15a                      	rjmp sound_driver_channel3
                                 sound_driver_channel2_fx_Sxx_invalid:
001f64 ce97                      	rjmp sound_driver_channel2_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Vxx: //duty
001f65 ce96                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Wxx: //DPCM sample speed
001f66 ce95                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Xxx: //DPCM sample retrigger
001f67 ce94                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Yxx: //DPCM sample offset
001f68 ce93                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Zxx: //DPCM sample delta counter
001f69 ce92                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 sound_driver_channel2_note:
001f6a 93b0 2812                 	sts triangle_note, r27 //store the note index
001f6c 93b0 2901                 	sts triangle_fx_Qxy_target_note, r27
001f6e 93b0 2908                 	sts triangle_fx_Rxy_target_note, r27
001f70 e0a3                      	ldi r26, 0x03
001f71 e0b2                      	ldi r27, 0x02
001f72 93b0 28cd                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
001f74 93a0 28d2                 	sts triangle_arpeggio_macro_offset, r26
001f76 93b0 28da                 	sts triangle_pitch_macro_offset, r27
001f78 93b0 28e0                 	sts triangle_hi_pitch_macro_offset, r27
001f7a 93b0 28e5                 	sts triangle_duty_macro_offset, r27
001f7c 9220 28d6                 	sts triangle_total_pitch_offset, zero //reset the pitch and hi pitch offset
001f7e 9220 28d7                 	sts triangle_total_pitch_offset+1, zero
001f80 9220 28dd                 	sts triangle_total_hi_pitch_offset, zero
001f82 9220 28ec                 	sts triangle_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001f84 9220 28ed                 	sts triangle_fx_1xx_total+1, zero
001f86 9220 28f0                 	sts triangle_fx_2xx_total, zero
001f88 9220 28f1                 	sts triangle_fx_2xx_total+1, zero
001f8a 9220 28f8                 	sts triangle_fx_3xx_total_offset, zero //reset 3xx offset
001f8c 9220 28f9                 	sts triangle_fx_3xx_total_offset+1, zero
001f8e 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001f90 91b0 0aad                 	lds r27, TCB2_CCMPH
001f92 93a0 28f2                 	sts triangle_fx_3xx_start, r26
001f94 93b0 28f3                 	sts triangle_fx_3xx_start+1, r27
001f96 9220 2902                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001f98 9220 2903                 	sts triangle_fx_Qxy_target+1, zero
001f9a 9220 2906                 	sts triangle_fx_Qxy_total_offset, zero
001f9c 9220 2907                 	sts triangle_fx_Qxy_total_offset+1, zero
001f9e 9220 2909                 	sts triangle_fx_Rxy_target, zero
001fa0 9220 290a                 	sts triangle_fx_Rxy_target+1, zero
001fa2 9220 290d                 	sts triangle_fx_Rxy_total_offset, zero
001fa4 9220 290e                 	sts triangle_fx_Rxy_total_offset+1, zero
001fa6 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001fa7 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001fa9 d0fd                      	rcall sound_driver_channel2_increment_offset
001faa ce51                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_volume:
001fab d0fb                      	rcall sound_driver_channel2_increment_offset
001fac 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001fad f021                      	breq sound_driver_channel2_volume_disable
                                 sound_driver_channel2_volume_enable:
001fae e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001faf 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001fb1 ce4a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_volume_disable:
001fb2 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
001fb4 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
001fb6 9220 0aad                 	sts TCB2_CCMPH, zero
001fb8 ce43                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_delay:
001fb9 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001fba 93b0 28c7                 	sts triangle_pattern_delay_rows, r27
001fbc d0ea                      	rcall sound_driver_channel2_increment_offset
001fbd c100                      	rjmp sound_driver_channel3
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change:
001fbe 9220 28cb                 	sts triangle_volume_macro, zero //reset all macro addresses
001fc0 9220 28cc                 	sts triangle_volume_macro+1, zero
001fc2 9220 28d0                 	sts triangle_arpeggio_macro, zero
001fc4 9220 28d1                 	sts triangle_arpeggio_macro+1, zero
001fc6 9220 28d8                 	sts triangle_pitch_macro, zero
001fc8 9220 28d9                 	sts triangle_pitch_macro+1, zero
001fca 9220 28de                 	sts triangle_hi_pitch_macro, zero
001fcc 9220 28df                 	sts triangle_hi_pitch_macro+1, zero
001fce 9220 28e3                 	sts triangle_duty_macro, zero
001fd0 9220 28e4                 	sts triangle_duty_macro+1, zero
001fd2 9220 28d6                 	sts triangle_total_pitch_offset, zero //reset the pitch offset
001fd4 9220 28d7                 	sts triangle_total_pitch_offset+1, zero
001fd6 9220 28dd                 	sts triangle_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001fd8 9631                      	adiw Z, 1 //point to the byte next to the flag
001fd9 91b4                      	lpm r27, Z //store the instrument offset into r27
001fda e9ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
001fdb e1f1                      	ldi ZH, HIGH(instruments)
001fdc 0feb                      	add ZL, r27 //point Z to offsetted instrument
001fdd 1df2                      	adc ZH, zero
001fde 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001fdf 1fff                      	rol ZH
001fe0 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001fe1 91b4                      	lpm r27, Z
                                 
001fe2 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001fe3 1fbb                      	rol r27
001fe4 2fea                      	mov ZL, r26
001fe5 2ffb                      	mov ZH, r27
001fe6 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001fe7 9632                      	adiw Z, 2 //point Z to the address of the macro
001fe8 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel2_instrument_change_macro_loop:
001fe9 95aa                      	dec r26
001fea f019                      	breq sound_driver_channel2_instrument_change_exit
001feb 95b6                      	lsr r27
001fec f078                      	brcs sound_driver_channel2_instrument_change_load_macro
001fed cffb                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_exit:
001fee e0a3                      	ldi r26, 0x03
001fef e0b2                      	ldi r27, 0x02
001ff0 93b0 28cd                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
001ff2 93a0 28d2                 	sts triangle_arpeggio_macro_offset, r26
001ff4 93b0 28da                 	sts triangle_pitch_macro_offset, r27
001ff6 93b0 28e0                 	sts triangle_hi_pitch_macro_offset, r27
001ff8 93b0 28e5                 	sts triangle_duty_macro_offset, r27
001ffa d0b6                      	rcall sound_driver_channel2_increment_offset_twice
001ffb ce00                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_load_macro:
001ffc 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001ffd 91d5                      	lpm r29, Z+
                                 
001ffe 30a5                      	cpi r26, 5
001fff f039                      	breq sound_driver_channel2_instrument_change_load_macro_volume
002000 30a4                      	cpi r26, 4
002001 f079                      	breq sound_driver_channel2_instrument_change_load_macro_arpeggio
002002 30a3                      	cpi r26, 3
002003 f0d9                      	breq sound_driver_channel2_instrument_change_load_macro_pitch
002004 30a2                      	cpi r26, 2
002005 f159                      	breq sound_driver_channel2_instrument_change_load_macro_hi_pitch
002006 c03c                      	rjmp sound_driver_channel2_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel2_instrument_change_load_macro_volume:
002007 93c0 28cb                 	sts triangle_volume_macro, r28
002009 93d0 28cc                 	sts triangle_volume_macro+1, r29
00200b d041                      	rcall sound_driver_channel2_instrument_change_read_header
00200c 93c0 28cf                 	sts triangle_volume_macro_release, r28
00200e 93d0 28ce                 	sts triangle_volume_macro_loop, r29
002010 cfd8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 	
                                 sound_driver_channel2_instrument_change_load_macro_arpeggio:
002011 93c0 28d0                 	sts triangle_arpeggio_macro, r28
002013 93d0 28d1                 	sts triangle_arpeggio_macro+1, r29
002015 9220 2902                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
002017 9220 2903                 	sts triangle_fx_Qxy_target+1, zero
002019 9220 2909                 	sts triangle_fx_Rxy_target, zero
00201b 9220 290a                 	sts triangle_fx_Rxy_target+1, zero
00201d d03a                      	rcall sound_driver_channel2_instrument_change_read_header_arpeggio
00201e cfca                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_pitch:
00201f 93c0 28d8                 	sts triangle_pitch_macro, r28
002021 93d0 28d9                 	sts triangle_pitch_macro+1, r29
002023 9220 2902                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
002025 9220 2903                 	sts triangle_fx_Qxy_target+1, zero
002027 9220 2909                 	sts triangle_fx_Rxy_target, zero
002029 9220 290a                 	sts triangle_fx_Rxy_target+1, zero
00202b d021                      	rcall sound_driver_channel2_instrument_change_read_header
00202c 93c0 28dc                 	sts triangle_pitch_macro_release, r28
00202e 93d0 28db                 	sts triangle_pitch_macro_loop, r29
002030 cfb8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_hi_pitch:
002031 93c0 28de                 	sts triangle_hi_pitch_macro, r28
002033 93d0 28df                 	sts triangle_hi_pitch_macro+1, r29
002035 9220 2902                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
002037 9220 2903                 	sts triangle_fx_Qxy_target+1, zero
002039 9220 2909                 	sts triangle_fx_Rxy_target, zero
00203b 9220 290a                 	sts triangle_fx_Rxy_target+1, zero
00203d d00f                      	rcall sound_driver_channel2_instrument_change_read_header
00203e 93c0 28e2                 	sts triangle_hi_pitch_macro_release, r28
002040 93d0 28e1                 	sts triangle_hi_pitch_macro_loop, r29
002042 cfa6                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_duty:
002043 93c0 28e3                 	sts triangle_duty_macro, r28
002045 93d0 28e4                 	sts triangle_duty_macro+1, r29
002047 d005                      	rcall sound_driver_channel2_instrument_change_read_header
002048 93c0 28e7                 	sts triangle_duty_macro_release, r28
00204a 93d0 28e6                 	sts triangle_duty_macro_loop, r29
00204c cf9c                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_read_header:
00204d 93ef                      	push ZL
00204e 93ff                      	push ZH
00204f 2fec                      	mov ZL, r28
002050 2ffd                      	mov ZH, r29
002051 0fee                      	lsl ZL
002052 1fff                      	rol ZH
002053 91c5                      	lpm r28, Z+
002054 91d4                      	lpm r29, Z
002055 91ff                      	pop ZH
002056 91ef                      	pop ZL
002057 9508                      	ret
                                 
                                 sound_driver_channel2_instrument_change_read_header_arpeggio:
002058 93ef                      	push ZL
002059 93ff                      	push ZH
00205a 2fec                      	mov ZL, r28
00205b 2ffd                      	mov ZH, r29
00205c 0fee                      	lsl ZL
00205d 1fff                      	rol ZH
00205e 91c5                      	lpm r28, Z+
00205f 91d5                      	lpm r29, Z+
002060 93c0 28d4                 	sts triangle_arpeggio_macro_release, r28
002062 93d0 28d3                 	sts triangle_arpeggio_macro_loop, r29
002064 91c4                      	lpm r28, Z
002065 93c0 28d5                 	sts triangle_arpeggio_macro_mode, r28
002067 91ff                      	pop ZH
002068 91ef                      	pop ZL
002069 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel2_release:
                                 sound_driver_channel2_release_volume:
00206a 91b0 28cf                 	lds r27, triangle_volume_macro_release
00206c 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
00206d f019                      	breq sound_driver_channel2_release_arpeggio //if the macro has no release flag, check the next macro
00206e 95b3                      	inc r27
00206f 93b0 28cd                 	sts triangle_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel2_release_arpeggio:
002071 91b0 28d4                 	lds r27, triangle_arpeggio_macro_release
002073 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
002074 f019                      	breq sound_driver_channel2_release_pitch
002075 95b3                      	inc r27
002076 93b0 28d2                 	sts triangle_arpeggio_macro_offset, r27
                                 sound_driver_channel2_release_pitch:
002078 91b0 28dc                 	lds r27, triangle_pitch_macro_release
00207a 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
00207b f019                      	breq sound_driver_channel2_release_hi_pitch
00207c 95b3                      	inc r27
00207d 93b0 28da                 	sts triangle_pitch_macro_offset, r27
                                 sound_driver_channel2_release_hi_pitch:
00207f 91b0 28e2                 	lds r27, triangle_hi_pitch_macro_release
002081 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
002082 f019                      	breq sound_driver_channel2_release_duty
002083 95b3                      	inc r27
002084 93b0 28e0                 	sts triangle_hi_pitch_macro_offset, r27
                                 sound_driver_channel2_release_duty:
002086 91b0 28e7                 	lds r27, triangle_duty_macro_release
002088 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
002089 f019                      	breq sound_driver_channel2_release_exit
00208a 95b3                      	inc r27
00208b 93b0 28e5                 	sts triangle_duty_macro_offset, r27
                                 sound_driver_channel2_release_exit:
00208d d019                      	rcall sound_driver_channel2_increment_offset
00208e cd6d                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_next_pattern:
00208f 91e0 2819                 	lds ZL, song_frames
002091 91f0 281a                 	lds ZH, song_frames+1
002093 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
002095 91b0 281c                 	lds r27, song_frame_offset+1
002097 9614                      	adiw r27:r26, 4 //offset for channel 2
002098 0fea                      	add ZL, r26
002099 1ffb                      	adc ZH, r27
                                 
00209a 91a5                      	lpm r26, Z+ //load the address of the next pattern
00209b 91b4                      	lpm r27, Z
00209c 0faa                      	lsl r26
00209d 1fbb                      	rol r27
00209e 93a0 28c5                 	sts triangle_pattern, r26
0020a0 93b0 28c6                 	sts triangle_pattern+1, r27
                                 
0020a2 9220 28c9                 	sts triangle_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
0020a4 9220 28ca                 	sts triangle_pattern_offset+1, zero
0020a6 cd55                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_increment_offset:
0020a7 91e0 28c9                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
0020a9 91f0 28ca                 	lds ZH, triangle_pattern_offset+1
0020ab 9631                      	adiw Z, 1
0020ac 93e0 28c9                 	sts triangle_pattern_offset, ZL
0020ae 93f0 28ca                 	sts triangle_pattern_offset+1, ZH
0020b0 9508                      	ret
                                 
                                 sound_driver_channel2_increment_offset_twice: //used for data that takes up 2 bytes worth of space
0020b1 91e0 28c9                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
0020b3 91f0 28ca                 	lds ZH, triangle_pattern_offset+1
0020b5 9632                      	adiw Z, 2 //increment the pointer twice
0020b6 93e0 28c9                 	sts triangle_pattern_offset, ZL
0020b8 93f0 28ca                 	sts triangle_pattern_offset+1, ZH
0020ba 9508                      	ret
                                 
                                 sound_driver_channel2_decrement_frame_delay:
0020bb 95ba                      	dec r27
0020bc 93b0 28c8                 	sts triangle_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel3:
0020be 91a0 2913                 	lds r26, noise_pattern_delay_rows
0020c0 91b0 2914                 	lds r27, noise_pattern_delay_frames
0020c2 9610                      	adiw r27:r26, 0
0020c3 f009                      	breq sound_driver_channel3_main //if the pattern delay is 0, proceed with sound driver procedures
0020c4 c1b9                      	rjmp sound_driver_channel3_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel3_main:
0020c5 91e0 2911                 	lds ZL, noise_pattern //current pattern for noise
0020c7 91f0 2912                 	lds ZH, noise_pattern+1
0020c9 91a0 2915                 	lds r26, noise_pattern_offset //current offset in the pattern for noise
0020cb 91b0 2916                 	lds r27, noise_pattern_offset+1
0020cd 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
0020ce 1ffb                      	adc ZH, r27
0020cf 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel3_check_if_note: //check if data is a note (0x00 - 0x56)
0020d0 35b7                      	cpi r27, 0x57
0020d1 f408                      	brsh sound_driver_channel3_check_if_volume
0020d2 c096                      	rjmp sound_driver_channel3_note
                                 sound_driver_channel3_check_if_volume: //check if data is volume (0x57-0x66)
0020d3 36b7                      	cpi r27, 0x67
0020d4 f408                      	brsh sound_driver_channel3_check_if_delay
0020d5 c0b1                      	rjmp sound_driver_channel3_volume
                                 sound_driver_channel3_check_if_delay: //check if data is a delay (0x67 - 0xE2)
0020d6 3eb3                      	cpi r27, 0xE3
0020d7 f408                      	brsh sound_driver_channel3_check_if_instrument
0020d8 c0b7                      	rjmp sound_driver_channel3_delay
                                 sound_driver_channel3_check_if_instrument: //check for instrument flag (0xE3)
0020d9 f409                      	brne sound_driver_channel3_check_if_release
0020da c0ba                      	rjmp sound_driver_channel3_instrument_change 
                                 sound_driver_channel3_check_if_release: //check for note release flag (0xE4)
0020db 3eb4                      	cpi r27, 0xE4
0020dc f409                      	brne sound_driver_channel3_check_if_end
0020dd c14b                      	rjmp sound_driver_channel3_release
                                 sound_driver_channel3_check_if_end:
0020de 3fbf                      	cpi r27, 0xFF
0020df f409                      	brne sound_driver_channel3_check_if_fx
0020e0 c16d                      	rjmp sound_driver_channel3_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel3_check_if_fx: //fx flags (0xE5 - 0xFE)
0020e1 9631                      	adiw Z, 1 //point Z to the byte next to the flag
0020e2 91a4                      	lpm r26, Z //load the fx data into r26
0020e3 d190                      	rcall sound_driver_channel3_increment_offset_twice
                                 
0020e4 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
0020e5 e5e6                      	ldi ZL, LOW(channel3_fx << 1) //load in note table
0020e6 e6f1                      	ldi ZH, HIGH(channel3_fx << 1)
0020e7 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
0020e8 0feb                      	add ZL, r27 //add offset
0020e9 1df2                      	adc ZH, zero
0020ea 91c5                      	lpm r28, Z+ //load address bytes
0020eb 91d4                      	lpm r29, Z
0020ec 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
0020ed 2ffd                      	mov ZH, r29
0020ee 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel3_fx_0xy:
0020ef 93a0 2934                 	sts noise_fx_0xy_sequence, r26
0020f1 9220 2935                 	sts noise_fx_0xy_sequence+1, zero
0020f3 cfd1                      	rjmp sound_driver_channel3_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel3_fx_1xx:
0020f4 9220 2938                 	sts noise_fx_2xx, zero //turn off any 2xx pitch slide down
0020f6 9220 2934                 	sts noise_fx_0xy_sequence, zero //disable any 0xy effect
0020f8 9220 2935                 	sts noise_fx_0xy_sequence+1, zero
0020fa 93a0 2936                 	sts noise_fx_1xx, r26
0020fc cfc8                      	rjmp sound_driver_channel3_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel3_fx_2xx:
0020fd 9220 2936                 	sts noise_fx_1xx, zero //turn off any 1xx pitch slide down
0020ff 9220 2934                 	sts noise_fx_0xy_sequence, zero //disable any 0xy effect
002101 9220 2935                 	sts noise_fx_0xy_sequence+1, zero
002103 93a0 2938                 	sts noise_fx_2xx, r26
002105 cfbf                      	rjmp sound_driver_channel3_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel3_fx_3xx:
002106 cfbe                      	rjmp sound_driver_channel3_main
                                 
                                 //VIBRATO
                                 sound_driver_channel3_fx_4xy:
002107 2fba                      	mov r27, r26
002108 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
002109 95a2                      	swap r26
00210a 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
00210b 93a0 293a                 	sts noise_fx_4xy_speed, r26
00210d 93b0 293b                 	sts noise_fx_4xy_depth, r27
00210f 9220 293c                 	sts noise_fx_4xy_phase, zero //reset the phase to 0
002111 9220 293d                 	sts noise_fx_4xy_offset, zero
002113 cfb1                      	rjmp sound_driver_channel3_main
                                 
                                 //TREMELO
                                 sound_driver_channel3_fx_7xy:
002114 2fba                      	mov r27, r26
002115 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
002116 95a2                      	swap r26
002117 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
002118 93a0 293e                 	sts noise_fx_7xy_speed, r26
00211a 93b0 293f                 	sts noise_fx_7xy_depth, r27
00211c 9220 2940                 	sts noise_fx_7xy_phase, zero //reset the phase to 0
00211e 9220 2941                 	sts noise_fx_7xy_value, zero //reset the tremelo value
002120 cfa4                      	rjmp sound_driver_channel3_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel3_fx_Axy:
002121 93a0 2942                 	sts noise_fx_Axy, r26
002123 cfa1                      	rjmp sound_driver_channel3_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel3_fx_Bxx:
002124 93a0 2820                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
002126 cf9e                      	rjmp sound_driver_channel3_main
                                 
                                 //HALT
                                 sound_driver_channel3_fx_Cxx:
002127 93b0 2821                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
002129 cf9b                      	rjmp sound_driver_channel3_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel3_fx_Dxx:
00212a 93b0 2822                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
00212c cf98                      	rjmp sound_driver_channel3_main
                                 
                                 //VOLUME
                                 sound_driver_channel3_fx_Exx:
00212d 91b0 2813                 	lds r27, noise_param
00212f 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
002130 2bba                      	or r27, r26 //move new VVVV bits into noise_param
002131 93b0 2813                 	sts noise_param, r27
002133 cf91                      	rjmp sound_driver_channel3_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel3_fx_Fxx:
002134 93a0 281f                 	sts song_speed, r26 //NOTE: only changes to speed are supported
002136 cf8e                      	rjmp sound_driver_channel3_main
                                 
                                 //DELAY
                                 sound_driver_channel3_fx_Gxx:
002137 15a2                      	cp r26, zero
002138 f051                      	breq sound_driver_channel3_fx_Gxx_invalid
002139 91b0 281f                 	lds r27, song_speed
00213b 17ab                      	cp r26, r27
00213c f430                      	brsh sound_driver_channel3_fx_Gxx_invalid
00213d 93a0 2943                 	sts noise_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
00213f e0b1                      	ldi r27, 0x01
002140 93b0 2913                 	sts noise_pattern_delay_rows, r27
002142 c13e                      	rjmp sound_driver_channel4
                                 sound_driver_channel3_fx_Gxx_invalid:
002143 cf81                      	rjmp sound_driver_channel3_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel3_fx_Hxy: //hardware sweep up
002144 cf80                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Ixy: //hardware sweep down
002145 cf7f                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Hxx: //FDS modulation depth
002146 cf7e                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Ixx: //FDS modulation speed
002147 cf7d                      	rjmp sound_driver_channel3_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel3_fx_Pxx:
002148 93a0 2945                 	sts noise_fx_Pxx_total, r26
00214a cf7a                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_Qxy: //note slide up
00214b cf79                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Rxy: //note slide down
00214c cf78                      	rjmp sound_driver_channel3_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel3_fx_Sxx:
00214d 15a2                      	cp r26, zero
00214e f051                      	breq sound_driver_channel3_fx_Sxx_invalid
00214f 91b0 281f                 	lds r27, song_speed
002151 17ab                      	cp r26, r27
002152 f430                      	brsh sound_driver_channel3_fx_Sxx_invalid
002153 93a0 2946                 	sts noise_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
002155 e0b1                      	ldi r27, 0x01
002156 93b0 2913                 	sts noise_pattern_delay_rows, r27
002158 c128                      	rjmp sound_driver_channel4
                                 sound_driver_channel3_fx_Sxx_invalid:
002159 cf6b                      	rjmp sound_driver_channel3_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel3_fx_Vxx:
00215a 95a6                      	lsr r26
00215b 95a7                      	ror r26 //move mode bit to bit 7
00215c 91b0 2814                 	lds r27, noise_period
00215e 77bf                      	andi r27, 0b01111111
00215f 2bba                      	or r27, r26 //store the new noise mode
002160 93b0 2813                 	sts noise_param, r27
                                 
002162 776f                      	andi noise_sequence_HIGH, 0b01111111
002163 2b6a                      	or noise_sequence_HIGH, r26
002164 cf60                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_Wxx: //DPCM sample speed
002165 cf5f                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Xxx: //DPCM sample retrigger
002166 cf5e                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Yxx: //DPCM sample offset
002167 cf5d                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Zxx: //DPCM sample delta counter
002168 cf5c                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 sound_driver_channel3_note:
002169 93b0 2817                 	sts noise_note, r27
00216b 93b0 2818                 	sts noise_adjusted_note, r27
00216d e0a3                      	ldi r26, 0x03
00216e e0b2                      	ldi r27, 0x02
00216f 93b0 2919                 	sts noise_volume_macro_offset, r27 //reset all macro offsets
002171 93a0 291e                 	sts noise_arpeggio_macro_offset, r26
002173 93b0 2926                 	sts noise_pitch_macro_offset, r27
002175 93b0 292c                 	sts noise_hi_pitch_macro_offset, r27
002177 93b0 2931                 	sts noise_duty_macro_offset, r27
002179 9220 2922                 	sts noise_total_pitch_offset, zero //reset the pitch and hi pitch offset
00217b 9220 2923                 	sts noise_total_pitch_offset+1, zero
00217d 9220 2929                 	sts noise_total_hi_pitch_offset, zero
00217f 9220 2937                 	sts noise_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
002181 9220 2939                 	sts noise_fx_2xx_total, zero
002183 9220 293d                 	sts noise_fx_4xy_offset, zero
002185 d0e4                      	rcall sound_driver_channel3_increment_offset
002186 cf3e                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_volume:
002187 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
002188 91a0 2813                 	lds r26, noise_param
00218a 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
00218b 2bab                      	or r26, r27 //move new VVVV bits into noise_param
00218c 93a0 2813                 	sts noise_param, r26
00218e d0db                      	rcall sound_driver_channel3_increment_offset
00218f cf35                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_delay:
002190 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
002191 93b0 2913                 	sts noise_pattern_delay_rows, r27
002193 d0d6                      	rcall sound_driver_channel3_increment_offset
002194 c0ec                      	rjmp sound_driver_channel4
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change:
002195 9220 2917                 	sts noise_volume_macro, zero //reset all macro addresses
002197 9220 2918                 	sts noise_volume_macro+1, zero
002199 9220 291c                 	sts noise_arpeggio_macro, zero
00219b 9220 291d                 	sts noise_arpeggio_macro+1, zero
00219d 9220 2924                 	sts noise_pitch_macro, zero
00219f 9220 2925                 	sts noise_pitch_macro+1, zero
0021a1 9220 292a                 	sts noise_hi_pitch_macro, zero
0021a3 9220 292b                 	sts noise_hi_pitch_macro+1, zero
0021a5 9220 292f                 	sts noise_duty_macro, zero
0021a7 9220 2930                 	sts noise_duty_macro+1, zero
0021a9 9220 2922                 	sts noise_total_pitch_offset, zero //reset the pitch offset
0021ab 9220 2923                 	sts noise_total_pitch_offset+1, zero
0021ad 9220 2929                 	sts noise_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
0021af 9631                      	adiw Z, 1 //point to the byte next to the flag
0021b0 91b4                      	lpm r27, Z //store the instrument offset into r27
0021b1 e9ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
0021b2 e1f1                      	ldi ZH, HIGH(instruments)
0021b3 0feb                      	add ZL, r27 //point Z to offsetted instrument
0021b4 1df2                      	adc ZH, zero
0021b5 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
0021b6 1fff                      	rol ZH
0021b7 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
0021b8 91b4                      	lpm r27, Z
                                 
0021b9 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
0021ba 1fbb                      	rol r27
0021bb 2fea                      	mov ZL, r26
0021bc 2ffb                      	mov ZH, r27
0021bd 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
0021be 9632                      	adiw Z, 2 //point Z to the address of the macro
0021bf e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel3_instrument_change_macro_loop:
0021c0 95aa                      	dec r26
0021c1 f019                      	breq sound_driver_channel3_instrument_change_exit
0021c2 95b6                      	lsr r27
0021c3 f078                      	brcs sound_driver_channel3_instrument_change_load_macro
0021c4 cffb                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_exit:
0021c5 e0a3                      	ldi r26, 0x03
0021c6 e0b2                      	ldi r27, 0x02
0021c7 93b0 2919                 	sts noise_volume_macro_offset, r27 //reset all macro offsets
0021c9 93a0 291e                 	sts noise_arpeggio_macro_offset, r26
0021cb 93b0 2926                 	sts noise_pitch_macro_offset, r27
0021cd 93b0 292c                 	sts noise_hi_pitch_macro_offset, r27
0021cf 93b0 2931                 	sts noise_duty_macro_offset, r27
0021d1 d0a2                      	rcall sound_driver_channel3_increment_offset_twice
0021d2 cef2                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_load_macro:
0021d3 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
0021d4 91d5                      	lpm r29, Z+
                                 
0021d5 30a5                      	cpi r26, 5
0021d6 f039                      	breq sound_driver_channel3_instrument_change_load_macro_volume
0021d7 30a4                      	cpi r26, 4
0021d8 f079                      	breq sound_driver_channel3_instrument_change_load_macro_arpeggio
0021d9 30a3                      	cpi r26, 3
0021da f099                      	breq sound_driver_channel3_instrument_change_load_macro_pitch
0021db 30a2                      	cpi r26, 2
0021dc f0d9                      	breq sound_driver_channel3_instrument_change_load_macro_hi_pitch
0021dd c024                      	rjmp sound_driver_channel3_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel3_instrument_change_load_macro_volume:
0021de 93c0 2917                 	sts noise_volume_macro, r28
0021e0 93d0 2918                 	sts noise_volume_macro+1, r29
0021e2 d029                      	rcall sound_driver_channel3_instrument_change_read_header
0021e3 93c0 291b                 	sts noise_volume_macro_release, r28
0021e5 93d0 291a                 	sts noise_volume_macro_loop, r29
0021e7 cfd8                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 	
                                 sound_driver_channel3_instrument_change_load_macro_arpeggio:
0021e8 93c0 291c                 	sts noise_arpeggio_macro, r28
0021ea 93d0 291d                 	sts noise_arpeggio_macro+1, r29
0021ec d02a                      	rcall sound_driver_channel3_instrument_change_read_header_arpeggio
0021ed cfd2                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_pitch:
0021ee 93c0 2924                 	sts noise_pitch_macro, r28
0021f0 93d0 2925                 	sts noise_pitch_macro+1, r29
0021f2 d019                      	rcall sound_driver_channel3_instrument_change_read_header
0021f3 93c0 2928                 	sts noise_pitch_macro_release, r28
0021f5 93d0 2927                 	sts noise_pitch_macro_loop, r29
0021f7 cfc8                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_hi_pitch:
0021f8 93c0 292a                 	sts noise_hi_pitch_macro, r28
0021fa 93d0 292b                 	sts noise_hi_pitch_macro+1, r29
0021fc d00f                      	rcall sound_driver_channel3_instrument_change_read_header
0021fd 93c0 292e                 	sts noise_hi_pitch_macro_release, r28
0021ff 93d0 292d                 	sts noise_hi_pitch_macro_loop, r29
002201 cfbe                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_duty:
002202 93c0 292f                 	sts noise_duty_macro, r28
002204 93d0 2930                 	sts noise_duty_macro+1, r29
002206 d005                      	rcall sound_driver_channel3_instrument_change_read_header
002207 93c0 2933                 	sts noise_duty_macro_release, r28
002209 93d0 2932                 	sts noise_duty_macro_loop, r29
00220b cfb4                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_read_header:
00220c 93ef                      	push ZL
00220d 93ff                      	push ZH
00220e 2fec                      	mov ZL, r28
00220f 2ffd                      	mov ZH, r29
002210 0fee                      	lsl ZL
002211 1fff                      	rol ZH
002212 91c5                      	lpm r28, Z+
002213 91d4                      	lpm r29, Z
002214 91ff                      	pop ZH
002215 91ef                      	pop ZL
002216 9508                      	ret
                                 
                                 sound_driver_channel3_instrument_change_read_header_arpeggio:
002217 93ef                      	push ZL
002218 93ff                      	push ZH
002219 2fec                      	mov ZL, r28
00221a 2ffd                      	mov ZH, r29
00221b 0fee                      	lsl ZL
00221c 1fff                      	rol ZH
00221d 91c5                      	lpm r28, Z+
00221e 91d5                      	lpm r29, Z+
00221f 93c0 2920                 	sts noise_arpeggio_macro_release, r28
002221 93d0 291f                 	sts noise_arpeggio_macro_loop, r29
002223 91c4                      	lpm r28, Z
002224 93c0 2921                 	sts noise_arpeggio_macro_mode, r28
002226 91ff                      	pop ZH
002227 91ef                      	pop ZL
002228 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel3_release:
                                 sound_driver_channel3_release_volume:
002229 91b0 291b                 	lds r27, noise_volume_macro_release
00222b 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
00222c f019                      	breq sound_driver_channel3_release_arpeggio //if the macro has no release flag, check the next macro
00222d 95b3                      	inc r27
00222e 93b0 2919                 	sts noise_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel3_release_arpeggio:
002230 91b0 2920                 	lds r27, noise_arpeggio_macro_release
002232 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
002233 f019                      	breq sound_driver_channel3_release_pitch
002234 95b3                      	inc r27
002235 93b0 291e                 	sts noise_arpeggio_macro_offset, r27
                                 sound_driver_channel3_release_pitch:
002237 91b0 2928                 	lds r27, noise_pitch_macro_release
002239 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
00223a f019                      	breq sound_driver_channel3_release_hi_pitch
00223b 95b3                      	inc r27
00223c 93b0 2926                 	sts noise_pitch_macro_offset, r27
                                 sound_driver_channel3_release_hi_pitch:
00223e 91b0 292e                 	lds r27, noise_hi_pitch_macro_release
002240 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
002241 f019                      	breq sound_driver_channel3_release_duty
002242 95b3                      	inc r27
002243 93b0 292c                 	sts noise_hi_pitch_macro_offset, r27
                                 sound_driver_channel3_release_duty:
002245 91b0 2933                 	lds r27, noise_duty_macro_release
002247 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
002248 f019                      	breq sound_driver_channel3_release_exit
002249 95b3                      	inc r27
00224a 93b0 2931                 	sts noise_duty_macro_offset, r27
                                 sound_driver_channel3_release_exit:
00224c d01d                      	rcall sound_driver_channel3_increment_offset
00224d ce77                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_next_pattern:
00224e 91e0 2819                 	lds ZL, song_frames
002250 91f0 281a                 	lds ZH, song_frames+1
002252 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
002254 91b0 281c                 	lds r27, song_frame_offset+1
002256 93a0 281b                 	sts song_frame_offset, r26
002258 93b0 281c                 	sts song_frame_offset+1, r27
00225a 9616                      	adiw r27:r26, 6 //offset for channel 3
00225b 0fea                      	add ZL, r26
00225c 1ffb                      	adc ZH, r27
                                 
00225d 91a5                      	lpm r26, Z+ //load the address of the next pattern
00225e 91b4                      	lpm r27, Z
00225f 0faa                      	lsl r26
002260 1fbb                      	rol r27
002261 93a0 2911                 	sts noise_pattern, r26
002263 93b0 2912                 	sts noise_pattern+1, r27
                                 
002265 9220 2915                 	sts noise_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
002267 9220 2916                 	sts noise_pattern_offset+1, zero
002269 ce5b                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_increment_offset:
00226a 91e0 2915                 	lds ZL, noise_pattern_offset //current offset in the pattern for noise
00226c 91f0 2916                 	lds ZH, noise_pattern_offset+1
00226e 9631                      	adiw Z, 1
00226f 93e0 2915                 	sts noise_pattern_offset, ZL
002271 93f0 2916                 	sts noise_pattern_offset+1, ZH
002273 9508                      	ret
                                 
                                 sound_driver_channel3_increment_offset_twice: //used for data that takes up 2 bytes worth of space
002274 91e0 2915                 	lds ZL, noise_pattern_offset //current offset in the pattern for noise
002276 91f0 2916                 	lds ZH, noise_pattern_offset+1
002278 9632                      	adiw Z, 2 //increment the pointer twice
002279 93e0 2915                 	sts noise_pattern_offset, ZL
00227b 93f0 2916                 	sts noise_pattern_offset+1, ZH
00227d 9508                      	ret
                                 
                                 sound_driver_channel3_decrement_frame_delay:
00227e 95ba                      	dec r27
00227f 93b0 2914                 	sts noise_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel4:
002281 91a0 294a                 	lds r26, dpcm_pattern_delay_rows
002283 91b0 294b                 	lds r27, dpcm_pattern_delay_frames
002285 9610                      	adiw r27:r26, 0
002286 f009                      	breq sound_driver_channel4_main //if the pattern delay is 0, proceed with sound driver procedures
002287 c0bd                      	rjmp sound_driver_channel4_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel4_main:
002288 91e0 2948                 	lds ZL, dpcm_pattern //current pattern for dpcm
00228a 91f0 2949                 	lds ZH, dpcm_pattern+1
00228c 91a0 294c                 	lds r26, dpcm_pattern_offset //current offset in the pattern for dpcm
00228e 91b0 294d                 	lds r27, dpcm_pattern_offset+1
002290 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
002291 1ffb                      	adc ZH, r27
002292 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel4_check_if_note: //check if data is a note (0x00 - 0x56)
002293 35b7                      	cpi r27, 0x57
002294 f408                      	brsh sound_driver_channel4_check_if_volume
002295 c056                      	rjmp sound_driver_channel4_note
                                 sound_driver_channel4_check_if_volume: //check if data is volume (0x57-0x66)
002296 36b7                      	cpi r27, 0x67
002297 f408                      	brsh sound_driver_channel4_check_if_delay
002298 c071                      	rjmp sound_driver_channel4_volume
                                 sound_driver_channel4_check_if_delay: //check if data is a delay (0x67 - 0xE2)
002299 3eb3                      	cpi r27, 0xE3
00229a f408                      	brsh sound_driver_channel4_check_if_instrument
00229b c070                      	rjmp sound_driver_channel4_delay
                                 sound_driver_channel4_check_if_instrument: //check for instrument flag (0xE3)
00229c f409                      	brne sound_driver_channel4_check_if_release
00229d c073                      	rjmp sound_driver_channel4_instrument_change 
                                 sound_driver_channel4_check_if_release: //check for note release flag (0xE4)
00229e 3eb4                      	cpi r27, 0xE4
00229f f409                      	brne sound_driver_channel4_check_if_end
0022a0 c072                      	rjmp sound_driver_channel4_release
                                 sound_driver_channel4_check_if_end:
0022a1 3fbf                      	cpi r27, 0xFF
0022a2 f409                      	brne sound_driver_channel4_check_if_fx
0022a3 c071                      	rjmp sound_driver_channel4_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel4_check_if_fx: //fx flags (0xE5 - 0xFE)
0022a4 9631                      	adiw Z, 1 //point Z to the byte next to the flag
0022a5 91a4                      	lpm r26, Z //load the fx data into r26
0022a6 d094                      	rcall sound_driver_channel4_increment_offset_twice
                                 
0022a7 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
0022a8 e8ea                      	ldi ZL, LOW(channel4_fx << 1) //load in note table
0022a9 e6f1                      	ldi ZH, HIGH(channel4_fx << 1)
0022aa 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
0022ab 0feb                      	add ZL, r27 //add offset
0022ac 1df2                      	adc ZH, zero
0022ad 91c5                      	lpm r28, Z+ //load address bytes
0022ae 91d4                      	lpm r29, Z
0022af 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
0022b0 2ffd                      	mov ZH, r29
0022b1 9409                      	ijmp
                                 
                                 
                                 
                                 sound_driver_channel4_fx_0xy: //arpeggio
0022b2 cfd5                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_1xx: //pitch slide up
0022b3 cfd4                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_2xx: //pitch slide down
0022b4 cfd3                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_3xx: //automatic portamento
0022b5 cfd2                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_4xy: //vibrato
0022b6 cfd1                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_7xy: //tremelo
0022b7 cfd0                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Axy: //volume slide
0022b8 cfcf                      	rjmp sound_driver_channel4_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel4_fx_Bxx:
0022b9 93a0 2820                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
0022bb cfcc                      	rjmp sound_driver_channel4_main
                                 
                                 //HALT
                                 sound_driver_channel4_fx_Cxx:
0022bc 93b0 2821                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
0022be cfc9                      	rjmp sound_driver_channel4_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel4_fx_Dxx:
0022bf 93b0 2822                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
0022c1 cfc6                      	rjmp sound_driver_channel4_main
                                 
                                 sound_driver_channel4_fx_Exx: //volume
0022c2 cfc5                      	rjmp sound_driver_channel4_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel4_fx_Fxx:
0022c3 93a0 281f                 	sts song_speed, r26 //NOTE: only changes to speed are supported
0022c5 cfc2                      	rjmp sound_driver_channel4_main
                                 
                                 //DELAY
                                 sound_driver_channel4_fx_Gxx:
0022c6 15a2                      	cp r26, zero
0022c7 f051                      	breq sound_driver_channel4_fx_Gxx_invalid
0022c8 91b0 281f                 	lds r27, song_speed
0022ca 17ab                      	cp r26, r27
0022cb f430                      	brsh sound_driver_channel4_fx_Gxx_invalid
0022cc 93a0 2952                 	sts dpcm_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
0022ce e0b1                      	ldi r27, 0x01
0022cf 93b0 294a                 	sts dpcm_pattern_delay_rows, r27
0022d1 c076                      	rjmp sound_driver_calculate_delays
                                 sound_driver_channel4_fx_Gxx_invalid:
0022d2 cfb5                      	rjmp sound_driver_channel4_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel4_fx_Hxy: //hardware sweep up
0022d3 cfb4                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Ixy: //hardware sweep down
0022d4 cfb3                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Hxx: //FDS modulation depth
0022d5 cfb2                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Ixx: //FDS modulation speed
0022d6 cfb1                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Pxx: //fine pitch
0022d7 cfb0                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Qxy: //note slide up
0022d8 cfaf                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Rxy: //note slide down
0022d9 cfae                      	rjmp sound_driver_channel4_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel4_fx_Sxx:
0022da 15a2                      	cp r26, zero
0022db f051                      	breq sound_driver_channel4_fx_Sxx_invalid
0022dc 91b0 281f                 	lds r27, song_speed
0022de 17ab                      	cp r26, r27
0022df f430                      	brsh sound_driver_channel4_fx_Sxx_invalid
0022e0 93a0 2954                 	sts dpcm_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
0022e2 e0b1                      	ldi r27, 0x01
0022e3 93b0 294a                 	sts dpcm_pattern_delay_rows, r27
0022e5 c062                      	rjmp sound_driver_calculate_delays
                                 sound_driver_channel4_fx_Sxx_invalid:
0022e6 cfa1                      	rjmp sound_driver_channel4_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel4_fx_Vxx: //duty
0022e7 cfa0                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Wxx: //DPCM sample speed
0022e8 cf9f                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Xxx: //DPCM sample retrigger
0022e9 cf9e                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Yxx: //DPCM sample offset
0022ea cf9d                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Zxx: //DPCM sample delta counter
0022eb cf9c                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_note:
0022ec 9631                      	adiw Z, 1 //point to the byte next to the flag
0022ed 90f4                      	lpm dpcm_period, Z //store the DPCM sample rate into r27
0022ee e3eb                      	ldi ZL, LOW(dpcm_samples) //point Z to dpcm_samples table
0022ef e1f0                      	ldi ZH, HIGH(dpcm_samples)
0022f0 0feb                      	add ZL, r27 //point Z to offsetted sample
0022f1 1df2                      	adc ZH, zero
0022f2 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the samples's address
0022f3 1fff                      	rol ZH
0022f4 91a5                      	lpm r26, Z+ //r26:r27 now points to the sample
0022f5 91b4                      	lpm r27, Z
                                 
0022f6 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the sample's data
0022f7 1fbb                      	rol r27
0022f8 2fea                      	mov ZL, r26
0022f9 2ffb                      	mov ZH, r27
0022fa 91b4                      	lpm r27, Z //get sample length
0022fb ef70                      	ldi dpcm_length_LOW, 0b11110000
0022fc e08f                      	ldi dpcm_length_HIGH, 0b00001111
0022fd 95b2                      	swap r27
0022fe 237b                      	and dpcm_length_LOW, r27
0022ff 238b                      	and dpcm_length_HIGH, r27
                                 
002300 93e0 294e                 	sts dpcm_sample, ZL //store address to sample
002302 93f0 294f                 	sts dpcm_sample+1, ZH
002304 9230 2950                 	sts dpcm_sample_offset, one //start sample offset at 1 (0th byte was used for sample length)
002306 9220 2951                 	sts dpcm_sample_offset+1, zero
                                 
002308 d032                      	rcall sound_driver_channel4_increment_offset_twice
002309 cf7e                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_volume:
00230a d026                      	rcall sound_driver_channel4_increment_offset
00230b cf7c                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_delay:
00230c 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
00230d 93b0 294a                 	sts dpcm_pattern_delay_rows, r27
00230f d021                      	rcall sound_driver_channel4_increment_offset
002310 c037                      	rjmp sound_driver_calculate_delays
                                 
                                 
                                 
                                 sound_driver_channel4_instrument_change:
002311 d029                      	rcall sound_driver_channel4_increment_offset_twice
002312 cf75                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_release:
002313 d01d                      	rcall sound_driver_channel4_increment_offset
002314 cf73                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_next_pattern:
002315 91e0 2819                 	lds ZL, song_frames
002317 91f0 281a                 	lds ZH, song_frames+1
002319 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
00231b 91b0 281c                 	lds r27, song_frame_offset+1
00231d 93a0 281b                 	sts song_frame_offset, r26
00231f 93b0 281c                 	sts song_frame_offset+1, r27
002321 9618                      	adiw r27:r26, 8 //offset for channel 4
002322 0fea                      	add ZL, r26
002323 1ffb                      	adc ZH, r27
                                 
002324 91a5                      	lpm r26, Z+ //load the address of the next pattern
002325 91b4                      	lpm r27, Z
002326 0faa                      	lsl r26
002327 1fbb                      	rol r27
002328 93a0 2948                 	sts dpcm_pattern, r26
00232a 93b0 2949                 	sts dpcm_pattern+1, r27
                                 
00232c 9220 294c                 	sts dpcm_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
00232e 9220 294d                 	sts dpcm_pattern_offset+1, zero
002330 cf57                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_increment_offset:
002331 91e0 294c                 	lds ZL, dpcm_pattern_offset //current offset in the pattern for dpcm
002333 91f0 294d                 	lds ZH, dpcm_pattern_offset+1
002335 9631                      	adiw Z, 1
002336 93e0 294c                 	sts dpcm_pattern_offset, ZL
002338 93f0 294d                 	sts dpcm_pattern_offset+1, ZH
00233a 9508                      	ret
                                 
                                 sound_driver_channel4_increment_offset_twice: //used for data that takes up 2 bytes worth of space
00233b 91e0 294c                 	lds ZL, dpcm_pattern_offset //current offset in the pattern for dpcm
00233d 91f0 294d                 	lds ZH, dpcm_pattern_offset+1
00233f 9632                      	adiw Z, 2 //increment the pointer twice
002340 93e0 294c                 	sts dpcm_pattern_offset, ZL
002342 93f0 294d                 	sts dpcm_pattern_offset+1, ZH
002344 9508                      	ret
                                 
                                 sound_driver_channel4_decrement_frame_delay:
002345 95ba                      	dec r27
002346 93b0 294b                 	sts dpcm_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_calculate_delays:
002348 91f0 281f                 	lds r31, song_speed
00234a 2fef                      	mov r30, r31
00234b 50e1                      	subi r30, 1
                                 sound_driver_calculate_delays_pulse1:
00234c 91a0 2826                 	lds r26, pulse1_pattern_delay_frames
00234e 11a2                      	cpse r26, zero
00234f c042                      	rjmp sound_driver_calculate_delays_pulse2
002350 c000                      	rjmp sound_driver_calculate_delays_pulse1_main
                                 
                                 sound_driver_calculate_delays_pulse1_main:
002351 2faf                      	mov r26, r31 //move the speed to r26
002352 91b0 2825                 	lds r27, pulse1_pattern_delay_rows //decrement the delay rows
002354 15b2                      	cp r27, zero
002355 f409                      	brne PC+2
002356 c03b                      	rjmp sound_driver_calculate_delays_pulse2
002357 95ba                      	dec r27
002358 93b0 2825                 	sts pulse1_pattern_delay_rows, r27
00235a 11b2                      	cpse r27, zero
00235b c034                      	rjmp sound_driver_calculate_delays_pulse1_store
00235c 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx:
00235d efbf                      	ldi r27, 0xFF
00235e 91c0 2872                 	lds r28, pulse1_fx_Sxx_pre
002360 91d0 2873                 	lds r29, pulse1_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse1_Sxx_check_pre:
002362 17cb                      	cp r28, r27
002363 f009                      	breq sound_driver_calculate_delays_pulse1_Sxx_check_post
002364 c00d                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_pre
                                 sound_driver_calculate_delays_pulse1_Sxx_check_post:
002365 17db                      	cp r29, r27
002366 f009                      	breq sound_driver_calculate_delays_pulse1_Gxx
002367 c015                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx:
002368 91c0 2860                 	lds r28, pulse1_fx_Gxx_pre
00236a 91d0 2861                 	lds r29, pulse1_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse1_Gxx_check_pre:
00236c 17cb                      	cp r28, r27
00236d f009                      	breq sound_driver_calculate_delays_pulse1_Gxx_check_post
00236e c012                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_pre
                                 sound_driver_calculate_delays_pulse1_Gxx_check_post:
00236f 17db                      	cp r29, r27
002370 f0f9                      	breq sound_driver_calculate_delays_pulse1_store
002371 c01a                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_pre:
002372 93b0 2872                 	sts pulse1_fx_Sxx_pre, r27
002374 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002375 93e0 2873                 	sts pulse1_fx_Sxx_post, r30
002377 95ca                      	dec r28
002378 93c0 2826                 	sts pulse1_pattern_delay_frames, r28
00237a 2fef                      	mov r30, r31
00237b 50e1                      	subi r30, 1
00237c c015                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_post:
00237d 93b0 2873                 	sts pulse1_fx_Sxx_post, r27
00237f 2fad                      	mov r26, r29
002380 c00f                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx_pre:
002381 93b0 2860                 	sts pulse1_fx_Gxx_pre, r27
002383 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002384 93e0 2861                 	sts pulse1_fx_Gxx_post, r30
002386 95ca                      	dec r28
002387 93c0 2826                 	sts pulse1_pattern_delay_frames, r28
002389 2fef                      	mov r30, r31
00238a 50e1                      	subi r30, 1
00238b c006                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse1_Gxx_post:
00238c 93b0 2861                 	sts pulse1_fx_Gxx_post, r27
00238e 2fad                      	mov r26, r29
00238f c000                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_store:
002390 93a0 2826                 	sts pulse1_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_pulse2:
002392 91a0 2877                 	lds r26, pulse2_pattern_delay_frames
002394 11a2                      	cpse r26, zero
002395 c042                      	rjmp sound_driver_calculate_delays_triangle
002396 c000                      	rjmp sound_driver_calculate_delays_pulse2_main
                                 
                                 sound_driver_calculate_delays_pulse2_main:
002397 2faf                      	mov r26, r31 //move the speed to r26
002398 91b0 2876                 	lds r27, pulse2_pattern_delay_rows //decrement the delay rows
00239a 15b2                      	cp r27, zero
00239b f409                      	brne PC+2
00239c c03b                      	rjmp sound_driver_calculate_delays_triangle
00239d 95ba                      	dec r27
00239e 93b0 2876                 	sts pulse2_pattern_delay_rows, r27
0023a0 11b2                      	cpse r27, zero
0023a1 c034                      	rjmp sound_driver_calculate_delays_pulse2_store
0023a2 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx:
0023a3 efbf                      	ldi r27, 0xFF
0023a4 91c0 28c3                 	lds r28, pulse2_fx_Sxx_pre
0023a6 91d0 28c4                 	lds r29, pulse2_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse2_Sxx_check_pre:
0023a8 17cb                      	cp r28, r27
0023a9 f009                      	breq sound_driver_calculate_delays_pulse2_Sxx_check_post
0023aa c00d                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_pre
                                 sound_driver_calculate_delays_pulse2_Sxx_check_post:
0023ab 17db                      	cp r29, r27
0023ac f009                      	breq sound_driver_calculate_delays_pulse2_Gxx
0023ad c015                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx:
0023ae 91c0 28b1                 	lds r28, pulse2_fx_Gxx_pre
0023b0 91d0 28b2                 	lds r29, pulse2_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse2_Gxx_check_pre:
0023b2 17cb                      	cp r28, r27
0023b3 f009                      	breq sound_driver_calculate_delays_pulse2_Gxx_check_post
0023b4 c012                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_pre
                                 sound_driver_calculate_delays_pulse2_Gxx_check_post:
0023b5 17db                      	cp r29, r27
0023b6 f0f9                      	breq sound_driver_calculate_delays_pulse2_store
0023b7 c01a                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_pre:
0023b8 93b0 28c3                 	sts pulse2_fx_Sxx_pre, r27
0023ba 1bec                      	sub r30, r28 //(song speed)-1-Sxx
0023bb 93e0 28c4                 	sts pulse2_fx_Sxx_post, r30
0023bd 95ca                      	dec r28
0023be 93c0 2877                 	sts pulse2_pattern_delay_frames, r28
0023c0 2fef                      	mov r30, r31
0023c1 50e1                      	subi r30, 1
0023c2 cfcf                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_post:
0023c3 93b0 28c4                 	sts pulse2_fx_Sxx_post, r27
0023c5 2fad                      	mov r26, r29
0023c6 c00f                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx_pre:
0023c7 93b0 28b1                 	sts pulse2_fx_Gxx_pre, r27
0023c9 1bec                      	sub r30, r28 //(song speed)-1-Sxx
0023ca 93e0 28b2                 	sts pulse2_fx_Gxx_post, r30
0023cc 95ca                      	dec r28
0023cd 93c0 2877                 	sts pulse2_pattern_delay_frames, r28
0023cf 2fef                      	mov r30, r31
0023d0 50e1                      	subi r30, 1
0023d1 cfc0                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse2_Gxx_post:
0023d2 93b0 28b2                 	sts pulse2_fx_Gxx_post, r27
0023d4 2fad                      	mov r26, r29
0023d5 c000                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_store:
0023d6 93a0 2877                 	sts pulse2_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_triangle:
0023d8 91a0 28c8                 	lds r26, triangle_pattern_delay_frames
0023da 11a2                      	cpse r26, zero
0023db c042                      	rjmp sound_driver_calculate_delays_noise
0023dc c000                      	rjmp sound_driver_calculate_delays_triangle_main
                                 
                                 sound_driver_calculate_delays_triangle_main:
0023dd 2faf                      	mov r26, r31 //move the speed to r26
0023de 91b0 28c7                 	lds r27, triangle_pattern_delay_rows //decrement the delay rows
0023e0 15b2                      	cp r27, zero
0023e1 f409                      	brne PC+2
0023e2 c03b                      	rjmp sound_driver_calculate_delays_noise
0023e3 95ba                      	dec r27
0023e4 93b0 28c7                 	sts triangle_pattern_delay_rows, r27
0023e6 11b2                      	cpse r27, zero
0023e7 c034                      	rjmp sound_driver_calculate_delays_triangle_store
0023e8 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_triangle_Sxx:
0023e9 efbf                      	ldi r27, 0xFF
0023ea 91c0 290f                 	lds r28, triangle_fx_Sxx_pre
0023ec 91d0 2910                 	lds r29, triangle_fx_Sxx_post
                                 sound_driver_calculate_delays_triangle_Sxx_check_pre:
0023ee 17cb                      	cp r28, r27
0023ef f009                      	breq sound_driver_calculate_delays_triangle_Sxx_check_post
0023f0 c00d                      	rjmp sound_driver_calculate_delays_triangle_Sxx_pre
                                 sound_driver_calculate_delays_triangle_Sxx_check_post:
0023f1 17db                      	cp r29, r27
0023f2 f009                      	breq sound_driver_calculate_delays_triangle_Gxx
0023f3 c015                      	rjmp sound_driver_calculate_delays_triangle_Sxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Gxx:
0023f4 91c0 28fd                 	lds r28, triangle_fx_Gxx_pre
0023f6 91d0 28fe                 	lds r29, triangle_fx_Gxx_post
                                 sound_driver_calculate_delays_triangle_Gxx_check_pre:
0023f8 17cb                      	cp r28, r27
0023f9 f009                      	breq sound_driver_calculate_delays_triangle_Gxx_check_post
0023fa c012                      	rjmp sound_driver_calculate_delays_triangle_Gxx_pre
                                 sound_driver_calculate_delays_triangle_Gxx_check_post:
0023fb 17db                      	cp r29, r27
0023fc f0f9                      	breq sound_driver_calculate_delays_triangle_store
0023fd c01a                      	rjmp sound_driver_calculate_delays_triangle_Gxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_pre:
0023fe 93b0 290f                 	sts triangle_fx_Sxx_pre, r27
002400 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002401 93e0 2910                 	sts triangle_fx_Sxx_post, r30
002403 95ca                      	dec r28
002404 93c0 28c8                 	sts triangle_pattern_delay_frames, r28
002406 2fef                      	mov r30, r31
002407 50e1                      	subi r30, 1
002408 c015                      	rjmp sound_driver_calculate_delays_noise
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_post:
002409 93b0 2910                 	sts triangle_fx_Sxx_post, r27
00240b 2fad                      	mov r26, r29
00240c c00f                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_Gxx_pre:
00240d 93b0 28fd                 	sts triangle_fx_Gxx_pre, r27
00240f 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002410 93e0 28fe                 	sts triangle_fx_Gxx_post, r30
002412 95ca                      	dec r28
002413 93c0 28c8                 	sts triangle_pattern_delay_frames, r28
002415 2fef                      	mov r30, r31
002416 50e1                      	subi r30, 1
002417 c006                      	rjmp sound_driver_calculate_delays_noise
                                 	
                                 sound_driver_calculate_delays_triangle_Gxx_post:
002418 93b0 28fe                 	sts triangle_fx_Gxx_post, r27
00241a 2fad                      	mov r26, r29
00241b c000                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_store:
00241c 93a0 28c8                 	sts triangle_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_noise:
00241e 91a0 2914                 	lds r26, noise_pattern_delay_frames
002420 11a2                      	cpse r26, zero
002421 c042                      	rjmp sound_driver_calculate_delays_dpcm
002422 c000                      	rjmp sound_driver_calculate_delays_noise_main
                                 
                                 sound_driver_calculate_delays_noise_main:
002423 2faf                      	mov r26, r31 //move the speed to r26
002424 91b0 2913                 	lds r27, noise_pattern_delay_rows //decrement the delay rows
002426 15b2                      	cp r27, zero
002427 f409                      	brne PC+2
002428 c03b                      	rjmp sound_driver_calculate_delays_dpcm
002429 95ba                      	dec r27
00242a 93b0 2913                 	sts noise_pattern_delay_rows, r27
00242c 11b2                      	cpse r27, zero
00242d c034                      	rjmp sound_driver_calculate_delays_noise_store
00242e 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_noise_Sxx:
00242f efbf                      	ldi r27, 0xFF
002430 91c0 2946                 	lds r28, noise_fx_Sxx_pre
002432 91d0 2947                 	lds r29, noise_fx_Sxx_post
                                 sound_driver_calculate_delays_noise_Sxx_check_pre:
002434 17cb                      	cp r28, r27
002435 f009                      	breq sound_driver_calculate_delays_noise_Sxx_check_post
002436 c00d                      	rjmp sound_driver_calculate_delays_noise_Sxx_pre
                                 sound_driver_calculate_delays_noise_Sxx_check_post:
002437 17db                      	cp r29, r27
002438 f009                      	breq sound_driver_calculate_delays_noise_Gxx
002439 c015                      	rjmp sound_driver_calculate_delays_noise_Sxx_post
                                 
                                 sound_driver_calculate_delays_noise_Gxx:
00243a 91c0 2943                 	lds r28, noise_fx_Gxx_pre
00243c 91d0 2944                 	lds r29, noise_fx_Gxx_post
                                 sound_driver_calculate_delays_noise_Gxx_check_pre:
00243e 17cb                      	cp r28, r27
00243f f009                      	breq sound_driver_calculate_delays_noise_Gxx_check_post
002440 c012                      	rjmp sound_driver_calculate_delays_noise_Gxx_pre
                                 sound_driver_calculate_delays_noise_Gxx_check_post:
002441 17db                      	cp r29, r27
002442 f0f9                      	breq sound_driver_calculate_delays_noise_store
002443 c01a                      	rjmp sound_driver_calculate_delays_noise_Gxx_post
                                 
                                 sound_driver_calculate_delays_noise_Sxx_pre:
002444 93b0 2946                 	sts noise_fx_Sxx_pre, r27
002446 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002447 93e0 2947                 	sts noise_fx_Sxx_post, r30
002449 95ca                      	dec r28
00244a 93c0 2914                 	sts noise_pattern_delay_frames, r28
00244c 2fef                      	mov r30, r31
00244d 50e1                      	subi r30, 1
00244e c015                      	rjmp sound_driver_calculate_delays_dpcm
                                 
                                 sound_driver_calculate_delays_noise_Sxx_post:
00244f 93b0 2947                 	sts noise_fx_Sxx_post, r27
002451 2fad                      	mov r26, r29
002452 c00f                      	rjmp sound_driver_calculate_delays_noise_store
                                 
                                 sound_driver_calculate_delays_noise_Gxx_pre:
002453 93b0 2943                 	sts noise_fx_Gxx_pre, r27
002455 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002456 93e0 2944                 	sts noise_fx_Gxx_post, r30
002458 95ca                      	dec r28
002459 93c0 2914                 	sts noise_pattern_delay_frames, r28
00245b 2fef                      	mov r30, r31
00245c 50e1                      	subi r30, 1
00245d c006                      	rjmp sound_driver_calculate_delays_dpcm
                                 	
                                 sound_driver_calculate_delays_noise_Gxx_post:
00245e 93b0 2944                 	sts noise_fx_Gxx_post, r27
002460 2fad                      	mov r26, r29
002461 c000                      	rjmp sound_driver_calculate_delays_noise_store
                                 
                                 sound_driver_calculate_delays_noise_store:
002462 93a0 2914                 	sts noise_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_dpcm:
002464 91a0 294b                 	lds r26, dpcm_pattern_delay_frames
002466 11a2                      	cpse r26, zero
002467 c042                      	rjmp sound_driver_instrument_fx_routine
002468 c000                      	rjmp sound_driver_calculate_delays_dpcm_main
                                 
                                 sound_driver_calculate_delays_dpcm_main:
002469 2faf                      	mov r26, r31 //move the speed to r26
00246a 91b0 294a                 	lds r27, dpcm_pattern_delay_rows //decrement the delay rows
00246c 15b2                      	cp r27, zero
00246d f409                      	brne PC+2
00246e c03b                      	rjmp sound_driver_instrument_fx_routine
00246f 95ba                      	dec r27
002470 93b0 294a                 	sts dpcm_pattern_delay_rows, r27
002472 11b2                      	cpse r27, zero
002473 c034                      	rjmp sound_driver_calculate_delays_dpcm_store
002474 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_dpcm_Sxx:
002475 efbf                      	ldi r27, 0xFF
002476 91c0 2954                 	lds r28, dpcm_fx_Sxx_pre
002478 91d0 2955                 	lds r29, dpcm_fx_Sxx_post
                                 sound_driver_calculate_delays_dpcm_Sxx_check_pre:
00247a 17cb                      	cp r28, r27
00247b f009                      	breq sound_driver_calculate_delays_dpcm_Sxx_check_post
00247c c00d                      	rjmp sound_driver_calculate_delays_dpcm_Sxx_pre
                                 sound_driver_calculate_delays_dpcm_Sxx_check_post:
00247d 17db                      	cp r29, r27
00247e f009                      	breq sound_driver_calculate_delays_dpcm_Gxx
00247f c015                      	rjmp sound_driver_calculate_delays_dpcm_Sxx_post
                                 
                                 sound_driver_calculate_delays_dpcm_Gxx:
002480 91c0 2952                 	lds r28, dpcm_fx_Gxx_pre
002482 91d0 2953                 	lds r29, dpcm_fx_Gxx_post
                                 sound_driver_calculate_delays_dpcm_Gxx_check_pre:
002484 17cb                      	cp r28, r27
002485 f009                      	breq sound_driver_calculate_delays_dpcm_Gxx_check_post
002486 c012                      	rjmp sound_driver_calculate_delays_dpcm_Gxx_pre
                                 sound_driver_calculate_delays_dpcm_Gxx_check_post:
002487 17db                      	cp r29, r27
002488 f0f9                      	breq sound_driver_calculate_delays_dpcm_store
002489 c01a                      	rjmp sound_driver_calculate_delays_dpcm_Gxx_post
                                 
                                 sound_driver_calculate_delays_dpcm_Sxx_pre:
00248a 93b0 2954                 	sts dpcm_fx_Sxx_pre, r27
00248c 1bec                      	sub r30, r28 //(song speed)-1-Sxx
00248d 93e0 2955                 	sts dpcm_fx_Sxx_post, r30
00248f 95ca                      	dec r28
002490 93c0 294b                 	sts dpcm_pattern_delay_frames, r28
002492 2fef                      	mov r30, r31
002493 50e1                      	subi r30, 1
002494 c015                      	rjmp sound_driver_instrument_fx_routine
                                 
                                 sound_driver_calculate_delays_dpcm_Sxx_post:
002495 93b0 2955                 	sts dpcm_fx_Sxx_post, r27
002497 2fad                      	mov r26, r29
002498 c00f                      	rjmp sound_driver_calculate_delays_dpcm_store
                                 
                                 sound_driver_calculate_delays_dpcm_Gxx_pre:
002499 93b0 2952                 	sts dpcm_fx_Gxx_pre, r27
00249b 1bec                      	sub r30, r28 //(song speed)-1-Sxx
00249c 93e0 2953                 	sts dpcm_fx_Gxx_post, r30
00249e 95ca                      	dec r28
00249f 93c0 294b                 	sts dpcm_pattern_delay_frames, r28
0024a1 2fef                      	mov r30, r31
0024a2 50e1                      	subi r30, 1
0024a3 c006                      	rjmp sound_driver_instrument_fx_routine
                                 	
                                 sound_driver_calculate_delays_dpcm_Gxx_post:
0024a4 93b0 2953                 	sts dpcm_fx_Gxx_post, r27
0024a6 2fad                      	mov r26, r29
0024a7 c000                      	rjmp sound_driver_calculate_delays_dpcm_store
                                 
                                 sound_driver_calculate_delays_dpcm_store:
0024a8 93a0 294b                 	sts dpcm_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_instrument_fx_routine:
                                 sound_driver_instrument_routine_channel0_volume:
0024aa 91e0 2829                 	lds ZL, pulse1_volume_macro
0024ac 91f0 282a                 	lds ZH, pulse1_volume_macro+1
0024ae 9630                      	adiw Z, 0
0024af f1a1                      	breq sound_driver_instrument_routine_channel0_volume_default //if no volume macro is in use, use default multiplier of F
0024b0 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0024b1 1fff                      	rol ZH
0024b2 91a0 282b                 	lds r26, pulse1_volume_macro_offset
0024b4 0fea                      	add ZL, r26
0024b5 1df2                      	adc ZH, zero
                                 
0024b6 91b0 282d                 	lds r27, pulse1_volume_macro_release
0024b8 17ba                      	cp r27, r26
0024b9 f429                      	brne sound_driver_instrument_routine_channel0_volume_increment //if the current offset is not equal to the release index, increment the offset
0024ba 91a0 282c                 	lds r26, pulse1_volume_macro_loop
0024bc 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0024bd f010                      	brlo sound_driver_instrument_routine_channel0_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0024be c003                      	rjmp sound_driver_instrument_routine_channel0_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_volume_increment:
0024bf 95a3                      	inc r26 //increment the macro offset
0024c0 93a0 282b                 	sts pulse1_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_volume_read:
0024c2 91b4                      	lpm r27, Z //load volume data into r27
0024c3 3fbf                      	cpi r27, 0xFF //check for macro end flag
0024c4 f469                      	brne sound_driver_instrument_routine_channel0_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_release:
0024c5 91b0 282d                 	lds r27, pulse1_volume_macro_release
0024c7 3fbf                      	cpi r27, 0xFF
0024c8 f429                      	brne sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_loop:
0024c9 91b0 282c                 	lds r27, pulse1_volume_macro_loop //load the loop index
0024cb 93b0 282b                 	sts pulse1_volume_macro_offset, r27 //store the loop index into the offset
0024cd cfdc                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index:
0024ce 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
0024cf 93a0 282b                 	sts pulse1_volume_macro_offset, r26
0024d1 cfd8                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_calculate:
0024d2 ebee                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
0024d3 e6f1                      	ldi ZH, HIGH(volumes << 1)
0024d4 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
0024d5 0feb                      	add ZL, r27 //add offset to the table
0024d6 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel0_volume_load:
0024d7 91b0 2800                 	lds r27, pulse1_param //load main volume
0024d9 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
0024da 91a0 285e                 	lds r26, pulse1_fx_7xy_value
0024dc 30a0                      	cpi r26, 0x00
0024dd f481                      	brne sound_driver_instrument_routine_channel0_volume_load_7xy
                                 
0024de 0feb                      	add ZL, r27 //offset the volume table by the main volume
0024df 1df2                      	adc ZH, zero
0024e0 91b4                      	lpm r27, Z
0024e1 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
0024e3 c023                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default:
0024e4 91b0 2800                 	lds r27, pulse1_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
0024e6 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
0024e7 91a0 285e                 	lds r26, pulse1_fx_7xy_value
0024e9 30a0                      	cpi r26, 0x00
0024ea f499                      	brne sound_driver_instrument_routine_channel0_volume_default_7xy
0024eb 93b0 2806                 	sts pulse1_output_volume, r27
0024ed c019                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy:
0024ee 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
0024ef f038                      	brcs sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
0024f0 f031                      	breq sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
                                 
0024f1 0feb                      	add ZL, r27 //offset the volume table by the main volume
0024f2 1df2                      	adc ZH, zero
0024f3 91b4                      	lpm r27, Z
0024f4 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
0024f6 c010                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy_overflow:
0024f7 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
0024f8 0feb                      	add ZL, r27 //offset the volume table by the main volume
0024f9 1df2                      	adc ZH, zero
0024fa 91b4                      	lpm r27, Z
0024fb 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
0024fd c009                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default_7xy:
0024fe 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
0024ff f020                      	brcs sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
002500 f019                      	breq sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
002501 93b0 2806                 	sts pulse1_output_volume, r27
002503 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel0_volume_default_7xy_overflow:
002504 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002505 93b0 2806                 	sts pulse1_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002507 91e0 282e                 	lds ZL, pulse1_arpeggio_macro
002509 91f0 282f                 	lds ZH, pulse1_arpeggio_macro+1
00250b 9630                      	adiw Z, 0
00250c f1d9                      	breq sound_driver_instrument_routine_channel0_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
00250d 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
00250e 1fff                      	rol ZH
00250f 91a0 2830                 	lds r26, pulse1_arpeggio_macro_offset
002511 0fea                      	add ZL, r26
002512 1df2                      	adc ZH, zero
                                 
002513 91b0 2832                 	lds r27, pulse1_arpeggio_macro_release
002515 17ba                      	cp r27, r26
002516 f429                      	brne sound_driver_instrument_routine_channel0_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002517 91a0 2831                 	lds r26, pulse1_arpeggio_macro_loop
002519 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00251a f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
00251b c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_increment:
00251c 95a3                      	inc r26 //increment the macro offset
00251d 93a0 2830                 	sts pulse1_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_read:
00251f 91b4                      	lpm r27, Z //load arpeggio data into r27
002520 38b0                      	cpi r27, 0x80 //check for macro end flag
002521 f009                      	breq sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag
002522 c041                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_check_mode:
002523 50a1                      	subi r26, 1 //keep the offset at the end flag
002524 93a0 2830                 	sts pulse1_arpeggio_macro_offset, r26
002526 91b0 2833                 	lds r27, pulse1_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002528 30b1                      	cpi r27, 0x01
002529 f048                      	brlo sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_release:
00252a 91b0 2832                 	lds r27, pulse1_arpeggio_macro_release
00252c 3fbf                      	cpi r27, 0xFF
00252d f4d1                      	brne sound_driver_instrument_routine_channel0_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_loop:
00252e 91b0 2831                 	lds r27, pulse1_arpeggio_macro_loop
002530 3fbf                      	cpi r27, 0xFF
002531 f499                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002532 c015                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute:
002533 91b0 2832                 	lds r27, pulse1_arpeggio_macro_release
002535 3fbf                      	cpi r27, 0xFF
002536 f421                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_check_loop:
002537 91b0 2831                 	lds r27, pulse1_arpeggio_macro_loop //load the loop index
002539 3fbf                      	cpi r27, 0xFF //check if loop flag exists
00253a f451                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop:
00253b 91c0 2846                 	lds r28, pulse1_fx_0xy_sequence //check for 0xy effect
00253d 91d0 2847                 	lds r29, pulse1_fx_0xy_sequence+1
00253f 9620                      	adiw r29:r28, 0
002540 f469                      	brne sound_driver_instrument_routine_channel0_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002541 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002542 93a0 2830                 	sts pulse1_arpeggio_macro_offset, r26 //store the last valid index into the offset
002544 cfc2                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload:
002545 93b0 2830                 	sts pulse1_arpeggio_macro_offset, r27 //store the loop index into the offset
002547 cfbf                      	rjmp sound_driver_instrument_routine_channel0_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_default:
002548 91c0 2846                 	lds r28, pulse1_fx_0xy_sequence //load 0xy effect
00254a 91d0 2847                 	lds r29, pulse1_fx_0xy_sequence+1
00254c 9620                      	adiw r29:r28, 0 //check for 0xy effect
00254d f099                      	breq sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel0_arpeggio_default_0xy:
00254e 95d6                      	lsr r29
00254f 95c7                      	ror r28
002550 95d7                      	ror r29
002551 95c7                      	ror r28
002552 95d7                      	ror r29
002553 95c7                      	ror r28
002554 95d7                      	ror r29
002555 95c7                      	ror r28
002556 95d7                      	ror r29
002557 95d2                      	swap r29
                                 
002558 93c0 2846                 	sts pulse1_fx_0xy_sequence, r28 //store the rolled sequence
00255a 93d0 2847                 	sts pulse1_fx_0xy_sequence+1, r29
00255c 70cf                      	andi r28, 0x0F //mask out the 4 LSB
00255d 91a0 2807                 	lds r26, pulse1_note //load the current note index
00255f 0fac                      	add r26, r28 //add the note offset
002560 c02e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002561 91a0 2807                 	lds r26, pulse1_note //load the current note index
002563 c02b                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process:
002564 9220 2834                 	sts pulse1_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002566 9220 2835                 	sts pulse1_total_pitch_offset+1, zero
002568 9220 283b                 	sts pulse1_total_hi_pitch_offset, zero
00256a 91a0 2833                 	lds r26, pulse1_arpeggio_macro_mode
00256c 30a1                      	cpi r26, 0x01 //absolute mode
00256d f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_absolute
00256e f069                      	breq sound_driver_instrument_routine_channel0_arpeggio_process_fixed
00256f c00e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute:
002570 91a0 2807                 	lds r26, pulse1_note //load the current note index
002572 0fab                      	add r26, r27 //offset the note with the arpeggio data
002573 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002574 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_add:
002575 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002576 f0c0                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
002577 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002578 c016                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract:
002579 fda7                      	sbrc r26, 7 //check if result is negative
00257a e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
00257b c013                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_fixed:
00257c 2fab                      	mov r26, r27 //move the arpeggio data into r26
00257d c011                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative:
00257e 91a0 2807                 	lds r26, pulse1_note //load the current note index
002580 0fab                      	add r26, r27 //offset the note with the arpeggio data
002581 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002582 c008                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_add:
002583 93a0 2807                 	sts pulse1_note, r26 //NOTE: relative mode modifies the original note index
002585 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002586 f040                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
002587 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002588 93a0 2807                 	sts pulse1_note, r26
00258a c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract:
00258b fda7                      	sbrc r26, 7 //check if result is negative
00258c e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
00258d 93a0 2807                 	sts pulse1_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_load:
00258f e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
002590 e0f0                      	ldi ZH, HIGH(note_table << 1)
002591 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002592 0fea                      	add ZL, r26 //add offset
002593 1df2                      	adc ZH, zero
002594 91a5                      	lpm r26, Z+ //load bytes
002595 91b4                      	lpm r27, Z
002596 93a0 0a8c                 	sts TCB0_CCMPL, r26 //load the LOW bits for timer
002598 93b0 0a8d                 	sts TCB0_CCMPH, r27 //load the HIGH bits for timer
00259a 93a0 2852                 	sts pulse1_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
00259c 93b0 2853                 	sts pulse1_fx_3xx_target+1, r27
00259e c000                      	rjmp sound_driver_instrument_routine_channel0_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch:
00259f 91e0 2836                 	lds ZL, pulse1_pitch_macro
0025a1 91f0 2837                 	lds ZH, pulse1_pitch_macro+1
0025a3 9630                      	adiw Z, 0
0025a4 f409                      	brne sound_driver_instrument_routine_channel0_pitch_continue
0025a5 c023                      	rjmp sound_driver_instrument_routine_channel0_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel0_pitch_continue:
0025a6 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0025a7 1fff                      	rol ZH
0025a8 91a0 2838                 	lds r26, pulse1_pitch_macro_offset
0025aa 0fea                      	add ZL, r26
0025ab 1df2                      	adc ZH, zero
                                 
0025ac 91b0 283a                 	lds r27, pulse1_pitch_macro_release
0025ae 17ba                      	cp r27, r26
0025af f429                      	brne sound_driver_instrument_routine_channel0_pitch_increment //if the current offset is not equal to the release index, increment the offset
0025b0 91a0 2839                 	lds r26, pulse1_pitch_macro_loop
0025b2 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0025b3 f010                      	brlo sound_driver_instrument_routine_channel0_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0025b4 c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_pitch_increment:
0025b5 95a3                      	inc r26 //increment the macro offset
0025b6 93a0 2838                 	sts pulse1_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_pitch_read:
0025b8 91b4                      	lpm r27, Z //load pitch data into r27
0025b9 38b0                      	cpi r27, 0x80 //check for macro end flag
0025ba f479                      	brne sound_driver_instrument_routine_channel0_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_release:
0025bb 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0025bc 93a0 2838                 	sts pulse1_pitch_macro_offset, r26
0025be 91b0 283a                 	lds r27, pulse1_pitch_macro_release
0025c0 3fbf                      	cpi r27, 0xFF
0025c1 f439                      	brne sound_driver_instrument_routine_channel0_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_loop:
0025c2 91b0 2839                 	lds r27, pulse1_pitch_macro_loop //load the loop index
0025c4 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0025c5 f019                      	breq sound_driver_instrument_routine_channel0_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
0025c6 93b0 2838                 	sts pulse1_pitch_macro_offset, r27 //store the loop index into the offset
0025c8 cfd6                      	rjmp sound_driver_instrument_routine_channel0_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_default:
0025c9 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel0_pitch_calculate:
0025ca 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0025cb 937f                      	push r23
0025cc 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
0025cd eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0025ce 0367                      	mulsu r22, r23
0025cf 917f                      	pop r23
0025d0 916f                      	pop r22
                                 
0025d1 9416                      	lsr r1 //shift out the fractional bits
0025d2 9407                      	ror r0
0025d3 9416                      	lsr r1
0025d4 9407                      	ror r0
0025d5 9416                      	lsr r1
0025d6 9407                      	ror r0
0025d7 9416                      	lsr r1
0025d8 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_check_negative:
0025d9 fe13                      	sbrs r1, 3 //check if result was a negative number
0025da c007                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_negative:
0025db efc0                      	ldi r28, 0xF0
0025dc 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_check_divisible_8:
0025dd 70b7                      	andi r27, 0b00000111
0025de f019                      	breq sound_driver_instrument_routine_channel0_pitch_calculate_offset
                                 
0025df e0b1                      	ldi r27, 0x01
0025e0 0e0b                      	add r0, r27
0025e1 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_offset:
0025e2 91a0 2834                 	lds r26, pulse1_total_pitch_offset
0025e4 91b0 2835                 	lds r27, pulse1_total_pitch_offset+1
0025e6 0e0a                      	add r0, r26
0025e7 1e1b                      	adc r1, r27
0025e8 9200 2834                 	sts pulse1_total_pitch_offset, r0
0025ea 9210 2835                 	sts pulse1_total_pitch_offset+1, r1
0025ec 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
0025ee 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
0025f0 0da0                      	add r26, r0 //offset the timer values
0025f1 1db1                      	adc r27, r1
                                 	
0025f2 91c0 284a                 	lds r28, pulse1_fx_1xx_total
0025f4 91d0 284b                 	lds r29, pulse1_fx_1xx_total+1
0025f6 1bac                      	sub r26, r28
0025f7 0bbd                      	sbc r27, r29
0025f8 91c0 284e                 	lds r28, pulse1_fx_2xx_total
0025fa 91d0 284f                 	lds r29, pulse1_fx_2xx_total+1
0025fc 0fac                      	add r26, r28
0025fd 1fbd                      	adc r27, r29
0025fe 91c0 2862                 	lds r28, pulse1_fx_Pxx_total
002600 91d0 2863                 	lds r29, pulse1_fx_Pxx_total+1
002602 0fac                      	add r26, r28
002603 1fbd                      	adc r27, r29
002604 91c0 2869                 	lds r28, pulse1_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
002606 91d0 286a                 	lds r29, pulse1_fx_Qxy_total_offset+1
002608 1bac                      	sub r26, r28
002609 0bbd                      	sbc r27, r29
00260a 91c0 2870                 	lds r28, pulse1_fx_Rxy_total_offset
00260c 91d0 2871                 	lds r29, pulse1_fx_Rxy_total_offset+1
00260e 0fac                      	add r26, r28
00260f 1fbd                      	adc r27, r29
                                 
002610 e5c9                      	ldi r28, 0x59
002611 e0d0                      	ldi r29, 0x00
002612 17ac                      	cp r26, r28
002613 07bd                      	cpc r27, r29
002614 f030                      	brlo sound_driver_instrument_routine_channel0_pitch_min
                                 
002615 e5ca                      	ldi r28, 0x5A
002616 e5d9                      	ldi r29, 0x59
002617 17ac                      	cp r26, r28
002618 07bd                      	cpc r27, r29
002619 f420                      	brsh sound_driver_instrument_routine_channel0_pitch_max
00261a c006                      	rjmp sound_driver_instrument_routine_channel0_pitch_store
                                 
                                 sound_driver_instrument_routine_channel0_pitch_min:
00261b e5c9                      	ldi r28, 0x59
00261c e0d0                      	ldi r29, 0x00
00261d c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_store
                                 
                                 sound_driver_instrument_routine_channel0_pitch_max:
00261e e5c9                      	ldi r28, 0x59
00261f e5d9                      	ldi r29, 0x59
002620 c000                      	rjmp sound_driver_instrument_routine_channel0_pitch_store
                                 
                                 sound_driver_instrument_routine_channel0_pitch_store:
002621 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
002623 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel0_hi_pitch:
002625 91e0 283c                 	lds ZL, pulse1_hi_pitch_macro
002627 91f0 283d                 	lds ZH, pulse1_hi_pitch_macro+1
002629 9630                      	adiw Z, 0
00262a f409                      	brne sound_driver_instrument_routine_channel0_hi_pitch_continue
00262b c03c                      	rjmp sound_driver_instrument_routine_channel0_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel0_hi_pitch_continue:
00262c 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00262d 1fff                      	rol ZH
00262e 91a0 283e                 	lds r26, pulse1_hi_pitch_macro_offset
002630 0fea                      	add ZL, r26
002631 1df2                      	adc ZH, zero
                                 
002632 91b0 2840                 	lds r27, pulse1_hi_pitch_macro_release
002634 17ba                      	cp r27, r26
002635 f429                      	brne sound_driver_instrument_routine_channel0_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002636 91a0 283f                 	lds r26, pulse1_hi_pitch_macro_loop
002638 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002639 f010                      	brlo sound_driver_instrument_routine_channel0_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00263a c003                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_increment:
00263b 95a3                      	inc r26 //increment the macro offset
00263c 93a0 283e                 	sts pulse1_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_hi_pitch_read:
00263e 91b4                      	lpm r27, Z //load hi pitch data into r27
00263f 38b0                      	cpi r27, 0x80 //check for macro end flag
002640 f489                      	brne sound_driver_instrument_routine_channel0_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_release:
002641 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002642 93a0 283e                 	sts pulse1_hi_pitch_macro_offset, r26
002644 91b0 2840                 	lds r27, pulse1_hi_pitch_macro_release
002646 3fbf                      	cpi r27, 0xFF
002647 f439                      	brne sound_driver_instrument_routine_channel0_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_loop:
002648 91b0 283f                 	lds r27, pulse1_hi_pitch_macro_loop //load the loop index
00264a 3fbf                      	cpi r27, 0xFF //check if there is a loop index
00264b f019                      	breq sound_driver_instrument_routine_channel0_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
00264c 93b0 283e                 	sts pulse1_hi_pitch_macro_offset, r27 //store the loop index into the offset
00264e cfd6                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_default:
00264f 91b0 283b                 	lds r27, pulse1_total_hi_pitch_offset
002651 c005                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate:
002652 91a0 283b                 	lds r26, pulse1_total_hi_pitch_offset //load the total hi pitch offset to change
002654 0fba                      	add r27, r26
002655 93b0 283b                 	sts pulse1_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply:
002657 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002658 937f                      	push r23
002659 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
00265a eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00265b 0367                      	mulsu r22, r23
00265c 917f                      	pop r23
00265d 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_offset:
00265e 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
002660 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
002662 0da0                      	add r26, r0 //offset the timer values
002663 1db1                      	adc r27, r1
002664 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
002666 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel0_duty:
002668 91e0 2841                 	lds ZL, pulse1_duty_macro
00266a 91f0 2842                 	lds ZH, pulse1_duty_macro+1
00266c 9630                      	adiw Z, 0
00266d f1b1                      	breq sound_driver_channel0_fx_routines //if no duty macro is in use, go to the next routine
00266e 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00266f 1fff                      	rol ZH
002670 91a0 2843                 	lds r26, pulse1_duty_macro_offset
002672 0fea                      	add ZL, r26
002673 1df2                      	adc ZH, zero
                                 
002674 91b0 2845                 	lds r27, pulse1_duty_macro_release
002676 17ba                      	cp r27, r26
002677 f429                      	brne sound_driver_instrument_routine_channel0_duty_increment //if the current offset is not equal to the release index, increment the offset
002678 91a0 2844                 	lds r26, pulse1_duty_macro_loop
00267a 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00267b f010                      	brlo sound_driver_instrument_routine_channel0_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00267c c027                      	rjmp sound_driver_channel0_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel0_duty_increment:
00267d 95a3                      	inc r26 //increment the macro offset
00267e 93a0 2843                 	sts pulse1_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_duty_read:
002680 91b4                      	lpm r27, Z //load pitch data into r27
002681 3fbf                      	cpi r27, 0xFF //check for macro end flag
002682 f471                      	brne sound_driver_instrument_routine_channel0_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_release:
002683 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002684 93a0 2843                 	sts pulse1_duty_macro_offset, r26
002686 91b0 2845                 	lds r27, pulse1_duty_macro_release
002688 3fbf                      	cpi r27, 0xFF
002689 f4d1                      	brne sound_driver_channel0_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_loop:
00268a 91b0 2844                 	lds r27, pulse1_duty_macro_loop //load the loop index
00268c 3fbf                      	cpi r27, 0xFF //check if there is a loop index
00268d f0b1                      	breq sound_driver_channel0_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
00268e 93b0 2843                 	sts pulse1_duty_macro_offset, r27 //store the loop index into the offset
002690 cfd7                      	rjmp sound_driver_instrument_routine_channel0_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_load:
002691 ebe6                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
002692 e6f0                      	ldi ZH, HIGH(sequences << 1)
002693 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
002694 1df2                      	adc ZH, zero
                                 
002695 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
002696 95b7                      	ror r27
002697 95b7                      	ror r27
002698 91a0 2800                 	lds r26, pulse1_param //load r26 with pulse1_param (register $4000)
00269a 2fca                      	mov r28, r26 //store a copy of pulse1_param into r28
00269b 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
00269c 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
00269d c001                      	rjmp sound_driver_instrument_routine_channel0_duty_load_store
00269e c005                      	rjmp sound_driver_channel0_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel0_duty_load_store:
00269f 9074                      	lpm pulse1_sequence, Z //store the sequence
                                 
0026a0 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
0026a1 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
0026a2 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_routines:
                                 sound_driver_channel0_fx_1xx_routine:
0026a4 91e0 2848                 	lds ZL, pulse1_fx_1xx
0026a6 91f0 2849                 	lds ZH, pulse1_fx_1xx+1
0026a8 9630                      	adiw Z, 0
0026a9 f051                      	breq sound_driver_channel0_fx_2xx_routine
                                 
0026aa 91a0 284a                 	lds r26, pulse1_fx_1xx_total //load the rate to change the pitch by
0026ac 91b0 284b                 	lds r27, pulse1_fx_1xx_total+1
0026ae 0fae                      	add r26, ZL //increase the total offset by the rate
0026af 1fbf                      	adc r27, ZH
0026b0 93a0 284a                 	sts pulse1_fx_1xx_total, r26
0026b2 93b0 284b                 	sts pulse1_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_2xx_routine:
0026b4 91e0 284c                 	lds ZL, pulse1_fx_2xx
0026b6 91f0 284d                 	lds ZH, pulse1_fx_2xx+1
0026b8 9630                      	adiw Z, 0
0026b9 f051                      	breq sound_driver_channel0_fx_3xx_routine
                                 
0026ba 91a0 284e                 	lds r26, pulse1_fx_2xx_total //load the rate to change the pitch by
0026bc 91b0 284f                 	lds r27, pulse1_fx_2xx_total+1
0026be 0fae                      	add r26, ZL //increase the total offset by the rate
0026bf 1fbf                      	adc r27, ZH
0026c0 93a0 284e                 	sts pulse1_fx_2xx_total, r26
0026c2 93b0 284f                 	sts pulse1_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_3xx_routine:
0026c4 91e0 2854                 	lds ZL, pulse1_fx_3xx_speed
0026c6 91f0 2855                 	lds ZH, pulse1_fx_3xx_speed+1
0026c8 9630                      	adiw Z, 0
0026c9 f409                      	brne sound_driver_channel0_fx_3xx_routine_check_start
0026ca c048                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_check_start:
0026cb 91a0 2850                 	lds r26, pulse1_fx_3xx_start
0026cd 91b0 2851                 	lds r27, pulse1_fx_3xx_start+1
0026cf 9610                      	adiw r26:r27, 0
0026d0 f409                      	brne sound_driver_channel0_fx_3xx_routine_main
0026d1 c041                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_main:
0026d2 91c0 2852                 	lds r28, pulse1_fx_3xx_target
0026d4 91d0 2853                 	lds r29, pulse1_fx_3xx_target+1
                                 
0026d6 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
0026d7 07bd                      	cpc r27, r29
0026d8 f011                      	breq sound_driver_channel0_fx_3xx_routine_disable
0026d9 f030                      	brlo sound_driver_channel0_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
0026da c01f                      	rjmp sound_driver_channel0_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel0_fx_3xx_routine_disable:
0026db 9220 2850                 	sts pulse1_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
0026dd 9220 2851                 	sts pulse1_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
0026df c033                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_subtract:
0026e0 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
0026e1 0bdb                      	sbc r29, r27
0026e2 91a0 2856                 	lds r26, pulse1_fx_3xx_total_offset
0026e4 91b0 2857                 	lds r27, pulse1_fx_3xx_total_offset+1
                                 
0026e6 0fae                      	add r26, ZL //add the speed to the total offset
0026e7 1fbf                      	adc r27, ZH
0026e8 1bca                      	sub r28, r26 //invert the total difference with the total offset
0026e9 0bdb                      	sbc r29, r27
0026ea f380                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0026eb 93a0 2856                 	sts pulse1_fx_3xx_total_offset, r26 //store the new total offset
0026ed 93b0 2857                 	sts pulse1_fx_3xx_total_offset+1, r27
                                 
0026ef 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the current timer period
0026f1 91b0 0a8d                 	lds r27, TCB0_CCMPH
0026f3 1bac                      	sub r26, r28 //offset the current timer period with the total offset
0026f4 0bbd                      	sbc r27, r29
0026f5 93a0 0a8c                 	sts TCB0_CCMPL, r26
0026f7 93b0 0a8d                 	sts TCB0_CCMPH, r27
0026f9 c019                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_add:
0026fa 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
0026fb 0bbd                      	sbc r27, r29
0026fc 91c0 2856                 	lds r28, pulse1_fx_3xx_total_offset
0026fe 91d0 2857                 	lds r29, pulse1_fx_3xx_total_offset+1
                                 
002700 0fce                      	add r28, ZL //add the speed to the total offset
002701 1fdf                      	adc r29, ZH
002702 1bac                      	sub r26, r28 //invert the total difference with the total offset
002703 0bbd                      	sbc r27, r29
002704 f2b0                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002705 93c0 2856                 	sts pulse1_fx_3xx_total_offset, r28 //store the new total offset
002707 93d0 2857                 	sts pulse1_fx_3xx_total_offset+1, r29
                                 
002709 91c0 0a8c                 	lds r28, TCB0_CCMPL //load the current timer period
00270b 91d0 0a8d                 	lds r29, TCB0_CCMPH
00270d 0fca                      	add r28, r26 //offset the current timer period with the total offset
00270e 1fdb                      	adc r29, r27
00270f 93c0 0a8c                 	sts TCB0_CCMPL, r28
002711 93d0 0a8d                 	sts TCB0_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel0_fx_4xy_routine:
002713 91a0 2858                 	lds r26, pulse1_fx_4xy_speed
002715 15a2                      	cp r26, zero
002716 f409                      	brne sound_driver_channel0_fx_4xy_routine_continue
002717 c05c                      	rjmp sound_driver_channel0_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel0_fx_4xy_routine_continue:
002718 91b0 2859                 	lds r27, pulse1_fx_4xy_depth
00271a 91c0 285a                 	lds r28, pulse1_fx_4xy_phase
00271c 0fca                      	add r28, r26 //increase the phase by the speed
00271d 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
00271e f008                      	brlo sound_driver_channel0_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
00271f e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase:
002720 93c0 285a                 	sts pulse1_fx_4xy_phase, r28 //store the new phase
002722 31c0                      	cpi r28, 16
002723 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_0
002724 32c0                      	cpi r28, 32
002725 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_1
002726 33c0                      	cpi r28, 48
002727 f030                      	brlo sound_driver_channel0_fx_4xy_routine_phase_2
002728 c007                      	rjmp sound_driver_channel0_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_0:
002729 70cf                      	andi r28, 0x0F //mask for values 0-15
00272a c029                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_1:
00272b 6fc0                      	ori r28, 0xF0
00272c 95c0                      	com r28 //invert values 0-15
00272d c026                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_2:
00272e 70cf                      	andi r28, 0x0F //mask for values 0-15
00272f c003                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_3:
002730 6fc0                      	ori r28, 0xF0
002731 95c0                      	com r28 //invert values 0-15
002732 c000                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_add:
002733 95b2                      	swap r27 //multiply depth by 16
002734 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002735 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002736 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002737 0fec                      	add ZL, r28 //offset the table by the depth+phase
002738 1df2                      	adc ZH, zero
002739 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
00273a 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00273b 937f                      	push r23
00273c 2f6c                      	mov r22, r28 //store the vibrato value into r22
00273d eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00273e 9f67                      	mul r22, r23
00273f 917f                      	pop r23
002740 916f                      	pop r22
                                 
002741 9416                      	lsr r1 //shift out the fractional bits
002742 9407                      	ror r0
002743 9416                      	lsr r1
002744 9407                      	ror r0
002745 9416                      	lsr r1
002746 9407                      	ror r0
002747 9416                      	lsr r1
002748 9407                      	ror r0
                                 	
002749 91a0 0a8c                 	lds r26, TCB0_CCMPL
00274b 91b0 0a8d                 	lds r27, TCB0_CCMPH
00274d 0da0                      	add r26, r0
00274e 1db1                      	adc r27, r1
00274f 93a0 0a8c                 	sts TCB0_CCMPL, r26
002751 93b0 0a8d                 	sts TCB0_CCMPH, r27
002753 c020                      	rjmp sound_driver_channel0_fx_7xy_routine
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_subtract:
002754 95b2                      	swap r27 //multiply depth by 16
002755 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002756 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002757 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002758 0fec                      	add ZL, r28 //offset the table by the depth+phase
002759 1df2                      	adc ZH, zero
00275a 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
00275b 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00275c 937f                      	push r23
00275d 2f6c                      	mov r22, r28 //store the vibrato value into r22
00275e eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00275f 9f67                      	mul r22, r23
002760 917f                      	pop r23
002761 916f                      	pop r22
                                 
002762 9416                      	lsr r1 //shift out the fractional bits
002763 9407                      	ror r0
002764 9416                      	lsr r1
002765 9407                      	ror r0
002766 9416                      	lsr r1
002767 9407                      	ror r0
002768 9416                      	lsr r1
002769 9407                      	ror r0
                                 
00276a 91a0 0a8c                 	lds r26, TCB0_CCMPL
00276c 91b0 0a8d                 	lds r27, TCB0_CCMPH
00276e 19a0                      	sub r26, r0
00276f 09b1                      	sbc r27, r1
002770 93a0 0a8c                 	sts TCB0_CCMPL, r26
002772 93b0 0a8d                 	sts TCB0_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_7xy_routine:
002774 91a0 285b                 	lds r26, pulse1_fx_7xy_speed
002776 15a2                      	cp r26, zero
002777 f0e9                      	breq sound_driver_channel0_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
002778 91b0 285c                 	lds r27, pulse1_fx_7xy_depth
00277a 91c0 285d                 	lds r28, pulse1_fx_7xy_phase
00277c 0fca                      	add r28, r26 //increase the phase by the speed
00277d 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
00277e f008                      	brlo sound_driver_channel0_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
00277f e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase:
002780 93c0 285d                 	sts pulse1_fx_7xy_phase, r28 //store the new phase
002782 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
002783 ffc4                      	sbrs r28, 4
002784 c001                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_0
002785 c002                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel0_fx_7xy_routine_phase_0:
002786 70cf                      	andi r28, 0x0F //mask for values 0-15
002787 c003                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase_1:
002788 6fc0                      	ori r28, 0xF0
002789 95c0                      	com r28 //invert values 0-15
00278a c000                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_load:
00278b 95b2                      	swap r27 //multiply depth by 16
00278c 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
00278d e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00278e e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00278f 0fec                      	add ZL, r28 //offset the table by the depth+phase
002790 1df2                      	adc ZH, zero
002791 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002792 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
002793 93c0 285e                 	sts pulse1_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Axy_routine:
002795 91b0 285f                 	lds r27, pulse1_fx_Axy
002797 15b2                      	cp r27, zero
002798 f0e9                      	breq sound_driver_channel0_fx_Qxy_routine //0 means that the effect is not in use
                                 	
002799 91a0 2805                 	lds r26, pulse1_fractional_volume //load fractional volume representation of the channel
00279b 91c0 2800                 	lds r28, pulse1_param //load the integer volume representation of the channel
00279d 2fda                      	mov r29, r26 //copy fractional volume into r29
00279e 2fec                      	mov r30, r28 //copy the pulse1_param into r30
00279f 95e2                      	swap r30
0027a0 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
0027a1 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
0027a2 17ed                      	cp r30, r29 //compare the fractional and integer volumes
0027a3 f009                      	breq sound_driver_channel0_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel0_fx_Axy_routine_reload:
0027a4 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate:
0027a5 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
0027a6 c004                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_addition:
0027a7 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0027a8 f428                      	brcc sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0027a9 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
0027aa c003                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_subtraction:
0027ab 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0027ac f008                      	brcs sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0027ad e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_store:
0027ae 93a0 2805                 	sts pulse1_fractional_volume, r26 //store the new fractional volume
0027b0 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
0027b1 95a2                      	swap r26
0027b2 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
0027b3 2bca                      	or r28, r26 //store the new volume back into pulse1_param
0027b4 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel0_fx_Qxy_routine:
0027b6 91e0 2865                 	lds ZL, pulse1_fx_Qxy_target
0027b8 91f0 2866                 	lds ZH, pulse1_fx_Qxy_target+1
0027ba 9630                      	adiw Z, 0
0027bb f119                      	breq sound_driver_channel0_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
0027bc 91a0 2869                 	lds r26, pulse1_fx_Qxy_total_offset
0027be 91b0 286a                 	lds r27, pulse1_fx_Qxy_total_offset+1
0027c0 91c0 0a8c                 	lds r28, TCB0_CCMPL
0027c2 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
0027c4 1bec                      	sub ZL, r28 //calculate the difference to the target
0027c5 0bfd                      	sbc ZH, r29
0027c6 f408                      	brsh sound_driver_channel0_fx_Qxy_routine_end //if the target has been reached (or passed)
0027c7 f068                      	brlo sound_driver_channel0_fx_Qxy_routine_add
                                 
                                 sound_driver_channel0_fx_Qxy_routine_end:
0027c8 9220 2869                 	sts pulse1_fx_Qxy_total_offset, zero //turn off the effect
0027ca 9220 286a                 	sts pulse1_fx_Qxy_total_offset+1, zero
0027cc 9220 2865                 	sts pulse1_fx_Qxy_target, zero
0027ce 9220 2866                 	sts pulse1_fx_Qxy_target+1, zero
0027d0 91b0 2864                 	lds r27, pulse1_fx_Qxy_target_note
0027d2 93b0 2807                 	sts pulse1_note, r27 //replace the note with the final target note
0027d4 c00a                      	rjmp sound_driver_channel0_fx_Rxy_routine
                                 
                                 sound_driver_channel0_fx_Qxy_routine_add:
0027d5 91c0 2867                 	lds r28, pulse1_fx_Qxy_speed
0027d7 91d0 2868                 	lds r29, pulse1_fx_Qxy_speed+1
0027d9 0fac                      	add r26, r28 //increase the total offset by the speed
0027da 1fbd                      	adc r27, r29
0027db 93a0 2869                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
0027dd 93b0 286a                 	sts pulse1_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Rxy_routine:
0027df 91e0 286c                 	lds ZL, pulse1_fx_Rxy_target
0027e1 91f0 286d                 	lds ZH, pulse1_fx_Rxy_target+1
0027e3 9630                      	adiw Z, 0
0027e4 f119                      	breq sound_driver_instrument_routine_channel1_volume //if the effect is not enabled, skip the routine
                                 
0027e5 91a0 2870                 	lds r26, pulse1_fx_Rxy_total_offset
0027e7 91b0 2871                 	lds r27, pulse1_fx_Rxy_total_offset+1
0027e9 91c0 0a8c                 	lds r28, TCB0_CCMPL
0027eb 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
0027ed 1bce                      	sub r28, ZL //calculate the difference to the target
0027ee 0bdf                      	sbc r29, ZH
0027ef f408                      	brsh sound_driver_channel0_fx_Rxy_routine_end //if the target has been reached (or passed)
0027f0 f068                      	brlo sound_driver_channel0_fx_Rxy_routine_add
                                 
                                 sound_driver_channel0_fx_Rxy_routine_end:
0027f1 9220 2870                 	sts pulse1_fx_Rxy_total_offset, zero //disable the effect
0027f3 9220 2871                 	sts pulse1_fx_Rxy_total_offset+1, zero
0027f5 9220 286c                 	sts pulse1_fx_Rxy_target, zero
0027f7 9220 286d                 	sts pulse1_fx_Rxy_target+1, zero
0027f9 91b0 286b                 	lds r27, pulse1_fx_Rxy_target_note
0027fb 93b0 2807                 	sts pulse1_note, r27 //replace the note with the final target note
0027fd c00a                      	rjmp sound_driver_instrument_routine_channel1_volume
                                 
                                 sound_driver_channel0_fx_Rxy_routine_add:
0027fe 91c0 286e                 	lds r28, pulse1_fx_Rxy_speed
002800 91d0 286f                 	lds r29, pulse1_fx_Rxy_speed+1
002802 0fac                      	add r26, r28 //increase the total offset by the speed
002803 1fbd                      	adc r27, r29
002804 93a0 2870                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
002806 93b0 2871                 	sts pulse1_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume:
002808 91e0 287a                 	lds ZL, pulse2_volume_macro
00280a 91f0 287b                 	lds ZH, pulse2_volume_macro+1
00280c 9630                      	adiw Z, 0
00280d f1a1                      	breq sound_driver_instrument_routine_channel1_volume_default //if no volume macro is in use, use default multiplier of F
00280e 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
00280f 1fff                      	rol ZH
002810 91a0 287c                 	lds r26, pulse2_volume_macro_offset
002812 0fea                      	add ZL, r26
002813 1df2                      	adc ZH, zero
                                 
002814 91b0 287e                 	lds r27, pulse2_volume_macro_release
002816 17ba                      	cp r27, r26
002817 f429                      	brne sound_driver_instrument_routine_channel1_volume_increment //if the current offset is not equal to the release index, increment the offset
002818 91a0 287d                 	lds r26, pulse2_volume_macro_loop
00281a 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00281b f010                      	brlo sound_driver_instrument_routine_channel1_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00281c c003                      	rjmp sound_driver_instrument_routine_channel1_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_volume_increment:
00281d 95a3                      	inc r26 //increment the macro offset
00281e 93a0 287c                 	sts pulse2_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_volume_read:
002820 91b4                      	lpm r27, Z //load volume data into r27
002821 3fbf                      	cpi r27, 0xFF //check for macro end flag
002822 f469                      	brne sound_driver_instrument_routine_channel1_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_release:
002823 91b0 287e                 	lds r27, pulse2_volume_macro_release
002825 3fbf                      	cpi r27, 0xFF
002826 f429                      	brne sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_loop:
002827 91b0 287d                 	lds r27, pulse2_volume_macro_loop //load the loop index
002829 93b0 287c                 	sts pulse2_volume_macro_offset, r27 //store the loop index into the offset
00282b cfdc                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index:
00282c 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
00282d 93a0 287c                 	sts pulse2_volume_macro_offset, r26
00282f cfd8                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_calculate:
002830 ebee                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
002831 e6f1                      	ldi ZH, HIGH(volumes << 1)
002832 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
002833 0feb                      	add ZL, r27 //add offset to the table
002834 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel1_volume_load:
002835 91b0 2808                 	lds r27, pulse2_param //load main volume
002837 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002838 91a0 28af                 	lds r26, pulse2_fx_7xy_value
00283a 30a0                      	cpi r26, 0x00
00283b f481                      	brne sound_driver_instrument_routine_channel1_volume_load_7xy
                                 
00283c 0feb                      	add ZL, r27 //offset the volume table by the main volume
00283d 1df2                      	adc ZH, zero
00283e 91b4                      	lpm r27, Z
00283f 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
002841 c023                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default:
002842 91b0 2808                 	lds r27, pulse2_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
002844 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002845 91a0 28af                 	lds r26, pulse2_fx_7xy_value
002847 30a0                      	cpi r26, 0x00
002848 f499                      	brne sound_driver_instrument_routine_channel1_volume_default_7xy
002849 93b0 280e                 	sts pulse2_output_volume, r27
00284b c019                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy:
00284c 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
00284d f038                      	brcs sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
00284e f031                      	breq sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
                                 
00284f 0feb                      	add ZL, r27 //offset the volume table by the main volume
002850 1df2                      	adc ZH, zero
002851 91b4                      	lpm r27, Z
002852 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
002854 c010                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy_overflow:
002855 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002856 0feb                      	add ZL, r27 //offset the volume table by the main volume
002857 1df2                      	adc ZH, zero
002858 91b4                      	lpm r27, Z
002859 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
00285b c009                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default_7xy:
00285c 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
00285d f020                      	brcs sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
00285e f019                      	breq sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
00285f 93b0 280e                 	sts pulse2_output_volume, r27
002861 c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel1_volume_default_7xy_overflow:
002862 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002863 93b0 280e                 	sts pulse2_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002865 91e0 287f                 	lds ZL, pulse2_arpeggio_macro
002867 91f0 2880                 	lds ZH, pulse2_arpeggio_macro+1
002869 9630                      	adiw Z, 0
00286a f1d9                      	breq sound_driver_instrument_routine_channel1_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
00286b 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
00286c 1fff                      	rol ZH
00286d 91a0 2881                 	lds r26, pulse2_arpeggio_macro_offset
00286f 0fea                      	add ZL, r26
002870 1df2                      	adc ZH, zero
                                 
002871 91b0 2883                 	lds r27, pulse2_arpeggio_macro_release
002873 17ba                      	cp r27, r26
002874 f429                      	brne sound_driver_instrument_routine_channel1_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002875 91a0 2882                 	lds r26, pulse2_arpeggio_macro_loop
002877 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002878 f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002879 c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_increment:
00287a 95a3                      	inc r26 //increment the macro offset
00287b 93a0 2881                 	sts pulse2_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_read:
00287d 91b4                      	lpm r27, Z //load arpeggio data into r27
00287e 38b0                      	cpi r27, 0x80 //check for macro end flag
00287f f009                      	breq sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag
002880 c041                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_check_mode:
002881 50a1                      	subi r26, 1 //keep the offset at the end flag
002882 93a0 2881                 	sts pulse2_arpeggio_macro_offset, r26
002884 91b0 2884                 	lds r27, pulse2_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002886 30b1                      	cpi r27, 0x01
002887 f048                      	brlo sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_release:
002888 91b0 2883                 	lds r27, pulse2_arpeggio_macro_release
00288a 3fbf                      	cpi r27, 0xFF
00288b f4d1                      	brne sound_driver_instrument_routine_channel1_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_loop:
00288c 91b0 2882                 	lds r27, pulse2_arpeggio_macro_loop
00288e 3fbf                      	cpi r27, 0xFF
00288f f499                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002890 c015                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute:
002891 91b0 2883                 	lds r27, pulse2_arpeggio_macro_release
002893 3fbf                      	cpi r27, 0xFF
002894 f421                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_check_loop:
002895 91b0 2882                 	lds r27, pulse2_arpeggio_macro_loop //load the loop index
002897 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002898 f451                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop:
002899 91c0 2897                 	lds r28, pulse2_fx_0xy_sequence //check for 0xy effect
00289b 91d0 2898                 	lds r29, pulse2_fx_0xy_sequence+1
00289d 9620                      	adiw r29:r28, 0
00289e f469                      	brne sound_driver_instrument_routine_channel1_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
00289f 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
0028a0 93a0 2881                 	sts pulse2_arpeggio_macro_offset, r26 //store the last valid index into the offset
0028a2 cfc2                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload:
0028a3 93b0 2881                 	sts pulse2_arpeggio_macro_offset, r27 //store the loop index into the offset
0028a5 cfbf                      	rjmp sound_driver_instrument_routine_channel1_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_default:
0028a6 91c0 2897                 	lds r28, pulse2_fx_0xy_sequence //load 0xy effect
0028a8 91d0 2898                 	lds r29, pulse2_fx_0xy_sequence+1
0028aa 9620                      	adiw r29:r28, 0 //check for 0xy effect
0028ab f099                      	breq sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel1_arpeggio_default_0xy:
0028ac 95d6                      	lsr r29
0028ad 95c7                      	ror r28
0028ae 95d7                      	ror r29
0028af 95c7                      	ror r28
0028b0 95d7                      	ror r29
0028b1 95c7                      	ror r28
0028b2 95d7                      	ror r29
0028b3 95c7                      	ror r28
0028b4 95d7                      	ror r29
0028b5 95d2                      	swap r29
                                 
0028b6 93c0 2897                 	sts pulse2_fx_0xy_sequence, r28 //store the rolled sequence
0028b8 93d0 2898                 	sts pulse2_fx_0xy_sequence+1, r29
0028ba 70cf                      	andi r28, 0x0F //mask out the 4 LSB
0028bb 91a0 280f                 	lds r26, pulse2_note //load the current note index
0028bd 0fac                      	add r26, r28 //add the note offset
0028be c02e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
0028bf 91a0 280f                 	lds r26, pulse2_note //load the current note index
0028c1 c02b                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process:
0028c2 9220 2885                 	sts pulse2_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
0028c4 9220 2886                 	sts pulse2_total_pitch_offset+1, zero
0028c6 9220 288c                 	sts pulse2_total_hi_pitch_offset, zero
0028c8 91a0 2884                 	lds r26, pulse2_arpeggio_macro_mode
0028ca 30a1                      	cpi r26, 0x01 //absolute mode
0028cb f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_absolute
0028cc f069                      	breq sound_driver_instrument_routine_channel1_arpeggio_process_fixed
0028cd c00e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute:
0028ce 91a0 280f                 	lds r26, pulse2_note //load the current note index
0028d0 0fab                      	add r26, r27 //offset the note with the arpeggio data
0028d1 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0028d2 c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_add:
0028d3 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0028d4 f0c0                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
0028d5 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0028d6 c016                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract:
0028d7 fda7                      	sbrc r26, 7 //check if result is negative
0028d8 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0028d9 c013                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_fixed:
0028da 2fab                      	mov r26, r27 //move the arpeggio data into r26
0028db c011                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative:
0028dc 91a0 280f                 	lds r26, pulse2_note //load the current note index
0028de 0fab                      	add r26, r27 //offset the note with the arpeggio data
0028df fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0028e0 c008                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_add:
0028e1 93a0 280f                 	sts pulse2_note, r26 //NOTE: relative mode modifies the original note index
0028e3 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0028e4 f040                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
0028e5 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0028e6 93a0 280f                 	sts pulse2_note, r26
0028e8 c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract:
0028e9 fda7                      	sbrc r26, 7 //check if result is negative
0028ea e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0028eb 93a0 280f                 	sts pulse2_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_load:
0028ed e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0028ee e0f0                      	ldi ZH, HIGH(note_table << 1)
0028ef 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
0028f0 0fea                      	add ZL, r26 //add offset
0028f1 1df2                      	adc ZH, zero
0028f2 91a5                      	lpm r26, Z+ //load bytes
0028f3 91b4                      	lpm r27, Z
0028f4 93a0 0a9c                 	sts TCB1_CCMPL, r26 //load the LOW bits for timer
0028f6 93b0 0a9d                 	sts TCB1_CCMPH, r27 //load the HIGH bits for timer
0028f8 93a0 28a3                 	sts pulse2_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
0028fa 93b0 28a4                 	sts pulse2_fx_3xx_target+1, r27
0028fc c000                      	rjmp sound_driver_instrument_routine_channel1_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch:
0028fd 91e0 2887                 	lds ZL, pulse2_pitch_macro
0028ff 91f0 2888                 	lds ZH, pulse2_pitch_macro+1
002901 9630                      	adiw Z, 0
002902 f409                      	brne sound_driver_instrument_routine_channel1_pitch_continue
002903 c023                      	rjmp sound_driver_instrument_routine_channel1_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel1_pitch_continue:
002904 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002905 1fff                      	rol ZH
002906 91a0 2889                 	lds r26, pulse2_pitch_macro_offset
002908 0fea                      	add ZL, r26
002909 1df2                      	adc ZH, zero
                                 
00290a 91b0 288b                 	lds r27, pulse2_pitch_macro_release
00290c 17ba                      	cp r27, r26
00290d f429                      	brne sound_driver_instrument_routine_channel1_pitch_increment //if the current offset is not equal to the release index, increment the offset
00290e 91a0 288a                 	lds r26, pulse2_pitch_macro_loop
002910 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002911 f010                      	brlo sound_driver_instrument_routine_channel1_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002912 c003                      	rjmp sound_driver_instrument_routine_channel1_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_pitch_increment:
002913 95a3                      	inc r26 //increment the macro offset
002914 93a0 2889                 	sts pulse2_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_pitch_read:
002916 91b4                      	lpm r27, Z //load pitch data into r27
002917 38b0                      	cpi r27, 0x80 //check for macro end flag
002918 f479                      	brne sound_driver_instrument_routine_channel1_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_release:
002919 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00291a 93a0 2889                 	sts pulse2_pitch_macro_offset, r26
00291c 91b0 288b                 	lds r27, pulse2_pitch_macro_release
00291e 3fbf                      	cpi r27, 0xFF
00291f f439                      	brne sound_driver_instrument_routine_channel1_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_loop:
002920 91b0 288a                 	lds r27, pulse2_pitch_macro_loop //load the loop index
002922 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002923 f019                      	breq sound_driver_instrument_routine_channel1_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002924 93b0 2889                 	sts pulse2_pitch_macro_offset, r27 //store the loop index into the offset
002926 cfd6                      	rjmp sound_driver_instrument_routine_channel1_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_default:
002927 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel1_pitch_calculate:
002928 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002929 937f                      	push r23
00292a 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
00292b eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00292c 0367                      	mulsu r22, r23
00292d 917f                      	pop r23
00292e 916f                      	pop r22
                                 
00292f 9416                      	lsr r1 //shift out the fractional bits
002930 9407                      	ror r0
002931 9416                      	lsr r1
002932 9407                      	ror r0
002933 9416                      	lsr r1
002934 9407                      	ror r0
002935 9416                      	lsr r1
002936 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_check_negative:
002937 fe13                      	sbrs r1, 3 //check if result was a negative number
002938 c007                      	rjmp sound_driver_instrument_routine_channel1_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_negative:
002939 efc0                      	ldi r28, 0xF0
00293a 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_check_divisible_8:
00293b 70b7                      	andi r27, 0b00000111
00293c f019                      	breq sound_driver_instrument_routine_channel1_pitch_calculate_offset
                                 
00293d e0b1                      	ldi r27, 0x01
00293e 0e0b                      	add r0, r27
00293f 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_offset:
002940 91a0 2885                 	lds r26, pulse2_total_pitch_offset
002942 91b0 2886                 	lds r27, pulse2_total_pitch_offset+1
002944 0e0a                      	add r0, r26
002945 1e1b                      	adc r1, r27
002946 9200 2885                 	sts pulse2_total_pitch_offset, r0
002948 9210 2886                 	sts pulse2_total_pitch_offset+1, r1
00294a 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
00294c 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
00294e 0da0                      	add r26, r0 //offset the timer values
00294f 1db1                      	adc r27, r1
                                 	
002950 91c0 289b                 	lds r28, pulse2_fx_1xx_total
002952 91d0 289c                 	lds r29, pulse2_fx_1xx_total+1
002954 1bac                      	sub r26, r28
002955 0bbd                      	sbc r27, r29
002956 91c0 289f                 	lds r28, pulse2_fx_2xx_total
002958 91d0 28a0                 	lds r29, pulse2_fx_2xx_total+1
00295a 0fac                      	add r26, r28
00295b 1fbd                      	adc r27, r29
00295c 91c0 28b3                 	lds r28, pulse2_fx_Pxx_total
00295e 91d0 28b4                 	lds r29, pulse2_fx_Pxx_total+1
002960 0fac                      	add r26, r28
002961 1fbd                      	adc r27, r29
002962 91c0 28ba                 	lds r28, pulse2_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
002964 91d0 28bb                 	lds r29, pulse2_fx_Qxy_total_offset+1
002966 1bac                      	sub r26, r28
002967 0bbd                      	sbc r27, r29
002968 91c0 28c1                 	lds r28, pulse2_fx_Rxy_total_offset
00296a 91d0 28c2                 	lds r29, pulse2_fx_Rxy_total_offset+1
00296c 0fac                      	add r26, r28
00296d 1fbd                      	adc r27, r29
                                 
00296e e5c9                      	ldi r28, 0x59
00296f e0d0                      	ldi r29, 0x00
002970 17ac                      	cp r26, r28
002971 07bd                      	cpc r27, r29
002972 f030                      	brlo sound_driver_instrument_routine_channel1_pitch_min
                                 
002973 e5ca                      	ldi r28, 0x5A
002974 e5d9                      	ldi r29, 0x59
002975 17ac                      	cp r26, r28
002976 07bd                      	cpc r27, r29
002977 f420                      	brsh sound_driver_instrument_routine_channel1_pitch_max
002978 c006                      	rjmp sound_driver_instrument_routine_channel1_pitch_store
                                 
                                 sound_driver_instrument_routine_channel1_pitch_min:
002979 e5c9                      	ldi r28, 0x59
00297a e0d0                      	ldi r29, 0x00
00297b c003                      	rjmp sound_driver_instrument_routine_channel1_pitch_store
                                 
                                 sound_driver_instrument_routine_channel1_pitch_max:
00297c e5c9                      	ldi r28, 0x59
00297d e5d9                      	ldi r29, 0x59
00297e c000                      	rjmp sound_driver_instrument_routine_channel1_pitch_store
                                 
                                 sound_driver_instrument_routine_channel1_pitch_store:
00297f 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
002981 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel1_hi_pitch:
002983 91e0 288d                 	lds ZL, pulse2_hi_pitch_macro
002985 91f0 288e                 	lds ZH, pulse2_hi_pitch_macro+1
002987 9630                      	adiw Z, 0
002988 f409                      	brne sound_driver_instrument_routine_channel1_hi_pitch_continue
002989 c03c                      	rjmp sound_driver_instrument_routine_channel1_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel1_hi_pitch_continue:
00298a 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00298b 1fff                      	rol ZH
00298c 91a0 288f                 	lds r26, pulse2_hi_pitch_macro_offset
00298e 0fea                      	add ZL, r26
00298f 1df2                      	adc ZH, zero
                                 
002990 91b0 2891                 	lds r27, pulse2_hi_pitch_macro_release
002992 17ba                      	cp r27, r26
002993 f429                      	brne sound_driver_instrument_routine_channel1_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002994 91a0 2890                 	lds r26, pulse2_hi_pitch_macro_loop
002996 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002997 f010                      	brlo sound_driver_instrument_routine_channel1_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002998 c003                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_increment:
002999 95a3                      	inc r26 //increment the macro offset
00299a 93a0 288f                 	sts pulse2_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_hi_pitch_read:
00299c 91b4                      	lpm r27, Z //load hi pitch data into r27
00299d 38b0                      	cpi r27, 0x80 //check for macro end flag
00299e f489                      	brne sound_driver_instrument_routine_channel1_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_release:
00299f 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0029a0 93a0 288f                 	sts pulse2_hi_pitch_macro_offset, r26
0029a2 91b0 2891                 	lds r27, pulse2_hi_pitch_macro_release
0029a4 3fbf                      	cpi r27, 0xFF
0029a5 f439                      	brne sound_driver_instrument_routine_channel1_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_loop:
0029a6 91b0 2890                 	lds r27, pulse2_hi_pitch_macro_loop //load the loop index
0029a8 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0029a9 f019                      	breq sound_driver_instrument_routine_channel1_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
0029aa 93b0 288f                 	sts pulse2_hi_pitch_macro_offset, r27 //store the loop index into the offset
0029ac cfd6                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_default:
0029ad 91b0 288c                 	lds r27, pulse2_total_hi_pitch_offset
0029af c005                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate:
0029b0 91a0 288c                 	lds r26, pulse2_total_hi_pitch_offset //load the total hi pitch offset to change
0029b2 0fba                      	add r27, r26
0029b3 93b0 288c                 	sts pulse2_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply:
0029b5 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0029b6 937f                      	push r23
0029b7 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
0029b8 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0029b9 0367                      	mulsu r22, r23
0029ba 917f                      	pop r23
0029bb 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_offset:
0029bc 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
0029be 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
0029c0 0da0                      	add r26, r0 //offset the timer values
0029c1 1db1                      	adc r27, r1
0029c2 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
0029c4 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel1_duty:
0029c6 91e0 2892                 	lds ZL, pulse2_duty_macro
0029c8 91f0 2893                 	lds ZH, pulse2_duty_macro+1
0029ca 9630                      	adiw Z, 0
0029cb f1b1                      	breq sound_driver_channel1_fx_routines //if no duty macro is in use, go to the next routine
0029cc 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0029cd 1fff                      	rol ZH
0029ce 91a0 2894                 	lds r26, pulse2_duty_macro_offset
0029d0 0fea                      	add ZL, r26
0029d1 1df2                      	adc ZH, zero
                                 
0029d2 91b0 2896                 	lds r27, pulse2_duty_macro_release
0029d4 17ba                      	cp r27, r26
0029d5 f429                      	brne sound_driver_instrument_routine_channel1_duty_increment //if the current offset is not equal to the release index, increment the offset
0029d6 91a0 2895                 	lds r26, pulse2_duty_macro_loop
0029d8 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0029d9 f010                      	brlo sound_driver_instrument_routine_channel1_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0029da c027                      	rjmp sound_driver_channel1_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel1_duty_increment:
0029db 95a3                      	inc r26 //increment the macro offset
0029dc 93a0 2894                 	sts pulse2_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_duty_read:
0029de 91b4                      	lpm r27, Z //load pitch data into r27
0029df 3fbf                      	cpi r27, 0xFF //check for macro end flag
0029e0 f471                      	brne sound_driver_instrument_routine_channel1_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_release:
0029e1 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0029e2 93a0 2894                 	sts pulse2_duty_macro_offset, r26
0029e4 91b0 2896                 	lds r27, pulse2_duty_macro_release
0029e6 3fbf                      	cpi r27, 0xFF
0029e7 f4d1                      	brne sound_driver_channel1_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_loop:
0029e8 91b0 2895                 	lds r27, pulse2_duty_macro_loop //load the loop index
0029ea 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0029eb f0b1                      	breq sound_driver_channel1_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
0029ec 93b0 2894                 	sts pulse2_duty_macro_offset, r27 //store the loop index into the offset
0029ee cfd7                      	rjmp sound_driver_instrument_routine_channel1_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_load:
0029ef ebe6                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
0029f0 e6f0                      	ldi ZH, HIGH(sequences << 1)
0029f1 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
0029f2 1df2                      	adc ZH, zero
                                 
0029f3 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
0029f4 95b7                      	ror r27
0029f5 95b7                      	ror r27
0029f6 91a0 2808                 	lds r26, pulse2_param //load r26 with pulse2_param (register $4000)
0029f8 2fca                      	mov r28, r26 //store a copy of pulse2_param into r28
0029f9 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
0029fa 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
0029fb c001                      	rjmp sound_driver_instrument_routine_channel1_duty_load_store
0029fc c005                      	rjmp sound_driver_channel1_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel1_duty_load_store:
0029fd 90a4                      	lpm pulse2_sequence, Z //store the sequence
                                 
0029fe 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
0029ff 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
002a00 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_routines:
                                 sound_driver_channel1_fx_1xx_routine:
002a02 91e0 2899                 	lds ZL, pulse2_fx_1xx
002a04 91f0 289a                 	lds ZH, pulse2_fx_1xx+1
002a06 9630                      	adiw Z, 0
002a07 f051                      	breq sound_driver_channel1_fx_2xx_routine
                                 
002a08 91a0 289b                 	lds r26, pulse2_fx_1xx_total //load the rate to change the pitch by
002a0a 91b0 289c                 	lds r27, pulse2_fx_1xx_total+1
002a0c 0fae                      	add r26, ZL //increase the total offset by the rate
002a0d 1fbf                      	adc r27, ZH
002a0e 93a0 289b                 	sts pulse2_fx_1xx_total, r26
002a10 93b0 289c                 	sts pulse2_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_2xx_routine:
002a12 91e0 289d                 	lds ZL, pulse2_fx_2xx
002a14 91f0 289e                 	lds ZH, pulse2_fx_2xx+1
002a16 9630                      	adiw Z, 0
002a17 f051                      	breq sound_driver_channel1_fx_3xx_routine
                                 
002a18 91a0 289f                 	lds r26, pulse2_fx_2xx_total //load the rate to change the pitch by
002a1a 91b0 28a0                 	lds r27, pulse2_fx_2xx_total+1
002a1c 0fae                      	add r26, ZL //increase the total offset by the rate
002a1d 1fbf                      	adc r27, ZH
002a1e 93a0 289f                 	sts pulse2_fx_2xx_total, r26
002a20 93b0 28a0                 	sts pulse2_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_3xx_routine:
002a22 91e0 28a5                 	lds ZL, pulse2_fx_3xx_speed
002a24 91f0 28a6                 	lds ZH, pulse2_fx_3xx_speed+1
002a26 9630                      	adiw Z, 0
002a27 f409                      	brne sound_driver_channel1_fx_3xx_routine_check_start
002a28 c048                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_check_start:
002a29 91a0 28a1                 	lds r26, pulse2_fx_3xx_start
002a2b 91b0 28a2                 	lds r27, pulse2_fx_3xx_start+1
002a2d 9610                      	adiw r26:r27, 0
002a2e f409                      	brne sound_driver_channel1_fx_3xx_routine_main
002a2f c041                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_main:
002a30 91c0 28a3                 	lds r28, pulse2_fx_3xx_target
002a32 91d0 28a4                 	lds r29, pulse2_fx_3xx_target+1
                                 
002a34 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
002a35 07bd                      	cpc r27, r29
002a36 f011                      	breq sound_driver_channel1_fx_3xx_routine_disable
002a37 f030                      	brlo sound_driver_channel1_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002a38 c01f                      	rjmp sound_driver_channel1_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel1_fx_3xx_routine_disable:
002a39 9220 28a1                 	sts pulse2_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002a3b 9220 28a2                 	sts pulse2_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002a3d c033                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_subtract:
002a3e 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002a3f 0bdb                      	sbc r29, r27
002a40 91a0 28a7                 	lds r26, pulse2_fx_3xx_total_offset
002a42 91b0 28a8                 	lds r27, pulse2_fx_3xx_total_offset+1
                                 
002a44 0fae                      	add r26, ZL //add the speed to the total offset
002a45 1fbf                      	adc r27, ZH
002a46 1bca                      	sub r28, r26 //invert the total difference with the total offset
002a47 0bdb                      	sbc r29, r27
002a48 f380                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002a49 93a0 28a7                 	sts pulse2_fx_3xx_total_offset, r26 //store the new total offset
002a4b 93b0 28a8                 	sts pulse2_fx_3xx_total_offset+1, r27
                                 
002a4d 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the current timer period
002a4f 91b0 0a9d                 	lds r27, TCB1_CCMPH
002a51 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002a52 0bbd                      	sbc r27, r29
002a53 93a0 0a9c                 	sts TCB1_CCMPL, r26
002a55 93b0 0a9d                 	sts TCB1_CCMPH, r27
002a57 c019                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_add:
002a58 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002a59 0bbd                      	sbc r27, r29
002a5a 91c0 28a7                 	lds r28, pulse2_fx_3xx_total_offset
002a5c 91d0 28a8                 	lds r29, pulse2_fx_3xx_total_offset+1
                                 
002a5e 0fce                      	add r28, ZL //add the speed to the total offset
002a5f 1fdf                      	adc r29, ZH
002a60 1bac                      	sub r26, r28 //invert the total difference with the total offset
002a61 0bbd                      	sbc r27, r29
002a62 f2b0                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002a63 93c0 28a7                 	sts pulse2_fx_3xx_total_offset, r28 //store the new total offset
002a65 93d0 28a8                 	sts pulse2_fx_3xx_total_offset+1, r29
                                 
002a67 91c0 0a9c                 	lds r28, TCB1_CCMPL //load the current timer period
002a69 91d0 0a9d                 	lds r29, TCB1_CCMPH
002a6b 0fca                      	add r28, r26 //offset the current timer period with the total offset
002a6c 1fdb                      	adc r29, r27
002a6d 93c0 0a9c                 	sts TCB1_CCMPL, r28
002a6f 93d0 0a9d                 	sts TCB1_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel1_fx_4xy_routine:
002a71 91a0 28a9                 	lds r26, pulse2_fx_4xy_speed
002a73 15a2                      	cp r26, zero
002a74 f409                      	brne sound_driver_channel1_fx_4xy_routine_continue
002a75 c05c                      	rjmp sound_driver_channel1_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel1_fx_4xy_routine_continue:
002a76 91b0 28aa                 	lds r27, pulse2_fx_4xy_depth
002a78 91c0 28ab                 	lds r28, pulse2_fx_4xy_phase
002a7a 0fca                      	add r28, r26 //increase the phase by the speed
002a7b 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002a7c f008                      	brlo sound_driver_channel1_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002a7d e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase:
002a7e 93c0 28ab                 	sts pulse2_fx_4xy_phase, r28 //store the new phase
002a80 31c0                      	cpi r28, 16
002a81 f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_0
002a82 32c0                      	cpi r28, 32
002a83 f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_1
002a84 33c0                      	cpi r28, 48
002a85 f030                      	brlo sound_driver_channel1_fx_4xy_routine_phase_2
002a86 c007                      	rjmp sound_driver_channel1_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_0:
002a87 70cf                      	andi r28, 0x0F //mask for values 0-15
002a88 c029                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_1:
002a89 6fc0                      	ori r28, 0xF0
002a8a 95c0                      	com r28 //invert values 0-15
002a8b c026                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_2:
002a8c 70cf                      	andi r28, 0x0F //mask for values 0-15
002a8d c003                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_3:
002a8e 6fc0                      	ori r28, 0xF0
002a8f 95c0                      	com r28 //invert values 0-15
002a90 c000                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_add:
002a91 95b2                      	swap r27 //multiply depth by 16
002a92 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002a93 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002a94 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002a95 0fec                      	add ZL, r28 //offset the table by the depth+phase
002a96 1df2                      	adc ZH, zero
002a97 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002a98 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002a99 937f                      	push r23
002a9a 2f6c                      	mov r22, r28 //store the vibrato value into r22
002a9b eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002a9c 9f67                      	mul r22, r23
002a9d 917f                      	pop r23
002a9e 916f                      	pop r22
                                 
002a9f 9416                      	lsr r1 //shift out the fractional bits
002aa0 9407                      	ror r0
002aa1 9416                      	lsr r1
002aa2 9407                      	ror r0
002aa3 9416                      	lsr r1
002aa4 9407                      	ror r0
002aa5 9416                      	lsr r1
002aa6 9407                      	ror r0
                                 	
002aa7 91a0 0a9c                 	lds r26, TCB1_CCMPL
002aa9 91b0 0a9d                 	lds r27, TCB1_CCMPH
002aab 0da0                      	add r26, r0
002aac 1db1                      	adc r27, r1
002aad 93a0 0a9c                 	sts TCB1_CCMPL, r26
002aaf 93b0 0a9d                 	sts TCB1_CCMPH, r27
002ab1 c020                      	rjmp sound_driver_channel1_fx_7xy_routine
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_subtract:
002ab2 95b2                      	swap r27 //multiply depth by 16
002ab3 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002ab4 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002ab5 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002ab6 0fec                      	add ZL, r28 //offset the table by the depth+phase
002ab7 1df2                      	adc ZH, zero
002ab8 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002ab9 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002aba 937f                      	push r23
002abb 2f6c                      	mov r22, r28 //store the vibrato value into r22
002abc eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002abd 9f67                      	mul r22, r23
002abe 917f                      	pop r23
002abf 916f                      	pop r22
                                 
002ac0 9416                      	lsr r1 //shift out the fractional bits
002ac1 9407                      	ror r0
002ac2 9416                      	lsr r1
002ac3 9407                      	ror r0
002ac4 9416                      	lsr r1
002ac5 9407                      	ror r0
002ac6 9416                      	lsr r1
002ac7 9407                      	ror r0
                                 
002ac8 91a0 0a9c                 	lds r26, TCB1_CCMPL
002aca 91b0 0a9d                 	lds r27, TCB1_CCMPH
002acc 19a0                      	sub r26, r0
002acd 09b1                      	sbc r27, r1
002ace 93a0 0a9c                 	sts TCB1_CCMPL, r26
002ad0 93b0 0a9d                 	sts TCB1_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_7xy_routine:
002ad2 91a0 28ac                 	lds r26, pulse2_fx_7xy_speed
002ad4 15a2                      	cp r26, zero
002ad5 f0e9                      	breq sound_driver_channel1_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
002ad6 91b0 28ad                 	lds r27, pulse2_fx_7xy_depth
002ad8 91c0 28ae                 	lds r28, pulse2_fx_7xy_phase
002ada 0fca                      	add r28, r26 //increase the phase by the speed
002adb 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002adc f008                      	brlo sound_driver_channel1_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
002add e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase:
002ade 93c0 28ae                 	sts pulse2_fx_7xy_phase, r28 //store the new phase
002ae0 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
002ae1 ffc4                      	sbrs r28, 4
002ae2 c001                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_0
002ae3 c002                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel1_fx_7xy_routine_phase_0:
002ae4 70cf                      	andi r28, 0x0F //mask for values 0-15
002ae5 c003                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase_1:
002ae6 6fc0                      	ori r28, 0xF0
002ae7 95c0                      	com r28 //invert values 0-15
002ae8 c000                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_load:
002ae9 95b2                      	swap r27 //multiply depth by 16
002aea 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002aeb e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002aec e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002aed 0fec                      	add ZL, r28 //offset the table by the depth+phase
002aee 1df2                      	adc ZH, zero
002aef 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002af0 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
002af1 93c0 28af                 	sts pulse2_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Axy_routine:
002af3 91b0 28b0                 	lds r27, pulse2_fx_Axy
002af5 15b2                      	cp r27, zero
002af6 f0e9                      	breq sound_driver_channel1_fx_Qxy_routine //0 means that the effect is not in use
                                 	
002af7 91a0 280d                 	lds r26, pulse2_fractional_volume //load fractional volume representation of the channel
002af9 91c0 2808                 	lds r28, pulse2_param //load the integer volume representation of the channel
002afb 2fda                      	mov r29, r26 //copy fractional volume into r29
002afc 2fec                      	mov r30, r28 //copy the pulse2_param into r30
002afd 95e2                      	swap r30
002afe 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
002aff 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
002b00 17ed                      	cp r30, r29 //compare the fractional and integer volumes
002b01 f009                      	breq sound_driver_channel1_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel1_fx_Axy_routine_reload:
002b02 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate:
002b03 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
002b04 c004                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_addition:
002b05 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002b06 f428                      	brcc sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002b07 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
002b08 c003                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_subtraction:
002b09 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002b0a f008                      	brcs sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002b0b e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_store:
002b0c 93a0 280d                 	sts pulse2_fractional_volume, r26 //store the new fractional volume
002b0e 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
002b0f 95a2                      	swap r26
002b10 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
002b11 2bca                      	or r28, r26 //store the new volume back into pulse2_param
002b12 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel1_fx_Qxy_routine:
002b14 91e0 28b6                 	lds ZL, pulse2_fx_Qxy_target
002b16 91f0 28b7                 	lds ZH, pulse2_fx_Qxy_target+1
002b18 9630                      	adiw Z, 0
002b19 f119                      	breq sound_driver_channel1_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002b1a 91a0 28ba                 	lds r26, pulse2_fx_Qxy_total_offset
002b1c 91b0 28bb                 	lds r27, pulse2_fx_Qxy_total_offset+1
002b1e 91c0 0a9c                 	lds r28, TCB1_CCMPL
002b20 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
002b22 1bec                      	sub ZL, r28 //calculate the difference to the target
002b23 0bfd                      	sbc ZH, r29
002b24 f408                      	brsh sound_driver_channel1_fx_Qxy_routine_end //if the target has been reached (or passed)
002b25 f068                      	brlo sound_driver_channel1_fx_Qxy_routine_add
                                 
                                 sound_driver_channel1_fx_Qxy_routine_end:
002b26 9220 28ba                 	sts pulse2_fx_Qxy_total_offset, zero //turn off the effect
002b28 9220 28bb                 	sts pulse2_fx_Qxy_total_offset+1, zero
002b2a 9220 28b6                 	sts pulse2_fx_Qxy_target, zero
002b2c 9220 28b7                 	sts pulse2_fx_Qxy_target+1, zero
002b2e 91b0 28b5                 	lds r27, pulse2_fx_Qxy_target_note
002b30 93b0 280f                 	sts pulse2_note, r27 //replace the note with the final target note
002b32 c00a                      	rjmp sound_driver_channel1_fx_Rxy_routine
                                 
                                 sound_driver_channel1_fx_Qxy_routine_add:
002b33 91c0 28b8                 	lds r28, pulse2_fx_Qxy_speed
002b35 91d0 28b9                 	lds r29, pulse2_fx_Qxy_speed+1
002b37 0fac                      	add r26, r28 //increase the total offset by the speed
002b38 1fbd                      	adc r27, r29
002b39 93a0 28ba                 	sts pulse2_fx_Qxy_total_offset, r26 //store the total offset
002b3b 93b0 28bb                 	sts pulse2_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Rxy_routine:
002b3d 91e0 28bd                 	lds ZL, pulse2_fx_Rxy_target
002b3f 91f0 28be                 	lds ZH, pulse2_fx_Rxy_target+1
002b41 9630                      	adiw Z, 0
002b42 f119                      	breq sound_driver_instrument_routine_channel2_volume //if the effect is not enabled, skip the routine
                                 
002b43 91a0 28c1                 	lds r26, pulse2_fx_Rxy_total_offset
002b45 91b0 28c2                 	lds r27, pulse2_fx_Rxy_total_offset+1
002b47 91c0 0a9c                 	lds r28, TCB1_CCMPL
002b49 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
002b4b 1bce                      	sub r28, ZL //calculate the difference to the target
002b4c 0bdf                      	sbc r29, ZH
002b4d f408                      	brsh sound_driver_channel1_fx_Rxy_routine_end //if the target has been reached (or passed)
002b4e f068                      	brlo sound_driver_channel1_fx_Rxy_routine_add
                                 
                                 sound_driver_channel1_fx_Rxy_routine_end:
002b4f 9220 28c1                 	sts pulse2_fx_Rxy_total_offset, zero //disable the effect
002b51 9220 28c2                 	sts pulse2_fx_Rxy_total_offset+1, zero
002b53 9220 28bd                 	sts pulse2_fx_Rxy_target, zero
002b55 9220 28be                 	sts pulse2_fx_Rxy_target+1, zero
002b57 91b0 28bc                 	lds r27, pulse2_fx_Rxy_target_note
002b59 93b0 280f                 	sts pulse2_note, r27 //replace the note with the final target note
002b5b c00a                      	rjmp sound_driver_instrument_routine_channel2_volume
                                 
                                 sound_driver_channel1_fx_Rxy_routine_add:
002b5c 91c0 28bf                 	lds r28, pulse2_fx_Rxy_speed
002b5e 91d0 28c0                 	lds r29, pulse2_fx_Rxy_speed+1
002b60 0fac                      	add r26, r28 //increase the total offset by the speed
002b61 1fbd                      	adc r27, r29
002b62 93a0 28c1                 	sts pulse2_fx_Rxy_total_offset, r26 //store the total offset
002b64 93b0 28c2                 	sts pulse2_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume:
002b66 91e0 28cb                 	lds ZL, triangle_volume_macro
002b68 91f0 28cc                 	lds ZH, triangle_volume_macro+1
002b6a 9630                      	adiw Z, 0
002b6b f199                      	breq sound_driver_instrument_routine_channel2_volume_default //if no volume macro is in use, do nothing
002b6c 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002b6d 1fff                      	rol ZH
002b6e 91a0 28cd                 	lds r26, triangle_volume_macro_offset
002b70 0fea                      	add ZL, r26
002b71 1df2                      	adc ZH, zero
                                 
002b72 91b0 28cf                 	lds r27, triangle_volume_macro_release
002b74 17ba                      	cp r27, r26
002b75 f429                      	brne sound_driver_instrument_routine_channel2_volume_increment //if the current offset is not equal to the release index, increment the offset
002b76 91a0 28ce                 	lds r26, triangle_volume_macro_loop
002b78 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002b79 f010                      	brlo sound_driver_instrument_routine_channel2_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002b7a c003                      	rjmp sound_driver_instrument_routine_channel2_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_volume_increment:
002b7b 95a3                      	inc r26 //increment the macro offset
002b7c 93a0 28cd                 	sts triangle_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_volume_read:
002b7e 91b4                      	lpm r27, Z //load volume data into r27
002b7f 3fbf                      	cpi r27, 0xFF //check for macro end flag
002b80 f469                      	brne sound_driver_instrument_routine_channel2_volume_process //if the data was not the macro end flag
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_release:
002b81 91b0 28cf                 	lds r27, triangle_volume_macro_release
002b83 3fbf                      	cpi r27, 0xFF
002b84 f429                      	brne sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_loop:
002b85 91b0 28ce                 	lds r27, triangle_volume_macro_loop //load the loop index
002b87 93b0 28cd                 	sts triangle_volume_macro_offset, r27 //store the loop index into the offset
002b89 cfdc                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index:
002b8a 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002b8b 93a0 28cd                 	sts triangle_volume_macro_offset, r26
002b8d cfd8                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_process:
002b8e 15b2                      	cp r27, zero
002b8f f041                      	breq sound_driver_instrument_routine_channel2_volume_process_disable
                                 sound_driver_instrument_routine_channel2_volume_process_enable:
002b90 91b0 0aa5                 	lds r27, TCB2_INTCTRL
002b92 30b1                      	cpi r27, TCB_CAPT_bm
002b93 f459                      	brne sound_driver_instrument_routine_channel2_volume_default //if the channel has already been muted, don't enable it again
002b94 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
002b95 93b0 0aa5                 	sts TCB2_INTCTRL, r27
002b97 c007                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 sound_driver_instrument_routine_channel2_volume_process_disable:
002b98 9220 0aa5                 	sts TCB2_INTCTRL, zero
002b9a 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
002b9c 9220 0aad                 	sts TCB2_CCMPH, zero
002b9e c000                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_volume_default:
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002b9f 91e0 28d0                 	lds ZL, triangle_arpeggio_macro
002ba1 91f0 28d1                 	lds ZH, triangle_arpeggio_macro+1
002ba3 9630                      	adiw Z, 0
002ba4 f1d9                      	breq sound_driver_instrument_routine_channel2_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002ba5 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002ba6 1fff                      	rol ZH
002ba7 91a0 28d2                 	lds r26, triangle_arpeggio_macro_offset
002ba9 0fea                      	add ZL, r26
002baa 1df2                      	adc ZH, zero
                                 
002bab 91b0 28d4                 	lds r27, triangle_arpeggio_macro_release
002bad 17ba                      	cp r27, r26
002bae f429                      	brne sound_driver_instrument_routine_channel2_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002baf 91a0 28d3                 	lds r26, triangle_arpeggio_macro_loop
002bb1 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002bb2 f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002bb3 c003                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_increment:
002bb4 95a3                      	inc r26 //increment the macro offset
002bb5 93a0 28d2                 	sts triangle_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_read:
002bb7 91b4                      	lpm r27, Z //load arpeggio data into r27
002bb8 38b0                      	cpi r27, 0x80 //check for macro end flag
002bb9 f009                      	breq sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag
002bba c041                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_check_mode:
002bbb 50a1                      	subi r26, 1 //keep the offset at the end flag
002bbc 93a0 28d2                 	sts triangle_arpeggio_macro_offset, r26
002bbe 91b0 28d5                 	lds r27, triangle_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002bc0 30b1                      	cpi r27, 0x01
002bc1 f048                      	brlo sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_release:
002bc2 91b0 28d4                 	lds r27, triangle_arpeggio_macro_release
002bc4 3fbf                      	cpi r27, 0xFF
002bc5 f4d1                      	brne sound_driver_instrument_routine_channel2_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_loop:
002bc6 91b0 28d3                 	lds r27, triangle_arpeggio_macro_loop
002bc8 3fbf                      	cpi r27, 0xFF
002bc9 f499                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002bca c015                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute:
002bcb 91b0 28d4                 	lds r27, triangle_arpeggio_macro_release
002bcd 3fbf                      	cpi r27, 0xFF
002bce f421                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_check_loop:
002bcf 91b0 28d3                 	lds r27, triangle_arpeggio_macro_loop //load the loop index
002bd1 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002bd2 f451                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop:
002bd3 91c0 28e8                 	lds r28, triangle_fx_0xy_sequence //check for 0xy effect
002bd5 91d0 28e9                 	lds r29, triangle_fx_0xy_sequence+1
002bd7 9620                      	adiw r29:r28, 0
002bd8 f469                      	brne sound_driver_instrument_routine_channel2_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002bd9 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002bda 93a0 28d2                 	sts triangle_arpeggio_macro_offset, r26 //store the last valid index into the offset
002bdc cfc2                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload:
002bdd 93b0 28d2                 	sts triangle_arpeggio_macro_offset, r27 //store the loop index into the offset
002bdf cfbf                      	rjmp sound_driver_instrument_routine_channel2_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_default:
002be0 91c0 28e8                 	lds r28, triangle_fx_0xy_sequence //load 0xy effect
002be2 91d0 28e9                 	lds r29, triangle_fx_0xy_sequence+1
002be4 9620                      	adiw r29:r28, 0 //check for 0xy effect
002be5 f099                      	breq sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel2_arpeggio_default_0xy:
002be6 95d6                      	lsr r29
002be7 95c7                      	ror r28
002be8 95d7                      	ror r29
002be9 95c7                      	ror r28
002bea 95d7                      	ror r29
002beb 95c7                      	ror r28
002bec 95d7                      	ror r29
002bed 95c7                      	ror r28
002bee 95d7                      	ror r29
002bef 95d2                      	swap r29
                                 
002bf0 93c0 28e8                 	sts triangle_fx_0xy_sequence, r28 //store the rolled sequence
002bf2 93d0 28e9                 	sts triangle_fx_0xy_sequence+1, r29
002bf4 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002bf5 91a0 2812                 	lds r26, triangle_note //load the current note index
002bf7 0fac                      	add r26, r28 //add the note offset
002bf8 c02e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002bf9 91a0 2812                 	lds r26, triangle_note //load the current note index
002bfb c02b                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process:
002bfc 9220 28d6                 	sts triangle_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002bfe 9220 28d7                 	sts triangle_total_pitch_offset+1, zero
002c00 9220 28dd                 	sts triangle_total_hi_pitch_offset, zero
002c02 91a0 28d5                 	lds r26, triangle_arpeggio_macro_mode
002c04 30a1                      	cpi r26, 0x01 //absolute mode
002c05 f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_absolute
002c06 f069                      	breq sound_driver_instrument_routine_channel2_arpeggio_process_fixed
002c07 c00e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute:
002c08 91a0 2812                 	lds r26, triangle_note //load the current note index
002c0a 0fab                      	add r26, r27 //offset the note with the arpeggio data
002c0b fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002c0c c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_add:
002c0d 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002c0e f0c0                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
002c0f e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002c10 c016                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract:
002c11 fda7                      	sbrc r26, 7 //check if result is negative
002c12 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002c13 c013                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_fixed:
002c14 2fab                      	mov r26, r27 //move the arpeggio data into r26
002c15 c011                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative:
002c16 91a0 2812                 	lds r26, triangle_note //load the current note index
002c18 0fab                      	add r26, r27 //offset the note with the arpeggio data
002c19 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002c1a c008                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_add:
002c1b 93a0 2812                 	sts triangle_note, r26 //NOTE: relative mode modifies the original note index
002c1d 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002c1e f040                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
002c1f e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002c20 93a0 2812                 	sts triangle_note, r26
002c22 c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract:
002c23 fda7                      	sbrc r26, 7 //check if result is negative
002c24 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002c25 93a0 2812                 	sts triangle_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_load:
002c27 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
002c28 e0f0                      	ldi ZH, HIGH(note_table << 1)
002c29 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002c2a 0fea                      	add ZL, r26 //add offset
002c2b 1df2                      	adc ZH, zero
002c2c 91a5                      	lpm r26, Z+ //load bytes
002c2d 91b4                      	lpm r27, Z
002c2e 93a0 0aac                 	sts TCB2_CCMPL, r26 //load the LOW bits for timer
002c30 93b0 0aad                 	sts TCB2_CCMPH, r27 //load the HIGH bits for timer
002c32 93a0 28f4                 	sts triangle_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002c34 93b0 28f5                 	sts triangle_fx_3xx_target+1, r27
002c36 c000                      	rjmp sound_driver_instrument_routine_channel2_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch:
002c37 91e0 28d8                 	lds ZL, triangle_pitch_macro
002c39 91f0 28d9                 	lds ZH, triangle_pitch_macro+1
002c3b 9630                      	adiw Z, 0
002c3c f409                      	brne sound_driver_instrument_routine_channel2_pitch_continue
002c3d c023                      	rjmp sound_driver_instrument_routine_channel2_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel2_pitch_continue:
002c3e 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002c3f 1fff                      	rol ZH
002c40 91a0 28da                 	lds r26, triangle_pitch_macro_offset
002c42 0fea                      	add ZL, r26
002c43 1df2                      	adc ZH, zero
                                 
002c44 91b0 28dc                 	lds r27, triangle_pitch_macro_release
002c46 17ba                      	cp r27, r26
002c47 f429                      	brne sound_driver_instrument_routine_channel2_pitch_increment //if the current offset is not equal to the release index, increment the offset
002c48 91a0 28db                 	lds r26, triangle_pitch_macro_loop
002c4a 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002c4b f010                      	brlo sound_driver_instrument_routine_channel2_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002c4c c003                      	rjmp sound_driver_instrument_routine_channel2_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_pitch_increment:
002c4d 95a3                      	inc r26 //increment the macro offset
002c4e 93a0 28da                 	sts triangle_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_pitch_read:
002c50 91b4                      	lpm r27, Z //load pitch data into r27
002c51 38b0                      	cpi r27, 0x80 //check for macro end flag
002c52 f479                      	brne sound_driver_instrument_routine_channel2_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_release:
002c53 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002c54 93a0 28da                 	sts triangle_pitch_macro_offset, r26
002c56 91b0 28dc                 	lds r27, triangle_pitch_macro_release
002c58 3fbf                      	cpi r27, 0xFF
002c59 f439                      	brne sound_driver_instrument_routine_channel2_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_loop:
002c5a 91b0 28db                 	lds r27, triangle_pitch_macro_loop //load the loop index
002c5c 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002c5d f019                      	breq sound_driver_instrument_routine_channel2_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002c5e 93b0 28da                 	sts triangle_pitch_macro_offset, r27 //store the loop index into the offset
002c60 cfd6                      	rjmp sound_driver_instrument_routine_channel2_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_default:
002c61 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel2_pitch_calculate:
002c62 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002c63 937f                      	push r23
002c64 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
002c65 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002c66 0367                      	mulsu r22, r23
002c67 917f                      	pop r23
002c68 916f                      	pop r22
                                 
002c69 9416                      	lsr r1 //shift out the fractional bits
002c6a 9407                      	ror r0
002c6b 9416                      	lsr r1
002c6c 9407                      	ror r0
002c6d 9416                      	lsr r1
002c6e 9407                      	ror r0
002c6f 9416                      	lsr r1
002c70 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_check_negative:
002c71 fe13                      	sbrs r1, 3 //check if result was a negative number
002c72 c007                      	rjmp sound_driver_instrument_routine_channel2_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_negative:
002c73 efc0                      	ldi r28, 0xF0
002c74 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_check_divisible_8:
002c75 70b7                      	andi r27, 0b00000111
002c76 f019                      	breq sound_driver_instrument_routine_channel2_pitch_calculate_offset
                                 
002c77 e0b1                      	ldi r27, 0x01
002c78 0e0b                      	add r0, r27
002c79 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_offset:
002c7a 91a0 28d6                 	lds r26, triangle_total_pitch_offset
002c7c 91b0 28d7                 	lds r27, triangle_total_pitch_offset+1
002c7e 0e0a                      	add r0, r26
002c7f 1e1b                      	adc r1, r27
002c80 9200 28d6                 	sts triangle_total_pitch_offset, r0
002c82 9210 28d7                 	sts triangle_total_pitch_offset+1, r1
002c84 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
002c86 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
002c88 0da0                      	add r26, r0 //offset the timer values
002c89 1db1                      	adc r27, r1
                                 	
002c8a 91c0 28ec                 	lds r28, triangle_fx_1xx_total
002c8c 91d0 28ed                 	lds r29, triangle_fx_1xx_total+1
002c8e 1bac                      	sub r26, r28
002c8f 0bbd                      	sbc r27, r29
002c90 91c0 28f0                 	lds r28, triangle_fx_2xx_total
002c92 91d0 28f1                 	lds r29, triangle_fx_2xx_total+1
002c94 0fac                      	add r26, r28
002c95 1fbd                      	adc r27, r29
002c96 91c0 28ff                 	lds r28, triangle_fx_Pxx_total
002c98 91d0 2900                 	lds r29, triangle_fx_Pxx_total+1
002c9a 0fac                      	add r26, r28
002c9b 1fbd                      	adc r27, r29
002c9c 91c0 2906                 	lds r28, triangle_fx_Qxy_total_offset
002c9e 91d0 2907                 	lds r29, triangle_fx_Qxy_total_offset+1
002ca0 1bac                      	sub r26, r28
002ca1 0bbd                      	sbc r27, r29
002ca2 91c0 290d                 	lds r28, triangle_fx_Rxy_total_offset
002ca4 91d0 290e                 	lds r29, triangle_fx_Rxy_total_offset+1
002ca6 0fac                      	add r26, r28
002ca7 1fbd                      	adc r27, r29
                                 
002ca8 e5c9                      	ldi r28, 0x59
002ca9 e0d0                      	ldi r29, 0x00
002caa 17ac                      	cp r26, r28
002cab 07bd                      	cpc r27, r29
002cac f030                      	brlo sound_driver_instrument_routine_channel2_pitch_min
                                 
002cad e5ca                      	ldi r28, 0x5A
002cae e5d9                      	ldi r29, 0x59
002caf 17ac                      	cp r26, r28
002cb0 07bd                      	cpc r27, r29
002cb1 f420                      	brsh sound_driver_instrument_routine_channel2_pitch_max
002cb2 c006                      	rjmp sound_driver_instrument_routine_channel2_pitch_store
                                 
                                 sound_driver_instrument_routine_channel2_pitch_min:
002cb3 e5c9                      	ldi r28, 0x59
002cb4 e0d0                      	ldi r29, 0x00
002cb5 c003                      	rjmp sound_driver_instrument_routine_channel2_pitch_store
                                 
                                 sound_driver_instrument_routine_channel2_pitch_max:
002cb6 e5c9                      	ldi r28, 0x59
002cb7 e5d9                      	ldi r29, 0x59
002cb8 c000                      	rjmp sound_driver_instrument_routine_channel2_pitch_store
                                 
                                 sound_driver_instrument_routine_channel2_pitch_store:
002cb9 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
002cbb 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel2_hi_pitch:
002cbd 91e0 28de                 	lds ZL, triangle_hi_pitch_macro
002cbf 91f0 28df                 	lds ZH, triangle_hi_pitch_macro+1
002cc1 9630                      	adiw Z, 0
002cc2 f409                      	brne sound_driver_instrument_routine_channel2_hi_pitch_continue
002cc3 c03c                      	rjmp sound_driver_instrument_routine_channel2_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel2_hi_pitch_continue:
002cc4 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002cc5 1fff                      	rol ZH
002cc6 91a0 28e0                 	lds r26, triangle_hi_pitch_macro_offset
002cc8 0fea                      	add ZL, r26
002cc9 1df2                      	adc ZH, zero
                                 
002cca 91b0 28e2                 	lds r27, triangle_hi_pitch_macro_release
002ccc 17ba                      	cp r27, r26
002ccd f429                      	brne sound_driver_instrument_routine_channel2_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002cce 91a0 28e1                 	lds r26, triangle_hi_pitch_macro_loop
002cd0 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002cd1 f010                      	brlo sound_driver_instrument_routine_channel2_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002cd2 c003                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_increment:
002cd3 95a3                      	inc r26 //increment the macro offset
002cd4 93a0 28e0                 	sts triangle_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_hi_pitch_read:
002cd6 91b4                      	lpm r27, Z //load hi pitch data into r27
002cd7 38b0                      	cpi r27, 0x80 //check for macro end flag
002cd8 f489                      	brne sound_driver_instrument_routine_channel2_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_release:
002cd9 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002cda 93a0 28e0                 	sts triangle_hi_pitch_macro_offset, r26
002cdc 91b0 28e2                 	lds r27, triangle_hi_pitch_macro_release
002cde 3fbf                      	cpi r27, 0xFF
002cdf f439                      	brne sound_driver_instrument_routine_channel2_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_loop:
002ce0 91b0 28e1                 	lds r27, triangle_hi_pitch_macro_loop //load the loop index
002ce2 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002ce3 f019                      	breq sound_driver_instrument_routine_channel2_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002ce4 93b0 28e0                 	sts triangle_hi_pitch_macro_offset, r27 //store the loop index into the offset
002ce6 cfd6                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_default:
002ce7 91b0 28dd                 	lds r27, triangle_total_hi_pitch_offset
002ce9 c005                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate:
002cea 91a0 28dd                 	lds r26, triangle_total_hi_pitch_offset //load the total hi pitch offset to change
002cec 0fba                      	add r27, r26
002ced 93b0 28dd                 	sts triangle_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply:
002cef 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002cf0 937f                      	push r23
002cf1 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002cf2 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002cf3 0367                      	mulsu r22, r23
002cf4 917f                      	pop r23
002cf5 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_offset:
002cf6 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
002cf8 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
002cfa 0da0                      	add r26, r0 //offset the timer values
002cfb 1db1                      	adc r27, r1
002cfc 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
002cfe 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: The triangle channel does not have a duty cycle
                                 sound_driver_instrument_routine_channel2_duty:
                                 
                                 
                                 
                                 sound_driver_channel2_fx_routines:
                                 sound_driver_channel2_fx_1xx_routine:
002d00 91e0 28ea                 	lds ZL, triangle_fx_1xx
002d02 91f0 28eb                 	lds ZH, triangle_fx_1xx+1
002d04 9630                      	adiw Z, 0
002d05 f051                      	breq sound_driver_channel2_fx_2xx_routine
                                 
002d06 91a0 28ec                 	lds r26, triangle_fx_1xx_total //load the rate to change the pitch by
002d08 91b0 28ed                 	lds r27, triangle_fx_1xx_total+1
002d0a 0fae                      	add r26, ZL //increase the total offset by the rate
002d0b 1fbf                      	adc r27, ZH
002d0c 93a0 28ec                 	sts triangle_fx_1xx_total, r26
002d0e 93b0 28ed                 	sts triangle_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_2xx_routine:
002d10 91e0 28ee                 	lds ZL, triangle_fx_2xx
002d12 91f0 28ef                 	lds ZH, triangle_fx_2xx+1
002d14 9630                      	adiw Z, 0
002d15 f051                      	breq sound_driver_channel2_fx_3xx_routine
                                 
002d16 91a0 28f0                 	lds r26, triangle_fx_2xx_total //load the rate to change the pitch by
002d18 91b0 28f1                 	lds r27, triangle_fx_2xx_total+1
002d1a 0fae                      	add r26, ZL //increase the total offset by the rate
002d1b 1fbf                      	adc r27, ZH
002d1c 93a0 28f0                 	sts triangle_fx_2xx_total, r26
002d1e 93b0 28f1                 	sts triangle_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_3xx_routine:
002d20 91e0 28f6                 	lds ZL, triangle_fx_3xx_speed
002d22 91f0 28f7                 	lds ZH, triangle_fx_3xx_speed+1
002d24 9630                      	adiw Z, 0
002d25 f409                      	brne sound_driver_channel2_fx_3xx_routine_check_start
002d26 c048                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_check_start:
002d27 91a0 28f2                 	lds r26, triangle_fx_3xx_start
002d29 91b0 28f3                 	lds r27, triangle_fx_3xx_start+1
002d2b 9610                      	adiw r26:r27, 0
002d2c f409                      	brne sound_driver_channel2_fx_3xx_routine_main
002d2d c041                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_main:
002d2e 91c0 28f4                 	lds r28, triangle_fx_3xx_target
002d30 91d0 28f5                 	lds r29, triangle_fx_3xx_target+1
                                 
002d32 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
002d33 07bd                      	cpc r27, r29
002d34 f011                      	breq sound_driver_channel2_fx_3xx_routine_disable
002d35 f030                      	brlo sound_driver_channel2_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002d36 c01f                      	rjmp sound_driver_channel2_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel2_fx_3xx_routine_disable:
002d37 9220 28f2                 	sts triangle_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002d39 9220 28f3                 	sts triangle_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002d3b c033                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_subtract:
002d3c 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002d3d 0bdb                      	sbc r29, r27
002d3e 91a0 28f8                 	lds r26, triangle_fx_3xx_total_offset
002d40 91b0 28f9                 	lds r27, triangle_fx_3xx_total_offset+1
                                 
002d42 0fae                      	add r26, ZL //add the speed to the total offset
002d43 1fbf                      	adc r27, ZH
002d44 1bca                      	sub r28, r26 //invert the total difference with the total offset
002d45 0bdb                      	sbc r29, r27
002d46 f380                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002d47 93a0 28f8                 	sts triangle_fx_3xx_total_offset, r26 //store the new total offset
002d49 93b0 28f9                 	sts triangle_fx_3xx_total_offset+1, r27
                                 
002d4b 91a0 0aac                 	lds r26, TCB2_CCMPL //load the current timer period
002d4d 91b0 0aad                 	lds r27, TCB2_CCMPH
002d4f 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002d50 0bbd                      	sbc r27, r29
002d51 93a0 0aac                 	sts TCB2_CCMPL, r26
002d53 93b0 0aad                 	sts TCB2_CCMPH, r27
002d55 c019                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_add:
002d56 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002d57 0bbd                      	sbc r27, r29
002d58 91c0 28f8                 	lds r28, triangle_fx_3xx_total_offset
002d5a 91d0 28f9                 	lds r29, triangle_fx_3xx_total_offset+1
                                 
002d5c 0fce                      	add r28, ZL //add the speed to the total offset
002d5d 1fdf                      	adc r29, ZH
002d5e 1bac                      	sub r26, r28 //invert the total difference with the total offset
002d5f 0bbd                      	sbc r27, r29
002d60 f2b0                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002d61 93c0 28f8                 	sts triangle_fx_3xx_total_offset, r28 //store the new total offset
002d63 93d0 28f9                 	sts triangle_fx_3xx_total_offset+1, r29
                                 
002d65 91c0 0aac                 	lds r28, TCB2_CCMPL //load the current timer period
002d67 91d0 0aad                 	lds r29, TCB2_CCMPH
002d69 0fca                      	add r28, r26 //offset the current timer period with the total offset
002d6a 1fdb                      	adc r29, r27
002d6b 93c0 0aac                 	sts TCB2_CCMPL, r28
002d6d 93d0 0aad                 	sts TCB2_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel2_fx_4xy_routine:
002d6f 91a0 28fa                 	lds r26, triangle_fx_4xy_speed
002d71 15a2                      	cp r26, zero
002d72 f409                      	brne sound_driver_channel2_fx_4xy_routine_continue
002d73 c05c                      	rjmp sound_driver_channel2_fx_Qxy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel2_fx_4xy_routine_continue:
002d74 91b0 28fb                 	lds r27, triangle_fx_4xy_depth
002d76 91c0 28fc                 	lds r28, triangle_fx_4xy_phase
002d78 0fca                      	add r28, r26 //increase the phase by the speed
002d79 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002d7a f008                      	brlo sound_driver_channel2_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002d7b e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase:
002d7c 93c0 28fc                 	sts triangle_fx_4xy_phase, r28 //store the new phase
002d7e 31c0                      	cpi r28, 16
002d7f f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_0
002d80 32c0                      	cpi r28, 32
002d81 f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_1
002d82 33c0                      	cpi r28, 48
002d83 f030                      	brlo sound_driver_channel2_fx_4xy_routine_phase_2
002d84 c007                      	rjmp sound_driver_channel2_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_0:
002d85 70cf                      	andi r28, 0x0F //mask for values 0-15
002d86 c029                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_1:
002d87 6fc0                      	ori r28, 0xF0
002d88 95c0                      	com r28 //invert values 0-15
002d89 c026                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_2:
002d8a 70cf                      	andi r28, 0x0F //mask for values 0-15
002d8b c003                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_3:
002d8c 6fc0                      	ori r28, 0xF0
002d8d 95c0                      	com r28 //invert values 0-15
002d8e c000                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_add:
002d8f 95b2                      	swap r27 //multiply depth by 16
002d90 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002d91 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002d92 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002d93 0fec                      	add ZL, r28 //offset the table by the depth+phase
002d94 1df2                      	adc ZH, zero
002d95 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002d96 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002d97 937f                      	push r23
002d98 2f6c                      	mov r22, r28 //store the vibrato value into r22
002d99 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002d9a 9f67                      	mul r22, r23
002d9b 917f                      	pop r23
002d9c 916f                      	pop r22
                                 
002d9d 9416                      	lsr r1 //shift out the fractional bits
002d9e 9407                      	ror r0
002d9f 9416                      	lsr r1
002da0 9407                      	ror r0
002da1 9416                      	lsr r1
002da2 9407                      	ror r0
002da3 9416                      	lsr r1
002da4 9407                      	ror r0
                                 	
002da5 91a0 0aac                 	lds r26, TCB2_CCMPL
002da7 91b0 0aad                 	lds r27, TCB2_CCMPH
002da9 0da0                      	add r26, r0
002daa 1db1                      	adc r27, r1
002dab 93a0 0aac                 	sts TCB2_CCMPL, r26
002dad 93b0 0aad                 	sts TCB2_CCMPH, r27
002daf c020                      	rjmp sound_driver_channel2_fx_Qxy_routine
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_subtract:
002db0 95b2                      	swap r27 //multiply depth by 16
002db1 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002db2 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002db3 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002db4 0fec                      	add ZL, r28 //offset the table by the depth+phase
002db5 1df2                      	adc ZH, zero
002db6 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002db7 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002db8 937f                      	push r23
002db9 2f6c                      	mov r22, r28 //store the vibrato value into r22
002dba eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002dbb 9f67                      	mul r22, r23
002dbc 917f                      	pop r23
002dbd 916f                      	pop r22
                                 
002dbe 9416                      	lsr r1 //shift out the fractional bits
002dbf 9407                      	ror r0
002dc0 9416                      	lsr r1
002dc1 9407                      	ror r0
002dc2 9416                      	lsr r1
002dc3 9407                      	ror r0
002dc4 9416                      	lsr r1
002dc5 9407                      	ror r0
                                 
002dc6 91a0 0aac                 	lds r26, TCB2_CCMPL
002dc8 91b0 0aad                 	lds r27, TCB2_CCMPH
002dca 19a0                      	sub r26, r0
002dcb 09b1                      	sbc r27, r1
002dcc 93a0 0aac                 	sts TCB2_CCMPL, r26
002dce 93b0 0aad                 	sts TCB2_CCMPH, r27
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel2_fx_Qxy_routine:
002dd0 91e0 2902                 	lds ZL, triangle_fx_Qxy_target
002dd2 91f0 2903                 	lds ZH, triangle_fx_Qxy_target+1
002dd4 9630                      	adiw Z, 0
002dd5 f119                      	breq sound_driver_channel2_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002dd6 91a0 2906                 	lds r26, triangle_fx_Qxy_total_offset
002dd8 91b0 2907                 	lds r27, triangle_fx_Qxy_total_offset+1
002dda 91c0 0aac                 	lds r28, TCB2_CCMPL
002ddc 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
002dde 1bec                      	sub ZL, r28 //calculate the difference to the target
002ddf 0bfd                      	sbc ZH, r29
002de0 f408                      	brsh sound_driver_channel2_fx_Qxy_routine_end //if the target has been reached (or passed)
002de1 f068                      	brlo sound_driver_channel2_fx_Qxy_routine_add
                                 
                                 sound_driver_channel2_fx_Qxy_routine_end:
002de2 9220 2906                 	sts triangle_fx_Qxy_total_offset, zero //turn off the effect
002de4 9220 2907                 	sts triangle_fx_Qxy_total_offset+1, zero
002de6 9220 2902                 	sts triangle_fx_Qxy_target, zero
002de8 9220 2903                 	sts triangle_fx_Qxy_target+1, zero
002dea 91b0 2901                 	lds r27, triangle_fx_Qxy_target_note
002dec 93b0 2812                 	sts triangle_note, r27 //replace the note with the final target note
002dee c00a                      	rjmp sound_driver_channel2_fx_Rxy_routine
                                 
                                 sound_driver_channel2_fx_Qxy_routine_add:
002def 91c0 2904                 	lds r28, triangle_fx_Qxy_speed
002df1 91d0 2905                 	lds r29, triangle_fx_Qxy_speed+1
002df3 0fac                      	add r26, r28 //increase the total offset by the speed
002df4 1fbd                      	adc r27, r29
002df5 93a0 2906                 	sts triangle_fx_Qxy_total_offset, r26 //store the total offset
002df7 93b0 2907                 	sts triangle_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_Rxy_routine:
002df9 91e0 2909                 	lds ZL, triangle_fx_Rxy_target
002dfb 91f0 290a                 	lds ZH, triangle_fx_Rxy_target+1
002dfd 9630                      	adiw Z, 0
002dfe f119                      	breq sound_driver_instrument_routine_channel3_volume //if the effect is not enabled, skip the routine
                                 
002dff 91a0 290d                 	lds r26, triangle_fx_Rxy_total_offset
002e01 91b0 290e                 	lds r27, triangle_fx_Rxy_total_offset+1
002e03 91c0 0aac                 	lds r28, TCB2_CCMPL
002e05 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
002e07 1bce                      	sub r28, ZL //calculate the difference to the target
002e08 0bdf                      	sbc r29, ZH
002e09 f408                      	brsh sound_driver_channel2_fx_Rxy_routine_end //if the target has been reached (or passed)
002e0a f068                      	brlo sound_driver_channel2_fx_Rxy_routine_add
                                 
                                 sound_driver_channel2_fx_Rxy_routine_end:
002e0b 9220 290d                 	sts triangle_fx_Rxy_total_offset, zero //disable the effect
002e0d 9220 290e                 	sts triangle_fx_Rxy_total_offset+1, zero
002e0f 9220 2909                 	sts triangle_fx_Rxy_target, zero
002e11 9220 290a                 	sts triangle_fx_Rxy_target+1, zero
002e13 91b0 2908                 	lds r27, triangle_fx_Rxy_target_note
002e15 93b0 2812                 	sts triangle_note, r27 //replace the note with the final target note
002e17 c00a                      	rjmp sound_driver_instrument_routine_channel3_volume
                                 
                                 sound_driver_channel2_fx_Rxy_routine_add:
002e18 91c0 290b                 	lds r28, triangle_fx_Rxy_speed
002e1a 91d0 290c                 	lds r29, triangle_fx_Rxy_speed+1
002e1c 0fac                      	add r26, r28 //increase the total offset by the speed
002e1d 1fbd                      	adc r27, r29
002e1e 93a0 290d                 	sts triangle_fx_Rxy_total_offset, r26 //store the total offset
002e20 93b0 290e                 	sts triangle_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume:
002e22 91e0 2917                 	lds ZL, noise_volume_macro
002e24 91f0 2918                 	lds ZH, noise_volume_macro+1
002e26 9630                      	adiw Z, 0
002e27 f1a1                      	breq sound_driver_instrument_routine_channel3_volume_default //if no volume macro is in use, use default multiplier of F
002e28 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002e29 1fff                      	rol ZH
002e2a 91a0 2919                 	lds r26, noise_volume_macro_offset
002e2c 0fea                      	add ZL, r26
002e2d 1df2                      	adc ZH, zero
                                 
002e2e 91b0 291b                 	lds r27, noise_volume_macro_release
002e30 17ba                      	cp r27, r26
002e31 f429                      	brne sound_driver_instrument_routine_channel3_volume_increment //if the current offset is not equal to the release index, increment the offset
002e32 91a0 291a                 	lds r26, noise_volume_macro_loop
002e34 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002e35 f010                      	brlo sound_driver_instrument_routine_channel3_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002e36 c003                      	rjmp sound_driver_instrument_routine_channel3_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_volume_increment:
002e37 95a3                      	inc r26 //increment the macro offset
002e38 93a0 2919                 	sts noise_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_volume_read:
002e3a 91b4                      	lpm r27, Z //load volume data into r27
002e3b 3fbf                      	cpi r27, 0xFF //check for macro end flag
002e3c f469                      	brne sound_driver_instrument_routine_channel3_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_check_release:
002e3d 91b0 291b                 	lds r27, noise_volume_macro_release
002e3f 3fbf                      	cpi r27, 0xFF
002e40 f429                      	brne sound_driver_instrument_routine_channel3_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_check_loop:
002e41 91b0 291a                 	lds r27, noise_volume_macro_loop //load the loop index
002e43 93b0 2919                 	sts noise_volume_macro_offset, r27 //store the loop index into the offset
002e45 cfdc                      	rjmp sound_driver_instrument_routine_channel3_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_last_index:
002e46 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002e47 93a0 2919                 	sts noise_volume_macro_offset, r26
002e49 cfd8                      	rjmp sound_driver_instrument_routine_channel3_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume_calculate:
002e4a ebee                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
002e4b e6f1                      	ldi ZH, HIGH(volumes << 1)
002e4c 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
002e4d 0feb                      	add ZL, r27 //add offset to the table
002e4e 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel3_volume_load:
002e4f 91b0 2813                 	lds r27, noise_param //load main volume
002e51 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002e52 91a0 2941                 	lds r26, noise_fx_7xy_value
002e54 30a0                      	cpi r26, 0x00
002e55 f481                      	brne sound_driver_instrument_routine_channel3_volume_load_7xy
                                 
002e56 0feb                      	add ZL, r27 //offset the volume table by the main volume
002e57 1df2                      	adc ZH, zero
002e58 91b4                      	lpm r27, Z
002e59 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002e5b c023                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_default:
002e5c 91b0 2813                 	lds r27, noise_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
002e5e 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002e5f 91a0 2941                 	lds r26, noise_fx_7xy_value
002e61 30a0                      	cpi r26, 0x00
002e62 f499                      	brne sound_driver_instrument_routine_channel3_volume_default_7xy
002e63 93b0 2816                 	sts noise_output_volume, r27
002e65 c019                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_load_7xy:
002e66 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002e67 f038                      	brcs sound_driver_instrument_routine_channel3_volume_load_7xy_overflow
002e68 f031                      	breq sound_driver_instrument_routine_channel3_volume_load_7xy_overflow
                                 
002e69 0feb                      	add ZL, r27 //offset the volume table by the main volume
002e6a 1df2                      	adc ZH, zero
002e6b 91b4                      	lpm r27, Z
002e6c 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002e6e c010                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_load_7xy_overflow:
002e6f e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002e70 0feb                      	add ZL, r27 //offset the volume table by the main volume
002e71 1df2                      	adc ZH, zero
002e72 91b4                      	lpm r27, Z
002e73 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002e75 c009                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_default_7xy:
002e76 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002e77 f020                      	brcs sound_driver_instrument_routine_channel3_volume_default_7xy_overflow
002e78 f019                      	breq sound_driver_instrument_routine_channel3_volume_default_7xy_overflow
002e79 93b0 2816                 	sts noise_output_volume, r27
002e7b c003                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel3_volume_default_7xy_overflow:
002e7c e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002e7d 93b0 2816                 	sts noise_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002e7f 91e0 291c                 	lds ZL, noise_arpeggio_macro
002e81 91f0 291d                 	lds ZH, noise_arpeggio_macro+1
002e83 9630                      	adiw Z, 0
002e84 f1d9                      	breq sound_driver_instrument_routine_channel3_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002e85 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002e86 1fff                      	rol ZH
002e87 91a0 291e                 	lds r26, noise_arpeggio_macro_offset
002e89 0fea                      	add ZL, r26
002e8a 1df2                      	adc ZH, zero
                                 
002e8b 91b0 2920                 	lds r27, noise_arpeggio_macro_release
002e8d 17ba                      	cp r27, r26
002e8e f429                      	brne sound_driver_instrument_routine_channel3_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002e8f 91a0 291f                 	lds r26, noise_arpeggio_macro_loop
002e91 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002e92 f010                      	brlo sound_driver_instrument_routine_channel3_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002e93 c003                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_increment:
002e94 95a3                      	inc r26 //increment the macro offset
002e95 93a0 291e                 	sts noise_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_arpeggio_read:
002e97 91b4                      	lpm r27, Z //load arpeggio data into r27
002e98 38b0                      	cpi r27, 0x80 //check for macro end flag
002e99 f009                      	breq sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag
002e9a c041                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_check_mode:
002e9b 50a1                      	subi r26, 1 //keep the offset at the end flag
002e9c 93a0 291e                 	sts noise_arpeggio_macro_offset, r26
002e9e 91b0 2921                 	lds r27, noise_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002ea0 30b1                      	cpi r27, 0x01
002ea1 f048                      	brlo sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_fixed_relative_check_release:
002ea2 91b0 2920                 	lds r27, noise_arpeggio_macro_release
002ea4 3fbf                      	cpi r27, 0xFF
002ea5 f4d1                      	brne sound_driver_instrument_routine_channel3_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_fixed_relative_check_loop:
002ea6 91b0 291f                 	lds r27, noise_arpeggio_macro_loop
002ea8 3fbf                      	cpi r27, 0xFF
002ea9 f499                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002eaa c015                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute:
002eab 91b0 2920                 	lds r27, noise_arpeggio_macro_release
002ead 3fbf                      	cpi r27, 0xFF
002eae f421                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_check_loop:
002eaf 91b0 291f                 	lds r27, noise_arpeggio_macro_loop //load the loop index
002eb1 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002eb2 f451                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_no_loop:
002eb3 91c0 2934                 	lds r28, noise_fx_0xy_sequence //check for 0xy effect
002eb5 91d0 2935                 	lds r29, noise_fx_0xy_sequence+1
002eb7 9620                      	adiw r29:r28, 0
002eb8 f469                      	brne sound_driver_instrument_routine_channel3_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002eb9 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002eba 93a0 291e                 	sts noise_arpeggio_macro_offset, r26 //store the last valid index into the offset
002ebc cfc2                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload:
002ebd 93b0 291e                 	sts noise_arpeggio_macro_offset, r27 //store the loop index into the offset
002ebf cfbf                      	rjmp sound_driver_instrument_routine_channel3_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_default:
002ec0 91c0 2934                 	lds r28, noise_fx_0xy_sequence //load 0xy effect
002ec2 91d0 2935                 	lds r29, noise_fx_0xy_sequence+1
002ec4 9620                      	adiw r29:r28, 0 //check for 0xy effect
002ec5 f099                      	breq sound_driver_instrument_routine_channel3_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel3_arpeggio_default_0xy:
002ec6 95d6                      	lsr r29
002ec7 95c7                      	ror r28
002ec8 95d7                      	ror r29
002ec9 95c7                      	ror r28
002eca 95d7                      	ror r29
002ecb 95c7                      	ror r28
002ecc 95d7                      	ror r29
002ecd 95c7                      	ror r28
002ece 95d7                      	ror r29
002ecf 95d2                      	swap r29
                                 
002ed0 93c0 2934                 	sts noise_fx_0xy_sequence, r28 //store the rolled sequence
002ed2 93d0 2935                 	sts noise_fx_0xy_sequence+1, r29
002ed4 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002ed5 91a0 2817                 	lds r26, noise_note //load the current note index
002ed7 0fac                      	add r26, r28 //add the note offset
002ed8 c01c                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel3_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002ed9 91a0 2817                 	lds r26, noise_note //load the current note index
002edb c019                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process:
002edc 9220 2922                 	sts noise_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002ede 9220 2923                 	sts noise_total_pitch_offset+1, zero
002ee0 9220 2929                 	sts noise_total_hi_pitch_offset, zero
002ee2 91a0 2921                 	lds r26, noise_arpeggio_macro_mode
002ee4 30a1                      	cpi r26, 0x01 //absolute mode
002ee5 f010                      	brlo sound_driver_instrument_routine_channel3_arpeggio_process_absolute
002ee6 f031                      	breq sound_driver_instrument_routine_channel3_arpeggio_process_fixed
002ee7 c007                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_absolute:
002ee8 91a0 2817                 	lds r26, noise_note //load the current note index
002eea 0fab                      	add r26, r27 //offset the note with the arpeggio data
002eeb 70af                      	andi r26, 0x0F //keep only bits 0-3 in case there was overflow
002eec c008                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_fixed:
002eed 2fab                      	mov r26, r27 //move the arpeggio data into r26
002eee c006                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_relative:
002eef 91a0 2817                 	lds r26, noise_note //load the current note index
002ef1 0fab                      	add r26, r27 //offset the note with the arpeggio data
002ef2 70af                      	andi r26, 0x0F //keep only bits 0-3 in case there was overflow
002ef3 93a0 2817                 	sts noise_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_load:
002ef5 93a0 2818                 	sts noise_adjusted_note, r26
002ef7 c000                      	rjmp sound_driver_instrument_routine_channel3_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch:
002ef8 91e0 2924                 	lds ZL, noise_pitch_macro
002efa 91f0 2925                 	lds ZH, noise_pitch_macro+1
002efc 9630                      	adiw Z, 0
002efd f409                      	brne sound_driver_instrument_routine_channel3_pitch_continue
002efe c023                      	rjmp sound_driver_instrument_routine_channel3_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel3_pitch_continue:
002eff 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002f00 1fff                      	rol ZH
002f01 91a0 2926                 	lds r26, noise_pitch_macro_offset
002f03 0fea                      	add ZL, r26
002f04 1df2                      	adc ZH, zero
                                 
002f05 91b0 2928                 	lds r27, noise_pitch_macro_release
002f07 17ba                      	cp r27, r26
002f08 f429                      	brne sound_driver_instrument_routine_channel3_pitch_increment //if the current offset is not equal to the release index, increment the offset
002f09 91a0 2927                 	lds r26, noise_pitch_macro_loop
002f0b 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002f0c f010                      	brlo sound_driver_instrument_routine_channel3_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002f0d c003                      	rjmp sound_driver_instrument_routine_channel3_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_pitch_increment:
002f0e 95a3                      	inc r26 //increment the macro offset
002f0f 93a0 2926                 	sts noise_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_pitch_read:
002f11 91b4                      	lpm r27, Z //load pitch data into r27
002f12 38b0                      	cpi r27, 0x80 //check for macro end flag
002f13 f479                      	brne sound_driver_instrument_routine_channel3_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag_check_release:
002f14 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002f15 93a0 2926                 	sts noise_pitch_macro_offset, r26
002f17 91b0 2928                 	lds r27, noise_pitch_macro_release
002f19 3fbf                      	cpi r27, 0xFF
002f1a f439                      	brne sound_driver_instrument_routine_channel3_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag_check_loop:
002f1b 91b0 2927                 	lds r27, noise_pitch_macro_loop //load the loop index
002f1d 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002f1e f019                      	breq sound_driver_instrument_routine_channel3_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002f1f 93b0 2926                 	sts noise_pitch_macro_offset, r27 //store the loop index into the offset
002f21 cfd6                      	rjmp sound_driver_instrument_routine_channel3_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch_default:
002f22 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel3_pitch_calculate:
                                 sound_driver_instrument_routine_channel3_pitch_calculate_offset:
002f23 91a0 2922                 	lds r26, noise_total_pitch_offset
002f25 0fba                      	add r27, r26
002f26 93b0 2922                 	sts noise_total_pitch_offset, r27
002f28 91a0 2818                 	lds r26, noise_adjusted_note
002f2a 1bab                      	sub r26, r27
                                 	
002f2b 91b0 2937                 	lds r27, noise_fx_1xx_total
002f2d 0fab                      	add r26, r27
002f2e 91b0 2939                 	lds r27, noise_fx_2xx_total
002f30 1bab                      	sub r26, r27
002f31 91b0 293d                 	lds r27, noise_fx_4xy_offset
002f33 1bab                      	sub r26, r27
002f34 91b0 2945                 	lds r27, noise_fx_Pxx_total
002f36 1bab                      	sub r26, r27
                                 
002f37 70af                      	andi r26, 0x0F
                                 
002f38 e4e2                      	ldi ZL, LOW(noise_period_table << 1) //load in note table
002f39 e0f1                      	ldi ZH, HIGH(noise_period_table << 1)
002f3a 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002f3b 0fea                      	add ZL, r26 //add offset
002f3c 1df2                      	adc ZH, zero
002f3d 91a5                      	lpm r26, Z+ //load bytes
002f3e 91b4                      	lpm r27, Z
002f3f 93a0 0abc                 	sts TCB3_CCMPL, r26 //load the LOW bits for timer
002f41 93b0 0abd                 	sts TCB3_CCMPH, r27 //load the HIGH bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel3_hi_pitch:
002f43 91e0 292a                 	lds ZL, noise_hi_pitch_macro
002f45 91f0 292b                 	lds ZH, noise_hi_pitch_macro+1
002f47 9630                      	adiw Z, 0
002f48 f409                      	brne sound_driver_instrument_routine_channel3_hi_pitch_continue
002f49 c03c                      	rjmp sound_driver_instrument_routine_channel3_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel3_hi_pitch_continue:
002f4a 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002f4b 1fff                      	rol ZH
002f4c 91a0 292c                 	lds r26, noise_hi_pitch_macro_offset
002f4e 0fea                      	add ZL, r26
002f4f 1df2                      	adc ZH, zero
                                 
002f50 91b0 292e                 	lds r27, noise_hi_pitch_macro_release
002f52 17ba                      	cp r27, r26
002f53 f429                      	brne sound_driver_instrument_routine_channel3_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002f54 91a0 292d                 	lds r26, noise_hi_pitch_macro_loop
002f56 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002f57 f010                      	brlo sound_driver_instrument_routine_channel3_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002f58 c003                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_increment:
002f59 95a3                      	inc r26 //increment the macro offset
002f5a 93a0 292c                 	sts noise_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_hi_pitch_read:
002f5c 91b4                      	lpm r27, Z //load hi pitch data into r27
002f5d 38b0                      	cpi r27, 0x80 //check for macro end flag
002f5e f489                      	brne sound_driver_instrument_routine_channel3_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag_check_release:
002f5f 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002f60 93a0 292c                 	sts noise_hi_pitch_macro_offset, r26
002f62 91b0 292e                 	lds r27, noise_hi_pitch_macro_release
002f64 3fbf                      	cpi r27, 0xFF
002f65 f439                      	brne sound_driver_instrument_routine_channel3_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag_check_loop:
002f66 91b0 292d                 	lds r27, noise_hi_pitch_macro_loop //load the loop index
002f68 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002f69 f019                      	breq sound_driver_instrument_routine_channel3_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002f6a 93b0 292c                 	sts noise_hi_pitch_macro_offset, r27 //store the loop index into the offset
002f6c cfd6                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_default:
002f6d 91b0 2929                 	lds r27, noise_total_hi_pitch_offset
002f6f c005                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate:
002f70 91a0 2929                 	lds r26, noise_total_hi_pitch_offset //load the total hi pitch offset to change
002f72 0fba                      	add r27, r26
002f73 93b0 2929                 	sts noise_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate_multiply:
002f75 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002f76 937f                      	push r23
002f77 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002f78 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002f79 0367                      	mulsu r22, r23
002f7a 917f                      	pop r23
002f7b 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate_offset:
002f7c 91a0 0abc                 	lds r26, TCB3_CCMPL //load the low bits for timer
002f7e 91b0 0abd                 	lds r27, TCB3_CCMPH //load the high bits for timer
002f80 0da0                      	add r26, r0 //offset the timer values
002f81 1db1                      	adc r27, r1
002f82 93a0 0abc                 	sts TCB3_CCMPL, r26 //store the new low bits for timer
002f84 93b0 0abd                 	sts TCB3_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty:
002f86 91e0 292f                 	lds ZL, noise_duty_macro
002f88 91f0 2930                 	lds ZH, noise_duty_macro+1
002f8a 9630                      	adiw Z, 0
002f8b f169                      	breq sound_driver_channel3_fx_routines //if no duty macro is in use, go to the next routine
002f8c 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002f8d 1fff                      	rol ZH
002f8e 91a0 2931                 	lds r26, noise_duty_macro_offset
002f90 0fea                      	add ZL, r26
002f91 1df2                      	adc ZH, zero
                                 
002f92 91b0 2933                 	lds r27, noise_duty_macro_release
002f94 17ba                      	cp r27, r26
002f95 f429                      	brne sound_driver_instrument_routine_channel3_duty_increment //if the current offset is not equal to the release index, increment the offset
002f96 91a0 2932                 	lds r26, noise_duty_macro_loop
002f98 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002f99 f010                      	brlo sound_driver_instrument_routine_channel3_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002f9a c01e                      	rjmp sound_driver_channel3_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel3_duty_increment:
002f9b 95a3                      	inc r26 //increment the macro offset
002f9c 93a0 2931                 	sts noise_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_duty_read:
002f9e 91b4                      	lpm r27, Z //load pitch data into r27
002f9f 3fbf                      	cpi r27, 0xFF //check for macro end flag
002fa0 f471                      	brne sound_driver_instrument_routine_channel3_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag_check_release:
002fa1 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002fa2 93a0 2931                 	sts noise_duty_macro_offset, r26
002fa4 91b0 2933                 	lds r27, noise_duty_macro_release
002fa6 3fbf                      	cpi r27, 0xFF
002fa7 f489                      	brne sound_driver_channel3_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag_check_loop:
002fa8 91b0 2932                 	lds r27, noise_duty_macro_loop //load the loop index
002faa 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002fab f069                      	breq sound_driver_channel3_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
002fac 93b0 2931                 	sts noise_duty_macro_offset, r27 //store the loop index into the offset
002fae cfd7                      	rjmp sound_driver_instrument_routine_channel3_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty_load:
002faf 95b6                      	lsr r27
002fb0 95b7                      	ror r27 //move mode bit to bit 7
002fb1 91c0 2814                 	lds r28, noise_period
002fb3 77cf                      	andi r28, 0b01111111
002fb4 2bcb                      	or r28, r27 //store the new noise mode
002fb5 93c0 2813                 	sts noise_param, r28
                                 
002fb7 776f                      	andi noise_sequence_HIGH, 0b01111111
002fb8 2b6b                      	or noise_sequence_HIGH, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_routines:
                                 sound_driver_channel3_fx_1xx_routine:
002fb9 91e0 2936                 	lds ZL, noise_fx_1xx
002fbb 30e0                      	cpi ZL, 0
002fbc f029                      	breq sound_driver_channel3_fx_2xx_routine
                                 
002fbd 91a0 2937                 	lds r26, noise_fx_1xx_total //load the rate to change the pitch by
002fbf 0fae                      	add r26, ZL //increase the total offset by the rate
002fc0 93a0 2937                 	sts noise_fx_1xx_total, r26
                                 
                                 
                                 
                                 sound_driver_channel3_fx_2xx_routine:
002fc2 91e0 2938                 	lds ZL, noise_fx_2xx
002fc4 30e0                      	cpi ZL, 0
002fc5 f029                      	breq sound_driver_channel3_fx_3xx_routine
                                 
002fc6 91a0 2939                 	lds r26, noise_fx_2xx_total //load the rate to change the pitch by
002fc8 0fae                      	add r26, ZL //increase the total offset by the rate
002fc9 93a0 2939                 	sts noise_fx_2xx_total, r26
                                 
                                 
                                 
                                 sound_driver_channel3_fx_3xx_routine:
                                 
                                 
                                 
                                 sound_driver_channel3_fx_4xy_routine:
002fcb 91a0 293a                 	lds r26, noise_fx_4xy_speed
002fcd 15a2                      	cp r26, zero
002fce f409                      	brne sound_driver_channel3_fx_4xy_routine_continue
002fcf c033                      	rjmp sound_driver_channel3_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel3_fx_4xy_routine_continue:
002fd0 91b0 293b                 	lds r27, noise_fx_4xy_depth
002fd2 91c0 293c                 	lds r28, noise_fx_4xy_phase
002fd4 0fca                      	add r28, r26 //increase the phase by the speed
002fd5 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002fd6 f008                      	brlo sound_driver_channel3_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002fd7 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase:
002fd8 93c0 293c                 	sts noise_fx_4xy_phase, r28 //store the new phase
002fda 31c0                      	cpi r28, 16
002fdb f028                      	brlo sound_driver_channel3_fx_4xy_routine_phase_0
002fdc 32c0                      	cpi r28, 32
002fdd f028                      	brlo sound_driver_channel3_fx_4xy_routine_phase_1
002fde 33c0                      	cpi r28, 48
002fdf f030                      	brlo sound_driver_channel3_fx_4xy_routine_phase_2
002fe0 c007                      	rjmp sound_driver_channel3_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_0:
002fe1 70cf                      	andi r28, 0x0F //mask for values 0-15
002fe2 c014                      	rjmp sound_driver_channel3_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_1:
002fe3 6fc0                      	ori r28, 0xF0
002fe4 95c0                      	com r28 //invert values 0-15
002fe5 c011                      	rjmp sound_driver_channel3_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_2:
002fe6 70cf                      	andi r28, 0x0F //mask for values 0-15
002fe7 c003                      	rjmp sound_driver_channel3_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_3:
002fe8 6fc0                      	ori r28, 0xF0
002fe9 95c0                      	com r28 //invert values 0-15
002fea c000                      	rjmp sound_driver_channel3_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel3_fx_4xy_routine_load_add:
002feb 95b2                      	swap r27 //multiply depth by 16
002fec 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002fed e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002fee e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002fef 0fec                      	add ZL, r28 //offset the table by the depth+phase
002ff0 1df2                      	adc ZH, zero
002ff1 91c4                      	lpm r28, Z //load the tremelo value into r28
002ff2 95c2                      	swap r28
002ff3 70cf                      	andi r28, 0x0F
                                 
002ff4 93c0 293d                 	sts noise_fx_4xy_offset, r28
002ff6 c00c                      	rjmp sound_driver_channel3_fx_7xy_routine
                                 
                                 sound_driver_channel3_fx_4xy_routine_load_subtract:
002ff7 95b2                      	swap r27 //multiply depth by 16
002ff8 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002ff9 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002ffa e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002ffb 0fec                      	add ZL, r28 //offset the table by the depth+phase
002ffc 1df2                      	adc ZH, zero
002ffd 91c4                      	lpm r28, Z //load the vibrato value into r28
002ffe 95c2                      	swap r28
002fff 70cf                      	andi r28, 0x0F
                                 
003000 95c1                      	neg r28
003001 93c0 293d                 	sts noise_fx_4xy_offset, r28
                                 
                                 
                                 
                                 sound_driver_channel3_fx_7xy_routine:
003003 91a0 293e                 	lds r26, noise_fx_7xy_speed
003005 15a2                      	cp r26, zero
003006 f0e9                      	breq sound_driver_channel3_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
003007 91b0 293f                 	lds r27, noise_fx_7xy_depth
003009 91c0 2940                 	lds r28, noise_fx_7xy_phase
00300b 0fca                      	add r28, r26 //increase the phase by the speed
00300c 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
00300d f008                      	brlo sound_driver_channel3_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
00300e e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel3_fx_7xy_routine_phase:
00300f 93c0 2940                 	sts noise_fx_7xy_phase, r28 //store the new phase
003011 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
003012 ffc4                      	sbrs r28, 4
003013 c001                      	rjmp sound_driver_channel3_fx_7xy_routine_phase_0
003014 c002                      	rjmp sound_driver_channel3_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel3_fx_7xy_routine_phase_0:
003015 70cf                      	andi r28, 0x0F //mask for values 0-15
003016 c003                      	rjmp sound_driver_channel3_fx_7xy_routine_load
                                 
                                 sound_driver_channel3_fx_7xy_routine_phase_1:
003017 6fc0                      	ori r28, 0xF0
003018 95c0                      	com r28 //invert values 0-15
003019 c000                      	rjmp sound_driver_channel3_fx_7xy_routine_load
                                 
                                 sound_driver_channel3_fx_7xy_routine_load:
00301a 95b2                      	swap r27 //multiply depth by 16
00301b 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
00301c e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00301d e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00301e 0fec                      	add ZL, r28 //offset the table by the depth+phase
00301f 1df2                      	adc ZH, zero
003020 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
003021 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
003022 93c0 2941                 	sts noise_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Axy_routine:
003024 91b0 2942                 	lds r27, noise_fx_Axy
003026 15b2                      	cp r27, zero
003027 f0e9                      	breq sound_driver_channel3_fx_Qxy_routine //0 means that the effect is not in use
                                 	
003028 91a0 2815                 	lds r26, noise_fractional_volume //load fractional volume representation of the channel
00302a 91c0 2813                 	lds r28, noise_param //load the integer volume representation of the channel
00302c 2fda                      	mov r29, r26 //copy fractional volume into r29
00302d 2fec                      	mov r30, r28 //copy the noise_param into r30
00302e 95e2                      	swap r30
00302f 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
003030 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
003031 17ed                      	cp r30, r29 //compare the fractional and integer volumes
003032 f009                      	breq sound_driver_channel3_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel3_fx_Axy_routine_reload:
003033 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate:
003034 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
003035 c004                      	rjmp sound_driver_channel3_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_addition:
003036 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
003037 f428                      	brcc sound_driver_channel3_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
003038 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
003039 c003                      	rjmp sound_driver_channel3_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_subtraction:
00303a 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
00303b f008                      	brcs sound_driver_channel3_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
00303c e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_store:
00303d 93a0 2815                 	sts noise_fractional_volume, r26 //store the new fractional volume
00303f 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
003040 95a2                      	swap r26
003041 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
003042 2bca                      	or r28, r26 //store the new volume back into noise_param
003043 93c0 2813                 	sts noise_param, r28
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Qxy_routine:
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Rxy_routine:
                                 
                                 
                                 
                                 sound_driver_exit:
003045 91ff                      	pop r31
003046 91ef                      	pop r30
003047 91df                      	pop r29
003048 91cf                      	pop r28
003049 940c 161b                 	jmp sequence_1_3 + 3 //+3 is to skip the stack instructions since we already pushed them
                                 
                                 
                                 
                                 //TABLES
00304b 7f05
00304c 010a
00304d 0214
00304e 0328
00304f 0450
003050 051e
003051 0607
003052 070d
003053 0806
003054 090c
003055 0a18
003056 0b30
003057 0c60
003058 0d24
003059 0e08
00305a 0f10                      length: .db $05, $7F, $0A, $01, $14, $02, $28, $03, $50, $04, $1E, $05, $07, $06, $0D, $07, $06, $08, $0C, $09, $18, $0A, $30, $0B, $60, $0C, $24, $0D, $08, $0E, $10, $0F
                                 
                                 //pulse sequences: 12.5%, 25%, 50%, 75%
00305b 0301
00305c fc0f                      sequences: .db 0b00000001, 0b00000011, 0b00001111, 0b11111100
                                 
                                 //list of famitracker fx: http://famitracker.com/wiki/index.php?title=Effect_list
                                 channel0_fx:
00305d 1857
00305e 185c
00305f 1878
003060 1894
003061 18b7                      	.dw sound_driver_channel0_fx_0xy, sound_driver_channel0_fx_1xx, sound_driver_channel0_fx_2xx, sound_driver_channel0_fx_3xx, sound_driver_channel0_fx_4xy
003062 18c2
003063 18cf
003064 18d2
003065 18d5
003066 18d8                      	.dw sound_driver_channel0_fx_7xy, sound_driver_channel0_fx_Axy, sound_driver_channel0_fx_Bxx, sound_driver_channel0_fx_Cxx, sound_driver_channel0_fx_Dxx
003067 18db
003068 18e3
003069 18e6
00306a 18f3
00306b 18f4                      	.dw sound_driver_channel0_fx_Exx, sound_driver_channel0_fx_Fxx, sound_driver_channel0_fx_Gxx, sound_driver_channel0_fx_Hxy, sound_driver_channel0_fx_Ixy
00306c 18f5
00306d 18f6
00306e 18f7
00306f 190f
003070 1951                      	.dw sound_driver_channel0_fx_Hxx, sound_driver_channel0_fx_Ixx, sound_driver_channel0_fx_Pxx, sound_driver_channel0_fx_Qxy, sound_driver_channel0_fx_Rxy
003071 1992
003072 199f
003073 19b3
003074 19b4
003075 19b5                      	.dw sound_driver_channel0_fx_Sxx, sound_driver_channel0_fx_Vxx, sound_driver_channel0_fx_Wxx, sound_driver_channel0_fx_Xxx, sound_driver_channel0_fx_Yxx
003076 19b6                      	.dw sound_driver_channel0_fx_Zxx
                                 
                                 channel1_fx:
003077 1b45
003078 1b4a
003079 1b66
00307a 1b82
00307b 1ba5                      	.dw sound_driver_channel1_fx_0xy, sound_driver_channel1_fx_1xx, sound_driver_channel1_fx_2xx, sound_driver_channel1_fx_3xx, sound_driver_channel1_fx_4xy
00307c 1bb0
00307d 1bbd
00307e 1bc0
00307f 1bc3
003080 1bc6                      	.dw sound_driver_channel1_fx_7xy, sound_driver_channel1_fx_Axy, sound_driver_channel1_fx_Bxx, sound_driver_channel1_fx_Cxx, sound_driver_channel1_fx_Dxx
003081 1bc9
003082 1bd1
003083 1bd4
003084 1be1
003085 1be2                      	.dw sound_driver_channel1_fx_Exx, sound_driver_channel1_fx_Fxx, sound_driver_channel1_fx_Gxx, sound_driver_channel1_fx_Hxy, sound_driver_channel1_fx_Ixy
003086 1be3
003087 1be4
003088 1be5
003089 1bfd
00308a 1c3f                      	.dw sound_driver_channel1_fx_Hxx, sound_driver_channel1_fx_Ixx, sound_driver_channel1_fx_Pxx, sound_driver_channel1_fx_Qxy, sound_driver_channel1_fx_Rxy
00308b 1c80
00308c 1c8d
00308d 1ca1
00308e 1ca2
00308f 1ca3                      	.dw sound_driver_channel1_fx_Sxx, sound_driver_channel1_fx_Vxx, sound_driver_channel1_fx_Wxx, sound_driver_channel1_fx_Xxx, sound_driver_channel1_fx_Yxx
003090 1ca4                      	.dw sound_driver_channel1_fx_Zxx
                                 
                                 channel2_fx:
003091 1e26
003092 1e2b
003093 1e47
003094 1e63
003095 1e86                      	.dw sound_driver_channel2_fx_0xy, sound_driver_channel2_fx_1xx, sound_driver_channel2_fx_2xx, sound_driver_channel2_fx_3xx, sound_driver_channel2_fx_4xy
003096 1e91
003097 1e92
003098 1e93
003099 1e96
00309a 1e99                      	.dw sound_driver_channel2_fx_7xy, sound_driver_channel2_fx_Axy, sound_driver_channel2_fx_Bxx, sound_driver_channel2_fx_Cxx, sound_driver_channel2_fx_Dxx
00309b 1e9c
00309c 1ea9
00309d 1eac
00309e 1eb9
00309f 1eba                      	.dw sound_driver_channel2_fx_Exx, sound_driver_channel2_fx_Fxx, sound_driver_channel2_fx_Gxx, sound_driver_channel2_fx_Hxy, sound_driver_channel2_fx_Ixy
0030a0 1ebb
0030a1 1ebc
0030a2 1ebd
0030a3 1ed5
0030a4 1f17                      	.dw sound_driver_channel2_fx_Hxx, sound_driver_channel2_fx_Ixx, sound_driver_channel2_fx_Pxx, sound_driver_channel2_fx_Qxy, sound_driver_channel2_fx_Rxy
0030a5 1f58
0030a6 1f65
0030a7 1f66
0030a8 1f67
0030a9 1f68                      	.dw sound_driver_channel2_fx_Sxx, sound_driver_channel2_fx_Vxx, sound_driver_channel2_fx_Wxx, sound_driver_channel2_fx_Xxx, sound_driver_channel2_fx_Yxx
0030aa 1f69                      	.dw sound_driver_channel2_fx_Zxx
                                 
                                 channel3_fx:
0030ab 20ef
0030ac 20f4
0030ad 20fd
0030ae 2106
0030af 2107                      	.dw sound_driver_channel3_fx_0xy, sound_driver_channel3_fx_1xx, sound_driver_channel3_fx_2xx, sound_driver_channel3_fx_3xx, sound_driver_channel3_fx_4xy
0030b0 2114
0030b1 2121
0030b2 2124
0030b3 2127
0030b4 212a                      	.dw sound_driver_channel3_fx_7xy, sound_driver_channel3_fx_Axy, sound_driver_channel3_fx_Bxx, sound_driver_channel3_fx_Cxx, sound_driver_channel3_fx_Dxx
0030b5 212d
0030b6 2134
0030b7 2137
0030b8 2144
0030b9 2145                      	.dw sound_driver_channel3_fx_Exx, sound_driver_channel3_fx_Fxx, sound_driver_channel3_fx_Gxx, sound_driver_channel3_fx_Hxy, sound_driver_channel3_fx_Ixy
0030ba 2146
0030bb 2147
0030bc 2148
0030bd 214b
0030be 214c                      	.dw sound_driver_channel3_fx_Hxx, sound_driver_channel3_fx_Ixx, sound_driver_channel3_fx_Pxx, sound_driver_channel3_fx_Qxy, sound_driver_channel3_fx_Rxy
0030bf 214d
0030c0 215a
0030c1 2165
0030c2 2166
0030c3 2167                      	.dw sound_driver_channel3_fx_Sxx, sound_driver_channel3_fx_Vxx, sound_driver_channel3_fx_Wxx, sound_driver_channel3_fx_Xxx, sound_driver_channel3_fx_Yxx
0030c4 2168                      	.dw sound_driver_channel3_fx_Zxx
                                 
                                 channel4_fx:
0030c5 22b2
0030c6 22b3
0030c7 22b4
0030c8 22b5
0030c9 22b6                      	.dw sound_driver_channel4_fx_0xy, sound_driver_channel4_fx_1xx, sound_driver_channel4_fx_2xx, sound_driver_channel4_fx_3xx, sound_driver_channel4_fx_4xy
0030ca 22b7
0030cb 22b8
0030cc 22b9
0030cd 22bc
0030ce 22bf                      	.dw sound_driver_channel4_fx_7xy, sound_driver_channel4_fx_Axy, sound_driver_channel4_fx_Bxx, sound_driver_channel4_fx_Cxx, sound_driver_channel4_fx_Dxx
0030cf 22c2
0030d0 22c3
0030d1 22c6
0030d2 22d3
0030d3 22d4                      	.dw sound_driver_channel4_fx_Exx, sound_driver_channel4_fx_Fxx, sound_driver_channel4_fx_Gxx, sound_driver_channel4_fx_Hxy, sound_driver_channel4_fx_Ixy
0030d4 22d5
0030d5 22d6
0030d6 22d7
0030d7 22d8
0030d8 22d9                      	.dw sound_driver_channel4_fx_Hxx, sound_driver_channel4_fx_Ixx, sound_driver_channel4_fx_Pxx, sound_driver_channel4_fx_Qxy, sound_driver_channel4_fx_Rxy
0030d9 22da
0030da 22e7
0030db 22e8
0030dc 22e9
0030dd 22ea                      	.dw sound_driver_channel4_fx_Sxx, sound_driver_channel4_fx_Vxx, sound_driver_channel4_fx_Wxx, sound_driver_channel4_fx_Xxx, sound_driver_channel4_fx_Yxx
0030de 22eb                      	.dw sound_driver_channel4_fx_Zxx
                                 
                                 //famitracker volumes table: http://famitracker.com/wiki/index.php?title=Volume
                                 volumes:
0030df 0000
0030e0 0000
0030e1 0000
0030e2 0000
0030e3 0000
0030e4 0000
0030e5 0000
0030e6 0000                      	.db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
0030e7 0100
0030e8 0101
0030e9 0101
0030ea 0101
0030eb 0101
0030ec 0101
0030ed 0101
0030ee 0101                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
0030ef 0100
0030f0 0101
0030f1 0101
0030f2 0101
0030f3 0101
0030f4 0101
0030f5 0101
0030f6 0201                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02
0030f7 0100
0030f8 0101
0030f9 0101
0030fa 0101
0030fb 0101
0030fc 0202
0030fd 0202
0030fe 0302                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03
0030ff 0100
003100 0101
003101 0101
003102 0101
003103 0202
003104 0202
003105 0303
003106 0403                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04
003107 0100
003108 0101
003109 0101
00310a 0202
00310b 0302
00310c 0303
00310d 0404
00310e 0504                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05
00310f 0100
003110 0101
003111 0201
003112 0202
003113 0303
003114 0404
003115 0504
003116 0605                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x06
003117 0100
003118 0101
003119 0201
00311a 0302
00311b 0403
00311c 0504
00311d 0605
00311e 0706                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07
00311f 0100
003120 0101
003121 0202
003122 0303
003123 0404
003124 0505
003125 0606
003126 0807                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07, 0x08
003127 0100
003128 0101
003129 0302
00312a 0403
00312b 0504
00312c 0606
00312d 0707
00312e 0908                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09
00312f 0100
003130 0201
003131 0302
003132 0404
003133 0605
003134 0706
003135 0808
003136 0a09                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A
003137 0100
003138 0201
003139 0302
00313a 0504
00313b 0605
00313c 0807
00313d 0908
00313e 0b0a                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B
00313f 0100
003140 0201
003141 0403
003142 0504
003143 0706
003144 0808
003145 0a09
003146 0c0b                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B, 0x0C
003147 0100
003148 0201
003149 0403
00314a 0605
00314b 0706
00314c 0908
00314d 0b0a
00314e 0d0c                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D
00314f 0100
003150 0201
003151 0403
003152 0605
003153 0807
003154 0a09
003155 0c0b
003156 0e0d                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E
003157 0100
003158 0302
003159 0504
00315a 0706
00315b 0908
00315c 0b0a
00315d 0d0c


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega4809" register use summary:
x  :   0 y  :   0 z  : 249 r0 : 148 r1 : 160 r2 : 666 r3 :   2 r4 :   0 
r5 :   0 r6 :   0 r7 :   6 r8 :   4 r9 :   9 r10:   6 r11:   4 r12:   9 
r13:   1 r14:   1 r15:   2 r16:   7 r17:   6 r18:   7 r19:   6 r20:   4 
r21:   9 r22: 138 r23: 127 r24:   3 r25:  24 r26: 938 r27:1199 r28: 686 
r29: 350 r30: 383 r31: 331 
Registers used: 30 out of 35 (85.7%)

"ATmega4809" instruction use summary:
.lds  :   0 .sts  :   0 adc   : 132 add   : 182 adiw  : 100 and   :   2 
andi  :  99 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   6 brcs  :  13 break :   0 breq  : 170 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  76 brlt  :   0 brmi  :   0 
brne  : 123 brpl  :   0 brsh  :  37 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :   0 cbr   :   5 
clc   :   0 clh   :   0 cli   :   8 cln   :   0 clr   :   5 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :  16 cp    : 115 cpc   :  15 
cpi   : 172 cpse  :  21 dec   :  40 des   :   0 eor   :   2 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   5 in    :   7 inc   :  46 
jmp   :  11 ld    :   0 ldd   :   0 ldi   : 306 lds   : 675 lpm   : 273 
lsl   :  80 lsr   : 135 mov   : 143 movw  :   0 mul   :  21 muls  :   0 
mulsu :  10 neg   :   1 nop   :   0 or    :  24 ori   :  12 out   :   9 
pop   :  97 push  :  91 rcall :  56 ret   :  34 reti  :   7 rjmp  : 559 
rol   :  57 ror   : 156 sbc   :  30 sbci  :   0 sbi   :   0 sbic  :   0 
sbis  :   0 sbiw  :   0 sbr   :  12 sbrc  :  25 sbrs  :  18 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   :1355 sub   :  53 subi  :  49 swap  :  47 tst   :   0 wdr   :   0 

Instructions used: 54 out of 114 (47.4%)

"ATmega4809" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x0062be  15370   9796  25166   49152  51.2%
[.dseg] 0x002800 0x002956      0    342    342    6144   5.6%
[.eseg] 0x000000 0x000000      0      0      0     256   0.0%

Assembly complete, 0 errors, 52 warnings
