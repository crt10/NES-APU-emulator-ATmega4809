
AVRASM ver. 2.2.8  C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm Fri Jan 22 20:26:03 2021

C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
                                 
                                 
                                 ; NES_APU_2a03.asm
                                 ;
                                 ; Created: 11/29/2020 1:44:10 AM
                                 ; Author : Tennyson Cheng
                                 ;
                                 
                                 .list
                                 
                                 .dseg
002800                           pulse1_param: .byte 1 //$4000 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002801                           pulse1_sweep_param: .byte 1 //$4001 EPPP.NSSS = Enable, Period, Negate, Shift
                                 //NOTE: In order to account for multiplier, we use 16 instead of 11 bits for the timer
002802                           pulse1_timerL: .byte 1 //$4002 LLLL.LLLL = Low 8 bits for timer
002803                           pulse1_timerH: .byte 1 //$4002 HHHH.HHHH = High 8 bits for timer
002804                           pulse1_length: .byte 1 //$4003 000l.llll = Length counter load
002805                           pulse1_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002806                           pulse1_output_volume: .byte 1 //this is the final output volume of pulse 1
002807                           pulse1_note: .byte 1 //the current note index in the note table
                                 
002808                           pulse2_param: .byte 1 //$4004 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002809                           pulse2_sweep_param: .byte 1 //$4005 EPPP.NSSS = Enable, Period, Negate, Shift
00280a                           pulse2_timerL: .byte 1 //$4006 LLLL.LLLL = Low 8 bits for timer
00280b                           pulse2_timerH: .byte 1 //$4006 HHHH.HHHH = High 8 bits for timer
00280c                           pulse2_length: .byte 1 //$4007 000l.llll = Length counter load
00280d                           pulse2_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
00280e                           pulse2_output_volume: .byte 1 //this is the final output volume of pulse 2
00280f                           pulse2_note: .byte 1 //the current note index in the note table
                                 
002810                           triangle_timerL: .byte 1 //$400A LLLL.LLLL = Low 8 bits for timer
002811                           triangle_timerH: .byte 1 //$400A HHHH.HHHH = High 8 bits for time
002812                           triangle_note: .byte 1 //the current note index in the note table
                                 
002813                           noise_param: .byte 1 //$400C 00lc.vvvv = Length counter halt/Loop flag, Constant volume flag, Volume
002814                           noise_period: .byte 1 //$400E M000.PPPP = Mode, Period
002815                           noise_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002816                           noise_output_volume: .byte 1 //this is the final output volume of pulse 2
002817                           noise_note: .byte 1 //the current note index in the period table
                                 
002818                           song_frames: .byte 2
00281a                           song_frame_offset: .byte 2
00281c                           song_size: .byte 2
00281e                           song_speed: .byte 1
                                 //song_channel_delay_reload: .byte 1 //bit 0-4 represents channels 0-4. a set bit means that there is a delay that needs to be calculated for that channel.
00281f                           song_fx_Bxx: .byte 1
002820                           song_fx_Cxx: .byte 1
002821                           song_fx_Dxx: .byte 1
                                 
                                 //PULSE 1
002822                           pulse1_pattern: .byte 2
002824                           pulse1_pattern_delay_rows: .byte 1
002825                           pulse1_pattern_delay_frames: .byte 1
002826                           pulse1_pattern_offset: .byte 2
                                 
002828                           pulse1_volume_macro: .byte 2
00282a                           pulse1_volume_macro_offset: .byte 1
00282b                           pulse1_volume_macro_loop: .byte 1
00282c                           pulse1_volume_macro_release: .byte 1
                                 
00282d                           pulse1_arpeggio_macro: .byte 2
00282f                           pulse1_arpeggio_macro_offset: .byte 1
002830                           pulse1_arpeggio_macro_loop: .byte 1
002831                           pulse1_arpeggio_macro_release: .byte 1
002832                           pulse1_arpeggio_macro_mode: .byte 1
                                 
002833                           pulse1_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002835                           pulse1_pitch_macro: .byte 2
002837                           pulse1_pitch_macro_offset: .byte 1
002838                           pulse1_pitch_macro_loop: .byte 1
002839                           pulse1_pitch_macro_release: .byte 1
                                 
00283a                           pulse1_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00283b                           pulse1_hi_pitch_macro: .byte 2
00283d                           pulse1_hi_pitch_macro_offset: .byte 1
00283e                           pulse1_hi_pitch_macro_loop: .byte 1
00283f                           pulse1_hi_pitch_macro_release: .byte 1
                                 
002840                           pulse1_duty_macro: .byte 2
002842                           pulse1_duty_macro_offset: .byte 1
002843                           pulse1_duty_macro_loop: .byte 1
002844                           pulse1_duty_macro_release: .byte 1
                                 
002845                           pulse1_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002847                           pulse1_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002849                           pulse1_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00284b                           pulse1_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
00284d                           pulse1_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
00284f                           pulse1_fx_3xx_start: .byte 2 //the starting note period
002851                           pulse1_fx_3xx_target: .byte 2 //target note period
002853                           pulse1_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
002855                           pulse1_fx_3xx_total_offset: .byte 2
002857                           pulse1_fx_4xy_speed: .byte 1
002858                           pulse1_fx_4xy_depth: .byte 1
002859                           pulse1_fx_4xy_phase: .byte 1
00285a                           pulse1_fx_7xy_speed: .byte 1
00285b                           pulse1_fx_7xy_depth: .byte 1
00285c                           pulse1_fx_7xy_phase: .byte 1
00285d                           pulse1_fx_7xy_value: .byte 1 //value to offset the volume
00285e                           pulse1_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
00285f                           pulse1_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002860                           pulse1_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002861                           pulse1_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
002863                           pulse1_fx_Qxy_target: .byte 2 //target note period
002865                           pulse1_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002867                           pulse1_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002869                           pulse1_fx_Rxy_target: .byte 2 //target note period
00286b                           pulse1_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
00286d                           pulse1_fx_Rxy_total_offset: .byte 2
00286f                           pulse1_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002870                           pulse1_fx_Sxx_post: .byte 1
                                 
                                 //PULSE 2
002871                           pulse2_pattern: .byte 2
002873                           pulse2_pattern_delay_rows: .byte 1
002874                           pulse2_pattern_delay_frames: .byte 1
002875                           pulse2_pattern_offset: .byte 2
                                 
002877                           pulse2_volume_macro: .byte 2
002879                           pulse2_volume_macro_offset: .byte 1
00287a                           pulse2_volume_macro_loop: .byte 1
00287b                           pulse2_volume_macro_release: .byte 1
                                 
00287c                           pulse2_arpeggio_macro: .byte 2
00287e                           pulse2_arpeggio_macro_offset: .byte 1
00287f                           pulse2_arpeggio_macro_loop: .byte 1
002880                           pulse2_arpeggio_macro_release: .byte 1
002881                           pulse2_arpeggio_macro_mode: .byte 1
                                 
002882                           pulse2_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002884                           pulse2_pitch_macro: .byte 2
002886                           pulse2_pitch_macro_offset: .byte 1
002887                           pulse2_pitch_macro_loop: .byte 1
002888                           pulse2_pitch_macro_release: .byte 1
                                 
002889                           pulse2_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00288a                           pulse2_hi_pitch_macro: .byte 2
00288c                           pulse2_hi_pitch_macro_offset: .byte 1
00288d                           pulse2_hi_pitch_macro_loop: .byte 1
00288e                           pulse2_hi_pitch_macro_release: .byte 1
                                 
00288f                           pulse2_duty_macro: .byte 2
002891                           pulse2_duty_macro_offset: .byte 1
002892                           pulse2_duty_macro_loop: .byte 1
002893                           pulse2_duty_macro_release: .byte 1
                                 
002894                           pulse2_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002896                           pulse2_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002898                           pulse2_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00289a                           pulse2_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
00289c                           pulse2_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
00289e                           pulse2_fx_3xx_start: .byte 2 //the starting note period
0028a0                           pulse2_fx_3xx_target: .byte 2 //target note period
0028a2                           pulse2_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028a4                           pulse2_fx_3xx_total_offset: .byte 2
0028a6                           pulse2_fx_4xy_speed: .byte 1
0028a7                           pulse2_fx_4xy_depth: .byte 1
0028a8                           pulse2_fx_4xy_phase: .byte 1
0028a9                           pulse2_fx_7xy_speed: .byte 1
0028aa                           pulse2_fx_7xy_depth: .byte 1
0028ab                           pulse2_fx_7xy_phase: .byte 1
0028ac                           pulse2_fx_7xy_value: .byte 1 //value to offset the volume
0028ad                           pulse2_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
0028ae                           pulse2_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028af                           pulse2_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028b0                           pulse2_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
0028b2                           pulse2_fx_Qxy_target: .byte 2 //target note period
0028b4                           pulse2_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
0028b6                           pulse2_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
0028b8                           pulse2_fx_Rxy_target: .byte 2 //target note period
0028ba                           pulse2_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
0028bc                           pulse2_fx_Rxy_total_offset: .byte 2
0028be                           pulse2_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
0028bf                           pulse2_fx_Sxx_post: .byte 1
                                 
                                 //TRIANGLE
0028c0                           triangle_pattern: .byte 2
0028c2                           triangle_pattern_delay_rows: .byte 1
0028c3                           triangle_pattern_delay_frames: .byte 1
0028c4                           triangle_pattern_offset: .byte 2
                                 
0028c6                           triangle_volume_macro: .byte 2
0028c8                           triangle_volume_macro_offset: .byte 1
0028c9                           triangle_volume_macro_loop: .byte 1
0028ca                           triangle_volume_macro_release: .byte 1
                                 
0028cb                           triangle_arpeggio_macro: .byte 2
0028cd                           triangle_arpeggio_macro_offset: .byte 1
0028ce                           triangle_arpeggio_macro_loop: .byte 1
0028cf                           triangle_arpeggio_macro_release: .byte 1
0028d0                           triangle_arpeggio_macro_mode: .byte 1
                                 
0028d1                           triangle_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
0028d3                           triangle_pitch_macro: .byte 2
0028d5                           triangle_pitch_macro_offset: .byte 1
0028d6                           triangle_pitch_macro_loop: .byte 1
0028d7                           triangle_pitch_macro_release: .byte 1
                                 
0028d8                           triangle_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
0028d9                           triangle_hi_pitch_macro: .byte 2
0028db                           triangle_hi_pitch_macro_offset: .byte 1
0028dc                           triangle_hi_pitch_macro_loop: .byte 1
0028dd                           triangle_hi_pitch_macro_release: .byte 1
                                 
0028de                           triangle_duty_macro: .byte 2
0028e0                           triangle_duty_macro_offset: .byte 1
0028e1                           triangle_duty_macro_loop: .byte 1
0028e2                           triangle_duty_macro_release: .byte 1
                                 
0028e3                           triangle_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
0028e5                           triangle_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
0028e7                           triangle_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
0028e9                           triangle_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
0028eb                           triangle_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
0028ed                           triangle_fx_3xx_start: .byte 2 //the starting note period
0028ef                           triangle_fx_3xx_target: .byte 2 //target note period
0028f1                           triangle_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028f3                           triangle_fx_3xx_total_offset: .byte 2
0028f5                           triangle_fx_4xy_speed: .byte 1
0028f6                           triangle_fx_4xy_depth: .byte 1
0028f7                           triangle_fx_4xy_phase: .byte 1
0028f8                           triangle_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028f9                           triangle_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028fa                           triangle_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
0028fc                           triangle_fx_Qxy_target: .byte 2 //target note period
0028fe                           triangle_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002900                           triangle_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002902                           triangle_fx_Rxy_target: .byte 2 //target note period
002904                           triangle_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
002906                           triangle_fx_Rxy_total_offset: .byte 2
002908                           triangle_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002909                           triangle_fx_Sxx_post: .byte 1
                                 
                                 //NOISE
00290a                           noise_pattern: .byte 2
00290c                           noise_pattern_delay_rows: .byte 1
00290d                           noise_pattern_delay_frames: .byte 1
00290e                           noise_pattern_offset: .byte 2
                                 
002910                           noise_volume_macro: .byte 2
002912                           noise_volume_macro_offset: .byte 1
002913                           noise_volume_macro_loop: .byte 1
002914                           noise_volume_macro_release: .byte 1
                                 
002915                           noise_arpeggio_macro: .byte 2
002917                           noise_arpeggio_macro_offset: .byte 1
002918                           noise_arpeggio_macro_loop: .byte 1
002919                           noise_arpeggio_macro_release: .byte 1
00291a                           noise_arpeggio_macro_mode: .byte 1
                                 
00291b                           noise_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
00291d                           noise_pitch_macro: .byte 2
00291f                           noise_pitch_macro_offset: .byte 1
002920                           noise_pitch_macro_loop: .byte 1
002921                           noise_pitch_macro_release: .byte 1
                                 
002922                           noise_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
002923                           noise_hi_pitch_macro: .byte 2
002925                           noise_hi_pitch_macro_offset: .byte 1
002926                           noise_hi_pitch_macro_loop: .byte 1
002927                           noise_hi_pitch_macro_release: .byte 1
                                 
002928                           noise_duty_macro: .byte 2
00292a                           noise_duty_macro_offset: .byte 1
00292b                           noise_duty_macro_loop: .byte 1
00292c                           noise_duty_macro_release: .byte 1
                                 
00292d                           noise_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
00292f                           noise_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002931                           noise_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
002933                           noise_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
002935                           noise_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
002937                           noise_fx_3xx_start: .byte 2 //the starting note period
002939                           noise_fx_3xx_target: .byte 2 //target note period
00293b                           noise_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
00293d                           noise_fx_3xx_total_offset: .byte 2
00293f                           noise_fx_4xy_speed: .byte 1
002940                           noise_fx_4xy_depth: .byte 1
002941                           noise_fx_4xy_phase: .byte 1
002942                           noise_fx_7xy_speed: .byte 1
002943                           noise_fx_7xy_depth: .byte 1
002944                           noise_fx_7xy_phase: .byte 1
002945                           noise_fx_7xy_value: .byte 1 //value to offset the volume
002946                           noise_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
002947                           noise_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002948                           noise_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002949                           noise_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
00294b                           noise_fx_Qxy_target: .byte 2 //target note period
00294d                           noise_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
00294f                           noise_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002951                           noise_fx_Rxy_target: .byte 2 //target note period
002953                           noise_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
002955                           noise_fx_Rxy_total_offset: .byte 2
002957                           noise_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002958                           noise_fx_Sxx_post: .byte 1
                                 
                                 //DPCM
002959                           dcpm_pattern_delay: .byte 1
                                 
                                 .cseg
                                 
                                 //NOTE: zero is defined in order to use the cp instruction without the need to load 0x00 into a register beforehand
                                 .def zero = r2
                                 .def pulse_channel_flags = r25 //[pulse1.pulse2] RSlc.RSlc = Reload, Start, Length halt/Loop, Constant volume
                                 .def pulse1_sequence = r10
                                 .def pulse1_length_counter = r11
                                 .def pulse1_sweep = r12 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse1_volume_divider = r16 //0000.PPPP = Period divider
                                 .def pulse1_volume_decay = r17 //0000.dddd = Decay
                                 .def pulse2_sequence = r13
                                 .def pulse2_length_counter = r14
                                 .def pulse2_sweep = r15 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse2_volume_divider = r18 //0000.PPPP = Period divider
                                 .def pulse2_volume_decay = r19 //0000.dddd = Decay
                                 .def triangle_sequence = r20
                                 .def noise_sequence_LOW = r21
                                 .def noise_sequence_HIGH = r22
                                 
                                 reset:
000000 940c 135b                 	jmp init
                                 
                                 .org TCA0_OVF_vect
00000e 940c 1808                 	jmp sound_driver
                                 
                                 .org TCA0_CMP0_vect
000012 940c 170f                 	jmp sequence_0_2
                                 
                                 .org TCA0_CMP1_vect
000014 940c 171a                 	jmp sequence_1_3
                                 
                                 .org TCA0_CMP2_vect
000016 940c 170f                 	jmp sequence_0_2
                                 
                                 .org TCB0_INT_vect
000018 940c 1731                 	jmp pulse1_sequence_routine
                                 
                                 .org TCB1_INT_vect
00001a 940c 177e                 	jmp pulse2_sequence_routine
                                 
                                 .org TCB2_INT_vect
000032 940c 17cb                 	jmp triangle_sequence_routine
                                 
                                 .org TCB3_INT_vect
000048 940c 17d6                 	jmp noise_sequence_routine
                                 
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(33): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(48): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(87): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(88): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(89): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(90): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(91): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(92): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(93): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(94): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(95): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(96): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(97): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(98): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(99): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(100): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(101): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(102): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(104): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(105): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(107): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(108): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(109): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(111): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(112): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(113): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(115): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(116): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(117): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(118): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(121): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(122): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(123): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(126): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(128): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(129): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(130): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(135): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(137): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(138): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(139): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(144): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(147): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(149): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(150): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(151): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(152): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(153): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(154): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(155): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(156): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(157): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(160): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(161): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(162): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(168): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(169): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(171): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(173): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(174): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(176): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(177): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(179): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(180): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(181): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(185): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(186): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(297): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(298): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(299): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(301): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(306): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(307): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(308): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(309): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(310): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(311): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(312): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(313): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(314): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(316): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(320): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(321): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(322): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(323): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(325): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(326): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(328): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(332): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(336): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(337): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(338): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(339): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(341): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(342): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(343): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(346): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(347): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(350): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(351): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(353): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(360): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(361): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
                                 .list
                                 
                                 init:
                                 	//MAIN CLOCK
00135b edc8                      	ldi r28, CPU_CCP_IOREG_gc //protected write
00135c 93c0 0034                 	sts CPU_CCP, r28
00135e e0c0                      	ldi r28, 0 << CLKCTRL_PEN_bp //disable prescaler for 20 MHz on main clock
00135f 93c0 0061                 	sts CLKCTRL_MCLKCTRLB, r28
                                 
                                 	//ZERO
001361 2422                      	clr zero
                                 
                                 	//MEMORY
001362 e3c0                      	ldi r28, 0b00110000
001363 93c0 2800                 	sts pulse1_param, r28
001365 e8c0                      	ldi r28, 0b10000000
001366 93c0 2801                 	sts pulse1_sweep_param, r28
001368 efcf                      	ldi r28, 0xFF
001369 93c0 2802                 	sts pulse1_timerL, r28
00136b 93c0 2803                 	sts pulse1_timerH, r28
00136d 93c0 2804                 	sts pulse1_length, r28
                                 
00136f e3c0                      	ldi r28, 0b00110000
001370 93c0 2808                 	sts pulse2_param, r28
001372 e8c0                      	ldi r28, 0b10000000
001373 93c0 2809                 	sts pulse2_sweep_param, r28
001375 efcf                      	ldi r28, 0xFF
001376 93c0 280a                 	sts pulse2_timerL, r28
001378 93c0 280b                 	sts pulse2_timerH, r28
00137a 93c0 280c                 	sts pulse2_length, r28
                                 
00137c efcf                      	ldi r28, 0xFF
00137d 93c0 2810                 	sts triangle_timerL, r28
00137f 93c0 2811                 	sts triangle_timerH, r28
                                 
001381 e3c0                      	ldi r28, 0b00110000
001382 93c0 2813                 	sts noise_param, r28
001384 e0cf                      	ldi r28, 0b00001111
001385 93c0 2814                 	sts noise_period, r28
                                 
001387 e0c2                      	ldi r28, 0x02
001388 93c0 281a                 	sts song_frame_offset, r28
00138a 9220 281b                 	sts song_frame_offset+1, zero
00138c efcf                      	ldi r28, 0xFF
00138d 93c0 281f                 	sts song_fx_Bxx, r28
00138f 9220 2820                 	sts song_fx_Cxx, zero
001391 9220 2821                 	sts song_fx_Dxx, zero
001393 e4ee                      	ldi ZL, LOW(song0_frames << 1)
001394 e0f3                      	ldi ZH, HIGH(song0_frames << 1)
001395 93e0 2818                 	sts song_frames, ZL
001397 93f0 2819                 	sts song_frames+1, ZH
001399 91c5                      	lpm r28, Z+ //load the song size
00139a 91d5                      	lpm r29, Z+
00139b 93c0 281c                 	sts song_size, r28
00139d 93d0 281d                 	sts song_size+1, r29
00139f 9220 281e                 	sts song_speed, zero
                                 
                                 	//CHANNEL 0
0013a1 91c5                      	lpm r28, Z+
0013a2 91d5                      	lpm r29, Z+
0013a3 0fcc                      	lsl r28
0013a4 1fdd                      	rol r29
0013a5 93c0 2822                 	sts pulse1_pattern, r28
0013a7 93d0 2823                 	sts pulse1_pattern+1, r29
0013a9 9220 2824                 	sts pulse1_pattern_delay_rows, zero
0013ab 9220 2825                 	sts pulse1_pattern_delay_frames, zero
0013ad 9220 2826                 	sts pulse1_pattern_offset, zero
0013af 9220 2827                 	sts pulse1_pattern_offset+1, zero
                                 
                                 	//CHANNEL 1
0013b1 91c5                      	lpm r28, Z+
0013b2 91d5                      	lpm r29, Z+
0013b3 0fcc                      	lsl r28
0013b4 1fdd                      	rol r29
0013b5 93c0 2871                 	sts pulse2_pattern, r28
0013b7 93d0 2872                 	sts pulse2_pattern+1, r29
0013b9 9220 2873                 	sts pulse2_pattern_delay_rows, zero
0013bb 9220 2874                 	sts pulse2_pattern_delay_frames, zero
0013bd 9220 2875                 	sts pulse2_pattern_offset, zero
0013bf 9220 2876                 	sts pulse2_pattern_offset+1, zero
                                 
                                 	//CHANNEL 2
0013c1 91c5                      	lpm r28, Z+
0013c2 91d5                      	lpm r29, Z+
0013c3 0fcc                      	lsl r28
0013c4 1fdd                      	rol r29
0013c5 93c0 28c0                 	sts triangle_pattern, r28
0013c7 93d0 28c1                 	sts triangle_pattern+1, r29
0013c9 9220 28c2                 	sts triangle_pattern_delay_rows, zero
0013cb 9220 28c3                 	sts triangle_pattern_delay_frames, zero
0013cd 9220 28c4                 	sts triangle_pattern_offset, zero
0013cf 9220 28c5                 	sts triangle_pattern_offset+1, zero
                                 
                                 	//CHANNEL 3
0013d1 91c5                      	lpm r28, Z+
0013d2 91d5                      	lpm r29, Z+
0013d3 0fcc                      	lsl r28
0013d4 1fdd                      	rol r29
0013d5 93c0 290a                 	sts noise_pattern, r28
0013d7 93d0 290b                 	sts noise_pattern+1, r29
0013d9 9220 290c                 	sts noise_pattern_delay_rows, zero
0013db 9220 290d                 	sts noise_pattern_delay_frames, zero
0013dd 9220 290e                 	sts noise_pattern_offset, zero
0013df 9220 290f                 	sts noise_pattern_offset+1, zero
                                 
                                 	//CHANNEL 0 instrument macros
0013e1 efcf                      	ldi r28, 0xFF
0013e2 9220 282a                 	sts pulse1_volume_macro_offset, zero
0013e4 93c0 282b                 	sts pulse1_volume_macro_loop, r28
0013e6 93c0 282c                 	sts pulse1_volume_macro_release, r28
0013e8 9220 282f                 	sts pulse1_arpeggio_macro_offset, zero
0013ea 93c0 2830                 	sts pulse1_arpeggio_macro_loop, r28
0013ec 93c0 2831                 	sts pulse1_arpeggio_macro_release, r28
0013ee 93c0 2832                 	sts pulse1_arpeggio_macro_mode, r28
0013f0 9220 2837                 	sts pulse1_pitch_macro_offset, zero
0013f2 93c0 2838                 	sts pulse1_pitch_macro_loop, r28
0013f4 93c0 2839                 	sts pulse1_pitch_macro_release, r28
0013f6 9220 283d                 	sts pulse1_hi_pitch_macro_offset, zero
0013f8 93c0 283e                 	sts pulse1_hi_pitch_macro_loop, r28
0013fa 93c0 283f                 	sts pulse1_hi_pitch_macro_release, r28
0013fc 9220 2842                 	sts pulse1_duty_macro_offset, zero
0013fe 93c0 2843                 	sts pulse1_duty_macro_loop, r28
001400 93c0 2844                 	sts pulse1_duty_macro_release, r28
                                 
001402 9220 2828                 	sts pulse1_volume_macro, zero
001404 9220 2829                 	sts pulse1_volume_macro+1, zero
001406 9220 282d                 	sts pulse1_arpeggio_macro, zero
001408 9220 282e                 	sts pulse1_arpeggio_macro+1, zero
00140a 9220 2833                 	sts pulse1_total_pitch_offset, zero
00140c 9220 2834                 	sts pulse1_total_pitch_offset+1, zero
00140e 9220 2835                 	sts pulse1_pitch_macro, zero
001410 9220 2836                 	sts pulse1_pitch_macro+1, zero
001412 9220 283a                 	sts pulse1_total_hi_pitch_offset, zero
001414 9220 283b                 	sts pulse1_hi_pitch_macro, zero
001416 9220 283c                 	sts pulse1_hi_pitch_macro+1, zero
001418 9220 2840                 	sts pulse1_duty_macro, zero
00141a 9220 2841                 	sts pulse1_duty_macro+1, zero
                                 
                                 	//CHANNEL 0 ENVELOPE
00141c e00f                      	ldi pulse1_volume_divider, 0x0F
00141d 9110 2800                 	lds pulse1_volume_decay, pulse1_param
00141f 701f                      	andi pulse1_volume_decay, 0x0F //mask for VVVV bits
001420 9190 2800                 	lds pulse_channel_flags, pulse1_param
001422 7390                      	andi pulse_channel_flags, 0b00110000
001423 6490                      	sbr pulse_channel_flags, 0b01000000 //set start flag
001424 9220 2806                 	sts pulse1_output_volume, zero
001426 93c0 2805                 	sts pulse1_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 0 LENGTH
001428 2ebc                      	mov pulse1_length_counter, r28
                                 
                                 	//CHANNEL 0 SEQUENCE
001429 e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
00142a 2eac                      	mov pulse1_sequence, r28
                                 
                                 	//CHANNEL 0 SWEEP
00142b 90c0 2801                 	lds pulse1_sweep, pulse1_sweep_param
00142d 94c2                      	swap pulse1_sweep //swap data from high byte and low byte
00142e 6890                      	sbr pulse_channel_flags, 0b10000000 //set reload flag
                                 
                                 	//CHANNEL 0 FX
00142f efcf                      	ldi r28, 0xFF
001430 9220 2845                 	sts pulse1_fx_0xy_sequence, zero
001432 9220 2846                 	sts pulse1_fx_0xy_sequence+1, zero
001434 9220 2847                 	sts pulse1_fx_1xx, zero
001436 9220 2848                 	sts pulse1_fx_1xx+1, zero
001438 9220 2849                 	sts pulse1_fx_1xx_total, zero
00143a 9220 284a                 	sts pulse1_fx_1xx_total+1, zero
00143c 9220 284b                 	sts pulse1_fx_2xx, zero
00143e 9220 284c                 	sts pulse1_fx_2xx+1, zero
001440 9220 284d                 	sts pulse1_fx_2xx_total, zero
001442 9220 284e                 	sts pulse1_fx_2xx_total+1, zero
001444 9220 284f                 	sts pulse1_fx_3xx_start, zero
001446 9220 2850                 	sts pulse1_fx_3xx_start+1, zero
001448 9220 2851                 	sts pulse1_fx_3xx_target, zero
00144a 9220 2852                 	sts pulse1_fx_3xx_target+1, zero
00144c 9220 2853                 	sts pulse1_fx_3xx_speed, zero
00144e 9220 2854                 	sts pulse1_fx_3xx_speed+1, zero
001450 9220 2855                 	sts pulse1_fx_3xx_total_offset, zero
001452 9220 2856                 	sts pulse1_fx_3xx_total_offset+1, zero
001454 9220 2857                 	sts pulse1_fx_4xy_speed, zero
001456 9220 2858                 	sts pulse1_fx_4xy_depth, zero
001458 9220 2859                 	sts pulse1_fx_4xy_phase, zero
00145a 9220 285a                 	sts pulse1_fx_7xy_speed, zero
00145c 9220 285b                 	sts pulse1_fx_7xy_depth, zero
00145e 9220 285c                 	sts pulse1_fx_7xy_phase, zero
001460 9220 285d                 	sts pulse1_fx_7xy_value, zero
001462 9220 285e                 	sts pulse1_fx_Axy, zero
001464 93c0 285f                 	sts pulse1_fx_Gxx_pre, r28
001466 93c0 2860                 	sts pulse1_fx_Gxx_post, r28
001468 9220 2861                 	sts pulse1_fx_Pxx_total, zero
00146a 9220 2862                 	sts pulse1_fx_Pxx_total+1, zero
00146c 9220 2863                 	sts pulse1_fx_Qxy_target, zero
00146e 9220 2864                 	sts pulse1_fx_Qxy_target+1, zero
001470 9220 2865                 	sts pulse1_fx_Qxy_speed, zero
001472 9220 2866                 	sts pulse1_fx_Qxy_speed+1, zero
001474 9220 2867                 	sts pulse1_fx_Qxy_total_offset, zero
001476 9220 2868                 	sts pulse1_fx_Qxy_total_offset+1, zero
001478 9220 2869                 	sts pulse1_fx_Rxy_target, zero
00147a 9220 286a                 	sts pulse1_fx_Rxy_target+1, zero
00147c 9220 286b                 	sts pulse1_fx_Rxy_speed, zero
00147e 9220 286c                 	sts pulse1_fx_Rxy_speed+1, zero
001480 9220 286d                 	sts pulse1_fx_Rxy_total_offset, zero
001482 9220 286e                 	sts pulse1_fx_Rxy_total_offset+1, zero
001484 93c0 286f                 	sts pulse1_fx_Sxx_pre, r28
001486 93c0 2870                 	sts pulse1_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 1 instrument macros
001488 efcf                      	ldi r28, 0xFF
001489 9220 2879                 	sts pulse2_volume_macro_offset, zero
00148b 93c0 287a                 	sts pulse2_volume_macro_loop, r28
00148d 93c0 287b                 	sts pulse2_volume_macro_release, r28
00148f 9220 287e                 	sts pulse2_arpeggio_macro_offset, zero
001491 93c0 287f                 	sts pulse2_arpeggio_macro_loop, r28
001493 93c0 2880                 	sts pulse2_arpeggio_macro_release, r28
001495 93c0 2881                 	sts pulse2_arpeggio_macro_mode, r28
001497 9220 2886                 	sts pulse2_pitch_macro_offset, zero
001499 93c0 2887                 	sts pulse2_pitch_macro_loop, r28
00149b 93c0 2888                 	sts pulse2_pitch_macro_release, r28
00149d 9220 288c                 	sts pulse2_hi_pitch_macro_offset, zero
00149f 93c0 288d                 	sts pulse2_hi_pitch_macro_loop, r28
0014a1 93c0 288e                 	sts pulse2_hi_pitch_macro_release, r28
0014a3 9220 2891                 	sts pulse2_duty_macro_offset, zero
0014a5 93c0 2892                 	sts pulse2_duty_macro_loop, r28
0014a7 93c0 2893                 	sts pulse2_duty_macro_release, r28
                                 
0014a9 9220 2877                 	sts pulse2_volume_macro, zero
0014ab 9220 2878                 	sts pulse2_volume_macro+1, zero
0014ad 9220 287c                 	sts pulse2_arpeggio_macro, zero
0014af 9220 287d                 	sts pulse2_arpeggio_macro+1, zero
0014b1 9220 2882                 	sts pulse2_total_pitch_offset, zero
0014b3 9220 2883                 	sts pulse2_total_pitch_offset+1, zero
0014b5 9220 2884                 	sts pulse2_pitch_macro, zero
0014b7 9220 2885                 	sts pulse2_pitch_macro+1, zero
0014b9 9220 2889                 	sts pulse2_total_hi_pitch_offset, zero
0014bb 9220 288a                 	sts pulse2_hi_pitch_macro, zero
0014bd 9220 288b                 	sts pulse2_hi_pitch_macro+1, zero
0014bf 9220 288f                 	sts pulse2_duty_macro, zero
0014c1 9220 2890                 	sts pulse2_duty_macro+1, zero
                                 
                                 	//CHANNEL 1 ENVELOPE
0014c3 e02f                      	ldi pulse2_volume_divider, 0x0F
0014c4 9130 2808                 	lds pulse2_volume_decay, pulse2_param
0014c6 703f                      	andi pulse2_volume_decay, 0x0F //mask for VVVV bits
0014c7 91d0 2808                 	lds r29, pulse2_param
0014c9 73d0                      	andi r29, 0b00110000
0014ca 62d0                      	sbr r29, 0b0100000 //set start flag
0014cb 95d2                      	swap r29
0014cc 2b9d                      	or pulse_channel_flags, r29
0014cd 9220 280e                 	sts pulse2_output_volume, zero
0014cf 93c0 280d                 	sts pulse2_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 1 LENGTH
0014d1 2eec                      	mov pulse2_length_counter, r28
                                 
                                 	//CHANNEL 1 SEQUENCE
0014d2 e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
0014d3 2edc                      	mov pulse2_sequence, r28
                                 
                                 	//CHANNEL 1 SWEEP
0014d4 90f0 2809                 	lds pulse2_sweep, pulse2_sweep_param
0014d6 94f2                      	swap pulse2_sweep //swap data from high byte and low byte
0014d7 6098                      	sbr pulse_channel_flags, 0b00001000 //set reload flag
                                 
                                 	//CHANNEL 1 FX
0014d8 efcf                      	ldi r28, 0xFF
0014d9 9220 2894                 	sts pulse2_fx_0xy_sequence, zero
0014db 9220 2895                 	sts pulse2_fx_0xy_sequence+1, zero
0014dd 9220 2896                 	sts pulse2_fx_1xx, zero
0014df 9220 2897                 	sts pulse2_fx_1xx+1, zero
0014e1 9220 2898                 	sts pulse2_fx_1xx_total, zero
0014e3 9220 2899                 	sts pulse2_fx_1xx_total+1, zero
0014e5 9220 289a                 	sts pulse2_fx_2xx, zero
0014e7 9220 289b                 	sts pulse2_fx_2xx+1, zero
0014e9 9220 289c                 	sts pulse2_fx_2xx_total, zero
0014eb 9220 289d                 	sts pulse2_fx_2xx_total+1, zero
0014ed 9220 289e                 	sts pulse2_fx_3xx_start, zero
0014ef 9220 289f                 	sts pulse2_fx_3xx_start+1, zero
0014f1 9220 28a0                 	sts pulse2_fx_3xx_target, zero
0014f3 9220 28a1                 	sts pulse2_fx_3xx_target+1, zero
0014f5 9220 28a2                 	sts pulse2_fx_3xx_speed, zero
0014f7 9220 28a3                 	sts pulse2_fx_3xx_speed+1, zero
0014f9 9220 28a4                 	sts pulse2_fx_3xx_total_offset, zero
0014fb 9220 28a5                 	sts pulse2_fx_3xx_total_offset+1, zero
0014fd 9220 28a6                 	sts pulse2_fx_4xy_speed, zero
0014ff 9220 28a7                 	sts pulse2_fx_4xy_depth, zero
001501 9220 28a8                 	sts pulse2_fx_4xy_phase, zero
001503 9220 28a9                 	sts pulse2_fx_7xy_speed, zero
001505 9220 28aa                 	sts pulse2_fx_7xy_depth, zero
001507 9220 28ab                 	sts pulse2_fx_7xy_phase, zero
001509 9220 28ac                 	sts pulse2_fx_7xy_value, zero
00150b 9220 28ad                 	sts pulse2_fx_Axy, zero
00150d 93c0 28ae                 	sts pulse2_fx_Gxx_pre, r28
00150f 93c0 28af                 	sts pulse2_fx_Gxx_post, r28
001511 9220 28b0                 	sts pulse2_fx_Pxx_total, zero
001513 9220 28b1                 	sts pulse2_fx_Pxx_total+1, zero
001515 9220 28b2                 	sts pulse2_fx_Qxy_target, zero
001517 9220 28b3                 	sts pulse2_fx_Qxy_target+1, zero
001519 9220 28b4                 	sts pulse2_fx_Qxy_speed, zero
00151b 9220 28b5                 	sts pulse2_fx_Qxy_speed+1, zero
00151d 9220 28b6                 	sts pulse2_fx_Qxy_total_offset, zero
00151f 9220 28b7                 	sts pulse2_fx_Qxy_total_offset+1, zero
001521 9220 28b8                 	sts pulse2_fx_Rxy_target, zero
001523 9220 28b9                 	sts pulse2_fx_Rxy_target+1, zero
001525 9220 28ba                 	sts pulse2_fx_Rxy_speed, zero
001527 9220 28bb                 	sts pulse2_fx_Rxy_speed+1, zero
001529 9220 28bc                 	sts pulse2_fx_Rxy_total_offset, zero
00152b 9220 28bd                 	sts pulse2_fx_Rxy_total_offset+1, zero
00152d 93c0 28be                 	sts pulse2_fx_Sxx_pre, r28
00152f 93c0 28bf                 	sts pulse2_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 2 instrument macros
001531 efcf                      	ldi r28, 0xFF
001532 9220 28c8                 	sts triangle_volume_macro_offset, zero
001534 93c0 28c9                 	sts triangle_volume_macro_loop, r28
001536 93c0 28ca                 	sts triangle_volume_macro_release, r28
001538 9220 28cd                 	sts triangle_arpeggio_macro_offset, zero
00153a 93c0 28ce                 	sts triangle_arpeggio_macro_loop, r28
00153c 93c0 28cf                 	sts triangle_arpeggio_macro_release, r28
00153e 93c0 28d0                 	sts triangle_arpeggio_macro_mode, r28
001540 9220 28d5                 	sts triangle_pitch_macro_offset, zero
001542 93c0 28d6                 	sts triangle_pitch_macro_loop, r28
001544 93c0 28d7                 	sts triangle_pitch_macro_release, r28
001546 9220 28db                 	sts triangle_hi_pitch_macro_offset, zero
001548 93c0 28dc                 	sts triangle_hi_pitch_macro_loop, r28
00154a 93c0 28dd                 	sts triangle_hi_pitch_macro_release, r28
00154c 9220 28e0                 	sts triangle_duty_macro_offset, zero
00154e 93c0 28e1                 	sts triangle_duty_macro_loop, r28
001550 93c0 28e2                 	sts triangle_duty_macro_release, r28
                                 
001552 9220 28c6                 	sts triangle_volume_macro, zero
001554 9220 28c7                 	sts triangle_volume_macro+1, zero
001556 9220 28cb                 	sts triangle_arpeggio_macro, zero
001558 9220 28cc                 	sts triangle_arpeggio_macro+1, zero
00155a 9220 28d1                 	sts triangle_total_pitch_offset, zero
00155c 9220 28d2                 	sts triangle_total_pitch_offset+1, zero
00155e 9220 28d3                 	sts triangle_pitch_macro, zero
001560 9220 28d4                 	sts triangle_pitch_macro+1, zero
001562 9220 28d8                 	sts triangle_total_hi_pitch_offset, zero
001564 9220 28d9                 	sts triangle_hi_pitch_macro, zero
001566 9220 28da                 	sts triangle_hi_pitch_macro+1, zero
001568 9220 28de                 	sts triangle_duty_macro, zero
00156a 9220 28df                 	sts triangle_duty_macro+1, zero
                                 
                                 	//CHANNEL 2 SEQUENCE
00156c e0c0                      	ldi r28, 0b00000000 //reset sequence to 0
00156d 2f4c                      	mov triangle_sequence, r28
                                 
                                 	//CHANNEL 2 FX
00156e efcf                      	ldi r28, 0xFF
00156f 9220 28e3                 	sts triangle_fx_0xy_sequence, zero
001571 9220 28e4                 	sts triangle_fx_0xy_sequence+1, zero
001573 9220 28e5                 	sts triangle_fx_1xx, zero
001575 9220 28e6                 	sts triangle_fx_1xx+1, zero
001577 9220 28e7                 	sts triangle_fx_1xx_total, zero
001579 9220 28e8                 	sts triangle_fx_1xx_total+1, zero
00157b 9220 28e9                 	sts triangle_fx_2xx, zero
00157d 9220 28ea                 	sts triangle_fx_2xx+1, zero
00157f 9220 28eb                 	sts triangle_fx_2xx_total, zero
001581 9220 28ec                 	sts triangle_fx_2xx_total+1, zero
001583 9220 28ed                 	sts triangle_fx_3xx_start, zero
001585 9220 28ee                 	sts triangle_fx_3xx_start+1, zero
001587 9220 28ef                 	sts triangle_fx_3xx_target, zero
001589 9220 28f0                 	sts triangle_fx_3xx_target+1, zero
00158b 9220 28f1                 	sts triangle_fx_3xx_speed, zero
00158d 9220 28f2                 	sts triangle_fx_3xx_speed+1, zero
00158f 9220 28f3                 	sts triangle_fx_3xx_total_offset, zero
001591 9220 28f4                 	sts triangle_fx_3xx_total_offset+1, zero
001593 9220 28f5                 	sts triangle_fx_4xy_speed, zero
001595 9220 28f6                 	sts triangle_fx_4xy_depth, zero
001597 9220 28f7                 	sts triangle_fx_4xy_phase, zero
001599 93c0 28f8                 	sts triangle_fx_Gxx_pre, r28
00159b 93c0 28f9                 	sts triangle_fx_Gxx_post, r28
00159d 9220 28fa                 	sts triangle_fx_Pxx_total, zero
00159f 9220 28fb                 	sts triangle_fx_Pxx_total+1, zero
0015a1 9220 28fc                 	sts triangle_fx_Qxy_target, zero
0015a3 9220 28fd                 	sts triangle_fx_Qxy_target+1, zero
0015a5 9220 28fe                 	sts triangle_fx_Qxy_speed, zero
0015a7 9220 28ff                 	sts triangle_fx_Qxy_speed+1, zero
0015a9 9220 2900                 	sts triangle_fx_Qxy_total_offset, zero
0015ab 9220 2901                 	sts triangle_fx_Qxy_total_offset+1, zero
0015ad 9220 2902                 	sts triangle_fx_Rxy_target, zero
0015af 9220 2903                 	sts triangle_fx_Rxy_target+1, zero
0015b1 9220 2904                 	sts triangle_fx_Rxy_speed, zero
0015b3 9220 2905                 	sts triangle_fx_Rxy_speed+1, zero
0015b5 9220 2906                 	sts triangle_fx_Rxy_total_offset, zero
0015b7 9220 2907                 	sts triangle_fx_Rxy_total_offset+1, zero
0015b9 93c0 2908                 	sts triangle_fx_Sxx_pre, r28
0015bb 93c0 2909                 	sts triangle_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 3 instrument macros
0015bd efcf                      	ldi r28, 0xFF
0015be 9220 2912                 	sts noise_volume_macro_offset, zero
0015c0 93c0 2913                 	sts noise_volume_macro_loop, r28
0015c2 93c0 2914                 	sts noise_volume_macro_release, r28
0015c4 9220 2917                 	sts noise_arpeggio_macro_offset, zero
0015c6 93c0 2918                 	sts noise_arpeggio_macro_loop, r28
0015c8 93c0 2919                 	sts noise_arpeggio_macro_release, r28
0015ca 93c0 291a                 	sts noise_arpeggio_macro_mode, r28
0015cc 9220 291f                 	sts noise_pitch_macro_offset, zero
0015ce 93c0 2920                 	sts noise_pitch_macro_loop, r28
0015d0 93c0 2921                 	sts noise_pitch_macro_release, r28
0015d2 9220 2925                 	sts noise_hi_pitch_macro_offset, zero
0015d4 93c0 2926                 	sts noise_hi_pitch_macro_loop, r28
0015d6 93c0 2927                 	sts noise_hi_pitch_macro_release, r28
0015d8 9220 292a                 	sts noise_duty_macro_offset, zero
0015da 93c0 292b                 	sts noise_duty_macro_loop, r28
0015dc 93c0 292c                 	sts noise_duty_macro_release, r28
                                 
0015de 9220 2910                 	sts noise_volume_macro, zero
0015e0 9220 2911                 	sts noise_volume_macro+1, zero
0015e2 9220 2915                 	sts noise_arpeggio_macro, zero
0015e4 9220 2916                 	sts noise_arpeggio_macro+1, zero
0015e6 9220 291b                 	sts noise_total_pitch_offset, zero
0015e8 9220 291c                 	sts noise_total_pitch_offset+1, zero
0015ea 9220 291d                 	sts noise_pitch_macro, zero
0015ec 9220 291e                 	sts noise_pitch_macro+1, zero
0015ee 9220 2922                 	sts noise_total_hi_pitch_offset, zero
0015f0 9220 2923                 	sts noise_hi_pitch_macro, zero
0015f2 9220 2924                 	sts noise_hi_pitch_macro+1, zero
0015f4 9220 2928                 	sts noise_duty_macro, zero
0015f6 9220 2929                 	sts noise_duty_macro+1, zero
                                 
                                 	//CHANNEL 3 VOLUME
0015f8 9220 2816                 	sts noise_output_volume, zero
0015fa 93c0 2815                 	sts noise_fractional_volume, r28 //initialize fractional volume to max value
                                 
                                 	//CHANNEL 3 SEQUENCE
0015fc e0c1                      	ldi r28, 0b00000001 //noise sequence is reset to 0x0001
0015fd 2f5c                      	mov noise_sequence_LOW, r28
0015fe 2d62                      	mov noise_sequence_HIGH, zero
                                 
                                 	//CHANNEL 3 FX
0015ff efcf                      	ldi r28, 0xFF
001600 9220 292d                 	sts noise_fx_0xy_sequence, zero
001602 9220 292e                 	sts noise_fx_0xy_sequence+1, zero
001604 9220 292f                 	sts noise_fx_1xx, zero
001606 9220 2930                 	sts noise_fx_1xx+1, zero
001608 9220 2931                 	sts noise_fx_1xx_total, zero
00160a 9220 2932                 	sts noise_fx_1xx_total+1, zero
00160c 9220 2933                 	sts noise_fx_2xx, zero
00160e 9220 2934                 	sts noise_fx_2xx+1, zero
001610 9220 2935                 	sts noise_fx_2xx_total, zero
001612 9220 2936                 	sts noise_fx_2xx_total+1, zero
001614 9220 2937                 	sts noise_fx_3xx_start, zero
001616 9220 2938                 	sts noise_fx_3xx_start+1, zero
001618 9220 2939                 	sts noise_fx_3xx_target, zero
00161a 9220 293a                 	sts noise_fx_3xx_target+1, zero
00161c 9220 293b                 	sts noise_fx_3xx_speed, zero
00161e 9220 293c                 	sts noise_fx_3xx_speed+1, zero
001620 9220 293d                 	sts noise_fx_3xx_total_offset, zero
001622 9220 293e                 	sts noise_fx_3xx_total_offset+1, zero
001624 9220 293f                 	sts noise_fx_4xy_speed, zero
001626 9220 2940                 	sts noise_fx_4xy_depth, zero
001628 9220 2941                 	sts noise_fx_4xy_phase, zero
00162a 9220 2942                 	sts noise_fx_7xy_speed, zero
00162c 9220 2943                 	sts noise_fx_7xy_depth, zero
00162e 9220 2944                 	sts noise_fx_7xy_phase, zero
001630 9220 2945                 	sts noise_fx_7xy_value, zero
001632 9220 2946                 	sts noise_fx_Axy, zero
001634 93c0 2947                 	sts noise_fx_Gxx_pre, r28
001636 93c0 2948                 	sts noise_fx_Gxx_post, r28
001638 9220 2949                 	sts noise_fx_Pxx_total, zero
00163a 9220 294a                 	sts noise_fx_Pxx_total+1, zero
00163c 9220 294b                 	sts noise_fx_Qxy_target, zero
00163e 9220 294c                 	sts noise_fx_Qxy_target+1, zero
001640 9220 294d                 	sts noise_fx_Qxy_speed, zero
001642 9220 294e                 	sts noise_fx_Qxy_speed+1, zero
001644 9220 294f                 	sts noise_fx_Qxy_total_offset, zero
001646 9220 2950                 	sts noise_fx_Qxy_total_offset+1, zero
001648 9220 2951                 	sts noise_fx_Rxy_target, zero
00164a 9220 2952                 	sts noise_fx_Rxy_target+1, zero
00164c 9220 2953                 	sts noise_fx_Rxy_speed, zero
00164e 9220 2954                 	sts noise_fx_Rxy_speed+1, zero
001650 9220 2955                 	sts noise_fx_Rxy_total_offset, zero
001652 9220 2956                 	sts noise_fx_Rxy_total_offset+1, zero
001654 93c0 2957                 	sts noise_fx_Sxx_pre, r28
001656 93c0 2958                 	sts noise_fx_Sxx_post, r28
                                 
                                 	//PINS
001658 efcf                      	ldi r28, 0xFF
001659 b9c0                      	out VPORTA_DIR, r28 //set all pins in VPORTA to output
                                 
                                 	//TIMERS
                                 	//Frame Counter
                                 	//NOTE:The frame counter will be defaulted to NTSC mode (60 Hz, 120 Hz, 240 Hz)
                                 	//Each interrupt will be setup to interrupt every 240 Hz clock
                                 	//CMP0 = sequence 0, CMP1 = sequence 1, CMP2 = sequence 2, OVF = sequence 3/sound driver
                                 	//Sequence 3 will clock the sound driver every 60Hz, in which new audio data is read and written to the registers
                                 	//Timer period Calculation: (0.00416666666 * 20000000/64)-1 = 1301.08333125 = 0x0515
                                 	//The ATmega4809 is cofigured to run at 20000000 Hz
                                 	//0.00416666666 seconds is the period for 240 Hz
                                 	//The /64 comes from the prescaler divider used
00165a e7c0                      	ldi r28, TCA_SINGLE_CMP0EN_bm | TCA_SINGLE_CMP1EN_bm | TCA_SINGLE_CMP2EN_bm | TCA_SINGLE_WGMODE_NORMAL_gc //interrupt mode
00165b 93c0 0a01                 	sts TCA0_SINGLE_CTRLB, r28
00165d e7c1                      	ldi r28, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP1_bm | TCA_SINGLE_CMP2_bm | TCA_SINGLE_OVF_bm //enable overflow and compare interrupts
00165e 93c0 0a0a                 	sts TCA0_SINGLE_INTCTRL, r28
001660 e1c5                      	ldi r28, 0x15 //set the period for CMP0
001661 93c0 0a28                 	sts TCA0_SINGLE_CMP0, r28
001663 e0c5                      	ldi r28, 0x05
001664 93c0 0a29                 	sts TCA0_SINGLE_CMP0 + 1, r28
001666 e2cb                      	ldi r28, 0x2B //set the period for CMP1
001667 93c0 0a2a                 	sts TCA0_SINGLE_CMP1, r28
001669 e0ca                      	ldi r28, 0x0A
00166a 93c0 0a2b                 	sts TCA0_SINGLE_CMP1 + 1, r28
00166c e4c1                      	ldi r28, 0x41 //set the period for CMP2
00166d 93c0 0a2c                 	sts TCA0_SINGLE_CMP2, r28
00166f e0cf                      	ldi r28, 0x0F
001670 93c0 0a2d                 	sts TCA0_SINGLE_CMP2 + 1, r28
001672 e5c7                      	ldi r28, 0x57 //set the period for OVF
001673 93c0 0a26                 	sts TCA0_SINGLE_PER, r28
001675 e1c4                      	ldi r28, 0x14
001676 93c0 0a27                 	sts TCA0_SINGLE_PER + 1, r28
001678 e0cb                      	ldi r28, TCA_SINGLE_CLKSEL_DIV64_gc | TCA_SINGLE_ENABLE_bm //use prescale divider of 64 and enable timer
001679 93c0 0a00                 	sts TCA0_SINGLE_CTRLA, r28
                                 
                                 	//NOTE: Channel Timers are clocked (20/2)/(0.8948865) = 11.1746014718 times faster than the NES APU
                                 	//Because of this, we multiply all the NES timer values by 11.1746014718 beforehand
                                 	//Since we rotate the sequence when the timer goes from t-(t-1) to 0, instead of 0 to t like the NES, we add 1 to the NES timers before multiplying
                                 	//The ATmega4809 is configured to run at 20 MHz
                                 	//The /2 comes from the prescaler divider used
                                 	//0.8948865 MHz is the speed of the NTSC NES APU
                                 	//NOTE: This means that any offset to the pitch for the NES timers would be multiplied by 11.1746014718 aswell.
                                 	//Pulse 1
00167b e0c0                      	ldi r28, TCB_CNTMODE_INT_gc //interrupt mode
00167c 93c0 0a81                 	sts TCB0_CTRLB, r28
00167e e0c1                      	ldi r28, TCB_CAPT_bm //enable interrupts
00167f 93c0 0a85                 	sts TCB0_INTCTRL, r28
001681 91c0 2802                 	lds r28, pulse1_timerL //load the LOW bits for timer
001683 93c0 0a8c                 	sts TCB0_CCMPL, r28
001685 91c0 2803                 	lds r28, pulse1_timerH //load the HIGH bits for timer
001687 93c0 0a8d                 	sts TCB0_CCMPH, r28
001689 e0c3                      	ldi r28, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
00168a 93c0 0a80                 	sts TCB0_CTRLA, r28
                                 
                                 	//PULSE 2
00168c e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
00168d 93b0 0a91                 	sts TCB1_CTRLB, r27
00168f e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001690 93b0 0a95                 	sts TCB1_INTCTRL, r27
001692 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
001694 93b0 0a9c                 	sts TCB1_CCMPL, r27
001696 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
001698 93b0 0a9d                 	sts TCB1_CCMPH, r27
00169a e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
00169b 93b0 0a90                 	sts TCB1_CTRLA, r27
                                 
                                 	//NOTE: The triangle timer is clocked at the same speed as the NES CPU, aka twice the NES APU.
                                 	//Therefore, we won't be using a /2 clock divider like we did with the pulse timers.
                                 	//TRIANGLE
00169d e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
00169e 93b0 0aa1                 	sts TCB2_CTRLB, r27
0016a0 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
0016a1 93b0 0aa5                 	sts TCB2_INTCTRL, r27
0016a3 91b0 2810                 	lds r27, triangle_timerL //load the LOW bits for timer
0016a5 93b0 0aac                 	sts TCB2_CCMPL, r27
0016a7 91b0 2811                 	lds r27, triangle_timerH //load the HIGH bits for timer
0016a9 93b0 0aad                 	sts TCB2_CCMPH, r27
0016ab e0b1                      	ldi r27, TCB_CLKSEL_CLKDIV1_gc | TCB_ENABLE_bm //use prescaler divider of 1 and enable timer
0016ac 93b0 0aa0                 	sts TCB2_CTRLA, r27
0016ae 9478                      	sei //global interrupt enable
                                 
                                 	//NOISE
0016af e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
0016b0 93b0 0ab1                 	sts TCB3_CTRLB, r27
0016b2 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
0016b3 93b0 0ab5                 	sts TCB3_INTCTRL, r27
0016b5 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
0016b7 93b0 0abc                 	sts TCB3_CCMPL, r27
0016b9 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
0016bb 93b0 0abd                 	sts TCB3_CCMPH, r27
0016bd e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
0016be 93b0 0ab0                 	sts TCB3_CTRLA, r27
                                 
                                 
                                 
                                 //https://wiki.nesdev.com/w/index.php/APU_Mixer
                                 volume_mixer:
0016c0 91c0 2806                 	lds r28, pulse1_output_volume
0016c2 91d0 280e                 	lds r29, pulse2_output_volume
                                 
                                 volume_mixer_pulse1:
0016c4 fea0                      	sbrs pulse1_sequence, 0 //if the sequence output is zero, return
0016c5 c015                      	rjmp volume_mixer_pulse1_off
                                 
0016c6 14b2                      	cp pulse1_length_counter, zero //if length is zero, return
0016c7 f099                      	breq volume_mixer_pulse1_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
0016c8 91e0 0a8c                 	lds r30, TCB0_CCMPL
0016ca e5f9                      	ldi r31, 0x059
0016cb 17ef                      	cp r30, r31
0016cc 91e0 0a8d                 	lds r30, TCB0_CCMPH
0016ce e0f0                      	ldi r31, 0x00
0016cf 07ef                      	cpc r30, r31
0016d0 f050                      	brlo volume_mixer_pulse1_off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $5965
0016d1 91e0 0a8c                 	lds r30, TCB0_CCMPL
0016d3 e6f6                      	ldi r31, 0x66
0016d4 17ef                      	cp r30, r31
0016d5 91e0 0a8d                 	lds r30, TCB0_CCMPH
0016d7 e5f9                      	ldi r31, 0x59
0016d8 07ef                      	cpc r30, r31
0016d9 f408                      	brsh volume_mixer_pulse1_off
0016da c001                      	rjmp volume_mixer_pulse2 //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse1_off:
0016db 27cc                      	clr r28
                                 
                                 volume_mixer_pulse2:
0016dc fed0                      	sbrs pulse2_sequence, 0 //if the sequence output is zero, return
0016dd c015                      	rjmp volume_mixer_pulse2_off
                                 
0016de 14e2                      	cp pulse2_length_counter, zero //if length is zero, return
0016df f099                      	breq volume_mixer_pulse2_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
0016e0 91e0 0a9c                 	lds r30, TCB1_CCMPL
0016e2 e5f9                      	ldi r31, 0x059
0016e3 17ef                      	cp r30, r31
0016e4 91e0 0a9d                 	lds r30, TCB1_CCMPH
0016e6 e0f0                      	ldi r31, 0x00
0016e7 07ef                      	cpc r30, r31
0016e8 f050                      	brlo volume_mixer_pulse2_off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $5965
0016e9 91e0 0a9c                 	lds r30, TCB1_CCMPL
0016eb e6f6                      	ldi r31, 0x66
0016ec 17ef                      	cp r30, r31
0016ed 91e0 0a9d                 	lds r30, TCB1_CCMPH
0016ef e5f9                      	ldi r31, 0x59
0016f0 07ef                      	cpc r30, r31
0016f1 f408                      	brsh volume_mixer_pulse2_off
0016f2 c001                      	rjmp volume_mixer_pulse_out //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse2_off:
0016f3 27dd                      	clr r29
                                 
                                 volume_mixer_pulse_out:
0016f4 0fcd                      	add r28, r29
0016f5 e6e2                      	ldi ZL, LOW(pulse_volume_table << 1)
0016f6 e0f2                      	ldi ZH, HIGH(pulse_volume_table << 1)
0016f7 0fec                      	add ZL, r28
0016f8 1df2                      	adc ZH, zero
0016f9 91c4                      	lpm r28, Z
                                 
                                 volume_mixer_tnd_triangle:
0016fa 2fd4                      	mov r29, triangle_sequence
0016fb fdd4                      	sbrc r29, 4 //check 5th bit
0016fc 95d0                      	com r29
0016fd 70df                      	andi r29, 0x0F
0016fe 2fed                      	mov r30, r29
0016ff 0fde                      	add r29, r30 //multiply the triangle volume by 3
001700 0fde                      	add r29, r30
                                 
                                 volume_mixer_tnd_noise:
001701 ff50                      	sbrs noise_sequence_LOW, 0 //check 0th bit, skip if set
001702 c004                      	rjmp volume_mixer_tnd_out
001703 91e0 2816                 	lds r30, noise_output_volume
001705 0fee                      	lsl r30 //multiply noise volume by 2
001706 0fde                      	add r29, r30
                                 
                                 volume_mixer_tnd_out:
001707 e8e2                      	ldi ZL, LOW(tnd_volume_table << 1)
001708 e0f2                      	ldi ZH, HIGH(tnd_volume_table << 1)
001709 0fed                      	add ZL, r29
00170a 1df2                      	adc ZH, zero
00170b 91d4                      	lpm r29, Z
                                 
                                 volume_mixer_output:
00170c 0fcd                      	add r28, r29
00170d b9c1                      	out VPORTA_OUT, r28
00170e cfb1                      	rjmp volume_mixer
                                 
                                 
                                 
                                 //FRAME COUNTER/AUDIO SAMPLE ISR
                                 sequence_0_2:
00170f b7bf                      	in r27, CPU_SREG
001710 93bf                      	push r27
001711 94f8                      	cli
                                 
                                 	//ENVELOPE
001712 d053                      	rcall pulse1_envelope_routine
001713 d09f                      	rcall pulse2_envelope_routine
                                 
001714 e5b0                      	ldi r27, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP2_bm //clear OVF flag
001715 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
001717 91bf                      	pop r27
001718 bfbf                      	out CPU_SREG, r27
001719 9518                      	reti
                                 
                                 sequence_1_3:
00171a b7bf                      	in r27, CPU_SREG
00171b 93bf                      	push r27
00171c 94f8                      	cli
                                 
                                 	//ENVELOPE
00171d d048                      	rcall pulse1_envelope_routine
00171e d094                      	rcall pulse2_envelope_routine
                                 
                                 	//SWEEP
00171f fcc3                      	sbrc pulse1_sweep, 3 //check if the sweep enable bit is cleared
001720 d01b                      	rcall pulse1_sweep_routine
001721 fcf3                      	sbrc pulse2_sweep, 3
001722 d066                      	rcall pulse2_sweep_routine
                                 
                                 	//LENGTH
                                 	//NOTE: The length routine is relatively simple, so we will not be using clocks to rjmp and ret to a seperate lable
                                 sequence_1_3_pulse1_length:
001723 fd95                      	sbrc pulse_channel_flags, 5 //check if the length counter halt bit is cleared
001724 c002                      	rjmp sequence_1_3_pulse2_length
001725 10b2                      	cpse pulse1_length_counter, zero //if length counter is already 0, don't decrement
001726 94ba                      	dec pulse1_length_counter
                                 sequence_1_3_pulse2_length:
001727 fd91                      	sbrc pulse_channel_flags, 1 //check if the length counter halt bit is cleared
001728 c002                      	rjmp sequence_1_3_exit
001729 10e2                      	cpse pulse2_length_counter, zero //if length counter is already 0, don't decrement
00172a 94ea                      	dec pulse2_length_counter
                                 
                                 sequence_1_3_exit:
00172b e2b1                      	ldi r27, TCA_SINGLE_CMP1_bm | TCA_SINGLE_OVF_bm //clear OVF flag
00172c 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
00172e 91bf                      	pop r27
00172f bfbf                      	out CPU_SREG, r27
001730 9518                      	reti
                                 
                                 //PULSE 1 ROUTINES
                                 pulse1_sequence_routine:
001731 b7bf                      	in r27, CPU_SREG
001732 93bf                      	push r27
001733 94f8                      	cli
                                 
001734 0caa                      	lsl pulse1_sequence //shifts sequence to the left
001735 1ca2                      	adc pulse1_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
001736 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
001737 93b0 0a86                 	sts TCB0_INTFLAGS, r27
001739 91bf                      	pop r27
00173a bfbf                      	out CPU_SREG, r27
00173b 9518                      	reti
                                 
                                 pulse1_sweep_routine:
00173c 2dbc                      	mov r27, pulse1_sweep
00173d 70b7                      	andi r27, 0x07 //mask for period divider bits
00173e f4f9                      	brne pulse1_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse1_sweep_routine_action: //if the divider is == 0, update the pulse timer period
00173f 93df                      	push r29
001740 2ddc                      	mov r29, pulse1_sweep
001741 95d2                      	swap r29
001742 70d7                      	andi r29, 0x07 //mask for shift bits
001743 f411                      	brne pulse1_sweep_routine_action_main //shift != 0
001744 91df                      	pop r29
001745 c019                      	rjmp pulse1_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse1_sweep_routine_action_main:
001746 91a0 0a8c                 	lds r26, TCB0_CCMPL
001748 91b0 0a8d                 	lds r27, TCB0_CCMPH
                                 pulse1_sweep_routine_action_main_loop:
00174a 95b6                      	lsr r27
00174b 95a7                      	ror r26
00174c 95da                      	dec r29
00174d f7e1                      	brne pulse1_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
00174e fec7                      	sbrs pulse1_sweep, 7 //check the negate flag
00174f c002                      	rjmp pulse1_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
001750 95a0                      	com r26 //pulse1 uses one's complement if the negate flag is set
001751 95b0                      	com r27
                                 
                                 pulse1_sweep_routine_action_main_add:
001752 91d0 0a8c                 	lds r29, TCB0_CCMPL //perform addition to get new timer period
001754 0fad                      	add r26, r29
001755 91d0 0a8d                 	lds r29, TCB0_CCMPH
001757 1fbd                      	adc r27, r29
                                 
001758 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new LOW bits for timer
00175a 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new HIGH bits for timer
                                 	
00175c 91df                      	pop r29
00175d c001                      	rjmp pulse1_sweep_routine_check_reload
                                 
                                 pulse1_sweep_routine_decrement_divider:
00175e 94ca                      	dec pulse1_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse1_sweep_routine_check_reload:
00175f ff97                      	sbrs pulse_channel_flags, 7 //if the reload flag is set, reload the sweep divider
001760 9508                      	ret
                                 
                                 pulse1_sweep_reload:
001761 90c0 2801                 	lds pulse1_sweep, pulse1_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
001763 94c2                      	swap pulse1_sweep //bring data from high byte to low byte
001764 779f                      	cbr pulse_channel_flags, 0b10000000 //clear reload flag
001765 9508                      	ret
                                 
                                 
                                 
                                 pulse1_envelope_routine:
001766 fd96                      	sbrc pulse_channel_flags, 6 //check if start flag is cleared
001767 c010                      	rjmp pulse1_envelope_routine_clear_start
                                 
001768 3000                      	cpi pulse1_volume_divider, 0x00 //check if the divider is 0
001769 f011                      	breq PC+3 //if the divider == 0, check loop flag
00176a 950a                      	dec pulse1_volume_divider //if the divider != 0, decrement and return
00176b 9508                      	ret
                                 
00176c 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the divider == 0, reset the divider period
00176e 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
00176f ff95                      	sbrs pulse_channel_flags, 5 //check if the loop flag is set
001770 c002                      	rjmp pulse1_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
001771 e01f                      	ldi pulse1_volume_decay, 0x0F //if the loop flag is set, reset decay and return
001772 9508                      	ret
                                 
                                 pulse1_envelope_routine_decrement_decay:
001773 3010                      	cpi pulse1_volume_decay, 0x00 //check if the decay is 0
001774 f409                      	brne PC+2 //if decay != 0, go decrement
001775 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
001776 951a                      	dec pulse1_volume_decay
001777 9508                      	ret
                                 
                                 pulse1_envelope_routine_clear_start:
001778 7b9f                      	cbr pulse_channel_flags, 0b01000000 //if the start flag is set, clear it
001779 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the start flag is set, reset the divider period
00177b 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
00177c e01f                      	ldi pulse1_volume_decay, 0x0F //if the start flag is set, reset decay
00177d 9508                      	ret
                                 
                                 //PULSE 2 ROUTINES
                                 pulse2_sequence_routine:
00177e b7bf                      	in r27, CPU_SREG
00177f 93bf                      	push r27
001780 94f8                      	cli
                                 
001781 0cdd                      	lsl pulse2_sequence //shifts sequence to the left
001782 1cd2                      	adc pulse2_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
001783 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
001784 93b0 0a96                 	sts TCB1_INTFLAGS, r27
001786 91bf                      	pop r27
001787 bfbf                      	out CPU_SREG, r27
001788 9518                      	reti
                                 
                                 pulse2_sweep_routine:
001789 2dbf                      	mov r27, pulse2_sweep
00178a 70b7                      	andi r27, 0x07 //mask for period divider bits
00178b f4f9                      	brne pulse2_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse2_sweep_routine_action: //if the divider is == 0, update the pulse timer period
00178c 93df                      	push r29
00178d 2ddf                      	mov r29, pulse2_sweep
00178e 95d2                      	swap r29
00178f 70d7                      	andi r29, 0x07 //mask for shift bits
001790 f411                      	brne pulse2_sweep_routine_action_main //shift != 0
001791 91df                      	pop r29
001792 c019                      	rjmp pulse2_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse2_sweep_routine_action_main:
001793 91a0 0a9c                 	lds r26, TCB1_CCMPL
001795 91b0 0a9d                 	lds r27, TCB1_CCMPH
                                 pulse2_sweep_routine_action_main_loop:
001797 95b6                      	lsr r27
001798 95a7                      	ror r26
001799 95da                      	dec r29
00179a f7e1                      	brne pulse2_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
00179b fef7                      	sbrs pulse2_sweep, 7 //check the negate flag
00179c c002                      	rjmp pulse2_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
00179d 95a0                      	com r26 //pulse2 uses one's complement if the negate flag is set
00179e 95b0                      	com r27
                                 
                                 pulse2_sweep_routine_action_main_add:
00179f 91d0 0a9c                 	lds r29, TCB1_CCMPL //perform addition to get new timer period
0017a1 0fad                      	add r26, r29
0017a2 91d0 0a9d                 	lds r29, TCB1_CCMPH
0017a4 1fbd                      	adc r27, r29
                                 
0017a5 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new LOW bits for timer
0017a7 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new HIGH bits for timer
                                 	
0017a9 91df                      	pop r29
0017aa c001                      	rjmp pulse2_sweep_routine_check_reload
                                 
                                 pulse2_sweep_routine_decrement_divider:
0017ab 94fa                      	dec pulse2_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse2_sweep_routine_check_reload:
0017ac ff93                      	sbrs pulse_channel_flags, 3 //if the reload flag is set, reload the sweep divider
0017ad 9508                      	ret
                                 
                                 pulse2_sweep_reload:
0017ae 90f0 2809                 	lds pulse2_sweep, pulse2_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
0017b0 94f2                      	swap pulse2_sweep //bring data from high byte to low byte
0017b1 7f97                      	cbr pulse_channel_flags, 0b00001000 //clear reload flag
0017b2 9508                      	ret
                                 
                                 
                                 
                                 pulse2_envelope_routine:
0017b3 fd92                      	sbrc pulse_channel_flags, 2 //check if start flag is cleared
0017b4 c010                      	rjmp pulse2_envelope_routine_clear_start
                                 
0017b5 3020                      	cpi pulse2_volume_divider, 0x00 //check if the divider is 0
0017b6 f011                      	breq PC+3 //if the divider == 0, check loop flag
0017b7 952a                      	dec pulse2_volume_divider //if the divider != 0, decrement and return
0017b8 9508                      	ret
                                 
0017b9 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the divider == 0, reset the divider period
0017bb 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
0017bc ff91                      	sbrs pulse_channel_flags, 1 //check if the loop flag is set
0017bd c002                      	rjmp pulse2_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
0017be e03f                      	ldi pulse2_volume_decay, 0x0F //if the loop flag is set, reset decay and return
0017bf 9508                      	ret
                                 
                                 pulse2_envelope_routine_decrement_decay:
0017c0 3030                      	cpi pulse2_volume_decay, 0x00 //check if the decay is 0
0017c1 f409                      	brne PC+2 //if decay != 0, go decrement
0017c2 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
0017c3 953a                      	dec pulse2_volume_decay
0017c4 9508                      	ret
                                 
                                 pulse2_envelope_routine_clear_start:
0017c5 7f9b                      	cbr pulse_channel_flags, 0b00000100 //if the start flag is set, clear it
0017c6 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the start flag is set, reset the divider period
0017c8 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
0017c9 e03f                      	ldi pulse2_volume_decay, 0x0F //if the start flag is set, reset decay
0017ca 9508                      	ret
                                 
                                 //TRIANGLE ROUTINES
                                 triangle_sequence_routine:
0017cb b7bf                      	in r27, CPU_SREG
0017cc 93bf                      	push r27
0017cd 94f8                      	cli
                                 
0017ce 5f4f                      	subi triangle_sequence, -1 //increment sequence by 1
0017cf 714f                      	andi triangle_sequence, 0b00011111 //mask out bits 5, 6 and 7 NOTE: the sequence only needs bits 0-4.
                                 
0017d0 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
0017d1 93b0 0aa6                 	sts TCB2_INTFLAGS, r27
0017d3 91bf                      	pop r27
0017d4 bfbf                      	out CPU_SREG, r27
0017d5 9518                      	reti
                                 
                                 //NOISE ROUTINES
                                 noise_sequence_routine:
0017d6 b7bf                      	in r27, CPU_SREG
0017d7 93bf                      	push r27
0017d8 94f8                      	cli
                                 
0017d9 2fa5                      	mov r26, noise_sequence_LOW
0017da fd67                      	sbrc noise_sequence_HIGH, 7 //skip if MODE bit is clear
0017db c00b                      	rjmp noise_sequence_routine_mode_set
                                 
                                 noise_sequence_routine_mode_clear:
0017dc 95a6                      	lsr r26 //move the 1th bit to the 0th bit place
0017dd 27a5                      	eor r26, noise_sequence_LOW
0017de fda0                      	sbrc r26, 0 //skip if the EOR of bit 0 and 1 is clear
0017df c003                      	rjmp noise_sequence_routine_mode_clear_EOR_set
                                 
                                 noise_sequence_routine_mode_clear_EOR_clear:
0017e0 9566                      	lsr noise_sequence_HIGH
0017e1 9557                      	ror noise_sequence_LOW
0017e2 c013                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_clear_EOR_set:
0017e3 9566                      	lsr noise_sequence_HIGH
0017e4 9557                      	ror noise_sequence_LOW
0017e5 6460                      	ori noise_sequence_HIGH, 0b01000000 //set the 14th bit
0017e6 c00f                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_set:
0017e7 0faa                      	lsl r26
0017e8 1faa                      	rol r26
0017e9 1faa                      	rol r26 //move the 6th bit to the 0th bit place
0017ea 27a5                      	eor r26, noise_sequence_LOW
0017eb fda0                      	sbrc r26, 0 //skip if the EOR of bit 0 and 1 is clear
0017ec c005                      	rjmp noise_sequence_routine_mode_set_EOR_set
                                 
                                 noise_sequence_routine_mode_set_EOR_clear:
0017ed 776f                      	cbr noise_sequence_HIGH, 0b10000000 //clear the MODE flag
0017ee 9566                      	lsr noise_sequence_HIGH
0017ef 9557                      	ror noise_sequence_LOW
0017f0 6860                      	sbr noise_sequence_HIGH, 0b10000000 //set the MODE flag
0017f1 c004                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_set_EOR_set:
0017f2 9566                      	lsr noise_sequence_HIGH
0017f3 9557                      	ror noise_sequence_LOW
0017f4 6860                      	sbr noise_sequence_HIGH, 0b10000000 //set the MODE flag
0017f5 c000                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_exit:
0017f6 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
0017f7 93b0 0ab6                 	sts TCB3_INTFLAGS, r27
0017f9 91bf                      	pop r27
0017fa bfbf                      	out CPU_SREG, r27
0017fb 9518                      	reti
                                 
                                 //CONVERTERS
                                 //converts and loads 5 bit length to corresponding 8 bit length value into r29
                                 length_converter:
0017fc e7e6                      	ldi ZL, LOW(length << 1)
0017fd e6f4                      	ldi ZH, HIGH(length << 1)
0017fe 0fed                      	add ZL, r29
0017ff 1df2                      	adc ZH, zero
001800 91d4                      	lpm r29, Z
001801 9508                      	ret
                                 
                                 //loads pulse sequence into r29
                                 duty_cycle_sequences:
001802 e9e6                      	ldi ZL, LOW(sequences << 1)
001803 e6f4                      	ldi ZH, HIGH(sequences << 1)
001804 0fed                      	add ZL, r29
001805 1df2                      	adc ZH, zero
001806 91d4                      	lpm r29, Z
001807 9508                      	ret
                                 
                                 
                                 
                                 //SOUND DRIVER
                                 sound_driver:
001808 b7bf                      	in r27, CPU_SREG
001809 93bf                      	push r27
00180a 94f8                      	cli
00180b 93cf                      	push r28
00180c 93df                      	push r29
00180d 93ef                      	push r30
00180e 93ff                      	push r31
                                 
                                 	//SOUND DRIVER
00180f 91a0 281f                 	lds r26, song_fx_Bxx
001811 3faf                      	cpi r26, 0xFF //0xFF means that the flag is disabled
001812 f4a9                      	brne sound_driver_fx_Bxx_routine
001813 91a0 2820                 	lds r26, song_fx_Cxx
001815 11a2                      	cpse r26, zero
001816 c08b                      	rjmp sound_driver_fx_Cxx_routine
001817 91a0 2821                 	lds r26, song_fx_Dxx
001819 11a2                      	cpse r26, zero
00181a c096                      	rjmp sound_driver_fx_Dxx_routine
                                 
00181b 91a0 281a                 	lds r26, song_frame_offset
00181d 91b0 281b                 	lds r27, song_frame_offset+1
00181f 91c0 281c                 	lds r28, song_size
001821 91d0 281d                 	lds r29, song_size+1
001823 17ac                      	cp r26, r28
001824 07bd                      	cpc r27, r29
001825 f408                      	brsh sound_driver_fx_song_loop
001826 c101                      	rjmp sound_driver_channel0
                                 
                                 
                                 sound_driver_fx_song_loop:
001827 e0a0                      	ldi r26, 0x00
                                 sound_driver_fx_Bxx_routine:
001828 91e0 2818                 	lds ZL, song_frames
00182a 91f0 2819                 	lds ZH, song_frames+1
00182c 27cc                      	clr r28 //initialize r29:r28 to 0
00182d 27dd                      	clr r29
00182e 95a3                      	inc r26 //increment xx parameter by 1
                                 sound_driver_fx_Bxx_routine_loop:
00182f 95aa                      	dec r26
001830 f011                      	breq sound_driver_fx_Bxx_routine_loop_exit //once r26 == 0, r29:r28 will hold Bxx*(5*2).
001831 962a                      	adiw r29:r28, 10 //increment the offset by 10 because 5 channels, and each address takes 2 bytes (5*2 = 10)
001832 cffc                      	rjmp sound_driver_fx_Bxx_routine_loop
                                 
                                 sound_driver_fx_Bxx_routine_loop_exit:
001833 9622                      	adiw r29:r28, 2 //add 2 to skip the first 2 bytes (first 2 bytes is the song size)
001834 93c0 281a                 	sts song_frame_offset, r28
001836 93d0 281b                 	sts song_frame_offset+1, r29
001838 0fec                      	add ZL, r28
001839 1ffd                      	adc ZH, r29
                                 
00183a 91a5                      	lpm r26, Z+ //load the address of the frame(pattern)
00183b 91b5                      	lpm r27, Z+
00183c 0faa                      	lsl r26
00183d 1fbb                      	rol r27
00183e 93a0 2822                 	sts pulse1_pattern, r26
001840 93b0 2823                 	sts pulse1_pattern+1, r27
001842 91a5                      	lpm r26, Z+
001843 91b5                      	lpm r27, Z+
001844 0faa                      	lsl r26
001845 1fbb                      	rol r27
001846 93a0 2871                 	sts pulse2_pattern, r26
001848 93b0 2872                 	sts pulse2_pattern+1, r27
00184a 91a5                      	lpm r26, Z+
00184b 91b5                      	lpm r27, Z+
00184c 0faa                      	lsl r26
00184d 1fbb                      	rol r27
00184e 93a0 28c0                 	sts triangle_pattern, r26
001850 93b0 28c1                 	sts triangle_pattern+1, r27
001852 91a5                      	lpm r26, Z+
001853 91b5                      	lpm r27, Z+
001854 0faa                      	lsl r26
001855 1fbb                      	rol r27
001856 93a0 290a                 	sts noise_pattern, r26
001858 93b0 290b                 	sts noise_pattern+1, r27
                                 
00185a 9220 2826                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
00185c 9220 2827                 	sts pulse1_pattern_offset+1, zero
00185e 9220 2824                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
001860 9220 2825                 	sts pulse1_pattern_delay_frames, zero
001862 9220 2875                 	sts pulse2_pattern_offset, zero
001864 9220 2876                 	sts pulse2_pattern_offset+1, zero
001866 9220 2873                 	sts pulse2_pattern_delay_rows, zero
001868 9220 2874                 	sts pulse2_pattern_delay_frames, zero
00186a 9220 28c4                 	sts triangle_pattern_offset, zero
00186c 9220 28c5                 	sts triangle_pattern_offset+1, zero
00186e 9220 28c2                 	sts triangle_pattern_delay_rows, zero
001870 9220 28c3                 	sts triangle_pattern_delay_frames, zero
001872 9220 290e                 	sts noise_pattern_offset, zero
001874 9220 290f                 	sts noise_pattern_offset+1, zero
001876 9220 290c                 	sts noise_pattern_delay_rows, zero
001878 9220 290d                 	sts noise_pattern_delay_frames, zero
                                 
00187a efaf                      	ldi r26, 0xFF
00187b 93a0 285f                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
00187d 93a0 2860                 	sts pulse1_fx_Gxx_post, r26
00187f 93a0 286f                 	sts pulse1_fx_Sxx_pre, r26
001881 93a0 2870                 	sts pulse1_fx_Sxx_post, r26
001883 93a0 28ae                 	sts pulse2_fx_Gxx_pre, r26
001885 93a0 28af                 	sts pulse2_fx_Gxx_post, r26
001887 93a0 28be                 	sts pulse2_fx_Sxx_pre, r26
001889 93a0 28bf                 	sts pulse2_fx_Sxx_post, r26
00188b 93a0 28f8                 	sts triangle_fx_Gxx_pre, r26
00188d 93a0 28f9                 	sts triangle_fx_Gxx_post, r26
00188f 93a0 2908                 	sts triangle_fx_Sxx_pre, r26
001891 93a0 2909                 	sts triangle_fx_Sxx_post, r26
001893 93a0 2947                 	sts noise_fx_Gxx_pre, r26
001895 93a0 2948                 	sts noise_fx_Gxx_post, r26
001897 93a0 2957                 	sts noise_fx_Sxx_pre, r26
001899 93a0 2958                 	sts noise_fx_Sxx_post, r26
                                 
00189b 93a0 281f                 	sts song_fx_Bxx, r26 //reset all song effects
00189d 9220 2820                 	sts song_fx_Cxx, zero
00189f 9220 2821                 	sts song_fx_Dxx, zero
0018a1 c086                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_fx_Cxx_routine:
0018a2 91ff                      	pop r31
0018a3 91ef                      	pop r30
0018a4 91df                      	pop r29
0018a5 91cf                      	pop r28
0018a6 91bf                      	pop r27
0018a7 bfbf                      	out CPU_SREG, r27
0018a8 94f8                      	cli //disable global interrupts
                                 		
0018a9 efaf                      	ldi r26, 0xFF
0018aa 93a0 281f                 	sts song_fx_Bxx, r26 //reset all song effects
0018ac 9220 2820                 	sts song_fx_Cxx, zero
0018ae 9220 2821                 	sts song_fx_Dxx, zero
0018b0 9518                      	reti
                                 
                                 sound_driver_fx_Dxx_routine:
0018b1 91e0 2818                 	lds ZL, song_frames
0018b3 91f0 2819                 	lds ZH, song_frames+1
0018b5 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
0018b7 91b0 281b                 	lds r27, song_frame_offset+1
0018b9 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
0018ba 93a0 281a                 	sts song_frame_offset, r26
0018bc 93b0 281b                 	sts song_frame_offset+1, r27
0018be 0fea                      	add ZL, r26
0018bf 1ffb                      	adc ZH, r27
                                 
0018c0 91a5                      	lpm r26, Z+ //load the address of the next pattern
0018c1 91b5                      	lpm r27, Z+
0018c2 0faa                      	lsl r26
0018c3 1fbb                      	rol r27
0018c4 93a0 2822                 	sts pulse1_pattern, r26
0018c6 93b0 2823                 	sts pulse1_pattern+1, r27
0018c8 91a5                      	lpm r26, Z+
0018c9 91b5                      	lpm r27, Z+
0018ca 0faa                      	lsl r26
0018cb 1fbb                      	rol r27
0018cc 93a0 2871                 	sts pulse2_pattern, r26
0018ce 93b0 2872                 	sts pulse2_pattern+1, r27
0018d0 91a5                      	lpm r26, Z+
0018d1 91b5                      	lpm r27, Z+
0018d2 0faa                      	lsl r26
0018d3 1fbb                      	rol r27
0018d4 93a0 28c0                 	sts triangle_pattern, r26
0018d6 93b0 28c1                 	sts triangle_pattern+1, r27
0018d8 91a5                      	lpm r26, Z+
0018d9 91b5                      	lpm r27, Z+
0018da 0faa                      	lsl r26
0018db 1fbb                      	rol r27
0018dc 93a0 290a                 	sts noise_pattern, r26
0018de 93b0 290b                 	sts noise_pattern+1, r27
                                 
0018e0 9220 2826                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
0018e2 9220 2827                 	sts pulse1_pattern_offset+1, zero
0018e4 9220 2824                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
0018e6 9220 2825                 	sts pulse1_pattern_delay_frames, zero
0018e8 9220 2875                 	sts pulse2_pattern_offset, zero
0018ea 9220 2876                 	sts pulse2_pattern_offset+1, zero
0018ec 9220 2873                 	sts pulse2_pattern_delay_rows, zero
0018ee 9220 2874                 	sts pulse2_pattern_delay_frames, zero
0018f0 9220 28c4                 	sts triangle_pattern_offset, zero
0018f2 9220 28c5                 	sts triangle_pattern_offset+1, zero
0018f4 9220 28c2                 	sts triangle_pattern_delay_rows, zero
0018f6 9220 28c3                 	sts triangle_pattern_delay_frames, zero
0018f8 9220 290e                 	sts noise_pattern_offset, zero
0018fa 9220 290f                 	sts noise_pattern_offset+1, zero
0018fc 9220 290c                 	sts noise_pattern_delay_rows, zero
0018fe 9220 290d                 	sts noise_pattern_delay_frames, zero
                                 
001900 efaf                      	ldi r26, 0xFF
001901 93a0 285f                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
001903 93a0 2860                 	sts pulse1_fx_Gxx_post, r26
001905 93a0 286f                 	sts pulse1_fx_Sxx_pre, r26
001907 93a0 2870                 	sts pulse1_fx_Sxx_post, r26
001909 93a0 28ae                 	sts pulse2_fx_Gxx_pre, r26
00190b 93a0 28af                 	sts pulse2_fx_Gxx_post, r26
00190d 93a0 28be                 	sts pulse2_fx_Sxx_pre, r26
00190f 93a0 28bf                 	sts pulse2_fx_Sxx_post, r26
001911 93a0 28f8                 	sts triangle_fx_Gxx_pre, r26
001913 93a0 28f9                 	sts triangle_fx_Gxx_post, r26
001915 93a0 2908                 	sts triangle_fx_Sxx_pre, r26
001917 93a0 2909                 	sts triangle_fx_Sxx_post, r26
001919 93a0 2947                 	sts noise_fx_Gxx_pre, r26
00191b 93a0 2948                 	sts noise_fx_Gxx_post, r26
00191d 93a0 2957                 	sts noise_fx_Sxx_pre, r26
00191f 93a0 2958                 	sts noise_fx_Sxx_post, r26
                                 
001921 93a0 281f                 	sts song_fx_Bxx, r26 //reset all song effects
001923 9220 2820                 	sts song_fx_Cxx, zero
001925 9220 2821                 	sts song_fx_Dxx, zero
001927 c000                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0:
001928 91a0 2824                 	lds r26, pulse1_pattern_delay_rows
00192a 91b0 2825                 	lds r27, pulse1_pattern_delay_frames
00192c 9610                      	adiw r27:r26, 0
00192d f009                      	breq sound_driver_channel0_main //if the pattern delay is 0, proceed with sound driver procedures
00192e c2d7                      	rjmp sound_driver_channel0_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel0_main:
00192f 91e0 2822                 	lds ZL, pulse1_pattern //current pattern for pulse 1
001931 91f0 2823                 	lds ZH, pulse1_pattern+1
001933 91a0 2826                 	lds r26, pulse1_pattern_offset //current offset in the pattern for pulse 1
001935 91b0 2827                 	lds r27, pulse1_pattern_offset+1
001937 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001938 1ffb                      	adc ZH, r27
001939 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel0_check_if_note: //check if data is a note (0x00 - 0x56)
00193a 35b7                      	cpi r27, 0x57
00193b f408                      	brsh sound_driver_channel0_check_if_volume
00193c c17c                      	rjmp sound_driver_channel0_note
                                 sound_driver_channel0_check_if_volume: //check if data is volume (0x57-0x66)
00193d 36b7                      	cpi r27, 0x67
00193e f408                      	brsh sound_driver_channel0_check_if_delay
00193f c1b6                      	rjmp sound_driver_channel0_volume
                                 sound_driver_channel0_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001940 3eb3                      	cpi r27, 0xE3
001941 f408                      	brsh sound_driver_channel0_check_if_instrument
001942 c1bd                      	rjmp sound_driver_channel0_delay
                                 sound_driver_channel0_check_if_instrument: //check for instrument flag (0xE3)
001943 f409                      	brne sound_driver_channel0_check_if_release
001944 c1c0                      	rjmp sound_driver_channel0_instrument_change 
                                 sound_driver_channel0_check_if_release: //check for note release flag (0xE4)
001945 3eb4                      	cpi r27, 0xE4
001946 f409                      	brne sound_driver_channel0_check_if_end
001947 c269                      	rjmp sound_driver_channel0_release
                                 sound_driver_channel0_check_if_end:
001948 3fbf                      	cpi r27, 0xFF
001949 f409                      	brne sound_driver_channel0_check_if_fx
00194a c28b                      	rjmp sound_driver_channel0_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel0_check_if_fx: //fx flags (0xE5 - 0xFE)
00194b 9631                      	adiw Z, 1 //point Z to the byte next to the flag
00194c 91a4                      	lpm r26, Z //load the fx data into r26
00194d d2ae                      	rcall sound_driver_channel0_increment_offset_twice
                                 
00194e 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
00194f e9ea                      	ldi ZL, LOW(channel0_fx << 1) //load in note table
001950 e6f4                      	ldi ZH, HIGH(channel0_fx << 1)
001951 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001952 0feb                      	add ZL, r27 //add offset
001953 1df2                      	adc ZH, zero
001954 91c5                      	lpm r28, Z+ //load address bytes
001955 91d4                      	lpm r29, Z
001956 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001957 2ffd                      	mov ZH, r29
001958 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel0_fx_0xy:
001959 93a0 2845                 	sts pulse1_fx_0xy_sequence, r26
00195b 9220 2846                 	sts pulse1_fx_0xy_sequence+1, zero
00195d cfd1                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel0_fx_1xx:
00195e 9220 284b                 	sts pulse1_fx_2xx, zero //turn off any 2xx pitch slide down
001960 9220 284c                 	sts pulse1_fx_2xx+1, zero
001962 9220 2845                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
001964 9220 2846                 	sts pulse1_fx_0xy_sequence+1, zero
001966 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001967 937f                      	push r23
001968 2f6a                      	mov r22, r26 //store the rate into r22
001969 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00196a 9f67                      	mul r22, r23
00196b 917f                      	pop r23
00196c 916f                      	pop r22
                                 
00196d 9416                      	lsr r1 //shift out the fractional bits
00196e 9407                      	ror r0
00196f 9416                      	lsr r1
001970 9407                      	ror r0
001971 9416                      	lsr r1
001972 9407                      	ror r0
001973 9416                      	lsr r1
001974 9407                      	ror r0
001975 9200 2847                 	sts pulse1_fx_1xx, r0
001977 9210 2848                 	sts pulse1_fx_1xx+1, r1
001979 cfb5                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel0_fx_2xx:
00197a 9220 2847                 	sts pulse1_fx_1xx, zero //turn off any 1xx pitch slide down
00197c 9220 2848                 	sts pulse1_fx_1xx+1, zero
00197e 9220 2845                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
001980 9220 2846                 	sts pulse1_fx_0xy_sequence+1, zero
001982 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001983 937f                      	push r23
001984 2f6a                      	mov r22, r26 //store the rate into r22
001985 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001986 9f67                      	mul r22, r23
001987 917f                      	pop r23
001988 916f                      	pop r22
                                 
001989 9416                      	lsr r1 //shift out the fractional bits
00198a 9407                      	ror r0
00198b 9416                      	lsr r1
00198c 9407                      	ror r0
00198d 9416                      	lsr r1
00198e 9407                      	ror r0
00198f 9416                      	lsr r1
001990 9407                      	ror r0
001991 9200 284b                 	sts pulse1_fx_2xx, r0
001993 9210 284c                 	sts pulse1_fx_2xx+1, r1
001995 cf99                      	rjmp sound_driver_channel0_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel0_fx_3xx:
001996 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001997 937f                      	push r23
001998 2f6a                      	mov r22, r26 //store the rate into r22
001999 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00199a 9f67                      	mul r22, r23
00199b 917f                      	pop r23
00199c 916f                      	pop r22
                                 
00199d 9416                      	lsr r1 //shift out the fractional bits
00199e 9407                      	ror r0
00199f 9416                      	lsr r1
0019a0 9407                      	ror r0
0019a1 9416                      	lsr r1
0019a2 9407                      	ror r0
0019a3 9416                      	lsr r1
0019a4 9407                      	ror r0
0019a5 9200 2853                 	sts pulse1_fx_3xx_speed, r0
0019a7 9210 2854                 	sts pulse1_fx_3xx_speed+1, r1
                                 
0019a9 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
0019aa c001                      	rjmp sound_driver_channel0_fx_3xx_enabled
0019ab cf83                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_3xx_enabled:
0019ac 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
0019ae 91b0 0a8d                 	lds r27, TCB0_CCMPH
0019b0 93a0 284f                 	sts pulse1_fx_3xx_start, r26
0019b2 93b0 2850                 	sts pulse1_fx_3xx_start+1, r27
                                 
0019b4 9220 2855                 	sts pulse1_fx_3xx_total_offset, zero
0019b6 9220 2856                 	sts pulse1_fx_3xx_total_offset+1, zero
0019b8 cf76                      	rjmp sound_driver_channel0_main
                                 
                                 //VIBRATO
                                 sound_driver_channel0_fx_4xy:
0019b9 2fba                      	mov r27, r26
0019ba 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
0019bb 95a2                      	swap r26
0019bc 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0019bd 93a0 2857                 	sts pulse1_fx_4xy_speed, r26
0019bf 93b0 2858                 	sts pulse1_fx_4xy_depth, r27
0019c1 9220 2859                 	sts pulse1_fx_4xy_phase, zero //reset the phase to 0
0019c3 cf6b                      	rjmp sound_driver_channel0_main
                                 
                                 //TREMELO
                                 sound_driver_channel0_fx_7xy:
0019c4 2fba                      	mov r27, r26
0019c5 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
0019c6 95a2                      	swap r26
0019c7 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0019c8 93a0 285a                 	sts pulse1_fx_7xy_speed, r26
0019ca 93b0 285b                 	sts pulse1_fx_7xy_depth, r27
0019cc 9220 285c                 	sts pulse1_fx_7xy_phase, zero //reset the phase to 0
0019ce 9220 285d                 	sts pulse1_fx_7xy_value, zero //reset the tremelo value
0019d0 cf5e                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel0_fx_Axy:
0019d1 93a0 285e                 	sts pulse1_fx_Axy, r26
0019d3 cf5b                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel0_fx_Bxx:
0019d4 93a0 281f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
0019d6 cf58                      	rjmp sound_driver_channel0_main
                                 
                                 //HALT
                                 sound_driver_channel0_fx_Cxx:
0019d7 93b0 2820                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
0019d9 cf55                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel0_fx_Dxx:
0019da 93b0 2821                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
0019dc cf52                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME
                                 sound_driver_channel0_fx_Exx:
0019dd 91b0 2800                 	lds r27, pulse1_param
0019df 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
0019e0 2bba                      	or r27, r26 //move new VVVV bits into pulse1_param
0019e1 93b0 2800                 	sts pulse1_param, r27
0019e3 6096                      	sbr pulse_channel_flags, 6
0019e4 cf4a                      	rjmp sound_driver_channel0_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel0_fx_Fxx:
0019e5 93a0 281e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
0019e7 cf47                      	rjmp sound_driver_channel0_main
                                 
                                 //DELAY
                                 sound_driver_channel0_fx_Gxx:
0019e8 15a2                      	cp r26, zero
0019e9 f051                      	breq sound_driver_channel0_fx_Gxx_invalid
0019ea 91b0 281e                 	lds r27, song_speed
0019ec 17ab                      	cp r26, r27
0019ed f430                      	brsh sound_driver_channel0_fx_Gxx_invalid
0019ee 93a0 285f                 	sts pulse1_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
0019f0 e0b1                      	ldi r27, 0x01
0019f1 93b0 2824                 	sts pulse1_pattern_delay_rows, r27
0019f3 c215                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Gxx_invalid:
0019f4 cf3a                      	rjmp sound_driver_channel0_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel0_fx_Hxy: //hardware sweep up
0019f5 cf39                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixy: //hardware sweep down
0019f6 cf38                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Hxx: //FDS modulation depth
0019f7 cf37                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixx: //FDS modulation speed
0019f8 cf36                      	rjmp sound_driver_channel0_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel0_fx_Pxx:
0019f9 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0019fa 937f                      	push r23
0019fb 2f6a                      	mov r22, r26
0019fc eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0019fd 0367                      	mulsu r22, r23
0019fe 917f                      	pop r23
0019ff 916f                      	pop r22
001a00 9416                      	lsr r1 //shift out the fractional bits
001a01 9407                      	ror r0
001a02 9416                      	lsr r1
001a03 9407                      	ror r0
001a04 9416                      	lsr r1
001a05 9407                      	ror r0
001a06 9416                      	lsr r1
001a07 9407                      	ror r0
001a08 9200 2861                 	sts pulse1_fx_Pxx_total, r0
001a0a 9210 2862                 	sts pulse1_fx_Pxx_total+1, r1
001a0c cf22                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel0_fx_Qxy:
                                 sound_driver_channel0_fx_Qxy_check_arpeggio_macro:
001a0d 91e0 282d                 	lds ZL, pulse1_arpeggio_macro
001a0f 91f0 282e                 	lds ZH, pulse1_arpeggio_macro+1
001a11 9630                      	adiw Z, 0
001a12 f009                      	breq sound_driver_channel0_fx_Qxy_check_pitch_macro
001a13 cf1b                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_pitch_macro:
001a14 91e0 2835                 	lds ZL, pulse1_pitch_macro
001a16 91f0 2836                 	lds ZH, pulse1_pitch_macro+1
001a18 9630                      	adiw Z, 0
001a19 f009                      	breq sound_driver_channel0_fx_Qxy_check_hi_pitch_macro
001a1a cf14                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_hi_pitch_macro:
001a1b 91e0 283b                 	lds ZL, pulse1_hi_pitch_macro
001a1d 91f0 283c                 	lds ZH, pulse1_hi_pitch_macro+1
001a1f 9630                      	adiw Z, 0
001a20 f009                      	breq sound_driver_channel0_fx_Qxy_process
001a21 cf0d                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_process:
001a22 2fba                      	mov r27, r26 //copy fx parameters into r27
001a23 70bf                      	andi r27, 0x0F //mask note index offset
001a24 91c0 2807                 	lds r28, pulse1_note //load current note index
001a26 0fbc                      	add r27, r28
001a27 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001a28 f008                      	brlo sound_driver_channel0_fx_Qxy_process_continue
001a29 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel0_fx_Qxy_process_continue:
001a2a e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001a2b e0f0                      	ldi ZH, HIGH(note_table << 1)
001a2c 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001a2d 0feb                      	add ZL, r27 //add offset
001a2e 1df2                      	adc ZH, zero
001a2f 91c5                      	lpm r28, Z+ //load bytes
001a30 91d4                      	lpm r29, Z
001a31 93c0 2863                 	sts pulse1_fx_Qxy_target, r28 //load the LOW bits for the target period
001a33 93d0 2864                 	sts pulse1_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
001a35 95a2                      	swap r26
001a36 70af                      	andi r26, 0x0F //mask effect speed
001a37 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001a38 95a3                      	inc r26 //increment the speed by 1
                                 
001a39 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001a3a 937f                      	push r23
001a3b 2f6a                      	mov r22, r26 //store the speed data into r27
001a3c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001a3d 9f67                      	mul r22, r23
001a3e 917f                      	pop r23
001a3f 916f                      	pop r22
                                 
001a40 9416                      	lsr r1 //shift out the fractional bits
001a41 9407                      	ror r0
001a42 9416                      	lsr r1
001a43 9407                      	ror r0
001a44 9416                      	lsr r1
001a45 9407                      	ror r0
001a46 9416                      	lsr r1
001a47 9407                      	ror r0
                                 
001a48 9200 2865                 	sts pulse1_fx_Qxy_speed, r0 //store the effect speed
001a4a 9210 2866                 	sts pulse1_fx_Qxy_speed+1, r1
001a4c 9220 2867                 	sts pulse1_fx_Qxy_total_offset, zero
001a4e 9220 2868                 	sts pulse1_fx_Qxy_total_offset+1, zero
001a50 cede                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel0_fx_Rxy:
                                 sound_driver_channel0_fx_Rxy_check_arpeggio_macro:
001a51 91e0 282d                 	lds ZL, pulse1_arpeggio_macro
001a53 91f0 282e                 	lds ZH, pulse1_arpeggio_macro+1
001a55 9630                      	adiw Z, 0
001a56 f009                      	breq sound_driver_channel0_fx_Rxy_check_pitch_macro
001a57 ced7                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_pitch_macro:
001a58 91e0 2835                 	lds ZL, pulse1_pitch_macro
001a5a 91f0 2836                 	lds ZH, pulse1_pitch_macro+1
001a5c 9630                      	adiw Z, 0
001a5d f009                      	breq sound_driver_channel0_fx_Rxy_check_hi_pitch_macro
001a5e ced0                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_hi_pitch_macro:
001a5f 91e0 283b                 	lds ZL, pulse1_hi_pitch_macro
001a61 91f0 283c                 	lds ZH, pulse1_hi_pitch_macro+1
001a63 9630                      	adiw Z, 0
001a64 f009                      	breq sound_driver_channel0_fx_Rxy_process
001a65 cec9                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_process:
001a66 2fba                      	mov r27, r26 //copy fx parameters into r27
001a67 70bf                      	andi r27, 0x0F //mask note index offset
001a68 91c0 2807                 	lds r28, pulse1_note //load current note index
001a6a 1bcb                      	sub r28, r27
001a6b f408                      	brcc sound_driver_channel0_fx_Rxy_process_continue
001a6c e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel0_fx_Rxy_process_continue:
001a6d e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001a6e e0f0                      	ldi ZH, HIGH(note_table << 1)
001a6f 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001a70 0fec                      	add ZL, r28 //add offset
001a71 1df2                      	adc ZH, zero
001a72 91c5                      	lpm r28, Z+ //load bytes
001a73 91d4                      	lpm r29, Z
001a74 93c0 2869                 	sts pulse1_fx_Rxy_target, r28 //load the LOW bits for the target period
001a76 93d0 286a                 	sts pulse1_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
001a78 95a2                      	swap r26
001a79 70af                      	andi r26, 0x0F //mask effect speed
001a7a 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001a7b 95a3                      	inc r26 //increment the speed by 1
                                 
001a7c 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001a7d 937f                      	push r23
001a7e 2f6a                      	mov r22, r26 //store the speed data into r27
001a7f eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001a80 9f67                      	mul r22, r23
001a81 917f                      	pop r23
001a82 916f                      	pop r22
                                 
001a83 9416                      	lsr r1 //shift out the fractional bits
001a84 9407                      	ror r0
001a85 9416                      	lsr r1
001a86 9407                      	ror r0
001a87 9416                      	lsr r1
001a88 9407                      	ror r0
001a89 9416                      	lsr r1
001a8a 9407                      	ror r0
                                 
001a8b 9200 286b                 	sts pulse1_fx_Rxy_speed, r0 //store the effect speed
001a8d 9210 286c                 	sts pulse1_fx_Rxy_speed+1, r1
001a8f 9220 286d                 	sts pulse1_fx_Rxy_total_offset, zero
001a91 9220 286e                 	sts pulse1_fx_Rxy_total_offset+1, zero
001a93 ce9b                      	rjmp sound_driver_channel0_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel0_fx_Sxx:
001a94 15a2                      	cp r26, zero
001a95 f051                      	breq sound_driver_channel0_fx_Sxx_invalid
001a96 91b0 281e                 	lds r27, song_speed
001a98 17ab                      	cp r26, r27
001a99 f430                      	brsh sound_driver_channel0_fx_Sxx_invalid
001a9a 93a0 286f                 	sts pulse1_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001a9c e0b1                      	ldi r27, 0x01
001a9d 93b0 2824                 	sts pulse1_pattern_delay_rows, r27
001a9f c169                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Sxx_invalid:
001aa0 ce8e                      	rjmp sound_driver_channel0_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel0_fx_Vxx:
001aa1 e9e6                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
001aa2 e6f4                      	ldi ZH, HIGH(sequences << 1)
001aa3 0fea                      	add ZL, r26 //offset the pointer
001aa4 1df2                      	adc ZH, zero
                                 
001aa5 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
001aa6 95a7                      	ror r26
001aa7 95a7                      	ror r26
001aa8 91b0 2800                 	lds r27, pulse1_param //load r27 with pulse1_param (register $4000)
001aaa 2fcb                      	mov r28, r27 //store a copy of pulse1_param into r28
001aab 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
001aac 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
001aad c001                      	rjmp sound_driver_channel0_fx_Vxx_store
001aae ce80                      	rjmp sound_driver_channel0_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel0_fx_Vxx_store:
001aaf 90a4                      	lpm pulse1_sequence, Z //store the sequence
                                 
001ab0 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
001ab1 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
001ab2 93c0 2800                 	sts pulse1_param, r28
001ab4 ce7a                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_Wxx: //DPCM sample speed
001ab5 ce79                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Xxx: //DPCM sample retrigger
001ab6 ce78                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Yxx: //DPCM sample offset
001ab7 ce77                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Zxx: //DPCM sample delta counter
001ab8 ce76                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 sound_driver_channel0_note:
001ab9 93b0 2807                 	sts pulse1_note, r27 //store the note index
001abb e0a3                      	ldi r26, 0x03
001abc e0b2                      	ldi r27, 0x02
001abd 93b0 282a                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
001abf 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26
001ac1 93b0 2837                 	sts pulse1_pitch_macro_offset, r27
001ac3 93b0 283d                 	sts pulse1_hi_pitch_macro_offset, r27
001ac5 93b0 2842                 	sts pulse1_duty_macro_offset, r27
001ac7 9220 2833                 	sts pulse1_total_pitch_offset, zero //reset the pitch and hi pitch offset
001ac9 9220 2834                 	sts pulse1_total_pitch_offset+1, zero
001acb 9220 283a                 	sts pulse1_total_hi_pitch_offset, zero
001acd 9220 2849                 	sts pulse1_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001acf 9220 284a                 	sts pulse1_fx_1xx_total+1, zero
001ad1 9220 284d                 	sts pulse1_fx_2xx_total, zero
001ad3 9220 284e                 	sts pulse1_fx_2xx_total+1, zero
001ad5 9220 2855                 	sts pulse1_fx_3xx_total_offset, zero //reset 3xx offset
001ad7 9220 2856                 	sts pulse1_fx_3xx_total_offset+1, zero
001ad9 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001adb 91b0 0a8d                 	lds r27, TCB0_CCMPH
001add 93a0 284f                 	sts pulse1_fx_3xx_start, r26
001adf 93b0 2850                 	sts pulse1_fx_3xx_start+1, r27
001ae1 9220 2801                 	sts pulse1_sweep_param, zero //reset any sweep effect
001ae3 6097                      	sbr pulse_channel_flags, 7 //set reload flag
001ae4 9220 2863                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001ae6 9220 2864                 	sts pulse1_fx_Qxy_target+1, zero
001ae8 9220 2867                 	sts pulse1_fx_Qxy_total_offset, zero
001aea 9220 2868                 	sts pulse1_fx_Qxy_total_offset+1, zero
001aec 9220 2869                 	sts pulse1_fx_Rxy_target, zero
001aee 9220 286a                 	sts pulse1_fx_Rxy_target+1, zero
001af0 9220 286d                 	sts pulse1_fx_Rxy_total_offset, zero
001af2 9220 286e                 	sts pulse1_fx_Rxy_total_offset+1, zero
001af4 d0fd                      	rcall sound_driver_channel0_increment_offset
001af5 ce39                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_volume:
001af6 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001af7 91a0 2800                 	lds r26, pulse1_param
001af9 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001afa 2bab                      	or r26, r27 //move new VVVV bits into pulse1_param
001afb 93a0 2800                 	sts pulse1_param, r26
001afd 6096                      	sbr pulse_channel_flags, 6
001afe d0f3                      	rcall sound_driver_channel0_increment_offset
001aff ce2f                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_delay:
001b00 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001b01 93b0 2824                 	sts pulse1_pattern_delay_rows, r27
001b03 d0ee                      	rcall sound_driver_channel0_increment_offset
001b04 c104                      	rjmp sound_driver_channel1
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change:
001b05 9220 2828                 	sts pulse1_volume_macro, zero //reset all macro addresses
001b07 9220 2829                 	sts pulse1_volume_macro+1, zero
001b09 9220 282d                 	sts pulse1_arpeggio_macro, zero
001b0b 9220 282e                 	sts pulse1_arpeggio_macro+1, zero
001b0d 9220 2835                 	sts pulse1_pitch_macro, zero
001b0f 9220 2836                 	sts pulse1_pitch_macro+1, zero
001b11 9220 283b                 	sts pulse1_hi_pitch_macro, zero
001b13 9220 283c                 	sts pulse1_hi_pitch_macro+1, zero
001b15 9220 2840                 	sts pulse1_duty_macro, zero
001b17 9220 2841                 	sts pulse1_duty_macro+1, zero
001b19 9220 2833                 	sts pulse1_total_pitch_offset, zero //reset the pitch offset
001b1b 9220 2834                 	sts pulse1_total_pitch_offset+1, zero
001b1d 9220 283a                 	sts pulse1_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001b1f 9631                      	adiw Z, 1 //point to the byte next to the flag
001b20 91b4                      	lpm r27, Z //store the instrument offset into r27
001b21 e3eb                      	ldi ZL, LOW(instruments) //point Z to instruments table
001b22 e1f1                      	ldi ZH, HIGH(instruments)
001b23 0feb                      	add ZL, r27 //point Z to offsetted instrument
001b24 1df2                      	adc ZH, zero
001b25 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001b26 1fff                      	rol ZH
001b27 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001b28 91b4                      	lpm r27, Z
                                 
001b29 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001b2a 1fbb                      	rol r27
001b2b 2fea                      	mov ZL, r26
001b2c 2ffb                      	mov ZH, r27
001b2d 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001b2e 9632                      	adiw Z, 2 //point Z to the address of the macro
001b2f e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel0_instrument_change_macro_loop:
001b30 95aa                      	dec r26
001b31 f019                      	breq sound_driver_channel0_instrument_change_exit
001b32 95b6                      	lsr r27
001b33 f078                      	brcs sound_driver_channel0_instrument_change_load_macro
001b34 cffb                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_exit:
001b35 e0a3                      	ldi r26, 0x03
001b36 e0b2                      	ldi r27, 0x02
001b37 93b0 282a                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
001b39 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26
001b3b 93b0 2837                 	sts pulse1_pitch_macro_offset, r27
001b3d 93b0 283d                 	sts pulse1_hi_pitch_macro_offset, r27
001b3f 93b0 2842                 	sts pulse1_duty_macro_offset, r27
001b41 d0ba                      	rcall sound_driver_channel0_increment_offset_twice
001b42 cdec                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_load_macro:
001b43 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001b44 91d5                      	lpm r29, Z+
                                 
001b45 30a5                      	cpi r26, 5
001b46 f039                      	breq sound_driver_channel0_instrument_change_load_macro_volume
001b47 30a4                      	cpi r26, 4
001b48 f079                      	breq sound_driver_channel0_instrument_change_load_macro_arpeggio
001b49 30a3                      	cpi r26, 3
001b4a f0d9                      	breq sound_driver_channel0_instrument_change_load_macro_pitch
001b4b 30a2                      	cpi r26, 2
001b4c f159                      	breq sound_driver_channel0_instrument_change_load_macro_hi_pitch
001b4d c03c                      	rjmp sound_driver_channel0_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel0_instrument_change_load_macro_volume:
001b4e 93c0 2828                 	sts pulse1_volume_macro, r28
001b50 93d0 2829                 	sts pulse1_volume_macro+1, r29
001b52 d041                      	rcall sound_driver_channel0_instrument_change_read_header
001b53 93c0 282c                 	sts pulse1_volume_macro_release, r28
001b55 93d0 282b                 	sts pulse1_volume_macro_loop, r29
001b57 cfd8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 	
                                 sound_driver_channel0_instrument_change_load_macro_arpeggio:
001b58 93c0 282d                 	sts pulse1_arpeggio_macro, r28
001b5a 93d0 282e                 	sts pulse1_arpeggio_macro+1, r29
001b5c 9220 2863                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001b5e 9220 2864                 	sts pulse1_fx_Qxy_target+1, zero
001b60 9220 2869                 	sts pulse1_fx_Rxy_target, zero
001b62 9220 286a                 	sts pulse1_fx_Rxy_target+1, zero
001b64 d03a                      	rcall sound_driver_channel0_instrument_change_read_header_arpeggio
001b65 cfca                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_pitch:
001b66 93c0 2835                 	sts pulse1_pitch_macro, r28
001b68 93d0 2836                 	sts pulse1_pitch_macro+1, r29
001b6a 9220 2863                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001b6c 9220 2864                 	sts pulse1_fx_Qxy_target+1, zero
001b6e 9220 2869                 	sts pulse1_fx_Rxy_target, zero
001b70 9220 286a                 	sts pulse1_fx_Rxy_target+1, zero
001b72 d021                      	rcall sound_driver_channel0_instrument_change_read_header
001b73 93c0 2839                 	sts pulse1_pitch_macro_release, r28
001b75 93d0 2838                 	sts pulse1_pitch_macro_loop, r29
001b77 cfb8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_hi_pitch:
001b78 93c0 283b                 	sts pulse1_hi_pitch_macro, r28
001b7a 93d0 283c                 	sts pulse1_hi_pitch_macro+1, r29
001b7c 9220 2863                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001b7e 9220 2864                 	sts pulse1_fx_Qxy_target+1, zero
001b80 9220 2869                 	sts pulse1_fx_Rxy_target, zero
001b82 9220 286a                 	sts pulse1_fx_Rxy_target+1, zero
001b84 d00f                      	rcall sound_driver_channel0_instrument_change_read_header
001b85 93c0 283f                 	sts pulse1_hi_pitch_macro_release, r28
001b87 93d0 283e                 	sts pulse1_hi_pitch_macro_loop, r29
001b89 cfa6                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_duty:
001b8a 93c0 2840                 	sts pulse1_duty_macro, r28
001b8c 93d0 2841                 	sts pulse1_duty_macro+1, r29
001b8e d005                      	rcall sound_driver_channel0_instrument_change_read_header
001b8f 93c0 2844                 	sts pulse1_duty_macro_release, r28
001b91 93d0 2843                 	sts pulse1_duty_macro_loop, r29
001b93 cf9c                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_read_header:
001b94 93ef                      	push ZL
001b95 93ff                      	push ZH
001b96 2fec                      	mov ZL, r28
001b97 2ffd                      	mov ZH, r29
001b98 0fee                      	lsl ZL
001b99 1fff                      	rol ZH
001b9a 91c5                      	lpm r28, Z+
001b9b 91d4                      	lpm r29, Z
001b9c 91ff                      	pop ZH
001b9d 91ef                      	pop ZL
001b9e 9508                      	ret
                                 
                                 sound_driver_channel0_instrument_change_read_header_arpeggio:
001b9f 93ef                      	push ZL
001ba0 93ff                      	push ZH
001ba1 2fec                      	mov ZL, r28
001ba2 2ffd                      	mov ZH, r29
001ba3 0fee                      	lsl ZL
001ba4 1fff                      	rol ZH
001ba5 91c5                      	lpm r28, Z+
001ba6 91d5                      	lpm r29, Z+
001ba7 93c0 2831                 	sts pulse1_arpeggio_macro_release, r28
001ba9 93d0 2830                 	sts pulse1_arpeggio_macro_loop, r29
001bab 91c4                      	lpm r28, Z
001bac 93c0 2832                 	sts pulse1_arpeggio_macro_mode, r28
001bae 91ff                      	pop ZH
001baf 91ef                      	pop ZL
001bb0 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel0_release:
                                 sound_driver_channel0_release_volume:
001bb1 91b0 282c                 	lds r27, pulse1_volume_macro_release
001bb3 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001bb4 f019                      	breq sound_driver_channel0_release_arpeggio //if the macro has no release flag, check the next macro
001bb5 95b3                      	inc r27
001bb6 93b0 282a                 	sts pulse1_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel0_release_arpeggio:
001bb8 91b0 2831                 	lds r27, pulse1_arpeggio_macro_release
001bba 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001bbb f019                      	breq sound_driver_channel0_release_pitch
001bbc 95b3                      	inc r27
001bbd 93b0 282f                 	sts pulse1_arpeggio_macro_offset, r27
                                 sound_driver_channel0_release_pitch:
001bbf 91b0 2839                 	lds r27, pulse1_pitch_macro_release
001bc1 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001bc2 f019                      	breq sound_driver_channel0_release_hi_pitch
001bc3 95b3                      	inc r27
001bc4 93b0 2837                 	sts pulse1_pitch_macro_offset, r27
                                 sound_driver_channel0_release_hi_pitch:
001bc6 91b0 283f                 	lds r27, pulse1_hi_pitch_macro_release
001bc8 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001bc9 f019                      	breq sound_driver_channel0_release_duty
001bca 95b3                      	inc r27
001bcb 93b0 283d                 	sts pulse1_hi_pitch_macro_offset, r27
                                 sound_driver_channel0_release_duty:
001bcd 91b0 2844                 	lds r27, pulse1_duty_macro_release
001bcf 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001bd0 f019                      	breq sound_driver_channel0_release_exit
001bd1 95b3                      	inc r27
001bd2 93b0 2842                 	sts pulse1_duty_macro_offset, r27
                                 sound_driver_channel0_release_exit:
001bd4 d01d                      	rcall sound_driver_channel0_increment_offset
001bd5 cd59                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_next_pattern:
001bd6 91e0 2818                 	lds ZL, song_frames
001bd8 91f0 2819                 	lds ZH, song_frames+1
001bda 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001bdc 91b0 281b                 	lds r27, song_frame_offset+1
001bde 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
001bdf 93a0 281a                 	sts song_frame_offset, r26
001be1 93b0 281b                 	sts song_frame_offset+1, r27
001be3 0fea                      	add ZL, r26
001be4 1ffb                      	adc ZH, r27
                                 
001be5 91a5                      	lpm r26, Z+ //load the address of the next pattern
001be6 91b4                      	lpm r27, Z
001be7 0faa                      	lsl r26
001be8 1fbb                      	rol r27
001be9 93a0 2822                 	sts pulse1_pattern, r26
001beb 93b0 2823                 	sts pulse1_pattern+1, r27
                                 
001bed 9220 2826                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001bef 9220 2827                 	sts pulse1_pattern_offset+1, zero
001bf1 cd3d                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_increment_offset:
001bf2 91e0 2826                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
001bf4 91f0 2827                 	lds ZH, pulse1_pattern_offset+1
001bf6 9631                      	adiw Z, 1
001bf7 93e0 2826                 	sts pulse1_pattern_offset, ZL
001bf9 93f0 2827                 	sts pulse1_pattern_offset+1, ZH
001bfb 9508                      	ret
                                 
                                 sound_driver_channel0_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001bfc 91e0 2826                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
001bfe 91f0 2827                 	lds ZH, pulse1_pattern_offset+1
001c00 9632                      	adiw Z, 2 //increment the pointer twice
001c01 93e0 2826                 	sts pulse1_pattern_offset, ZL
001c03 93f0 2827                 	sts pulse1_pattern_offset+1, ZH
001c05 9508                      	ret
                                 
                                 sound_driver_channel0_decrement_frame_delay:
001c06 95ba                      	dec r27
001c07 93b0 2825                 	sts pulse1_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel1:
001c09 91a0 2873                 	lds r26, pulse2_pattern_delay_rows
001c0b 91b0 2874                 	lds r27, pulse2_pattern_delay_frames
001c0d 9610                      	adiw r27:r26, 0
001c0e f009                      	breq sound_driver_channel1_main //if the pattern delay is 0, proceed with sound driver procedures
001c0f c2d3                      	rjmp sound_driver_channel1_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel1_main:
001c10 91e0 2871                 	lds ZL, pulse2_pattern //current pattern for pulse 2
001c12 91f0 2872                 	lds ZH, pulse2_pattern+1
001c14 91a0 2875                 	lds r26, pulse2_pattern_offset //current offset in the pattern for pulse 2
001c16 91b0 2876                 	lds r27, pulse2_pattern_offset+1
001c18 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001c19 1ffb                      	adc ZH, r27
001c1a 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel1_check_if_note: //check if data is a note (0x00 - 0x56)
001c1b 35b7                      	cpi r27, 0x57
001c1c f408                      	brsh sound_driver_channel1_check_if_volume
001c1d c17c                      	rjmp sound_driver_channel1_note
                                 sound_driver_channel1_check_if_volume: //check if data is volume (0x57-0x66)
001c1e 36b7                      	cpi r27, 0x67
001c1f f408                      	brsh sound_driver_channel1_check_if_delay
001c20 c1b6                      	rjmp sound_driver_channel1_volume
                                 sound_driver_channel1_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001c21 3eb3                      	cpi r27, 0xE3
001c22 f408                      	brsh sound_driver_channel1_check_if_instrument
001c23 c1bd                      	rjmp sound_driver_channel1_delay
                                 sound_driver_channel1_check_if_instrument: //check for instrument flag (0xE3)
001c24 f409                      	brne sound_driver_channel1_check_if_release
001c25 c1c0                      	rjmp sound_driver_channel1_instrument_change 
                                 sound_driver_channel1_check_if_release: //check for note release flag (0xE4)
001c26 3eb4                      	cpi r27, 0xE4
001c27 f409                      	brne sound_driver_channel1_check_if_end
001c28 c269                      	rjmp sound_driver_channel1_release
                                 sound_driver_channel1_check_if_end:
001c29 3fbf                      	cpi r27, 0xFF
001c2a f409                      	brne sound_driver_channel1_check_if_fx
001c2b c28b                      	rjmp sound_driver_channel1_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel1_check_if_fx: //fx flags (0xE5 - 0xFE)
001c2c 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001c2d 91a4                      	lpm r26, Z //load the fx data into r26
001c2e d2aa                      	rcall sound_driver_channel1_increment_offset_twice
                                 
001c2f 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001c30 ecee                      	ldi ZL, LOW(channel1_fx << 1) //load in note table
001c31 e6f4                      	ldi ZH, HIGH(channel1_fx << 1)
001c32 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001c33 0feb                      	add ZL, r27 //add offset
001c34 1df2                      	adc ZH, zero
001c35 91c5                      	lpm r28, Z+ //load address bytes
001c36 91d4                      	lpm r29, Z
001c37 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001c38 2ffd                      	mov ZH, r29
001c39 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel1_fx_0xy:
001c3a 93a0 2894                 	sts pulse2_fx_0xy_sequence, r26
001c3c 9220 2895                 	sts pulse2_fx_0xy_sequence+1, zero
001c3e cfd1                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel1_fx_1xx:
001c3f 9220 289a                 	sts pulse2_fx_2xx, zero //turn off any 2xx pitch slide down
001c41 9220 289b                 	sts pulse2_fx_2xx+1, zero
001c43 9220 2894                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
001c45 9220 2895                 	sts pulse2_fx_0xy_sequence+1, zero
001c47 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001c48 937f                      	push r23
001c49 2f6a                      	mov r22, r26 //store the rate into r22
001c4a eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001c4b 9f67                      	mul r22, r23
001c4c 917f                      	pop r23
001c4d 916f                      	pop r22
                                 
001c4e 9416                      	lsr r1 //shift out the fractional bits
001c4f 9407                      	ror r0
001c50 9416                      	lsr r1
001c51 9407                      	ror r0
001c52 9416                      	lsr r1
001c53 9407                      	ror r0
001c54 9416                      	lsr r1
001c55 9407                      	ror r0
001c56 9200 2896                 	sts pulse2_fx_1xx, r0
001c58 9210 2897                 	sts pulse2_fx_1xx+1, r1
001c5a cfb5                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel1_fx_2xx:
001c5b 9220 2896                 	sts pulse2_fx_1xx, zero //turn off any 1xx pitch slide down
001c5d 9220 2897                 	sts pulse2_fx_1xx+1, zero
001c5f 9220 2894                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
001c61 9220 2895                 	sts pulse2_fx_0xy_sequence+1, zero
001c63 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001c64 937f                      	push r23
001c65 2f6a                      	mov r22, r26 //store the rate into r22
001c66 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001c67 9f67                      	mul r22, r23
001c68 917f                      	pop r23
001c69 916f                      	pop r22
                                 
001c6a 9416                      	lsr r1 //shift out the fractional bits
001c6b 9407                      	ror r0
001c6c 9416                      	lsr r1
001c6d 9407                      	ror r0
001c6e 9416                      	lsr r1
001c6f 9407                      	ror r0
001c70 9416                      	lsr r1
001c71 9407                      	ror r0
001c72 9200 289a                 	sts pulse2_fx_2xx, r0
001c74 9210 289b                 	sts pulse2_fx_2xx+1, r1
001c76 cf99                      	rjmp sound_driver_channel1_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel1_fx_3xx:
001c77 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001c78 937f                      	push r23
001c79 2f6a                      	mov r22, r26 //store the rate into r22
001c7a eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001c7b 9f67                      	mul r22, r23
001c7c 917f                      	pop r23
001c7d 916f                      	pop r22
                                 
001c7e 9416                      	lsr r1 //shift out the fractional bits
001c7f 9407                      	ror r0
001c80 9416                      	lsr r1
001c81 9407                      	ror r0
001c82 9416                      	lsr r1
001c83 9407                      	ror r0
001c84 9416                      	lsr r1
001c85 9407                      	ror r0
001c86 9200 28a2                 	sts pulse2_fx_3xx_speed, r0
001c88 9210 28a3                 	sts pulse2_fx_3xx_speed+1, r1
                                 
001c8a 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001c8b c001                      	rjmp sound_driver_channel1_fx_3xx_enabled
001c8c cf83                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_3xx_enabled:
001c8d 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001c8f 91b0 0a9d                 	lds r27, TCB1_CCMPH
001c91 93a0 289e                 	sts pulse2_fx_3xx_start, r26
001c93 93b0 289f                 	sts pulse2_fx_3xx_start+1, r27
                                 
001c95 9220 28a4                 	sts pulse2_fx_3xx_total_offset, zero
001c97 9220 28a5                 	sts pulse2_fx_3xx_total_offset+1, zero
001c99 cf76                      	rjmp sound_driver_channel1_main
                                 
                                 //VIBRATO
                                 sound_driver_channel1_fx_4xy:
001c9a 2fba                      	mov r27, r26
001c9b 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001c9c 95a2                      	swap r26
001c9d 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001c9e 93a0 28a6                 	sts pulse2_fx_4xy_speed, r26
001ca0 93b0 28a7                 	sts pulse2_fx_4xy_depth, r27
001ca2 9220 28a8                 	sts pulse2_fx_4xy_phase, zero //reset the phase to 0
001ca4 cf6b                      	rjmp sound_driver_channel1_main
                                 
                                 //TREMELO
                                 sound_driver_channel1_fx_7xy:
001ca5 2fba                      	mov r27, r26
001ca6 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001ca7 95a2                      	swap r26
001ca8 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001ca9 93a0 28a9                 	sts pulse2_fx_7xy_speed, r26
001cab 93b0 28aa                 	sts pulse2_fx_7xy_depth, r27
001cad 9220 28ab                 	sts pulse2_fx_7xy_phase, zero //reset the phase to 0
001caf 9220 28ac                 	sts pulse2_fx_7xy_value, zero //reset the tremelo value
001cb1 cf5e                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel1_fx_Axy:
001cb2 93a0 28ad                 	sts pulse2_fx_Axy, r26
001cb4 cf5b                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel1_fx_Bxx:
001cb5 93a0 281f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001cb7 cf58                      	rjmp sound_driver_channel1_main
                                 
                                 //HALT
                                 sound_driver_channel1_fx_Cxx:
001cb8 93b0 2820                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001cba cf55                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel1_fx_Dxx:
001cbb 93b0 2821                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001cbd cf52                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME
                                 sound_driver_channel1_fx_Exx:
001cbe 91b0 2808                 	lds r27, pulse2_param
001cc0 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
001cc1 2bba                      	or r27, r26 //move new VVVV bits into pulse2_param
001cc2 93b0 2808                 	sts pulse2_param, r27
001cc4 6092                      	sbr pulse_channel_flags, 2
001cc5 cf4a                      	rjmp sound_driver_channel1_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel1_fx_Fxx:
001cc6 93a0 281e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001cc8 cf47                      	rjmp sound_driver_channel1_main
                                 
                                 //DELAY
                                 sound_driver_channel1_fx_Gxx:
001cc9 15a2                      	cp r26, zero
001cca f051                      	breq sound_driver_channel1_fx_Gxx_invalid
001ccb 91b0 281e                 	lds r27, song_speed
001ccd 17ab                      	cp r26, r27
001cce f430                      	brsh sound_driver_channel1_fx_Gxx_invalid
001ccf 93a0 28ae                 	sts pulse2_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001cd1 e0b1                      	ldi r27, 0x01
001cd2 93b0 2873                 	sts pulse2_pattern_delay_rows, r27
001cd4 c211                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Gxx_invalid:
001cd5 cf3a                      	rjmp sound_driver_channel1_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel1_fx_Hxy: //hardware sweep up
001cd6 cf39                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixy: //hardware sweep down
001cd7 cf38                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Hxx: //FDS modulation depth
001cd8 cf37                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixx: //FDS modulation speed
001cd9 cf36                      	rjmp sound_driver_channel1_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel1_fx_Pxx:
001cda 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001cdb 937f                      	push r23
001cdc 2f6a                      	mov r22, r26
001cdd eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001cde 0367                      	mulsu r22, r23
001cdf 917f                      	pop r23
001ce0 916f                      	pop r22
001ce1 9416                      	lsr r1 //shift out the fractional bits
001ce2 9407                      	ror r0
001ce3 9416                      	lsr r1
001ce4 9407                      	ror r0
001ce5 9416                      	lsr r1
001ce6 9407                      	ror r0
001ce7 9416                      	lsr r1
001ce8 9407                      	ror r0
001ce9 9200 28b0                 	sts pulse2_fx_Pxx_total, r0
001ceb 9210 28b1                 	sts pulse2_fx_Pxx_total+1, r1
001ced cf22                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel1_fx_Qxy:
                                 sound_driver_channel1_fx_Qxy_check_arpeggio_macro:
001cee 91e0 287c                 	lds ZL, pulse2_arpeggio_macro
001cf0 91f0 287d                 	lds ZH, pulse2_arpeggio_macro+1
001cf2 9630                      	adiw Z, 0
001cf3 f009                      	breq sound_driver_channel1_fx_Qxy_check_pitch_macro
001cf4 cf1b                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_pitch_macro:
001cf5 91e0 2884                 	lds ZL, pulse2_pitch_macro
001cf7 91f0 2885                 	lds ZH, pulse2_pitch_macro+1
001cf9 9630                      	adiw Z, 0
001cfa f009                      	breq sound_driver_channel1_fx_Qxy_check_hi_pitch_macro
001cfb cf14                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_hi_pitch_macro:
001cfc 91e0 288a                 	lds ZL, pulse2_hi_pitch_macro
001cfe 91f0 288b                 	lds ZH, pulse2_hi_pitch_macro+1
001d00 9630                      	adiw Z, 0
001d01 f009                      	breq sound_driver_channel1_fx_Qxy_process
001d02 cf0d                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_process:
001d03 2fba                      	mov r27, r26 //copy fx parameters into r27
001d04 70bf                      	andi r27, 0x0F //mask note index offset
001d05 91c0 280f                 	lds r28, pulse2_note //load current note index
001d07 0fbc                      	add r27, r28
001d08 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001d09 f008                      	brlo sound_driver_channel1_fx_Qxy_process_continue
001d0a e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel1_fx_Qxy_process_continue:
001d0b e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001d0c e0f0                      	ldi ZH, HIGH(note_table << 1)
001d0d 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001d0e 0feb                      	add ZL, r27 //add offset
001d0f 1df2                      	adc ZH, zero
001d10 91c5                      	lpm r28, Z+ //load bytes
001d11 91d4                      	lpm r29, Z
001d12 93c0 28b2                 	sts pulse2_fx_Qxy_target, r28 //load the LOW bits for the target period
001d14 93d0 28b3                 	sts pulse2_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
001d16 95a2                      	swap r26
001d17 70af                      	andi r26, 0x0F //mask effect speed
001d18 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001d19 95a3                      	inc r26 //increment the speed by 1
                                 
001d1a 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001d1b 937f                      	push r23
001d1c 2f6a                      	mov r22, r26 //store the speed data into r27
001d1d eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001d1e 9f67                      	mul r22, r23
001d1f 917f                      	pop r23
001d20 916f                      	pop r22
                                 
001d21 9416                      	lsr r1 //shift out the fractional bits
001d22 9407                      	ror r0
001d23 9416                      	lsr r1
001d24 9407                      	ror r0
001d25 9416                      	lsr r1
001d26 9407                      	ror r0
001d27 9416                      	lsr r1
001d28 9407                      	ror r0
                                 
001d29 9200 28b4                 	sts pulse2_fx_Qxy_speed, r0 //store the effect speed
001d2b 9210 28b5                 	sts pulse2_fx_Qxy_speed+1, r1
001d2d 9220 28b6                 	sts pulse2_fx_Qxy_total_offset, zero
001d2f 9220 28b7                 	sts pulse2_fx_Qxy_total_offset+1, zero
001d31 cede                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel1_fx_Rxy:
                                 sound_driver_channel1_fx_Rxy_check_arpeggio_macro:
001d32 91e0 287c                 	lds ZL, pulse2_arpeggio_macro
001d34 91f0 287d                 	lds ZH, pulse2_arpeggio_macro+1
001d36 9630                      	adiw Z, 0
001d37 f009                      	breq sound_driver_channel1_fx_Rxy_check_pitch_macro
001d38 ced7                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_pitch_macro:
001d39 91e0 2884                 	lds ZL, pulse2_pitch_macro
001d3b 91f0 2885                 	lds ZH, pulse2_pitch_macro+1
001d3d 9630                      	adiw Z, 0
001d3e f009                      	breq sound_driver_channel1_fx_Rxy_check_hi_pitch_macro
001d3f ced0                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_hi_pitch_macro:
001d40 91e0 288a                 	lds ZL, pulse2_hi_pitch_macro
001d42 91f0 288b                 	lds ZH, pulse2_hi_pitch_macro+1
001d44 9630                      	adiw Z, 0
001d45 f009                      	breq sound_driver_channel1_fx_Rxy_process
001d46 cec9                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_process:
001d47 2fba                      	mov r27, r26 //copy fx parameters into r27
001d48 70bf                      	andi r27, 0x0F //mask note index offset
001d49 91c0 280f                 	lds r28, pulse2_note //load current note index
001d4b 1bcb                      	sub r28, r27
001d4c f408                      	brcc sound_driver_channel1_fx_Rxy_process_continue
001d4d e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel1_fx_Rxy_process_continue:
001d4e e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001d4f e0f0                      	ldi ZH, HIGH(note_table << 1)
001d50 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001d51 0fec                      	add ZL, r28 //add offset
001d52 1df2                      	adc ZH, zero
001d53 91c5                      	lpm r28, Z+ //load bytes
001d54 91d4                      	lpm r29, Z
001d55 93c0 28b8                 	sts pulse2_fx_Rxy_target, r28 //load the LOW bits for the target period
001d57 93d0 28b9                 	sts pulse2_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
001d59 95a2                      	swap r26
001d5a 70af                      	andi r26, 0x0F //mask effect speed
001d5b 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001d5c 95a3                      	inc r26 //increment the speed by 1
                                 
001d5d 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001d5e 937f                      	push r23
001d5f 2f6a                      	mov r22, r26 //store the speed data into r27
001d60 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001d61 9f67                      	mul r22, r23
001d62 917f                      	pop r23
001d63 916f                      	pop r22
                                 
001d64 9416                      	lsr r1 //shift out the fractional bits
001d65 9407                      	ror r0
001d66 9416                      	lsr r1
001d67 9407                      	ror r0
001d68 9416                      	lsr r1
001d69 9407                      	ror r0
001d6a 9416                      	lsr r1
001d6b 9407                      	ror r0
                                 
001d6c 9200 28ba                 	sts pulse2_fx_Rxy_speed, r0 //store the effect speed
001d6e 9210 28bb                 	sts pulse2_fx_Rxy_speed+1, r1
001d70 9220 28bc                 	sts pulse2_fx_Rxy_total_offset, zero
001d72 9220 28bd                 	sts pulse2_fx_Rxy_total_offset+1, zero
001d74 ce9b                      	rjmp sound_driver_channel1_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel1_fx_Sxx:
001d75 15a2                      	cp r26, zero
001d76 f051                      	breq sound_driver_channel1_fx_Sxx_invalid
001d77 91b0 281e                 	lds r27, song_speed
001d79 17ab                      	cp r26, r27
001d7a f430                      	brsh sound_driver_channel1_fx_Sxx_invalid
001d7b 93a0 28be                 	sts pulse2_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001d7d e0b1                      	ldi r27, 0x01
001d7e 93b0 2873                 	sts pulse2_pattern_delay_rows, r27
001d80 c165                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Sxx_invalid:
001d81 ce8e                      	rjmp sound_driver_channel1_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel1_fx_Vxx:
001d82 e9e6                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
001d83 e6f4                      	ldi ZH, HIGH(sequences << 1)
001d84 0fea                      	add ZL, r26 //offset the pointer
001d85 1df2                      	adc ZH, zero
                                 
001d86 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
001d87 95a7                      	ror r26
001d88 95a7                      	ror r26
001d89 91b0 2808                 	lds r27, pulse2_param //load r27 with pulse2_param (register $4000)
001d8b 2fcb                      	mov r28, r27 //store a copy of pulse2_param into r28
001d8c 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
001d8d 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
001d8e c001                      	rjmp sound_driver_channel1_fx_Vxx_store
001d8f ce80                      	rjmp sound_driver_channel1_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel1_fx_Vxx_store:
001d90 90d4                      	lpm pulse2_sequence, Z //store the sequence
                                 
001d91 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
001d92 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
001d93 93c0 2808                 	sts pulse2_param, r28
001d95 ce7a                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_Wxx: //DPCM sample speed
001d96 ce79                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Xxx: //DPCM sample retrigger
001d97 ce78                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Yxx: //DPCM sample offset
001d98 ce77                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Zxx: //DPCM sample delta counter
001d99 ce76                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 sound_driver_channel1_note:
001d9a 93b0 280f                 	sts pulse2_note, r27 //store the note index
001d9c e0a3                      	ldi r26, 0x03
001d9d e0b2                      	ldi r27, 0x02
001d9e 93b0 2879                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
001da0 93a0 287e                 	sts pulse2_arpeggio_macro_offset, r26
001da2 93b0 2886                 	sts pulse2_pitch_macro_offset, r27
001da4 93b0 288c                 	sts pulse2_hi_pitch_macro_offset, r27
001da6 93b0 2891                 	sts pulse2_duty_macro_offset, r27
001da8 9220 2882                 	sts pulse2_total_pitch_offset, zero //reset the pitch and hi pitch offset
001daa 9220 2883                 	sts pulse2_total_pitch_offset+1, zero
001dac 9220 2889                 	sts pulse2_total_hi_pitch_offset, zero
001dae 9220 2898                 	sts pulse2_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001db0 9220 2899                 	sts pulse2_fx_1xx_total+1, zero
001db2 9220 289c                 	sts pulse2_fx_2xx_total, zero
001db4 9220 289d                 	sts pulse2_fx_2xx_total+1, zero
001db6 9220 28a4                 	sts pulse2_fx_3xx_total_offset, zero //reset 3xx offset
001db8 9220 28a5                 	sts pulse2_fx_3xx_total_offset+1, zero
001dba 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001dbc 91b0 0a9d                 	lds r27, TCB1_CCMPH
001dbe 93a0 289e                 	sts pulse2_fx_3xx_start, r26
001dc0 93b0 289f                 	sts pulse2_fx_3xx_start+1, r27
001dc2 9220 2809                 	sts pulse2_sweep_param, zero //reset any sweep effect
001dc4 6093                      	sbr pulse_channel_flags, 3 //set reload flag
001dc5 9220 28b2                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001dc7 9220 28b3                 	sts pulse2_fx_Qxy_target+1, zero
001dc9 9220 28b6                 	sts pulse2_fx_Qxy_total_offset, zero
001dcb 9220 28b7                 	sts pulse2_fx_Qxy_total_offset+1, zero
001dcd 9220 28b8                 	sts pulse2_fx_Rxy_target, zero
001dcf 9220 28b9                 	sts pulse2_fx_Rxy_target+1, zero
001dd1 9220 28bc                 	sts pulse2_fx_Rxy_total_offset, zero
001dd3 9220 28bd                 	sts pulse2_fx_Rxy_total_offset+1, zero
001dd5 d0f9                      	rcall sound_driver_channel1_increment_offset
001dd6 ce39                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_volume:
001dd7 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001dd8 91a0 2808                 	lds r26, pulse2_param
001dda 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001ddb 2bab                      	or r26, r27 //move new VVVV bits into pulse2_param
001ddc 93a0 2808                 	sts pulse2_param, r26
001dde 6092                      	sbr pulse_channel_flags, 2
001ddf d0ef                      	rcall sound_driver_channel1_increment_offset
001de0 ce2f                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_delay:
001de1 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001de2 93b0 2873                 	sts pulse2_pattern_delay_rows, r27
001de4 d0ea                      	rcall sound_driver_channel1_increment_offset
001de5 c100                      	rjmp sound_driver_channel2
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change:
001de6 9220 2877                 	sts pulse2_volume_macro, zero //reset all macro addresses
001de8 9220 2878                 	sts pulse2_volume_macro+1, zero
001dea 9220 287c                 	sts pulse2_arpeggio_macro, zero
001dec 9220 287d                 	sts pulse2_arpeggio_macro+1, zero
001dee 9220 2884                 	sts pulse2_pitch_macro, zero
001df0 9220 2885                 	sts pulse2_pitch_macro+1, zero
001df2 9220 288a                 	sts pulse2_hi_pitch_macro, zero
001df4 9220 288b                 	sts pulse2_hi_pitch_macro+1, zero
001df6 9220 288f                 	sts pulse2_duty_macro, zero
001df8 9220 2890                 	sts pulse2_duty_macro+1, zero
001dfa 9220 2882                 	sts pulse2_total_pitch_offset, zero //reset the pitch offset
001dfc 9220 2883                 	sts pulse2_total_pitch_offset+1, zero
001dfe 9220 2889                 	sts pulse2_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001e00 9631                      	adiw Z, 1 //point to the byte next to the flag
001e01 91b4                      	lpm r27, Z //store the instrument offset into r27
001e02 e3eb                      	ldi ZL, LOW(instruments) //point Z to instruments table
001e03 e1f1                      	ldi ZH, HIGH(instruments)
001e04 0feb                      	add ZL, r27 //point Z to offsetted instrument
001e05 1df2                      	adc ZH, zero
001e06 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001e07 1fff                      	rol ZH
001e08 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001e09 91b4                      	lpm r27, Z
                                 
001e0a 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001e0b 1fbb                      	rol r27
001e0c 2fea                      	mov ZL, r26
001e0d 2ffb                      	mov ZH, r27
001e0e 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001e0f 9632                      	adiw Z, 2 //point Z to the address of the macro
001e10 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel1_instrument_change_macro_loop:
001e11 95aa                      	dec r26
001e12 f019                      	breq sound_driver_channel1_instrument_change_exit
001e13 95b6                      	lsr r27
001e14 f078                      	brcs sound_driver_channel1_instrument_change_load_macro
001e15 cffb                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_exit:
001e16 e0a3                      	ldi r26, 0x03
001e17 e0b2                      	ldi r27, 0x02
001e18 93b0 2879                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
001e1a 93a0 287e                 	sts pulse2_arpeggio_macro_offset, r26
001e1c 93b0 2886                 	sts pulse2_pitch_macro_offset, r27
001e1e 93b0 288c                 	sts pulse2_hi_pitch_macro_offset, r27
001e20 93b0 2891                 	sts pulse2_duty_macro_offset, r27
001e22 d0b6                      	rcall sound_driver_channel1_increment_offset_twice
001e23 cdec                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_load_macro:
001e24 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001e25 91d5                      	lpm r29, Z+
                                 
001e26 30a5                      	cpi r26, 5
001e27 f039                      	breq sound_driver_channel1_instrument_change_load_macro_volume
001e28 30a4                      	cpi r26, 4
001e29 f079                      	breq sound_driver_channel1_instrument_change_load_macro_arpeggio
001e2a 30a3                      	cpi r26, 3
001e2b f0d9                      	breq sound_driver_channel1_instrument_change_load_macro_pitch
001e2c 30a2                      	cpi r26, 2
001e2d f159                      	breq sound_driver_channel1_instrument_change_load_macro_hi_pitch
001e2e c03c                      	rjmp sound_driver_channel1_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel1_instrument_change_load_macro_volume:
001e2f 93c0 2877                 	sts pulse2_volume_macro, r28
001e31 93d0 2878                 	sts pulse2_volume_macro+1, r29
001e33 d041                      	rcall sound_driver_channel1_instrument_change_read_header
001e34 93c0 287b                 	sts pulse2_volume_macro_release, r28
001e36 93d0 287a                 	sts pulse2_volume_macro_loop, r29
001e38 cfd8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 	
                                 sound_driver_channel1_instrument_change_load_macro_arpeggio:
001e39 93c0 287c                 	sts pulse2_arpeggio_macro, r28
001e3b 93d0 287d                 	sts pulse2_arpeggio_macro+1, r29
001e3d 9220 28b2                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001e3f 9220 28b3                 	sts pulse2_fx_Qxy_target+1, zero
001e41 9220 28b8                 	sts pulse2_fx_Rxy_target, zero
001e43 9220 28b9                 	sts pulse2_fx_Rxy_target+1, zero
001e45 d03a                      	rcall sound_driver_channel1_instrument_change_read_header_arpeggio
001e46 cfca                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_pitch:
001e47 93c0 2884                 	sts pulse2_pitch_macro, r28
001e49 93d0 2885                 	sts pulse2_pitch_macro+1, r29
001e4b 9220 28b2                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001e4d 9220 28b3                 	sts pulse2_fx_Qxy_target+1, zero
001e4f 9220 28b8                 	sts pulse2_fx_Rxy_target, zero
001e51 9220 28b9                 	sts pulse2_fx_Rxy_target+1, zero
001e53 d021                      	rcall sound_driver_channel1_instrument_change_read_header
001e54 93c0 2888                 	sts pulse2_pitch_macro_release, r28
001e56 93d0 2887                 	sts pulse2_pitch_macro_loop, r29
001e58 cfb8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_hi_pitch:
001e59 93c0 288a                 	sts pulse2_hi_pitch_macro, r28
001e5b 93d0 288b                 	sts pulse2_hi_pitch_macro+1, r29
001e5d 9220 28b2                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001e5f 9220 28b3                 	sts pulse2_fx_Qxy_target+1, zero
001e61 9220 28b8                 	sts pulse2_fx_Rxy_target, zero
001e63 9220 28b9                 	sts pulse2_fx_Rxy_target+1, zero
001e65 d00f                      	rcall sound_driver_channel1_instrument_change_read_header
001e66 93c0 288e                 	sts pulse2_hi_pitch_macro_release, r28
001e68 93d0 288d                 	sts pulse2_hi_pitch_macro_loop, r29
001e6a cfa6                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_duty:
001e6b 93c0 288f                 	sts pulse2_duty_macro, r28
001e6d 93d0 2890                 	sts pulse2_duty_macro+1, r29
001e6f d005                      	rcall sound_driver_channel1_instrument_change_read_header
001e70 93c0 2893                 	sts pulse2_duty_macro_release, r28
001e72 93d0 2892                 	sts pulse2_duty_macro_loop, r29
001e74 cf9c                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_read_header:
001e75 93ef                      	push ZL
001e76 93ff                      	push ZH
001e77 2fec                      	mov ZL, r28
001e78 2ffd                      	mov ZH, r29
001e79 0fee                      	lsl ZL
001e7a 1fff                      	rol ZH
001e7b 91c5                      	lpm r28, Z+
001e7c 91d4                      	lpm r29, Z
001e7d 91ff                      	pop ZH
001e7e 91ef                      	pop ZL
001e7f 9508                      	ret
                                 
                                 sound_driver_channel1_instrument_change_read_header_arpeggio:
001e80 93ef                      	push ZL
001e81 93ff                      	push ZH
001e82 2fec                      	mov ZL, r28
001e83 2ffd                      	mov ZH, r29
001e84 0fee                      	lsl ZL
001e85 1fff                      	rol ZH
001e86 91c5                      	lpm r28, Z+
001e87 91d5                      	lpm r29, Z+
001e88 93c0 2880                 	sts pulse2_arpeggio_macro_release, r28
001e8a 93d0 287f                 	sts pulse2_arpeggio_macro_loop, r29
001e8c 91c4                      	lpm r28, Z
001e8d 93c0 2881                 	sts pulse2_arpeggio_macro_mode, r28
001e8f 91ff                      	pop ZH
001e90 91ef                      	pop ZL
001e91 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel1_release:
                                 sound_driver_channel1_release_volume:
001e92 91b0 287b                 	lds r27, pulse2_volume_macro_release
001e94 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001e95 f019                      	breq sound_driver_channel1_release_arpeggio //if the macro has no release flag, check the next macro
001e96 95b3                      	inc r27
001e97 93b0 2879                 	sts pulse2_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel1_release_arpeggio:
001e99 91b0 2880                 	lds r27, pulse2_arpeggio_macro_release
001e9b 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001e9c f019                      	breq sound_driver_channel1_release_pitch
001e9d 95b3                      	inc r27
001e9e 93b0 287e                 	sts pulse2_arpeggio_macro_offset, r27
                                 sound_driver_channel1_release_pitch:
001ea0 91b0 2888                 	lds r27, pulse2_pitch_macro_release
001ea2 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001ea3 f019                      	breq sound_driver_channel1_release_hi_pitch
001ea4 95b3                      	inc r27
001ea5 93b0 2886                 	sts pulse2_pitch_macro_offset, r27
                                 sound_driver_channel1_release_hi_pitch:
001ea7 91b0 288e                 	lds r27, pulse2_hi_pitch_macro_release
001ea9 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001eaa f019                      	breq sound_driver_channel1_release_duty
001eab 95b3                      	inc r27
001eac 93b0 288c                 	sts pulse2_hi_pitch_macro_offset, r27
                                 sound_driver_channel1_release_duty:
001eae 91b0 2893                 	lds r27, pulse2_duty_macro_release
001eb0 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001eb1 f019                      	breq sound_driver_channel1_release_exit
001eb2 95b3                      	inc r27
001eb3 93b0 2891                 	sts pulse2_duty_macro_offset, r27
                                 sound_driver_channel1_release_exit:
001eb5 d019                      	rcall sound_driver_channel1_increment_offset
001eb6 cd59                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_next_pattern:
001eb7 91e0 2818                 	lds ZL, song_frames
001eb9 91f0 2819                 	lds ZH, song_frames+1
001ebb 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001ebd 91b0 281b                 	lds r27, song_frame_offset+1
001ebf 9612                      	adiw r27:r26, 2 //offset for channel 1
001ec0 0fea                      	add ZL, r26
001ec1 1ffb                      	adc ZH, r27
                                 
001ec2 91a5                      	lpm r26, Z+ //load the address of the next pattern
001ec3 91b4                      	lpm r27, Z
001ec4 0faa                      	lsl r26
001ec5 1fbb                      	rol r27
001ec6 93a0 2871                 	sts pulse2_pattern, r26
001ec8 93b0 2872                 	sts pulse2_pattern+1, r27
                                 
001eca 9220 2875                 	sts pulse2_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001ecc 9220 2876                 	sts pulse2_pattern_offset+1, zero
001ece cd41                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_increment_offset:
001ecf 91e0 2875                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001ed1 91f0 2876                 	lds ZH, pulse2_pattern_offset+1
001ed3 9631                      	adiw Z, 1
001ed4 93e0 2875                 	sts pulse2_pattern_offset, ZL
001ed6 93f0 2876                 	sts pulse2_pattern_offset+1, ZH
001ed8 9508                      	ret
                                 
                                 sound_driver_channel1_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001ed9 91e0 2875                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001edb 91f0 2876                 	lds ZH, pulse2_pattern_offset+1
001edd 9632                      	adiw Z, 2 //increment the pointer twice
001ede 93e0 2875                 	sts pulse2_pattern_offset, ZL
001ee0 93f0 2876                 	sts pulse2_pattern_offset+1, ZH
001ee2 9508                      	ret
                                 
                                 sound_driver_channel1_decrement_frame_delay:
001ee3 95ba                      	dec r27
001ee4 93b0 2874                 	sts pulse2_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel2:
001ee6 91a0 28c2                 	lds r26, triangle_pattern_delay_rows
001ee8 91b0 28c3                 	lds r27, triangle_pattern_delay_frames
001eea 9610                      	adiw r27:r26, 0
001eeb f009                      	breq sound_driver_channel2_main //if the pattern delay is 0, proceed with sound driver procedures
001eec c2bb                      	rjmp sound_driver_channel2_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel2_main:
001eed 91e0 28c0                 	lds ZL, triangle_pattern //current pattern for triangle
001eef 91f0 28c1                 	lds ZH, triangle_pattern+1
001ef1 91a0 28c4                 	lds r26, triangle_pattern_offset //current offset in the pattern for triangle
001ef3 91b0 28c5                 	lds r27, triangle_pattern_offset+1
001ef5 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001ef6 1ffb                      	adc ZH, r27
001ef7 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel2_check_if_note: //check if data is a note (0x00 - 0x56)
001ef8 35b7                      	cpi r27, 0x57
001ef9 f408                      	brsh sound_driver_channel2_check_if_volume
001efa c160                      	rjmp sound_driver_channel2_note
                                 sound_driver_channel2_check_if_volume: //check if data is volume (0x57-0x66)
001efb 36b7                      	cpi r27, 0x67
001efc f408                      	brsh sound_driver_channel2_check_if_delay
001efd c19a                      	rjmp sound_driver_channel2_volume
                                 sound_driver_channel2_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001efe 3eb3                      	cpi r27, 0xE3
001eff f408                      	brsh sound_driver_channel2_check_if_instrument
001f00 c1a5                      	rjmp sound_driver_channel2_delay
                                 sound_driver_channel2_check_if_instrument: //check for instrument flag (0xE3)
001f01 f409                      	brne sound_driver_channel2_check_if_release
001f02 c1a8                      	rjmp sound_driver_channel2_instrument_change 
                                 sound_driver_channel2_check_if_release: //check for note release flag (0xE4)
001f03 3eb4                      	cpi r27, 0xE4
001f04 f409                      	brne sound_driver_channel2_check_if_end
001f05 c251                      	rjmp sound_driver_channel2_release
                                 sound_driver_channel2_check_if_end:
001f06 3fbf                      	cpi r27, 0xFF
001f07 f409                      	brne sound_driver_channel2_check_if_fx
001f08 c273                      	rjmp sound_driver_channel2_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel2_check_if_fx: //fx flags (0xE5 - 0xFE)
001f09 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001f0a 91a4                      	lpm r26, Z //load the fx data into r26
001f0b d292                      	rcall sound_driver_channel2_increment_offset_twice
                                 
001f0c 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001f0d e0e2                      	ldi ZL, LOW(channel2_fx << 1) //load in note table
001f0e e6f5                      	ldi ZH, HIGH(channel2_fx << 1)
001f0f 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001f10 0feb                      	add ZL, r27 //add offset
001f11 1df2                      	adc ZH, zero
001f12 91c5                      	lpm r28, Z+ //load address bytes
001f13 91d4                      	lpm r29, Z
001f14 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001f15 2ffd                      	mov ZH, r29
001f16 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel2_fx_0xy:
001f17 93a0 28e3                 	sts triangle_fx_0xy_sequence, r26
001f19 9220 28e4                 	sts triangle_fx_0xy_sequence+1, zero
001f1b cfd1                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel2_fx_1xx:
001f1c 9220 28e9                 	sts triangle_fx_2xx, zero //turn off any 2xx pitch slide down
001f1e 9220 28ea                 	sts triangle_fx_2xx+1, zero
001f20 9220 28e3                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001f22 9220 28e4                 	sts triangle_fx_0xy_sequence+1, zero
001f24 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001f25 937f                      	push r23
001f26 2f6a                      	mov r22, r26 //store the rate into r22
001f27 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001f28 9f67                      	mul r22, r23
001f29 917f                      	pop r23
001f2a 916f                      	pop r22
                                 
001f2b 9416                      	lsr r1 //shift out the fractional bits
001f2c 9407                      	ror r0
001f2d 9416                      	lsr r1
001f2e 9407                      	ror r0
001f2f 9416                      	lsr r1
001f30 9407                      	ror r0
001f31 9416                      	lsr r1
001f32 9407                      	ror r0
001f33 9200 28e5                 	sts triangle_fx_1xx, r0
001f35 9210 28e6                 	sts triangle_fx_1xx+1, r1
001f37 cfb5                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel2_fx_2xx:
001f38 9220 28e5                 	sts triangle_fx_1xx, zero //turn off any 1xx pitch slide down
001f3a 9220 28e6                 	sts triangle_fx_1xx+1, zero
001f3c 9220 28e3                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001f3e 9220 28e4                 	sts triangle_fx_0xy_sequence+1, zero
001f40 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001f41 937f                      	push r23
001f42 2f6a                      	mov r22, r26 //store the rate into r22
001f43 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001f44 9f67                      	mul r22, r23
001f45 917f                      	pop r23
001f46 916f                      	pop r22
                                 
001f47 9416                      	lsr r1 //shift out the fractional bits
001f48 9407                      	ror r0
001f49 9416                      	lsr r1
001f4a 9407                      	ror r0
001f4b 9416                      	lsr r1
001f4c 9407                      	ror r0
001f4d 9416                      	lsr r1
001f4e 9407                      	ror r0
001f4f 9200 28e9                 	sts triangle_fx_2xx, r0
001f51 9210 28ea                 	sts triangle_fx_2xx+1, r1
001f53 cf99                      	rjmp sound_driver_channel2_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel2_fx_3xx:
001f54 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001f55 937f                      	push r23
001f56 2f6a                      	mov r22, r26 //store the rate into r22
001f57 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001f58 9f67                      	mul r22, r23
001f59 917f                      	pop r23
001f5a 916f                      	pop r22
                                 
001f5b 9416                      	lsr r1 //shift out the fractional bits
001f5c 9407                      	ror r0
001f5d 9416                      	lsr r1
001f5e 9407                      	ror r0
001f5f 9416                      	lsr r1
001f60 9407                      	ror r0
001f61 9416                      	lsr r1
001f62 9407                      	ror r0
001f63 9200 28f1                 	sts triangle_fx_3xx_speed, r0
001f65 9210 28f2                 	sts triangle_fx_3xx_speed+1, r1
                                 
001f67 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001f68 c001                      	rjmp sound_driver_channel2_fx_3xx_enabled
001f69 cf83                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_3xx_enabled:
001f6a 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001f6c 91b0 0aad                 	lds r27, TCB2_CCMPH
001f6e 93a0 28ed                 	sts triangle_fx_3xx_start, r26
001f70 93b0 28ee                 	sts triangle_fx_3xx_start+1, r27
                                 
001f72 9220 28f3                 	sts triangle_fx_3xx_total_offset, zero
001f74 9220 28f4                 	sts triangle_fx_3xx_total_offset+1, zero
001f76 cf76                      	rjmp sound_driver_channel2_main
                                 
                                 //VIBRATO
                                 sound_driver_channel2_fx_4xy:
001f77 2fba                      	mov r27, r26
001f78 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001f79 95a2                      	swap r26
001f7a 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001f7b 93a0 28f5                 	sts triangle_fx_4xy_speed, r26
001f7d 93b0 28f6                 	sts triangle_fx_4xy_depth, r27
001f7f 9220 28f7                 	sts triangle_fx_4xy_phase, zero //reset the phase to 0
001f81 cf6b                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_7xy: //tremelo
001f82 cf6a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Axy: //volume slide
001f83 cf69                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel2_fx_Bxx:
001f84 93a0 281f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001f86 cf66                      	rjmp sound_driver_channel2_main
                                 
                                 //HALT
                                 sound_driver_channel2_fx_Cxx:
001f87 93b0 2820                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001f89 cf63                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel2_fx_Dxx:
001f8a 93b0 2821                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001f8c cf60                      	rjmp sound_driver_channel2_main
                                 
                                 //VOLUME
                                 sound_driver_channel2_fx_Exx:
001f8d 15a2                      	cp r26, zero
001f8e f021                      	breq sound_driver_channel2_fx_Exx_disable
                                 sound_driver_channel2_fx_Exx_enable:
001f8f e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001f90 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001f92 cf5a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Exx_disable:
001f93 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
001f95 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
001f97 9220 0aad                 	sts TCB2_CCMPH, zero
001f99 cf53                      	rjmp sound_driver_channel2_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel2_fx_Fxx:
001f9a 93a0 281e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001f9c cf50                      	rjmp sound_driver_channel2_main
                                 
                                 //DELAY
                                 sound_driver_channel2_fx_Gxx:
001f9d 15a2                      	cp r26, zero
001f9e f051                      	breq sound_driver_channel2_fx_Gxx_invalid
001f9f 91b0 281e                 	lds r27, song_speed
001fa1 17ab                      	cp r26, r27
001fa2 f430                      	brsh sound_driver_channel2_fx_Gxx_invalid
001fa3 93a0 28f8                 	sts triangle_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001fa5 e0b1                      	ldi r27, 0x01
001fa6 93b0 28c2                 	sts triangle_pattern_delay_rows, r27
001fa8 c202                      	rjmp sound_driver_channel3
                                 sound_driver_channel2_fx_Gxx_invalid:
001fa9 cf43                      	rjmp sound_driver_channel2_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Hxy: //hardware sweep up
001faa cf42                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixy: //hardware sweep down
001fab cf41                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Hxx: //FDS modulation depth
001fac cf40                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixx: //FDS modulation speed
001fad cf3f                      	rjmp sound_driver_channel2_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel2_fx_Pxx:
001fae 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001faf 937f                      	push r23
001fb0 2f6a                      	mov r22, r26
001fb1 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001fb2 0367                      	mulsu r22, r23
001fb3 917f                      	pop r23
001fb4 916f                      	pop r22
001fb5 9416                      	lsr r1 //shift out the fractional bits
001fb6 9407                      	ror r0
001fb7 9416                      	lsr r1
001fb8 9407                      	ror r0
001fb9 9416                      	lsr r1
001fba 9407                      	ror r0
001fbb 9416                      	lsr r1
001fbc 9407                      	ror r0
001fbd 9200 28fa                 	sts triangle_fx_Pxx_total, r0
001fbf 9210 28fb                 	sts triangle_fx_Pxx_total+1, r1
001fc1 cf2b                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel2_fx_Qxy:
                                 sound_driver_channel2_fx_Qxy_check_arpeggio_macro:
001fc2 91e0 28cb                 	lds ZL, triangle_arpeggio_macro
001fc4 91f0 28cc                 	lds ZH, triangle_arpeggio_macro+1
001fc6 9630                      	adiw Z, 0
001fc7 f009                      	breq sound_driver_channel2_fx_Qxy_check_pitch_macro
001fc8 cf24                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_pitch_macro:
001fc9 91e0 28d3                 	lds ZL, triangle_pitch_macro
001fcb 91f0 28d4                 	lds ZH, triangle_pitch_macro+1
001fcd 9630                      	adiw Z, 0
001fce f009                      	breq sound_driver_channel2_fx_Qxy_check_hi_pitch_macro
001fcf cf1d                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_hi_pitch_macro:
001fd0 91e0 28d9                 	lds ZL, triangle_hi_pitch_macro
001fd2 91f0 28da                 	lds ZH, triangle_hi_pitch_macro+1
001fd4 9630                      	adiw Z, 0
001fd5 f009                      	breq sound_driver_channel2_fx_Qxy_process
001fd6 cf16                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_process:
001fd7 2fba                      	mov r27, r26 //copy fx parameters into r27
001fd8 70bf                      	andi r27, 0x0F //mask note index offset
001fd9 91c0 2812                 	lds r28, triangle_note //load current note index
001fdb 0fbc                      	add r27, r28
001fdc 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001fdd f008                      	brlo sound_driver_channel2_fx_Qxy_process_continue
001fde e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel2_fx_Qxy_process_continue:
001fdf e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001fe0 e0f0                      	ldi ZH, HIGH(note_table << 1)
001fe1 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001fe2 0feb                      	add ZL, r27 //add offset
001fe3 1df2                      	adc ZH, zero
001fe4 91c5                      	lpm r28, Z+ //load bytes
001fe5 91d4                      	lpm r29, Z
001fe6 93c0 28fc                 	sts triangle_fx_Qxy_target, r28 //load the LOW bits for the target period
001fe8 93d0 28fd                 	sts triangle_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
001fea 95a2                      	swap r26
001feb 70af                      	andi r26, 0x0F //mask effect speed
001fec 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001fed 95a3                      	inc r26 //increment the speed by 1
                                 
001fee 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001fef 937f                      	push r23
001ff0 2f6a                      	mov r22, r26 //store the speed data into r27
001ff1 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001ff2 9f67                      	mul r22, r23
001ff3 917f                      	pop r23
001ff4 916f                      	pop r22
                                 
001ff5 9416                      	lsr r1 //shift out the fractional bits
001ff6 9407                      	ror r0
001ff7 9416                      	lsr r1
001ff8 9407                      	ror r0
001ff9 9416                      	lsr r1
001ffa 9407                      	ror r0
001ffb 9416                      	lsr r1
001ffc 9407                      	ror r0
                                 
001ffd 9200 28fe                 	sts triangle_fx_Qxy_speed, r0 //store the effect speed
001fff 9210 28ff                 	sts triangle_fx_Qxy_speed+1, r1
002001 9220 2900                 	sts triangle_fx_Qxy_total_offset, zero
002003 9220 2901                 	sts triangle_fx_Qxy_total_offset+1, zero
002005 cee7                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel2_fx_Rxy:
                                 sound_driver_channel2_fx_Rxy_check_arpeggio_macro:
002006 91e0 28cb                 	lds ZL, triangle_arpeggio_macro
002008 91f0 28cc                 	lds ZH, triangle_arpeggio_macro+1
00200a 9630                      	adiw Z, 0
00200b f009                      	breq sound_driver_channel2_fx_Rxy_check_pitch_macro
00200c cee0                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_pitch_macro:
00200d 91e0 28d3                 	lds ZL, triangle_pitch_macro
00200f 91f0 28d4                 	lds ZH, triangle_pitch_macro+1
002011 9630                      	adiw Z, 0
002012 f009                      	breq sound_driver_channel2_fx_Rxy_check_hi_pitch_macro
002013 ced9                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_hi_pitch_macro:
002014 91e0 28d9                 	lds ZL, triangle_hi_pitch_macro
002016 91f0 28da                 	lds ZH, triangle_hi_pitch_macro+1
002018 9630                      	adiw Z, 0
002019 f009                      	breq sound_driver_channel2_fx_Rxy_process
00201a ced2                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_process:
00201b 2fba                      	mov r27, r26 //copy fx parameters into r27
00201c 70bf                      	andi r27, 0x0F //mask note index offset
00201d 91c0 2812                 	lds r28, triangle_note //load current note index
00201f 1bcb                      	sub r28, r27
002020 f408                      	brcc sound_driver_channel2_fx_Rxy_process_continue
002021 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel2_fx_Rxy_process_continue:
002022 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
002023 e0f0                      	ldi ZH, HIGH(note_table << 1)
002024 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
002025 0fec                      	add ZL, r28 //add offset
002026 1df2                      	adc ZH, zero
002027 91c5                      	lpm r28, Z+ //load bytes
002028 91d4                      	lpm r29, Z
002029 93c0 2902                 	sts triangle_fx_Rxy_target, r28 //load the LOW bits for the target period
00202b 93d0 2903                 	sts triangle_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
00202d 95a2                      	swap r26
00202e 70af                      	andi r26, 0x0F //mask effect speed
00202f 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
002030 95a3                      	inc r26 //increment the speed by 1
                                 
002031 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002032 937f                      	push r23
002033 2f6a                      	mov r22, r26 //store the speed data into r27
002034 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002035 9f67                      	mul r22, r23
002036 917f                      	pop r23
002037 916f                      	pop r22
                                 
002038 9416                      	lsr r1 //shift out the fractional bits
002039 9407                      	ror r0
00203a 9416                      	lsr r1
00203b 9407                      	ror r0
00203c 9416                      	lsr r1
00203d 9407                      	ror r0
00203e 9416                      	lsr r1
00203f 9407                      	ror r0
                                 
002040 9200 2904                 	sts triangle_fx_Rxy_speed, r0 //store the effect speed
002042 9210 2905                 	sts triangle_fx_Rxy_speed+1, r1
002044 9220 2906                 	sts triangle_fx_Rxy_total_offset, zero
002046 9220 2907                 	sts triangle_fx_Rxy_total_offset+1, zero
002048 cea4                      	rjmp sound_driver_channel2_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel2_fx_Sxx:
002049 15a2                      	cp r26, zero
00204a f051                      	breq sound_driver_channel2_fx_Sxx_invalid
00204b 91b0 281e                 	lds r27, song_speed
00204d 17ab                      	cp r26, r27
00204e f430                      	brsh sound_driver_channel2_fx_Sxx_invalid
00204f 93a0 2908                 	sts triangle_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
002051 e0b1                      	ldi r27, 0x01
002052 93b0 28c2                 	sts triangle_pattern_delay_rows, r27
002054 c156                      	rjmp sound_driver_channel3
                                 sound_driver_channel2_fx_Sxx_invalid:
002055 ce97                      	rjmp sound_driver_channel2_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Vxx: //duty
002056 ce96                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Wxx: //DPCM sample speed
002057 ce95                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Xxx: //DPCM sample retrigger
002058 ce94                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Yxx: //DPCM sample offset
002059 ce93                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Zxx: //DPCM sample delta counter
00205a ce92                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 sound_driver_channel2_note:
00205b 93b0 2812                 	sts triangle_note, r27 //store the note index
00205d e0a3                      	ldi r26, 0x03
00205e e0b2                      	ldi r27, 0x02
00205f 93b0 28c8                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
002061 93a0 28cd                 	sts triangle_arpeggio_macro_offset, r26
002063 93b0 28d5                 	sts triangle_pitch_macro_offset, r27
002065 93b0 28db                 	sts triangle_hi_pitch_macro_offset, r27
002067 93b0 28e0                 	sts triangle_duty_macro_offset, r27
002069 9220 28d1                 	sts triangle_total_pitch_offset, zero //reset the pitch and hi pitch offset
00206b 9220 28d1                 	sts triangle_total_pitch_offset, zero
00206d 9220 28d8                 	sts triangle_total_hi_pitch_offset, zero
00206f 9220 28e7                 	sts triangle_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
002071 9220 28e8                 	sts triangle_fx_1xx_total+1, zero
002073 9220 28eb                 	sts triangle_fx_2xx_total, zero
002075 9220 28ec                 	sts triangle_fx_2xx_total+1, zero
002077 9220 28f3                 	sts triangle_fx_3xx_total_offset, zero //reset 3xx offset
002079 9220 28f4                 	sts triangle_fx_3xx_total_offset+1, zero
00207b 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
00207d 91b0 0aad                 	lds r27, TCB2_CCMPH
00207f 93a0 28ed                 	sts triangle_fx_3xx_start, r26
002081 93b0 28ee                 	sts triangle_fx_3xx_start+1, r27
002083 9220 28fc                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
002085 9220 28fd                 	sts triangle_fx_Qxy_target+1, zero
002087 9220 2900                 	sts triangle_fx_Qxy_total_offset, zero
002089 9220 2901                 	sts triangle_fx_Qxy_total_offset+1, zero
00208b 9220 2902                 	sts triangle_fx_Rxy_target, zero
00208d 9220 2903                 	sts triangle_fx_Rxy_target+1, zero
00208f 9220 2906                 	sts triangle_fx_Rxy_total_offset, zero
002091 9220 2907                 	sts triangle_fx_Rxy_total_offset+1, zero
002093 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
002094 93b0 0aa5                 	sts TCB2_INTCTRL, r27
002096 d0fd                      	rcall sound_driver_channel2_increment_offset
002097 ce55                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_volume:
002098 d0fb                      	rcall sound_driver_channel2_increment_offset
002099 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
00209a f021                      	breq sound_driver_channel2_volume_disable
                                 sound_driver_channel2_volume_enable:
00209b e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
00209c 93b0 0aa5                 	sts TCB2_INTCTRL, r27
00209e ce4e                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_volume_disable:
00209f 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
0020a1 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
0020a3 9220 0aad                 	sts TCB2_CCMPH, zero
0020a5 ce47                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_delay:
0020a6 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
0020a7 93b0 28c2                 	sts triangle_pattern_delay_rows, r27
0020a9 d0ea                      	rcall sound_driver_channel2_increment_offset
0020aa c100                      	rjmp sound_driver_channel3
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change:
0020ab 9220 28c6                 	sts triangle_volume_macro, zero //reset all macro addresses
0020ad 9220 28c7                 	sts triangle_volume_macro+1, zero
0020af 9220 28cb                 	sts triangle_arpeggio_macro, zero
0020b1 9220 28cc                 	sts triangle_arpeggio_macro+1, zero
0020b3 9220 28d3                 	sts triangle_pitch_macro, zero
0020b5 9220 28d4                 	sts triangle_pitch_macro+1, zero
0020b7 9220 28d9                 	sts triangle_hi_pitch_macro, zero
0020b9 9220 28da                 	sts triangle_hi_pitch_macro+1, zero
0020bb 9220 28de                 	sts triangle_duty_macro, zero
0020bd 9220 28df                 	sts triangle_duty_macro+1, zero
0020bf 9220 28d1                 	sts triangle_total_pitch_offset, zero //reset the pitch offset
0020c1 9220 28d2                 	sts triangle_total_pitch_offset+1, zero
0020c3 9220 28d8                 	sts triangle_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
0020c5 9631                      	adiw Z, 1 //point to the byte next to the flag
0020c6 91b4                      	lpm r27, Z //store the instrument offset into r27
0020c7 e3eb                      	ldi ZL, LOW(instruments) //point Z to instruments table
0020c8 e1f1                      	ldi ZH, HIGH(instruments)
0020c9 0feb                      	add ZL, r27 //point Z to offsetted instrument
0020ca 1df2                      	adc ZH, zero
0020cb 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
0020cc 1fff                      	rol ZH
0020cd 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
0020ce 91b4                      	lpm r27, Z
                                 
0020cf 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
0020d0 1fbb                      	rol r27
0020d1 2fea                      	mov ZL, r26
0020d2 2ffb                      	mov ZH, r27
0020d3 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
0020d4 9632                      	adiw Z, 2 //point Z to the address of the macro
0020d5 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel2_instrument_change_macro_loop:
0020d6 95aa                      	dec r26
0020d7 f019                      	breq sound_driver_channel2_instrument_change_exit
0020d8 95b6                      	lsr r27
0020d9 f078                      	brcs sound_driver_channel2_instrument_change_load_macro
0020da cffb                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_exit:
0020db e0a3                      	ldi r26, 0x03
0020dc e0b2                      	ldi r27, 0x02
0020dd 93b0 28c8                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
0020df 93a0 28cd                 	sts triangle_arpeggio_macro_offset, r26
0020e1 93b0 28d5                 	sts triangle_pitch_macro_offset, r27
0020e3 93b0 28db                 	sts triangle_hi_pitch_macro_offset, r27
0020e5 93b0 28e0                 	sts triangle_duty_macro_offset, r27
0020e7 d0b6                      	rcall sound_driver_channel2_increment_offset_twice
0020e8 ce04                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_load_macro:
0020e9 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
0020ea 91d5                      	lpm r29, Z+
                                 
0020eb 30a5                      	cpi r26, 5
0020ec f039                      	breq sound_driver_channel2_instrument_change_load_macro_volume
0020ed 30a4                      	cpi r26, 4
0020ee f079                      	breq sound_driver_channel2_instrument_change_load_macro_arpeggio
0020ef 30a3                      	cpi r26, 3
0020f0 f0d9                      	breq sound_driver_channel2_instrument_change_load_macro_pitch
0020f1 30a2                      	cpi r26, 2
0020f2 f159                      	breq sound_driver_channel2_instrument_change_load_macro_hi_pitch
0020f3 c03c                      	rjmp sound_driver_channel2_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel2_instrument_change_load_macro_volume:
0020f4 93c0 28c6                 	sts triangle_volume_macro, r28
0020f6 93d0 28c7                 	sts triangle_volume_macro+1, r29
0020f8 d041                      	rcall sound_driver_channel2_instrument_change_read_header
0020f9 93c0 28ca                 	sts triangle_volume_macro_release, r28
0020fb 93d0 28c9                 	sts triangle_volume_macro_loop, r29
0020fd cfd8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 	
                                 sound_driver_channel2_instrument_change_load_macro_arpeggio:
0020fe 93c0 28cb                 	sts triangle_arpeggio_macro, r28
002100 93d0 28cc                 	sts triangle_arpeggio_macro+1, r29
002102 9220 28fc                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
002104 9220 28fd                 	sts triangle_fx_Qxy_target+1, zero
002106 9220 2902                 	sts triangle_fx_Rxy_target, zero
002108 9220 2903                 	sts triangle_fx_Rxy_target+1, zero
00210a d03a                      	rcall sound_driver_channel2_instrument_change_read_header_arpeggio
00210b cfca                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_pitch:
00210c 93c0 28d3                 	sts triangle_pitch_macro, r28
00210e 93d0 28d4                 	sts triangle_pitch_macro+1, r29
002110 9220 28fc                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
002112 9220 28fd                 	sts triangle_fx_Qxy_target+1, zero
002114 9220 2902                 	sts triangle_fx_Rxy_target, zero
002116 9220 2903                 	sts triangle_fx_Rxy_target+1, zero
002118 d021                      	rcall sound_driver_channel2_instrument_change_read_header
002119 93c0 28d7                 	sts triangle_pitch_macro_release, r28
00211b 93d0 28d6                 	sts triangle_pitch_macro_loop, r29
00211d cfb8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_hi_pitch:
00211e 93c0 28d9                 	sts triangle_hi_pitch_macro, r28
002120 93d0 28da                 	sts triangle_hi_pitch_macro+1, r29
002122 9220 28fc                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
002124 9220 28fd                 	sts triangle_fx_Qxy_target+1, zero
002126 9220 2902                 	sts triangle_fx_Rxy_target, zero
002128 9220 2903                 	sts triangle_fx_Rxy_target+1, zero
00212a d00f                      	rcall sound_driver_channel2_instrument_change_read_header
00212b 93c0 28dd                 	sts triangle_hi_pitch_macro_release, r28
00212d 93d0 28dc                 	sts triangle_hi_pitch_macro_loop, r29
00212f cfa6                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_duty:
002130 93c0 28de                 	sts triangle_duty_macro, r28
002132 93d0 28df                 	sts triangle_duty_macro+1, r29
002134 d005                      	rcall sound_driver_channel2_instrument_change_read_header
002135 93c0 28e2                 	sts triangle_duty_macro_release, r28
002137 93d0 28e1                 	sts triangle_duty_macro_loop, r29
002139 cf9c                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_read_header:
00213a 93ef                      	push ZL
00213b 93ff                      	push ZH
00213c 2fec                      	mov ZL, r28
00213d 2ffd                      	mov ZH, r29
00213e 0fee                      	lsl ZL
00213f 1fff                      	rol ZH
002140 91c5                      	lpm r28, Z+
002141 91d4                      	lpm r29, Z
002142 91ff                      	pop ZH
002143 91ef                      	pop ZL
002144 9508                      	ret
                                 
                                 sound_driver_channel2_instrument_change_read_header_arpeggio:
002145 93ef                      	push ZL
002146 93ff                      	push ZH
002147 2fec                      	mov ZL, r28
002148 2ffd                      	mov ZH, r29
002149 0fee                      	lsl ZL
00214a 1fff                      	rol ZH
00214b 91c5                      	lpm r28, Z+
00214c 91d5                      	lpm r29, Z+
00214d 93c0 28cf                 	sts triangle_arpeggio_macro_release, r28
00214f 93d0 28ce                 	sts triangle_arpeggio_macro_loop, r29
002151 91c4                      	lpm r28, Z
002152 93c0 28d0                 	sts triangle_arpeggio_macro_mode, r28
002154 91ff                      	pop ZH
002155 91ef                      	pop ZL
002156 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel2_release:
                                 sound_driver_channel2_release_volume:
002157 91b0 28ca                 	lds r27, triangle_volume_macro_release
002159 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
00215a f019                      	breq sound_driver_channel2_release_arpeggio //if the macro has no release flag, check the next macro
00215b 95b3                      	inc r27
00215c 93b0 28c8                 	sts triangle_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel2_release_arpeggio:
00215e 91b0 28cf                 	lds r27, triangle_arpeggio_macro_release
002160 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
002161 f019                      	breq sound_driver_channel2_release_pitch
002162 95b3                      	inc r27
002163 93b0 28cd                 	sts triangle_arpeggio_macro_offset, r27
                                 sound_driver_channel2_release_pitch:
002165 91b0 28d7                 	lds r27, triangle_pitch_macro_release
002167 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
002168 f019                      	breq sound_driver_channel2_release_hi_pitch
002169 95b3                      	inc r27
00216a 93b0 28d5                 	sts triangle_pitch_macro_offset, r27
                                 sound_driver_channel2_release_hi_pitch:
00216c 91b0 28dd                 	lds r27, triangle_hi_pitch_macro_release
00216e 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
00216f f019                      	breq sound_driver_channel2_release_duty
002170 95b3                      	inc r27
002171 93b0 28db                 	sts triangle_hi_pitch_macro_offset, r27
                                 sound_driver_channel2_release_duty:
002173 91b0 28e2                 	lds r27, triangle_duty_macro_release
002175 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
002176 f019                      	breq sound_driver_channel2_release_exit
002177 95b3                      	inc r27
002178 93b0 28e0                 	sts triangle_duty_macro_offset, r27
                                 sound_driver_channel2_release_exit:
00217a d019                      	rcall sound_driver_channel2_increment_offset
00217b cd71                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_next_pattern:
00217c 91e0 2818                 	lds ZL, song_frames
00217e 91f0 2819                 	lds ZH, song_frames+1
002180 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
002182 91b0 281b                 	lds r27, song_frame_offset+1
002184 9614                      	adiw r27:r26, 4 //offset for channel 2
002185 0fea                      	add ZL, r26
002186 1ffb                      	adc ZH, r27
                                 
002187 91a5                      	lpm r26, Z+ //load the address of the next pattern
002188 91b4                      	lpm r27, Z
002189 0faa                      	lsl r26
00218a 1fbb                      	rol r27
00218b 93a0 28c0                 	sts triangle_pattern, r26
00218d 93b0 28c1                 	sts triangle_pattern+1, r27
                                 
00218f 9220 28c4                 	sts triangle_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
002191 9220 28c5                 	sts triangle_pattern_offset+1, zero
002193 cd59                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_increment_offset:
002194 91e0 28c4                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
002196 91f0 28c5                 	lds ZH, triangle_pattern_offset+1
002198 9631                      	adiw Z, 1
002199 93e0 28c4                 	sts triangle_pattern_offset, ZL
00219b 93f0 28c5                 	sts triangle_pattern_offset+1, ZH
00219d 9508                      	ret
                                 
                                 sound_driver_channel2_increment_offset_twice: //used for data that takes up 2 bytes worth of space
00219e 91e0 28c4                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
0021a0 91f0 28c5                 	lds ZH, triangle_pattern_offset+1
0021a2 9632                      	adiw Z, 2 //increment the pointer twice
0021a3 93e0 28c4                 	sts triangle_pattern_offset, ZL
0021a5 93f0 28c5                 	sts triangle_pattern_offset+1, ZH
0021a7 9508                      	ret
                                 
                                 sound_driver_channel2_decrement_frame_delay:
0021a8 95ba                      	dec r27
0021a9 93b0 28c3                 	sts triangle_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel3:
0021ab 91a0 290c                 	lds r26, noise_pattern_delay_rows
0021ad 91b0 290d                 	lds r27, noise_pattern_delay_frames
0021af 9610                      	adiw r27:r26, 0
0021b0 f009                      	breq sound_driver_channel3_main //if the pattern delay is 0, proceed with sound driver procedures
0021b1 c2c9                      	rjmp sound_driver_channel3_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel3_main:
0021b2 91e0 290a                 	lds ZL, noise_pattern //current pattern for noise
0021b4 91f0 290b                 	lds ZH, noise_pattern+1
0021b6 91a0 290e                 	lds r26, noise_pattern_offset //current offset in the pattern for noise
0021b8 91b0 290f                 	lds r27, noise_pattern_offset+1
0021ba 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
0021bb 1ffb                      	adc ZH, r27
0021bc 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel3_check_if_note: //check if data is a note (0x00 - 0x56)
0021bd 35b7                      	cpi r27, 0x57
0021be f408                      	brsh sound_driver_channel3_check_if_volume
0021bf c172                      	rjmp sound_driver_channel3_note
                                 sound_driver_channel3_check_if_volume: //check if data is volume (0x57-0x66)
0021c0 36b7                      	cpi r27, 0x67
0021c1 f408                      	brsh sound_driver_channel3_check_if_delay
0021c2 c1a9                      	rjmp sound_driver_channel3_volume
                                 sound_driver_channel3_check_if_delay: //check if data is a delay (0x67 - 0xE2)
0021c3 3eb3                      	cpi r27, 0xE3
0021c4 f408                      	brsh sound_driver_channel3_check_if_instrument
0021c5 c1af                      	rjmp sound_driver_channel3_delay
                                 sound_driver_channel3_check_if_instrument: //check for instrument flag (0xE3)
0021c6 f409                      	brne sound_driver_channel3_check_if_release
0021c7 c1b2                      	rjmp sound_driver_channel3_instrument_change 
                                 sound_driver_channel3_check_if_release: //check for note release flag (0xE4)
0021c8 3eb4                      	cpi r27, 0xE4
0021c9 f409                      	brne sound_driver_channel3_check_if_end
0021ca c25b                      	rjmp sound_driver_channel3_release
                                 sound_driver_channel3_check_if_end:
0021cb 3fbf                      	cpi r27, 0xFF
0021cc f409                      	brne sound_driver_channel3_check_if_fx
0021cd c27d                      	rjmp sound_driver_channel3_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel3_check_if_fx: //fx flags (0xE5 - 0xFE)
0021ce 9631                      	adiw Z, 1 //point Z to the byte next to the flag
0021cf 91a4                      	lpm r26, Z //load the fx data into r26
0021d0 d2a0                      	rcall sound_driver_channel3_increment_offset_twice
                                 
0021d1 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
0021d2 e3e6                      	ldi ZL, LOW(channel3_fx << 1) //load in note table
0021d3 e6f5                      	ldi ZH, HIGH(channel3_fx << 1)
0021d4 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
0021d5 0feb                      	add ZL, r27 //add offset
0021d6 1df2                      	adc ZH, zero
0021d7 91c5                      	lpm r28, Z+ //load address bytes
0021d8 91d4                      	lpm r29, Z
0021d9 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
0021da 2ffd                      	mov ZH, r29
0021db 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel3_fx_0xy:
0021dc 93a0 292d                 	sts noise_fx_0xy_sequence, r26
0021de 9220 292e                 	sts noise_fx_0xy_sequence+1, zero
0021e0 cfd1                      	rjmp sound_driver_channel3_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel3_fx_1xx:
0021e1 9220 2933                 	sts noise_fx_2xx, zero //turn off any 2xx pitch slide down
0021e3 9220 2934                 	sts noise_fx_2xx+1, zero
0021e5 9220 292d                 	sts noise_fx_0xy_sequence, zero //disable any 0xy effect
0021e7 9220 292e                 	sts noise_fx_0xy_sequence+1, zero
0021e9 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0021ea 937f                      	push r23
0021eb 2f6a                      	mov r22, r26 //store the rate into r22
0021ec eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0021ed 9f67                      	mul r22, r23
0021ee 917f                      	pop r23
0021ef 916f                      	pop r22
                                 
0021f0 9416                      	lsr r1 //shift out the fractional bits
0021f1 9407                      	ror r0
0021f2 9416                      	lsr r1
0021f3 9407                      	ror r0
0021f4 9416                      	lsr r1
0021f5 9407                      	ror r0
0021f6 9416                      	lsr r1
0021f7 9407                      	ror r0
0021f8 9200 292f                 	sts noise_fx_1xx, r0
0021fa 9210 2930                 	sts noise_fx_1xx+1, r1
0021fc cfb5                      	rjmp sound_driver_channel3_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel3_fx_2xx:
0021fd 9220 292f                 	sts noise_fx_1xx, zero //turn off any 1xx pitch slide down
0021ff 9220 2930                 	sts noise_fx_1xx+1, zero
002201 9220 292d                 	sts noise_fx_0xy_sequence, zero //disable any 0xy effect
002203 9220 292e                 	sts noise_fx_0xy_sequence+1, zero
002205 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002206 937f                      	push r23
002207 2f6a                      	mov r22, r26 //store the rate into r22
002208 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002209 9f67                      	mul r22, r23
00220a 917f                      	pop r23
00220b 916f                      	pop r22
                                 
00220c 9416                      	lsr r1 //shift out the fractional bits
00220d 9407                      	ror r0
00220e 9416                      	lsr r1
00220f 9407                      	ror r0
002210 9416                      	lsr r1
002211 9407                      	ror r0
002212 9416                      	lsr r1
002213 9407                      	ror r0
002214 9200 2933                 	sts noise_fx_2xx, r0
002216 9210 2934                 	sts noise_fx_2xx+1, r1
002218 cf99                      	rjmp sound_driver_channel3_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel3_fx_3xx:
002219 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00221a 937f                      	push r23
00221b 2f6a                      	mov r22, r26 //store the rate into r22
00221c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00221d 9f67                      	mul r22, r23
00221e 917f                      	pop r23
00221f 916f                      	pop r22
                                 
002220 9416                      	lsr r1 //shift out the fractional bits
002221 9407                      	ror r0
002222 9416                      	lsr r1
002223 9407                      	ror r0
002224 9416                      	lsr r1
002225 9407                      	ror r0
002226 9416                      	lsr r1
002227 9407                      	ror r0
002228 9200 293b                 	sts noise_fx_3xx_speed, r0
00222a 9210 293c                 	sts noise_fx_3xx_speed+1, r1
                                 
00222c 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
00222d c001                      	rjmp sound_driver_channel3_fx_3xx_enabled
00222e cf83                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_3xx_enabled:
00222f 91a0 0abc                 	lds r26, TCB3_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
002231 91b0 0abd                 	lds r27, TCB3_CCMPH
002233 93a0 2937                 	sts noise_fx_3xx_start, r26
002235 93b0 2938                 	sts noise_fx_3xx_start+1, r27
                                 
002237 9220 293d                 	sts noise_fx_3xx_total_offset, zero
002239 9220 293e                 	sts noise_fx_3xx_total_offset+1, zero
00223b cf76                      	rjmp sound_driver_channel3_main
                                 
                                 //VIBRATO
                                 sound_driver_channel3_fx_4xy:
00223c 2fba                      	mov r27, r26
00223d 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
00223e 95a2                      	swap r26
00223f 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
002240 93a0 293f                 	sts noise_fx_4xy_speed, r26
002242 93b0 2940                 	sts noise_fx_4xy_depth, r27
002244 9220 2941                 	sts noise_fx_4xy_phase, zero //reset the phase to 0
002246 cf6b                      	rjmp sound_driver_channel3_main
                                 
                                 //TREMELO
                                 sound_driver_channel3_fx_7xy:
002247 2fba                      	mov r27, r26
002248 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
002249 95a2                      	swap r26
00224a 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
00224b 93a0 2942                 	sts noise_fx_7xy_speed, r26
00224d 93b0 2943                 	sts noise_fx_7xy_depth, r27
00224f 9220 2944                 	sts noise_fx_7xy_phase, zero //reset the phase to 0
002251 9220 2945                 	sts noise_fx_7xy_value, zero //reset the tremelo value
002253 cf5e                      	rjmp sound_driver_channel3_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel3_fx_Axy:
002254 93a0 2946                 	sts noise_fx_Axy, r26
002256 cf5b                      	rjmp sound_driver_channel3_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel3_fx_Bxx:
002257 93a0 281f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
002259 cf58                      	rjmp sound_driver_channel3_main
                                 
                                 //HALT
                                 sound_driver_channel3_fx_Cxx:
00225a 93b0 2820                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
00225c cf55                      	rjmp sound_driver_channel3_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel3_fx_Dxx:
00225d 93b0 2821                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
00225f cf52                      	rjmp sound_driver_channel3_main
                                 
                                 //VOLUME
                                 sound_driver_channel3_fx_Exx:
002260 91b0 2813                 	lds r27, noise_param
002262 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
002263 2bba                      	or r27, r26 //move new VVVV bits into noise_param
002264 93b0 2813                 	sts noise_param, r27
002266 cf4b                      	rjmp sound_driver_channel3_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel3_fx_Fxx:
002267 93a0 281e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
002269 cf48                      	rjmp sound_driver_channel3_main
                                 
                                 //DELAY
                                 sound_driver_channel3_fx_Gxx:
00226a 15a2                      	cp r26, zero
00226b f051                      	breq sound_driver_channel3_fx_Gxx_invalid
00226c 91b0 281e                 	lds r27, song_speed
00226e 17ab                      	cp r26, r27
00226f f430                      	brsh sound_driver_channel3_fx_Gxx_invalid
002270 93a0 2947                 	sts noise_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
002272 e0b1                      	ldi r27, 0x01
002273 93b0 290c                 	sts noise_pattern_delay_rows, r27
002275 c208                      	rjmp sound_driver_channel4
                                 sound_driver_channel3_fx_Gxx_invalid:
002276 cf3b                      	rjmp sound_driver_channel3_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel3_fx_Hxy: //hardware sweep up
002277 cf3a                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Ixy: //hardware sweep down
002278 cf39                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Hxx: //FDS modulation depth
002279 cf38                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Ixx: //FDS modulation speed
00227a cf37                      	rjmp sound_driver_channel3_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel3_fx_Pxx:
00227b 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00227c 937f                      	push r23
00227d 2f6a                      	mov r22, r26
00227e eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00227f 0367                      	mulsu r22, r23
002280 917f                      	pop r23
002281 916f                      	pop r22
002282 9416                      	lsr r1 //shift out the fractional bits
002283 9407                      	ror r0
002284 9416                      	lsr r1
002285 9407                      	ror r0
002286 9416                      	lsr r1
002287 9407                      	ror r0
002288 9416                      	lsr r1
002289 9407                      	ror r0
00228a 9200 2949                 	sts noise_fx_Pxx_total, r0
00228c 9210 294a                 	sts noise_fx_Pxx_total+1, r1
00228e cf23                      	rjmp sound_driver_channel3_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel3_fx_Qxy:
                                 sound_driver_channel3_fx_Qxy_check_arpeggio_macro:
00228f 91e0 2915                 	lds ZL, noise_arpeggio_macro
002291 91f0 2916                 	lds ZH, noise_arpeggio_macro+1
002293 9630                      	adiw Z, 0
002294 f009                      	breq sound_driver_channel3_fx_Qxy_check_pitch_macro
002295 cf1c                      	rjmp sound_driver_channel3_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Qxy_check_pitch_macro:
002296 91e0 291d                 	lds ZL, noise_pitch_macro
002298 91f0 291e                 	lds ZH, noise_pitch_macro+1
00229a 9630                      	adiw Z, 0
00229b f009                      	breq sound_driver_channel3_fx_Qxy_check_hi_pitch_macro
00229c cf15                      	rjmp sound_driver_channel3_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Qxy_check_hi_pitch_macro:
00229d 91e0 2923                 	lds ZL, noise_hi_pitch_macro
00229f 91f0 2924                 	lds ZH, noise_hi_pitch_macro+1
0022a1 9630                      	adiw Z, 0
0022a2 f009                      	breq sound_driver_channel3_fx_Qxy_process
0022a3 cf0e                      	rjmp sound_driver_channel3_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Qxy_process:
0022a4 2fba                      	mov r27, r26 //copy fx parameters into r27
0022a5 70bf                      	andi r27, 0x0F //mask note index offset
0022a6 91c0 2817                 	lds r28, noise_note //load current note index
0022a8 0fbc                      	add r27, r28
0022a9 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
0022aa f008                      	brlo sound_driver_channel3_fx_Qxy_process_continue
0022ab e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel3_fx_Qxy_process_continue:
0022ac e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0022ad e0f0                      	ldi ZH, HIGH(note_table << 1)
0022ae 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
0022af 0feb                      	add ZL, r27 //add offset
0022b0 1df2                      	adc ZH, zero
0022b1 91c5                      	lpm r28, Z+ //load bytes
0022b2 91d4                      	lpm r29, Z
0022b3 93c0 294b                 	sts noise_fx_Qxy_target, r28 //load the LOW bits for the target period
0022b5 93d0 294c                 	sts noise_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
0022b7 95a2                      	swap r26
0022b8 70af                      	andi r26, 0x0F //mask effect speed
0022b9 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0022ba 95a3                      	inc r26 //increment the speed by 1
                                 
0022bb 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0022bc 937f                      	push r23
0022bd 2f6a                      	mov r22, r26 //store the speed data into r27
0022be eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0022bf 9f67                      	mul r22, r23
0022c0 917f                      	pop r23
0022c1 916f                      	pop r22
                                 
0022c2 9416                      	lsr r1 //shift out the fractional bits
0022c3 9407                      	ror r0
0022c4 9416                      	lsr r1
0022c5 9407                      	ror r0
0022c6 9416                      	lsr r1
0022c7 9407                      	ror r0
0022c8 9416                      	lsr r1
0022c9 9407                      	ror r0
                                 
0022ca 9200 294d                 	sts noise_fx_Qxy_speed, r0 //store the effect speed
0022cc 9210 294e                 	sts noise_fx_Qxy_speed+1, r1
0022ce 9220 294f                 	sts noise_fx_Qxy_total_offset, zero
0022d0 9220 2950                 	sts noise_fx_Qxy_total_offset+1, zero
0022d2 cedf                      	rjmp sound_driver_channel3_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel3_fx_Rxy:
                                 sound_driver_channel3_fx_Rxy_check_arpeggio_macro:
0022d3 91e0 2915                 	lds ZL, noise_arpeggio_macro
0022d5 91f0 2916                 	lds ZH, noise_arpeggio_macro+1
0022d7 9630                      	adiw Z, 0
0022d8 f009                      	breq sound_driver_channel3_fx_Rxy_check_pitch_macro
0022d9 ced8                      	rjmp sound_driver_channel3_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Rxy_check_pitch_macro:
0022da 91e0 291d                 	lds ZL, noise_pitch_macro
0022dc 91f0 291e                 	lds ZH, noise_pitch_macro+1
0022de 9630                      	adiw Z, 0
0022df f009                      	breq sound_driver_channel3_fx_Rxy_check_hi_pitch_macro
0022e0 ced1                      	rjmp sound_driver_channel3_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Rxy_check_hi_pitch_macro:
0022e1 91e0 2923                 	lds ZL, noise_hi_pitch_macro
0022e3 91f0 2924                 	lds ZH, noise_hi_pitch_macro+1
0022e5 9630                      	adiw Z, 0
0022e6 f009                      	breq sound_driver_channel3_fx_Rxy_process
0022e7 ceca                      	rjmp sound_driver_channel3_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Rxy_process:
0022e8 2fba                      	mov r27, r26 //copy fx parameters into r27
0022e9 70bf                      	andi r27, 0x0F //mask note index offset
0022ea 91c0 2817                 	lds r28, noise_note //load current note index
0022ec 1bcb                      	sub r28, r27
0022ed f408                      	brcc sound_driver_channel3_fx_Rxy_process_continue
0022ee e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel3_fx_Rxy_process_continue:
0022ef e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0022f0 e0f0                      	ldi ZH, HIGH(note_table << 1)
0022f1 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
0022f2 0fec                      	add ZL, r28 //add offset
0022f3 1df2                      	adc ZH, zero
0022f4 91c5                      	lpm r28, Z+ //load bytes
0022f5 91d4                      	lpm r29, Z
0022f6 93c0 2951                 	sts noise_fx_Rxy_target, r28 //load the LOW bits for the target period
0022f8 93d0 2952                 	sts noise_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
0022fa 95a2                      	swap r26
0022fb 70af                      	andi r26, 0x0F //mask effect speed
0022fc 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0022fd 95a3                      	inc r26 //increment the speed by 1
                                 
0022fe 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0022ff 937f                      	push r23
002300 2f6a                      	mov r22, r26 //store the speed data into r27
002301 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002302 9f67                      	mul r22, r23
002303 917f                      	pop r23
002304 916f                      	pop r22
                                 
002305 9416                      	lsr r1 //shift out the fractional bits
002306 9407                      	ror r0
002307 9416                      	lsr r1
002308 9407                      	ror r0
002309 9416                      	lsr r1
00230a 9407                      	ror r0
00230b 9416                      	lsr r1
00230c 9407                      	ror r0
                                 
00230d 9200 2953                 	sts noise_fx_Rxy_speed, r0 //store the effect speed
00230f 9210 2954                 	sts noise_fx_Rxy_speed+1, r1
002311 9220 2955                 	sts noise_fx_Rxy_total_offset, zero
002313 9220 2956                 	sts noise_fx_Rxy_total_offset+1, zero
002315 ce9c                      	rjmp sound_driver_channel3_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel3_fx_Sxx:
002316 15a2                      	cp r26, zero
002317 f051                      	breq sound_driver_channel3_fx_Sxx_invalid
002318 91b0 281e                 	lds r27, song_speed
00231a 17ab                      	cp r26, r27
00231b f430                      	brsh sound_driver_channel3_fx_Sxx_invalid
00231c 93a0 2957                 	sts noise_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
00231e e0b1                      	ldi r27, 0x01
00231f 93b0 290c                 	sts noise_pattern_delay_rows, r27
002321 c15c                      	rjmp sound_driver_channel4
                                 sound_driver_channel3_fx_Sxx_invalid:
002322 ce8f                      	rjmp sound_driver_channel3_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel3_fx_Vxx:
002323 95a6                      	lsr r26
002324 95a7                      	ror r26 //move mode bit to bit 7
002325 91b0 2814                 	lds r27, noise_period
002327 77bf                      	andi r27, 0b01111111
002328 2bba                      	or r27, r26 //store the new noise mode
002329 93b0 2813                 	sts noise_param, r27
                                 
00232b 776f                      	andi noise_sequence_HIGH, 0b01111111
00232c 2b6a                      	or noise_sequence_HIGH, r26
00232d ce84                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_Wxx: //DPCM sample speed
00232e ce83                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Xxx: //DPCM sample retrigger
00232f ce82                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Yxx: //DPCM sample offset
002330 ce81                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Zxx: //DPCM sample delta counter
002331 ce80                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 sound_driver_channel3_note:
002332 93b0 2817                 	sts noise_note, r27 //store the note index
002334 e0a3                      	ldi r26, 0x03
002335 e0b2                      	ldi r27, 0x02
002336 93b0 2912                 	sts noise_volume_macro_offset, r27 //reset all macro offsets
002338 93a0 2917                 	sts noise_arpeggio_macro_offset, r26
00233a 93b0 291f                 	sts noise_pitch_macro_offset, r27
00233c 93b0 2925                 	sts noise_hi_pitch_macro_offset, r27
00233e 93b0 292a                 	sts noise_duty_macro_offset, r27
002340 9220 291b                 	sts noise_total_pitch_offset, zero //reset the pitch and hi pitch offset
002342 9220 291c                 	sts noise_total_pitch_offset+1, zero
002344 9220 2922                 	sts noise_total_hi_pitch_offset, zero
002346 9220 2931                 	sts noise_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
002348 9220 2932                 	sts noise_fx_1xx_total+1, zero
00234a 9220 2935                 	sts noise_fx_2xx_total, zero
00234c 9220 2936                 	sts noise_fx_2xx_total+1, zero
00234e 9220 293d                 	sts noise_fx_3xx_total_offset, zero //reset 3xx offset
002350 9220 293e                 	sts noise_fx_3xx_total_offset+1, zero
002352 91a0 0abc                 	lds r26, TCB3_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
002354 91b0 0abd                 	lds r27, TCB3_CCMPH
002356 93a0 2937                 	sts noise_fx_3xx_start, r26
002358 93b0 2938                 	sts noise_fx_3xx_start+1, r27
00235a 9220 294b                 	sts noise_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00235c 9220 294c                 	sts noise_fx_Qxy_target+1, zero
00235e 9220 294f                 	sts noise_fx_Qxy_total_offset, zero
002360 9220 2950                 	sts noise_fx_Qxy_total_offset+1, zero
002362 9220 2951                 	sts noise_fx_Rxy_target, zero
002364 9220 2952                 	sts noise_fx_Rxy_target+1, zero
002366 9220 2955                 	sts noise_fx_Rxy_total_offset, zero
002368 9220 2956                 	sts noise_fx_Rxy_total_offset+1, zero
00236a d0fc                      	rcall sound_driver_channel3_increment_offset
00236b ce46                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_volume:
00236c 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
00236d 91a0 2813                 	lds r26, noise_param
00236f 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
002370 2bab                      	or r26, r27 //move new VVVV bits into noise_param
002371 93a0 2813                 	sts noise_param, r26
002373 d0f3                      	rcall sound_driver_channel3_increment_offset
002374 ce3d                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_delay:
002375 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
002376 93b0 290c                 	sts noise_pattern_delay_rows, r27
002378 d0ee                      	rcall sound_driver_channel3_increment_offset
002379 c104                      	rjmp sound_driver_channel4
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change:
00237a 9220 2910                 	sts noise_volume_macro, zero //reset all macro addresses
00237c 9220 2911                 	sts noise_volume_macro+1, zero
00237e 9220 2915                 	sts noise_arpeggio_macro, zero
002380 9220 2916                 	sts noise_arpeggio_macro+1, zero
002382 9220 291d                 	sts noise_pitch_macro, zero
002384 9220 291e                 	sts noise_pitch_macro+1, zero
002386 9220 2923                 	sts noise_hi_pitch_macro, zero
002388 9220 2924                 	sts noise_hi_pitch_macro+1, zero
00238a 9220 2928                 	sts noise_duty_macro, zero
00238c 9220 2929                 	sts noise_duty_macro+1, zero
00238e 9220 291b                 	sts noise_total_pitch_offset, zero //reset the pitch offset
002390 9220 291c                 	sts noise_total_pitch_offset+1, zero
002392 9220 2922                 	sts noise_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
002394 9631                      	adiw Z, 1 //point to the byte next to the flag
002395 91b4                      	lpm r27, Z //store the instrument offset into r27
002396 e3eb                      	ldi ZL, LOW(instruments) //point Z to instruments table
002397 e1f1                      	ldi ZH, HIGH(instruments)
002398 0feb                      	add ZL, r27 //point Z to offsetted instrument
002399 1df2                      	adc ZH, zero
00239a 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
00239b 1fff                      	rol ZH
00239c 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
00239d 91b4                      	lpm r27, Z
                                 
00239e 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
00239f 1fbb                      	rol r27
0023a0 2fea                      	mov ZL, r26
0023a1 2ffb                      	mov ZH, r27
0023a2 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
0023a3 9632                      	adiw Z, 2 //point Z to the address of the macro
0023a4 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel3_instrument_change_macro_loop:
0023a5 95aa                      	dec r26
0023a6 f019                      	breq sound_driver_channel3_instrument_change_exit
0023a7 95b6                      	lsr r27
0023a8 f078                      	brcs sound_driver_channel3_instrument_change_load_macro
0023a9 cffb                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_exit:
0023aa e0a3                      	ldi r26, 0x03
0023ab e0b2                      	ldi r27, 0x02
0023ac 93b0 2912                 	sts noise_volume_macro_offset, r27 //reset all macro offsets
0023ae 93a0 2917                 	sts noise_arpeggio_macro_offset, r26
0023b0 93b0 291f                 	sts noise_pitch_macro_offset, r27
0023b2 93b0 2925                 	sts noise_hi_pitch_macro_offset, r27
0023b4 93b0 292a                 	sts noise_duty_macro_offset, r27
0023b6 d0ba                      	rcall sound_driver_channel3_increment_offset_twice
0023b7 cdfa                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_load_macro:
0023b8 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
0023b9 91d5                      	lpm r29, Z+
                                 
0023ba 30a5                      	cpi r26, 5
0023bb f039                      	breq sound_driver_channel3_instrument_change_load_macro_volume
0023bc 30a4                      	cpi r26, 4
0023bd f079                      	breq sound_driver_channel3_instrument_change_load_macro_arpeggio
0023be 30a3                      	cpi r26, 3
0023bf f0d9                      	breq sound_driver_channel3_instrument_change_load_macro_pitch
0023c0 30a2                      	cpi r26, 2
0023c1 f159                      	breq sound_driver_channel3_instrument_change_load_macro_hi_pitch
0023c2 c03c                      	rjmp sound_driver_channel3_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel3_instrument_change_load_macro_volume:
0023c3 93c0 2910                 	sts noise_volume_macro, r28
0023c5 93d0 2911                 	sts noise_volume_macro+1, r29
0023c7 d041                      	rcall sound_driver_channel3_instrument_change_read_header
0023c8 93c0 2914                 	sts noise_volume_macro_release, r28
0023ca 93d0 2913                 	sts noise_volume_macro_loop, r29
0023cc cfd8                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 	
                                 sound_driver_channel3_instrument_change_load_macro_arpeggio:
0023cd 93c0 2915                 	sts noise_arpeggio_macro, r28
0023cf 93d0 2916                 	sts noise_arpeggio_macro+1, r29
0023d1 9220 294b                 	sts noise_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0023d3 9220 294c                 	sts noise_fx_Qxy_target+1, zero
0023d5 9220 2951                 	sts noise_fx_Rxy_target, zero
0023d7 9220 2952                 	sts noise_fx_Rxy_target+1, zero
0023d9 d03a                      	rcall sound_driver_channel3_instrument_change_read_header_arpeggio
0023da cfca                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_pitch:
0023db 93c0 291d                 	sts noise_pitch_macro, r28
0023dd 93d0 291e                 	sts noise_pitch_macro+1, r29
0023df 9220 294b                 	sts noise_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0023e1 9220 294c                 	sts noise_fx_Qxy_target+1, zero
0023e3 9220 2951                 	sts noise_fx_Rxy_target, zero
0023e5 9220 2952                 	sts noise_fx_Rxy_target+1, zero
0023e7 d021                      	rcall sound_driver_channel3_instrument_change_read_header
0023e8 93c0 2921                 	sts noise_pitch_macro_release, r28
0023ea 93d0 2920                 	sts noise_pitch_macro_loop, r29
0023ec cfb8                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_hi_pitch:
0023ed 93c0 2923                 	sts noise_hi_pitch_macro, r28
0023ef 93d0 2924                 	sts noise_hi_pitch_macro+1, r29
0023f1 9220 294b                 	sts noise_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0023f3 9220 294c                 	sts noise_fx_Qxy_target+1, zero
0023f5 9220 2951                 	sts noise_fx_Rxy_target, zero
0023f7 9220 2952                 	sts noise_fx_Rxy_target+1, zero
0023f9 d00f                      	rcall sound_driver_channel3_instrument_change_read_header
0023fa 93c0 2927                 	sts noise_hi_pitch_macro_release, r28
0023fc 93d0 2926                 	sts noise_hi_pitch_macro_loop, r29
0023fe cfa6                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_duty:
0023ff 93c0 2928                 	sts noise_duty_macro, r28
002401 93d0 2929                 	sts noise_duty_macro+1, r29
002403 d005                      	rcall sound_driver_channel3_instrument_change_read_header
002404 93c0 292c                 	sts noise_duty_macro_release, r28
002406 93d0 292b                 	sts noise_duty_macro_loop, r29
002408 cf9c                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_read_header:
002409 93ef                      	push ZL
00240a 93ff                      	push ZH
00240b 2fec                      	mov ZL, r28
00240c 2ffd                      	mov ZH, r29
00240d 0fee                      	lsl ZL
00240e 1fff                      	rol ZH
00240f 91c5                      	lpm r28, Z+
002410 91d4                      	lpm r29, Z
002411 91ff                      	pop ZH
002412 91ef                      	pop ZL
002413 9508                      	ret
                                 
                                 sound_driver_channel3_instrument_change_read_header_arpeggio:
002414 93ef                      	push ZL
002415 93ff                      	push ZH
002416 2fec                      	mov ZL, r28
002417 2ffd                      	mov ZH, r29
002418 0fee                      	lsl ZL
002419 1fff                      	rol ZH
00241a 91c5                      	lpm r28, Z+
00241b 91d5                      	lpm r29, Z+
00241c 93c0 2919                 	sts noise_arpeggio_macro_release, r28
00241e 93d0 2918                 	sts noise_arpeggio_macro_loop, r29
002420 91c4                      	lpm r28, Z
002421 93c0 291a                 	sts noise_arpeggio_macro_mode, r28
002423 91ff                      	pop ZH
002424 91ef                      	pop ZL
002425 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel3_release:
                                 sound_driver_channel3_release_volume:
002426 91b0 2914                 	lds r27, noise_volume_macro_release
002428 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
002429 f019                      	breq sound_driver_channel3_release_arpeggio //if the macro has no release flag, check the next macro
00242a 95b3                      	inc r27
00242b 93b0 2912                 	sts noise_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel3_release_arpeggio:
00242d 91b0 2919                 	lds r27, noise_arpeggio_macro_release
00242f 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
002430 f019                      	breq sound_driver_channel3_release_pitch
002431 95b3                      	inc r27
002432 93b0 2917                 	sts noise_arpeggio_macro_offset, r27
                                 sound_driver_channel3_release_pitch:
002434 91b0 2921                 	lds r27, noise_pitch_macro_release
002436 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
002437 f019                      	breq sound_driver_channel3_release_hi_pitch
002438 95b3                      	inc r27
002439 93b0 291f                 	sts noise_pitch_macro_offset, r27
                                 sound_driver_channel3_release_hi_pitch:
00243b 91b0 2927                 	lds r27, noise_hi_pitch_macro_release
00243d 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
00243e f019                      	breq sound_driver_channel3_release_duty
00243f 95b3                      	inc r27
002440 93b0 2925                 	sts noise_hi_pitch_macro_offset, r27
                                 sound_driver_channel3_release_duty:
002442 91b0 292c                 	lds r27, noise_duty_macro_release
002444 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
002445 f019                      	breq sound_driver_channel3_release_exit
002446 95b3                      	inc r27
002447 93b0 292a                 	sts noise_duty_macro_offset, r27
                                 sound_driver_channel3_release_exit:
002449 d01d                      	rcall sound_driver_channel3_increment_offset
00244a cd67                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_next_pattern:
00244b 91e0 2818                 	lds ZL, song_frames
00244d 91f0 2819                 	lds ZH, song_frames+1
00244f 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
002451 91b0 281b                 	lds r27, song_frame_offset+1
002453 93a0 281a                 	sts song_frame_offset, r26
002455 93b0 281b                 	sts song_frame_offset+1, r27
002457 9616                      	adiw r27:r26, 6 //offset for channel 3
002458 0fea                      	add ZL, r26
002459 1ffb                      	adc ZH, r27
                                 
00245a 91a5                      	lpm r26, Z+ //load the address of the next pattern
00245b 91b4                      	lpm r27, Z
00245c 0faa                      	lsl r26
00245d 1fbb                      	rol r27
00245e 93a0 290a                 	sts noise_pattern, r26
002460 93b0 290b                 	sts noise_pattern+1, r27
                                 
002462 9220 290e                 	sts noise_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
002464 9220 290f                 	sts noise_pattern_offset+1, zero
002466 cd4b                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_increment_offset:
002467 91e0 290e                 	lds ZL, noise_pattern_offset //current offset in the pattern for noise
002469 91f0 290f                 	lds ZH, noise_pattern_offset+1
00246b 9631                      	adiw Z, 1
00246c 93e0 290e                 	sts noise_pattern_offset, ZL
00246e 93f0 290f                 	sts noise_pattern_offset+1, ZH
002470 9508                      	ret
                                 
                                 sound_driver_channel3_increment_offset_twice: //used for data that takes up 2 bytes worth of space
002471 91e0 290e                 	lds ZL, noise_pattern_offset //current offset in the pattern for noise
002473 91f0 290f                 	lds ZH, noise_pattern_offset+1
002475 9632                      	adiw Z, 2 //increment the pointer twice
002476 93e0 290e                 	sts noise_pattern_offset, ZL
002478 93f0 290f                 	sts noise_pattern_offset+1, ZH
00247a 9508                      	ret
                                 
                                 sound_driver_channel3_decrement_frame_delay:
00247b 95ba                      	dec r27
00247c 93b0 290d                 	sts noise_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel4:
                                 
                                 sound_driver_calculate_delays:
00247e 91f0 281e                 	lds r31, song_speed
002480 2fef                      	mov r30, r31
002481 50e1                      	subi r30, 1
                                 sound_driver_calculate_delays_pulse1:
002482 91a0 2825                 	lds r26, pulse1_pattern_delay_frames
002484 11a2                      	cpse r26, zero
002485 c042                      	rjmp sound_driver_calculate_delays_pulse2
002486 c000                      	rjmp sound_driver_calculate_delays_pulse1_main
                                 
                                 sound_driver_calculate_delays_pulse1_main:
002487 2faf                      	mov r26, r31 //move the speed to r26
002488 91b0 2824                 	lds r27, pulse1_pattern_delay_rows //decrement the delay rows
00248a 15b2                      	cp r27, zero
00248b f409                      	brne PC+2
00248c c03b                      	rjmp sound_driver_calculate_delays_pulse2
00248d 95ba                      	dec r27
00248e 93b0 2824                 	sts pulse1_pattern_delay_rows, r27
002490 11b2                      	cpse r27, zero
002491 c034                      	rjmp sound_driver_calculate_delays_pulse1_store
002492 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx:
002493 efbf                      	ldi r27, 0xFF
002494 91c0 286f                 	lds r28, pulse1_fx_Sxx_pre
002496 91d0 2870                 	lds r29, pulse1_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse1_Sxx_check_pre:
002498 17cb                      	cp r28, r27
002499 f009                      	breq sound_driver_calculate_delays_pulse1_Sxx_check_post
00249a c00d                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_pre
                                 sound_driver_calculate_delays_pulse1_Sxx_check_post:
00249b 17db                      	cp r29, r27
00249c f009                      	breq sound_driver_calculate_delays_pulse1_Gxx
00249d c015                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx:
00249e 91c0 285f                 	lds r28, pulse1_fx_Gxx_pre
0024a0 91d0 2860                 	lds r29, pulse1_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse1_Gxx_check_pre:
0024a2 17cb                      	cp r28, r27
0024a3 f009                      	breq sound_driver_calculate_delays_pulse1_Gxx_check_post
0024a4 c012                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_pre
                                 sound_driver_calculate_delays_pulse1_Gxx_check_post:
0024a5 17db                      	cp r29, r27
0024a6 f0f9                      	breq sound_driver_calculate_delays_pulse1_store
0024a7 c01a                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_pre:
0024a8 93b0 286f                 	sts pulse1_fx_Sxx_pre, r27
0024aa 1bec                      	sub r30, r28 //(song speed)-1-Sxx
0024ab 93e0 2870                 	sts pulse1_fx_Sxx_post, r30
0024ad 95ca                      	dec r28
0024ae 93c0 2825                 	sts pulse1_pattern_delay_frames, r28
0024b0 2fef                      	mov r30, r31
0024b1 50e1                      	subi r30, 1
0024b2 c015                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_post:
0024b3 93b0 2870                 	sts pulse1_fx_Sxx_post, r27
0024b5 2fad                      	mov r26, r29
0024b6 c00f                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx_pre:
0024b7 93b0 285f                 	sts pulse1_fx_Gxx_pre, r27
0024b9 1bec                      	sub r30, r28 //(song speed)-1-Sxx
0024ba 93e0 2860                 	sts pulse1_fx_Gxx_post, r30
0024bc 95ca                      	dec r28
0024bd 93c0 2825                 	sts pulse1_pattern_delay_frames, r28
0024bf 2fef                      	mov r30, r31
0024c0 50e1                      	subi r30, 1
0024c1 c006                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse1_Gxx_post:
0024c2 93b0 2860                 	sts pulse1_fx_Gxx_post, r27
0024c4 2fad                      	mov r26, r29
0024c5 c000                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_store:
0024c6 93a0 2825                 	sts pulse1_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_pulse2:
0024c8 91a0 2874                 	lds r26, pulse2_pattern_delay_frames
0024ca 11a2                      	cpse r26, zero
0024cb c042                      	rjmp sound_driver_calculate_delays_triangle
0024cc c000                      	rjmp sound_driver_calculate_delays_pulse2_main
                                 
                                 sound_driver_calculate_delays_pulse2_main:
0024cd 2faf                      	mov r26, r31 //move the speed to r26
0024ce 91b0 2873                 	lds r27, pulse2_pattern_delay_rows //decrement the delay rows
0024d0 15b2                      	cp r27, zero
0024d1 f409                      	brne PC+2
0024d2 c03b                      	rjmp sound_driver_calculate_delays_triangle
0024d3 95ba                      	dec r27
0024d4 93b0 2873                 	sts pulse2_pattern_delay_rows, r27
0024d6 11b2                      	cpse r27, zero
0024d7 c034                      	rjmp sound_driver_calculate_delays_pulse2_store
0024d8 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx:
0024d9 efbf                      	ldi r27, 0xFF
0024da 91c0 28be                 	lds r28, pulse2_fx_Sxx_pre
0024dc 91d0 28bf                 	lds r29, pulse2_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse2_Sxx_check_pre:
0024de 17cb                      	cp r28, r27
0024df f009                      	breq sound_driver_calculate_delays_pulse2_Sxx_check_post
0024e0 c00d                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_pre
                                 sound_driver_calculate_delays_pulse2_Sxx_check_post:
0024e1 17db                      	cp r29, r27
0024e2 f009                      	breq sound_driver_calculate_delays_pulse2_Gxx
0024e3 c015                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx:
0024e4 91c0 28ae                 	lds r28, pulse2_fx_Gxx_pre
0024e6 91d0 28af                 	lds r29, pulse2_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse2_Gxx_check_pre:
0024e8 17cb                      	cp r28, r27
0024e9 f009                      	breq sound_driver_calculate_delays_pulse2_Gxx_check_post
0024ea c012                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_pre
                                 sound_driver_calculate_delays_pulse2_Gxx_check_post:
0024eb 17db                      	cp r29, r27
0024ec f0f9                      	breq sound_driver_calculate_delays_pulse2_store
0024ed c01a                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_pre:
0024ee 93b0 28be                 	sts pulse2_fx_Sxx_pre, r27
0024f0 1bec                      	sub r30, r28 //(song speed)-1-Sxx
0024f1 93e0 28bf                 	sts pulse2_fx_Sxx_post, r30
0024f3 95ca                      	dec r28
0024f4 93c0 2874                 	sts pulse2_pattern_delay_frames, r28
0024f6 2fef                      	mov r30, r31
0024f7 50e1                      	subi r30, 1
0024f8 cfcf                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_post:
0024f9 93b0 28bf                 	sts pulse2_fx_Sxx_post, r27
0024fb 2fad                      	mov r26, r29
0024fc c00f                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx_pre:
0024fd 93b0 28ae                 	sts pulse2_fx_Gxx_pre, r27
0024ff 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002500 93e0 28af                 	sts pulse2_fx_Gxx_post, r30
002502 95ca                      	dec r28
002503 93c0 2874                 	sts pulse2_pattern_delay_frames, r28
002505 2fef                      	mov r30, r31
002506 50e1                      	subi r30, 1
002507 cfc0                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse2_Gxx_post:
002508 93b0 28af                 	sts pulse2_fx_Gxx_post, r27
00250a 2fad                      	mov r26, r29
00250b c000                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_store:
00250c 93a0 2874                 	sts pulse2_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_triangle:
00250e 91a0 28c3                 	lds r26, triangle_pattern_delay_frames
002510 11a2                      	cpse r26, zero
002511 c042                      	rjmp sound_driver_calculate_delays_noise
002512 c000                      	rjmp sound_driver_calculate_delays_triangle_main
                                 
                                 sound_driver_calculate_delays_triangle_main:
002513 2faf                      	mov r26, r31 //move the speed to r26
002514 91b0 28c2                 	lds r27, triangle_pattern_delay_rows //decrement the delay rows
002516 15b2                      	cp r27, zero
002517 f409                      	brne PC+2
002518 c03b                      	rjmp sound_driver_calculate_delays_noise
002519 95ba                      	dec r27
00251a 93b0 28c2                 	sts triangle_pattern_delay_rows, r27
00251c 11b2                      	cpse r27, zero
00251d c034                      	rjmp sound_driver_calculate_delays_triangle_store
00251e 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_triangle_Sxx:
00251f efbf                      	ldi r27, 0xFF
002520 91c0 2908                 	lds r28, triangle_fx_Sxx_pre
002522 91d0 2909                 	lds r29, triangle_fx_Sxx_post
                                 sound_driver_calculate_delays_triangle_Sxx_check_pre:
002524 17cb                      	cp r28, r27
002525 f009                      	breq sound_driver_calculate_delays_triangle_Sxx_check_post
002526 c00d                      	rjmp sound_driver_calculate_delays_triangle_Sxx_pre
                                 sound_driver_calculate_delays_triangle_Sxx_check_post:
002527 17db                      	cp r29, r27
002528 f009                      	breq sound_driver_calculate_delays_triangle_Gxx
002529 c015                      	rjmp sound_driver_calculate_delays_triangle_Sxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Gxx:
00252a 91c0 28f8                 	lds r28, triangle_fx_Gxx_pre
00252c 91d0 28f9                 	lds r29, triangle_fx_Gxx_post
                                 sound_driver_calculate_delays_triangle_Gxx_check_pre:
00252e 17cb                      	cp r28, r27
00252f f009                      	breq sound_driver_calculate_delays_triangle_Gxx_check_post
002530 c012                      	rjmp sound_driver_calculate_delays_triangle_Gxx_pre
                                 sound_driver_calculate_delays_triangle_Gxx_check_post:
002531 17db                      	cp r29, r27
002532 f0f9                      	breq sound_driver_calculate_delays_triangle_store
002533 c01a                      	rjmp sound_driver_calculate_delays_triangle_Gxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_pre:
002534 93b0 2908                 	sts triangle_fx_Sxx_pre, r27
002536 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002537 93e0 2909                 	sts triangle_fx_Sxx_post, r30
002539 95ca                      	dec r28
00253a 93c0 28c3                 	sts triangle_pattern_delay_frames, r28
00253c 2fef                      	mov r30, r31
00253d 50e1                      	subi r30, 1
00253e c015                      	rjmp sound_driver_calculate_delays_noise
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_post:
00253f 93b0 2909                 	sts triangle_fx_Sxx_post, r27
002541 2fad                      	mov r26, r29
002542 c00f                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_Gxx_pre:
002543 93b0 28f8                 	sts triangle_fx_Gxx_pre, r27
002545 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002546 93e0 28f9                 	sts triangle_fx_Gxx_post, r30
002548 95ca                      	dec r28
002549 93c0 28c3                 	sts triangle_pattern_delay_frames, r28
00254b 2fef                      	mov r30, r31
00254c 50e1                      	subi r30, 1
00254d c006                      	rjmp sound_driver_calculate_delays_noise
                                 	
                                 sound_driver_calculate_delays_triangle_Gxx_post:
00254e 93b0 28f9                 	sts triangle_fx_Gxx_post, r27
002550 2fad                      	mov r26, r29
002551 c000                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_store:
002552 93a0 28c3                 	sts triangle_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_noise:
002554 91a0 290d                 	lds r26, noise_pattern_delay_frames
002556 11a2                      	cpse r26, zero
002557 c042                      	rjmp sound_driver_calculate_delays_dpcm
002558 c000                      	rjmp sound_driver_calculate_delays_noise_main
                                 
                                 sound_driver_calculate_delays_noise_main:
002559 2faf                      	mov r26, r31 //move the speed to r26
00255a 91b0 290c                 	lds r27, noise_pattern_delay_rows //decrement the delay rows
00255c 15b2                      	cp r27, zero
00255d f409                      	brne PC+2
00255e c03b                      	rjmp sound_driver_calculate_delays_dpcm
00255f 95ba                      	dec r27
002560 93b0 290c                 	sts noise_pattern_delay_rows, r27
002562 11b2                      	cpse r27, zero
002563 c034                      	rjmp sound_driver_calculate_delays_noise_store
002564 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_noise_Sxx:
002565 efbf                      	ldi r27, 0xFF
002566 91c0 2957                 	lds r28, noise_fx_Sxx_pre
002568 91d0 2958                 	lds r29, noise_fx_Sxx_post
                                 sound_driver_calculate_delays_noise_Sxx_check_pre:
00256a 17cb                      	cp r28, r27
00256b f009                      	breq sound_driver_calculate_delays_noise_Sxx_check_post
00256c c00d                      	rjmp sound_driver_calculate_delays_noise_Sxx_pre
                                 sound_driver_calculate_delays_noise_Sxx_check_post:
00256d 17db                      	cp r29, r27
00256e f009                      	breq sound_driver_calculate_delays_noise_Gxx
00256f c015                      	rjmp sound_driver_calculate_delays_noise_Sxx_post
                                 
                                 sound_driver_calculate_delays_noise_Gxx:
002570 91c0 2947                 	lds r28, noise_fx_Gxx_pre
002572 91d0 2948                 	lds r29, noise_fx_Gxx_post
                                 sound_driver_calculate_delays_noise_Gxx_check_pre:
002574 17cb                      	cp r28, r27
002575 f009                      	breq sound_driver_calculate_delays_noise_Gxx_check_post
002576 c012                      	rjmp sound_driver_calculate_delays_noise_Gxx_pre
                                 sound_driver_calculate_delays_noise_Gxx_check_post:
002577 17db                      	cp r29, r27
002578 f0f9                      	breq sound_driver_calculate_delays_noise_store
002579 c01a                      	rjmp sound_driver_calculate_delays_noise_Gxx_post
                                 
                                 sound_driver_calculate_delays_noise_Sxx_pre:
00257a 93b0 2957                 	sts noise_fx_Sxx_pre, r27
00257c 1bec                      	sub r30, r28 //(song speed)-1-Sxx
00257d 93e0 2958                 	sts noise_fx_Sxx_post, r30
00257f 95ca                      	dec r28
002580 93c0 290d                 	sts noise_pattern_delay_frames, r28
002582 2fef                      	mov r30, r31
002583 50e1                      	subi r30, 1
002584 c015                      	rjmp sound_driver_calculate_delays_dpcm
                                 
                                 sound_driver_calculate_delays_noise_Sxx_post:
002585 93b0 2958                 	sts noise_fx_Sxx_post, r27
002587 2fad                      	mov r26, r29
002588 c00f                      	rjmp sound_driver_calculate_delays_noise_store
                                 
                                 sound_driver_calculate_delays_noise_Gxx_pre:
002589 93b0 2947                 	sts noise_fx_Gxx_pre, r27
00258b 1bec                      	sub r30, r28 //(song speed)-1-Sxx
00258c 93e0 2948                 	sts noise_fx_Gxx_post, r30
00258e 95ca                      	dec r28
00258f 93c0 290d                 	sts noise_pattern_delay_frames, r28
002591 2fef                      	mov r30, r31
002592 50e1                      	subi r30, 1
002593 c006                      	rjmp sound_driver_calculate_delays_dpcm
                                 	
                                 sound_driver_calculate_delays_noise_Gxx_post:
002594 93b0 2948                 	sts noise_fx_Gxx_post, r27
002596 2fad                      	mov r26, r29
002597 c000                      	rjmp sound_driver_calculate_delays_noise_store
                                 
                                 sound_driver_calculate_delays_noise_store:
002598 93a0 290d                 	sts noise_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_dpcm:
                                 
                                 sound_driver_instrument_fx_routine:
                                 sound_driver_instrument_routine_channel0_volume:
00259a 91e0 2828                 	lds ZL, pulse1_volume_macro
00259c 91f0 2829                 	lds ZH, pulse1_volume_macro+1
00259e 9630                      	adiw Z, 0
00259f f1a1                      	breq sound_driver_instrument_routine_channel0_volume_default //if no volume macro is in use, use default multiplier of F
0025a0 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0025a1 1fff                      	rol ZH
0025a2 91a0 282a                 	lds r26, pulse1_volume_macro_offset
0025a4 0fea                      	add ZL, r26
0025a5 1df2                      	adc ZH, zero
                                 
0025a6 91b0 282c                 	lds r27, pulse1_volume_macro_release
0025a8 17ba                      	cp r27, r26
0025a9 f429                      	brne sound_driver_instrument_routine_channel0_volume_increment //if the current offset is not equal to the release index, increment the offset
0025aa 91a0 282b                 	lds r26, pulse1_volume_macro_loop
0025ac 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0025ad f010                      	brlo sound_driver_instrument_routine_channel0_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0025ae c003                      	rjmp sound_driver_instrument_routine_channel0_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_volume_increment:
0025af 95a3                      	inc r26 //increment the macro offset
0025b0 93a0 282a                 	sts pulse1_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_volume_read:
0025b2 91b4                      	lpm r27, Z //load volume data into r27
0025b3 3fbf                      	cpi r27, 0xFF //check for macro end flag
0025b4 f469                      	brne sound_driver_instrument_routine_channel0_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_release:
0025b5 91b0 282c                 	lds r27, pulse1_volume_macro_release
0025b7 3fbf                      	cpi r27, 0xFF
0025b8 f429                      	brne sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_loop:
0025b9 91b0 282b                 	lds r27, pulse1_volume_macro_loop //load the loop index
0025bb 93b0 282a                 	sts pulse1_volume_macro_offset, r27 //store the loop index into the offset
0025bd cfdc                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index:
0025be 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
0025bf 93a0 282a                 	sts pulse1_volume_macro_offset, r26
0025c1 cfd8                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_calculate:
0025c2 e6ea                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
0025c3 e6f5                      	ldi ZH, HIGH(volumes << 1)
0025c4 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
0025c5 0feb                      	add ZL, r27 //add offset to the table
0025c6 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel0_volume_load:
0025c7 91b0 2800                 	lds r27, pulse1_param //load main volume
0025c9 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
0025ca 91a0 285d                 	lds r26, pulse1_fx_7xy_value
0025cc 30a0                      	cpi r26, 0x00
0025cd f481                      	brne sound_driver_instrument_routine_channel0_volume_load_7xy
                                 
0025ce 0feb                      	add ZL, r27 //offset the volume table by the main volume
0025cf 1df2                      	adc ZH, zero
0025d0 91b4                      	lpm r27, Z
0025d1 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
0025d3 c024                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default:
0025d4 91b0 2800                 	lds r27, pulse1_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
0025d6 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
0025d7 91a0 285d                 	lds r26, pulse1_fx_7xy_value
0025d9 30a0                      	cpi r26, 0x00
0025da f4a1                      	brne sound_driver_instrument_routine_channel0_volume_default_7xy
0025db 93b0 2806                 	sts pulse1_output_volume, r27
0025dd c01a                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy:
0025de 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
0025df f040                      	brcs sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
0025e0 f039                      	breq sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
0025e1 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
                                 
0025e2 0feb                      	add ZL, r27 //offset the volume table by the main volume
0025e3 1df2                      	adc ZH, zero
0025e4 91b4                      	lpm r27, Z
0025e5 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
0025e7 c010                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy_overflow:
0025e8 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
0025e9 0feb                      	add ZL, r27 //offset the volume table by the main volume
0025ea 1df2                      	adc ZH, zero
0025eb 91b4                      	lpm r27, Z
0025ec 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
0025ee c009                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default_7xy:
0025ef 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
0025f0 f020                      	brcs sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
0025f1 f019                      	breq sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
0025f2 93b0 2806                 	sts pulse1_output_volume, r27
0025f4 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel0_volume_default_7xy_overflow:
0025f5 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
0025f6 93b0 2806                 	sts pulse1_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
0025f8 91e0 282d                 	lds ZL, pulse1_arpeggio_macro
0025fa 91f0 282e                 	lds ZH, pulse1_arpeggio_macro+1
0025fc 9630                      	adiw Z, 0
0025fd f1d9                      	breq sound_driver_instrument_routine_channel0_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
0025fe 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0025ff 1fff                      	rol ZH
002600 91a0 282f                 	lds r26, pulse1_arpeggio_macro_offset
002602 0fea                      	add ZL, r26
002603 1df2                      	adc ZH, zero
                                 
002604 91b0 2831                 	lds r27, pulse1_arpeggio_macro_release
002606 17ba                      	cp r27, r26
002607 f429                      	brne sound_driver_instrument_routine_channel0_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002608 91a0 2830                 	lds r26, pulse1_arpeggio_macro_loop
00260a 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00260b f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
00260c c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_increment:
00260d 95a3                      	inc r26 //increment the macro offset
00260e 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_read:
002610 91b4                      	lpm r27, Z //load arpeggio data into r27
002611 38b0                      	cpi r27, 0x80 //check for macro end flag
002612 f009                      	breq sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag
002613 c041                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_check_mode:
002614 50a1                      	subi r26, 1 //keep the offset at the end flag
002615 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26
002617 91b0 2832                 	lds r27, pulse1_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002619 30b1                      	cpi r27, 0x01
00261a f048                      	brlo sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_release:
00261b 91b0 2831                 	lds r27, pulse1_arpeggio_macro_release
00261d 3fbf                      	cpi r27, 0xFF
00261e f4d1                      	brne sound_driver_instrument_routine_channel0_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_loop:
00261f 91b0 2830                 	lds r27, pulse1_arpeggio_macro_loop
002621 3fbf                      	cpi r27, 0xFF
002622 f499                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002623 c015                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute:
002624 91b0 2831                 	lds r27, pulse1_arpeggio_macro_release
002626 3fbf                      	cpi r27, 0xFF
002627 f421                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_check_loop:
002628 91b0 2830                 	lds r27, pulse1_arpeggio_macro_loop //load the loop index
00262a 3fbf                      	cpi r27, 0xFF //check if loop flag exists
00262b f451                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop:
00262c 91c0 2845                 	lds r28, pulse1_fx_0xy_sequence //check for 0xy effect
00262e 91d0 2846                 	lds r29, pulse1_fx_0xy_sequence+1
002630 9620                      	adiw r29:r28, 0
002631 f469                      	brne sound_driver_instrument_routine_channel0_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002632 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002633 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26 //store the last valid index into the offset
002635 cfc2                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload:
002636 93b0 282f                 	sts pulse1_arpeggio_macro_offset, r27 //store the loop index into the offset
002638 cfbf                      	rjmp sound_driver_instrument_routine_channel0_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_default:
002639 91c0 2845                 	lds r28, pulse1_fx_0xy_sequence //load 0xy effect
00263b 91d0 2846                 	lds r29, pulse1_fx_0xy_sequence+1
00263d 9620                      	adiw r29:r28, 0 //check for 0xy effect
00263e f099                      	breq sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel0_arpeggio_default_xy:
00263f 95d6                      	lsr r29
002640 95c7                      	ror r28
002641 95d7                      	ror r29
002642 95c7                      	ror r28
002643 95d7                      	ror r29
002644 95c7                      	ror r28
002645 95d7                      	ror r29
002646 95c7                      	ror r28
002647 95d7                      	ror r29
002648 95d2                      	swap r29
                                 
002649 93c0 2845                 	sts pulse1_fx_0xy_sequence, r28 //store the rolled sequence
00264b 93d0 2846                 	sts pulse1_fx_0xy_sequence+1, r29
00264d 70cf                      	andi r28, 0x0F //mask out the 4 LSB
00264e 91a0 2807                 	lds r26, pulse1_note //load the current note index
002650 0fac                      	add r26, r28 //add the note offset
002651 c02e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002652 91a0 2807                 	lds r26, pulse1_note //load the current note index
002654 c02b                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process:
002655 9220 2833                 	sts pulse1_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002657 9220 2834                 	sts pulse1_total_pitch_offset+1, zero
002659 9220 283a                 	sts pulse1_total_hi_pitch_offset, zero
00265b 91a0 2832                 	lds r26, pulse1_arpeggio_macro_mode
00265d 30a1                      	cpi r26, 0x01 //absolute mode
00265e f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_absolute
00265f f069                      	breq sound_driver_instrument_routine_channel0_arpeggio_process_fixed
002660 c00e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute:
002661 91a0 2807                 	lds r26, pulse1_note //load the current note index
002663 0fab                      	add r26, r27 //offset the note with the arpeggio data
002664 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002665 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_add:
002666 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002667 f0c0                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
002668 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002669 c016                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract:
00266a fda7                      	sbrc r26, 7 //check if result is negative
00266b e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
00266c c013                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_fixed:
00266d 2fab                      	mov r26, r27 //move the arpeggio data into r26
00266e c011                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative:
00266f 91a0 2807                 	lds r26, pulse1_note //load the current note index
002671 0fab                      	add r26, r27 //offset the note with the arpeggio data
002672 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002673 c008                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_add:
002674 93a0 2807                 	sts pulse1_note, r26 //NOTE: relative mode modifies the original note index
002676 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002677 f040                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
002678 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002679 93a0 2807                 	sts pulse1_note, r26
00267b c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract:
00267c fda7                      	sbrc r26, 7 //check if result is negative
00267d e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
00267e 93a0 2807                 	sts pulse1_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_load:
002680 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
002681 e0f0                      	ldi ZH, HIGH(note_table << 1)
002682 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002683 0fea                      	add ZL, r26 //add offset
002684 1df2                      	adc ZH, zero
002685 91a5                      	lpm r26, Z+ //load bytes
002686 91b4                      	lpm r27, Z
002687 93a0 0a8c                 	sts TCB0_CCMPL, r26 //load the LOW bits for timer
002689 93b0 0a8d                 	sts TCB0_CCMPH, r27 //load the HIGH bits for timer
00268b 93a0 2851                 	sts pulse1_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
00268d 93b0 2852                 	sts pulse1_fx_3xx_target+1, r27
00268f c000                      	rjmp sound_driver_instrument_routine_channel0_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch:
002690 91e0 2835                 	lds ZL, pulse1_pitch_macro
002692 91f0 2836                 	lds ZH, pulse1_pitch_macro+1
002694 9630                      	adiw Z, 0
002695 f409                      	brne sound_driver_instrument_routine_channel0_pitch_continue
002696 c023                      	rjmp sound_driver_instrument_routine_channel0_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel0_pitch_continue:
002697 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002698 1fff                      	rol ZH
002699 91a0 2837                 	lds r26, pulse1_pitch_macro_offset
00269b 0fea                      	add ZL, r26
00269c 1df2                      	adc ZH, zero
                                 
00269d 91b0 2839                 	lds r27, pulse1_pitch_macro_release
00269f 17ba                      	cp r27, r26
0026a0 f429                      	brne sound_driver_instrument_routine_channel0_pitch_increment //if the current offset is not equal to the release index, increment the offset
0026a1 91a0 2838                 	lds r26, pulse1_pitch_macro_loop
0026a3 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0026a4 f010                      	brlo sound_driver_instrument_routine_channel0_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0026a5 c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_pitch_increment:
0026a6 95a3                      	inc r26 //increment the macro offset
0026a7 93a0 2837                 	sts pulse1_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_pitch_read:
0026a9 91b4                      	lpm r27, Z //load pitch data into r27
0026aa 38b0                      	cpi r27, 0x80 //check for macro end flag
0026ab f479                      	brne sound_driver_instrument_routine_channel0_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_release:
0026ac 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0026ad 93a0 2837                 	sts pulse1_pitch_macro_offset, r26
0026af 91b0 2839                 	lds r27, pulse1_pitch_macro_release
0026b1 3fbf                      	cpi r27, 0xFF
0026b2 f439                      	brne sound_driver_instrument_routine_channel0_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_loop:
0026b3 91b0 2838                 	lds r27, pulse1_pitch_macro_loop //load the loop index
0026b5 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0026b6 f019                      	breq sound_driver_instrument_routine_channel0_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
0026b7 93b0 2837                 	sts pulse1_pitch_macro_offset, r27 //store the loop index into the offset
0026b9 cfd6                      	rjmp sound_driver_instrument_routine_channel0_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_default:
0026ba e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel0_pitch_calculate:
0026bb 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0026bc 937f                      	push r23
0026bd 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
0026be eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0026bf 0367                      	mulsu r22, r23
0026c0 917f                      	pop r23
0026c1 916f                      	pop r22
                                 
0026c2 9416                      	lsr r1 //shift out the fractional bits
0026c3 9407                      	ror r0
0026c4 9416                      	lsr r1
0026c5 9407                      	ror r0
0026c6 9416                      	lsr r1
0026c7 9407                      	ror r0
0026c8 9416                      	lsr r1
0026c9 9407                      	ror r0
0026ca fe13                      	sbrs r1, 3 //check if result was a negative number
0026cb c002                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_negative:
0026cc efb0                      	ldi r27, 0xF0
0026cd 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_offset:
0026ce 91a0 2833                 	lds r26, pulse1_total_pitch_offset
0026d0 91b0 2834                 	lds r27, pulse1_total_pitch_offset+1
0026d2 0e0a                      	add r0, r26
0026d3 1e1b                      	adc r1, r27
0026d4 9200 2833                 	sts pulse1_total_pitch_offset, r0
0026d6 9210 2834                 	sts pulse1_total_pitch_offset+1, r1
0026d8 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
0026da 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
0026dc 0da0                      	add r26, r0 //offset the timer values
0026dd 1db1                      	adc r27, r1
                                 	
0026de 91c0 2849                 	lds r28, pulse1_fx_1xx_total
0026e0 91d0 284a                 	lds r29, pulse1_fx_1xx_total+1
0026e2 1bac                      	sub r26, r28
0026e3 0bbd                      	sbc r27, r29
0026e4 91c0 284d                 	lds r28, pulse1_fx_2xx_total
0026e6 91d0 284e                 	lds r29, pulse1_fx_2xx_total+1
0026e8 0fac                      	add r26, r28
0026e9 1fbd                      	adc r27, r29
0026ea 91c0 2861                 	lds r28, pulse1_fx_Pxx_total
0026ec 91d0 2862                 	lds r29, pulse1_fx_Pxx_total+1
0026ee 0fac                      	add r26, r28
0026ef 1fbd                      	adc r27, r29
0026f0 91c0 2867                 	lds r28, pulse1_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
0026f2 91d0 2868                 	lds r29, pulse1_fx_Qxy_total_offset+1
0026f4 1bac                      	sub r26, r28
0026f5 0bbd                      	sbc r27, r29
0026f6 91c0 286d                 	lds r28, pulse1_fx_Rxy_total_offset
0026f8 91d0 286e                 	lds r29, pulse1_fx_Rxy_total_offset+1
0026fa 0fac                      	add r26, r28
0026fb 1fbd                      	adc r27, r29
                                 
0026fc 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
0026fe 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel0_hi_pitch:
002700 91e0 283b                 	lds ZL, pulse1_hi_pitch_macro
002702 91f0 283c                 	lds ZH, pulse1_hi_pitch_macro+1
002704 9630                      	adiw Z, 0
002705 f409                      	brne sound_driver_instrument_routine_channel0_hi_pitch_continue
002706 c03c                      	rjmp sound_driver_instrument_routine_channel0_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel0_hi_pitch_continue:
002707 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002708 1fff                      	rol ZH
002709 91a0 283d                 	lds r26, pulse1_hi_pitch_macro_offset
00270b 0fea                      	add ZL, r26
00270c 1df2                      	adc ZH, zero
                                 
00270d 91b0 283f                 	lds r27, pulse1_hi_pitch_macro_release
00270f 17ba                      	cp r27, r26
002710 f429                      	brne sound_driver_instrument_routine_channel0_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002711 91a0 283e                 	lds r26, pulse1_hi_pitch_macro_loop
002713 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002714 f010                      	brlo sound_driver_instrument_routine_channel0_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002715 c003                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_increment:
002716 95a3                      	inc r26 //increment the macro offset
002717 93a0 283d                 	sts pulse1_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_hi_pitch_read:
002719 91b4                      	lpm r27, Z //load hi pitch data into r27
00271a 38b0                      	cpi r27, 0x80 //check for macro end flag
00271b f489                      	brne sound_driver_instrument_routine_channel0_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_release:
00271c 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00271d 93a0 283d                 	sts pulse1_hi_pitch_macro_offset, r26
00271f 91b0 283f                 	lds r27, pulse1_hi_pitch_macro_release
002721 3fbf                      	cpi r27, 0xFF
002722 f439                      	brne sound_driver_instrument_routine_channel0_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_loop:
002723 91b0 283e                 	lds r27, pulse1_hi_pitch_macro_loop //load the loop index
002725 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002726 f019                      	breq sound_driver_instrument_routine_channel0_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002727 93b0 283d                 	sts pulse1_hi_pitch_macro_offset, r27 //store the loop index into the offset
002729 cfd6                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_default:
00272a 91b0 283a                 	lds r27, pulse1_total_hi_pitch_offset
00272c c005                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate:
00272d 91a0 283a                 	lds r26, pulse1_total_hi_pitch_offset //load the total hi pitch offset to change
00272f 0fba                      	add r27, r26
002730 93b0 283a                 	sts pulse1_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply:
002732 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002733 937f                      	push r23
002734 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002735 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002736 0367                      	mulsu r22, r23
002737 917f                      	pop r23
002738 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_offset:
002739 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
00273b 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
00273d 0da0                      	add r26, r0 //offset the timer values
00273e 1db1                      	adc r27, r1
00273f 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
002741 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel0_duty:
002743 91e0 2840                 	lds ZL, pulse1_duty_macro
002745 91f0 2841                 	lds ZH, pulse1_duty_macro+1
002747 9630                      	adiw Z, 0
002748 f1b1                      	breq sound_driver_channel0_fx_routines //if no duty macro is in use, go to the next routine
002749 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00274a 1fff                      	rol ZH
00274b 91a0 2842                 	lds r26, pulse1_duty_macro_offset
00274d 0fea                      	add ZL, r26
00274e 1df2                      	adc ZH, zero
                                 
00274f 91b0 2844                 	lds r27, pulse1_duty_macro_release
002751 17ba                      	cp r27, r26
002752 f429                      	brne sound_driver_instrument_routine_channel0_duty_increment //if the current offset is not equal to the release index, increment the offset
002753 91a0 2843                 	lds r26, pulse1_duty_macro_loop
002755 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002756 f010                      	brlo sound_driver_instrument_routine_channel0_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002757 c027                      	rjmp sound_driver_channel0_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel0_duty_increment:
002758 95a3                      	inc r26 //increment the macro offset
002759 93a0 2842                 	sts pulse1_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_duty_read:
00275b 91b4                      	lpm r27, Z //load pitch data into r27
00275c 3fbf                      	cpi r27, 0xFF //check for macro end flag
00275d f471                      	brne sound_driver_instrument_routine_channel0_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_release:
00275e 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00275f 93a0 2842                 	sts pulse1_duty_macro_offset, r26
002761 91b0 2844                 	lds r27, pulse1_duty_macro_release
002763 3fbf                      	cpi r27, 0xFF
002764 f4d1                      	brne sound_driver_channel0_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_loop:
002765 91b0 2843                 	lds r27, pulse1_duty_macro_loop //load the loop index
002767 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002768 f0b1                      	breq sound_driver_channel0_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
002769 93b0 2842                 	sts pulse1_duty_macro_offset, r27 //store the loop index into the offset
00276b cfd7                      	rjmp sound_driver_instrument_routine_channel0_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_load:
00276c e9e6                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
00276d e6f4                      	ldi ZH, HIGH(sequences << 1)
00276e 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
00276f 1df2                      	adc ZH, zero
                                 
002770 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
002771 95b7                      	ror r27
002772 95b7                      	ror r27
002773 91a0 2800                 	lds r26, pulse1_param //load r26 with pulse1_param (register $4000)
002775 2fca                      	mov r28, r26 //store a copy of pulse1_param into r28
002776 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
002777 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
002778 c001                      	rjmp sound_driver_instrument_routine_channel0_duty_load_store
002779 c005                      	rjmp sound_driver_channel0_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel0_duty_load_store:
00277a 90a4                      	lpm pulse1_sequence, Z //store the sequence
                                 
00277b 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
00277c 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
00277d 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_routines:
                                 sound_driver_channel0_fx_1xx_routine:
00277f 91e0 2847                 	lds ZL, pulse1_fx_1xx
002781 91f0 2848                 	lds ZH, pulse1_fx_1xx+1
002783 9630                      	adiw Z, 0
002784 f051                      	breq sound_driver_channel0_fx_2xx_routine
                                 
002785 91a0 2849                 	lds r26, pulse1_fx_1xx_total //load the rate to change the pitch by
002787 91b0 284a                 	lds r27, pulse1_fx_1xx_total+1
002789 0fae                      	add r26, ZL //increase the total offset by the rate
00278a 1fbf                      	adc r27, ZH
00278b 93a0 2849                 	sts pulse1_fx_1xx_total, r26
00278d 93b0 284a                 	sts pulse1_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_2xx_routine:
00278f 91e0 284b                 	lds ZL, pulse1_fx_2xx
002791 91f0 284c                 	lds ZH, pulse1_fx_2xx+1
002793 9630                      	adiw Z, 0
002794 f051                      	breq sound_driver_channel0_fx_3xx_routine
                                 
002795 91a0 284d                 	lds r26, pulse1_fx_2xx_total //load the rate to change the pitch by
002797 91b0 284e                 	lds r27, pulse1_fx_2xx_total+1
002799 0fae                      	add r26, ZL //increase the total offset by the rate
00279a 1fbf                      	adc r27, ZH
00279b 93a0 284d                 	sts pulse1_fx_2xx_total, r26
00279d 93b0 284e                 	sts pulse1_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_3xx_routine:
00279f 91e0 2853                 	lds ZL, pulse1_fx_3xx_speed
0027a1 91f0 2854                 	lds ZH, pulse1_fx_3xx_speed+1
0027a3 9630                      	adiw Z, 0
0027a4 f409                      	brne sound_driver_channel0_fx_3xx_routine_check_start
0027a5 c048                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_check_start:
0027a6 91a0 284f                 	lds r26, pulse1_fx_3xx_start
0027a8 91b0 2850                 	lds r27, pulse1_fx_3xx_start+1
0027aa 9610                      	adiw r26:r27, 0
0027ab f409                      	brne sound_driver_channel0_fx_3xx_routine_main
0027ac c041                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_main:
0027ad 91c0 2851                 	lds r28, pulse1_fx_3xx_target
0027af 91d0 2852                 	lds r29, pulse1_fx_3xx_target+1
                                 
0027b1 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
0027b2 07bd                      	cpc r27, r29
0027b3 f011                      	breq sound_driver_channel0_fx_3xx_routine_disable
0027b4 f030                      	brlo sound_driver_channel0_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
0027b5 c01f                      	rjmp sound_driver_channel0_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel0_fx_3xx_routine_disable:
0027b6 9220 284f                 	sts pulse1_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
0027b8 9220 2850                 	sts pulse1_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
0027ba c033                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_subtract:
0027bb 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
0027bc 0bdb                      	sbc r29, r27
0027bd 91a0 2855                 	lds r26, pulse1_fx_3xx_total_offset
0027bf 91b0 2856                 	lds r27, pulse1_fx_3xx_total_offset+1
                                 
0027c1 0fae                      	add r26, ZL //add the speed to the total offset
0027c2 1fbf                      	adc r27, ZH
0027c3 1bca                      	sub r28, r26 //invert the total difference with the total offset
0027c4 0bdb                      	sbc r29, r27
0027c5 f380                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0027c6 93a0 2855                 	sts pulse1_fx_3xx_total_offset, r26 //store the new total offset
0027c8 93b0 2856                 	sts pulse1_fx_3xx_total_offset+1, r27
                                 
0027ca 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the current timer period
0027cc 91b0 0a8d                 	lds r27, TCB0_CCMPH
0027ce 1bac                      	sub r26, r28 //offset the current timer period with the total offset
0027cf 0bbd                      	sbc r27, r29
0027d0 93a0 0a8c                 	sts TCB0_CCMPL, r26
0027d2 93b0 0a8d                 	sts TCB0_CCMPH, r27
0027d4 c019                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_add:
0027d5 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
0027d6 0bbd                      	sbc r27, r29
0027d7 91c0 2855                 	lds r28, pulse1_fx_3xx_total_offset
0027d9 91d0 2856                 	lds r29, pulse1_fx_3xx_total_offset+1
                                 
0027db 0fce                      	add r28, ZL //add the speed to the total offset
0027dc 1fdf                      	adc r29, ZH
0027dd 1bac                      	sub r26, r28 //invert the total difference with the total offset
0027de 0bbd                      	sbc r27, r29
0027df f2b0                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0027e0 93c0 2855                 	sts pulse1_fx_3xx_total_offset, r28 //store the new total offset
0027e2 93d0 2856                 	sts pulse1_fx_3xx_total_offset+1, r29
                                 
0027e4 91c0 0a8c                 	lds r28, TCB0_CCMPL //load the current timer period
0027e6 91d0 0a8d                 	lds r29, TCB0_CCMPH
0027e8 0fca                      	add r28, r26 //offset the current timer period with the total offset
0027e9 1fdb                      	adc r29, r27
0027ea 93c0 0a8c                 	sts TCB0_CCMPL, r28
0027ec 93d0 0a8d                 	sts TCB0_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel0_fx_4xy_routine:
0027ee 91a0 2857                 	lds r26, pulse1_fx_4xy_speed
0027f0 15a2                      	cp r26, zero
0027f1 f409                      	brne sound_driver_channel0_fx_4xy_routine_continue
0027f2 c05c                      	rjmp sound_driver_channel0_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel0_fx_4xy_routine_continue:
0027f3 91b0 2858                 	lds r27, pulse1_fx_4xy_depth
0027f5 91c0 2859                 	lds r28, pulse1_fx_4xy_phase
0027f7 0fca                      	add r28, r26 //increase the phase by the speed
0027f8 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
0027f9 f008                      	brlo sound_driver_channel0_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
0027fa 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase:
0027fb 93c0 2859                 	sts pulse1_fx_4xy_phase, r28 //store the new phase
0027fd 31c0                      	cpi r28, 16
0027fe f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_0
0027ff 32c0                      	cpi r28, 32
002800 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_1
002801 33c0                      	cpi r28, 48
002802 f030                      	brlo sound_driver_channel0_fx_4xy_routine_phase_2
002803 c007                      	rjmp sound_driver_channel0_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_0:
002804 70cf                      	andi r28, 0x0F //mask for values 0-15
002805 c029                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_1:
002806 6fc0                      	ori r28, 0xF0
002807 95c0                      	com r28 //invert values 0-15
002808 c026                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_2:
002809 70cf                      	andi r28, 0x0F //mask for values 0-15
00280a c003                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_3:
00280b 6fc0                      	ori r28, 0xF0
00280c 95c0                      	com r28 //invert values 0-15
00280d c000                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_add:
00280e 95b2                      	swap r27 //multiply depth by 16
00280f 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002810 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002811 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002812 0fec                      	add ZL, r28 //offset the table by the depth+phase
002813 1df2                      	adc ZH, zero
002814 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002815 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002816 937f                      	push r23
002817 2f6c                      	mov r22, r28 //store the vibrato value into r22
002818 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002819 9f67                      	mul r22, r23
00281a 917f                      	pop r23
00281b 916f                      	pop r22
                                 
00281c 9416                      	lsr r1 //shift out the fractional bits
00281d 9407                      	ror r0
00281e 9416                      	lsr r1
00281f 9407                      	ror r0
002820 9416                      	lsr r1
002821 9407                      	ror r0
002822 9416                      	lsr r1
002823 9407                      	ror r0
                                 	
002824 91a0 0a8c                 	lds r26, TCB0_CCMPL
002826 91b0 0a8d                 	lds r27, TCB0_CCMPH
002828 0da0                      	add r26, r0
002829 1db1                      	adc r27, r1
00282a 93a0 0a8c                 	sts TCB0_CCMPL, r26
00282c 93b0 0a8d                 	sts TCB0_CCMPH, r27
00282e c020                      	rjmp sound_driver_channel0_fx_7xy_routine
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_subtract:
00282f 95b2                      	swap r27 //multiply depth by 16
002830 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002831 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002832 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002833 0fec                      	add ZL, r28 //offset the table by the depth+phase
002834 1df2                      	adc ZH, zero
002835 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002836 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002837 937f                      	push r23
002838 2f6c                      	mov r22, r28 //store the vibrato value into r22
002839 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00283a 9f67                      	mul r22, r23
00283b 917f                      	pop r23
00283c 916f                      	pop r22
                                 
00283d 9416                      	lsr r1 //shift out the fractional bits
00283e 9407                      	ror r0
00283f 9416                      	lsr r1
002840 9407                      	ror r0
002841 9416                      	lsr r1
002842 9407                      	ror r0
002843 9416                      	lsr r1
002844 9407                      	ror r0
                                 
002845 91a0 0a8c                 	lds r26, TCB0_CCMPL
002847 91b0 0a8d                 	lds r27, TCB0_CCMPH
002849 19a0                      	sub r26, r0
00284a 09b1                      	sbc r27, r1
00284b 93a0 0a8c                 	sts TCB0_CCMPL, r26
00284d 93b0 0a8d                 	sts TCB0_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_7xy_routine:
00284f 91a0 285a                 	lds r26, pulse1_fx_7xy_speed
002851 15a2                      	cp r26, zero
002852 f0f1                      	breq sound_driver_channel0_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
002853 91b0 285b                 	lds r27, pulse1_fx_7xy_depth
002855 91c0 285c                 	lds r28, pulse1_fx_7xy_phase
002857 0fca                      	add r28, r26 //increase the phase by the speed
002858 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
002859 f010                      	brlo sound_driver_channel0_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
00285a e0c0                      	ldi r28, 0x00
00285b 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase:
00285c 93c0 285c                 	sts pulse1_fx_7xy_phase, r28 //store the new phase
00285e 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
00285f ffc4                      	sbrs r28, 4
002860 c001                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_0
002861 c002                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel0_fx_7xy_routine_phase_0:
002862 70cf                      	andi r28, 0x0F //mask for values 0-15
002863 c003                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase_1:
002864 6fc0                      	ori r28, 0xF0
002865 95c0                      	com r28 //invert values 0-15
002866 c000                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_load:
002867 95b2                      	swap r27 //multiply depth by 16
002868 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002869 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00286a e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00286b 0fec                      	add ZL, r28 //offset the table by the depth+phase
00286c 1df2                      	adc ZH, zero
00286d 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
00286e 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
00286f 93c0 285d                 	sts pulse1_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Axy_routine:
002871 91b0 285e                 	lds r27, pulse1_fx_Axy
002873 15b2                      	cp r27, zero
002874 f0e9                      	breq sound_driver_channel0_fx_Qxy_routine //0 means that the effect is not in use
                                 	
002875 91a0 2805                 	lds r26, pulse1_fractional_volume //load fractional volume representation of the channel
002877 91c0 2800                 	lds r28, pulse1_param //load the integer volume representation of the channel
002879 2fda                      	mov r29, r26 //copy fractional volume into r29
00287a 2fec                      	mov r30, r28 //copy the pulse1_param into r30
00287b 95e2                      	swap r30
00287c 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
00287d 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
00287e 17ed                      	cp r30, r29 //compare the fractional and integer volumes
00287f f009                      	breq sound_driver_channel0_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel0_fx_Axy_routine_reload:
002880 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate:
002881 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
002882 c004                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_addition:
002883 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002884 f428                      	brcc sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002885 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
002886 c003                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_subtraction:
002887 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002888 f008                      	brcs sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002889 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_store:
00288a 93a0 2805                 	sts pulse1_fractional_volume, r26 //store the new fractional volume
00288c 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
00288d 95a2                      	swap r26
00288e 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
00288f 2bca                      	or r28, r26 //store the new volume back into pulse1_param
002890 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel0_fx_Qxy_routine:
002892 91e0 2863                 	lds ZL, pulse1_fx_Qxy_target
002894 91f0 2864                 	lds ZH, pulse1_fx_Qxy_target+1
002896 9630                      	adiw Z, 0
002897 f139                      	breq sound_driver_channel0_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002898 91a0 2867                 	lds r26, pulse1_fx_Qxy_total_offset
00289a 91b0 2868                 	lds r27, pulse1_fx_Qxy_total_offset+1
00289c 91c0 0a8c                 	lds r28, TCB0_CCMPL
00289e 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
0028a0 1bec                      	sub ZL, r28 //calculate the difference to the target
0028a1 0bfd                      	sbc ZH, r29
0028a2 f408                      	brsh sound_driver_channel0_fx_Qxy_routine_end //if the target has been reached (or passed)
0028a3 f088                      	brlo sound_driver_channel0_fx_Qxy_routine_add
                                 
                                 sound_driver_channel0_fx_Qxy_routine_end:
0028a4 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
0028a5 0bbf                      	sbc r27, ZH
                                 
0028a6 91c0 2861                 	lds r28, pulse1_fx_Pxx_total
0028a8 91d0 2862                 	lds r29, pulse1_fx_Pxx_total+1
                                 
0028aa 0fac                      	add r26, r28
0028ab 1fbd                      	adc r27, r29
                                 
0028ac 93a0 2867                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
0028ae 93b0 2868                 	sts pulse1_fx_Qxy_total_offset+1, r27
0028b0 9220 2863                 	sts pulse1_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
0028b2 9220 2864                 	sts pulse1_fx_Qxy_target+1, zero
0028b4 c00a                      	rjmp sound_driver_channel0_fx_Rxy_routine
                                 
                                 sound_driver_channel0_fx_Qxy_routine_add:
0028b5 91c0 2865                 	lds r28, pulse1_fx_Qxy_speed
0028b7 91d0 2866                 	lds r29, pulse1_fx_Qxy_speed+1
0028b9 0fac                      	add r26, r28 //increase the total offset by the speed
0028ba 1fbd                      	adc r27, r29
0028bb 93a0 2867                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
0028bd 93b0 2868                 	sts pulse1_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Rxy_routine:
0028bf 91e0 2869                 	lds ZL, pulse1_fx_Rxy_target
0028c1 91f0 286a                 	lds ZH, pulse1_fx_Rxy_target+1
0028c3 9630                      	adiw Z, 0
0028c4 f139                      	breq sound_driver_instrument_routine_channel1_volume //if the effect is not enabled, skip the routine
                                 
0028c5 91a0 286d                 	lds r26, pulse1_fx_Rxy_total_offset
0028c7 91b0 286e                 	lds r27, pulse1_fx_Rxy_total_offset+1
0028c9 91c0 0a8c                 	lds r28, TCB0_CCMPL
0028cb 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
0028cd 1bce                      	sub r28, ZL //calculate the difference to the target
0028ce 0bdf                      	sbc r29, ZH
0028cf f408                      	brsh sound_driver_channel0_fx_Rxy_routine_end //if the target has been reached (or passed)
0028d0 f088                      	brlo sound_driver_channel0_fx_Rxy_routine_add
                                 
                                 sound_driver_channel0_fx_Rxy_routine_end:
0028d1 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
0028d2 0bbd                      	sbc r27, r29
                                 
0028d3 91c0 2861                 	lds r28, pulse1_fx_Pxx_total
0028d5 91d0 2862                 	lds r29, pulse1_fx_Pxx_total+1
                                 
0028d7 0fac                      	add r26, r28
0028d8 1fbd                      	adc r27, r29
                                 
0028d9 93a0 286d                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
0028db 93b0 286e                 	sts pulse1_fx_Rxy_total_offset+1, r27
0028dd 9220 2869                 	sts pulse1_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
0028df 9220 286a                 	sts pulse1_fx_Rxy_target+1, zero
0028e1 c00a                      	rjmp sound_driver_instrument_routine_channel1_volume
                                 
                                 sound_driver_channel0_fx_Rxy_routine_add:
0028e2 91c0 286b                 	lds r28, pulse1_fx_Rxy_speed
0028e4 91d0 286c                 	lds r29, pulse1_fx_Rxy_speed+1
0028e6 0fac                      	add r26, r28 //increase the total offset by the speed
0028e7 1fbd                      	adc r27, r29
0028e8 93a0 286d                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
0028ea 93b0 286e                 	sts pulse1_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume:
0028ec 91e0 2877                 	lds ZL, pulse2_volume_macro
0028ee 91f0 2878                 	lds ZH, pulse2_volume_macro+1
0028f0 9630                      	adiw Z, 0
0028f1 f1a1                      	breq sound_driver_instrument_routine_channel1_volume_default //if no volume macro is in use, use default multiplier of F
0028f2 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0028f3 1fff                      	rol ZH
0028f4 91a0 2879                 	lds r26, pulse2_volume_macro_offset
0028f6 0fea                      	add ZL, r26
0028f7 1df2                      	adc ZH, zero
                                 
0028f8 91b0 287b                 	lds r27, pulse2_volume_macro_release
0028fa 17ba                      	cp r27, r26
0028fb f429                      	brne sound_driver_instrument_routine_channel1_volume_increment //if the current offset is not equal to the release index, increment the offset
0028fc 91a0 287a                 	lds r26, pulse2_volume_macro_loop
0028fe 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0028ff f010                      	brlo sound_driver_instrument_routine_channel1_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002900 c003                      	rjmp sound_driver_instrument_routine_channel1_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_volume_increment:
002901 95a3                      	inc r26 //increment the macro offset
002902 93a0 2879                 	sts pulse2_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_volume_read:
002904 91b4                      	lpm r27, Z //load volume data into r27
002905 3fbf                      	cpi r27, 0xFF //check for macro end flag
002906 f469                      	brne sound_driver_instrument_routine_channel1_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_release:
002907 91b0 287b                 	lds r27, pulse2_volume_macro_release
002909 3fbf                      	cpi r27, 0xFF
00290a f429                      	brne sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_loop:
00290b 91b0 287a                 	lds r27, pulse2_volume_macro_loop //load the loop index
00290d 93b0 2879                 	sts pulse2_volume_macro_offset, r27 //store the loop index into the offset
00290f cfdc                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index:
002910 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002911 93a0 2879                 	sts pulse2_volume_macro_offset, r26
002913 cfd8                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_calculate:
002914 e6ea                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
002915 e6f5                      	ldi ZH, HIGH(volumes << 1)
002916 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
002917 0feb                      	add ZL, r27 //add offset to the table
002918 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel1_volume_load:
002919 91b0 2808                 	lds r27, pulse2_param //load main volume
00291b 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
00291c 91a0 28ac                 	lds r26, pulse2_fx_7xy_value
00291e 30a0                      	cpi r26, 0x00
00291f f481                      	brne sound_driver_instrument_routine_channel1_volume_load_7xy
                                 
002920 0feb                      	add ZL, r27 //offset the volume table by the main volume
002921 1df2                      	adc ZH, zero
002922 91b4                      	lpm r27, Z
002923 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
002925 c024                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default:
002926 91b0 2808                 	lds r27, pulse2_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
002928 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002929 91a0 28ac                 	lds r26, pulse2_fx_7xy_value
00292b 30a0                      	cpi r26, 0x00
00292c f4a1                      	brne sound_driver_instrument_routine_channel1_volume_default_7xy
00292d 93b0 280e                 	sts pulse2_output_volume, r27
00292f c01a                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy:
002930 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002931 f040                      	brcs sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
002932 f039                      	breq sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
002933 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
                                 
002934 0feb                      	add ZL, r27 //offset the volume table by the main volume
002935 1df2                      	adc ZH, zero
002936 91b4                      	lpm r27, Z
002937 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
002939 c010                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy_overflow:
00293a e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
00293b 0feb                      	add ZL, r27 //offset the volume table by the main volume
00293c 1df2                      	adc ZH, zero
00293d 91b4                      	lpm r27, Z
00293e 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
002940 c009                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default_7xy:
002941 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002942 f020                      	brcs sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
002943 f019                      	breq sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
002944 93b0 280e                 	sts pulse2_output_volume, r27
002946 c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel1_volume_default_7xy_overflow:
002947 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002948 93b0 280e                 	sts pulse2_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
00294a 91e0 287c                 	lds ZL, pulse2_arpeggio_macro
00294c 91f0 287d                 	lds ZH, pulse2_arpeggio_macro+1
00294e 9630                      	adiw Z, 0
00294f f1d9                      	breq sound_driver_instrument_routine_channel1_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002950 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002951 1fff                      	rol ZH
002952 91a0 287e                 	lds r26, pulse2_arpeggio_macro_offset
002954 0fea                      	add ZL, r26
002955 1df2                      	adc ZH, zero
                                 
002956 91b0 2880                 	lds r27, pulse2_arpeggio_macro_release
002958 17ba                      	cp r27, r26
002959 f429                      	brne sound_driver_instrument_routine_channel1_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
00295a 91a0 287f                 	lds r26, pulse2_arpeggio_macro_loop
00295c 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00295d f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
00295e c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_increment:
00295f 95a3                      	inc r26 //increment the macro offset
002960 93a0 287e                 	sts pulse2_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_read:
002962 91b4                      	lpm r27, Z //load arpeggio data into r27
002963 38b0                      	cpi r27, 0x80 //check for macro end flag
002964 f009                      	breq sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag
002965 c041                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_check_mode:
002966 50a1                      	subi r26, 1 //keep the offset at the end flag
002967 93a0 287e                 	sts pulse2_arpeggio_macro_offset, r26
002969 91b0 2881                 	lds r27, pulse2_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
00296b 30b1                      	cpi r27, 0x01
00296c f048                      	brlo sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_release:
00296d 91b0 2880                 	lds r27, pulse2_arpeggio_macro_release
00296f 3fbf                      	cpi r27, 0xFF
002970 f4d1                      	brne sound_driver_instrument_routine_channel1_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_loop:
002971 91b0 287f                 	lds r27, pulse2_arpeggio_macro_loop
002973 3fbf                      	cpi r27, 0xFF
002974 f499                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002975 c015                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute:
002976 91b0 2880                 	lds r27, pulse2_arpeggio_macro_release
002978 3fbf                      	cpi r27, 0xFF
002979 f421                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_check_loop:
00297a 91b0 287f                 	lds r27, pulse2_arpeggio_macro_loop //load the loop index
00297c 3fbf                      	cpi r27, 0xFF //check if loop flag exists
00297d f451                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop:
00297e 91c0 2894                 	lds r28, pulse2_fx_0xy_sequence //check for 0xy effect
002980 91d0 2895                 	lds r29, pulse2_fx_0xy_sequence+1
002982 9620                      	adiw r29:r28, 0
002983 f469                      	brne sound_driver_instrument_routine_channel1_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002984 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002985 93a0 287e                 	sts pulse2_arpeggio_macro_offset, r26 //store the last valid index into the offset
002987 cfc2                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload:
002988 93b0 287e                 	sts pulse2_arpeggio_macro_offset, r27 //store the loop index into the offset
00298a cfbf                      	rjmp sound_driver_instrument_routine_channel1_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_default:
00298b 91c0 2894                 	lds r28, pulse2_fx_0xy_sequence //load 0xy effect
00298d 91d0 2895                 	lds r29, pulse2_fx_0xy_sequence+1
00298f 9620                      	adiw r29:r28, 0 //check for 0xy effect
002990 f099                      	breq sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel1_arpeggio_default_xy:
002991 95d6                      	lsr r29
002992 95c7                      	ror r28
002993 95d7                      	ror r29
002994 95c7                      	ror r28
002995 95d7                      	ror r29
002996 95c7                      	ror r28
002997 95d7                      	ror r29
002998 95c7                      	ror r28
002999 95d7                      	ror r29
00299a 95d2                      	swap r29
                                 
00299b 93c0 2894                 	sts pulse2_fx_0xy_sequence, r28 //store the rolled sequence
00299d 93d0 2895                 	sts pulse2_fx_0xy_sequence+1, r29
00299f 70cf                      	andi r28, 0x0F //mask out the 4 LSB
0029a0 91a0 280f                 	lds r26, pulse2_note //load the current note index
0029a2 0fac                      	add r26, r28 //add the note offset
0029a3 c02e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
0029a4 91a0 280f                 	lds r26, pulse2_note //load the current note index
0029a6 c02b                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process:
0029a7 9220 2882                 	sts pulse2_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
0029a9 9220 2883                 	sts pulse2_total_pitch_offset+1, zero
0029ab 9220 2889                 	sts pulse2_total_hi_pitch_offset, zero
0029ad 91a0 2881                 	lds r26, pulse2_arpeggio_macro_mode
0029af 30a1                      	cpi r26, 0x01 //absolute mode
0029b0 f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_absolute
0029b1 f069                      	breq sound_driver_instrument_routine_channel1_arpeggio_process_fixed
0029b2 c00e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute:
0029b3 91a0 280f                 	lds r26, pulse2_note //load the current note index
0029b5 0fab                      	add r26, r27 //offset the note with the arpeggio data
0029b6 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0029b7 c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_add:
0029b8 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0029b9 f0c0                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
0029ba e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0029bb c016                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract:
0029bc fda7                      	sbrc r26, 7 //check if result is negative
0029bd e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0029be c013                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_fixed:
0029bf 2fab                      	mov r26, r27 //move the arpeggio data into r26
0029c0 c011                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative:
0029c1 91a0 280f                 	lds r26, pulse2_note //load the current note index
0029c3 0fab                      	add r26, r27 //offset the note with the arpeggio data
0029c4 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0029c5 c008                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_add:
0029c6 93a0 280f                 	sts pulse2_note, r26 //NOTE: relative mode modifies the original note index
0029c8 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0029c9 f040                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
0029ca e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0029cb 93a0 280f                 	sts pulse2_note, r26
0029cd c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract:
0029ce fda7                      	sbrc r26, 7 //check if result is negative
0029cf e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0029d0 93a0 280f                 	sts pulse2_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_load:
0029d2 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0029d3 e0f0                      	ldi ZH, HIGH(note_table << 1)
0029d4 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
0029d5 0fea                      	add ZL, r26 //add offset
0029d6 1df2                      	adc ZH, zero
0029d7 91a5                      	lpm r26, Z+ //load bytes
0029d8 91b4                      	lpm r27, Z
0029d9 93a0 0a9c                 	sts TCB1_CCMPL, r26 //load the LOW bits for timer
0029db 93b0 0a9d                 	sts TCB1_CCMPH, r27 //load the HIGH bits for timer
0029dd 93a0 28a0                 	sts pulse2_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
0029df 93b0 28a1                 	sts pulse2_fx_3xx_target+1, r27
0029e1 c000                      	rjmp sound_driver_instrument_routine_channel1_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch:
0029e2 91e0 2884                 	lds ZL, pulse2_pitch_macro
0029e4 91f0 2885                 	lds ZH, pulse2_pitch_macro+1
0029e6 9630                      	adiw Z, 0
0029e7 f409                      	brne sound_driver_instrument_routine_channel1_pitch_continue
0029e8 c023                      	rjmp sound_driver_instrument_routine_channel1_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel1_pitch_continue:
0029e9 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0029ea 1fff                      	rol ZH
0029eb 91a0 2886                 	lds r26, pulse2_pitch_macro_offset
0029ed 0fea                      	add ZL, r26
0029ee 1df2                      	adc ZH, zero
                                 
0029ef 91b0 2888                 	lds r27, pulse2_pitch_macro_release
0029f1 17ba                      	cp r27, r26
0029f2 f429                      	brne sound_driver_instrument_routine_channel1_pitch_increment //if the current offset is not equal to the release index, increment the offset
0029f3 91a0 2887                 	lds r26, pulse2_pitch_macro_loop
0029f5 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0029f6 f010                      	brlo sound_driver_instrument_routine_channel1_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0029f7 c003                      	rjmp sound_driver_instrument_routine_channel1_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_pitch_increment:
0029f8 95a3                      	inc r26 //increment the macro offset
0029f9 93a0 2886                 	sts pulse2_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_pitch_read:
0029fb 91b4                      	lpm r27, Z //load pitch data into r27
0029fc 38b0                      	cpi r27, 0x80 //check for macro end flag
0029fd f479                      	brne sound_driver_instrument_routine_channel1_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_release:
0029fe 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0029ff 93a0 2886                 	sts pulse2_pitch_macro_offset, r26
002a01 91b0 2888                 	lds r27, pulse2_pitch_macro_release
002a03 3fbf                      	cpi r27, 0xFF
002a04 f439                      	brne sound_driver_instrument_routine_channel1_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_loop:
002a05 91b0 2887                 	lds r27, pulse2_pitch_macro_loop //load the loop index
002a07 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002a08 f019                      	breq sound_driver_instrument_routine_channel1_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002a09 93b0 2886                 	sts pulse2_pitch_macro_offset, r27 //store the loop index into the offset
002a0b cfd6                      	rjmp sound_driver_instrument_routine_channel1_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_default:
002a0c e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel1_pitch_calculate:
002a0d 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002a0e 937f                      	push r23
002a0f 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
002a10 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002a11 0367                      	mulsu r22, r23
002a12 917f                      	pop r23
002a13 916f                      	pop r22
                                 
002a14 9416                      	lsr r1 //shift out the fractional bits
002a15 9407                      	ror r0
002a16 9416                      	lsr r1
002a17 9407                      	ror r0
002a18 9416                      	lsr r1
002a19 9407                      	ror r0
002a1a 9416                      	lsr r1
002a1b 9407                      	ror r0
002a1c fe13                      	sbrs r1, 3 //check if result was a negative number
002a1d c002                      	rjmp sound_driver_instrument_routine_channel1_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_negative:
002a1e efb0                      	ldi r27, 0xF0
002a1f 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_offset:
002a20 91a0 2882                 	lds r26, pulse2_total_pitch_offset
002a22 91b0 2883                 	lds r27, pulse2_total_pitch_offset+1
002a24 0e0a                      	add r0, r26
002a25 1e1b                      	adc r1, r27
002a26 9200 2882                 	sts pulse2_total_pitch_offset, r0
002a28 9210 2883                 	sts pulse2_total_pitch_offset+1, r1
002a2a 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
002a2c 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
002a2e 0da0                      	add r26, r0 //offset the timer values
002a2f 1db1                      	adc r27, r1
                                 	
002a30 91c0 2898                 	lds r28, pulse2_fx_1xx_total
002a32 91d0 2899                 	lds r29, pulse2_fx_1xx_total+1
002a34 1bac                      	sub r26, r28
002a35 0bbd                      	sbc r27, r29
002a36 91c0 289c                 	lds r28, pulse2_fx_2xx_total
002a38 91d0 289d                 	lds r29, pulse2_fx_2xx_total+1
002a3a 0fac                      	add r26, r28
002a3b 1fbd                      	adc r27, r29
002a3c 91c0 28b0                 	lds r28, pulse2_fx_Pxx_total
002a3e 91d0 28b1                 	lds r29, pulse2_fx_Pxx_total+1
002a40 0fac                      	add r26, r28
002a41 1fbd                      	adc r27, r29
002a42 91c0 28b6                 	lds r28, pulse2_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
002a44 91d0 28b7                 	lds r29, pulse2_fx_Qxy_total_offset+1
002a46 1bac                      	sub r26, r28
002a47 0bbd                      	sbc r27, r29
002a48 91c0 28bc                 	lds r28, pulse2_fx_Rxy_total_offset
002a4a 91d0 28bd                 	lds r29, pulse2_fx_Rxy_total_offset+1
002a4c 0fac                      	add r26, r28
002a4d 1fbd                      	adc r27, r29
                                 
002a4e 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
002a50 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel1_hi_pitch:
002a52 91e0 288a                 	lds ZL, pulse2_hi_pitch_macro
002a54 91f0 288b                 	lds ZH, pulse2_hi_pitch_macro+1
002a56 9630                      	adiw Z, 0
002a57 f409                      	brne sound_driver_instrument_routine_channel1_hi_pitch_continue
002a58 c03c                      	rjmp sound_driver_instrument_routine_channel1_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel1_hi_pitch_continue:
002a59 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002a5a 1fff                      	rol ZH
002a5b 91a0 288c                 	lds r26, pulse2_hi_pitch_macro_offset
002a5d 0fea                      	add ZL, r26
002a5e 1df2                      	adc ZH, zero
                                 
002a5f 91b0 288e                 	lds r27, pulse2_hi_pitch_macro_release
002a61 17ba                      	cp r27, r26
002a62 f429                      	brne sound_driver_instrument_routine_channel1_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002a63 91a0 288d                 	lds r26, pulse2_hi_pitch_macro_loop
002a65 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002a66 f010                      	brlo sound_driver_instrument_routine_channel1_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002a67 c003                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_increment:
002a68 95a3                      	inc r26 //increment the macro offset
002a69 93a0 288c                 	sts pulse2_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_hi_pitch_read:
002a6b 91b4                      	lpm r27, Z //load hi pitch data into r27
002a6c 38b0                      	cpi r27, 0x80 //check for macro end flag
002a6d f489                      	brne sound_driver_instrument_routine_channel1_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_release:
002a6e 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002a6f 93a0 288c                 	sts pulse2_hi_pitch_macro_offset, r26
002a71 91b0 288e                 	lds r27, pulse2_hi_pitch_macro_release
002a73 3fbf                      	cpi r27, 0xFF
002a74 f439                      	brne sound_driver_instrument_routine_channel1_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_loop:
002a75 91b0 288d                 	lds r27, pulse2_hi_pitch_macro_loop //load the loop index
002a77 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002a78 f019                      	breq sound_driver_instrument_routine_channel1_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002a79 93b0 288c                 	sts pulse2_hi_pitch_macro_offset, r27 //store the loop index into the offset
002a7b cfd6                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_default:
002a7c 91b0 2889                 	lds r27, pulse2_total_hi_pitch_offset
002a7e c005                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate:
002a7f 91a0 2889                 	lds r26, pulse2_total_hi_pitch_offset //load the total hi pitch offset to change
002a81 0fba                      	add r27, r26
002a82 93b0 2889                 	sts pulse2_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply:
002a84 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002a85 937f                      	push r23
002a86 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002a87 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002a88 0367                      	mulsu r22, r23
002a89 917f                      	pop r23
002a8a 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_offset:
002a8b 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
002a8d 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
002a8f 0da0                      	add r26, r0 //offset the timer values
002a90 1db1                      	adc r27, r1
002a91 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
002a93 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel1_duty:
002a95 91e0 288f                 	lds ZL, pulse2_duty_macro
002a97 91f0 2890                 	lds ZH, pulse2_duty_macro+1
002a99 9630                      	adiw Z, 0
002a9a f1b1                      	breq sound_driver_channel1_fx_routines //if no duty macro is in use, go to the next routine
002a9b 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002a9c 1fff                      	rol ZH
002a9d 91a0 2891                 	lds r26, pulse2_duty_macro_offset
002a9f 0fea                      	add ZL, r26
002aa0 1df2                      	adc ZH, zero
                                 
002aa1 91b0 2893                 	lds r27, pulse2_duty_macro_release
002aa3 17ba                      	cp r27, r26
002aa4 f429                      	brne sound_driver_instrument_routine_channel1_duty_increment //if the current offset is not equal to the release index, increment the offset
002aa5 91a0 2892                 	lds r26, pulse2_duty_macro_loop
002aa7 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002aa8 f010                      	brlo sound_driver_instrument_routine_channel1_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002aa9 c027                      	rjmp sound_driver_channel1_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel1_duty_increment:
002aaa 95a3                      	inc r26 //increment the macro offset
002aab 93a0 2891                 	sts pulse2_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_duty_read:
002aad 91b4                      	lpm r27, Z //load pitch data into r27
002aae 3fbf                      	cpi r27, 0xFF //check for macro end flag
002aaf f471                      	brne sound_driver_instrument_routine_channel1_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_release:
002ab0 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002ab1 93a0 2891                 	sts pulse2_duty_macro_offset, r26
002ab3 91b0 2893                 	lds r27, pulse2_duty_macro_release
002ab5 3fbf                      	cpi r27, 0xFF
002ab6 f4d1                      	brne sound_driver_channel1_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_loop:
002ab7 91b0 2892                 	lds r27, pulse2_duty_macro_loop //load the loop index
002ab9 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002aba f0b1                      	breq sound_driver_channel1_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
002abb 93b0 2891                 	sts pulse2_duty_macro_offset, r27 //store the loop index into the offset
002abd cfd7                      	rjmp sound_driver_instrument_routine_channel1_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_load:
002abe e9e6                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
002abf e6f4                      	ldi ZH, HIGH(sequences << 1)
002ac0 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
002ac1 1df2                      	adc ZH, zero
                                 
002ac2 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
002ac3 95b7                      	ror r27
002ac4 95b7                      	ror r27
002ac5 91a0 2808                 	lds r26, pulse2_param //load r26 with pulse2_param (register $4000)
002ac7 2fca                      	mov r28, r26 //store a copy of pulse2_param into r28
002ac8 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
002ac9 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
002aca c001                      	rjmp sound_driver_instrument_routine_channel1_duty_load_store
002acb c005                      	rjmp sound_driver_channel1_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel1_duty_load_store:
002acc 90d4                      	lpm pulse2_sequence, Z //store the sequence
                                 
002acd 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
002ace 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
002acf 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_routines:
                                 sound_driver_channel1_fx_1xx_routine:
002ad1 91e0 2896                 	lds ZL, pulse2_fx_1xx
002ad3 91f0 2897                 	lds ZH, pulse2_fx_1xx+1
002ad5 9630                      	adiw Z, 0
002ad6 f051                      	breq sound_driver_channel1_fx_2xx_routine
                                 
002ad7 91a0 2898                 	lds r26, pulse2_fx_1xx_total //load the rate to change the pitch by
002ad9 91b0 2899                 	lds r27, pulse2_fx_1xx_total+1
002adb 0fae                      	add r26, ZL //increase the total offset by the rate
002adc 1fbf                      	adc r27, ZH
002add 93a0 2898                 	sts pulse2_fx_1xx_total, r26
002adf 93b0 2899                 	sts pulse2_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_2xx_routine:
002ae1 91e0 289a                 	lds ZL, pulse2_fx_2xx
002ae3 91f0 289b                 	lds ZH, pulse2_fx_2xx+1
002ae5 9630                      	adiw Z, 0
002ae6 f051                      	breq sound_driver_channel1_fx_3xx_routine
                                 
002ae7 91a0 289c                 	lds r26, pulse2_fx_2xx_total //load the rate to change the pitch by
002ae9 91b0 289d                 	lds r27, pulse2_fx_2xx_total+1
002aeb 0fae                      	add r26, ZL //increase the total offset by the rate
002aec 1fbf                      	adc r27, ZH
002aed 93a0 289c                 	sts pulse2_fx_2xx_total, r26
002aef 93b0 289d                 	sts pulse2_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_3xx_routine:
002af1 91e0 28a2                 	lds ZL, pulse2_fx_3xx_speed
002af3 91f0 28a3                 	lds ZH, pulse2_fx_3xx_speed+1
002af5 9630                      	adiw Z, 0
002af6 f409                      	brne sound_driver_channel1_fx_3xx_routine_check_start
002af7 c048                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_check_start:
002af8 91a0 289e                 	lds r26, pulse2_fx_3xx_start
002afa 91b0 289f                 	lds r27, pulse2_fx_3xx_start+1
002afc 9610                      	adiw r26:r27, 0
002afd f409                      	brne sound_driver_channel1_fx_3xx_routine_main
002afe c041                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_main:
002aff 91c0 28a0                 	lds r28, pulse2_fx_3xx_target
002b01 91d0 28a1                 	lds r29, pulse2_fx_3xx_target+1
                                 
002b03 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
002b04 07bd                      	cpc r27, r29
002b05 f011                      	breq sound_driver_channel1_fx_3xx_routine_disable
002b06 f030                      	brlo sound_driver_channel1_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002b07 c01f                      	rjmp sound_driver_channel1_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel1_fx_3xx_routine_disable:
002b08 9220 289e                 	sts pulse2_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002b0a 9220 289f                 	sts pulse2_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002b0c c033                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_subtract:
002b0d 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002b0e 0bdb                      	sbc r29, r27
002b0f 91a0 28a4                 	lds r26, pulse2_fx_3xx_total_offset
002b11 91b0 28a5                 	lds r27, pulse2_fx_3xx_total_offset+1
                                 
002b13 0fae                      	add r26, ZL //add the speed to the total offset
002b14 1fbf                      	adc r27, ZH
002b15 1bca                      	sub r28, r26 //invert the total difference with the total offset
002b16 0bdb                      	sbc r29, r27
002b17 f380                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002b18 93a0 28a4                 	sts pulse2_fx_3xx_total_offset, r26 //store the new total offset
002b1a 93b0 28a5                 	sts pulse2_fx_3xx_total_offset+1, r27
                                 
002b1c 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the current timer period
002b1e 91b0 0a9d                 	lds r27, TCB1_CCMPH
002b20 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002b21 0bbd                      	sbc r27, r29
002b22 93a0 0a9c                 	sts TCB1_CCMPL, r26
002b24 93b0 0a9d                 	sts TCB1_CCMPH, r27
002b26 c019                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_add:
002b27 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002b28 0bbd                      	sbc r27, r29
002b29 91c0 28a4                 	lds r28, pulse2_fx_3xx_total_offset
002b2b 91d0 28a5                 	lds r29, pulse2_fx_3xx_total_offset+1
                                 
002b2d 0fce                      	add r28, ZL //add the speed to the total offset
002b2e 1fdf                      	adc r29, ZH
002b2f 1bac                      	sub r26, r28 //invert the total difference with the total offset
002b30 0bbd                      	sbc r27, r29
002b31 f2b0                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002b32 93c0 28a4                 	sts pulse2_fx_3xx_total_offset, r28 //store the new total offset
002b34 93d0 28a5                 	sts pulse2_fx_3xx_total_offset+1, r29
                                 
002b36 91c0 0a9c                 	lds r28, TCB1_CCMPL //load the current timer period
002b38 91d0 0a9d                 	lds r29, TCB1_CCMPH
002b3a 0fca                      	add r28, r26 //offset the current timer period with the total offset
002b3b 1fdb                      	adc r29, r27
002b3c 93c0 0a9c                 	sts TCB1_CCMPL, r28
002b3e 93d0 0a9d                 	sts TCB1_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel1_fx_4xy_routine:
002b40 91a0 28a6                 	lds r26, pulse2_fx_4xy_speed
002b42 15a2                      	cp r26, zero
002b43 f409                      	brne sound_driver_channel1_fx_4xy_routine_continue
002b44 c05c                      	rjmp sound_driver_channel1_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel1_fx_4xy_routine_continue:
002b45 91b0 28a7                 	lds r27, pulse2_fx_4xy_depth
002b47 91c0 28a8                 	lds r28, pulse2_fx_4xy_phase
002b49 0fca                      	add r28, r26 //increase the phase by the speed
002b4a 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
002b4b f008                      	brlo sound_driver_channel1_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002b4c 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase:
002b4d 93c0 28a8                 	sts pulse2_fx_4xy_phase, r28 //store the new phase
002b4f 31c0                      	cpi r28, 16
002b50 f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_0
002b51 32c0                      	cpi r28, 32
002b52 f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_1
002b53 33c0                      	cpi r28, 48
002b54 f030                      	brlo sound_driver_channel1_fx_4xy_routine_phase_2
002b55 c007                      	rjmp sound_driver_channel1_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_0:
002b56 70cf                      	andi r28, 0x0F //mask for values 0-15
002b57 c029                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_1:
002b58 6fc0                      	ori r28, 0xF0
002b59 95c0                      	com r28 //invert values 0-15
002b5a c026                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_2:
002b5b 70cf                      	andi r28, 0x0F //mask for values 0-15
002b5c c003                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_3:
002b5d 6fc0                      	ori r28, 0xF0
002b5e 95c0                      	com r28 //invert values 0-15
002b5f c000                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_add:
002b60 95b2                      	swap r27 //multiply depth by 16
002b61 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002b62 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002b63 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002b64 0fec                      	add ZL, r28 //offset the table by the depth+phase
002b65 1df2                      	adc ZH, zero
002b66 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002b67 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002b68 937f                      	push r23
002b69 2f6c                      	mov r22, r28 //store the vibrato value into r22
002b6a eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002b6b 9f67                      	mul r22, r23
002b6c 917f                      	pop r23
002b6d 916f                      	pop r22
                                 
002b6e 9416                      	lsr r1 //shift out the fractional bits
002b6f 9407                      	ror r0
002b70 9416                      	lsr r1
002b71 9407                      	ror r0
002b72 9416                      	lsr r1
002b73 9407                      	ror r0
002b74 9416                      	lsr r1
002b75 9407                      	ror r0
                                 	
002b76 91a0 0a9c                 	lds r26, TCB1_CCMPL
002b78 91b0 0a9d                 	lds r27, TCB1_CCMPH
002b7a 0da0                      	add r26, r0
002b7b 1db1                      	adc r27, r1
002b7c 93a0 0a9c                 	sts TCB1_CCMPL, r26
002b7e 93b0 0a9d                 	sts TCB1_CCMPH, r27
002b80 c020                      	rjmp sound_driver_channel1_fx_7xy_routine
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_subtract:
002b81 95b2                      	swap r27 //multiply depth by 16
002b82 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002b83 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002b84 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002b85 0fec                      	add ZL, r28 //offset the table by the depth+phase
002b86 1df2                      	adc ZH, zero
002b87 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002b88 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002b89 937f                      	push r23
002b8a 2f6c                      	mov r22, r28 //store the vibrato value into r22
002b8b eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002b8c 9f67                      	mul r22, r23
002b8d 917f                      	pop r23
002b8e 916f                      	pop r22
                                 
002b8f 9416                      	lsr r1 //shift out the fractional bits
002b90 9407                      	ror r0
002b91 9416                      	lsr r1
002b92 9407                      	ror r0
002b93 9416                      	lsr r1
002b94 9407                      	ror r0
002b95 9416                      	lsr r1
002b96 9407                      	ror r0
                                 
002b97 91a0 0a9c                 	lds r26, TCB1_CCMPL
002b99 91b0 0a9d                 	lds r27, TCB1_CCMPH
002b9b 19a0                      	sub r26, r0
002b9c 09b1                      	sbc r27, r1
002b9d 93a0 0a9c                 	sts TCB1_CCMPL, r26
002b9f 93b0 0a9d                 	sts TCB1_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_7xy_routine:
002ba1 91a0 28a9                 	lds r26, pulse2_fx_7xy_speed
002ba3 15a2                      	cp r26, zero
002ba4 f0f1                      	breq sound_driver_channel1_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
002ba5 91b0 28aa                 	lds r27, pulse2_fx_7xy_depth
002ba7 91c0 28ab                 	lds r28, pulse2_fx_7xy_phase
002ba9 0fca                      	add r28, r26 //increase the phase by the speed
002baa 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
002bab f010                      	brlo sound_driver_channel1_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
002bac e0c0                      	ldi r28, 0x00
002bad 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase:
002bae 93c0 28ab                 	sts pulse2_fx_7xy_phase, r28 //store the new phase
002bb0 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
002bb1 ffc4                      	sbrs r28, 4
002bb2 c001                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_0
002bb3 c002                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel1_fx_7xy_routine_phase_0:
002bb4 70cf                      	andi r28, 0x0F //mask for values 0-15
002bb5 c003                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase_1:
002bb6 6fc0                      	ori r28, 0xF0
002bb7 95c0                      	com r28 //invert values 0-15
002bb8 c000                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_load:
002bb9 95b2                      	swap r27 //multiply depth by 16
002bba 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002bbb e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002bbc e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002bbd 0fec                      	add ZL, r28 //offset the table by the depth+phase
002bbe 1df2                      	adc ZH, zero
002bbf 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002bc0 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
002bc1 93c0 28ac                 	sts pulse2_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Axy_routine:
002bc3 91b0 28ad                 	lds r27, pulse2_fx_Axy
002bc5 15b2                      	cp r27, zero
002bc6 f0e9                      	breq sound_driver_channel1_fx_Qxy_routine //0 means that the effect is not in use
                                 	
002bc7 91a0 280d                 	lds r26, pulse2_fractional_volume //load fractional volume representation of the channel
002bc9 91c0 2808                 	lds r28, pulse2_param //load the integer volume representation of the channel
002bcb 2fda                      	mov r29, r26 //copy fractional volume into r29
002bcc 2fec                      	mov r30, r28 //copy the pulse2_param into r30
002bcd 95e2                      	swap r30
002bce 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
002bcf 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
002bd0 17ed                      	cp r30, r29 //compare the fractional and integer volumes
002bd1 f009                      	breq sound_driver_channel1_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel1_fx_Axy_routine_reload:
002bd2 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate:
002bd3 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
002bd4 c004                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_addition:
002bd5 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002bd6 f428                      	brcc sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002bd7 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
002bd8 c003                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_subtraction:
002bd9 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002bda f008                      	brcs sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002bdb e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_store:
002bdc 93a0 280d                 	sts pulse2_fractional_volume, r26 //store the new fractional volume
002bde 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
002bdf 95a2                      	swap r26
002be0 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
002be1 2bca                      	or r28, r26 //store the new volume back into pulse2_param
002be2 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel1_fx_Qxy_routine:
002be4 91e0 28b2                 	lds ZL, pulse2_fx_Qxy_target
002be6 91f0 28b3                 	lds ZH, pulse2_fx_Qxy_target+1
002be8 9630                      	adiw Z, 0
002be9 f139                      	breq sound_driver_channel1_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002bea 91a0 28b6                 	lds r26, pulse2_fx_Qxy_total_offset
002bec 91b0 28b7                 	lds r27, pulse2_fx_Qxy_total_offset+1
002bee 91c0 0a9c                 	lds r28, TCB1_CCMPL
002bf0 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
002bf2 1bec                      	sub ZL, r28 //calculate the difference to the target
002bf3 0bfd                      	sbc ZH, r29
002bf4 f408                      	brsh sound_driver_channel1_fx_Qxy_routine_end //if the target has been reached (or passed)
002bf5 f088                      	brlo sound_driver_channel1_fx_Qxy_routine_add
                                 
                                 sound_driver_channel1_fx_Qxy_routine_end:
002bf6 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
002bf7 0bbf                      	sbc r27, ZH
                                 
002bf8 91c0 28b0                 	lds r28, pulse2_fx_Pxx_total
002bfa 91d0 28b1                 	lds r29, pulse2_fx_Pxx_total+1
                                 
002bfc 0fac                      	add r26, r28
002bfd 1fbd                      	adc r27, r29
                                 
002bfe 93a0 28b6                 	sts pulse2_fx_Qxy_total_offset, r26 //store the total offset
002c00 93b0 28b7                 	sts pulse2_fx_Qxy_total_offset+1, r27
002c02 9220 28b2                 	sts pulse2_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
002c04 9220 28b3                 	sts pulse2_fx_Qxy_target+1, zero
002c06 c00a                      	rjmp sound_driver_channel1_fx_Rxy_routine
                                 
                                 sound_driver_channel1_fx_Qxy_routine_add:
002c07 91c0 28b4                 	lds r28, pulse2_fx_Qxy_speed
002c09 91d0 28b5                 	lds r29, pulse2_fx_Qxy_speed+1
002c0b 0fac                      	add r26, r28 //increase the total offset by the speed
002c0c 1fbd                      	adc r27, r29
002c0d 93a0 28b6                 	sts pulse2_fx_Qxy_total_offset, r26 //store the total offset
002c0f 93b0 28b7                 	sts pulse2_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Rxy_routine:
002c11 91e0 28b8                 	lds ZL, pulse2_fx_Rxy_target
002c13 91f0 28b9                 	lds ZH, pulse2_fx_Rxy_target+1
002c15 9630                      	adiw Z, 0
002c16 f139                      	breq sound_driver_instrument_routine_channel2_volume //if the effect is not enabled, skip the routine
                                 
002c17 91a0 28bc                 	lds r26, pulse2_fx_Rxy_total_offset
002c19 91b0 28bd                 	lds r27, pulse2_fx_Rxy_total_offset+1
002c1b 91c0 0a9c                 	lds r28, TCB1_CCMPL
002c1d 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
002c1f 1bce                      	sub r28, ZL //calculate the difference to the target
002c20 0bdf                      	sbc r29, ZH
002c21 f408                      	brsh sound_driver_channel1_fx_Rxy_routine_end //if the target has been reached (or passed)
002c22 f088                      	brlo sound_driver_channel1_fx_Rxy_routine_add
                                 
                                 sound_driver_channel1_fx_Rxy_routine_end:
002c23 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
002c24 0bbd                      	sbc r27, r29
                                 
002c25 91c0 28b0                 	lds r28, pulse2_fx_Pxx_total
002c27 91d0 28b1                 	lds r29, pulse2_fx_Pxx_total+1
                                 
002c29 0fac                      	add r26, r28
002c2a 1fbd                      	adc r27, r29
                                 
002c2b 93a0 28bc                 	sts pulse2_fx_Rxy_total_offset, r26 //store the total offset
002c2d 93b0 28bd                 	sts pulse2_fx_Rxy_total_offset+1, r27
002c2f 9220 28b8                 	sts pulse2_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
002c31 9220 28b9                 	sts pulse2_fx_Rxy_target+1, zero
002c33 c00a                      	rjmp sound_driver_instrument_routine_channel2_volume
                                 
                                 sound_driver_channel1_fx_Rxy_routine_add:
002c34 91c0 28ba                 	lds r28, pulse2_fx_Rxy_speed
002c36 91d0 28bb                 	lds r29, pulse2_fx_Rxy_speed+1
002c38 0fac                      	add r26, r28 //increase the total offset by the speed
002c39 1fbd                      	adc r27, r29
002c3a 93a0 28bc                 	sts pulse2_fx_Rxy_total_offset, r26 //store the total offset
002c3c 93b0 28bd                 	sts pulse2_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume:
002c3e 91e0 28c6                 	lds ZL, triangle_volume_macro
002c40 91f0 28c7                 	lds ZH, triangle_volume_macro+1
002c42 9630                      	adiw Z, 0
002c43 f199                      	breq sound_driver_instrument_routine_channel2_volume_default //if no volume macro is in use, do nothing
002c44 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002c45 1fff                      	rol ZH
002c46 91a0 28c8                 	lds r26, triangle_volume_macro_offset
002c48 0fea                      	add ZL, r26
002c49 1df2                      	adc ZH, zero
                                 
002c4a 91b0 28ca                 	lds r27, triangle_volume_macro_release
002c4c 17ba                      	cp r27, r26
002c4d f429                      	brne sound_driver_instrument_routine_channel2_volume_increment //if the current offset is not equal to the release index, increment the offset
002c4e 91a0 28c9                 	lds r26, triangle_volume_macro_loop
002c50 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002c51 f010                      	brlo sound_driver_instrument_routine_channel2_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002c52 c003                      	rjmp sound_driver_instrument_routine_channel2_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_volume_increment:
002c53 95a3                      	inc r26 //increment the macro offset
002c54 93a0 28c8                 	sts triangle_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_volume_read:
002c56 91b4                      	lpm r27, Z //load volume data into r27
002c57 3fbf                      	cpi r27, 0xFF //check for macro end flag
002c58 f469                      	brne sound_driver_instrument_routine_channel2_volume_process //if the data was not the macro end flag
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_release:
002c59 91b0 28ca                 	lds r27, triangle_volume_macro_release
002c5b 3fbf                      	cpi r27, 0xFF
002c5c f429                      	brne sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_loop:
002c5d 91b0 28c9                 	lds r27, triangle_volume_macro_loop //load the loop index
002c5f 93b0 28c8                 	sts triangle_volume_macro_offset, r27 //store the loop index into the offset
002c61 cfdc                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index:
002c62 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002c63 93a0 28c8                 	sts triangle_volume_macro_offset, r26
002c65 cfd8                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_process:
002c66 15b2                      	cp r27, zero
002c67 f041                      	breq sound_driver_instrument_routine_channel2_volume_process_disable
                                 sound_driver_instrument_routine_channel2_volume_process_enable:
002c68 91b0 0aa5                 	lds r27, TCB2_INTCTRL
002c6a 30b1                      	cpi r27, TCB_CAPT_bm
002c6b f459                      	brne sound_driver_instrument_routine_channel2_volume_default //if the channel has already been muted, don't enable it again
002c6c e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
002c6d 93b0 0aa5                 	sts TCB2_INTCTRL, r27
002c6f c007                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 sound_driver_instrument_routine_channel2_volume_process_disable:
002c70 9220 0aa5                 	sts TCB2_INTCTRL, zero
002c72 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
002c74 9220 0aad                 	sts TCB2_CCMPH, zero
002c76 c000                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_volume_default:
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002c77 91e0 28cb                 	lds ZL, triangle_arpeggio_macro
002c79 91f0 28cc                 	lds ZH, triangle_arpeggio_macro+1
002c7b 9630                      	adiw Z, 0
002c7c f1d9                      	breq sound_driver_instrument_routine_channel2_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002c7d 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002c7e 1fff                      	rol ZH
002c7f 91a0 28cd                 	lds r26, triangle_arpeggio_macro_offset
002c81 0fea                      	add ZL, r26
002c82 1df2                      	adc ZH, zero
                                 
002c83 91b0 28cf                 	lds r27, triangle_arpeggio_macro_release
002c85 17ba                      	cp r27, r26
002c86 f429                      	brne sound_driver_instrument_routine_channel2_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002c87 91a0 28ce                 	lds r26, triangle_arpeggio_macro_loop
002c89 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002c8a f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002c8b c003                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_increment:
002c8c 95a3                      	inc r26 //increment the macro offset
002c8d 93a0 28cd                 	sts triangle_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_read:
002c8f 91b4                      	lpm r27, Z //load arpeggio data into r27
002c90 38b0                      	cpi r27, 0x80 //check for macro end flag
002c91 f009                      	breq sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag
002c92 c041                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_check_mode:
002c93 50a1                      	subi r26, 1 //keep the offset at the end flag
002c94 93a0 28cd                 	sts triangle_arpeggio_macro_offset, r26
002c96 91b0 28d0                 	lds r27, triangle_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002c98 30b1                      	cpi r27, 0x01
002c99 f048                      	brlo sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_release:
002c9a 91b0 28cf                 	lds r27, triangle_arpeggio_macro_release
002c9c 3fbf                      	cpi r27, 0xFF
002c9d f4d1                      	brne sound_driver_instrument_routine_channel2_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_loop:
002c9e 91b0 28ce                 	lds r27, triangle_arpeggio_macro_loop
002ca0 3fbf                      	cpi r27, 0xFF
002ca1 f499                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002ca2 c015                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute:
002ca3 91b0 28cf                 	lds r27, triangle_arpeggio_macro_release
002ca5 3fbf                      	cpi r27, 0xFF
002ca6 f421                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_check_loop:
002ca7 91b0 28ce                 	lds r27, triangle_arpeggio_macro_loop //load the loop index
002ca9 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002caa f451                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop:
002cab 91c0 28e3                 	lds r28, triangle_fx_0xy_sequence //check for 0xy effect
002cad 91d0 28e4                 	lds r29, triangle_fx_0xy_sequence+1
002caf 9620                      	adiw r29:r28, 0
002cb0 f469                      	brne sound_driver_instrument_routine_channel2_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002cb1 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002cb2 93a0 28cd                 	sts triangle_arpeggio_macro_offset, r26 //store the last valid index into the offset
002cb4 cfc2                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload:
002cb5 93b0 28cd                 	sts triangle_arpeggio_macro_offset, r27 //store the loop index into the offset
002cb7 cfbf                      	rjmp sound_driver_instrument_routine_channel2_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_default:
002cb8 91c0 28e3                 	lds r28, triangle_fx_0xy_sequence //load 0xy effect
002cba 91d0 28e4                 	lds r29, triangle_fx_0xy_sequence+1
002cbc 9620                      	adiw r29:r28, 0 //check for 0xy effect
002cbd f099                      	breq sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel2_arpeggio_default_xy:
002cbe 95d6                      	lsr r29
002cbf 95c7                      	ror r28
002cc0 95d7                      	ror r29
002cc1 95c7                      	ror r28
002cc2 95d7                      	ror r29
002cc3 95c7                      	ror r28
002cc4 95d7                      	ror r29
002cc5 95c7                      	ror r28
002cc6 95d7                      	ror r29
002cc7 95d2                      	swap r29
                                 
002cc8 93c0 28e3                 	sts triangle_fx_0xy_sequence, r28 //store the rolled sequence
002cca 93d0 28e4                 	sts triangle_fx_0xy_sequence+1, r29
002ccc 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002ccd 91a0 2812                 	lds r26, triangle_note //load the current note index
002ccf 0fac                      	add r26, r28 //add the note offset
002cd0 c02e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002cd1 91a0 2812                 	lds r26, triangle_note //load the current note index
002cd3 c02b                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process:
002cd4 9220 28d1                 	sts triangle_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002cd6 9220 28d2                 	sts triangle_total_pitch_offset+1, zero
002cd8 9220 28d8                 	sts triangle_total_hi_pitch_offset, zero
002cda 91a0 28d0                 	lds r26, triangle_arpeggio_macro_mode
002cdc 30a1                      	cpi r26, 0x01 //absolute mode
002cdd f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_absolute
002cde f069                      	breq sound_driver_instrument_routine_channel2_arpeggio_process_fixed
002cdf c00e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute:
002ce0 91a0 2812                 	lds r26, triangle_note //load the current note index
002ce2 0fab                      	add r26, r27 //offset the note with the arpeggio data
002ce3 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002ce4 c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_add:
002ce5 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002ce6 f0c0                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
002ce7 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002ce8 c016                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract:
002ce9 fda7                      	sbrc r26, 7 //check if result is negative
002cea e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002ceb c013                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_fixed:
002cec 2fab                      	mov r26, r27 //move the arpeggio data into r26
002ced c011                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative:
002cee 91a0 2812                 	lds r26, triangle_note //load the current note index
002cf0 0fab                      	add r26, r27 //offset the note with the arpeggio data
002cf1 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002cf2 c008                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_add:
002cf3 93a0 2812                 	sts triangle_note, r26 //NOTE: relative mode modifies the original note index
002cf5 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002cf6 f040                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
002cf7 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002cf8 93a0 2812                 	sts triangle_note, r26
002cfa c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract:
002cfb fda7                      	sbrc r26, 7 //check if result is negative
002cfc e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002cfd 93a0 2812                 	sts triangle_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_load:
002cff e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
002d00 e0f0                      	ldi ZH, HIGH(note_table << 1)
002d01 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002d02 0fea                      	add ZL, r26 //add offset
002d03 1df2                      	adc ZH, zero
002d04 91a5                      	lpm r26, Z+ //load bytes
002d05 91b4                      	lpm r27, Z
002d06 93a0 0aac                 	sts TCB2_CCMPL, r26 //load the LOW bits for timer
002d08 93b0 0aad                 	sts TCB2_CCMPH, r27 //load the HIGH bits for timer
002d0a 93a0 28ef                 	sts triangle_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002d0c 93b0 28f0                 	sts triangle_fx_3xx_target+1, r27
002d0e c000                      	rjmp sound_driver_instrument_routine_channel2_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch:
002d0f 91e0 28d3                 	lds ZL, triangle_pitch_macro
002d11 91f0 28d4                 	lds ZH, triangle_pitch_macro+1
002d13 9630                      	adiw Z, 0
002d14 f409                      	brne sound_driver_instrument_routine_channel2_pitch_continue
002d15 c023                      	rjmp sound_driver_instrument_routine_channel2_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel2_pitch_continue:
002d16 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002d17 1fff                      	rol ZH
002d18 91a0 28d5                 	lds r26, triangle_pitch_macro_offset
002d1a 0fea                      	add ZL, r26
002d1b 1df2                      	adc ZH, zero
                                 
002d1c 91b0 28d7                 	lds r27, triangle_pitch_macro_release
002d1e 17ba                      	cp r27, r26
002d1f f429                      	brne sound_driver_instrument_routine_channel2_pitch_increment //if the current offset is not equal to the release index, increment the offset
002d20 91a0 28d6                 	lds r26, triangle_pitch_macro_loop
002d22 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002d23 f010                      	brlo sound_driver_instrument_routine_channel2_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002d24 c003                      	rjmp sound_driver_instrument_routine_channel2_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_pitch_increment:
002d25 95a3                      	inc r26 //increment the macro offset
002d26 93a0 28d5                 	sts triangle_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_pitch_read:
002d28 91b4                      	lpm r27, Z //load pitch data into r27
002d29 38b0                      	cpi r27, 0x80 //check for macro end flag
002d2a f479                      	brne sound_driver_instrument_routine_channel2_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_release:
002d2b 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002d2c 93a0 28d5                 	sts triangle_pitch_macro_offset, r26
002d2e 91b0 28d7                 	lds r27, triangle_pitch_macro_release
002d30 3fbf                      	cpi r27, 0xFF
002d31 f439                      	brne sound_driver_instrument_routine_channel2_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_loop:
002d32 91b0 28d6                 	lds r27, triangle_pitch_macro_loop //load the loop index
002d34 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002d35 f019                      	breq sound_driver_instrument_routine_channel2_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002d36 93b0 28d5                 	sts triangle_pitch_macro_offset, r27 //store the loop index into the offset
002d38 cfd6                      	rjmp sound_driver_instrument_routine_channel2_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_default:
002d39 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel2_pitch_calculate:
002d3a 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002d3b 937f                      	push r23
002d3c 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
002d3d eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002d3e 0367                      	mulsu r22, r23
002d3f 917f                      	pop r23
002d40 916f                      	pop r22
                                 
002d41 9416                      	lsr r1 //shift out the fractional bits
002d42 9407                      	ror r0
002d43 9416                      	lsr r1
002d44 9407                      	ror r0
002d45 9416                      	lsr r1
002d46 9407                      	ror r0
002d47 9416                      	lsr r1
002d48 9407                      	ror r0
002d49 fe13                      	sbrs r1, 3 //check if result was a negative number
002d4a c002                      	rjmp sound_driver_instrument_routine_channel2_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_negative:
002d4b efb0                      	ldi r27, 0xF0
002d4c 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_offset:
002d4d 91a0 28d1                 	lds r26, triangle_total_pitch_offset
002d4f 91b0 28d2                 	lds r27, triangle_total_pitch_offset+1
002d51 0e0a                      	add r0, r26
002d52 1e1b                      	adc r1, r27
002d53 9200 28d1                 	sts triangle_total_pitch_offset, r0
002d55 9210 28d2                 	sts triangle_total_pitch_offset+1, r1
002d57 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
002d59 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
002d5b 0da0                      	add r26, r0 //offset the timer values
002d5c 1db1                      	adc r27, r1
                                 	
002d5d 91c0 28e7                 	lds r28, triangle_fx_1xx_total
002d5f 91d0 28e8                 	lds r29, triangle_fx_1xx_total+1
002d61 1bac                      	sub r26, r28
002d62 0bbd                      	sbc r27, r29
002d63 91c0 28eb                 	lds r28, triangle_fx_2xx_total
002d65 91d0 28ec                 	lds r29, triangle_fx_2xx_total+1
002d67 0fac                      	add r26, r28
002d68 1fbd                      	adc r27, r29
002d69 91c0 28fa                 	lds r28, triangle_fx_Pxx_total
002d6b 91d0 28fb                 	lds r29, triangle_fx_Pxx_total+1
002d6d 0fac                      	add r26, r28
002d6e 1fbd                      	adc r27, r29
002d6f 91c0 2900                 	lds r28, triangle_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
002d71 91d0 2901                 	lds r29, triangle_fx_Qxy_total_offset+1
002d73 1bac                      	sub r26, r28
002d74 0bbd                      	sbc r27, r29
002d75 91c0 2906                 	lds r28, triangle_fx_Rxy_total_offset
002d77 91d0 2907                 	lds r29, triangle_fx_Rxy_total_offset+1
002d79 0fac                      	add r26, r28
002d7a 1fbd                      	adc r27, r29
                                 
002d7b 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
002d7d 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel2_hi_pitch:
002d7f 91e0 28d9                 	lds ZL, triangle_hi_pitch_macro
002d81 91f0 28da                 	lds ZH, triangle_hi_pitch_macro+1
002d83 9630                      	adiw Z, 0
002d84 f409                      	brne sound_driver_instrument_routine_channel2_hi_pitch_continue
002d85 c03c                      	rjmp sound_driver_instrument_routine_channel2_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel2_hi_pitch_continue:
002d86 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002d87 1fff                      	rol ZH
002d88 91a0 28db                 	lds r26, triangle_hi_pitch_macro_offset
002d8a 0fea                      	add ZL, r26
002d8b 1df2                      	adc ZH, zero
                                 
002d8c 91b0 28dd                 	lds r27, triangle_hi_pitch_macro_release
002d8e 17ba                      	cp r27, r26
002d8f f429                      	brne sound_driver_instrument_routine_channel2_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002d90 91a0 28dc                 	lds r26, triangle_hi_pitch_macro_loop
002d92 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002d93 f010                      	brlo sound_driver_instrument_routine_channel2_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002d94 c003                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_increment:
002d95 95a3                      	inc r26 //increment the macro offset
002d96 93a0 28db                 	sts triangle_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_hi_pitch_read:
002d98 91b4                      	lpm r27, Z //load hi pitch data into r27
002d99 38b0                      	cpi r27, 0x80 //check for macro end flag
002d9a f489                      	brne sound_driver_instrument_routine_channel2_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_release:
002d9b 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002d9c 93a0 28db                 	sts triangle_hi_pitch_macro_offset, r26
002d9e 91b0 28dd                 	lds r27, triangle_hi_pitch_macro_release
002da0 3fbf                      	cpi r27, 0xFF
002da1 f439                      	brne sound_driver_instrument_routine_channel2_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_loop:
002da2 91b0 28dc                 	lds r27, triangle_hi_pitch_macro_loop //load the loop index
002da4 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002da5 f019                      	breq sound_driver_instrument_routine_channel2_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002da6 93b0 28db                 	sts triangle_hi_pitch_macro_offset, r27 //store the loop index into the offset
002da8 cfd6                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_default:
002da9 91b0 28d8                 	lds r27, triangle_total_hi_pitch_offset
002dab c005                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate:
002dac 91a0 28d8                 	lds r26, triangle_total_hi_pitch_offset //load the total hi pitch offset to change
002dae 0fba                      	add r27, r26
002daf 93b0 28d8                 	sts triangle_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply:
002db1 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002db2 937f                      	push r23
002db3 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002db4 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002db5 0367                      	mulsu r22, r23
002db6 917f                      	pop r23
002db7 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_offset:
002db8 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
002dba 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
002dbc 0da0                      	add r26, r0 //offset the timer values
002dbd 1db1                      	adc r27, r1
002dbe 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
002dc0 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: The triangle channel does not have a duty cycle
                                 sound_driver_instrument_routine_channel2_duty:
                                 
                                 
                                 
                                 sound_driver_channel2_fx_routines:
                                 sound_driver_channel2_fx_1xx_routine:
002dc2 91e0 28e5                 	lds ZL, triangle_fx_1xx
002dc4 91f0 28e6                 	lds ZH, triangle_fx_1xx+1
002dc6 9630                      	adiw Z, 0
002dc7 f051                      	breq sound_driver_channel2_fx_2xx_routine
                                 
002dc8 91a0 28e7                 	lds r26, triangle_fx_1xx_total //load the rate to change the pitch by
002dca 91b0 28e8                 	lds r27, triangle_fx_1xx_total+1
002dcc 0fae                      	add r26, ZL //increase the total offset by the rate
002dcd 1fbf                      	adc r27, ZH
002dce 93a0 28e7                 	sts triangle_fx_1xx_total, r26
002dd0 93b0 28e8                 	sts triangle_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_2xx_routine:
002dd2 91e0 28e9                 	lds ZL, triangle_fx_2xx
002dd4 91f0 28ea                 	lds ZH, triangle_fx_2xx+1
002dd6 9630                      	adiw Z, 0
002dd7 f051                      	breq sound_driver_channel2_fx_3xx_routine
                                 
002dd8 91a0 28eb                 	lds r26, triangle_fx_2xx_total //load the rate to change the pitch by
002dda 91b0 28ec                 	lds r27, triangle_fx_2xx_total+1
002ddc 0fae                      	add r26, ZL //increase the total offset by the rate
002ddd 1fbf                      	adc r27, ZH
002dde 93a0 28eb                 	sts triangle_fx_2xx_total, r26
002de0 93b0 28ec                 	sts triangle_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_3xx_routine:
002de2 91e0 28f1                 	lds ZL, triangle_fx_3xx_speed
002de4 91f0 28f2                 	lds ZH, triangle_fx_3xx_speed+1
002de6 9630                      	adiw Z, 0
002de7 f409                      	brne sound_driver_channel2_fx_3xx_routine_check_start
002de8 c048                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_check_start:
002de9 91a0 28ed                 	lds r26, triangle_fx_3xx_start
002deb 91b0 28ee                 	lds r27, triangle_fx_3xx_start+1
002ded 9610                      	adiw r26:r27, 0
002dee f409                      	brne sound_driver_channel2_fx_3xx_routine_main
002def c041                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_main:
002df0 91c0 28ef                 	lds r28, triangle_fx_3xx_target
002df2 91d0 28f0                 	lds r29, triangle_fx_3xx_target+1
                                 
002df4 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
002df5 07bd                      	cpc r27, r29
002df6 f011                      	breq sound_driver_channel2_fx_3xx_routine_disable
002df7 f030                      	brlo sound_driver_channel2_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002df8 c01f                      	rjmp sound_driver_channel2_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel2_fx_3xx_routine_disable:
002df9 9220 28ed                 	sts triangle_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002dfb 9220 28ee                 	sts triangle_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002dfd c033                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_subtract:
002dfe 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002dff 0bdb                      	sbc r29, r27
002e00 91a0 28f3                 	lds r26, triangle_fx_3xx_total_offset
002e02 91b0 28f4                 	lds r27, triangle_fx_3xx_total_offset+1
                                 
002e04 0fae                      	add r26, ZL //add the speed to the total offset
002e05 1fbf                      	adc r27, ZH
002e06 1bca                      	sub r28, r26 //invert the total difference with the total offset
002e07 0bdb                      	sbc r29, r27
002e08 f380                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002e09 93a0 28f3                 	sts triangle_fx_3xx_total_offset, r26 //store the new total offset
002e0b 93b0 28f4                 	sts triangle_fx_3xx_total_offset+1, r27
                                 
002e0d 91a0 0aac                 	lds r26, TCB2_CCMPL //load the current timer period
002e0f 91b0 0aad                 	lds r27, TCB2_CCMPH
002e11 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002e12 0bbd                      	sbc r27, r29
002e13 93a0 0aac                 	sts TCB2_CCMPL, r26
002e15 93b0 0aad                 	sts TCB2_CCMPH, r27
002e17 c019                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_add:
002e18 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002e19 0bbd                      	sbc r27, r29
002e1a 91c0 28f3                 	lds r28, triangle_fx_3xx_total_offset
002e1c 91d0 28f4                 	lds r29, triangle_fx_3xx_total_offset+1
                                 
002e1e 0fce                      	add r28, ZL //add the speed to the total offset
002e1f 1fdf                      	adc r29, ZH
002e20 1bac                      	sub r26, r28 //invert the total difference with the total offset
002e21 0bbd                      	sbc r27, r29
002e22 f2b0                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002e23 93c0 28f3                 	sts triangle_fx_3xx_total_offset, r28 //store the new total offset
002e25 93d0 28f4                 	sts triangle_fx_3xx_total_offset+1, r29
                                 
002e27 91c0 0aac                 	lds r28, TCB2_CCMPL //load the current timer period
002e29 91d0 0aad                 	lds r29, TCB2_CCMPH
002e2b 0fca                      	add r28, r26 //offset the current timer period with the total offset
002e2c 1fdb                      	adc r29, r27
002e2d 93c0 0aac                 	sts TCB2_CCMPL, r28
002e2f 93d0 0aad                 	sts TCB2_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel2_fx_4xy_routine:
002e31 91a0 28f5                 	lds r26, triangle_fx_4xy_speed
002e33 15a2                      	cp r26, zero
002e34 f409                      	brne sound_driver_channel2_fx_4xy_routine_continue
002e35 c05c                      	rjmp sound_driver_channel2_fx_Qxy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel2_fx_4xy_routine_continue:
002e36 91b0 28f6                 	lds r27, triangle_fx_4xy_depth
002e38 91c0 28f7                 	lds r28, triangle_fx_4xy_phase
002e3a 0fca                      	add r28, r26 //increase the phase by the speed
002e3b 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
002e3c f008                      	brlo sound_driver_channel2_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002e3d 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase:
002e3e 93c0 28f7                 	sts triangle_fx_4xy_phase, r28 //store the new phase
002e40 31c0                      	cpi r28, 16
002e41 f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_0
002e42 32c0                      	cpi r28, 32
002e43 f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_1
002e44 33c0                      	cpi r28, 48
002e45 f030                      	brlo sound_driver_channel2_fx_4xy_routine_phase_2
002e46 c007                      	rjmp sound_driver_channel2_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_0:
002e47 70cf                      	andi r28, 0x0F //mask for values 0-15
002e48 c029                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_1:
002e49 6fc0                      	ori r28, 0xF0
002e4a 95c0                      	com r28 //invert values 0-15
002e4b c026                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_2:
002e4c 70cf                      	andi r28, 0x0F //mask for values 0-15
002e4d c003                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_3:
002e4e 6fc0                      	ori r28, 0xF0
002e4f 95c0                      	com r28 //invert values 0-15
002e50 c000                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_add:
002e51 95b2                      	swap r27 //multiply depth by 16
002e52 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002e53 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002e54 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002e55 0fec                      	add ZL, r28 //offset the table by the depth+phase
002e56 1df2                      	adc ZH, zero
002e57 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002e58 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002e59 937f                      	push r23
002e5a 2f6c                      	mov r22, r28 //store the vibrato value into r22
002e5b eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002e5c 9f67                      	mul r22, r23
002e5d 917f                      	pop r23
002e5e 916f                      	pop r22
                                 
002e5f 9416                      	lsr r1 //shift out the fractional bits
002e60 9407                      	ror r0
002e61 9416                      	lsr r1
002e62 9407                      	ror r0
002e63 9416                      	lsr r1
002e64 9407                      	ror r0
002e65 9416                      	lsr r1
002e66 9407                      	ror r0
                                 	
002e67 91a0 0aac                 	lds r26, TCB2_CCMPL
002e69 91b0 0aad                 	lds r27, TCB2_CCMPH
002e6b 0da0                      	add r26, r0
002e6c 1db1                      	adc r27, r1
002e6d 93a0 0aac                 	sts TCB2_CCMPL, r26
002e6f 93b0 0aad                 	sts TCB2_CCMPH, r27
002e71 c020                      	rjmp sound_driver_channel2_fx_Qxy_routine
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_subtract:
002e72 95b2                      	swap r27 //multiply depth by 16
002e73 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002e74 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002e75 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002e76 0fec                      	add ZL, r28 //offset the table by the depth+phase
002e77 1df2                      	adc ZH, zero
002e78 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002e79 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002e7a 937f                      	push r23
002e7b 2f6c                      	mov r22, r28 //store the vibrato value into r22
002e7c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002e7d 9f67                      	mul r22, r23
002e7e 917f                      	pop r23
002e7f 916f                      	pop r22
                                 
002e80 9416                      	lsr r1 //shift out the fractional bits
002e81 9407                      	ror r0
002e82 9416                      	lsr r1
002e83 9407                      	ror r0
002e84 9416                      	lsr r1
002e85 9407                      	ror r0
002e86 9416                      	lsr r1
002e87 9407                      	ror r0
                                 
002e88 91a0 0aac                 	lds r26, TCB2_CCMPL
002e8a 91b0 0aad                 	lds r27, TCB2_CCMPH
002e8c 19a0                      	sub r26, r0
002e8d 09b1                      	sbc r27, r1
002e8e 93a0 0aac                 	sts TCB2_CCMPL, r26
002e90 93b0 0aad                 	sts TCB2_CCMPH, r27
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel2_fx_Qxy_routine:
002e92 91e0 28fc                 	lds ZL, triangle_fx_Qxy_target
002e94 91f0 28fd                 	lds ZH, triangle_fx_Qxy_target+1
002e96 9630                      	adiw Z, 0
002e97 f139                      	breq sound_driver_channel2_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002e98 91a0 2900                 	lds r26, triangle_fx_Qxy_total_offset
002e9a 91b0 2901                 	lds r27, triangle_fx_Qxy_total_offset+1
002e9c 91c0 0aac                 	lds r28, TCB2_CCMPL
002e9e 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
002ea0 1bec                      	sub ZL, r28 //calculate the difference to the target
002ea1 0bfd                      	sbc ZH, r29
002ea2 f408                      	brsh sound_driver_channel2_fx_Qxy_routine_end //if the target has been reached (or passed)
002ea3 f088                      	brlo sound_driver_channel2_fx_Qxy_routine_add
                                 
                                 sound_driver_channel2_fx_Qxy_routine_end:
002ea4 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
002ea5 0bbf                      	sbc r27, ZH
                                 
002ea6 91c0 28fa                 	lds r28, triangle_fx_Pxx_total
002ea8 91d0 28fb                 	lds r29, triangle_fx_Pxx_total+1
                                 
002eaa 0fac                      	add r26, r28
002eab 1fbd                      	adc r27, r29
                                 
002eac 93a0 2900                 	sts triangle_fx_Qxy_total_offset, r26 //store the total offset
002eae 93b0 2901                 	sts triangle_fx_Qxy_total_offset+1, r27
002eb0 9220 28fc                 	sts triangle_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
002eb2 9220 28fd                 	sts triangle_fx_Qxy_target+1, zero
002eb4 c00a                      	rjmp sound_driver_channel2_fx_Rxy_routine
                                 
                                 sound_driver_channel2_fx_Qxy_routine_add:
002eb5 91c0 28fe                 	lds r28, triangle_fx_Qxy_speed
002eb7 91d0 28ff                 	lds r29, triangle_fx_Qxy_speed+1
002eb9 0fac                      	add r26, r28 //increase the total offset by the speed
002eba 1fbd                      	adc r27, r29
002ebb 93a0 2900                 	sts triangle_fx_Qxy_total_offset, r26 //store the total offset
002ebd 93b0 2901                 	sts triangle_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_Rxy_routine:
002ebf 91e0 2902                 	lds ZL, triangle_fx_Rxy_target
002ec1 91f0 2903                 	lds ZH, triangle_fx_Rxy_target+1
002ec3 9630                      	adiw Z, 0
002ec4 f139                      	breq sound_driver_instrument_routine_channel3_volume //if the effect is not enabled, skip the routine
                                 
002ec5 91a0 2906                 	lds r26, triangle_fx_Rxy_total_offset
002ec7 91b0 2907                 	lds r27, triangle_fx_Rxy_total_offset+1
002ec9 91c0 0aac                 	lds r28, TCB2_CCMPL
002ecb 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
002ecd 1bce                      	sub r28, ZL //calculate the difference to the target
002ece 0bdf                      	sbc r29, ZH
002ecf f408                      	brsh sound_driver_channel2_fx_Rxy_routine_end //if the target has been reached (or passed)
002ed0 f088                      	brlo sound_driver_channel2_fx_Rxy_routine_add
                                 
                                 sound_driver_channel2_fx_Rxy_routine_end:
002ed1 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
002ed2 0bbd                      	sbc r27, r29
                                 
002ed3 91c0 28fa                 	lds r28, triangle_fx_Pxx_total
002ed5 91d0 28fb                 	lds r29, triangle_fx_Pxx_total+1
                                 
002ed7 0fac                      	add r26, r28
002ed8 1fbd                      	adc r27, r29
                                 
002ed9 93a0 2906                 	sts triangle_fx_Rxy_total_offset, r26 //store the total offset
002edb 93b0 2907                 	sts triangle_fx_Rxy_total_offset+1, r27
002edd 9220 2902                 	sts triangle_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
002edf 9220 2903                 	sts triangle_fx_Rxy_target+1, zero
002ee1 c00a                      	rjmp sound_driver_instrument_routine_channel3_volume
                                 
                                 sound_driver_channel2_fx_Rxy_routine_add:
002ee2 91c0 2904                 	lds r28, triangle_fx_Rxy_speed
002ee4 91d0 2905                 	lds r29, triangle_fx_Rxy_speed+1
002ee6 0fac                      	add r26, r28 //increase the total offset by the speed
002ee7 1fbd                      	adc r27, r29
002ee8 93a0 2906                 	sts triangle_fx_Rxy_total_offset, r26 //store the total offset
002eea 93b0 2907                 	sts triangle_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume:
002eec 91e0 2910                 	lds ZL, noise_volume_macro
002eee 91f0 2911                 	lds ZH, noise_volume_macro+1
002ef0 9630                      	adiw Z, 0
002ef1 f1a1                      	breq sound_driver_instrument_routine_channel3_volume_default //if no volume macro is in use, use default multiplier of F
002ef2 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002ef3 1fff                      	rol ZH
002ef4 91a0 2912                 	lds r26, noise_volume_macro_offset
002ef6 0fea                      	add ZL, r26
002ef7 1df2                      	adc ZH, zero
                                 
002ef8 91b0 2914                 	lds r27, noise_volume_macro_release
002efa 17ba                      	cp r27, r26
002efb f429                      	brne sound_driver_instrument_routine_channel3_volume_increment //if the current offset is not equal to the release index, increment the offset
002efc 91a0 2913                 	lds r26, noise_volume_macro_loop
002efe 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002eff f010                      	brlo sound_driver_instrument_routine_channel3_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002f00 c003                      	rjmp sound_driver_instrument_routine_channel3_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_volume_increment:
002f01 95a3                      	inc r26 //increment the macro offset
002f02 93a0 2912                 	sts noise_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_volume_read:
002f04 91b4                      	lpm r27, Z //load volume data into r27
002f05 3fbf                      	cpi r27, 0xFF //check for macro end flag
002f06 f469                      	brne sound_driver_instrument_routine_channel3_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_check_release:
002f07 91b0 2914                 	lds r27, noise_volume_macro_release
002f09 3fbf                      	cpi r27, 0xFF
002f0a f429                      	brne sound_driver_instrument_routine_channel3_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_check_loop:
002f0b 91b0 2913                 	lds r27, noise_volume_macro_loop //load the loop index
002f0d 93b0 2912                 	sts noise_volume_macro_offset, r27 //store the loop index into the offset
002f0f cfdc                      	rjmp sound_driver_instrument_routine_channel3_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_last_index:
002f10 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002f11 93a0 2912                 	sts noise_volume_macro_offset, r26
002f13 cfd8                      	rjmp sound_driver_instrument_routine_channel3_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume_calculate:
002f14 e6ea                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
002f15 e6f5                      	ldi ZH, HIGH(volumes << 1)
002f16 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
002f17 0feb                      	add ZL, r27 //add offset to the table
002f18 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel3_volume_load:
002f19 91b0 2813                 	lds r27, noise_param //load main volume
002f1b 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002f1c 91a0 2945                 	lds r26, noise_fx_7xy_value
002f1e 30a0                      	cpi r26, 0x00
002f1f f481                      	brne sound_driver_instrument_routine_channel3_volume_load_7xy
                                 
002f20 0feb                      	add ZL, r27 //offset the volume table by the main volume
002f21 1df2                      	adc ZH, zero
002f22 91b4                      	lpm r27, Z
002f23 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002f25 c024                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_default:
002f26 91b0 2813                 	lds r27, noise_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
002f28 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002f29 91a0 2945                 	lds r26, noise_fx_7xy_value
002f2b 30a0                      	cpi r26, 0x00
002f2c f4a1                      	brne sound_driver_instrument_routine_channel3_volume_default_7xy
002f2d 93b0 2816                 	sts noise_output_volume, r27
002f2f c01a                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_load_7xy:
002f30 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002f31 f040                      	brcs sound_driver_instrument_routine_channel3_volume_load_7xy_overflow
002f32 f039                      	breq sound_driver_instrument_routine_channel3_volume_load_7xy_overflow
002f33 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
                                 
002f34 0feb                      	add ZL, r27 //offset the volume table by the main volume
002f35 1df2                      	adc ZH, zero
002f36 91b4                      	lpm r27, Z
002f37 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002f39 c010                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_load_7xy_overflow:
002f3a e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002f3b 0feb                      	add ZL, r27 //offset the volume table by the main volume
002f3c 1df2                      	adc ZH, zero
002f3d 91b4                      	lpm r27, Z
002f3e 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002f40 c009                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_default_7xy:
002f41 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002f42 f020                      	brcs sound_driver_instrument_routine_channel3_volume_default_7xy_overflow
002f43 f019                      	breq sound_driver_instrument_routine_channel3_volume_default_7xy_overflow
002f44 93b0 2816                 	sts noise_output_volume, r27
002f46 c003                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel3_volume_default_7xy_overflow:
002f47 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002f48 93b0 2816                 	sts noise_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002f4a 91e0 2915                 	lds ZL, noise_arpeggio_macro
002f4c 91f0 2916                 	lds ZH, noise_arpeggio_macro+1
002f4e 9630                      	adiw Z, 0
002f4f f1d9                      	breq sound_driver_instrument_routine_channel3_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002f50 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002f51 1fff                      	rol ZH
002f52 91a0 2917                 	lds r26, noise_arpeggio_macro_offset
002f54 0fea                      	add ZL, r26
002f55 1df2                      	adc ZH, zero
                                 
002f56 91b0 2919                 	lds r27, noise_arpeggio_macro_release
002f58 17ba                      	cp r27, r26
002f59 f429                      	brne sound_driver_instrument_routine_channel3_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002f5a 91a0 2918                 	lds r26, noise_arpeggio_macro_loop
002f5c 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002f5d f010                      	brlo sound_driver_instrument_routine_channel3_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002f5e c003                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_increment:
002f5f 95a3                      	inc r26 //increment the macro offset
002f60 93a0 2917                 	sts noise_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_arpeggio_read:
002f62 91b4                      	lpm r27, Z //load arpeggio data into r27
002f63 38b0                      	cpi r27, 0x80 //check for macro end flag
002f64 f009                      	breq sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag
002f65 c041                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_check_mode:
002f66 50a1                      	subi r26, 1 //keep the offset at the end flag
002f67 93a0 2917                 	sts noise_arpeggio_macro_offset, r26
002f69 91b0 291a                 	lds r27, noise_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002f6b 30b1                      	cpi r27, 0x01
002f6c f048                      	brlo sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_fixed_relative_check_release:
002f6d 91b0 2919                 	lds r27, noise_arpeggio_macro_release
002f6f 3fbf                      	cpi r27, 0xFF
002f70 f4d1                      	brne sound_driver_instrument_routine_channel3_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_fixed_relative_check_loop:
002f71 91b0 2918                 	lds r27, noise_arpeggio_macro_loop
002f73 3fbf                      	cpi r27, 0xFF
002f74 f499                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002f75 c015                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute:
002f76 91b0 2919                 	lds r27, noise_arpeggio_macro_release
002f78 3fbf                      	cpi r27, 0xFF
002f79 f421                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_check_loop:
002f7a 91b0 2918                 	lds r27, noise_arpeggio_macro_loop //load the loop index
002f7c 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002f7d f451                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_no_loop:
002f7e 91c0 292d                 	lds r28, noise_fx_0xy_sequence //check for 0xy effect
002f80 91d0 292e                 	lds r29, noise_fx_0xy_sequence+1
002f82 9620                      	adiw r29:r28, 0
002f83 f469                      	brne sound_driver_instrument_routine_channel3_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002f84 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002f85 93a0 2917                 	sts noise_arpeggio_macro_offset, r26 //store the last valid index into the offset
002f87 cfc2                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload:
002f88 93b0 2917                 	sts noise_arpeggio_macro_offset, r27 //store the loop index into the offset
002f8a cfbf                      	rjmp sound_driver_instrument_routine_channel3_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_default:
002f8b 91c0 292d                 	lds r28, noise_fx_0xy_sequence //load 0xy effect
002f8d 91d0 292e                 	lds r29, noise_fx_0xy_sequence+1
002f8f 9620                      	adiw r29:r28, 0 //check for 0xy effect
002f90 f099                      	breq sound_driver_instrument_routine_channel3_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel3_arpeggio_default_xy:
002f91 95d6                      	lsr r29
002f92 95c7                      	ror r28
002f93 95d7                      	ror r29
002f94 95c7                      	ror r28
002f95 95d7                      	ror r29
002f96 95c7                      	ror r28
002f97 95d7                      	ror r29
002f98 95c7                      	ror r28
002f99 95d7                      	ror r29
002f9a 95d2                      	swap r29
                                 
002f9b 93c0 292d                 	sts noise_fx_0xy_sequence, r28 //store the rolled sequence
002f9d 93d0 292e                 	sts noise_fx_0xy_sequence+1, r29
002f9f 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002fa0 91a0 2817                 	lds r26, noise_note //load the current note index
002fa2 0fac                      	add r26, r28 //add the note offset
002fa3 c02e                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel3_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002fa4 91a0 2817                 	lds r26, noise_note //load the current note index
002fa6 c02b                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process:
002fa7 9220 291b                 	sts noise_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002fa9 9220 291c                 	sts noise_total_pitch_offset+1, zero
002fab 9220 2922                 	sts noise_total_hi_pitch_offset, zero
002fad 91a0 291a                 	lds r26, noise_arpeggio_macro_mode
002faf 30a1                      	cpi r26, 0x01 //absolute mode
002fb0 f010                      	brlo sound_driver_instrument_routine_channel3_arpeggio_process_absolute
002fb1 f069                      	breq sound_driver_instrument_routine_channel3_arpeggio_process_fixed
002fb2 c00e                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_absolute:
002fb3 91a0 2817                 	lds r26, noise_note //load the current note index
002fb5 0fab                      	add r26, r27 //offset the note with the arpeggio data
002fb6 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002fb7 c004                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_absolute_add:
002fb8 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002fb9 f0c0                      	brlo sound_driver_instrument_routine_channel3_arpeggio_process_load //if the result is valid, go load the new note
002fba e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002fbb c016                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_absolute_subtract:
002fbc fda7                      	sbrc r26, 7 //check if result is negative
002fbd e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002fbe c013                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_fixed:
002fbf 2fab                      	mov r26, r27 //move the arpeggio data into r26
002fc0 c011                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_relative:
002fc1 91a0 2817                 	lds r26, noise_note //load the current note index
002fc3 0fab                      	add r26, r27 //offset the note with the arpeggio data
002fc4 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002fc5 c008                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_relative_add:
002fc6 93a0 2817                 	sts noise_note, r26 //NOTE: relative mode modifies the original note index
002fc8 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002fc9 f040                      	brlo sound_driver_instrument_routine_channel3_arpeggio_process_load //if the result is valid, go load the new note
002fca e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002fcb 93a0 2817                 	sts noise_note, r26
002fcd c004                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_relative_subtract:
002fce fda7                      	sbrc r26, 7 //check if result is negative
002fcf e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002fd0 93a0 2817                 	sts noise_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_load:
002fd2 e4e2                      	ldi ZL, LOW(noise_period_table << 1) //load in note table
002fd3 e0f1                      	ldi ZH, HIGH(noise_period_table << 1)
002fd4 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002fd5 0fea                      	add ZL, r26 //add offset
002fd6 1df2                      	adc ZH, zero
002fd7 91a5                      	lpm r26, Z+ //load bytes
002fd8 91b4                      	lpm r27, Z
002fd9 93a0 0abc                 	sts TCB3_CCMPL, r26 //load the LOW bits for timer
002fdb 93b0 0abd                 	sts TCB3_CCMPH, r27 //load the HIGH bits for timer
002fdd 93a0 2939                 	sts noise_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002fdf 93b0 293a                 	sts noise_fx_3xx_target+1, r27
002fe1 c000                      	rjmp sound_driver_instrument_routine_channel3_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch:
002fe2 91e0 291d                 	lds ZL, noise_pitch_macro
002fe4 91f0 291e                 	lds ZH, noise_pitch_macro+1
002fe6 9630                      	adiw Z, 0
002fe7 f409                      	brne sound_driver_instrument_routine_channel3_pitch_continue
002fe8 c023                      	rjmp sound_driver_instrument_routine_channel3_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel3_pitch_continue:
002fe9 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002fea 1fff                      	rol ZH
002feb 91a0 291f                 	lds r26, noise_pitch_macro_offset
002fed 0fea                      	add ZL, r26
002fee 1df2                      	adc ZH, zero
                                 
002fef 91b0 2921                 	lds r27, noise_pitch_macro_release
002ff1 17ba                      	cp r27, r26
002ff2 f429                      	brne sound_driver_instrument_routine_channel3_pitch_increment //if the current offset is not equal to the release index, increment the offset
002ff3 91a0 2920                 	lds r26, noise_pitch_macro_loop
002ff5 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002ff6 f010                      	brlo sound_driver_instrument_routine_channel3_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002ff7 c003                      	rjmp sound_driver_instrument_routine_channel3_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_pitch_increment:
002ff8 95a3                      	inc r26 //increment the macro offset
002ff9 93a0 291f                 	sts noise_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_pitch_read:
002ffb 91b4                      	lpm r27, Z //load pitch data into r27
002ffc 38b0                      	cpi r27, 0x80 //check for macro end flag
002ffd f479                      	brne sound_driver_instrument_routine_channel3_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag_check_release:
002ffe 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002fff 93a0 291f                 	sts noise_pitch_macro_offset, r26
003001 91b0 2921                 	lds r27, noise_pitch_macro_release
003003 3fbf                      	cpi r27, 0xFF
003004 f439                      	brne sound_driver_instrument_routine_channel3_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag_check_loop:
003005 91b0 2920                 	lds r27, noise_pitch_macro_loop //load the loop index
003007 3fbf                      	cpi r27, 0xFF //check if there is a loop index
003008 f019                      	breq sound_driver_instrument_routine_channel3_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
003009 93b0 291f                 	sts noise_pitch_macro_offset, r27 //store the loop index into the offset
00300b cfd6                      	rjmp sound_driver_instrument_routine_channel3_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch_default:
00300c e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel3_pitch_calculate:
00300d 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00300e 937f                      	push r23
00300f 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
003010 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
003011 0367                      	mulsu r22, r23
003012 917f                      	pop r23
003013 916f                      	pop r22
                                 
003014 9416                      	lsr r1 //shift out the fractional bits
003015 9407                      	ror r0
003016 9416                      	lsr r1
003017 9407                      	ror r0
003018 9416                      	lsr r1
003019 9407                      	ror r0
00301a 9416                      	lsr r1
00301b 9407                      	ror r0
00301c fe13                      	sbrs r1, 3 //check if result was a negative number
00301d c002                      	rjmp sound_driver_instrument_routine_channel3_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel3_pitch_calculate_negative:
00301e efb0                      	ldi r27, 0xF0
00301f 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel3_pitch_calculate_offset:
003020 91a0 291b                 	lds r26, noise_total_pitch_offset
003022 91b0 291c                 	lds r27, noise_total_pitch_offset+1
003024 0e0a                      	add r0, r26
003025 1e1b                      	adc r1, r27
003026 9200 291b                 	sts noise_total_pitch_offset, r0
003028 9210 291c                 	sts noise_total_pitch_offset+1, r1
00302a 91a0 0abc                 	lds r26, TCB3_CCMPL //load the low bits for timer
00302c 91b0 0abd                 	lds r27, TCB3_CCMPH //load the high bits for timer
00302e 0da0                      	add r26, r0 //offset the timer values
00302f 1db1                      	adc r27, r1
                                 	
003030 91c0 2931                 	lds r28, noise_fx_1xx_total
003032 91d0 2932                 	lds r29, noise_fx_1xx_total+1
003034 1bac                      	sub r26, r28
003035 0bbd                      	sbc r27, r29
003036 91c0 2935                 	lds r28, noise_fx_2xx_total
003038 91d0 2936                 	lds r29, noise_fx_2xx_total+1
00303a 0fac                      	add r26, r28
00303b 1fbd                      	adc r27, r29
00303c 91c0 2949                 	lds r28, noise_fx_Pxx_total
00303e 91d0 294a                 	lds r29, noise_fx_Pxx_total+1
003040 0fac                      	add r26, r28
003041 1fbd                      	adc r27, r29
003042 91c0 294f                 	lds r28, noise_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
003044 91d0 2950                 	lds r29, noise_fx_Qxy_total_offset+1
003046 1bac                      	sub r26, r28
003047 0bbd                      	sbc r27, r29
003048 91c0 2955                 	lds r28, noise_fx_Rxy_total_offset
00304a 91d0 2956                 	lds r29, noise_fx_Rxy_total_offset+1
00304c 0fac                      	add r26, r28
00304d 1fbd                      	adc r27, r29
                                 
00304e 93a0 0abc                 	sts TCB3_CCMPL, r26 //store the new low bits for timer
003050 93b0 0abd                 	sts TCB3_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel3_hi_pitch:
003052 91e0 2923                 	lds ZL, noise_hi_pitch_macro
003054 91f0 2924                 	lds ZH, noise_hi_pitch_macro+1
003056 9630                      	adiw Z, 0
003057 f409                      	brne sound_driver_instrument_routine_channel3_hi_pitch_continue
003058 c03c                      	rjmp sound_driver_instrument_routine_channel3_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel3_hi_pitch_continue:
003059 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00305a 1fff                      	rol ZH
00305b 91a0 2925                 	lds r26, noise_hi_pitch_macro_offset
00305d 0fea                      	add ZL, r26
00305e 1df2                      	adc ZH, zero
                                 
00305f 91b0 2927                 	lds r27, noise_hi_pitch_macro_release
003061 17ba                      	cp r27, r26
003062 f429                      	brne sound_driver_instrument_routine_channel3_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
003063 91a0 2926                 	lds r26, noise_hi_pitch_macro_loop
003065 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
003066 f010                      	brlo sound_driver_instrument_routine_channel3_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
003067 c003                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_increment:
003068 95a3                      	inc r26 //increment the macro offset
003069 93a0 2925                 	sts noise_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_hi_pitch_read:
00306b 91b4                      	lpm r27, Z //load hi pitch data into r27
00306c 38b0                      	cpi r27, 0x80 //check for macro end flag
00306d f489                      	brne sound_driver_instrument_routine_channel3_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag_check_release:
00306e 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00306f 93a0 2925                 	sts noise_hi_pitch_macro_offset, r26
003071 91b0 2927                 	lds r27, noise_hi_pitch_macro_release
003073 3fbf                      	cpi r27, 0xFF
003074 f439                      	brne sound_driver_instrument_routine_channel3_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag_check_loop:
003075 91b0 2926                 	lds r27, noise_hi_pitch_macro_loop //load the loop index
003077 3fbf                      	cpi r27, 0xFF //check if there is a loop index
003078 f019                      	breq sound_driver_instrument_routine_channel3_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
003079 93b0 2925                 	sts noise_hi_pitch_macro_offset, r27 //store the loop index into the offset
00307b cfd6                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_default:
00307c 91b0 2922                 	lds r27, noise_total_hi_pitch_offset
00307e c005                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate:
00307f 91a0 2922                 	lds r26, noise_total_hi_pitch_offset //load the total hi pitch offset to change
003081 0fba                      	add r27, r26
003082 93b0 2922                 	sts noise_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate_multiply:
003084 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
003085 937f                      	push r23
003086 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
003087 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
003088 0367                      	mulsu r22, r23
003089 917f                      	pop r23
00308a 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate_offset:
00308b 91a0 0abc                 	lds r26, TCB3_CCMPL //load the low bits for timer
00308d 91b0 0abd                 	lds r27, TCB3_CCMPH //load the high bits for timer
00308f 0da0                      	add r26, r0 //offset the timer values
003090 1db1                      	adc r27, r1
003091 93a0 0abc                 	sts TCB3_CCMPL, r26 //store the new low bits for timer
003093 93b0 0abd                 	sts TCB3_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty:
003095 91e0 2928                 	lds ZL, noise_duty_macro
003097 91f0 2929                 	lds ZH, noise_duty_macro+1
003099 9630                      	adiw Z, 0
00309a f169                      	breq sound_driver_channel3_fx_routines //if no duty macro is in use, go to the next routine
00309b 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00309c 1fff                      	rol ZH
00309d 91a0 292a                 	lds r26, noise_duty_macro_offset
00309f 0fea                      	add ZL, r26
0030a0 1df2                      	adc ZH, zero
                                 
0030a1 91b0 292c                 	lds r27, noise_duty_macro_release
0030a3 17ba                      	cp r27, r26
0030a4 f429                      	brne sound_driver_instrument_routine_channel3_duty_increment //if the current offset is not equal to the release index, increment the offset
0030a5 91a0 292b                 	lds r26, noise_duty_macro_loop
0030a7 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0030a8 f010                      	brlo sound_driver_instrument_routine_channel3_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0030a9 c01e                      	rjmp sound_driver_channel3_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel3_duty_increment:
0030aa 95a3                      	inc r26 //increment the macro offset
0030ab 93a0 292a                 	sts noise_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_duty_read:
0030ad 91b4                      	lpm r27, Z //load pitch data into r27
0030ae 3fbf                      	cpi r27, 0xFF //check for macro end flag
0030af f471                      	brne sound_driver_instrument_routine_channel3_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag_check_release:
0030b0 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0030b1 93a0 292a                 	sts noise_duty_macro_offset, r26
0030b3 91b0 292c                 	lds r27, noise_duty_macro_release
0030b5 3fbf                      	cpi r27, 0xFF
0030b6 f489                      	brne sound_driver_channel3_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag_check_loop:
0030b7 91b0 292b                 	lds r27, noise_duty_macro_loop //load the loop index
0030b9 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0030ba f069                      	breq sound_driver_channel3_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
0030bb 93b0 292a                 	sts noise_duty_macro_offset, r27 //store the loop index into the offset
0030bd cfd7                      	rjmp sound_driver_instrument_routine_channel3_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty_load:
0030be 95b6                      	lsr r27
0030bf 95b7                      	ror r27 //move mode bit to bit 7
0030c0 91c0 2814                 	lds r28, noise_period
0030c2 77cf                      	andi r28, 0b01111111
0030c3 2bcb                      	or r28, r27 //store the new noise mode
0030c4 93c0 2813                 	sts noise_param, r28
                                 
0030c6 776f                      	andi noise_sequence_HIGH, 0b01111111
0030c7 2b6b                      	or noise_sequence_HIGH, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_routines:
                                 sound_driver_channel3_fx_1xx_routine:
0030c8 91e0 292f                 	lds ZL, noise_fx_1xx
0030ca 91f0 2930                 	lds ZH, noise_fx_1xx+1
0030cc 9630                      	adiw Z, 0
0030cd f051                      	breq sound_driver_channel3_fx_2xx_routine
                                 
0030ce 91a0 2931                 	lds r26, noise_fx_1xx_total //load the rate to change the pitch by
0030d0 91b0 2932                 	lds r27, noise_fx_1xx_total+1
0030d2 0fae                      	add r26, ZL //increase the total offset by the rate
0030d3 1fbf                      	adc r27, ZH
0030d4 93a0 2931                 	sts noise_fx_1xx_total, r26
0030d6 93b0 2932                 	sts noise_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_2xx_routine:
0030d8 91e0 2933                 	lds ZL, noise_fx_2xx
0030da 91f0 2934                 	lds ZH, noise_fx_2xx+1
0030dc 9630                      	adiw Z, 0
0030dd f051                      	breq sound_driver_channel3_fx_3xx_routine
                                 
0030de 91a0 2935                 	lds r26, noise_fx_2xx_total //load the rate to change the pitch by
0030e0 91b0 2936                 	lds r27, noise_fx_2xx_total+1
0030e2 0fae                      	add r26, ZL //increase the total offset by the rate
0030e3 1fbf                      	adc r27, ZH
0030e4 93a0 2935                 	sts noise_fx_2xx_total, r26
0030e6 93b0 2936                 	sts noise_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_3xx_routine:
0030e8 91e0 293b                 	lds ZL, noise_fx_3xx_speed
0030ea 91f0 293c                 	lds ZH, noise_fx_3xx_speed+1
0030ec 9630                      	adiw Z, 0
0030ed f409                      	brne sound_driver_channel3_fx_3xx_routine_check_start
0030ee c048                      	rjmp sound_driver_channel3_fx_4xy_routine
                                 
                                 sound_driver_channel3_fx_3xx_routine_check_start:
0030ef 91a0 2937                 	lds r26, noise_fx_3xx_start
0030f1 91b0 2938                 	lds r27, noise_fx_3xx_start+1
0030f3 9610                      	adiw r26:r27, 0
0030f4 f409                      	brne sound_driver_channel3_fx_3xx_routine_main
0030f5 c041                      	rjmp sound_driver_channel3_fx_4xy_routine
                                 
                                 sound_driver_channel3_fx_3xx_routine_main:
0030f6 91c0 2939                 	lds r28, noise_fx_3xx_target
0030f8 91d0 293a                 	lds r29, noise_fx_3xx_target+1
                                 
0030fa 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
0030fb 07bd                      	cpc r27, r29
0030fc f011                      	breq sound_driver_channel3_fx_3xx_routine_disable
0030fd f030                      	brlo sound_driver_channel3_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
0030fe c01f                      	rjmp sound_driver_channel3_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel3_fx_3xx_routine_disable:
0030ff 9220 2937                 	sts noise_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
003101 9220 2938                 	sts noise_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
003103 c033                      	rjmp sound_driver_channel3_fx_4xy_routine
                                 
                                 sound_driver_channel3_fx_3xx_routine_subtract:
003104 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
003105 0bdb                      	sbc r29, r27
003106 91a0 293d                 	lds r26, noise_fx_3xx_total_offset
003108 91b0 293e                 	lds r27, noise_fx_3xx_total_offset+1
                                 
00310a 0fae                      	add r26, ZL //add the speed to the total offset
00310b 1fbf                      	adc r27, ZH
00310c 1bca                      	sub r28, r26 //invert the total difference with the total offset
00310d 0bdb                      	sbc r29, r27
00310e f380                      	brlo sound_driver_channel3_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
00310f 93a0 293d                 	sts noise_fx_3xx_total_offset, r26 //store the new total offset
003111 93b0 293e                 	sts noise_fx_3xx_total_offset+1, r27
                                 
003113 91a0 0abc                 	lds r26, TCB3_CCMPL //load the current timer period
003115 91b0 0abd                 	lds r27, TCB3_CCMPH
003117 1bac                      	sub r26, r28 //offset the current timer period with the total offset
003118 0bbd                      	sbc r27, r29
003119 93a0 0abc                 	sts TCB3_CCMPL, r26
00311b 93b0 0abd                 	sts TCB3_CCMPH, r27
00311d c019                      	rjmp sound_driver_channel3_fx_4xy_routine
                                 
                                 sound_driver_channel3_fx_3xx_routine_add:
00311e 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
00311f 0bbd                      	sbc r27, r29
003120 91c0 293d                 	lds r28, noise_fx_3xx_total_offset
003122 91d0 293e                 	lds r29, noise_fx_3xx_total_offset+1
                                 
003124 0fce                      	add r28, ZL //add the speed to the total offset
003125 1fdf                      	adc r29, ZH
003126 1bac                      	sub r26, r28 //invert the total difference with the total offset
003127 0bbd                      	sbc r27, r29
003128 f2b0                      	brlo sound_driver_channel3_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
003129 93c0 293d                 	sts noise_fx_3xx_total_offset, r28 //store the new total offset
00312b 93d0 293e                 	sts noise_fx_3xx_total_offset+1, r29
                                 
00312d 91c0 0abc                 	lds r28, TCB3_CCMPL //load the current timer period
00312f 91d0 0abd                 	lds r29, TCB3_CCMPH
003131 0fca                      	add r28, r26 //offset the current timer period with the total offset
003132 1fdb                      	adc r29, r27
003133 93c0 0abc                 	sts TCB3_CCMPL, r28
003135 93d0 0abd                 	sts TCB3_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel3_fx_4xy_routine:
003137 91a0 293f                 	lds r26, noise_fx_4xy_speed
003139 15a2                      	cp r26, zero
00313a f409                      	brne sound_driver_channel3_fx_4xy_routine_continue
00313b c05c                      	rjmp sound_driver_channel3_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel3_fx_4xy_routine_continue:
00313c 91b0 2940                 	lds r27, noise_fx_4xy_depth
00313e 91c0 2941                 	lds r28, noise_fx_4xy_phase
003140 0fca                      	add r28, r26 //increase the phase by the speed
003141 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
003142 f008                      	brlo sound_driver_channel3_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
003143 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase:
003144 93c0 2941                 	sts noise_fx_4xy_phase, r28 //store the new phase
003146 31c0                      	cpi r28, 16
003147 f028                      	brlo sound_driver_channel3_fx_4xy_routine_phase_0
003148 32c0                      	cpi r28, 32
003149 f028                      	brlo sound_driver_channel3_fx_4xy_routine_phase_1
00314a 33c0                      	cpi r28, 48
00314b f030                      	brlo sound_driver_channel3_fx_4xy_routine_phase_2
00314c c007                      	rjmp sound_driver_channel3_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_0:
00314d 70cf                      	andi r28, 0x0F //mask for values 0-15
00314e c029                      	rjmp sound_driver_channel3_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_1:
00314f 6fc0                      	ori r28, 0xF0
003150 95c0                      	com r28 //invert values 0-15
003151 c026                      	rjmp sound_driver_channel3_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_2:
003152 70cf                      	andi r28, 0x0F //mask for values 0-15
003153 c003                      	rjmp sound_driver_channel3_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_3:
003154 6fc0                      	ori r28, 0xF0
003155 95c0                      	com r28 //invert values 0-15
003156 c000                      	rjmp sound_driver_channel3_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel3_fx_4xy_routine_load_add:
003157 95b2                      	swap r27 //multiply depth by 16
003158 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
003159 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00315a e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00315b 0fec                      	add ZL, r28 //offset the table by the depth+phase
00315c 1df2                      	adc ZH, zero
00315d 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
00315e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00315f 937f                      	push r23
003160 2f6c                      	mov r22, r28 //store the vibrato value into r22
003161 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
003162 9f67                      	mul r22, r23
003163 917f                      	pop r23
003164 916f                      	pop r22
                                 
003165 9416                      	lsr r1 //shift out the fractional bits
003166 9407                      	ror r0
003167 9416                      	lsr r1
003168 9407                      	ror r0
003169 9416                      	lsr r1
00316a 9407                      	ror r0
00316b 9416                      	lsr r1
00316c 9407                      	ror r0
                                 	
00316d 91a0 0abc                 	lds r26, TCB3_CCMPL
00316f 91b0 0abd                 	lds r27, TCB3_CCMPH
003171 0da0                      	add r26, r0
003172 1db1                      	adc r27, r1
003173 93a0 0abc                 	sts TCB3_CCMPL, r26
003175 93b0 0abd                 	sts TCB3_CCMPH, r27
003177 c020                      	rjmp sound_driver_channel3_fx_7xy_routine
                                 
                                 sound_driver_channel3_fx_4xy_routine_load_subtract:
003178 95b2                      	swap r27 //multiply depth by 16
003179 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
00317a e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00317b e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00317c 0fec                      	add ZL, r28 //offset the table by the depth+phase
00317d 1df2                      	adc ZH, zero
00317e 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
00317f 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
003180 937f                      	push r23
003181 2f6c                      	mov r22, r28 //store the vibrato value into r22
003182 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
003183 9f67                      	mul r22, r23
003184 917f                      	pop r23
003185 916f                      	pop r22
                                 
003186 9416                      	lsr r1 //shift out the fractional bits
003187 9407                      	ror r0
003188 9416                      	lsr r1
003189 9407                      	ror r0
00318a 9416                      	lsr r1
00318b 9407                      	ror r0
00318c 9416                      	lsr r1
00318d 9407                      	ror r0
                                 
00318e 91a0 0abc                 	lds r26, TCB3_CCMPL
003190 91b0 0abd                 	lds r27, TCB3_CCMPH
003192 19a0                      	sub r26, r0
003193 09b1                      	sbc r27, r1
003194 93a0 0abc                 	sts TCB3_CCMPL, r26
003196 93b0 0abd                 	sts TCB3_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_7xy_routine:
003198 91a0 2942                 	lds r26, noise_fx_7xy_speed
00319a 15a2                      	cp r26, zero
00319b f0f1                      	breq sound_driver_channel3_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
00319c 91b0 2943                 	lds r27, noise_fx_7xy_depth
00319e 91c0 2944                 	lds r28, noise_fx_7xy_phase
0031a0 0fca                      	add r28, r26 //increase the phase by the speed
0031a1 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
0031a2 f010                      	brlo sound_driver_channel3_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
0031a3 e0c0                      	ldi r28, 0x00
0031a4 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel3_fx_7xy_routine_phase:
0031a5 93c0 2944                 	sts noise_fx_7xy_phase, r28 //store the new phase
0031a7 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
0031a8 ffc4                      	sbrs r28, 4
0031a9 c001                      	rjmp sound_driver_channel3_fx_7xy_routine_phase_0
0031aa c002                      	rjmp sound_driver_channel3_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel3_fx_7xy_routine_phase_0:
0031ab 70cf                      	andi r28, 0x0F //mask for values 0-15
0031ac c003                      	rjmp sound_driver_channel3_fx_7xy_routine_load
                                 
                                 sound_driver_channel3_fx_7xy_routine_phase_1:
0031ad 6fc0                      	ori r28, 0xF0
0031ae 95c0                      	com r28 //invert values 0-15
0031af c000                      	rjmp sound_driver_channel3_fx_7xy_routine_load
                                 
                                 sound_driver_channel3_fx_7xy_routine_load:
0031b0 95b2                      	swap r27 //multiply depth by 16
0031b1 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0031b2 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0031b3 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0031b4 0fec                      	add ZL, r28 //offset the table by the depth+phase
0031b5 1df2                      	adc ZH, zero
0031b6 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
0031b7 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
0031b8 93c0 2945                 	sts noise_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Axy_routine:
0031ba 91b0 2946                 	lds r27, noise_fx_Axy
0031bc 15b2                      	cp r27, zero
0031bd f0e9                      	breq sound_driver_channel3_fx_Qxy_routine //0 means that the effect is not in use
                                 	
0031be 91a0 2815                 	lds r26, noise_fractional_volume //load fractional volume representation of the channel
0031c0 91c0 2813                 	lds r28, noise_param //load the integer volume representation of the channel
0031c2 2fda                      	mov r29, r26 //copy fractional volume into r29
0031c3 2fec                      	mov r30, r28 //copy the noise_param into r30
0031c4 95e2                      	swap r30
0031c5 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
0031c6 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
0031c7 17ed                      	cp r30, r29 //compare the fractional and integer volumes
0031c8 f009                      	breq sound_driver_channel3_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel3_fx_Axy_routine_reload:
0031c9 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate:
0031ca fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
0031cb c004                      	rjmp sound_driver_channel3_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_addition:
0031cc 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0031cd f428                      	brcc sound_driver_channel3_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0031ce efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
0031cf c003                      	rjmp sound_driver_channel3_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_subtraction:
0031d0 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0031d1 f008                      	brcs sound_driver_channel3_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0031d2 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_store:
0031d3 93a0 2815                 	sts noise_fractional_volume, r26 //store the new fractional volume
0031d5 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
0031d6 95a2                      	swap r26
0031d7 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
0031d8 2bca                      	or r28, r26 //store the new volume back into noise_param
0031d9 93c0 2813                 	sts noise_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel3_fx_Qxy_routine:
0031db 91e0 294b                 	lds ZL, noise_fx_Qxy_target
0031dd 91f0 294c                 	lds ZH, noise_fx_Qxy_target+1
0031df 9630                      	adiw Z, 0
0031e0 f139                      	breq sound_driver_channel3_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
0031e1 91a0 294f                 	lds r26, noise_fx_Qxy_total_offset
0031e3 91b0 2950                 	lds r27, noise_fx_Qxy_total_offset+1
0031e5 91c0 0abc                 	lds r28, TCB3_CCMPL
0031e7 91d0 0abd                 	lds r29, TCB3_CCMPH
                                 
0031e9 1bec                      	sub ZL, r28 //calculate the difference to the target
0031ea 0bfd                      	sbc ZH, r29
0031eb f408                      	brsh sound_driver_channel3_fx_Qxy_routine_end //if the target has been reached (or passed)
0031ec f088                      	brlo sound_driver_channel3_fx_Qxy_routine_add
                                 
                                 sound_driver_channel3_fx_Qxy_routine_end:
0031ed 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
0031ee 0bbf                      	sbc r27, ZH
                                 
0031ef 91c0 2949                 	lds r28, noise_fx_Pxx_total
0031f1 91d0 294a                 	lds r29, noise_fx_Pxx_total+1
                                 
0031f3 0fac                      	add r26, r28
0031f4 1fbd                      	adc r27, r29
                                 
0031f5 93a0 294f                 	sts noise_fx_Qxy_total_offset, r26 //store the total offset
0031f7 93b0 2950                 	sts noise_fx_Qxy_total_offset+1, r27
0031f9 9220 294b                 	sts noise_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
0031fb 9220 294c                 	sts noise_fx_Qxy_target+1, zero
0031fd c00a                      	rjmp sound_driver_channel3_fx_Rxy_routine
                                 
                                 sound_driver_channel3_fx_Qxy_routine_add:
0031fe 91c0 294d                 	lds r28, noise_fx_Qxy_speed
003200 91d0 294e                 	lds r29, noise_fx_Qxy_speed+1
003202 0fac                      	add r26, r28 //increase the total offset by the speed
003203 1fbd                      	adc r27, r29
003204 93a0 294f                 	sts noise_fx_Qxy_total_offset, r26 //store the total offset
003206 93b0 2950                 	sts noise_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Rxy_routine:
003208 91e0 2951                 	lds ZL, noise_fx_Rxy_target
00320a 91f0 2952                 	lds ZH, noise_fx_Rxy_target+1
00320c 9630                      	adiw Z, 0
00320d f139                      	breq sound_driver_instrument_routine_channel4_volume //if the effect is not enabled, skip the routine
                                 
00320e 91a0 2955                 	lds r26, noise_fx_Rxy_total_offset
003210 91b0 2956                 	lds r27, noise_fx_Rxy_total_offset+1
003212 91c0 0abc                 	lds r28, TCB3_CCMPL
003214 91d0 0abd                 	lds r29, TCB3_CCMPH
                                 
003216 1bce                      	sub r28, ZL //calculate the difference to the target
003217 0bdf                      	sbc r29, ZH
003218 f408                      	brsh sound_driver_channel3_fx_Rxy_routine_end //if the target has been reached (or passed)
003219 f088                      	brlo sound_driver_channel3_fx_Rxy_routine_add
                                 
                                 sound_driver_channel3_fx_Rxy_routine_end:
00321a 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
00321b 0bbd                      	sbc r27, r29
                                 
00321c 91c0 2949                 	lds r28, noise_fx_Pxx_total
00321e 91d0 294a                 	lds r29, noise_fx_Pxx_total+1
                                 
003220 0fac                      	add r26, r28
003221 1fbd                      	adc r27, r29
                                 
003222 93a0 2955                 	sts noise_fx_Rxy_total_offset, r26 //store the total offset
003224 93b0 2956                 	sts noise_fx_Rxy_total_offset+1, r27
003226 9220 2951                 	sts noise_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
003228 9220 2952                 	sts noise_fx_Rxy_target+1, zero
00322a c00a                      	rjmp sound_driver_instrument_routine_channel4_volume
                                 
                                 sound_driver_channel3_fx_Rxy_routine_add:
00322b 91c0 2953                 	lds r28, noise_fx_Rxy_speed
00322d 91d0 2954                 	lds r29, noise_fx_Rxy_speed+1
00322f 0fac                      	add r26, r28 //increase the total offset by the speed
003230 1fbd                      	adc r27, r29
003231 93a0 2955                 	sts noise_fx_Rxy_total_offset, r26 //store the total offset
003233 93b0 2956                 	sts noise_fx_Rxy_total_offset+1, r27
                                 
                                 sound_driver_instrument_routine_channel4_volume:
                                 
                                 sound_driver_exit:
003235 91ff                      	pop r31
003236 91ef                      	pop r30
003237 91df                      	pop r29
003238 91cf                      	pop r28
003239 940c 171d                 	jmp sequence_1_3 + 3 //+3 is to skip the stack instructions since we already pushed them
                                 
                                 
                                 
                                 //TABLES
00323b 7f05
00323c 010a
00323d 0214
00323e 0328
00323f 0450
003240 051e
003241 0607
003242 070d
003243 0806
003244 090c
003245 0a18
003246 0b30
003247 0c60
003248 0d24
003249 0e08
00324a 0f10                      length: .db $05, $7F, $0A, $01, $14, $02, $28, $03, $50, $04, $1E, $05, $07, $06, $0D, $07, $06, $08, $0C, $09, $18, $0A, $30, $0B, $60, $0C, $24, $0D, $08, $0E, $10, $0F
                                 
                                 //pulse sequences: 12.5%, 25%, 50%, 75%
00324b 0301
00324c fc0f                      sequences: .db 0b00000001, 0b00000011, 0b00001111, 0b11111100
                                 
                                 //list of famitracker fx: http://famitracker.com/wiki/index.php?title=Effect_list
                                 channel0_fx:
00324d 1959
00324e 195e
00324f 197a
003250 1996
003251 19b9                      	.dw sound_driver_channel0_fx_0xy, sound_driver_channel0_fx_1xx, sound_driver_channel0_fx_2xx, sound_driver_channel0_fx_3xx, sound_driver_channel0_fx_4xy
003252 19c4
003253 19d1
003254 19d4
003255 19d7
003256 19da                      	.dw sound_driver_channel0_fx_7xy, sound_driver_channel0_fx_Axy, sound_driver_channel0_fx_Bxx, sound_driver_channel0_fx_Cxx, sound_driver_channel0_fx_Dxx
003257 19dd
003258 19e5
003259 19e8
00325a 19f5
00325b 19f6                      	.dw sound_driver_channel0_fx_Exx, sound_driver_channel0_fx_Fxx, sound_driver_channel0_fx_Gxx, sound_driver_channel0_fx_Hxy, sound_driver_channel0_fx_Ixy
00325c 19f7
00325d 19f8
00325e 19f9
00325f 1a0d
003260 1a51                      	.dw sound_driver_channel0_fx_Hxx, sound_driver_channel0_fx_Ixx, sound_driver_channel0_fx_Pxx, sound_driver_channel0_fx_Qxy, sound_driver_channel0_fx_Rxy
003261 1a94
003262 1aa1
003263 1ab5
003264 1ab6
003265 1ab7                      	.dw sound_driver_channel0_fx_Sxx, sound_driver_channel0_fx_Vxx, sound_driver_channel0_fx_Wxx, sound_driver_channel0_fx_Xxx, sound_driver_channel0_fx_Yxx
003266 1ab8                      	.dw sound_driver_channel0_fx_Zxx
                                 
                                 channel1_fx:
003267 1c3a
003268 1c3f
003269 1c5b
00326a 1c77
00326b 1c9a                      	.dw sound_driver_channel1_fx_0xy, sound_driver_channel1_fx_1xx, sound_driver_channel1_fx_2xx, sound_driver_channel1_fx_3xx, sound_driver_channel1_fx_4xy
00326c 1ca5
00326d 1cb2
00326e 1cb5
00326f 1cb8
003270 1cbb                      	.dw sound_driver_channel1_fx_7xy, sound_driver_channel1_fx_Axy, sound_driver_channel1_fx_Bxx, sound_driver_channel1_fx_Cxx, sound_driver_channel1_fx_Dxx
003271 1cbe
003272 1cc6
003273 1cc9
003274 1cd6
003275 1cd7                      	.dw sound_driver_channel1_fx_Exx, sound_driver_channel1_fx_Fxx, sound_driver_channel1_fx_Gxx, sound_driver_channel1_fx_Hxy, sound_driver_channel1_fx_Ixy
003276 1cd8
003277 1cd9
003278 1cda
003279 1cee
00327a 1d32                      	.dw sound_driver_channel1_fx_Hxx, sound_driver_channel1_fx_Ixx, sound_driver_channel1_fx_Pxx, sound_driver_channel1_fx_Qxy, sound_driver_channel1_fx_Rxy
00327b 1d75
00327c 1d82
00327d 1d96
00327e 1d97
00327f 1d98                      	.dw sound_driver_channel1_fx_Sxx, sound_driver_channel1_fx_Vxx, sound_driver_channel1_fx_Wxx, sound_driver_channel1_fx_Xxx, sound_driver_channel1_fx_Yxx
003280 1d99                      	.dw sound_driver_channel1_fx_Zxx
                                 
                                 channel2_fx:
003281 1f17
003282 1f1c
003283 1f38
003284 1f54
003285 1f77                      	.dw sound_driver_channel2_fx_0xy, sound_driver_channel2_fx_1xx, sound_driver_channel2_fx_2xx, sound_driver_channel2_fx_3xx, sound_driver_channel2_fx_4xy
003286 1f82
003287 1f83
003288 1f84
003289 1f87
00328a 1f8a                      	.dw sound_driver_channel2_fx_7xy, sound_driver_channel2_fx_Axy, sound_driver_channel2_fx_Bxx, sound_driver_channel2_fx_Cxx, sound_driver_channel2_fx_Dxx
00328b 1f8d
00328c 1f9a
00328d 1f9d
00328e 1faa
00328f 1fab                      	.dw sound_driver_channel2_fx_Exx, sound_driver_channel2_fx_Fxx, sound_driver_channel2_fx_Gxx, sound_driver_channel2_fx_Hxy, sound_driver_channel2_fx_Ixy
003290 1fac
003291 1fad
003292 1fae
003293 1fc2
003294 2006                      	.dw sound_driver_channel2_fx_Hxx, sound_driver_channel2_fx_Ixx, sound_driver_channel2_fx_Pxx, sound_driver_channel2_fx_Qxy, sound_driver_channel2_fx_Rxy
003295 2049
003296 2056
003297 2057
003298 2058
003299 2059                      	.dw sound_driver_channel2_fx_Sxx, sound_driver_channel2_fx_Vxx, sound_driver_channel2_fx_Wxx, sound_driver_channel2_fx_Xxx, sound_driver_channel2_fx_Yxx
00329a 205a                      	.dw sound_driver_channel2_fx_Zxx
                                 
                                 channel3_fx:
00329b 21dc
00329c 21e1
00329d 21fd
00329e 2219
00329f 223c                      	.dw sound_driver_channel3_fx_0xy, sound_driver_channel3_fx_1xx, sound_driver_channel3_fx_2xx, sound_driver_channel3_fx_3xx, sound_driver_channel3_fx_4xy
0032a0 2247
0032a1 2254
0032a2 2257
0032a3 225a
0032a4 225d                      	.dw sound_driver_channel3_fx_7xy, sound_driver_channel3_fx_Axy, sound_driver_channel3_fx_Bxx, sound_driver_channel3_fx_Cxx, sound_driver_channel3_fx_Dxx
0032a5 2260
0032a6 2267
0032a7 226a
0032a8 2277
0032a9 2278                      	.dw sound_driver_channel3_fx_Exx, sound_driver_channel3_fx_Fxx, sound_driver_channel3_fx_Gxx, sound_driver_channel3_fx_Hxy, sound_driver_channel3_fx_Ixy
0032aa 2279
0032ab 227a
0032ac 227b
0032ad 228f
0032ae 22d3                      	.dw sound_driver_channel3_fx_Hxx, sound_driver_channel3_fx_Ixx, sound_driver_channel3_fx_Pxx, sound_driver_channel3_fx_Qxy, sound_driver_channel3_fx_Rxy
0032af 2316
0032b0 2323
0032b1 232e
0032b2 232f
0032b3 2330                      	.dw sound_driver_channel3_fx_Sxx, sound_driver_channel3_fx_Vxx, sound_driver_channel3_fx_Wxx, sound_driver_channel3_fx_Xxx, sound_driver_channel3_fx_Yxx
0032b4 2331                      	.dw sound_driver_channel3_fx_Zxx
                                 
                                 //famitracker volumes table: http://famitracker.com/wiki/index.php?title=Volume
                                 volumes:
0032b5 0000
0032b6 0000
0032b7 0000
0032b8 0000
0032b9 0000
0032ba 0000
0032bb 0000
0032bc 0000                      	.db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
0032bd 0100
0032be 0101
0032bf 0101
0032c0 0101
0032c1 0101
0032c2 0101
0032c3 0101
0032c4 0101                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
0032c5 0100
0032c6 0101
0032c7 0101
0032c8 0101
0032c9 0101
0032ca 0101
0032cb 0101
0032cc 0201                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02
0032cd 0100
0032ce 0101
0032cf 0101
0032d0 0101
0032d1 0101
0032d2 0202
0032d3 0202
0032d4 0302                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03
0032d5 0100
0032d6 0101
0032d7 0101
0032d8 0101
0032d9 0202
0032da 0202
0032db 0303
0032dc 0403                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04
0032dd 0100
0032de 0101
0032df 0101
0032e0 0202
0032e1 0302
0032e2 0303
0032e3 0404
0032e4 0504                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05
0032e5 0100
0032e6 0101
0032e7 0201
0032e8 0202
0032e9 0303
0032ea 0404
0032eb 0504
0032ec 0605                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x06
0032ed 0100
0032ee 0101
0032ef 0201
0032f0 0302
0032f1 0403
0032f2 0504
0032f3 0605
0032f4 0706                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07
0032f5 0100
0032f6 0101
0032f7 0202
0032f8 0303
0032f9 0404
0032fa 0505
0032fb 0606
0032fc 0807                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07, 0x08
0032fd 0100
0032fe 0101
0032ff 0302
003300 0403
003301 0504
003302 0606
003303 0707
003304 0908                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09
003305 0100
003306 0201
003307 0302
003308 0404
003309 0605
00330a 0706
00330b 0808
00330c 0a09                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A
00330d 0100
00330e 0201
00330f 0302
003310 0504
003311 0605
003312 0807
003313 0908
003314 0b0a                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B
003315 0100
003316 0201
003317 0403
003318 0504
003319 0706
00331a 0808
00331b 0a09
00331c 0c0b                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B, 0x0C
00331d 0100
00331e 0201
00331f 0403
003320 0605
003321 0706
003322 0908
003323 0b0a
003324 0d0c                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D
003325 0100
003326 0201
003327 0403
003328 0605
003329 0807
00332a 0a09
00332b 0c0b
00332c 0e0d                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E
00332d 0100
00332e 0302
00332f 0504
003330 0706
003331 0908
003332 0b0a
003333 0d0c


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega4809" register use summary:
x  :   0 y  :   0 z  : 248 r0 : 192 r1 : 200 r2 : 697 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   6 r11:   4 r12:   9 
r13:   6 r14:   4 r15:   9 r16:   7 r17:   6 r18:   7 r19:   6 r20:   4 
r21:   9 r22: 174 r23: 160 r24:   0 r25:  24 r26: 978 r27:1184 r28: 696 
r29: 374 r30: 378 r31: 337 
Registers used: 25 out of 35 (71.4%)

"ATmega4809" instruction use summary:
.lds  :   0 .sts  :   0 adc   : 148 add   : 195 adiw  : 106 and   :   0 
andi  :  95 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   7 brcs  :  13 break :   0 breq  : 169 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  80 brlt  :   0 brmi  :   0 
brne  : 121 brpl  :   0 brsh  :  31 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :   0 cbr   :   5 
clc   :   0 clh   :   0 cli   :   8 cln   :   0 clr   :   5 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :  16 cp    : 100 cpc   :   9 
cpi   : 168 cpse  :  20 dec   :  35 des   :   0 eor   :   2 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   4 in    :   7 inc   :  48 
jmp   :  10 ld    :   0 ldd   :   0 ldi   : 285 lds   : 725 lpm   : 260 
lsl   :  79 lsr   : 171 mov   : 139 movw  :   0 mul   :  28 muls  :   0 
mulsu :  12 neg   :   0 nop   :   0 or    :  22 ori   :  12 out   :   9 
pop   : 115 push  : 109 rcall :  50 ret   :  32 reti  :   7 rjmp  : 514 
rol   :  53 ror   : 192 sbc   :  48 sbci  :   0 sbi   :   0 sbic  :   0 
sbis  :   0 sbiw  :   0 sbr   :  12 sbrc  :  29 sbrs  :  16 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   :1398 sub   :  66 subi  :  52 swap  :  46 tst   :   0 wdr   :   0 

Instructions used: 52 out of 114 (45.6%)

"ATmega4809" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x00666a  15844  10262  26106   49152  53.1%
[.dseg] 0x002800 0x00295a      0    346    346    6144   5.6%
[.eseg] 0x000000 0x000000      0      0      0     256   0.0%

Assembly complete, 0 errors, 103 warnings
