
AVRASM ver. 2.2.8  C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm Fri Jan 08 20:09:33 2021

C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(112): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(112): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
                                 
                                 
                                 ; NES_APU_2a03.asm
                                 ;
                                 ; Created: 11/29/2020 1:44:10 AM
                                 ; Author : Tennyson Cheng
                                 ;
                                 
                                 .list
                                 
                                 .dseg
002800                           pulse1_param: .byte 1 //$4000 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002801                           pulse1_sweep_param: .byte 1 //$4001 EPPP.NSSS = Enable, Period, Negate, Shift
                                 //NOTE: In order to account for multiplier, we use 16 instead of 11 bits for the timer
002802                           pulse1_timerL: .byte 1 //$4002 LLLL.LLLL = Low 8 bits for timer
002803                           pulse1_timerH: .byte 1 //$4002 HHHH.HHHH = High 8 bits for timer
002804                           pulse1_length: .byte 1 //$4002 000l.llll = Length counter load
002805                           pulse1_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002806                           pulse1_output_volume: .byte 1 //this is the final output volume of pulse 1
002807                           pulse1_note: .byte 1 //the current note index in the note table
                                 
002808                           song_frames: .byte 2
00280a                           song_frame_offset: .byte 2
                                 
                                 
                                 
00280c                           pulse1_pattern: .byte 2
00280e                           pulse1_pattern_delay: .byte 1
00280f                           pulse1_pattern_offset: .byte 2
                                 
002811                           pulse1_volume_macro: .byte 2
002813                           pulse1_volume_macro_offset: .byte 1
002814                           pulse1_volume_macro_loop: .byte 1
002815                           pulse1_volume_macro_release: .byte 1
                                 
002816                           pulse1_arpeggio_macro: .byte 2
002818                           pulse1_arpeggio_macro_offset: .byte 1
002819                           pulse1_arpeggio_macro_loop: .byte 1
00281a                           pulse1_arpeggio_macro_release: .byte 1
00281b                           pulse1_arpeggio_macro_mode: .byte 1
                                 
00281c                           pulse1_total_pitch_offset: .byte 1 //used to reference the overall change in pitch for the pitch macro
00281d                           pulse1_pitch_macro: .byte 2
00281f                           pulse1_pitch_macro_offset: .byte 1
002820                           pulse1_pitch_macro_loop: .byte 1
002821                           pulse1_pitch_macro_release: .byte 1
                                 
002822                           pulse1_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
002823                           pulse1_hi_pitch_macro: .byte 2
002825                           pulse1_hi_pitch_macro_offset: .byte 1
002826                           pulse1_hi_pitch_macro_loop: .byte 1
002827                           pulse1_hi_pitch_macro_release: .byte 1
                                 
002828                           pulse1_duty_macro: .byte 2
00282a                           pulse1_duty_macro_offset: .byte 1
00282b                           pulse1_duty_macro_loop: .byte 1
00282c                           pulse1_duty_macro_release: .byte 1
                                 
00282d                           pulse1_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
00282f                           pulse1_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
002831                           pulse1_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
002833                           pulse1_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
002835                           pulse1_fx_3xx_start: .byte 2 //the starting note period
002837                           pulse1_fx_3xx_target: .byte 2 //target note period
002839                           pulse1_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
00283b                           pulse1_fx_3xx_total_offset: .byte 2
00283d                           pulse1_fx_Pxx: .byte 1 //refers to the fine pitch offset set by the Pxx effect
00283e                           pulse1_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
00283f                           pulse1_fx_Qxy_target: .byte 2 //target note period
002841                           pulse1_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002843                           pulse1_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002845                           pulse1_fx_Rxy_target: .byte 2 //target note period
002847                           pulse1_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
002849                           pulse1_fx_Rxy_total_offset: .byte 2
                                 
00284b                           pulse2_pattern_delay: .byte 1
00284c                           triangle_pattern_delay: .byte 1
00284d                           noise_pattern_delay: .byte 1
00284e                           dcpm_pattern_delay: .byte 1
                                 
                                 .cseg
                                 
                                 //NOTE: zero is defined in order to use the cp instruction without the need to load 0x00 into a register beforehand
                                 .def zero = r2
                                 .def channel_flags = r25 //[pulse1.pulse2] RSlc.0000 = Reload, Start, Length halt/Loop, Constant volume
                                 .def pulse1_sequence = r13
                                 .def pulse1_length_counter = r14
                                 .def pulse1_sweep = r15 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse1_volume_divider = r16 //0000.PPPP = Period divider
                                 .def pulse1_volume_decay = r17 //0000.dddd = Decay
                                 
                                 reset:
000000 940c 00b7                 	jmp init
                                 
                                 .org TCA0_OVF_vect
00000e 940c 01ea                 	jmp sound_driver
                                 
                                 .org TCA0_CMP0_vect
000012 940c 01d0                 	jmp sequence_0_2
                                 
                                 .org TCA0_CMP1_vect
000014 940c 01da                 	jmp sequence_1_3
                                 
                                 .org TCA0_CMP2_vect
000016 940c 01d0                 	jmp sequence_0_2
                                 
                                 .org TCB0_INT_vect
000018 940c 06f2                 	jmp pulse1_sequence_routine
                                 
                                 .list
                                 
                                 init:
                                 	//MAIN CLOCK
0000b7 edb8                      	ldi r27, CPU_CCP_IOREG_gc //protected write
0000b8 93b0 0034                 	sts CPU_CCP, r27
0000ba e0b0                      	ldi r27, 0 << CLKCTRL_PEN_bp //disable prescaler for 20 MHz on main clock
0000bb 93b0 0061                 	sts CLKCTRL_MCLKCTRLB, r27
                                 
                                 /*	//TEST FOR C4, 1 SECOND, 50% DD
                                 	ldi r26, 0x97
                                 	ldi r27, 0x12
                                 	ldi r26, 0x15
                                 	ldi r27, 0x09
                                 	sts pulse1_timerL, r26
                                 	sts pulse1_timerH, r27
                                 	ldi r27, 0b10111111
                                 	sts pulse1_param, r27
                                 	ldi r27, 0x01
                                 	sts pulse1_length, r27
                                 	//TEST FOR SWEEP UP
                                 	ldi r27, 0b11111111
                                 	sts pulse1_sweep_param, r27*/
                                 
                                 	//ZERO
0000bd 2422                      	clr zero
                                 
                                 	//MEMORY
0000be e3b0                      	ldi r27, 0b00110000
0000bf 93b0 2800                 	sts pulse1_param, r27
0000c1 e8b0                      	ldi r27, 0b10000000
0000c2 93b0 2801                 	sts pulse1_sweep_param, r27
0000c4 efbf                      	ldi r27, 0xFF
0000c5 93b0 2802                 	sts pulse1_timerL, r27
0000c7 93b0 2803                 	sts pulse1_timerH, r27
0000c9 93b0 2804                 	sts pulse1_length, r27
                                 
0000cb e0b0                      	ldi r27, 0x00
0000cc 93b0 280a                 	sts song_frame_offset, r27
0000ce 93b0 280b                 	sts song_frame_offset+1, r27
0000d0 eee2                      	ldi ZL, LOW(song0_frames << 1)
0000d1 e0f0                      	ldi ZH, HIGH(song0_frames << 1)
0000d2 93e0 2808                 	sts song_frames, ZL
0000d4 93f0 2809                 	sts song_frames+1, ZH
                                 
                                 	//CHANNEL 0 TEST
0000d6 e0b0                      	ldi r27, 0x00
0000d7 0feb                      	add ZL, r27
0000d8 1df2                      	adc ZH, zero
0000d9 91a5                      	lpm r26, Z+
0000da 91b4                      	lpm r27, Z
0000db 0faa                      	lsl r26
0000dc 1fbb                      	rol r27
0000dd 93a0 280c                 	sts pulse1_pattern, r26
0000df 93b0 280d                 	sts pulse1_pattern+1, r27
0000e1 e0b0                      	ldi r27, 0x00
0000e2 9220 280e                 	sts pulse1_pattern_delay, zero
0000e4 9220 280f                 	sts pulse1_pattern_offset, zero
0000e6 9220 2810                 	sts pulse1_pattern_offset+1, zero
                                 
                                 	//channel 0 instrument macros
0000e8 efbf                      	ldi r27, 0xFF
0000e9 9220 2813                 	sts pulse1_volume_macro_offset, zero
0000eb 93b0 2814                 	sts pulse1_volume_macro_loop, r27
0000ed 93b0 2815                 	sts pulse1_volume_macro_release, r27
0000ef 9220 2818                 	sts pulse1_arpeggio_macro_offset, zero
0000f1 93b0 2819                 	sts pulse1_arpeggio_macro_loop, r27
0000f3 93b0 281a                 	sts pulse1_arpeggio_macro_release, r27
0000f5 93b0 281b                 	sts pulse1_arpeggio_macro_mode, r27
0000f7 9220 281f                 	sts pulse1_pitch_macro_offset, zero
0000f9 93b0 2820                 	sts pulse1_pitch_macro_loop, r27
0000fb 93b0 2821                 	sts pulse1_pitch_macro_release, r27
0000fd 9220 2825                 	sts pulse1_hi_pitch_macro_offset, zero
0000ff 93b0 2826                 	sts pulse1_hi_pitch_macro_loop, r27
000101 93b0 2827                 	sts pulse1_hi_pitch_macro_release, r27
000103 9220 282a                 	sts pulse1_duty_macro_offset, zero
000105 93b0 282b                 	sts pulse1_duty_macro_loop, r27
000107 93b0 282c                 	sts pulse1_duty_macro_release, r27
                                 
000109 9220 2811                 	sts pulse1_volume_macro, zero
00010b 9220 2812                 	sts pulse1_volume_macro+1, zero
00010d 9220 2816                 	sts pulse1_arpeggio_macro, zero
00010f 9220 2817                 	sts pulse1_arpeggio_macro+1, zero
000111 9220 281c                 	sts pulse1_total_pitch_offset, zero
000113 9220 281d                 	sts pulse1_pitch_macro, zero
000115 9220 281e                 	sts pulse1_pitch_macro+1, zero
000117 9220 2822                 	sts pulse1_total_hi_pitch_offset, zero
000119 9220 2823                 	sts pulse1_hi_pitch_macro, zero
00011b 9220 2824                 	sts pulse1_hi_pitch_macro+1, zero
00011d 9220 2828                 	sts pulse1_duty_macro, zero
00011f 9220 2829                 	sts pulse1_duty_macro+1, zero
                                 
000121 9220 284b                 	sts pulse2_pattern_delay, zero
000123 9220 284c                 	sts triangle_pattern_delay, zero
000125 9220 284d                 	sts noise_pattern_delay, zero
000127 9220 284e                 	sts dcpm_pattern_delay, zero
                                 
                                 	//PINS
000129 efbf                      	ldi r27, 0xFF //set all pins in VPORTD to output
00012a b9b0                      	out VPORTA_DIR, r27
                                 
                                 	//ENVELOPE
00012b e00f                      	ldi pulse1_volume_divider, 0x0F
00012c 9110 2800                 	lds pulse1_volume_decay, pulse1_param
00012e 701f                      	andi pulse1_volume_decay, 0x0F //mask for VVVV bits
00012f 9190 2800                 	lds channel_flags, pulse1_param
000131 7390                      	andi channel_flags, 0b00110000
000132 6490                      	sbr channel_flags, 0b01000000 //set start flag
000133 9220 2806                 	sts pulse1_output_volume, zero
000135 93b0 2805                 	sts pulse1_fractional_volume, r27 //initialize fractional volume to max value
                                 	
                                 	//LENGTH
000137 91d0 2804                 	lds r29, pulse1_length
000139 d605                      	rcall length_converter
00013a 2eed                      	mov pulse1_length_counter, r29
                                 
                                 	//SEQUENCE
00013b 91d0 2800                 	lds r29, pulse1_param //load param for sequence table
00013d 0fdd                      	lsl r29 //shift duty cycle bits to LSB
00013e 1fdd                      	rol r29
00013f 1fdd                      	rol r29
000140 70d3                      	andi r29, 0b00000011 //mask duty cycle bits
000141 d613                      	rcall duty_cycle_sequences
000142 2edd                      	mov pulse1_sequence, r29
                                 
                                 	//SWEEP
000143 90f0 2801                 	lds pulse1_sweep, pulse1_sweep_param
000145 94f2                      	swap pulse1_sweep //swap data from high byte and low byte
000146 6890                      	sbr channel_flags, 0b10000000 //set reload flag
                                 
                                 	//FX
000147 9220 282d                 	sts pulse1_fx_1xx, zero
000149 9220 282e                 	sts pulse1_fx_1xx+1, zero
00014b 9220 282f                 	sts pulse1_fx_1xx_total, zero
00014d 9220 2830                 	sts pulse1_fx_1xx_total+1, zero
00014f 9220 2831                 	sts pulse1_fx_2xx, zero
000151 9220 2832                 	sts pulse1_fx_2xx+1, zero
000153 9220 2833                 	sts pulse1_fx_2xx_total, zero
000155 9220 2834                 	sts pulse1_fx_2xx_total+1, zero
000157 9220 2835                 	sts pulse1_fx_3xx_start, zero
000159 9220 2836                 	sts pulse1_fx_3xx_start+1, zero
00015b 9220 2837                 	sts pulse1_fx_3xx_target, zero
00015d 9220 2838                 	sts pulse1_fx_3xx_target+1, zero
00015f 9220 2839                 	sts pulse1_fx_3xx_speed, zero
000161 9220 283a                 	sts pulse1_fx_3xx_speed+1, zero
000163 9220 283b                 	sts pulse1_fx_3xx_total_offset, zero
000165 9220 283c                 	sts pulse1_fx_3xx_total_offset+1, zero
000167 9220 283d                 	sts pulse1_fx_Pxx, zero
000169 9220 283e                 	sts pulse1_fx_Axy, zero
00016b 9220 283f                 	sts pulse1_fx_Qxy_target, zero
00016d 9220 2840                 	sts pulse1_fx_Qxy_target+1, zero
00016f 9220 2841                 	sts pulse1_fx_Qxy_speed, zero
000171 9220 2842                 	sts pulse1_fx_Qxy_speed+1, zero
000173 9220 2843                 	sts pulse1_fx_Qxy_total_offset, zero
000175 9220 2844                 	sts pulse1_fx_Qxy_total_offset+1, zero
000177 9220 2845                 	sts pulse1_fx_Rxy_target, zero
000179 9220 2846                 	sts pulse1_fx_Rxy_target+1, zero
00017b 9220 2847                 	sts pulse1_fx_Rxy_speed, zero
00017d 9220 2848                 	sts pulse1_fx_Rxy_speed+1, zero
00017f 9220 2849                 	sts pulse1_fx_Rxy_total_offset, zero
000181 9220 284a                 	sts pulse1_fx_Rxy_total_offset+1, zero
                                 
                                 	//TIMERS
                                 	//Frame Counter
                                 	//NOTE:The frame counter will be defaulted to NTSC mode (60 Hz, 120 Hz, 240 Hz)
                                 	//Each interrupt will be setup to interrupt every 240 Hz clock
                                 	//CMP0 = sequence 0, CMP1 = sequence 1, CMP2 = sequence 2, OVF = sequence 3/sound driver
                                 	//Sequence 3 will clock the sound driver every 60Hz, in which new audio data is read and written to the registers
                                 	//Timer period Calculation: (0.00416666666 * 20000000/64)-1 = 1301.08333125 = 0x0515
                                 	//The ATmega4809 is cofigured to run at 20000000 Hz
                                 	//0.00416666666 seconds is the period for 240 Hz
                                 	//The /64 comes from the prescaler divider used
000183 e7b0                      	ldi r27, TCA_SINGLE_CMP0EN_bm | TCA_SINGLE_CMP1EN_bm | TCA_SINGLE_CMP2EN_bm | TCA_SINGLE_WGMODE_NORMAL_gc //interrupt mode
000184 93b0 0a01                 	sts TCA0_SINGLE_CTRLB, r27
000186 e7b1                      	ldi r27, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP1_bm | TCA_SINGLE_CMP2_bm | TCA_SINGLE_OVF_bm //enable overflow and compare interrupts
000187 93b0 0a0a                 	sts TCA0_SINGLE_INTCTRL, r27
000189 e1b5                      	ldi r27, 0x15 //set the period for CMP0
00018a 93b0 0a28                 	sts TCA0_SINGLE_CMP0, r27
00018c e0b5                      	ldi r27, 0x05
00018d 93b0 0a29                 	sts TCA0_SINGLE_CMP0 + 1, r27
00018f e2bb                      	ldi r27, 0x2B //set the period for CMP1
000190 93b0 0a2a                 	sts TCA0_SINGLE_CMP1, r27
000192 e0ba                      	ldi r27, 0x0A
000193 93b0 0a2b                 	sts TCA0_SINGLE_CMP1 + 1, r27
000195 e4b1                      	ldi r27, 0x41 //set the period for CMP2
000196 93b0 0a2c                 	sts TCA0_SINGLE_CMP2, r27
000198 e0bf                      	ldi r27, 0x0F
000199 93b0 0a2d                 	sts TCA0_SINGLE_CMP2 + 1, r27
00019b e5b7                      	ldi r27, 0x57 //set the period for OVF
00019c 93b0 0a26                 	sts TCA0_SINGLE_PER, r27
00019e e1b4                      	ldi r27, 0x14
00019f 93b0 0a27                 	sts TCA0_SINGLE_PER + 1, r27
0001a1 e0bb                      	ldi r27, TCA_SINGLE_CLKSEL_DIV64_gc | TCA_SINGLE_ENABLE_bm //use prescale divider of 64 and enable timer
0001a2 93b0 0a00                 	sts TCA0_SINGLE_CTRLA, r27
                                 
                                 	//NOTE: Channel Timers are clocked (20/2)/(0.8948865) = 11.1746014718 times faster than the NES APU
                                 	//Because of this, we multiply all the NES timer values by 11.1746014718 beforehand
                                 	//Since we rotate the sequence when the timer goes from t-(t-1) to 0, instead of 0 to t like the NES, we add 1 to the NES timers before multiplying
                                 	//The ATmega4809 is configured to run at 20 MHz
                                 	//The /2 comes from the prescaler divider used
                                 	//0.8948865 MHz is the speed of the NTSC NES APU
                                 	//NOTE: This means that any offset to the pitch for the NES timers would be multiplied by 11.1746014718 aswell.
                                 	//Pulse 1
0001a4 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
0001a5 93b0 0a81                 	sts TCB0_CTRLB, r27
0001a7 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
0001a8 93b0 0a85                 	sts TCB0_INTCTRL, r27
0001aa 91b0 2802                 	lds r27, pulse1_timerL //load the LOW bits for timer
0001ac 93b0 0a8c                 	sts TCB0_CCMPL, r27
0001ae 91b0 2803                 	lds r27, pulse1_timerH //load the HIGH bits for timer
0001b0 93b0 0a8d                 	sts TCB0_CCMPH, r27
0001b2 e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
0001b3 93b0 0a80                 	sts TCB0_CTRLA, r27
0001b5 9478                      	sei //global interrupt enable
                                 
                                 pulse1:
0001b6 fed0                      	sbrs pulse1_sequence, 0 //if the sequence output is zero, return
0001b7 c012                      	rjmp pulse1_off
                                 
0001b8 14e2                      	cp pulse1_length_counter, zero //if length is zero, return
0001b9 f081                      	breq pulse1_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
                                 pulse1_check_timer_08:
0001ba 91c0 0a8c                 	lds r28, TCB0_CCMPL
0001bc 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 pulse1_check_timer_08_HIGH:
0001be 30d1                      	cpi r29, 0x01 //check timer HIGH period
0001bf f008                      	brlo pulse1_check_timer_08_LOW //if the timer HIGH period is $00, check the LOW period
0001c0 c002                      	rjmp pulse1_check_timer_7FF_HIGH //if the timer HIGH period is > $01, check > $07FF condition
                                 pulse1_check_timer_08_LOW:
0001c1 35c9                      	cpi r28, 0x59 //check timer LOW period
0001c2 f038                      	brlo pulse1_off //if the HIGH period == $00 && LOW period <= $59, pulse off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $5965
                                 pulse1_check_timer_7FF_HIGH:
0001c3 35d9                      	cpi r29, 0x59 //check timer HIGH period
0001c4 f038                      	brlo pulse1_on //if the HIGH period is < $59, then all conditions have passed and pulse is not muted
0001c5 f009                      	breq pulse1_check_timer_7FF_LOW //if the HIGH period is == $59, we go check if the LOW period is < $65
0001c6 c003                      	rjmp pulse1_off //pulse off if HIGH period is > $59
                                 pulse1_check_timer_7FF_LOW:
0001c7 36c5                      	cpi r28, 0x65 //check timer LOW period
0001c8 f408                      	brsh pulse1_off //if the HIGH period == $59 && LOW period >= $65, pulse off
0001c9 c002                      	rjmp pulse1_on //if the HIGH period == $59 && LOW period < $65, pulse on
                                 
                                 pulse1_off:
0001ca b821                      	out VPORTA_OUT, zero
0001cb cfea                      	rjmp pulse1
                                 
                                 pulse1_on:
0001cc 91d0 2806                 	lds r29, pulse1_output_volume
                                 /*	cpse r29, zero
                                 	rjmp pulse1_off //if VVVV bits are 0, then there is no volume (channel off)*/
                                 
0001ce b9d1                      	out VPORTA_OUT, r29
0001cf cfe6                      	rjmp pulse1
                                 
                                 //FRAME COUNTER/AUDIO SAMPLE ISR
                                 sequence_0_2:
0001d0 b7bf                      	in r27, CPU_SREG
0001d1 93bf                      	push r27
0001d2 94f8                      	cli
                                 
                                 	//ENVELOPE
0001d3 d553                      	rcall pulse1_envelope_routine
                                 
0001d4 e5b0                      	ldi r27, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP2_bm //clear OVF flag
0001d5 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
0001d7 91bf                      	pop r27
0001d8 bfbf                      	out CPU_SREG, r27
0001d9 9518                      	reti
                                 
                                 sequence_1_3:
0001da b7bf                      	in r27, CPU_SREG
0001db 93bf                      	push r27
0001dc 94f8                      	cli
                                 
                                 	//ENVELOPE
0001dd d549                      	rcall pulse1_envelope_routine
                                 
                                 	//SWEEP
0001de fcf3                      	sbrc pulse1_sweep, 3 //check if the sweep enable bit is cleared
0001df d51d                      	rcall pulse1_sweep_routine
                                 
                                 	//LENGTH
                                 	//NOTE: The length routine is relatively simple, so we will not be using clocks to rjmp and ret to a seperate lable
0001e0 fd95                      	sbrc channel_flags, 5 //check if the length counter halt bit is cleared
0001e1 c002                      	rjmp sequence_1_3_exit
0001e2 10e2                      	cpse pulse1_length_counter, zero //if length counter is already 0, don't decrement
0001e3 94ea                      	dec pulse1_length_counter
                                 
                                 sequence_1_3_exit:
0001e4 e2b1                      	ldi r27, TCA_SINGLE_CMP1_bm | TCA_SINGLE_OVF_bm //clear OVF flag
0001e5 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
0001e7 91bf                      	pop r27
0001e8 bfbf                      	out CPU_SREG, r27
0001e9 9518                      	reti
                                 
                                 sound_driver:
0001ea b7bf                      	in r27, CPU_SREG
0001eb 93bf                      	push r27
0001ec 94f8                      	cli
0001ed 93cf                      	push r28
0001ee 93df                      	push r29
                                 
                                 	//SOUND DRIVER
0001ef 91b0 280e                 	lds r27, pulse1_pattern_delay
0001f1 11b2                      	cpse r27, zero //if the pattern delay is 0, proceed with sound driver procedures
0001f2 c276                      	rjmp sound_driver_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 
                                 
                                 sound_driver_channel0:
0001f3 91e0 280c                 	lds ZL, pulse1_pattern //current pattern for pulse 1
0001f5 91f0 280d                 	lds ZH, pulse1_pattern+1
0001f7 91a0 280f                 	lds r26, pulse1_pattern_offset //current offset in the pattern for pulse 1
0001f9 91b0 2810                 	lds r27, pulse1_pattern_offset+1
0001fb 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
0001fc 1ffb                      	adc ZH, r27
0001fd 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel0_check_if_note: //check if data is a note (0x00 - 0x56)
0001fe 35b7                      	cpi r27, 0x57
0001ff f408                      	brsh sound_driver_channel0_check_if_volume
000200 c122                      	rjmp sound_driver_channel0_note
                                 sound_driver_channel0_check_if_volume: //check if data is volume (0x57-0x66)
000201 36b7                      	cpi r27, 0x67
000202 f408                      	brsh sound_driver_channel0_check_if_delay
000203 c157                      	rjmp sound_driver_channel0_volume
                                 sound_driver_channel0_check_if_delay: //check if data is a delay (0x67 - 0xE2)
000204 3eb3                      	cpi r27, 0xE3
000205 f408                      	brsh sound_driver_channel0_check_if_instrument
000206 c15e                      	rjmp sound_driver_channel0_delay
                                 sound_driver_channel0_check_if_instrument: //check for instrument flag (0xE3)
000207 f409                      	brne sound_driver_channel0_check_if_release
000208 c161                      	rjmp sound_driver_channel0_instrument_change 
                                 sound_driver_channel0_check_if_release: //check for note release flag (0xE4)
000209 3eb4                      	cpi r27, 0xE4
00020a f409                      	brne sound_driver_channel0_check_if_end
00020b c208                      	rjmp sound_driver_channel0_release
                                 sound_driver_channel0_check_if_end:
00020c 3fbf                      	cpi r27, 0xFF
00020d f409                      	brne sound_driver_channel0_check_if_fx
00020e c22a                      	rjmp sound_driver_channel0_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel0_check_if_fx: //fx flags (0xE5 - 0xFE)
00020f 9631                      	adiw Z, 1 //point Z to the byte next to the flag
000210 91a4                      	lpm r26, Z //load the fx data into r26
000211 d24d                      	rcall sound_driver_channel0_increment_offset_twice
                                 
000212 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
000213 ebea                      	ldi ZL, LOW(fx << 1) //load in note table
000214 e0fe                      	ldi ZH, HIGH(fx << 1)
000215 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
000216 0feb                      	add ZL, r27 //add offset
000217 1df2                      	adc ZH, zero
000218 91c5                      	lpm r28, Z+ //load address bytes
000219 91d4                      	lpm r29, Z
00021a 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
00021b 2ffd                      	mov ZH, r29
00021c 9409                      	ijmp
                                 
                                 
                                 
                                 sound_driver_channel0_fx_0xy: //arpeggio
00021d cfd5                      	rjmp sound_driver_channel0
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel0_fx_1xx:
00021e 9220 2831                 	sts pulse1_fx_2xx, zero //turn off any 2xx pitch slide down
000220 9220 2832                 	sts pulse1_fx_2xx+1, zero
000222 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
000223 937f                      	push r23
000224 2f6a                      	mov r22, r26 //store the rate into r22
000225 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
000226 9f67                      	mul r22, r23
000227 917f                      	pop r23
000228 916f                      	pop r22
                                 
000229 9416                      	lsr r1 //shift out the fractional bits
00022a 9407                      	ror r0
00022b 9416                      	lsr r1
00022c 9407                      	ror r0
00022d 9416                      	lsr r1
00022e 9407                      	ror r0
00022f 9416                      	lsr r1
000230 9407                      	ror r0
000231 9200 282d                 	sts pulse1_fx_1xx, r0
000233 9210 282e                 	sts pulse1_fx_1xx+1, r1
000235 cfbd                      	rjmp sound_driver_channel0
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel0_fx_2xx:
000236 9220 282d                 	sts pulse1_fx_1xx, zero //turn off any 1xx pitch slide down
000238 9220 282e                 	sts pulse1_fx_1xx+1, zero
00023a 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00023b 937f                      	push r23
00023c 2f6a                      	mov r22, r26 //store the rate into r22
00023d eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00023e 9f67                      	mul r22, r23
00023f 917f                      	pop r23
000240 916f                      	pop r22
                                 
000241 9416                      	lsr r1 //shift out the fractional bits
000242 9407                      	ror r0
000243 9416                      	lsr r1
000244 9407                      	ror r0
000245 9416                      	lsr r1
000246 9407                      	ror r0
000247 9416                      	lsr r1
000248 9407                      	ror r0
000249 9200 2831                 	sts pulse1_fx_2xx, r0
00024b 9210 2832                 	sts pulse1_fx_2xx+1, r1
00024d cfa5                      	rjmp sound_driver_channel0
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel0_fx_3xx:
00024e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00024f 937f                      	push r23
000250 2f6a                      	mov r22, r26 //store the rate into r22
000251 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
000252 9f67                      	mul r22, r23
000253 917f                      	pop r23
000254 916f                      	pop r22
                                 
000255 9416                      	lsr r1 //shift out the fractional bits
000256 9407                      	ror r0
000257 9416                      	lsr r1
000258 9407                      	ror r0
000259 9416                      	lsr r1
00025a 9407                      	ror r0
00025b 9416                      	lsr r1
00025c 9407                      	ror r0
00025d 9200 2839                 	sts pulse1_fx_3xx_speed, r0
00025f 9210 283a                 	sts pulse1_fx_3xx_speed+1, r1
                                 
000261 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
000262 c001                      	rjmp sound_driver_channel0_fx_3xx_enabled
000263 cf8f                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_channel0_fx_3xx_enabled:
000264 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
000266 91b0 0a8d                 	lds r27, TCB0_CCMPH
000268 93a0 2835                 	sts pulse1_fx_3xx_start, r26
00026a 93b0 2836                 	sts pulse1_fx_3xx_start+1, r27
                                 
00026c 9220 283b                 	sts pulse1_fx_3xx_total_offset, zero
00026e 9220 283c                 	sts pulse1_fx_3xx_total_offset+1, zero
000270 cf82                      	rjmp sound_driver_channel0
                                 
                                 //VIBRATO
                                 sound_driver_channel0_fx_4xy:
000271 cf81                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_7xy: //tremelo effect
000272 cf80                      	rjmp sound_driver_channel0
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel0_fx_Axy:
000273 93a0 283e                 	sts pulse1_fx_Axy, r26
000275 cf7d                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_channel0_fx_Bxx: //pattern jump
000276 cf7c                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Cxx: //halt
000277 cf7b                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Dxx: //frame skip
000278 cf7a                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Exx: //volume
000279 cf79                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Fxx: //speed and tempo
00027a cf78                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Gxx: //note delay
00027b cf77                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Hxy: //hardware sweep up
00027c cf76                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_lxy: //hardware sweep down
00027d cf75                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Hxx: //FDS modulation depth
00027e cf74                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Ixx: //FDS modulation speed
00027f cf73                      	rjmp sound_driver_channel0
                                 
                                 //FINE PITCH
                                 sound_driver_channel0_fx_Pxx:
000280 93a0 283d                 	sts pulse1_fx_Pxx, r26
000282 cf70                      	rjmp sound_driver_channel0
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel0_fx_Qxy:
                                 sound_driver_channel0_fx_Qxy_check_arpeggio_macro:
000283 91e0 2816                 	lds ZL, pulse1_arpeggio_macro
000285 91f0 2817                 	lds ZH, pulse1_arpeggio_macro+1
000287 9630                      	adiw Z, 0
000288 f009                      	breq sound_driver_channel0_fx_Qxy_check_pitch_macro
000289 cf69                      	rjmp sound_driver_channel0 //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_pitch_macro:
00028a 91e0 281d                 	lds ZL, pulse1_pitch_macro
00028c 91f0 281e                 	lds ZH, pulse1_pitch_macro+1
00028e 9630                      	adiw Z, 0
00028f f009                      	breq sound_driver_channel0_fx_Qxy_check_hi_pitch_macro
000290 cf62                      	rjmp sound_driver_channel0 //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_hi_pitch_macro:
000291 91e0 2823                 	lds ZL, pulse1_hi_pitch_macro
000293 91f0 2824                 	lds ZH, pulse1_hi_pitch_macro+1
000295 9630                      	adiw Z, 0
000296 f009                      	breq sound_driver_channel0_fx_Qxy_process
000297 cf5b                      	rjmp sound_driver_channel0 //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_process:
000298 2fba                      	mov r27, r26 //copy fx parameters into r27
000299 70bf                      	andi r27, 0x0F //mask note index offset
00029a 91c0 2807                 	lds r28, pulse1_note //load current note index
00029c 0fbc                      	add r27, r28
00029d 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
00029e f008                      	brlo sound_driver_channel0_fx_Qxy_process_continue
00029f e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel0_fx_Qxy_process_continue:
0002a0 e3e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0002a1 e0f0                      	ldi ZH, HIGH(note_table << 1)
0002a2 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
0002a3 0feb                      	add ZL, r27 //add offset
0002a4 1df2                      	adc ZH, zero
0002a5 91c5                      	lpm r28, Z+ //load bytes
0002a6 91d4                      	lpm r29, Z
0002a7 93c0 283f                 	sts pulse1_fx_Qxy_target, r28 //load the LOW bits for the target period
0002a9 93d0 2840                 	sts pulse1_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
0002ab 95a2                      	swap r26
0002ac 70af                      	andi r26, 0x0F //mask effect speed
0002ad 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0002ae 95a3                      	inc r26 //increment the speed by 1
                                 
0002af 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0002b0 937f                      	push r23
0002b1 2f6a                      	mov r22, r26 //store the speed data into r27
0002b2 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0002b3 9f67                      	mul r22, r23
0002b4 917f                      	pop r23
0002b5 916f                      	pop r22
                                 
0002b6 9416                      	lsr r1 //shift out the fractional bits
0002b7 9407                      	ror r0
0002b8 9416                      	lsr r1
0002b9 9407                      	ror r0
0002ba 9416                      	lsr r1
0002bb 9407                      	ror r0
0002bc 9416                      	lsr r1
0002bd 9407                      	ror r0
                                 
0002be 9200 2841                 	sts pulse1_fx_Qxy_speed, r0 //store the effect speed
0002c0 9210 2842                 	sts pulse1_fx_Qxy_speed+1, r1
0002c2 9220 2843                 	sts pulse1_fx_Qxy_total_offset, zero
0002c4 9220 2844                 	sts pulse1_fx_Qxy_total_offset+1, zero
0002c6 cf2c                      	rjmp sound_driver_channel0
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel0_fx_Rxy:
                                 sound_driver_channel0_fx_Rxy_check_arpeggio_macro:
0002c7 91e0 2816                 	lds ZL, pulse1_arpeggio_macro
0002c9 91f0 2817                 	lds ZH, pulse1_arpeggio_macro+1
0002cb 9630                      	adiw Z, 0
0002cc f009                      	breq sound_driver_channel0_fx_Rxy_check_pitch_macro
0002cd cf25                      	rjmp sound_driver_channel0 //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_pitch_macro:
0002ce 91e0 281d                 	lds ZL, pulse1_pitch_macro
0002d0 91f0 281e                 	lds ZH, pulse1_pitch_macro+1
0002d2 9630                      	adiw Z, 0
0002d3 f009                      	breq sound_driver_channel0_fx_Rxy_check_hi_pitch_macro
0002d4 cf1e                      	rjmp sound_driver_channel0 //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_hi_pitch_macro:
0002d5 91e0 2823                 	lds ZL, pulse1_hi_pitch_macro
0002d7 91f0 2824                 	lds ZH, pulse1_hi_pitch_macro+1
0002d9 9630                      	adiw Z, 0
0002da f009                      	breq sound_driver_channel0_fx_Rxy_process
0002db cf17                      	rjmp sound_driver_channel0 //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_process:
0002dc 2fba                      	mov r27, r26 //copy fx parameters into r27
0002dd 70bf                      	andi r27, 0x0F //mask note index offset
0002de 91c0 2807                 	lds r28, pulse1_note //load current note index
0002e0 1bcb                      	sub r28, r27
0002e1 f408                      	brcc sound_driver_channel0_fx_Rxy_process_continue
0002e2 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel0_fx_Rxy_process_continue:
0002e3 e3e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0002e4 e0f0                      	ldi ZH, HIGH(note_table << 1)
0002e5 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
0002e6 0fec                      	add ZL, r28 //add offset
0002e7 1df2                      	adc ZH, zero
0002e8 91c5                      	lpm r28, Z+ //load bytes
0002e9 91d4                      	lpm r29, Z
0002ea 93c0 2845                 	sts pulse1_fx_Rxy_target, r28 //load the LOW bits for the target period
0002ec 93d0 2846                 	sts pulse1_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
0002ee 95a2                      	swap r26
0002ef 70af                      	andi r26, 0x0F //mask effect speed
0002f0 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0002f1 95a3                      	inc r26 //increment the speed by 1
                                 
0002f2 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0002f3 937f                      	push r23
0002f4 2f6a                      	mov r22, r26 //store the speed data into r27
0002f5 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0002f6 9f67                      	mul r22, r23
0002f7 917f                      	pop r23
0002f8 916f                      	pop r22
                                 
0002f9 9416                      	lsr r1 //shift out the fractional bits
0002fa 9407                      	ror r0
0002fb 9416                      	lsr r1
0002fc 9407                      	ror r0
0002fd 9416                      	lsr r1
0002fe 9407                      	ror r0
0002ff 9416                      	lsr r1
000300 9407                      	ror r0
                                 
000301 9200 2847                 	sts pulse1_fx_Rxy_speed, r0 //store the effect speed
000303 9210 2848                 	sts pulse1_fx_Rxy_speed+1, r1
000305 9220 2849                 	sts pulse1_fx_Rxy_total_offset, zero
000307 9220 284a                 	sts pulse1_fx_Rxy_total_offset+1, zero
000309 cee9                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_channel0_fx_Sxx: //mute delay
00030a cee8                      	rjmp sound_driver_channel0
                                 
                                 //DUTY
                                 sound_driver_channel0_fx_Vxx:
00030b e0fe                      	ldi ZH, HIGH(sequences << 1) //point Z to sequence table
00030c ebe6                      	ldi ZL, LOW(sequences << 1)
00030d 0fea                      	add ZL, r26 //offset the pointer
00030e 1df2                      	adc ZH, zero
                                 
00030f 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
000310 95a7                      	ror r26
000311 95a7                      	ror r26
000312 91b0 2800                 	lds r27, pulse1_param //load r27 with pulse1_param (register $4000)
000314 2fcb                      	mov r28, r27 //store a copy of pulse1_param into r28
000315 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
000316 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
000317 c001                      	rjmp sound_driver_channel0_fx_Vxx_store
000318 ceda                      	rjmp sound_driver_channel0 //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel0_fx_Vxx_store:
000319 90d4                      	lpm pulse1_sequence, Z //store the sequence
                                 
00031a 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
00031b 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
00031c 93c0 2800                 	sts pulse1_param, r28
00031e ced4                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_channel0_fx_Wxx: //DPCM sample speed
00031f ced3                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Xxx: //DPCM sample retrigger
000320 ced2                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Yxx: //DPCM sample offset
000321 ced1                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Zxx: //DPCM sample delta counter
000322 ced0                      	rjmp sound_driver_channel0
                                 
                                 
                                 sound_driver_channel0_note:
000323 93b0 2807                 	sts pulse1_note, r27 //store the note index
000325 e0a3                      	ldi r26, 0x03
000326 e0b2                      	ldi r27, 0x02
000327 93b0 2813                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
000329 93a0 2818                 	sts pulse1_arpeggio_macro_offset, r26
00032b 93b0 281f                 	sts pulse1_pitch_macro_offset, r27
00032d 93b0 2825                 	sts pulse1_hi_pitch_macro_offset, r27
00032f 93b0 282a                 	sts pulse1_duty_macro_offset, r27
000331 9220 281c                 	sts pulse1_total_pitch_offset, zero //reset the pitch and hi pitch offset
000333 9220 2822                 	sts pulse1_total_hi_pitch_offset, zero
000335 9220 282f                 	sts pulse1_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
000337 9220 2830                 	sts pulse1_fx_1xx_total+1, zero
000339 9220 2833                 	sts pulse1_fx_2xx_total, zero
00033b 9220 2834                 	sts pulse1_fx_2xx_total+1, zero
00033d 9220 283b                 	sts pulse1_fx_3xx_total_offset, zero //reset 3xx offset
00033f 9220 283c                 	sts pulse1_fx_3xx_total_offset+1, zero
000341 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
000343 91b0 0a8d                 	lds r27, TCB0_CCMPH
000345 93a0 2835                 	sts pulse1_fx_3xx_start, r26
000347 93b0 2836                 	sts pulse1_fx_3xx_start+1, r27
000349 9220 283f                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00034b 9220 2840                 	sts pulse1_fx_Qxy_target+1, zero
00034d 9220 2843                 	sts pulse1_fx_Qxy_total_offset, zero
00034f 9220 2844                 	sts pulse1_fx_Qxy_total_offset+1, zero
000351 9220 2845                 	sts pulse1_fx_Rxy_target, zero
000353 9220 2846                 	sts pulse1_fx_Rxy_target+1, zero
000355 9220 2849                 	sts pulse1_fx_Rxy_total_offset, zero
000357 9220 284a                 	sts pulse1_fx_Rxy_total_offset+1, zero
000359 d0fb                      	rcall sound_driver_channel0_increment_offset
00035a ce98                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0_volume:
00035b 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
00035c 91a0 2800                 	lds r26, pulse1_param
00035e 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
00035f 2bab                      	or r26, r27 //move new VVVV bits into pulse1_param
000360 93a0 2800                 	sts pulse1_param, r26
000362 6096                      	sbr channel_flags, 6
000363 d0f1                      	rcall sound_driver_channel0_increment_offset
000364 ce8e                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0_delay:
000365 56b7                      	subi r27, 0x67 //NOTE: the delay values are offset by the highest volume value, which is 0x66
000366 93b0 280e                 	sts pulse1_pattern_delay, r27
000368 d0ec                      	rcall sound_driver_channel0_increment_offset
000369 c102                      	rjmp sound_driver_instrument_routine
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change:
00036a 9220 2811                 	sts pulse1_volume_macro, zero //reset all macro addresses
00036c 9220 2812                 	sts pulse1_volume_macro+1, zero
00036e 9220 2816                 	sts pulse1_arpeggio_macro, zero
000370 9220 2817                 	sts pulse1_arpeggio_macro+1, zero
000372 9220 281d                 	sts pulse1_pitch_macro, zero
000374 9220 281e                 	sts pulse1_pitch_macro+1, zero
000376 9220 2823                 	sts pulse1_hi_pitch_macro, zero
000378 9220 2824                 	sts pulse1_hi_pitch_macro+1, zero
00037a 9220 2828                 	sts pulse1_duty_macro, zero
00037c 9220 2829                 	sts pulse1_duty_macro+1, zero
00037e 9220 281c                 	sts pulse1_total_pitch_offset, zero //reset the pitch offset
000380 9220 2822                 	sts pulse1_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
000382 9631                      	adiw Z, 1 //point to the byte next to the flag
000383 91b4                      	lpm r27, Z //store the instrument offset into r27
000384 ebe5                      	ldi ZL, LOW(instruments) //point Z to instruments table
000385 e0f0                      	ldi ZH, HIGH(instruments)
000386 0feb                      	add ZL, r27 //point Z to offsetted instrument
000387 1df2                      	adc ZH, zero
000388 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
000389 1fff                      	rol ZH
00038a 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
00038b 91b4                      	lpm r27, Z
                                 
00038c 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
00038d 1fbb                      	rol r27
00038e 2fea                      	mov ZL, r26
00038f 2ffb                      	mov ZH, r27
000390 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
000391 9632                      	adiw Z, 2 //point Z to the address of the macro
000392 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel0_instrument_change_macro_loop:
000393 95aa                      	dec r26
000394 f019                      	breq sound_driver_channel0_instrument_change_exit
000395 95b6                      	lsr r27
000396 f078                      	brcs sound_driver_channel0_instrument_change_load_macro
000397 cffb                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_exit:
000398 e0a3                      	ldi r26, 0x03
000399 e0b2                      	ldi r27, 0x02
00039a 93b0 2813                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
00039c 93a0 2818                 	sts pulse1_arpeggio_macro_offset, r26
00039e 93b0 281f                 	sts pulse1_pitch_macro_offset, r27
0003a0 93b0 2825                 	sts pulse1_hi_pitch_macro_offset, r27
0003a2 93b0 282a                 	sts pulse1_duty_macro_offset, r27
0003a4 d0ba                      	rcall sound_driver_channel0_increment_offset_twice
0003a5 ce4d                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_load_macro:
0003a6 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
0003a7 91d5                      	lpm r29, Z+
                                 
0003a8 30a5                      	cpi r26, 5
0003a9 f039                      	breq sound_driver_channel0_instrument_change_load_macro_volume
0003aa 30a4                      	cpi r26, 4
0003ab f079                      	breq sound_driver_channel0_instrument_change_load_macro_arpeggio
0003ac 30a3                      	cpi r26, 3
0003ad f0d9                      	breq sound_driver_channel0_instrument_change_load_macro_pitch
0003ae 30a2                      	cpi r26, 2
0003af f159                      	breq sound_driver_channel0_instrument_change_load_macro_hi_pitch
0003b0 c03c                      	rjmp sound_driver_channel0_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel0_instrument_change_load_macro_volume:
0003b1 93c0 2811                 	sts pulse1_volume_macro, r28
0003b3 93d0 2812                 	sts pulse1_volume_macro+1, r29
0003b5 d041                      	rcall sound_driver_channel0_instrument_change_read_header
0003b6 93c0 2815                 	sts pulse1_volume_macro_release, r28
0003b8 93d0 2814                 	sts pulse1_volume_macro_loop, r29
0003ba cfd8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 	
                                 sound_driver_channel0_instrument_change_load_macro_arpeggio:
0003bb 93c0 2816                 	sts pulse1_arpeggio_macro, r28
0003bd 93d0 2817                 	sts pulse1_arpeggio_macro+1, r29
0003bf 9220 283f                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0003c1 9220 2840                 	sts pulse1_fx_Qxy_target+1, zero
0003c3 9220 2845                 	sts pulse1_fx_Rxy_target, zero
0003c5 9220 2846                 	sts pulse1_fx_Rxy_target+1, zero
0003c7 d03a                      	rcall sound_driver_channel0_instrument_change_read_header_arpeggio
0003c8 cfca                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_pitch:
0003c9 93c0 281d                 	sts pulse1_pitch_macro, r28
0003cb 93d0 281e                 	sts pulse1_pitch_macro+1, r29
0003cd 9220 283f                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0003cf 9220 2840                 	sts pulse1_fx_Qxy_target+1, zero
0003d1 9220 2845                 	sts pulse1_fx_Rxy_target, zero
0003d3 9220 2846                 	sts pulse1_fx_Rxy_target+1, zero
0003d5 d021                      	rcall sound_driver_channel0_instrument_change_read_header
0003d6 93c0 2821                 	sts pulse1_pitch_macro_release, r28
0003d8 93d0 2820                 	sts pulse1_pitch_macro_loop, r29
0003da cfb8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_hi_pitch:
0003db 93c0 2823                 	sts pulse1_hi_pitch_macro, r28
0003dd 93d0 2824                 	sts pulse1_hi_pitch_macro+1, r29
0003df 9220 283f                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0003e1 9220 2840                 	sts pulse1_fx_Qxy_target+1, zero
0003e3 9220 2845                 	sts pulse1_fx_Rxy_target, zero
0003e5 9220 2846                 	sts pulse1_fx_Rxy_target+1, zero
0003e7 d00f                      	rcall sound_driver_channel0_instrument_change_read_header
0003e8 93c0 2827                 	sts pulse1_hi_pitch_macro_release, r28
0003ea 93d0 2826                 	sts pulse1_hi_pitch_macro_loop, r29
0003ec cfa6                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_duty:
0003ed 93c0 2828                 	sts pulse1_duty_macro, r28
0003ef 93d0 2829                 	sts pulse1_duty_macro+1, r29
0003f1 d005                      	rcall sound_driver_channel0_instrument_change_read_header
0003f2 93c0 282c                 	sts pulse1_duty_macro_release, r28
0003f4 93d0 282b                 	sts pulse1_duty_macro_loop, r29
0003f6 cf9c                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_read_header:
0003f7 93ef                      	push ZL
0003f8 93ff                      	push ZH
0003f9 2fec                      	mov ZL, r28
0003fa 2ffd                      	mov ZH, r29
0003fb 0fee                      	lsl ZL
0003fc 1fff                      	rol ZH
0003fd 91c5                      	lpm r28, Z+
0003fe 91d4                      	lpm r29, Z
0003ff 91ff                      	pop ZH
000400 91ef                      	pop ZL
000401 9508                      	ret
                                 
                                 sound_driver_channel0_instrument_change_read_header_arpeggio:
000402 93ef                      	push ZL
000403 93ff                      	push ZH
000404 2fec                      	mov ZL, r28
000405 2ffd                      	mov ZH, r29
000406 0fee                      	lsl ZL
000407 1fff                      	rol ZH
000408 91c5                      	lpm r28, Z+
000409 91d5                      	lpm r29, Z+
00040a 93c0 281a                 	sts pulse1_arpeggio_macro_release, r28
00040c 93d0 2819                 	sts pulse1_arpeggio_macro_loop, r29
00040e 91c4                      	lpm r28, Z
00040f 93c0 281b                 	sts pulse1_arpeggio_macro_mode, r28
000411 91ff                      	pop ZH
000412 91ef                      	pop ZL
000413 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel0_release:
                                 sound_driver_channel0_release_volume:
000414 91b0 2815                 	lds r27, pulse1_volume_macro_release
000416 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
000417 f019                      	breq sound_driver_channel0_release_arpeggio //if the macro has no release flag, check the next macro
000418 95b3                      	inc r27
000419 93b0 2813                 	sts pulse1_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel0_release_arpeggio:
00041b 91b0 281a                 	lds r27, pulse1_arpeggio_macro_release
00041d 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
00041e f019                      	breq sound_driver_channel0_release_pitch
00041f 95b3                      	inc r27
000420 93b0 2818                 	sts pulse1_arpeggio_macro_offset, r27
                                 sound_driver_channel0_release_pitch:
000422 91b0 2821                 	lds r27, pulse1_pitch_macro_release
000424 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
000425 f019                      	breq sound_driver_channel0_release_hi_pitch
000426 95b3                      	inc r27
000427 93b0 281f                 	sts pulse1_pitch_macro_offset, r27
                                 sound_driver_channel0_release_hi_pitch:
000429 91b0 2827                 	lds r27, pulse1_hi_pitch_macro_release
00042b 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
00042c f019                      	breq sound_driver_channel0_release_duty
00042d 95b3                      	inc r27
00042e 93b0 2825                 	sts pulse1_hi_pitch_macro_offset, r27
                                 sound_driver_channel0_release_duty:
000430 91b0 282c                 	lds r27, pulse1_duty_macro_release
000432 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
000433 f019                      	breq sound_driver_channel0_release_exit
000434 95b3                      	inc r27
000435 93b0 282a                 	sts pulse1_duty_macro_offset, r27
                                 sound_driver_channel0_release_exit:
000437 d01d                      	rcall sound_driver_channel0_increment_offset
000438 cdba                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0_next_pattern:
000439 91e0 2808                 	lds ZL, song_frames
00043b 91f0 2809                 	lds ZH, song_frames+1
00043d 91a0 280a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
00043f 91b0 280b                 	lds r27, song_frame_offset+1
000441 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
000442 93a0 280a                 	sts song_frame_offset, r26
000444 93b0 280b                 	sts song_frame_offset+1, r27
                                 	//adiw r27:r26, 2 //offset for channel 1 (test)
000446 0fea                      	add ZL, r26
000447 1ffb                      	adc ZH, r27
                                 
000448 91a5                      	lpm r26, Z+ //load the address of the next pattern
000449 91b4                      	lpm r27, Z
00044a 0faa                      	lsl r26
00044b 1fbb                      	rol r27
00044c 93a0 280c                 	sts pulse1_pattern, r26
00044e 93b0 280d                 	sts pulse1_pattern+1, r27
                                 
000450 9220 280f                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
000452 9220 2810                 	sts pulse1_pattern_offset+1, zero
000454 cd9e                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0_increment_offset:
000455 91e0 280f                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
000457 91f0 2810                 	lds ZH, pulse1_pattern_offset+1
000459 9631                      	adiw Z, 1
00045a 93e0 280f                 	sts pulse1_pattern_offset, ZL
00045c 93f0 2810                 	sts pulse1_pattern_offset+1, ZH
00045e 9508                      	ret
                                 
                                 sound_driver_channel0_increment_offset_twice: //used for data that takes up 2 bytes worth of space
00045f 91e0 280f                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
000461 91f0 2810                 	lds ZH, pulse1_pattern_offset+1
000463 9632                      	adiw Z, 2 //increment the pointer twice
000464 93e0 280f                 	sts pulse1_pattern_offset, ZL
000466 93f0 2810                 	sts pulse1_pattern_offset+1, ZH
000468 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_decrement_frame_delay:
000469 95ba                      	dec r27
00046a 93b0 280e                 	sts pulse1_pattern_delay, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine:
                                 sound_driver_instrument_routine_channel0_volume:
00046c 91e0 2811                 	lds ZL, pulse1_volume_macro
00046e 91f0 2812                 	lds ZH, pulse1_volume_macro+1
000470 9630                      	adiw Z, 0
000471 f181                      	breq sound_driver_instrument_routine_channel0_volume_default //if no volume macro is in use, use default multiplier of F
000472 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
000473 1fff                      	rol ZH
000474 91a0 2813                 	lds r26, pulse1_volume_macro_offset
000476 0fea                      	add ZL, r26
000477 1df2                      	adc ZH, zero
                                 
000478 91b0 2815                 	lds r27, pulse1_volume_macro_release
00047a 17ba                      	cp r27, r26
00047b f429                      	brne sound_driver_instrument_routine_channel0_volume_increment //if the current offset is not equal to the release index, increment the offset
00047c 91a0 2814                 	lds r26, pulse1_volume_macro_loop
00047e 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00047f f010                      	brlo sound_driver_instrument_routine_channel0_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
000480 c003                      	rjmp sound_driver_instrument_routine_channel0_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_volume_increment:
000481 95a3                      	inc r26 //increment the macro offset
000482 93a0 2813                 	sts pulse1_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_volume_read:
000484 91b4                      	lpm r27, Z //load volume data into r27
000485 3fbf                      	cpi r27, 0xFF //check for macro end flag
000486 f469                      	brne sound_driver_instrument_routine_channel0_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_release:
000487 91b0 2815                 	lds r27, pulse1_volume_macro_release
000489 3fbf                      	cpi r27, 0xFF
00048a f429                      	brne sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_loop:
00048b 91b0 2814                 	lds r27, pulse1_volume_macro_loop //load the loop index
00048d 93b0 2813                 	sts pulse1_volume_macro_offset, r27 //store the loop index into the offset
00048f cfdc                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index:
000490 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
000491 93a0 2813                 	sts pulse1_volume_macro_offset, r26
000493 cfd8                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_calculate:
000494 eeee                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
000495 e0fe                      	ldi ZH, HIGH(volumes << 1)
000496 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
000497 0feb                      	add ZL, r27 //add offset to the table
000498 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel0_volume_load:
000499 91b0 2800                 	lds r27, pulse1_param //load main volume
00049b 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
00049c 0feb                      	add ZL, r27 //offset the volume table by the main volume
00049d 1df2                      	adc ZH, zero
00049e 91b4                      	lpm r27, Z
00049f 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
0004a1 c005                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default:
0004a2 91b0 2800                 	lds r27, pulse1_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
0004a4 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
0004a5 93b0 2806                 	sts pulse1_output_volume, r27
                                 	
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
0004a7 91e0 2816                 	lds ZL, pulse1_arpeggio_macro
0004a9 91f0 2817                 	lds ZH, pulse1_arpeggio_macro+1
0004ab 9630                      	adiw Z, 0
0004ac f1f9                      	breq sound_driver_instrument_routine_channel0_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
0004ad 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0004ae 1fff                      	rol ZH
0004af 91a0 2818                 	lds r26, pulse1_arpeggio_macro_offset
0004b1 0fea                      	add ZL, r26
0004b2 1df2                      	adc ZH, zero
                                 
0004b3 91b0 281a                 	lds r27, pulse1_arpeggio_macro_release
0004b5 17ba                      	cp r27, r26
0004b6 f429                      	brne sound_driver_instrument_routine_channel0_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
0004b7 91a0 2819                 	lds r26, pulse1_arpeggio_macro_loop
0004b9 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0004ba f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
0004bb c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_increment:
0004bc 95a3                      	inc r26 //increment the macro offset
0004bd 93a0 2818                 	sts pulse1_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_read:
0004bf 91b4                      	lpm r27, Z //load arpeggio data into r27
0004c0 38b0                      	cpi r27, 0x80 //check for macro end flag
0004c1 f4f9                      	brne sound_driver_instrument_routine_channel0_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_check_mode:
0004c2 50a1                      	subi r26, 1 //keep the offset at the end flag
0004c3 93a0 2818                 	sts pulse1_arpeggio_macro_offset, r26
0004c5 91b0 281b                 	lds r27, pulse1_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
0004c7 30b1                      	cpi r27, 0x01
0004c8 f048                      	brlo sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_release:
0004c9 91b0 281a                 	lds r27, pulse1_arpeggio_macro_release
0004cb 3fbf                      	cpi r27, 0xFF
0004cc f4f9                      	brne sound_driver_instrument_routine_channel0_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_loop:
0004cd 91b0 2819                 	lds r27, pulse1_arpeggio_macro_loop
0004cf 3fbf                      	cpi r27, 0xFF
0004d0 f469                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
0004d1 c01a                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute:
0004d2 91b0 281a                 	lds r27, pulse1_arpeggio_macro_release
0004d4 3fbf                      	cpi r27, 0xFF
0004d5 f421                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_check_loop:
0004d6 91b0 2819                 	lds r27, pulse1_arpeggio_macro_loop //load the loop index
0004d8 3fbf                      	cpi r27, 0xFF //check if loop flag exists
0004d9 f421                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop:
0004da 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
0004db 93a0 2818                 	sts pulse1_arpeggio_macro_offset, r26 //store the last valid index into the offset
0004dd cfc9                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload:
0004de 93b0 2818                 	sts pulse1_arpeggio_macro_offset, r27 //store the loop index into the offset
0004e0 cfc6                      	rjmp sound_driver_instrument_routine_channel0_arpeggio //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process:
0004e1 9220 281c                 	sts pulse1_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
0004e3 9220 2822                 	sts pulse1_total_hi_pitch_offset, zero
0004e5 91a0 281b                 	lds r26, pulse1_arpeggio_macro_mode
0004e7 30a0                      	cpi r26, 0x00 //absolute mode
0004e8 f031                      	breq sound_driver_instrument_routine_channel0_arpeggio_process_absolute
0004e9 30a1                      	cpi r26, 0x01 //fixed mode
0004ea f081                      	breq sound_driver_instrument_routine_channel0_arpeggio_process_fixed
0004eb c011                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_default:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
0004ec 91a0 2807                 	lds r26, pulse1_note //load the current note index
0004ee c01f                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute:
0004ef 91a0 2807                 	lds r26, pulse1_note //load the current note index
0004f1 0fab                      	add r26, r27 //offset the note with the arpeggio data
0004f2 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0004f3 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_add:
0004f4 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0004f5 f0c0                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
0004f6 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0004f7 c016                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract:
0004f8 fda7                      	sbrc r26, 7 //check if result is negative
0004f9 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0004fa c013                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_fixed:
0004fb 2fab                      	mov r26, r27 //move the arpeggio data into r26
0004fc c011                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative:
0004fd 91a0 2807                 	lds r26, pulse1_note //load the current note index
0004ff 0fab                      	add r26, r27 //offset the note with the arpeggio data
000500 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
000501 c008                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_add:
000502 93a0 2807                 	sts pulse1_note, r26 //NOTE: relative mode modifies the original note index
000504 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
000505 f040                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
000506 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
000507 93a0 2807                 	sts pulse1_note, r26
000509 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract:
00050a fda7                      	sbrc r26, 7 //check if result is negative
00050b e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
00050c 93a0 2807                 	sts pulse1_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_load:
00050e e3e4                      	ldi ZL, LOW(note_table << 1) //load in note table
00050f e0f0                      	ldi ZH, HIGH(note_table << 1)
000510 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
000511 0fea                      	add ZL, r26 //add offset
000512 1df2                      	adc ZH, zero
000513 91a5                      	lpm r26, Z+ //load bytes
000514 91b4                      	lpm r27, Z
000515 93a0 0a8c                 	sts TCB0_CCMPL, r26 //load the LOW bits for timer
000517 93b0 0a8d                 	sts TCB0_CCMPH, r27 //load the HIGH bits for timer
000519 93a0 2837                 	sts pulse1_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
00051b 93b0 2838                 	sts pulse1_fx_3xx_target+1, r27
00051d c000                      	rjmp sound_driver_instrument_routine_channel0_pitch
                                 
                                 
                                 
                                 //NOTE: There is a limitation with the pitch routines in that the total pitch can not be offset by 127 in both,
                                 //the positive and negative direction, from the original note pitch. This shouldn't be too much of a problem as
                                 //most songs that use instruments with the pitch macro, do not stray that far from the original note pitch.
                                 //In the case of hi pitch, the total pitch can not be offset by 127*16 from the original pitch. This is also
                                 //not a big deal as you can easily reach the entire note range with an offset of up to 127*16.
                                 sound_driver_instrument_routine_channel0_pitch:
00051e 91e0 281d                 	lds ZL, pulse1_pitch_macro
000520 91f0 281e                 	lds ZH, pulse1_pitch_macro+1
000522 9630                      	adiw Z, 0
000523 f409                      	brne sound_driver_instrument_routine_channel0_pitch_continue
000524 c023                      	rjmp sound_driver_instrument_routine_channel0_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel0_pitch_continue:
000525 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
000526 1fff                      	rol ZH
000527 91a0 281f                 	lds r26, pulse1_pitch_macro_offset
000529 0fea                      	add ZL, r26
00052a 1df2                      	adc ZH, zero
                                 
00052b 91b0 2821                 	lds r27, pulse1_pitch_macro_release
00052d 17ba                      	cp r27, r26
00052e f429                      	brne sound_driver_instrument_routine_channel0_pitch_increment //if the current offset is not equal to the release index, increment the offset
00052f 91a0 2820                 	lds r26, pulse1_pitch_macro_loop
000531 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
000532 f010                      	brlo sound_driver_instrument_routine_channel0_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
000533 c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_pitch_increment:
000534 95a3                      	inc r26 //increment the macro offset
000535 93a0 281f                 	sts pulse1_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_pitch_read:
000537 91b4                      	lpm r27, Z //load pitch data into r27
000538 38b0                      	cpi r27, 0x80 //check for macro end flag
000539 f489                      	brne sound_driver_instrument_routine_channel0_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_release:
00053a 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00053b 93a0 281f                 	sts pulse1_pitch_macro_offset, r26
00053d 91b0 2821                 	lds r27, pulse1_pitch_macro_release
00053f 3fbf                      	cpi r27, 0xFF
000540 f439                      	brne sound_driver_instrument_routine_channel0_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_loop:
000541 91b0 2820                 	lds r27, pulse1_pitch_macro_loop //load the loop index
000543 3fbf                      	cpi r27, 0xFF //check if there is a loop index
000544 f019                      	breq sound_driver_instrument_routine_channel0_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
000545 93b0 281f                 	sts pulse1_pitch_macro_offset, r27 //store the loop index into the offset
000547 cfd6                      	rjmp sound_driver_instrument_routine_channel0_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_default:
000548 91b0 281c                 	lds r27, pulse1_total_pitch_offset
00054a c005                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate:
00054b 91a0 281c                 	lds r26, pulse1_total_pitch_offset //load the total pitch offset to change
00054d 0fba                      	add r27, r26
00054e 93b0 281c                 	sts pulse1_total_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_multiply:
                                 	//NOTE: The Pxx effect is processed with the pitch instrument macro because the calculations are the same
000550 91a0 283d                 	lds r26, pulse1_fx_Pxx
000552 0fba                      	add r27, r26
                                 
000553 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
000554 937f                      	push r23
000555 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
000556 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
000557 0367                      	mulsu r22, r23
000558 917f                      	pop r23
000559 916f                      	pop r22
                                 
00055a 9416                      	lsr r1 //shift out the fractional bits
00055b 9407                      	ror r0
00055c 9416                      	lsr r1
00055d 9407                      	ror r0
00055e 9416                      	lsr r1
00055f 9407                      	ror r0
000560 9416                      	lsr r1
000561 9407                      	ror r0
000562 fe13                      	sbrs r1, 3 //check if result was a negative number
000563 c002                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_negative:
000564 efb0                      	ldi r27, 0xF0
000565 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_offset:
000566 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
000568 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
00056a 0da0                      	add r26, r0 //offset the timer values
00056b 1db1                      	adc r27, r1
                                 	
00056c 91c0 282f                 	lds r28, pulse1_fx_1xx_total
00056e 91d0 2830                 	lds r29, pulse1_fx_1xx_total+1
000570 1bac                      	sub r26, r28
000571 0bbd                      	sbc r27, r29
000572 91c0 2833                 	lds r28, pulse1_fx_2xx_total
000574 91d0 2834                 	lds r29, pulse1_fx_2xx_total+1
000576 0fac                      	add r26, r28
000577 1fbd                      	adc r27, r29
000578 91c0 2843                 	lds r28, pulse1_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
00057a 91d0 2844                 	lds r29, pulse1_fx_Qxy_total_offset+1
00057c 1bac                      	sub r26, r28
00057d 0bbd                      	sbc r27, r29
00057e 91c0 2849                 	lds r28, pulse1_fx_Rxy_total_offset
000580 91d0 284a                 	lds r29, pulse1_fx_Rxy_total_offset+1
000582 0fac                      	add r26, r28
000583 1fbd                      	adc r27, r29
                                 
000584 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
000586 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel0_hi_pitch:
000588 91e0 2823                 	lds ZL, pulse1_hi_pitch_macro
00058a 91f0 2824                 	lds ZH, pulse1_hi_pitch_macro+1
00058c 9630                      	adiw Z, 0
00058d f409                      	brne sound_driver_instrument_routine_channel0_hi_pitch_continue
00058e c03c                      	rjmp sound_driver_instrument_routine_channel0_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel0_hi_pitch_continue:
00058f 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
000590 1fff                      	rol ZH
000591 91a0 2825                 	lds r26, pulse1_hi_pitch_macro_offset
000593 0fea                      	add ZL, r26
000594 1df2                      	adc ZH, zero
                                 
000595 91b0 2827                 	lds r27, pulse1_hi_pitch_macro_release
000597 17ba                      	cp r27, r26
000598 f429                      	brne sound_driver_instrument_routine_channel0_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
000599 91a0 2826                 	lds r26, pulse1_hi_pitch_macro_loop
00059b 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00059c f010                      	brlo sound_driver_instrument_routine_channel0_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00059d c003                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_increment:
00059e 95a3                      	inc r26 //increment the macro offset
00059f 93a0 2825                 	sts pulse1_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_hi_pitch_read:
0005a1 91b4                      	lpm r27, Z //load hi pitch data into r27
0005a2 38b0                      	cpi r27, 0x80 //check for macro end flag
0005a3 f489                      	brne sound_driver_instrument_routine_channel0_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_release:
0005a4 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0005a5 93a0 2825                 	sts pulse1_hi_pitch_macro_offset, r26
0005a7 91b0 2827                 	lds r27, pulse1_hi_pitch_macro_release
0005a9 3fbf                      	cpi r27, 0xFF
0005aa f439                      	brne sound_driver_instrument_routine_channel0_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_loop:
0005ab 91b0 2826                 	lds r27, pulse1_hi_pitch_macro_loop //load the loop index
0005ad 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0005ae f019                      	breq sound_driver_instrument_routine_channel0_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
0005af 93b0 2825                 	sts pulse1_hi_pitch_macro_offset, r27 //store the loop index into the offset
0005b1 cfd6                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_default:
0005b2 91b0 2822                 	lds r27, pulse1_total_hi_pitch_offset
0005b4 c005                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate:
0005b5 91a0 2822                 	lds r26, pulse1_total_hi_pitch_offset //load the total hi pitch offset to change
0005b7 0fba                      	add r27, r26
0005b8 93b0 2822                 	sts pulse1_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply:
0005ba 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0005bb 937f                      	push r23
0005bc 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
0005bd eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0005be 0367                      	mulsu r22, r23
0005bf 917f                      	pop r23
0005c0 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_offset:
0005c1 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
0005c3 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
0005c5 0da0                      	add r26, r0 //offset the timer values
0005c6 1db1                      	adc r27, r1
0005c7 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
0005c9 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel0_duty:
0005cb 91e0 2828                 	lds ZL, pulse1_duty_macro
0005cd 91f0 2829                 	lds ZH, pulse1_duty_macro+1
0005cf 9630                      	adiw Z, 0
0005d0 f1b1                      	breq sound_driver_channel0_fx_routines //if no duty macro is in use, go to the next routine
0005d1 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0005d2 1fff                      	rol ZH
0005d3 91a0 282a                 	lds r26, pulse1_duty_macro_offset
0005d5 0fea                      	add ZL, r26
0005d6 1df2                      	adc ZH, zero
                                 
0005d7 91b0 282c                 	lds r27, pulse1_duty_macro_release
0005d9 17ba                      	cp r27, r26
0005da f429                      	brne sound_driver_instrument_routine_channel0_duty_increment //if the current offset is not equal to the release index, increment the offset
0005db 91a0 282b                 	lds r26, pulse1_duty_macro_loop
0005dd 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0005de f010                      	brlo sound_driver_instrument_routine_channel0_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0005df c027                      	rjmp sound_driver_channel0_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel0_duty_increment:
0005e0 95a3                      	inc r26 //increment the macro offset
0005e1 93a0 282a                 	sts pulse1_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_duty_read:
0005e3 91b4                      	lpm r27, Z //load pitch data into r27
0005e4 3fbf                      	cpi r27, 0xFF //check for macro end flag
0005e5 f471                      	brne sound_driver_instrument_routine_channel0_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_release:
0005e6 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0005e7 93a0 282a                 	sts pulse1_duty_macro_offset, r26
0005e9 91b0 282c                 	lds r27, pulse1_duty_macro_release
0005eb 3fbf                      	cpi r27, 0xFF
0005ec f4d1                      	brne sound_driver_channel0_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_loop:
0005ed 91b0 282b                 	lds r27, pulse1_duty_macro_loop //load the loop index
0005ef 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0005f0 f0b1                      	breq sound_driver_channel0_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
0005f1 93b0 282a                 	sts pulse1_duty_macro_offset, r27 //store the loop index into the offset
0005f3 cfd7                      	rjmp sound_driver_instrument_routine_channel0_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_load:
0005f4 e0fe                      	ldi ZH, HIGH(sequences << 1) //point Z to sequence table
0005f5 ebe6                      	ldi ZL, LOW(sequences << 1)
0005f6 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
0005f7 1df2                      	adc ZH, zero
                                 
0005f8 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
0005f9 95b7                      	ror r27
0005fa 95b7                      	ror r27
0005fb 91a0 2800                 	lds r26, pulse1_param //load r26 with pulse1_param (register $4000)
0005fd 2fca                      	mov r28, r26 //store a copy of pulse1_param into r28
0005fe 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
0005ff 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
000600 c001                      	rjmp sound_driver_instrument_routine_channel0_duty_load_store
000601 c005                      	rjmp sound_driver_channel0_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel0_duty_load_store:
000602 90d4                      	lpm pulse1_sequence, Z //store the sequence
                                 
000603 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
000604 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
000605 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_routines:
                                 sound_driver_channel0_fx_1xx_routine:
000607 91e0 282d                 	lds ZL, pulse1_fx_1xx
000609 91f0 282e                 	lds ZH, pulse1_fx_1xx+1
00060b 9630                      	adiw Z, 0
00060c f051                      	breq sound_driver_channel0_fx_2xx_routine
                                 
00060d 91a0 282f                 	lds r26, pulse1_fx_1xx_total //load the rate to change the pitch by
00060f 91b0 2830                 	lds r27, pulse1_fx_1xx_total+1
000611 0fae                      	add r26, ZL //increase the total offset by the rate
000612 1fbf                      	adc r27, ZH
000613 93a0 282f                 	sts pulse1_fx_1xx_total, r26
000615 93b0 2830                 	sts pulse1_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_2xx_routine:
000617 91e0 2831                 	lds ZL, pulse1_fx_2xx
000619 91f0 2832                 	lds ZH, pulse1_fx_2xx+1
00061b 9630                      	adiw Z, 0
00061c f051                      	breq sound_driver_channel0_fx_3xx_routine
                                 
00061d 91a0 2833                 	lds r26, pulse1_fx_2xx_total //load the rate to change the pitch by
00061f 91b0 2834                 	lds r27, pulse1_fx_2xx_total+1
000621 0fae                      	add r26, ZL //increase the total offset by the rate
000622 1fbf                      	adc r27, ZH
000623 93a0 2833                 	sts pulse1_fx_2xx_total, r26
000625 93b0 2834                 	sts pulse1_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_3xx_routine:
000627 91e0 2839                 	lds ZL, pulse1_fx_3xx_speed
000629 91f0 283a                 	lds ZH, pulse1_fx_3xx_speed+1
00062b 9630                      	adiw Z, 0
00062c f409                      	brne sound_driver_channel0_fx_3xx_routine_check_start
00062d c048                      	rjmp sound_driver_channel0_fx_Axy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_check_start:
00062e 91a0 2835                 	lds r26, pulse1_fx_3xx_start
000630 91b0 2836                 	lds r27, pulse1_fx_3xx_start+1
000632 9610                      	adiw r26:r27, 0
000633 f409                      	brne sound_driver_channel0_fx_3xx_routine_main
000634 c041                      	rjmp sound_driver_channel0_fx_Axy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_main:
000635 91c0 2837                 	lds r28, pulse1_fx_3xx_target
000637 91d0 2838                 	lds r29, pulse1_fx_3xx_target+1
                                 
000639 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
00063a 07bd                      	cpc r27, r29
00063b f011                      	breq sound_driver_channel0_fx_3xx_routine_disable
00063c f030                      	brlo sound_driver_channel0_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
00063d c01f                      	rjmp sound_driver_channel0_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel0_fx_3xx_routine_disable:
00063e 9220 2835                 	sts pulse1_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
000640 9220 2836                 	sts pulse1_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
000642 c033                      	rjmp sound_driver_channel0_fx_Axy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_subtract:
000643 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
000644 0bdb                      	sbc r29, r27
000645 91a0 283b                 	lds r26, pulse1_fx_3xx_total_offset
000647 91b0 283c                 	lds r27, pulse1_fx_3xx_total_offset+1
                                 
000649 0fae                      	add r26, ZL //add the speed to the total offset
00064a 1fbf                      	adc r27, ZH
00064b 1bca                      	sub r28, r26 //invert the total difference with the total offset
00064c 0bdb                      	sbc r29, r27
00064d f380                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
00064e 93a0 283b                 	sts pulse1_fx_3xx_total_offset, r26 //store the new total offset
000650 93b0 283c                 	sts pulse1_fx_3xx_total_offset+1, r27
                                 
000652 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the current timer period
000654 91b0 0a8d                 	lds r27, TCB0_CCMPH
000656 1bac                      	sub r26, r28 //offset the current timer period with the total offset
000657 0bbd                      	sbc r27, r29
000658 93a0 0a8c                 	sts TCB0_CCMPL, r26
00065a 93b0 0a8d                 	sts TCB0_CCMPH, r27
00065c c019                      	rjmp sound_driver_channel0_fx_Axy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_add:
00065d 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
00065e 0bbd                      	sbc r27, r29
00065f 91c0 283b                 	lds r28, pulse1_fx_3xx_total_offset
000661 91d0 283c                 	lds r29, pulse1_fx_3xx_total_offset+1
                                 
000663 0fce                      	add r28, ZL //add the speed to the total offset
000664 1fdf                      	adc r29, ZH
000665 1bac                      	sub r26, r28 //invert the total difference with the total offset
000666 0bbd                      	sbc r27, r29
000667 f2b0                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
000668 93c0 283b                 	sts pulse1_fx_3xx_total_offset, r28 //store the new total offset
00066a 93d0 283c                 	sts pulse1_fx_3xx_total_offset+1, r29
                                 
00066c 91c0 0a8c                 	lds r28, TCB0_CCMPL //load the current timer period
00066e 91d0 0a8d                 	lds r29, TCB0_CCMPH
000670 0fca                      	add r28, r26 //offset the current timer period with the total offset
000671 1fdb                      	adc r29, r27
000672 93c0 0a8c                 	sts TCB0_CCMPL, r28
000674 93d0 0a8d                 	sts TCB0_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Axy_routine:
000676 91b0 283e                 	lds r27, pulse1_fx_Axy
000678 15b2                      	cp r27, zero
000679 f0e9                      	breq sound_driver_channel0_fx_Qxy_routine //0 means that the effect is not in use
                                 	
00067a 91a0 2805                 	lds r26, pulse1_fractional_volume //load fractional volume representation of the channel
00067c 91c0 2800                 	lds r28, pulse1_param //load the integer volume representation of the channel
00067e 2fda                      	mov r29, r26 //copy fractional volume into r29
00067f 2fec                      	mov r30, r28 //copy the pulse1_param into r30
000680 95e2                      	swap r30
000681 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
000682 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
000683 17ed                      	cp r30, r29 //compare the fractional and integer volumes
000684 f009                      	breq sound_driver_channel0_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel0_fx_Axy_routine_reload:
000685 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate:
000686 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
000687 c004                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_addition:
000688 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
000689 f428                      	brcc sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
00068a efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
00068b c003                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_subtraction:
00068c 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
00068d f008                      	brcs sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
00068e e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_store:
00068f 93a0 2805                 	sts pulse1_fractional_volume, r26 //store the new fractional volume
000691 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
000692 95a2                      	swap r26
000693 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
000694 2bca                      	or r28, r26 //store the new volume back into pulse1_param
000695 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel0_fx_Qxy_routine:
000697 91e0 283f                 	lds ZL, pulse1_fx_Qxy_target
000699 91f0 2840                 	lds ZH, pulse1_fx_Qxy_target+1
00069b 9630                      	adiw Z, 0
00069c f131                      	breq sound_driver_channel0_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
00069d 91a0 2843                 	lds r26, pulse1_fx_Qxy_total_offset
00069f 91b0 2844                 	lds r27, pulse1_fx_Qxy_total_offset+1
0006a1 91c0 0a8c                 	lds r28, TCB0_CCMPL
0006a3 91d0 0a8d                 	lds r29, TCB0_CCMPH
0006a5 1bca                      	sub r28, r26 //subtract the timer period by the total offset
0006a6 0bdb                      	sbc r29, r27
                                 
0006a7 17ce                      	cp r28, ZL //compare the new timer period with the target
0006a8 07df                      	cpc r29, ZH
0006a9 f010                      	brlo sound_driver_channel0_fx_Qxy_routine_end //if the target has been reached (or passed)
0006aa f009                      	breq sound_driver_channel0_fx_Qxy_routine_end
0006ab f468                      	brsh sound_driver_channel0_fx_Qxy_routine_add
                                 
                                 sound_driver_channel0_fx_Qxy_routine_end:
0006ac 1bec                      	sub ZL, r28 //calculate the difference to the target
0006ad 0bfd                      	sbc ZH, r29
0006ae 0fae                      	add r26, ZL //increase the total offset to the exact amount needed to reach the target
0006af 1fbf                      	adc r27, ZH
0006b0 93a0 2843                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
0006b2 93b0 2844                 	sts pulse1_fx_Qxy_total_offset+1, r27
0006b4 9220 283f                 	sts pulse1_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
0006b6 9220 2840                 	sts pulse1_fx_Qxy_target+1, zero
0006b8 c00a                      	rjmp sound_driver_channel0_fx_Rxy_routine
                                 
                                 sound_driver_channel0_fx_Qxy_routine_add:
0006b9 91c0 2841                 	lds r28, pulse1_fx_Qxy_speed
0006bb 91d0 2842                 	lds r29, pulse1_fx_Qxy_speed+1
0006bd 0fac                      	add r26, r28 //increase the total offset by the speed
0006be 1fbd                      	adc r27, r29
0006bf 93a0 2843                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
0006c1 93b0 2844                 	sts pulse1_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Rxy_routine:
0006c3 91e0 2845                 	lds ZL, pulse1_fx_Rxy_target
0006c5 91f0 2846                 	lds ZH, pulse1_fx_Rxy_target+1
0006c7 9630                      	adiw Z, 0
0006c8 f131                      	breq sound_driver_channel0_fx_xy_routine //if the effect is not enabled, skip the routine
                                 
0006c9 91a0 2849                 	lds r26, pulse1_fx_Rxy_total_offset
0006cb 91b0 284a                 	lds r27, pulse1_fx_Rxy_total_offset+1
0006cd 91c0 0a8c                 	lds r28, TCB0_CCMPL
0006cf 91d0 0a8d                 	lds r29, TCB0_CCMPH
0006d1 0fca                      	add r28, r26 //add the total offset to the timer period
0006d2 0fdb                      	add r29, r27
                                 
0006d3 17ce                      	cp r28, ZL //compare the new timer period with the target
0006d4 07df                      	cpc r29, ZH
0006d5 f010                      	brlo sound_driver_channel0_fx_Rxy_routine_end //if the target has been reached (or passed)
0006d6 f009                      	breq sound_driver_channel0_fx_Rxy_routine_end
0006d7 f468                      	brsh sound_driver_channel0_fx_Rxy_routine_add
                                 
                                 sound_driver_channel0_fx_Rxy_routine_end:
0006d8 1bec                      	sub ZL, r28 //calculate the difference to the target
0006d9 0bfd                      	sbc ZH, r29
0006da 0fae                      	add r26, ZL //increase the total offset to the exact amount needed to reach the target
0006db 1fbf                      	adc r27, ZH
0006dc 93a0 2849                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
0006de 93b0 284a                 	sts pulse1_fx_Rxy_total_offset+1, r27
0006e0 9220 2845                 	sts pulse1_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
0006e2 9220 2846                 	sts pulse1_fx_Rxy_target+1, zero
0006e4 c00a                      	rjmp sound_driver_channel0_fx_xy_routine
                                 
                                 sound_driver_channel0_fx_Rxy_routine_add:
0006e5 91c0 2847                 	lds r28, pulse1_fx_Rxy_speed
0006e7 91d0 2848                 	lds r29, pulse1_fx_Rxy_speed+1
0006e9 0fac                      	add r26, r28 //increase the total offset by the speed
0006ea 1fbd                      	adc r27, r29
0006eb 93a0 2849                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
0006ed 93b0 284a                 	sts pulse1_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 sound_driver_channel0_fx_xy_routine:
                                 
                                 sound_driver_exit:
0006ef 91df                      	pop r29
0006f0 91cf                      	pop r28
0006f1 caeb                      	rjmp sequence_1_3 + 3 //+3 is to skip the stack instructions since we already pushed them
                                 
                                 //PULSE 1 ROUTINES
                                 pulse1_sequence_routine:
0006f2 b7bf                      	in r27, CPU_SREG
0006f3 93bf                      	push r27
0006f4 94f8                      	cli
                                 
0006f5 0cdd                      	lsl pulse1_sequence //shifts sequence to the left
0006f6 1cd2                      	adc pulse1_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
0006f7 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
0006f8 93b0 0a86                 	sts TCB0_INTFLAGS, r27
0006fa 91bf                      	pop r27
0006fb bfbf                      	out CPU_SREG, r27
0006fc 9518                      	reti
                                 
                                 pulse1_sweep_routine:
0006fd 2dbf                      	mov r27, pulse1_sweep
0006fe 70b7                      	andi r27, 0x07 //mask for period divider bits
0006ff f4f9                      	brne pulse1_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse1_sweep_routine_action: //if the divider is == 0, update the pulse timer period
000700 93df                      	push r29
000701 2ddf                      	mov r29, pulse1_sweep
000702 95d2                      	swap r29
000703 70d7                      	andi r29, 0x07 //mask for shift bits
000704 f409                      	brne PC+2 //check of shift == 0
000705 91df                      	pop r29
000706 c019                      	rjmp pulse1_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
000707 91a0 0a8c                 	lds r26, TCB0_CCMPL
000709 91b0 0a8d                 	lds r27, TCB0_CCMPH
00070b 95b6                      	lsr r27
00070c 95a7                      	ror r26
00070d 95da                      	dec r29
00070e f7e1                      	brne PC-3 //keep looping/shifting until shift count is 0
                                 
00070f fef7                      	sbrs pulse1_sweep, 7 //check the negate flag
000710 c002                      	rjmp PC+3 //if negate flag was clear, go straight to addition
                                 
000711 95a0                      	com r26 //pulse1 uses one's complement if the negate flag is set
000712 95b0                      	com r27
                                 
000713 91d0 0a8c                 	lds r29, TCB0_CCMPL //perform addition to get new timer period
000715 0fad                      	add r26, r29
000716 91d0 0a8d                 	lds r29, TCB0_CCMPH
000718 1fbd                      	adc r27, r29
                                 
000719 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new LOW bits for timer
00071b 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new HIGH bits for timer
                                 
                                 	//sts pulse1_timerL, r26
                                 	//sts pulse1_timerH, r27
                                 
                                 /*	//Sweep Test
                                 	mov r29, pulse1_sweep //invert the negate bit
                                 	ldi r27, 0b10000000
                                 	eor r29, r27
                                 	ori r29, 0b01111111
                                 
                                 	lds r27, pulse1_sweep_param //reload the pulse sweep divider params
                                 	swap r27
                                 	ori r27, 0b10000000
                                 	and r27, r29
                                 	mov pulse1_sweep, r27
                                 	sbr channel_flags, 0b10000000*/
                                 	
00071d 91df                      	pop r29
00071e c001                      	rjmp pulse1_sweep_routine_check_reload
                                 
                                 pulse1_sweep_routine_decrement_divider:
00071f 94fa                      	dec pulse1_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse1_sweep_routine_check_reload:
000720 ff97                      	sbrs channel_flags, 7 //if the reload flag is set, reload the sweep divider
000721 9508                      	ret
                                 
                                 pulse1_sweep_reload:
000722 90f0 2801                 	lds pulse1_sweep, pulse1_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
000724 94f2                      	swap pulse1_sweep //bring data from high byte to low byte
000725 779f                      	cbr channel_flags, 0b10000000 //clear ready flag
000726 9508                      	ret
                                 
                                 pulse1_envelope_routine:
000727 fd96                      	sbrc channel_flags, 6 //check if start flag is cleared
000728 c010                      	rjmp pulse1_envelope_routine_clear_start
                                 
000729 3000                      	cpi pulse1_volume_divider, 0x00 //check if the divider is 0
00072a f011                      	breq PC+3 //if the divider == 0, check loop flag
00072b 950a                      	dec pulse1_volume_divider //if the divider != 0, decrement and return
00072c 9508                      	ret
                                 
00072d 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the divider == 0, reset the divider period
00072f 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
000730 ff95                      	sbrs channel_flags, 5 //check if the loop flag is set
000731 c002                      	rjmp pulse1_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
000732 e01f                      	ldi pulse1_volume_decay, 0x0F //if the loop flag is set, reset decay and return
000733 9508                      	ret
                                 
                                 pulse1_envelope_routine_decrement_decay:
000734 3010                      	cpi pulse1_volume_decay, 0x00 //check if the decay is 0
000735 f409                      	brne PC+2 //if decay != 0, go decrement
000736 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
000737 951a                      	dec pulse1_volume_decay
000738 9508                      	ret
                                 
                                 pulse1_envelope_routine_clear_start:
000739 7b9f                      	cbr channel_flags, 0b01000000 //if the start flag is set, clear it
00073a 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the start flag is set, reset the divider period
00073c 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
00073d e01f                      	ldi pulse1_volume_decay, 0x0F //if the start flag is set, reset decay
00073e 9508                      	ret
                                 
                                 //CONVERTERS (TABLES)
                                 //converts and loads 5 bit length to corresponding 8 bit length value into r29
                                 length_converter:
00073f e0fe                      	ldi ZH, HIGH(length << 1)
000740 e8ea                      	ldi ZL, LOW(length << 1)
000741 0fed                      	add ZL, r29
000742 1df2                      	adc ZH, zero
000743 91d4                      	lpm r29, Z
000744 9508                      	ret
                                 
000745 7f05
000746 010a
000747 0214
000748 0328
000749 0450
00074a 051e
00074b 0607
00074c 070d
00074d 0806
00074e 090c
00074f 0a18
000750 0b30
000751 0c60
000752 0d24
000753 0e08
000754 0f10                      length: .db $05, $7F, $0A, $01, $14, $02, $28, $03, $50, $04, $1E, $05, $07, $06, $0D, $07, $06, $08, $0C, $09, $18, $0A, $30, $0B, $60, $0C, $24, $0D, $08, $0E, $10, $0F
                                 
                                 //loads pulse sequence into r29
                                 duty_cycle_sequences:
000755 e0fe                      	ldi ZH, HIGH(sequences << 1)
000756 ebe6                      	ldi ZL, LOW(sequences << 1)
000757 0fed                      	add ZL, r29
000758 1df2                      	adc ZH, zero
000759 91d4                      	lpm r29, Z
00075a 9508                      	ret
                                 
                                 //pulse sequences: 12.5%, 25%, 50%, 75%
00075b 0301
00075c fc0f                      sequences: .db 0b00000001, 0b00000011, 0b00001111, 0b11111100
                                 
                                 //list of famitracker fx: http://famitracker.com/wiki/index.php?title=Effect_list
                                 fx:
00075d 021d
00075e 021e
00075f 0236
000760 024e
000761 0271                      	.dw sound_driver_channel0_fx_0xy, sound_driver_channel0_fx_1xx, sound_driver_channel0_fx_2xx, sound_driver_channel0_fx_3xx, sound_driver_channel0_fx_4xy
000762 0272
000763 0273
000764 0276
000765 0277
000766 0278                      	.dw sound_driver_channel0_fx_7xy, sound_driver_channel0_fx_Axy, sound_driver_channel0_fx_Bxx, sound_driver_channel0_fx_Cxx, sound_driver_channel0_fx_Dxx
000767 0279
000768 027a
000769 027b
00076a 027c
00076b 027d                      	.dw sound_driver_channel0_fx_Exx, sound_driver_channel0_fx_Fxx, sound_driver_channel0_fx_Gxx, sound_driver_channel0_fx_Hxy, sound_driver_channel0_fx_lxy
00076c 027e
00076d 027f
00076e 0280
00076f 0283
000770 02c7                      	.dw sound_driver_channel0_fx_Hxx, sound_driver_channel0_fx_Ixx, sound_driver_channel0_fx_Pxx, sound_driver_channel0_fx_Qxy, sound_driver_channel0_fx_Rxy
000771 030a
000772 030b
000773 031f
000774 0320
000775 0321                      	.dw sound_driver_channel0_fx_Sxx, sound_driver_channel0_fx_Vxx, sound_driver_channel0_fx_Wxx, sound_driver_channel0_fx_Xxx, sound_driver_channel0_fx_Yxx
000776 0322                      	.dw sound_driver_channel0_fx_Zxx
                                 
                                 //famitracker volumes table: http://famitracker.com/wiki/index.php?title=Volume
                                 volumes:
000777 0000
000778 0000
000779 0000
00077a 0000
00077b 0000
00077c 0000
00077d 0000
00077e 0000                      	.db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
00077f 0100
000780 0101
000781 0101
000782 0101
000783 0101
000784 0101
000785 0101
000786 0101                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
000787 0100
000788 0101
000789 0101
00078a 0101
00078b 0101
00078c 0101
00078d 0101
00078e 0201                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02
00078f 0100
000790 0101
000791 0101
000792 0101
000793 0101
000794 0202
000795 0202
000796 0302                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03
000797 0100
000798 0101
000799 0101
00079a 0101
00079b 0202
00079c 0202
00079d 0303
00079e 0403                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04
00079f 0100
0007a0 0101
0007a1 0101
0007a2 0202
0007a3 0302
0007a4 0303
0007a5 0404
0007a6 0504                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05
0007a7 0100
0007a8 0101
0007a9 0201
0007aa 0202
0007ab 0303
0007ac 0404
0007ad 0504
0007ae 0605                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x06
0007af 0100
0007b0 0101
0007b1 0201
0007b2 0302
0007b3 0403
0007b4 0504
0007b5 0605
0007b6 0706                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07
0007b7 0100
0007b8 0101
0007b9 0202
0007ba 0303
0007bb 0404
0007bc 0505
0007bd 0606
0007be 0807                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07, 0x08
0007bf 0100
0007c0 0101
0007c1 0302
0007c2 0403
0007c3 0504
0007c4 0606
0007c5 0707
0007c6 0908                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09
0007c7 0100
0007c8 0201
0007c9 0302
0007ca 0404
0007cb 0605
0007cc 0706
0007cd 0808
0007ce 0a09                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A
0007cf 0100
0007d0 0201
0007d1 0302
0007d2 0504
0007d3 0605
0007d4 0807
0007d5 0908
0007d6 0b0a                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B
0007d7 0100
0007d8 0201
0007d9 0403
0007da 0504
0007db 0706
0007dc 0808
0007dd 0a09
0007de 0c0b                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B, 0x0C
0007df 0100
0007e0 0201
0007e1 0403
0007e2 0605
0007e3 0706
0007e4 0908
0007e5 0b0a
0007e6 0d0c                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D
0007e7 0100
0007e8 0201
0007e9 0403
0007ea 0605
0007eb 0807
0007ec 0a09
0007ed 0c0b
0007ee 0e0d                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E
0007ef 0100
0007f0 0302
0007f1 0504
0007f2 0706
0007f3 0908
0007f4 0b0a
0007f5 0d0c


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega4809" register use summary:
x  :   0 y  :   0 z  :  56 r0 :  31 r1 :  33 r2 : 140 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 
r13:   6 r14:   4 r15:   9 r16:   7 r17:   6 r18:   0 r19:   0 r20:   0 
r21:   0 r22:  28 r23:  28 r24:   0 r25:  11 r26: 197 r27: 315 r28:  81 
r29:  87 r30:  84 r31:  79 
Registers used: 18 out of 35 (51.4%)

"ATmega4809" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  34 add   :  43 adiw  :  23 and   :   0 
andi  :  22 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   2 brcs  :   2 break :   0 breq  :  36 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  17 brlt  :   0 brmi  :   0 
brne  :  29 brpl  :   0 brsh  :   6 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :   0 cbr   :   2 
clc   :   0 clh   :   0 cli   :   4 cln   :   0 clr   :   1 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :   2 cp    :  16 cpc   :   3 
cpi   :  42 cpse  :   5 dec   :   7 des   :   0 eor   :   0 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   1 in    :   4 inc   :  12 
jmp   :   6 ld    :   0 ldd   :   0 ldi   :  73 lds   : 158 lpm   :  58 
lsl   :  19 lsr   :  28 mov   :  27 movw  :   0 mul   :   5 muls  :   0 
mulsu :   2 neg   :   0 nop   :   0 or    :   5 ori   :   0 out   :   6 
pop   :  25 push  :  25 rcall :  16 ret   :  13 reti  :   3 rjmp  : 108 
rol   :  13 ror   :  29 sbc   :  10 sbci  :   0 sbi   :   0 sbic  :   0 
sbis  :   0 sbiw  :   0 sbr   :   3 sbrc  :   8 sbrs  :   5 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   : 284 sub   :  11 subi  :   9 swap  :   8 tst   :   0 wdr   :   0 

Instructions used: 50 out of 114 (43.9%)

"ATmega4809" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x000fee   3392    658   4050   49152   8.2%
[.dseg] 0x002800 0x00284f      0     79     79    6144   1.3%
[.eseg] 0x000000 0x000000      0      0      0     256   0.0%

Assembly complete, 0 errors, 0 warnings
