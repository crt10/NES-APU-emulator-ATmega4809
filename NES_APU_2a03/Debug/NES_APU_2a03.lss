
AVRASM ver. 2.2.8  C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm Thu Jan 21 23:39:20 2021

C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
                                 
                                 
                                 ; NES_APU_2a03.asm
                                 ;
                                 ; Created: 11/29/2020 1:44:10 AM
                                 ; Author : Tennyson Cheng
                                 ;
                                 
                                 .list
                                 
                                 .dseg
002800                           pulse1_param: .byte 1 //$4000 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002801                           pulse1_sweep_param: .byte 1 //$4001 EPPP.NSSS = Enable, Period, Negate, Shift
                                 //NOTE: In order to account for multiplier, we use 16 instead of 11 bits for the timer
002802                           pulse1_timerL: .byte 1 //$4002 LLLL.LLLL = Low 8 bits for timer
002803                           pulse1_timerH: .byte 1 //$4002 HHHH.HHHH = High 8 bits for timer
002804                           pulse1_length: .byte 1 //$4003 000l.llll = Length counter load
002805                           pulse1_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002806                           pulse1_output_volume: .byte 1 //this is the final output volume of pulse 1
002807                           pulse1_note: .byte 1 //the current note index in the note table
                                 
002808                           pulse2_param: .byte 1 //$4004 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002809                           pulse2_sweep_param: .byte 1 //$4005 EPPP.NSSS = Enable, Period, Negate, Shift
00280a                           pulse2_timerL: .byte 1 //$4006 LLLL.LLLL = Low 8 bits for timer
00280b                           pulse2_timerH: .byte 1 //$4006 HHHH.HHHH = High 8 bits for timer
00280c                           pulse2_length: .byte 1 //$4007 000l.llll = Length counter load
00280d                           pulse2_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
00280e                           pulse2_output_volume: .byte 1 //this is the final output volume of pulse 2
00280f                           pulse2_note: .byte 1 //the current note index in the note table
                                 
002810                           triangle_timerL: .byte 1 //$400A LLLL.LLLL = Low 8 bits for timer
002811                           triangle_timerH: .byte 1 //$400A HHHH.HHHH = High 8 bits for time
002812                           triangle_note: .byte 1 //the current note index in the note table
                                 
002813                           noise_param: .byte 1 //$400C 00lc.vvvv = Length counter halt/Loop flag, Constant volume flag, Volume
002814                           noise_period: .byte 1 //$400E M000.PPPP = Mode, Period
002815                           noise_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002816                           noise_output_volume: .byte 1 //this is the final output volume of pulse 2
002817                           noise_note: .byte 1 //the current note index in the period table
                                 
002818                           song_frames: .byte 2
00281a                           song_frame_offset: .byte 2
00281c                           song_size: .byte 2
00281e                           song_speed: .byte 1
                                 //song_channel_delay_reload: .byte 1 //bit 0-4 represents channels 0-4. a set bit means that there is a delay that needs to be calculated for that channel.
00281f                           song_fx_Bxx: .byte 1
002820                           song_fx_Cxx: .byte 1
002821                           song_fx_Dxx: .byte 1
                                 
                                 //PULSE 1
002822                           pulse1_pattern: .byte 2
002824                           pulse1_pattern_delay_rows: .byte 1
002825                           pulse1_pattern_delay_frames: .byte 1
002826                           pulse1_pattern_offset: .byte 2
                                 
002828                           pulse1_volume_macro: .byte 2
00282a                           pulse1_volume_macro_offset: .byte 1
00282b                           pulse1_volume_macro_loop: .byte 1
00282c                           pulse1_volume_macro_release: .byte 1
                                 
00282d                           pulse1_arpeggio_macro: .byte 2
00282f                           pulse1_arpeggio_macro_offset: .byte 1
002830                           pulse1_arpeggio_macro_loop: .byte 1
002831                           pulse1_arpeggio_macro_release: .byte 1
002832                           pulse1_arpeggio_macro_mode: .byte 1
                                 
002833                           pulse1_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002835                           pulse1_pitch_macro: .byte 2
002837                           pulse1_pitch_macro_offset: .byte 1
002838                           pulse1_pitch_macro_loop: .byte 1
002839                           pulse1_pitch_macro_release: .byte 1
                                 
00283a                           pulse1_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00283b                           pulse1_hi_pitch_macro: .byte 2
00283d                           pulse1_hi_pitch_macro_offset: .byte 1
00283e                           pulse1_hi_pitch_macro_loop: .byte 1
00283f                           pulse1_hi_pitch_macro_release: .byte 1
                                 
002840                           pulse1_duty_macro: .byte 2
002842                           pulse1_duty_macro_offset: .byte 1
002843                           pulse1_duty_macro_loop: .byte 1
002844                           pulse1_duty_macro_release: .byte 1
                                 
002845                           pulse1_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002847                           pulse1_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002849                           pulse1_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00284b                           pulse1_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
00284d                           pulse1_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
00284f                           pulse1_fx_3xx_start: .byte 2 //the starting note period
002851                           pulse1_fx_3xx_target: .byte 2 //target note period
002853                           pulse1_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
002855                           pulse1_fx_3xx_total_offset: .byte 2
002857                           pulse1_fx_4xy_speed: .byte 1
002858                           pulse1_fx_4xy_depth: .byte 1
002859                           pulse1_fx_4xy_phase: .byte 1
00285a                           pulse1_fx_7xy_speed: .byte 1
00285b                           pulse1_fx_7xy_depth: .byte 1
00285c                           pulse1_fx_7xy_phase: .byte 1
00285d                           pulse1_fx_7xy_value: .byte 1 //value to offset the volume
00285e                           pulse1_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
00285f                           pulse1_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002860                           pulse1_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002861                           pulse1_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
002863                           pulse1_fx_Qxy_target: .byte 2 //target note period
002865                           pulse1_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002867                           pulse1_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002869                           pulse1_fx_Rxy_target: .byte 2 //target note period
00286b                           pulse1_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
00286d                           pulse1_fx_Rxy_total_offset: .byte 2
00286f                           pulse1_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002870                           pulse1_fx_Sxx_post: .byte 1
                                 
                                 //PULSE 2
002871                           pulse2_pattern: .byte 2
002873                           pulse2_pattern_delay_rows: .byte 1
002874                           pulse2_pattern_delay_frames: .byte 1
002875                           pulse2_pattern_offset: .byte 2
                                 
002877                           pulse2_volume_macro: .byte 2
002879                           pulse2_volume_macro_offset: .byte 1
00287a                           pulse2_volume_macro_loop: .byte 1
00287b                           pulse2_volume_macro_release: .byte 1
                                 
00287c                           pulse2_arpeggio_macro: .byte 2
00287e                           pulse2_arpeggio_macro_offset: .byte 1
00287f                           pulse2_arpeggio_macro_loop: .byte 1
002880                           pulse2_arpeggio_macro_release: .byte 1
002881                           pulse2_arpeggio_macro_mode: .byte 1
                                 
002882                           pulse2_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002884                           pulse2_pitch_macro: .byte 2
002886                           pulse2_pitch_macro_offset: .byte 1
002887                           pulse2_pitch_macro_loop: .byte 1
002888                           pulse2_pitch_macro_release: .byte 1
                                 
002889                           pulse2_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00288a                           pulse2_hi_pitch_macro: .byte 2
00288c                           pulse2_hi_pitch_macro_offset: .byte 1
00288d                           pulse2_hi_pitch_macro_loop: .byte 1
00288e                           pulse2_hi_pitch_macro_release: .byte 1
                                 
00288f                           pulse2_duty_macro: .byte 2
002891                           pulse2_duty_macro_offset: .byte 1
002892                           pulse2_duty_macro_loop: .byte 1
002893                           pulse2_duty_macro_release: .byte 1
                                 
002894                           pulse2_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002896                           pulse2_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002898                           pulse2_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00289a                           pulse2_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
00289c                           pulse2_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
00289e                           pulse2_fx_3xx_start: .byte 2 //the starting note period
0028a0                           pulse2_fx_3xx_target: .byte 2 //target note period
0028a2                           pulse2_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028a4                           pulse2_fx_3xx_total_offset: .byte 2
0028a6                           pulse2_fx_4xy_speed: .byte 1
0028a7                           pulse2_fx_4xy_depth: .byte 1
0028a8                           pulse2_fx_4xy_phase: .byte 1
0028a9                           pulse2_fx_7xy_speed: .byte 1
0028aa                           pulse2_fx_7xy_depth: .byte 1
0028ab                           pulse2_fx_7xy_phase: .byte 1
0028ac                           pulse2_fx_7xy_value: .byte 1 //value to offset the volume
0028ad                           pulse2_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
0028ae                           pulse2_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028af                           pulse2_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028b0                           pulse2_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
0028b2                           pulse2_fx_Qxy_target: .byte 2 //target note period
0028b4                           pulse2_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
0028b6                           pulse2_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
0028b8                           pulse2_fx_Rxy_target: .byte 2 //target note period
0028ba                           pulse2_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
0028bc                           pulse2_fx_Rxy_total_offset: .byte 2
0028be                           pulse2_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
0028bf                           pulse2_fx_Sxx_post: .byte 1
                                 
                                 //TRIANGLE
0028c0                           triangle_pattern: .byte 2
0028c2                           triangle_pattern_delay_rows: .byte 1
0028c3                           triangle_pattern_delay_frames: .byte 1
0028c4                           triangle_pattern_offset: .byte 2
                                 
0028c6                           triangle_volume_macro: .byte 2
0028c8                           triangle_volume_macro_offset: .byte 1
0028c9                           triangle_volume_macro_loop: .byte 1
0028ca                           triangle_volume_macro_release: .byte 1
                                 
0028cb                           triangle_arpeggio_macro: .byte 2
0028cd                           triangle_arpeggio_macro_offset: .byte 1
0028ce                           triangle_arpeggio_macro_loop: .byte 1
0028cf                           triangle_arpeggio_macro_release: .byte 1
0028d0                           triangle_arpeggio_macro_mode: .byte 1
                                 
0028d1                           triangle_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
0028d3                           triangle_pitch_macro: .byte 2
0028d5                           triangle_pitch_macro_offset: .byte 1
0028d6                           triangle_pitch_macro_loop: .byte 1
0028d7                           triangle_pitch_macro_release: .byte 1
                                 
0028d8                           triangle_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
0028d9                           triangle_hi_pitch_macro: .byte 2
0028db                           triangle_hi_pitch_macro_offset: .byte 1
0028dc                           triangle_hi_pitch_macro_loop: .byte 1
0028dd                           triangle_hi_pitch_macro_release: .byte 1
                                 
0028de                           triangle_duty_macro: .byte 2
0028e0                           triangle_duty_macro_offset: .byte 1
0028e1                           triangle_duty_macro_loop: .byte 1
0028e2                           triangle_duty_macro_release: .byte 1
                                 
0028e3                           triangle_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
0028e5                           triangle_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
0028e7                           triangle_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
0028e9                           triangle_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
0028eb                           triangle_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
0028ed                           triangle_fx_3xx_start: .byte 2 //the starting note period
0028ef                           triangle_fx_3xx_target: .byte 2 //target note period
0028f1                           triangle_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028f3                           triangle_fx_3xx_total_offset: .byte 2
0028f5                           triangle_fx_4xy_speed: .byte 1
0028f6                           triangle_fx_4xy_depth: .byte 1
0028f7                           triangle_fx_4xy_phase: .byte 1
0028f8                           triangle_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028f9                           triangle_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028fa                           triangle_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
0028fc                           triangle_fx_Qxy_target: .byte 2 //target note period
0028fe                           triangle_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002900                           triangle_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002902                           triangle_fx_Rxy_target: .byte 2 //target note period
002904                           triangle_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
002906                           triangle_fx_Rxy_total_offset: .byte 2
002908                           triangle_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002909                           triangle_fx_Sxx_post: .byte 1
                                 
                                 //NOISE
00290a                           noise_pattern: .byte 2
00290c                           noise_pattern_delay_rows: .byte 1
00290d                           noise_pattern_delay_frames: .byte 1
00290e                           noise_pattern_offset: .byte 2
                                 
002910                           noise_volume_macro: .byte 2
002912                           noise_volume_macro_offset: .byte 1
002913                           noise_volume_macro_loop: .byte 1
002914                           noise_volume_macro_release: .byte 1
                                 
002915                           noise_arpeggio_macro: .byte 2
002917                           noise_arpeggio_macro_offset: .byte 1
002918                           noise_arpeggio_macro_loop: .byte 1
002919                           noise_arpeggio_macro_release: .byte 1
00291a                           noise_arpeggio_macro_mode: .byte 1
                                 
00291b                           noise_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
00291d                           noise_pitch_macro: .byte 2
00291f                           noise_pitch_macro_offset: .byte 1
002920                           noise_pitch_macro_loop: .byte 1
002921                           noise_pitch_macro_release: .byte 1
                                 
002922                           noise_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
002923                           noise_hi_pitch_macro: .byte 2
002925                           noise_hi_pitch_macro_offset: .byte 1
002926                           noise_hi_pitch_macro_loop: .byte 1
002927                           noise_hi_pitch_macro_release: .byte 1
                                 
002928                           noise_duty_macro: .byte 2
00292a                           noise_duty_macro_offset: .byte 1
00292b                           noise_duty_macro_loop: .byte 1
00292c                           noise_duty_macro_release: .byte 1
                                 
00292d                           noise_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
00292f                           noise_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002931                           noise_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
002933                           noise_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
002935                           noise_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
002937                           noise_fx_3xx_start: .byte 2 //the starting note period
002939                           noise_fx_3xx_target: .byte 2 //target note period
00293b                           noise_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
00293d                           noise_fx_3xx_total_offset: .byte 2
00293f                           noise_fx_4xy_speed: .byte 1
002940                           noise_fx_4xy_depth: .byte 1
002941                           noise_fx_4xy_phase: .byte 1
002942                           noise_fx_7xy_speed: .byte 1
002943                           noise_fx_7xy_depth: .byte 1
002944                           noise_fx_7xy_phase: .byte 1
002945                           noise_fx_7xy_value: .byte 1 //value to offset the volume
002946                           noise_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
002947                           noise_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002948                           noise_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002949                           noise_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
00294b                           noise_fx_Qxy_target: .byte 2 //target note period
00294d                           noise_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
00294f                           noise_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002951                           noise_fx_Rxy_target: .byte 2 //target note period
002953                           noise_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
002955                           noise_fx_Rxy_total_offset: .byte 2
002957                           noise_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002958                           noise_fx_Sxx_post: .byte 1
                                 
                                 //DPCM
002959                           dcpm_pattern_delay: .byte 1
                                 
                                 .cseg
                                 
                                 //NOTE: zero is defined in order to use the cp instruction without the need to load 0x00 into a register beforehand
                                 .def zero = r2
                                 .def pulse_channel_flags = r25 //[pulse1.pulse2] RSlc.RSlc = Reload, Start, Length halt/Loop, Constant volume
                                 .def pulse1_sequence = r10
                                 .def pulse1_length_counter = r11
                                 .def pulse1_sweep = r12 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse1_volume_divider = r16 //0000.PPPP = Period divider
                                 .def pulse1_volume_decay = r17 //0000.dddd = Decay
                                 .def pulse2_sequence = r13
                                 .def pulse2_length_counter = r14
                                 .def pulse2_sweep = r15 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse2_volume_divider = r18 //0000.PPPP = Period divider
                                 .def pulse2_volume_decay = r19 //0000.dddd = Decay
                                 .def triangle_sequence = r20
                                 .def noise_sequence_LOW = r21
                                 .def noise_sequence_HIGH = r22
                                 
                                 reset:
000000 940c 135b                 	jmp init
                                 
                                 .org TCA0_OVF_vect
00000e 940c 1802                 	jmp sound_driver
                                 
                                 .org TCA0_CMP0_vect
000012 940c 1709                 	jmp sequence_0_2
                                 
                                 .org TCA0_CMP1_vect
000014 940c 1714                 	jmp sequence_1_3
                                 
                                 .org TCA0_CMP2_vect
000016 940c 1709                 	jmp sequence_0_2
                                 
                                 .org TCB0_INT_vect
000018 940c 172b                 	jmp pulse1_sequence_routine
                                 
                                 .org TCB1_INT_vect
00001a 940c 1778                 	jmp pulse2_sequence_routine
                                 
                                 .org TCB2_INT_vect
000032 940c 17c5                 	jmp triangle_sequence_routine
                                 
                                 .org TCB3_INT_vect
000048 940c 17d0                 	jmp noise_sequence_routine
                                 
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(33): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(48): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(87): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(88): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(89): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(90): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(91): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(92): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(93): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(94): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(95): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(96): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(97): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(98): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(99): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(100): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(101): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(102): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(104): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(105): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(107): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(108): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(109): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(111): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(112): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(113): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(115): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(116): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(117): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(118): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(121): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(122): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(123): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(126): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(128): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(129): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(130): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(135): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(137): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(138): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(139): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(144): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(147): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(149): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(150): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(151): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(152): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(153): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(154): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(155): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(156): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(157): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(160): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(161): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(162): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(168): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(169): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(171): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(173): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(174): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(176): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(177): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(179): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(180): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(181): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(185): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(186): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(297): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(298): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(299): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(301): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(306): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(307): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(308): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(309): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(310): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(311): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(312): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(313): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(314): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(316): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(320): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(321): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(322): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(323): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(325): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(326): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(328): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(332): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(336): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(337): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(338): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(339): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(341): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(342): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(343): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(346): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(347): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(350): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(351): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(353): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(360): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(361): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
                                 .list
                                 
                                 init:
                                 	//MAIN CLOCK
00135b edc8                      	ldi r28, CPU_CCP_IOREG_gc //protected write
00135c 93c0 0034                 	sts CPU_CCP, r28
00135e e0c0                      	ldi r28, 0 << CLKCTRL_PEN_bp //disable prescaler for 20 MHz on main clock
00135f 93c0 0061                 	sts CLKCTRL_MCLKCTRLB, r28
                                 
                                 	//ZERO
001361 2422                      	clr zero
                                 
                                 	//MEMORY
001362 e3c0                      	ldi r28, 0b00110000
001363 93c0 2800                 	sts pulse1_param, r28
001365 e8c0                      	ldi r28, 0b10000000
001366 93c0 2801                 	sts pulse1_sweep_param, r28
001368 efcf                      	ldi r28, 0xFF
001369 93c0 2802                 	sts pulse1_timerL, r28
00136b 93c0 2803                 	sts pulse1_timerH, r28
00136d 93c0 2804                 	sts pulse1_length, r28
                                 
00136f e3c0                      	ldi r28, 0b00110000
001370 93c0 2808                 	sts pulse2_param, r28
001372 e8c0                      	ldi r28, 0b10000000
001373 93c0 2809                 	sts pulse2_sweep_param, r28
001375 efcf                      	ldi r28, 0xFF
001376 93c0 280a                 	sts pulse2_timerL, r28
001378 93c0 280b                 	sts pulse2_timerH, r28
00137a 93c0 280c                 	sts pulse2_length, r28
                                 
00137c efcf                      	ldi r28, 0xFF
00137d 93c0 2810                 	sts triangle_timerL, r28
00137f 93c0 2811                 	sts triangle_timerH, r28
                                 
001381 e3c0                      	ldi r28, 0b00110000
001382 93c0 2813                 	sts noise_param, r28
001384 e0cf                      	ldi r28, 0b00001111
001385 93c0 2814                 	sts noise_period, r28
                                 
001387 e0c2                      	ldi r28, 0x02
001388 93c0 281a                 	sts song_frame_offset, r28
00138a 9220 281b                 	sts song_frame_offset+1, zero
00138c efcf                      	ldi r28, 0xFF
00138d 93c0 281f                 	sts song_fx_Bxx, r28
00138f 9220 2820                 	sts song_fx_Cxx, zero
001391 9220 2821                 	sts song_fx_Dxx, zero
001393 e4ee                      	ldi ZL, LOW(song0_frames << 1)
001394 e0f3                      	ldi ZH, HIGH(song0_frames << 1)
001395 93e0 2818                 	sts song_frames, ZL
001397 93f0 2819                 	sts song_frames+1, ZH
001399 91c5                      	lpm r28, Z+ //load the song size
00139a 91d5                      	lpm r29, Z+
00139b 93c0 281c                 	sts song_size, r28
00139d 93d0 281d                 	sts song_size+1, r29
00139f 9220 281e                 	sts song_speed, zero
                                 
                                 	//CHANNEL 0
0013a1 91c5                      	lpm r28, Z+
0013a2 91d5                      	lpm r29, Z+
0013a3 0fcc                      	lsl r28
0013a4 1fdd                      	rol r29
0013a5 93c0 2822                 	sts pulse1_pattern, r28
0013a7 93d0 2823                 	sts pulse1_pattern+1, r29
0013a9 9220 2824                 	sts pulse1_pattern_delay_rows, zero
0013ab 9220 2825                 	sts pulse1_pattern_delay_frames, zero
0013ad 9220 2826                 	sts pulse1_pattern_offset, zero
0013af 9220 2827                 	sts pulse1_pattern_offset+1, zero
                                 
                                 	//CHANNEL 1
0013b1 91c5                      	lpm r28, Z+
0013b2 91d5                      	lpm r29, Z+
0013b3 0fcc                      	lsl r28
0013b4 1fdd                      	rol r29
0013b5 93c0 2871                 	sts pulse2_pattern, r28
0013b7 93d0 2872                 	sts pulse2_pattern+1, r29
0013b9 9220 2873                 	sts pulse2_pattern_delay_rows, zero
0013bb 9220 2874                 	sts pulse2_pattern_delay_frames, zero
0013bd 9220 2875                 	sts pulse2_pattern_offset, zero
0013bf 9220 2876                 	sts pulse2_pattern_offset+1, zero
                                 
                                 	//CHANNEL 2
0013c1 91c5                      	lpm r28, Z+
0013c2 91d5                      	lpm r29, Z+
0013c3 0fcc                      	lsl r28
0013c4 1fdd                      	rol r29
0013c5 93c0 28c0                 	sts triangle_pattern, r28
0013c7 93d0 28c1                 	sts triangle_pattern+1, r29
0013c9 9220 28c2                 	sts triangle_pattern_delay_rows, zero
0013cb 9220 28c3                 	sts triangle_pattern_delay_frames, zero
0013cd 9220 28c4                 	sts triangle_pattern_offset, zero
0013cf 9220 28c5                 	sts triangle_pattern_offset+1, zero
                                 
                                 	//CHANNEL 3
0013d1 91c5                      	lpm r28, Z+
0013d2 91d5                      	lpm r29, Z+
0013d3 0fcc                      	lsl r28
0013d4 1fdd                      	rol r29
0013d5 93c0 290a                 	sts noise_pattern, r28
0013d7 93d0 290b                 	sts noise_pattern+1, r29
0013d9 9220 290c                 	sts noise_pattern_delay_rows, zero
0013db 9220 290d                 	sts noise_pattern_delay_frames, zero
0013dd 9220 290e                 	sts noise_pattern_offset, zero
0013df 9220 290f                 	sts noise_pattern_offset+1, zero
                                 
                                 	//CHANNEL 0 instrument macros
0013e1 efcf                      	ldi r28, 0xFF
0013e2 9220 282a                 	sts pulse1_volume_macro_offset, zero
0013e4 93c0 282b                 	sts pulse1_volume_macro_loop, r28
0013e6 93c0 282c                 	sts pulse1_volume_macro_release, r28
0013e8 9220 282f                 	sts pulse1_arpeggio_macro_offset, zero
0013ea 93c0 2830                 	sts pulse1_arpeggio_macro_loop, r28
0013ec 93c0 2831                 	sts pulse1_arpeggio_macro_release, r28
0013ee 93c0 2832                 	sts pulse1_arpeggio_macro_mode, r28
0013f0 9220 2837                 	sts pulse1_pitch_macro_offset, zero
0013f2 93c0 2838                 	sts pulse1_pitch_macro_loop, r28
0013f4 93c0 2839                 	sts pulse1_pitch_macro_release, r28
0013f6 9220 283d                 	sts pulse1_hi_pitch_macro_offset, zero
0013f8 93c0 283e                 	sts pulse1_hi_pitch_macro_loop, r28
0013fa 93c0 283f                 	sts pulse1_hi_pitch_macro_release, r28
0013fc 9220 2842                 	sts pulse1_duty_macro_offset, zero
0013fe 93c0 2843                 	sts pulse1_duty_macro_loop, r28
001400 93c0 2844                 	sts pulse1_duty_macro_release, r28
                                 
001402 9220 2828                 	sts pulse1_volume_macro, zero
001404 9220 2829                 	sts pulse1_volume_macro+1, zero
001406 9220 282d                 	sts pulse1_arpeggio_macro, zero
001408 9220 282e                 	sts pulse1_arpeggio_macro+1, zero
00140a 9220 2833                 	sts pulse1_total_pitch_offset, zero
00140c 9220 2834                 	sts pulse1_total_pitch_offset+1, zero
00140e 9220 2835                 	sts pulse1_pitch_macro, zero
001410 9220 2836                 	sts pulse1_pitch_macro+1, zero
001412 9220 283a                 	sts pulse1_total_hi_pitch_offset, zero
001414 9220 283b                 	sts pulse1_hi_pitch_macro, zero
001416 9220 283c                 	sts pulse1_hi_pitch_macro+1, zero
001418 9220 2840                 	sts pulse1_duty_macro, zero
00141a 9220 2841                 	sts pulse1_duty_macro+1, zero
                                 
                                 	//CHANNEL 0 ENVELOPE
00141c e00f                      	ldi pulse1_volume_divider, 0x0F
00141d 9110 2800                 	lds pulse1_volume_decay, pulse1_param
00141f 701f                      	andi pulse1_volume_decay, 0x0F //mask for VVVV bits
001420 9190 2800                 	lds pulse_channel_flags, pulse1_param
001422 7390                      	andi pulse_channel_flags, 0b00110000
001423 6490                      	sbr pulse_channel_flags, 0b01000000 //set start flag
001424 9220 2806                 	sts pulse1_output_volume, zero
001426 93c0 2805                 	sts pulse1_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 0 LENGTH
001428 2ebc                      	mov pulse1_length_counter, r28
                                 
                                 	//CHANNEL 0 SEQUENCE
001429 e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
00142a 2eac                      	mov pulse1_sequence, r28
                                 
                                 	//CHANNEL 0 SWEEP
00142b 90c0 2801                 	lds pulse1_sweep, pulse1_sweep_param
00142d 94c2                      	swap pulse1_sweep //swap data from high byte and low byte
00142e 6890                      	sbr pulse_channel_flags, 0b10000000 //set reload flag
                                 
                                 	//CHANNEL 0 FX
00142f efcf                      	ldi r28, 0xFF
001430 9220 2845                 	sts pulse1_fx_0xy_sequence, zero
001432 9220 2846                 	sts pulse1_fx_0xy_sequence+1, zero
001434 9220 2847                 	sts pulse1_fx_1xx, zero
001436 9220 2848                 	sts pulse1_fx_1xx+1, zero
001438 9220 2849                 	sts pulse1_fx_1xx_total, zero
00143a 9220 284a                 	sts pulse1_fx_1xx_total+1, zero
00143c 9220 284b                 	sts pulse1_fx_2xx, zero
00143e 9220 284c                 	sts pulse1_fx_2xx+1, zero
001440 9220 284d                 	sts pulse1_fx_2xx_total, zero
001442 9220 284e                 	sts pulse1_fx_2xx_total+1, zero
001444 9220 284f                 	sts pulse1_fx_3xx_start, zero
001446 9220 2850                 	sts pulse1_fx_3xx_start+1, zero
001448 9220 2851                 	sts pulse1_fx_3xx_target, zero
00144a 9220 2852                 	sts pulse1_fx_3xx_target+1, zero
00144c 9220 2853                 	sts pulse1_fx_3xx_speed, zero
00144e 9220 2854                 	sts pulse1_fx_3xx_speed+1, zero
001450 9220 2855                 	sts pulse1_fx_3xx_total_offset, zero
001452 9220 2856                 	sts pulse1_fx_3xx_total_offset+1, zero
001454 9220 2857                 	sts pulse1_fx_4xy_speed, zero
001456 9220 2858                 	sts pulse1_fx_4xy_depth, zero
001458 9220 2859                 	sts pulse1_fx_4xy_phase, zero
00145a 9220 285a                 	sts pulse1_fx_7xy_speed, zero
00145c 9220 285b                 	sts pulse1_fx_7xy_depth, zero
00145e 9220 285c                 	sts pulse1_fx_7xy_phase, zero
001460 9220 285d                 	sts pulse1_fx_7xy_value, zero
001462 9220 285e                 	sts pulse1_fx_Axy, zero
001464 93c0 285f                 	sts pulse1_fx_Gxx_pre, r28
001466 93c0 2860                 	sts pulse1_fx_Gxx_post, r28
001468 9220 2861                 	sts pulse1_fx_Pxx_total, zero
00146a 9220 2862                 	sts pulse1_fx_Pxx_total+1, zero
00146c 9220 2863                 	sts pulse1_fx_Qxy_target, zero
00146e 9220 2864                 	sts pulse1_fx_Qxy_target+1, zero
001470 9220 2865                 	sts pulse1_fx_Qxy_speed, zero
001472 9220 2866                 	sts pulse1_fx_Qxy_speed+1, zero
001474 9220 2867                 	sts pulse1_fx_Qxy_total_offset, zero
001476 9220 2868                 	sts pulse1_fx_Qxy_total_offset+1, zero
001478 9220 2869                 	sts pulse1_fx_Rxy_target, zero
00147a 9220 286a                 	sts pulse1_fx_Rxy_target+1, zero
00147c 9220 286b                 	sts pulse1_fx_Rxy_speed, zero
00147e 9220 286c                 	sts pulse1_fx_Rxy_speed+1, zero
001480 9220 286d                 	sts pulse1_fx_Rxy_total_offset, zero
001482 9220 286e                 	sts pulse1_fx_Rxy_total_offset+1, zero
001484 93c0 286f                 	sts pulse1_fx_Sxx_pre, r28
001486 93c0 2870                 	sts pulse1_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 1 instrument macros
001488 efcf                      	ldi r28, 0xFF
001489 9220 2879                 	sts pulse2_volume_macro_offset, zero
00148b 93c0 287a                 	sts pulse2_volume_macro_loop, r28
00148d 93c0 287b                 	sts pulse2_volume_macro_release, r28
00148f 9220 287e                 	sts pulse2_arpeggio_macro_offset, zero
001491 93c0 287f                 	sts pulse2_arpeggio_macro_loop, r28
001493 93c0 2880                 	sts pulse2_arpeggio_macro_release, r28
001495 93c0 2881                 	sts pulse2_arpeggio_macro_mode, r28
001497 9220 2886                 	sts pulse2_pitch_macro_offset, zero
001499 93c0 2887                 	sts pulse2_pitch_macro_loop, r28
00149b 93c0 2888                 	sts pulse2_pitch_macro_release, r28
00149d 9220 288c                 	sts pulse2_hi_pitch_macro_offset, zero
00149f 93c0 288d                 	sts pulse2_hi_pitch_macro_loop, r28
0014a1 93c0 288e                 	sts pulse2_hi_pitch_macro_release, r28
0014a3 9220 2891                 	sts pulse2_duty_macro_offset, zero
0014a5 93c0 2892                 	sts pulse2_duty_macro_loop, r28
0014a7 93c0 2893                 	sts pulse2_duty_macro_release, r28
                                 
0014a9 9220 2877                 	sts pulse2_volume_macro, zero
0014ab 9220 2878                 	sts pulse2_volume_macro+1, zero
0014ad 9220 287c                 	sts pulse2_arpeggio_macro, zero
0014af 9220 287d                 	sts pulse2_arpeggio_macro+1, zero
0014b1 9220 2882                 	sts pulse2_total_pitch_offset, zero
0014b3 9220 2883                 	sts pulse2_total_pitch_offset+1, zero
0014b5 9220 2884                 	sts pulse2_pitch_macro, zero
0014b7 9220 2885                 	sts pulse2_pitch_macro+1, zero
0014b9 9220 2889                 	sts pulse2_total_hi_pitch_offset, zero
0014bb 9220 288a                 	sts pulse2_hi_pitch_macro, zero
0014bd 9220 288b                 	sts pulse2_hi_pitch_macro+1, zero
0014bf 9220 288f                 	sts pulse2_duty_macro, zero
0014c1 9220 2890                 	sts pulse2_duty_macro+1, zero
                                 
                                 	//CHANNEL 1 ENVELOPE
0014c3 e02f                      	ldi pulse2_volume_divider, 0x0F
0014c4 9130 2808                 	lds pulse2_volume_decay, pulse2_param
0014c6 703f                      	andi pulse2_volume_decay, 0x0F //mask for VVVV bits
0014c7 91d0 2808                 	lds r29, pulse2_param
0014c9 73d0                      	andi r29, 0b00110000
0014ca 62d0                      	sbr r29, 0b0100000 //set start flag
0014cb 95d2                      	swap r29
0014cc 2b9d                      	or pulse_channel_flags, r29
0014cd 9220 280e                 	sts pulse2_output_volume, zero
0014cf 93c0 280d                 	sts pulse2_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 1 LENGTH
0014d1 2eec                      	mov pulse2_length_counter, r28
                                 
                                 	//CHANNEL 1 SEQUENCE
0014d2 e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
0014d3 2edc                      	mov pulse2_sequence, r28
                                 
                                 	//CHANNEL 1 SWEEP
0014d4 90f0 2809                 	lds pulse2_sweep, pulse2_sweep_param
0014d6 94f2                      	swap pulse2_sweep //swap data from high byte and low byte
0014d7 6098                      	sbr pulse_channel_flags, 0b00001000 //set reload flag
                                 
                                 	//CHANNEL 1 FX
0014d8 efcf                      	ldi r28, 0xFF
0014d9 9220 2894                 	sts pulse2_fx_0xy_sequence, zero
0014db 9220 2895                 	sts pulse2_fx_0xy_sequence+1, zero
0014dd 9220 2896                 	sts pulse2_fx_1xx, zero
0014df 9220 2897                 	sts pulse2_fx_1xx+1, zero
0014e1 9220 2898                 	sts pulse2_fx_1xx_total, zero
0014e3 9220 2899                 	sts pulse2_fx_1xx_total+1, zero
0014e5 9220 289a                 	sts pulse2_fx_2xx, zero
0014e7 9220 289b                 	sts pulse2_fx_2xx+1, zero
0014e9 9220 289c                 	sts pulse2_fx_2xx_total, zero
0014eb 9220 289d                 	sts pulse2_fx_2xx_total+1, zero
0014ed 9220 289e                 	sts pulse2_fx_3xx_start, zero
0014ef 9220 289f                 	sts pulse2_fx_3xx_start+1, zero
0014f1 9220 28a0                 	sts pulse2_fx_3xx_target, zero
0014f3 9220 28a1                 	sts pulse2_fx_3xx_target+1, zero
0014f5 9220 28a2                 	sts pulse2_fx_3xx_speed, zero
0014f7 9220 28a3                 	sts pulse2_fx_3xx_speed+1, zero
0014f9 9220 28a4                 	sts pulse2_fx_3xx_total_offset, zero
0014fb 9220 28a5                 	sts pulse2_fx_3xx_total_offset+1, zero
0014fd 9220 28a6                 	sts pulse2_fx_4xy_speed, zero
0014ff 9220 28a7                 	sts pulse2_fx_4xy_depth, zero
001501 9220 28a8                 	sts pulse2_fx_4xy_phase, zero
001503 9220 28a9                 	sts pulse2_fx_7xy_speed, zero
001505 9220 28aa                 	sts pulse2_fx_7xy_depth, zero
001507 9220 28ab                 	sts pulse2_fx_7xy_phase, zero
001509 9220 28ac                 	sts pulse2_fx_7xy_value, zero
00150b 9220 28ad                 	sts pulse2_fx_Axy, zero
00150d 93c0 28ae                 	sts pulse2_fx_Gxx_pre, r28
00150f 93c0 28af                 	sts pulse2_fx_Gxx_post, r28
001511 9220 28b0                 	sts pulse2_fx_Pxx_total, zero
001513 9220 28b1                 	sts pulse2_fx_Pxx_total+1, zero
001515 9220 28b2                 	sts pulse2_fx_Qxy_target, zero
001517 9220 28b3                 	sts pulse2_fx_Qxy_target+1, zero
001519 9220 28b4                 	sts pulse2_fx_Qxy_speed, zero
00151b 9220 28b5                 	sts pulse2_fx_Qxy_speed+1, zero
00151d 9220 28b6                 	sts pulse2_fx_Qxy_total_offset, zero
00151f 9220 28b7                 	sts pulse2_fx_Qxy_total_offset+1, zero
001521 9220 28b8                 	sts pulse2_fx_Rxy_target, zero
001523 9220 28b9                 	sts pulse2_fx_Rxy_target+1, zero
001525 9220 28ba                 	sts pulse2_fx_Rxy_speed, zero
001527 9220 28bb                 	sts pulse2_fx_Rxy_speed+1, zero
001529 9220 28bc                 	sts pulse2_fx_Rxy_total_offset, zero
00152b 9220 28bd                 	sts pulse2_fx_Rxy_total_offset+1, zero
00152d 93c0 28be                 	sts pulse2_fx_Sxx_pre, r28
00152f 93c0 28bf                 	sts pulse2_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 2 instrument macros
001531 efcf                      	ldi r28, 0xFF
001532 9220 28c8                 	sts triangle_volume_macro_offset, zero
001534 93c0 28c9                 	sts triangle_volume_macro_loop, r28
001536 93c0 28ca                 	sts triangle_volume_macro_release, r28
001538 9220 28cd                 	sts triangle_arpeggio_macro_offset, zero
00153a 93c0 28ce                 	sts triangle_arpeggio_macro_loop, r28
00153c 93c0 28cf                 	sts triangle_arpeggio_macro_release, r28
00153e 93c0 28d0                 	sts triangle_arpeggio_macro_mode, r28
001540 9220 28d5                 	sts triangle_pitch_macro_offset, zero
001542 93c0 28d6                 	sts triangle_pitch_macro_loop, r28
001544 93c0 28d7                 	sts triangle_pitch_macro_release, r28
001546 9220 28db                 	sts triangle_hi_pitch_macro_offset, zero
001548 93c0 28dc                 	sts triangle_hi_pitch_macro_loop, r28
00154a 93c0 28dd                 	sts triangle_hi_pitch_macro_release, r28
00154c 9220 28e0                 	sts triangle_duty_macro_offset, zero
00154e 93c0 28e1                 	sts triangle_duty_macro_loop, r28
001550 93c0 28e2                 	sts triangle_duty_macro_release, r28
                                 
001552 9220 28c6                 	sts triangle_volume_macro, zero
001554 9220 28c7                 	sts triangle_volume_macro+1, zero
001556 9220 28cb                 	sts triangle_arpeggio_macro, zero
001558 9220 28cc                 	sts triangle_arpeggio_macro+1, zero
00155a 9220 28d1                 	sts triangle_total_pitch_offset, zero
00155c 9220 28d2                 	sts triangle_total_pitch_offset+1, zero
00155e 9220 28d3                 	sts triangle_pitch_macro, zero
001560 9220 28d4                 	sts triangle_pitch_macro+1, zero
001562 9220 28d8                 	sts triangle_total_hi_pitch_offset, zero
001564 9220 28d9                 	sts triangle_hi_pitch_macro, zero
001566 9220 28da                 	sts triangle_hi_pitch_macro+1, zero
001568 9220 28de                 	sts triangle_duty_macro, zero
00156a 9220 28df                 	sts triangle_duty_macro+1, zero
                                 
                                 	//CHANNEL 2 SEQUENCE
00156c e0c0                      	ldi r28, 0b00000000 //reset sequence to 0
00156d 2f4c                      	mov triangle_sequence, r28
                                 
                                 	//CHANNEL 2 FX
00156e efcf                      	ldi r28, 0xFF
00156f 9220 28e3                 	sts triangle_fx_0xy_sequence, zero
001571 9220 28e4                 	sts triangle_fx_0xy_sequence+1, zero
001573 9220 28e5                 	sts triangle_fx_1xx, zero
001575 9220 28e6                 	sts triangle_fx_1xx+1, zero
001577 9220 28e7                 	sts triangle_fx_1xx_total, zero
001579 9220 28e8                 	sts triangle_fx_1xx_total+1, zero
00157b 9220 28e9                 	sts triangle_fx_2xx, zero
00157d 9220 28ea                 	sts triangle_fx_2xx+1, zero
00157f 9220 28eb                 	sts triangle_fx_2xx_total, zero
001581 9220 28ec                 	sts triangle_fx_2xx_total+1, zero
001583 9220 28ed                 	sts triangle_fx_3xx_start, zero
001585 9220 28ee                 	sts triangle_fx_3xx_start+1, zero
001587 9220 28ef                 	sts triangle_fx_3xx_target, zero
001589 9220 28f0                 	sts triangle_fx_3xx_target+1, zero
00158b 9220 28f1                 	sts triangle_fx_3xx_speed, zero
00158d 9220 28f2                 	sts triangle_fx_3xx_speed+1, zero
00158f 9220 28f3                 	sts triangle_fx_3xx_total_offset, zero
001591 9220 28f4                 	sts triangle_fx_3xx_total_offset+1, zero
001593 9220 28f5                 	sts triangle_fx_4xy_speed, zero
001595 9220 28f6                 	sts triangle_fx_4xy_depth, zero
001597 9220 28f7                 	sts triangle_fx_4xy_phase, zero
001599 93c0 28f8                 	sts triangle_fx_Gxx_pre, r28
00159b 93c0 28f9                 	sts triangle_fx_Gxx_post, r28
00159d 9220 28fa                 	sts triangle_fx_Pxx_total, zero
00159f 9220 28fb                 	sts triangle_fx_Pxx_total+1, zero
0015a1 9220 28fc                 	sts triangle_fx_Qxy_target, zero
0015a3 9220 28fd                 	sts triangle_fx_Qxy_target+1, zero
0015a5 9220 28fe                 	sts triangle_fx_Qxy_speed, zero
0015a7 9220 28ff                 	sts triangle_fx_Qxy_speed+1, zero
0015a9 9220 2900                 	sts triangle_fx_Qxy_total_offset, zero
0015ab 9220 2901                 	sts triangle_fx_Qxy_total_offset+1, zero
0015ad 9220 2902                 	sts triangle_fx_Rxy_target, zero
0015af 9220 2903                 	sts triangle_fx_Rxy_target+1, zero
0015b1 9220 2904                 	sts triangle_fx_Rxy_speed, zero
0015b3 9220 2905                 	sts triangle_fx_Rxy_speed+1, zero
0015b5 9220 2906                 	sts triangle_fx_Rxy_total_offset, zero
0015b7 9220 2907                 	sts triangle_fx_Rxy_total_offset+1, zero
0015b9 93c0 2908                 	sts triangle_fx_Sxx_pre, r28
0015bb 93c0 2909                 	sts triangle_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 3 instrument macros
0015bd efcf                      	ldi r28, 0xFF
0015be 9220 2912                 	sts noise_volume_macro_offset, zero
0015c0 93c0 2913                 	sts noise_volume_macro_loop, r28
0015c2 93c0 2914                 	sts noise_volume_macro_release, r28
0015c4 9220 2917                 	sts noise_arpeggio_macro_offset, zero
0015c6 93c0 2918                 	sts noise_arpeggio_macro_loop, r28
0015c8 93c0 2919                 	sts noise_arpeggio_macro_release, r28
0015ca 93c0 291a                 	sts noise_arpeggio_macro_mode, r28
0015cc 9220 291f                 	sts noise_pitch_macro_offset, zero
0015ce 93c0 2920                 	sts noise_pitch_macro_loop, r28
0015d0 93c0 2921                 	sts noise_pitch_macro_release, r28
0015d2 9220 2925                 	sts noise_hi_pitch_macro_offset, zero
0015d4 93c0 2926                 	sts noise_hi_pitch_macro_loop, r28
0015d6 93c0 2927                 	sts noise_hi_pitch_macro_release, r28
0015d8 9220 292a                 	sts noise_duty_macro_offset, zero
0015da 93c0 292b                 	sts noise_duty_macro_loop, r28
0015dc 93c0 292c                 	sts noise_duty_macro_release, r28
                                 
0015de 9220 2910                 	sts noise_volume_macro, zero
0015e0 9220 2911                 	sts noise_volume_macro+1, zero
0015e2 9220 2915                 	sts noise_arpeggio_macro, zero
0015e4 9220 2916                 	sts noise_arpeggio_macro+1, zero
0015e6 9220 291b                 	sts noise_total_pitch_offset, zero
0015e8 9220 291c                 	sts noise_total_pitch_offset+1, zero
0015ea 9220 291d                 	sts noise_pitch_macro, zero
0015ec 9220 291e                 	sts noise_pitch_macro+1, zero
0015ee 9220 2922                 	sts noise_total_hi_pitch_offset, zero
0015f0 9220 2923                 	sts noise_hi_pitch_macro, zero
0015f2 9220 2924                 	sts noise_hi_pitch_macro+1, zero
0015f4 9220 2928                 	sts noise_duty_macro, zero
0015f6 9220 2929                 	sts noise_duty_macro+1, zero
                                 
                                 	//CHANNEL 3 VOLUME
0015f8 9220 2816                 	sts noise_output_volume, zero
0015fa 93c0 2815                 	sts noise_fractional_volume, r28 //initialize fractional volume to max value
                                 
                                 	//CHANNEL 3 SEQUENCE
0015fc e0c1                      	ldi r28, 0b00000001 //noise sequence is reset to 0x0001
0015fd 2f5c                      	mov noise_sequence_LOW, r28
0015fe 2d62                      	mov noise_sequence_HIGH, zero
                                 
                                 	//CHANNEL 3 FX
0015ff efcf                      	ldi r28, 0xFF
001600 9220 292d                 	sts noise_fx_0xy_sequence, zero
001602 9220 292e                 	sts noise_fx_0xy_sequence+1, zero
001604 9220 292f                 	sts noise_fx_1xx, zero
001606 9220 2930                 	sts noise_fx_1xx+1, zero
001608 9220 2931                 	sts noise_fx_1xx_total, zero
00160a 9220 2932                 	sts noise_fx_1xx_total+1, zero
00160c 9220 2933                 	sts noise_fx_2xx, zero
00160e 9220 2934                 	sts noise_fx_2xx+1, zero
001610 9220 2935                 	sts noise_fx_2xx_total, zero
001612 9220 2936                 	sts noise_fx_2xx_total+1, zero
001614 9220 2937                 	sts noise_fx_3xx_start, zero
001616 9220 2938                 	sts noise_fx_3xx_start+1, zero
001618 9220 2939                 	sts noise_fx_3xx_target, zero
00161a 9220 293a                 	sts noise_fx_3xx_target+1, zero
00161c 9220 293b                 	sts noise_fx_3xx_speed, zero
00161e 9220 293c                 	sts noise_fx_3xx_speed+1, zero
001620 9220 293d                 	sts noise_fx_3xx_total_offset, zero
001622 9220 293e                 	sts noise_fx_3xx_total_offset+1, zero
001624 9220 293f                 	sts noise_fx_4xy_speed, zero
001626 9220 2940                 	sts noise_fx_4xy_depth, zero
001628 9220 2941                 	sts noise_fx_4xy_phase, zero
00162a 9220 2942                 	sts noise_fx_7xy_speed, zero
00162c 9220 2943                 	sts noise_fx_7xy_depth, zero
00162e 9220 2944                 	sts noise_fx_7xy_phase, zero
001630 9220 2945                 	sts noise_fx_7xy_value, zero
001632 9220 2946                 	sts noise_fx_Axy, zero
001634 93c0 2947                 	sts noise_fx_Gxx_pre, r28
001636 93c0 2948                 	sts noise_fx_Gxx_post, r28
001638 9220 2949                 	sts noise_fx_Pxx_total, zero
00163a 9220 294a                 	sts noise_fx_Pxx_total+1, zero
00163c 9220 294b                 	sts noise_fx_Qxy_target, zero
00163e 9220 294c                 	sts noise_fx_Qxy_target+1, zero
001640 9220 294d                 	sts noise_fx_Qxy_speed, zero
001642 9220 294e                 	sts noise_fx_Qxy_speed+1, zero
001644 9220 294f                 	sts noise_fx_Qxy_total_offset, zero
001646 9220 2950                 	sts noise_fx_Qxy_total_offset+1, zero
001648 9220 2951                 	sts noise_fx_Rxy_target, zero
00164a 9220 2952                 	sts noise_fx_Rxy_target+1, zero
00164c 9220 2953                 	sts noise_fx_Rxy_speed, zero
00164e 9220 2954                 	sts noise_fx_Rxy_speed+1, zero
001650 9220 2955                 	sts noise_fx_Rxy_total_offset, zero
001652 9220 2956                 	sts noise_fx_Rxy_total_offset+1, zero
001654 93c0 2957                 	sts noise_fx_Sxx_pre, r28
001656 93c0 2958                 	sts noise_fx_Sxx_post, r28
                                 
                                 	//PINS
001658 efcf                      	ldi r28, 0xFF
001659 b9c0                      	out VPORTA_DIR, r28 //set all pins in VPORTA to output
                                 
                                 	//TIMERS
                                 	//Frame Counter
                                 	//NOTE:The frame counter will be defaulted to NTSC mode (60 Hz, 120 Hz, 240 Hz)
                                 	//Each interrupt will be setup to interrupt every 240 Hz clock
                                 	//CMP0 = sequence 0, CMP1 = sequence 1, CMP2 = sequence 2, OVF = sequence 3/sound driver
                                 	//Sequence 3 will clock the sound driver every 60Hz, in which new audio data is read and written to the registers
                                 	//Timer period Calculation: (0.00416666666 * 20000000/64)-1 = 1301.08333125 = 0x0515
                                 	//The ATmega4809 is cofigured to run at 20000000 Hz
                                 	//0.00416666666 seconds is the period for 240 Hz
                                 	//The /64 comes from the prescaler divider used
00165a e7c0                      	ldi r28, TCA_SINGLE_CMP0EN_bm | TCA_SINGLE_CMP1EN_bm | TCA_SINGLE_CMP2EN_bm | TCA_SINGLE_WGMODE_NORMAL_gc //interrupt mode
00165b 93c0 0a01                 	sts TCA0_SINGLE_CTRLB, r28
00165d e7c1                      	ldi r28, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP1_bm | TCA_SINGLE_CMP2_bm | TCA_SINGLE_OVF_bm //enable overflow and compare interrupts
00165e 93c0 0a0a                 	sts TCA0_SINGLE_INTCTRL, r28
001660 e1c5                      	ldi r28, 0x15 //set the period for CMP0
001661 93c0 0a28                 	sts TCA0_SINGLE_CMP0, r28
001663 e0c5                      	ldi r28, 0x05
001664 93c0 0a29                 	sts TCA0_SINGLE_CMP0 + 1, r28
001666 e2cb                      	ldi r28, 0x2B //set the period for CMP1
001667 93c0 0a2a                 	sts TCA0_SINGLE_CMP1, r28
001669 e0ca                      	ldi r28, 0x0A
00166a 93c0 0a2b                 	sts TCA0_SINGLE_CMP1 + 1, r28
00166c e4c1                      	ldi r28, 0x41 //set the period for CMP2
00166d 93c0 0a2c                 	sts TCA0_SINGLE_CMP2, r28
00166f e0cf                      	ldi r28, 0x0F
001670 93c0 0a2d                 	sts TCA0_SINGLE_CMP2 + 1, r28
001672 e5c7                      	ldi r28, 0x57 //set the period for OVF
001673 93c0 0a26                 	sts TCA0_SINGLE_PER, r28
001675 e1c4                      	ldi r28, 0x14
001676 93c0 0a27                 	sts TCA0_SINGLE_PER + 1, r28
001678 e0cb                      	ldi r28, TCA_SINGLE_CLKSEL_DIV64_gc | TCA_SINGLE_ENABLE_bm //use prescale divider of 64 and enable timer
001679 93c0 0a00                 	sts TCA0_SINGLE_CTRLA, r28
                                 
                                 	//NOTE: Channel Timers are clocked (20/2)/(0.8948865) = 11.1746014718 times faster than the NES APU
                                 	//Because of this, we multiply all the NES timer values by 11.1746014718 beforehand
                                 	//Since we rotate the sequence when the timer goes from t-(t-1) to 0, instead of 0 to t like the NES, we add 1 to the NES timers before multiplying
                                 	//The ATmega4809 is configured to run at 20 MHz
                                 	//The /2 comes from the prescaler divider used
                                 	//0.8948865 MHz is the speed of the NTSC NES APU
                                 	//NOTE: This means that any offset to the pitch for the NES timers would be multiplied by 11.1746014718 aswell.
                                 	//Pulse 1
00167b e0c0                      	ldi r28, TCB_CNTMODE_INT_gc //interrupt mode
00167c 93c0 0a81                 	sts TCB0_CTRLB, r28
00167e e0c1                      	ldi r28, TCB_CAPT_bm //enable interrupts
00167f 93c0 0a85                 	sts TCB0_INTCTRL, r28
001681 91c0 2802                 	lds r28, pulse1_timerL //load the LOW bits for timer
001683 93c0 0a8c                 	sts TCB0_CCMPL, r28
001685 91c0 2803                 	lds r28, pulse1_timerH //load the HIGH bits for timer
001687 93c0 0a8d                 	sts TCB0_CCMPH, r28
001689 e0c3                      	ldi r28, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
00168a 93c0 0a80                 	sts TCB0_CTRLA, r28
                                 
                                 	//PULSE 2
00168c e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
00168d 93b0 0a91                 	sts TCB1_CTRLB, r27
00168f e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001690 93b0 0a95                 	sts TCB1_INTCTRL, r27
001692 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
001694 93b0 0a9c                 	sts TCB1_CCMPL, r27
001696 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
001698 93b0 0a9d                 	sts TCB1_CCMPH, r27
00169a e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
00169b 93b0 0a90                 	sts TCB1_CTRLA, r27
                                 
                                 	//NOTE: The triangle timer is clocked at the same speed as the NES CPU, aka twice the NES APU.
                                 	//Therefore, we won't be using a /2 clock divider like we did with the pulse timers.
                                 	//TRIANGLE
00169d e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
00169e 93b0 0aa1                 	sts TCB2_CTRLB, r27
0016a0 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
0016a1 93b0 0aa5                 	sts TCB2_INTCTRL, r27
0016a3 91b0 2810                 	lds r27, triangle_timerL //load the LOW bits for timer
0016a5 93b0 0aac                 	sts TCB2_CCMPL, r27
0016a7 91b0 2811                 	lds r27, triangle_timerH //load the HIGH bits for timer
0016a9 93b0 0aad                 	sts TCB2_CCMPH, r27
0016ab e0b1                      	ldi r27, TCB_CLKSEL_CLKDIV1_gc | TCB_ENABLE_bm //use prescaler divider of 1 and enable timer
0016ac 93b0 0aa0                 	sts TCB2_CTRLA, r27
0016ae 9478                      	sei //global interrupt enable
                                 
                                 	//NOISE
0016af e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
0016b0 93b0 0ab1                 	sts TCB3_CTRLB, r27
0016b2 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
0016b3 93b0 0ab5                 	sts TCB3_INTCTRL, r27
0016b5 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
0016b7 93b0 0abc                 	sts TCB3_CCMPL, r27
0016b9 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
0016bb 93b0 0abd                 	sts TCB3_CCMPH, r27
0016bd e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
0016be 93b0 0ab0                 	sts TCB3_CTRLA, r27
                                 
                                 
                                 
                                 //https://wiki.nesdev.com/w/index.php/APU_Mixer
                                 volume_mixer:
0016c0 91c0 2806                 	lds r28, pulse1_output_volume
0016c2 91d0 280e                 	lds r29, pulse2_output_volume
                                 
                                 volume_mixer_pulse1:
0016c4 fea0                      	sbrs pulse1_sequence, 0 //if the sequence output is zero, return
0016c5 c015                      	rjmp volume_mixer_pulse1_off
                                 
0016c6 14b2                      	cp pulse1_length_counter, zero //if length is zero, return
0016c7 f099                      	breq volume_mixer_pulse1_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
0016c8 91e0 0a8c                 	lds r30, TCB0_CCMPL
0016ca e5f9                      	ldi r31, 0x059
0016cb 17ef                      	cp r30, r31
0016cc 91e0 0a8d                 	lds r30, TCB0_CCMPH
0016ce e0f0                      	ldi r31, 0x00
0016cf 07ef                      	cpc r30, r31
0016d0 f050                      	brlo volume_mixer_pulse1_off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $5965
0016d1 91e0 0a8c                 	lds r30, TCB0_CCMPL
0016d3 e6f6                      	ldi r31, 0x66
0016d4 17ef                      	cp r30, r31
0016d5 91e0 0a8d                 	lds r30, TCB0_CCMPH
0016d7 e5f9                      	ldi r31, 0x59
0016d8 07ef                      	cpc r30, r31
0016d9 f408                      	brsh volume_mixer_pulse1_off
0016da c001                      	rjmp volume_mixer_pulse2 //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse1_off:
0016db 27cc                      	clr r28
                                 
                                 volume_mixer_pulse2:
0016dc fed0                      	sbrs pulse2_sequence, 0 //if the sequence output is zero, return
0016dd c015                      	rjmp volume_mixer_pulse2_off
                                 
0016de 14e2                      	cp pulse2_length_counter, zero //if length is zero, return
0016df f099                      	breq volume_mixer_pulse2_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
0016e0 91e0 0a9c                 	lds r30, TCB1_CCMPL
0016e2 e5f9                      	ldi r31, 0x059
0016e3 17ef                      	cp r30, r31
0016e4 91e0 0a9d                 	lds r30, TCB1_CCMPH
0016e6 e0f0                      	ldi r31, 0x00
0016e7 07ef                      	cpc r30, r31
0016e8 f050                      	brlo volume_mixer_pulse2_off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $5965
0016e9 91e0 0a9c                 	lds r30, TCB1_CCMPL
0016eb e6f6                      	ldi r31, 0x66
0016ec 17ef                      	cp r30, r31
0016ed 91e0 0a9d                 	lds r30, TCB1_CCMPH
0016ef e5f9                      	ldi r31, 0x59
0016f0 07ef                      	cpc r30, r31
0016f1 f408                      	brsh volume_mixer_pulse2_off
0016f2 c001                      	rjmp volume_mixer_pulse_out //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse2_off:
0016f3 27dd                      	clr r29
                                 
                                 volume_mixer_pulse_out:
0016f4 0fcd                      	add r28, r29
0016f5 e6e2                      	ldi ZL, LOW(pulse_volume_table << 1)
0016f6 e0f2                      	ldi ZH, HIGH(pulse_volume_table << 1)
0016f7 0fec                      	add ZL, r28
0016f8 1df2                      	adc ZH, zero
0016f9 91c4                      	lpm r28, Z
                                 
                                 volume_mixer_tnd_triangle:
0016fa 2fd4                      	mov r29, triangle_sequence
0016fb fdd4                      	sbrc r29, 4 //check 5th bit
0016fc 95d0                      	com r29
0016fd 70df                      	andi r29, 0x0F
0016fe 2fed                      	mov r30, r29
0016ff 0fde                      	add r29, r30 //multiply the triangle volume by 3
001700 0fde                      	add r29, r30
                                 
                                 volume_mixer_tnd_out:
001701 e8e2                      	ldi ZL, LOW(tnd_volume_table << 1)
001702 e0f2                      	ldi ZH, HIGH(tnd_volume_table << 1)
001703 0fed                      	add ZL, r29
001704 1df2                      	adc ZH, zero
001705 91d4                      	lpm r29, Z
                                 
                                 volume_mixer_output:
001706 0fcd                      	add r28, r29
001707 b9c1                      	out VPORTA_OUT, r28
001708 cfb7                      	rjmp volume_mixer
                                 
                                 
                                 
                                 //FRAME COUNTER/AUDIO SAMPLE ISR
                                 sequence_0_2:
001709 b7bf                      	in r27, CPU_SREG
00170a 93bf                      	push r27
00170b 94f8                      	cli
                                 
                                 	//ENVELOPE
00170c d053                      	rcall pulse1_envelope_routine
00170d d09f                      	rcall pulse2_envelope_routine
                                 
00170e e5b0                      	ldi r27, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP2_bm //clear OVF flag
00170f 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
001711 91bf                      	pop r27
001712 bfbf                      	out CPU_SREG, r27
001713 9518                      	reti
                                 
                                 sequence_1_3:
001714 b7bf                      	in r27, CPU_SREG
001715 93bf                      	push r27
001716 94f8                      	cli
                                 
                                 	//ENVELOPE
001717 d048                      	rcall pulse1_envelope_routine
001718 d094                      	rcall pulse2_envelope_routine
                                 
                                 	//SWEEP
001719 fcc3                      	sbrc pulse1_sweep, 3 //check if the sweep enable bit is cleared
00171a d01b                      	rcall pulse1_sweep_routine
00171b fcf3                      	sbrc pulse2_sweep, 3
00171c d066                      	rcall pulse2_sweep_routine
                                 
                                 	//LENGTH
                                 	//NOTE: The length routine is relatively simple, so we will not be using clocks to rjmp and ret to a seperate lable
                                 sequence_1_3_pulse1_length:
00171d fd95                      	sbrc pulse_channel_flags, 5 //check if the length counter halt bit is cleared
00171e c002                      	rjmp sequence_1_3_pulse2_length
00171f 10b2                      	cpse pulse1_length_counter, zero //if length counter is already 0, don't decrement
001720 94ba                      	dec pulse1_length_counter
                                 sequence_1_3_pulse2_length:
001721 fd91                      	sbrc pulse_channel_flags, 1 //check if the length counter halt bit is cleared
001722 c002                      	rjmp sequence_1_3_exit
001723 10e2                      	cpse pulse2_length_counter, zero //if length counter is already 0, don't decrement
001724 94ea                      	dec pulse2_length_counter
                                 
                                 sequence_1_3_exit:
001725 e2b1                      	ldi r27, TCA_SINGLE_CMP1_bm | TCA_SINGLE_OVF_bm //clear OVF flag
001726 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
001728 91bf                      	pop r27
001729 bfbf                      	out CPU_SREG, r27
00172a 9518                      	reti
                                 
                                 //PULSE 1 ROUTINES
                                 pulse1_sequence_routine:
00172b b7bf                      	in r27, CPU_SREG
00172c 93bf                      	push r27
00172d 94f8                      	cli
                                 
00172e 0caa                      	lsl pulse1_sequence //shifts sequence to the left
00172f 1ca2                      	adc pulse1_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
001730 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
001731 93b0 0a86                 	sts TCB0_INTFLAGS, r27
001733 91bf                      	pop r27
001734 bfbf                      	out CPU_SREG, r27
001735 9518                      	reti
                                 
                                 pulse1_sweep_routine:
001736 2dbc                      	mov r27, pulse1_sweep
001737 70b7                      	andi r27, 0x07 //mask for period divider bits
001738 f4f9                      	brne pulse1_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse1_sweep_routine_action: //if the divider is == 0, update the pulse timer period
001739 93df                      	push r29
00173a 2ddc                      	mov r29, pulse1_sweep
00173b 95d2                      	swap r29
00173c 70d7                      	andi r29, 0x07 //mask for shift bits
00173d f411                      	brne pulse1_sweep_routine_action_main //shift != 0
00173e 91df                      	pop r29
00173f c019                      	rjmp pulse1_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse1_sweep_routine_action_main:
001740 91a0 0a8c                 	lds r26, TCB0_CCMPL
001742 91b0 0a8d                 	lds r27, TCB0_CCMPH
                                 pulse1_sweep_routine_action_main_loop:
001744 95b6                      	lsr r27
001745 95a7                      	ror r26
001746 95da                      	dec r29
001747 f7e1                      	brne pulse1_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
001748 fec7                      	sbrs pulse1_sweep, 7 //check the negate flag
001749 c002                      	rjmp pulse1_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
00174a 95a0                      	com r26 //pulse1 uses one's complement if the negate flag is set
00174b 95b0                      	com r27
                                 
                                 pulse1_sweep_routine_action_main_add:
00174c 91d0 0a8c                 	lds r29, TCB0_CCMPL //perform addition to get new timer period
00174e 0fad                      	add r26, r29
00174f 91d0 0a8d                 	lds r29, TCB0_CCMPH
001751 1fbd                      	adc r27, r29
                                 
001752 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new LOW bits for timer
001754 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new HIGH bits for timer
                                 	
001756 91df                      	pop r29
001757 c001                      	rjmp pulse1_sweep_routine_check_reload
                                 
                                 pulse1_sweep_routine_decrement_divider:
001758 94ca                      	dec pulse1_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse1_sweep_routine_check_reload:
001759 ff97                      	sbrs pulse_channel_flags, 7 //if the reload flag is set, reload the sweep divider
00175a 9508                      	ret
                                 
                                 pulse1_sweep_reload:
00175b 90c0 2801                 	lds pulse1_sweep, pulse1_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
00175d 94c2                      	swap pulse1_sweep //bring data from high byte to low byte
00175e 779f                      	cbr pulse_channel_flags, 0b10000000 //clear reload flag
00175f 9508                      	ret
                                 
                                 
                                 
                                 pulse1_envelope_routine:
001760 fd96                      	sbrc pulse_channel_flags, 6 //check if start flag is cleared
001761 c010                      	rjmp pulse1_envelope_routine_clear_start
                                 
001762 3000                      	cpi pulse1_volume_divider, 0x00 //check if the divider is 0
001763 f011                      	breq PC+3 //if the divider == 0, check loop flag
001764 950a                      	dec pulse1_volume_divider //if the divider != 0, decrement and return
001765 9508                      	ret
                                 
001766 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the divider == 0, reset the divider period
001768 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
001769 ff95                      	sbrs pulse_channel_flags, 5 //check if the loop flag is set
00176a c002                      	rjmp pulse1_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
00176b e01f                      	ldi pulse1_volume_decay, 0x0F //if the loop flag is set, reset decay and return
00176c 9508                      	ret
                                 
                                 pulse1_envelope_routine_decrement_decay:
00176d 3010                      	cpi pulse1_volume_decay, 0x00 //check if the decay is 0
00176e f409                      	brne PC+2 //if decay != 0, go decrement
00176f 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
001770 951a                      	dec pulse1_volume_decay
001771 9508                      	ret
                                 
                                 pulse1_envelope_routine_clear_start:
001772 7b9f                      	cbr pulse_channel_flags, 0b01000000 //if the start flag is set, clear it
001773 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the start flag is set, reset the divider period
001775 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
001776 e01f                      	ldi pulse1_volume_decay, 0x0F //if the start flag is set, reset decay
001777 9508                      	ret
                                 
                                 //PULSE 2 ROUTINES
                                 pulse2_sequence_routine:
001778 b7bf                      	in r27, CPU_SREG
001779 93bf                      	push r27
00177a 94f8                      	cli
                                 
00177b 0cdd                      	lsl pulse2_sequence //shifts sequence to the left
00177c 1cd2                      	adc pulse2_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
00177d e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
00177e 93b0 0a96                 	sts TCB1_INTFLAGS, r27
001780 91bf                      	pop r27
001781 bfbf                      	out CPU_SREG, r27
001782 9518                      	reti
                                 
                                 pulse2_sweep_routine:
001783 2dbf                      	mov r27, pulse2_sweep
001784 70b7                      	andi r27, 0x07 //mask for period divider bits
001785 f4f9                      	brne pulse2_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse2_sweep_routine_action: //if the divider is == 0, update the pulse timer period
001786 93df                      	push r29
001787 2ddf                      	mov r29, pulse2_sweep
001788 95d2                      	swap r29
001789 70d7                      	andi r29, 0x07 //mask for shift bits
00178a f411                      	brne pulse2_sweep_routine_action_main //shift != 0
00178b 91df                      	pop r29
00178c c019                      	rjmp pulse2_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse2_sweep_routine_action_main:
00178d 91a0 0a9c                 	lds r26, TCB1_CCMPL
00178f 91b0 0a9d                 	lds r27, TCB1_CCMPH
                                 pulse2_sweep_routine_action_main_loop:
001791 95b6                      	lsr r27
001792 95a7                      	ror r26
001793 95da                      	dec r29
001794 f7e1                      	brne pulse2_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
001795 fef7                      	sbrs pulse2_sweep, 7 //check the negate flag
001796 c002                      	rjmp pulse2_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
001797 95a0                      	com r26 //pulse2 uses one's complement if the negate flag is set
001798 95b0                      	com r27
                                 
                                 pulse2_sweep_routine_action_main_add:
001799 91d0 0a9c                 	lds r29, TCB1_CCMPL //perform addition to get new timer period
00179b 0fad                      	add r26, r29
00179c 91d0 0a9d                 	lds r29, TCB1_CCMPH
00179e 1fbd                      	adc r27, r29
                                 
00179f 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new LOW bits for timer
0017a1 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new HIGH bits for timer
                                 	
0017a3 91df                      	pop r29
0017a4 c001                      	rjmp pulse2_sweep_routine_check_reload
                                 
                                 pulse2_sweep_routine_decrement_divider:
0017a5 94fa                      	dec pulse2_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse2_sweep_routine_check_reload:
0017a6 ff93                      	sbrs pulse_channel_flags, 3 //if the reload flag is set, reload the sweep divider
0017a7 9508                      	ret
                                 
                                 pulse2_sweep_reload:
0017a8 90f0 2809                 	lds pulse2_sweep, pulse2_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
0017aa 94f2                      	swap pulse2_sweep //bring data from high byte to low byte
0017ab 7f97                      	cbr pulse_channel_flags, 0b00001000 //clear reload flag
0017ac 9508                      	ret
                                 
                                 
                                 
                                 pulse2_envelope_routine:
0017ad fd92                      	sbrc pulse_channel_flags, 2 //check if start flag is cleared
0017ae c010                      	rjmp pulse2_envelope_routine_clear_start
                                 
0017af 3020                      	cpi pulse2_volume_divider, 0x00 //check if the divider is 0
0017b0 f011                      	breq PC+3 //if the divider == 0, check loop flag
0017b1 952a                      	dec pulse2_volume_divider //if the divider != 0, decrement and return
0017b2 9508                      	ret
                                 
0017b3 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the divider == 0, reset the divider period
0017b5 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
0017b6 ff91                      	sbrs pulse_channel_flags, 1 //check if the loop flag is set
0017b7 c002                      	rjmp pulse2_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
0017b8 e03f                      	ldi pulse2_volume_decay, 0x0F //if the loop flag is set, reset decay and return
0017b9 9508                      	ret
                                 
                                 pulse2_envelope_routine_decrement_decay:
0017ba 3030                      	cpi pulse2_volume_decay, 0x00 //check if the decay is 0
0017bb f409                      	brne PC+2 //if decay != 0, go decrement
0017bc 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
0017bd 953a                      	dec pulse2_volume_decay
0017be 9508                      	ret
                                 
                                 pulse2_envelope_routine_clear_start:
0017bf 7f9b                      	cbr pulse_channel_flags, 0b00000100 //if the start flag is set, clear it
0017c0 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the start flag is set, reset the divider period
0017c2 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
0017c3 e03f                      	ldi pulse2_volume_decay, 0x0F //if the start flag is set, reset decay
0017c4 9508                      	ret
                                 
                                 //TRIANGLE ROUTINES
                                 triangle_sequence_routine:
0017c5 b7bf                      	in r27, CPU_SREG
0017c6 93bf                      	push r27
0017c7 94f8                      	cli
                                 
0017c8 5f4f                      	subi triangle_sequence, -1 //increment sequence by 1
0017c9 714f                      	andi triangle_sequence, 0b00011111 //mask out bits 5, 6 and 7 NOTE: the sequence only needs bits 0-4.
                                 
0017ca e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
0017cb 93b0 0aa6                 	sts TCB2_INTFLAGS, r27
0017cd 91bf                      	pop r27
0017ce bfbf                      	out CPU_SREG, r27
0017cf 9518                      	reti
                                 
                                 //NOISE ROUTINES
                                 noise_sequence_routine:
0017d0 b7bf                      	in r27, CPU_SREG
0017d1 93bf                      	push r27
0017d2 94f8                      	cli
                                 
0017d3 2fa5                      	mov r26, noise_sequence_LOW
0017d4 fd67                      	sbrc noise_sequence_HIGH, 7 //skip if MODE bit is clear
0017d5 c00b                      	rjmp noise_sequence_routine_mode_set
                                 
                                 noise_sequence_routine_mode_clear:
0017d6 95a6                      	lsr r26 //move the 1th bit to the 0th bit place
0017d7 27a5                      	eor r26, noise_sequence_LOW
0017d8 fda0                      	sbrc r26, 0 //skip if the EOR of bit 0 and 1 is clear
0017d9 c003                      	rjmp noise_sequence_routine_mode_clear_EOR_set
                                 
                                 noise_sequence_routine_mode_clear_EOR_clear:
0017da 9566                      	lsr noise_sequence_HIGH
0017db 9557                      	ror noise_sequence_LOW
0017dc c013                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_clear_EOR_set:
0017dd 9566                      	lsr noise_sequence_HIGH
0017de 9557                      	ror noise_sequence_LOW
0017df 6460                      	ori noise_sequence_HIGH, 0b01000000 //set the 14th bit
0017e0 c00f                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_set:
0017e1 0faa                      	lsl r26
0017e2 1faa                      	rol r26
0017e3 1faa                      	rol r26 //move the 6th bit to the 0th bit place
0017e4 27a5                      	eor r26, noise_sequence_LOW
0017e5 fda0                      	sbrc r26, 0 //skip if the EOR of bit 0 and 1 is clear
0017e6 c005                      	rjmp noise_sequence_routine_mode_set_EOR_set
                                 
                                 noise_sequence_routine_mode_set_EOR_clear:
0017e7 776f                      	cbr noise_sequence_HIGH, 0b10000000 //clear the MODE flag
0017e8 9566                      	lsr noise_sequence_HIGH
0017e9 9557                      	ror noise_sequence_LOW
0017ea 6860                      	sbr noise_sequence_HIGH, 0b10000000 //set the MODE flag
0017eb c004                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_set_EOR_set:
0017ec 9566                      	lsr noise_sequence_HIGH
0017ed 9557                      	ror noise_sequence_LOW
0017ee 6860                      	sbr noise_sequence_HIGH, 0b10000000 //set the MODE flag
0017ef c000                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_exit:
0017f0 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
0017f1 93b0 0ab6                 	sts TCB3_INTFLAGS, r27
0017f3 91bf                      	pop r27
0017f4 bfbf                      	out CPU_SREG, r27
0017f5 9518                      	reti
                                 
                                 //CONVERTERS
                                 //converts and loads 5 bit length to corresponding 8 bit length value into r29
                                 length_converter:
0017f6 e6ea                      	ldi ZL, LOW(length << 1)
0017f7 e6f4                      	ldi ZH, HIGH(length << 1)
0017f8 0fed                      	add ZL, r29
0017f9 1df2                      	adc ZH, zero
0017fa 91d4                      	lpm r29, Z
0017fb 9508                      	ret
                                 
                                 //loads pulse sequence into r29
                                 duty_cycle_sequences:
0017fc e8ea                      	ldi ZL, LOW(sequences << 1)
0017fd e6f4                      	ldi ZH, HIGH(sequences << 1)
0017fe 0fed                      	add ZL, r29
0017ff 1df2                      	adc ZH, zero
001800 91d4                      	lpm r29, Z
001801 9508                      	ret
                                 
                                 
                                 
                                 //SOUND DRIVER
                                 sound_driver:
001802 b7bf                      	in r27, CPU_SREG
001803 93bf                      	push r27
001804 94f8                      	cli
001805 93cf                      	push r28
001806 93df                      	push r29
001807 93ef                      	push r30
001808 93ff                      	push r31
                                 
                                 	//SOUND DRIVER
001809 91a0 281f                 	lds r26, song_fx_Bxx
00180b 3faf                      	cpi r26, 0xFF //0xFF means that the flag is disabled
00180c f4a9                      	brne sound_driver_fx_Bxx_routine
00180d 91a0 2820                 	lds r26, song_fx_Cxx
00180f 11a2                      	cpse r26, zero
001810 c08b                      	rjmp sound_driver_fx_Cxx_routine
001811 91a0 2821                 	lds r26, song_fx_Dxx
001813 11a2                      	cpse r26, zero
001814 c096                      	rjmp sound_driver_fx_Dxx_routine
                                 
001815 91a0 281a                 	lds r26, song_frame_offset
001817 91b0 281b                 	lds r27, song_frame_offset+1
001819 91c0 281c                 	lds r28, song_size
00181b 91d0 281d                 	lds r29, song_size+1
00181d 17ac                      	cp r26, r28
00181e 07bd                      	cpc r27, r29
00181f f408                      	brsh sound_driver_fx_song_loop
001820 c101                      	rjmp sound_driver_channel0
                                 
                                 
                                 sound_driver_fx_song_loop:
001821 e0a0                      	ldi r26, 0x00
                                 sound_driver_fx_Bxx_routine:
001822 91e0 2818                 	lds ZL, song_frames
001824 91f0 2819                 	lds ZH, song_frames+1
001826 27cc                      	clr r28 //initialize r29:r28 to 0
001827 27dd                      	clr r29
001828 95a3                      	inc r26 //increment xx parameter by 1
                                 sound_driver_fx_Bxx_routine_loop:
001829 95aa                      	dec r26
00182a f011                      	breq sound_driver_fx_Bxx_routine_loop_exit //once r26 == 0, r29:r28 will hold Bxx*(5*2).
00182b 962a                      	adiw r29:r28, 10 //increment the offset by 10 because 5 channels, and each address takes 2 bytes (5*2 = 10)
00182c cffc                      	rjmp sound_driver_fx_Bxx_routine_loop
                                 
                                 sound_driver_fx_Bxx_routine_loop_exit:
00182d 9622                      	adiw r29:r28, 2 //add 2 to skip the first 2 bytes (first 2 bytes is the song size)
00182e 93c0 281a                 	sts song_frame_offset, r28
001830 93d0 281b                 	sts song_frame_offset+1, r29
001832 0fec                      	add ZL, r28
001833 1ffd                      	adc ZH, r29
                                 
001834 91a5                      	lpm r26, Z+ //load the address of the frame(pattern)
001835 91b5                      	lpm r27, Z+
001836 0faa                      	lsl r26
001837 1fbb                      	rol r27
001838 93a0 2822                 	sts pulse1_pattern, r26
00183a 93b0 2823                 	sts pulse1_pattern+1, r27
00183c 91a5                      	lpm r26, Z+
00183d 91b5                      	lpm r27, Z+
00183e 0faa                      	lsl r26
00183f 1fbb                      	rol r27
001840 93a0 2871                 	sts pulse2_pattern, r26
001842 93b0 2872                 	sts pulse2_pattern+1, r27
001844 91a5                      	lpm r26, Z+
001845 91b5                      	lpm r27, Z+
001846 0faa                      	lsl r26
001847 1fbb                      	rol r27
001848 93a0 28c0                 	sts triangle_pattern, r26
00184a 93b0 28c1                 	sts triangle_pattern+1, r27
00184c 91a5                      	lpm r26, Z+
00184d 91b5                      	lpm r27, Z+
00184e 0faa                      	lsl r26
00184f 1fbb                      	rol r27
001850 93a0 290a                 	sts noise_pattern, r26
001852 93b0 290b                 	sts noise_pattern+1, r27
                                 
001854 9220 2826                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001856 9220 2827                 	sts pulse1_pattern_offset+1, zero
001858 9220 2824                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
00185a 9220 2825                 	sts pulse1_pattern_delay_frames, zero
00185c 9220 2875                 	sts pulse2_pattern_offset, zero
00185e 9220 2876                 	sts pulse2_pattern_offset+1, zero
001860 9220 2873                 	sts pulse2_pattern_delay_rows, zero
001862 9220 2874                 	sts pulse2_pattern_delay_frames, zero
001864 9220 28c4                 	sts triangle_pattern_offset, zero
001866 9220 28c5                 	sts triangle_pattern_offset+1, zero
001868 9220 28c2                 	sts triangle_pattern_delay_rows, zero
00186a 9220 28c3                 	sts triangle_pattern_delay_frames, zero
00186c 9220 290e                 	sts noise_pattern_offset, zero
00186e 9220 290f                 	sts noise_pattern_offset+1, zero
001870 9220 290c                 	sts noise_pattern_delay_rows, zero
001872 9220 290d                 	sts noise_pattern_delay_frames, zero
                                 
001874 efaf                      	ldi r26, 0xFF
001875 93a0 285f                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
001877 93a0 2860                 	sts pulse1_fx_Gxx_post, r26
001879 93a0 286f                 	sts pulse1_fx_Sxx_pre, r26
00187b 93a0 2870                 	sts pulse1_fx_Sxx_post, r26
00187d 93a0 28ae                 	sts pulse2_fx_Gxx_pre, r26
00187f 93a0 28af                 	sts pulse2_fx_Gxx_post, r26
001881 93a0 28be                 	sts pulse2_fx_Sxx_pre, r26
001883 93a0 28bf                 	sts pulse2_fx_Sxx_post, r26
001885 93a0 28f8                 	sts triangle_fx_Gxx_pre, r26
001887 93a0 28f9                 	sts triangle_fx_Gxx_post, r26
001889 93a0 2908                 	sts triangle_fx_Sxx_pre, r26
00188b 93a0 2909                 	sts triangle_fx_Sxx_post, r26
00188d 93a0 2947                 	sts noise_fx_Gxx_pre, r26
00188f 93a0 2948                 	sts noise_fx_Gxx_post, r26
001891 93a0 2957                 	sts noise_fx_Sxx_pre, r26
001893 93a0 2958                 	sts noise_fx_Sxx_post, r26
                                 
001895 93a0 281f                 	sts song_fx_Bxx, r26 //reset all song effects
001897 9220 2820                 	sts song_fx_Cxx, zero
001899 9220 2821                 	sts song_fx_Dxx, zero
00189b c086                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_fx_Cxx_routine:
00189c 91ff                      	pop r31
00189d 91ef                      	pop r30
00189e 91df                      	pop r29
00189f 91cf                      	pop r28
0018a0 91bf                      	pop r27
0018a1 bfbf                      	out CPU_SREG, r27
0018a2 94f8                      	cli //disable global interrupts
                                 		
0018a3 efaf                      	ldi r26, 0xFF
0018a4 93a0 281f                 	sts song_fx_Bxx, r26 //reset all song effects
0018a6 9220 2820                 	sts song_fx_Cxx, zero
0018a8 9220 2821                 	sts song_fx_Dxx, zero
0018aa 9518                      	reti
                                 
                                 sound_driver_fx_Dxx_routine:
0018ab 91e0 2818                 	lds ZL, song_frames
0018ad 91f0 2819                 	lds ZH, song_frames+1
0018af 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
0018b1 91b0 281b                 	lds r27, song_frame_offset+1
0018b3 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
0018b4 93a0 281a                 	sts song_frame_offset, r26
0018b6 93b0 281b                 	sts song_frame_offset+1, r27
0018b8 0fea                      	add ZL, r26
0018b9 1ffb                      	adc ZH, r27
                                 
0018ba 91a5                      	lpm r26, Z+ //load the address of the next pattern
0018bb 91b5                      	lpm r27, Z+
0018bc 0faa                      	lsl r26
0018bd 1fbb                      	rol r27
0018be 93a0 2822                 	sts pulse1_pattern, r26
0018c0 93b0 2823                 	sts pulse1_pattern+1, r27
0018c2 91a5                      	lpm r26, Z+
0018c3 91b5                      	lpm r27, Z+
0018c4 0faa                      	lsl r26
0018c5 1fbb                      	rol r27
0018c6 93a0 2871                 	sts pulse2_pattern, r26
0018c8 93b0 2872                 	sts pulse2_pattern+1, r27
0018ca 91a5                      	lpm r26, Z+
0018cb 91b5                      	lpm r27, Z+
0018cc 0faa                      	lsl r26
0018cd 1fbb                      	rol r27
0018ce 93a0 28c0                 	sts triangle_pattern, r26
0018d0 93b0 28c1                 	sts triangle_pattern+1, r27
0018d2 91a5                      	lpm r26, Z+
0018d3 91b5                      	lpm r27, Z+
0018d4 0faa                      	lsl r26
0018d5 1fbb                      	rol r27
0018d6 93a0 290a                 	sts noise_pattern, r26
0018d8 93b0 290b                 	sts noise_pattern+1, r27
                                 
0018da 9220 2826                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
0018dc 9220 2827                 	sts pulse1_pattern_offset+1, zero
0018de 9220 2824                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
0018e0 9220 2825                 	sts pulse1_pattern_delay_frames, zero
0018e2 9220 2875                 	sts pulse2_pattern_offset, zero
0018e4 9220 2876                 	sts pulse2_pattern_offset+1, zero
0018e6 9220 2873                 	sts pulse2_pattern_delay_rows, zero
0018e8 9220 2874                 	sts pulse2_pattern_delay_frames, zero
0018ea 9220 28c4                 	sts triangle_pattern_offset, zero
0018ec 9220 28c5                 	sts triangle_pattern_offset+1, zero
0018ee 9220 28c2                 	sts triangle_pattern_delay_rows, zero
0018f0 9220 28c3                 	sts triangle_pattern_delay_frames, zero
0018f2 9220 290e                 	sts noise_pattern_offset, zero
0018f4 9220 290f                 	sts noise_pattern_offset+1, zero
0018f6 9220 290c                 	sts noise_pattern_delay_rows, zero
0018f8 9220 290d                 	sts noise_pattern_delay_frames, zero
                                 
0018fa efaf                      	ldi r26, 0xFF
0018fb 93a0 285f                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
0018fd 93a0 2860                 	sts pulse1_fx_Gxx_post, r26
0018ff 93a0 286f                 	sts pulse1_fx_Sxx_pre, r26
001901 93a0 2870                 	sts pulse1_fx_Sxx_post, r26
001903 93a0 28ae                 	sts pulse2_fx_Gxx_pre, r26
001905 93a0 28af                 	sts pulse2_fx_Gxx_post, r26
001907 93a0 28be                 	sts pulse2_fx_Sxx_pre, r26
001909 93a0 28bf                 	sts pulse2_fx_Sxx_post, r26
00190b 93a0 28f8                 	sts triangle_fx_Gxx_pre, r26
00190d 93a0 28f9                 	sts triangle_fx_Gxx_post, r26
00190f 93a0 2908                 	sts triangle_fx_Sxx_pre, r26
001911 93a0 2909                 	sts triangle_fx_Sxx_post, r26
001913 93a0 2947                 	sts noise_fx_Gxx_pre, r26
001915 93a0 2948                 	sts noise_fx_Gxx_post, r26
001917 93a0 2957                 	sts noise_fx_Sxx_pre, r26
001919 93a0 2958                 	sts noise_fx_Sxx_post, r26
                                 
00191b 93a0 281f                 	sts song_fx_Bxx, r26 //reset all song effects
00191d 9220 2820                 	sts song_fx_Cxx, zero
00191f 9220 2821                 	sts song_fx_Dxx, zero
001921 c000                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0:
001922 91a0 2824                 	lds r26, pulse1_pattern_delay_rows
001924 91b0 2825                 	lds r27, pulse1_pattern_delay_frames
001926 9610                      	adiw r27:r26, 0
001927 f009                      	breq sound_driver_channel0_main //if the pattern delay is 0, proceed with sound driver procedures
001928 c2d7                      	rjmp sound_driver_channel0_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel0_main:
001929 91e0 2822                 	lds ZL, pulse1_pattern //current pattern for pulse 1
00192b 91f0 2823                 	lds ZH, pulse1_pattern+1
00192d 91a0 2826                 	lds r26, pulse1_pattern_offset //current offset in the pattern for pulse 1
00192f 91b0 2827                 	lds r27, pulse1_pattern_offset+1
001931 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001932 1ffb                      	adc ZH, r27
001933 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel0_check_if_note: //check if data is a note (0x00 - 0x56)
001934 35b7                      	cpi r27, 0x57
001935 f408                      	brsh sound_driver_channel0_check_if_volume
001936 c17c                      	rjmp sound_driver_channel0_note
                                 sound_driver_channel0_check_if_volume: //check if data is volume (0x57-0x66)
001937 36b7                      	cpi r27, 0x67
001938 f408                      	brsh sound_driver_channel0_check_if_delay
001939 c1b6                      	rjmp sound_driver_channel0_volume
                                 sound_driver_channel0_check_if_delay: //check if data is a delay (0x67 - 0xE2)
00193a 3eb3                      	cpi r27, 0xE3
00193b f408                      	brsh sound_driver_channel0_check_if_instrument
00193c c1bd                      	rjmp sound_driver_channel0_delay
                                 sound_driver_channel0_check_if_instrument: //check for instrument flag (0xE3)
00193d f409                      	brne sound_driver_channel0_check_if_release
00193e c1c0                      	rjmp sound_driver_channel0_instrument_change 
                                 sound_driver_channel0_check_if_release: //check for note release flag (0xE4)
00193f 3eb4                      	cpi r27, 0xE4
001940 f409                      	brne sound_driver_channel0_check_if_end
001941 c269                      	rjmp sound_driver_channel0_release
                                 sound_driver_channel0_check_if_end:
001942 3fbf                      	cpi r27, 0xFF
001943 f409                      	brne sound_driver_channel0_check_if_fx
001944 c28b                      	rjmp sound_driver_channel0_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel0_check_if_fx: //fx flags (0xE5 - 0xFE)
001945 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001946 91a4                      	lpm r26, Z //load the fx data into r26
001947 d2ae                      	rcall sound_driver_channel0_increment_offset_twice
                                 
001948 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001949 e8ee                      	ldi ZL, LOW(channel0_fx << 1) //load in note table
00194a e6f4                      	ldi ZH, HIGH(channel0_fx << 1)
00194b 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
00194c 0feb                      	add ZL, r27 //add offset
00194d 1df2                      	adc ZH, zero
00194e 91c5                      	lpm r28, Z+ //load address bytes
00194f 91d4                      	lpm r29, Z
001950 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001951 2ffd                      	mov ZH, r29
001952 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel0_fx_0xy:
001953 93a0 2845                 	sts pulse1_fx_0xy_sequence, r26
001955 9220 2846                 	sts pulse1_fx_0xy_sequence+1, zero
001957 cfd1                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel0_fx_1xx:
001958 9220 284b                 	sts pulse1_fx_2xx, zero //turn off any 2xx pitch slide down
00195a 9220 284c                 	sts pulse1_fx_2xx+1, zero
00195c 9220 2845                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
00195e 9220 2846                 	sts pulse1_fx_0xy_sequence+1, zero
001960 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001961 937f                      	push r23
001962 2f6a                      	mov r22, r26 //store the rate into r22
001963 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001964 9f67                      	mul r22, r23
001965 917f                      	pop r23
001966 916f                      	pop r22
                                 
001967 9416                      	lsr r1 //shift out the fractional bits
001968 9407                      	ror r0
001969 9416                      	lsr r1
00196a 9407                      	ror r0
00196b 9416                      	lsr r1
00196c 9407                      	ror r0
00196d 9416                      	lsr r1
00196e 9407                      	ror r0
00196f 9200 2847                 	sts pulse1_fx_1xx, r0
001971 9210 2848                 	sts pulse1_fx_1xx+1, r1
001973 cfb5                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel0_fx_2xx:
001974 9220 2847                 	sts pulse1_fx_1xx, zero //turn off any 1xx pitch slide down
001976 9220 2848                 	sts pulse1_fx_1xx+1, zero
001978 9220 2845                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
00197a 9220 2846                 	sts pulse1_fx_0xy_sequence+1, zero
00197c 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00197d 937f                      	push r23
00197e 2f6a                      	mov r22, r26 //store the rate into r22
00197f eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001980 9f67                      	mul r22, r23
001981 917f                      	pop r23
001982 916f                      	pop r22
                                 
001983 9416                      	lsr r1 //shift out the fractional bits
001984 9407                      	ror r0
001985 9416                      	lsr r1
001986 9407                      	ror r0
001987 9416                      	lsr r1
001988 9407                      	ror r0
001989 9416                      	lsr r1
00198a 9407                      	ror r0
00198b 9200 284b                 	sts pulse1_fx_2xx, r0
00198d 9210 284c                 	sts pulse1_fx_2xx+1, r1
00198f cf99                      	rjmp sound_driver_channel0_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel0_fx_3xx:
001990 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001991 937f                      	push r23
001992 2f6a                      	mov r22, r26 //store the rate into r22
001993 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001994 9f67                      	mul r22, r23
001995 917f                      	pop r23
001996 916f                      	pop r22
                                 
001997 9416                      	lsr r1 //shift out the fractional bits
001998 9407                      	ror r0
001999 9416                      	lsr r1
00199a 9407                      	ror r0
00199b 9416                      	lsr r1
00199c 9407                      	ror r0
00199d 9416                      	lsr r1
00199e 9407                      	ror r0
00199f 9200 2853                 	sts pulse1_fx_3xx_speed, r0
0019a1 9210 2854                 	sts pulse1_fx_3xx_speed+1, r1
                                 
0019a3 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
0019a4 c001                      	rjmp sound_driver_channel0_fx_3xx_enabled
0019a5 cf83                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_3xx_enabled:
0019a6 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
0019a8 91b0 0a8d                 	lds r27, TCB0_CCMPH
0019aa 93a0 284f                 	sts pulse1_fx_3xx_start, r26
0019ac 93b0 2850                 	sts pulse1_fx_3xx_start+1, r27
                                 
0019ae 9220 2855                 	sts pulse1_fx_3xx_total_offset, zero
0019b0 9220 2856                 	sts pulse1_fx_3xx_total_offset+1, zero
0019b2 cf76                      	rjmp sound_driver_channel0_main
                                 
                                 //VIBRATO
                                 sound_driver_channel0_fx_4xy:
0019b3 2fba                      	mov r27, r26
0019b4 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
0019b5 95a2                      	swap r26
0019b6 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0019b7 93a0 2857                 	sts pulse1_fx_4xy_speed, r26
0019b9 93b0 2858                 	sts pulse1_fx_4xy_depth, r27
0019bb 9220 2859                 	sts pulse1_fx_4xy_phase, zero //reset the phase to 0
0019bd cf6b                      	rjmp sound_driver_channel0_main
                                 
                                 //TREMELO
                                 sound_driver_channel0_fx_7xy:
0019be 2fba                      	mov r27, r26
0019bf 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
0019c0 95a2                      	swap r26
0019c1 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0019c2 93a0 285a                 	sts pulse1_fx_7xy_speed, r26
0019c4 93b0 285b                 	sts pulse1_fx_7xy_depth, r27
0019c6 9220 285c                 	sts pulse1_fx_7xy_phase, zero //reset the phase to 0
0019c8 9220 285d                 	sts pulse1_fx_7xy_value, zero //reset the tremelo value
0019ca cf5e                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel0_fx_Axy:
0019cb 93a0 285e                 	sts pulse1_fx_Axy, r26
0019cd cf5b                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel0_fx_Bxx:
0019ce 93a0 281f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
0019d0 cf58                      	rjmp sound_driver_channel0_main
                                 
                                 //HALT
                                 sound_driver_channel0_fx_Cxx:
0019d1 93b0 2820                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
0019d3 cf55                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel0_fx_Dxx:
0019d4 93b0 2821                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
0019d6 cf52                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME
                                 sound_driver_channel0_fx_Exx:
0019d7 91b0 2800                 	lds r27, pulse1_param
0019d9 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
0019da 2bba                      	or r27, r26 //move new VVVV bits into pulse1_param
0019db 93b0 2800                 	sts pulse1_param, r27
0019dd 6096                      	sbr pulse_channel_flags, 6
0019de cf4a                      	rjmp sound_driver_channel0_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel0_fx_Fxx:
0019df 93a0 281e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
0019e1 cf47                      	rjmp sound_driver_channel0_main
                                 
                                 //DELAY
                                 sound_driver_channel0_fx_Gxx:
0019e2 15a2                      	cp r26, zero
0019e3 f051                      	breq sound_driver_channel0_fx_Gxx_invalid
0019e4 91b0 281e                 	lds r27, song_speed
0019e6 17ab                      	cp r26, r27
0019e7 f430                      	brsh sound_driver_channel0_fx_Gxx_invalid
0019e8 93a0 285f                 	sts pulse1_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
0019ea e0b1                      	ldi r27, 0x01
0019eb 93b0 2824                 	sts pulse1_pattern_delay_rows, r27
0019ed c215                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Gxx_invalid:
0019ee cf3a                      	rjmp sound_driver_channel0_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel0_fx_Hxy: //hardware sweep up
0019ef cf39                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixy: //hardware sweep down
0019f0 cf38                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Hxx: //FDS modulation depth
0019f1 cf37                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixx: //FDS modulation speed
0019f2 cf36                      	rjmp sound_driver_channel0_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel0_fx_Pxx:
0019f3 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0019f4 937f                      	push r23
0019f5 2f6a                      	mov r22, r26
0019f6 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0019f7 9f67                      	mul r22, r23
0019f8 917f                      	pop r23
0019f9 916f                      	pop r22
0019fa 9416                      	lsr r1 //shift out the fractional bits
0019fb 9407                      	ror r0
0019fc 9416                      	lsr r1
0019fd 9407                      	ror r0
0019fe 9416                      	lsr r1
0019ff 9407                      	ror r0
001a00 9416                      	lsr r1
001a01 9407                      	ror r0
001a02 9200 2861                 	sts pulse1_fx_Pxx_total, r0
001a04 9210 2862                 	sts pulse1_fx_Pxx_total+1, r1
001a06 cf22                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel0_fx_Qxy:
                                 sound_driver_channel0_fx_Qxy_check_arpeggio_macro:
001a07 91e0 282d                 	lds ZL, pulse1_arpeggio_macro
001a09 91f0 282e                 	lds ZH, pulse1_arpeggio_macro+1
001a0b 9630                      	adiw Z, 0
001a0c f009                      	breq sound_driver_channel0_fx_Qxy_check_pitch_macro
001a0d cf1b                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_pitch_macro:
001a0e 91e0 2835                 	lds ZL, pulse1_pitch_macro
001a10 91f0 2836                 	lds ZH, pulse1_pitch_macro+1
001a12 9630                      	adiw Z, 0
001a13 f009                      	breq sound_driver_channel0_fx_Qxy_check_hi_pitch_macro
001a14 cf14                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_hi_pitch_macro:
001a15 91e0 283b                 	lds ZL, pulse1_hi_pitch_macro
001a17 91f0 283c                 	lds ZH, pulse1_hi_pitch_macro+1
001a19 9630                      	adiw Z, 0
001a1a f009                      	breq sound_driver_channel0_fx_Qxy_process
001a1b cf0d                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_process:
001a1c 2fba                      	mov r27, r26 //copy fx parameters into r27
001a1d 70bf                      	andi r27, 0x0F //mask note index offset
001a1e 91c0 2807                 	lds r28, pulse1_note //load current note index
001a20 0fbc                      	add r27, r28
001a21 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001a22 f008                      	brlo sound_driver_channel0_fx_Qxy_process_continue
001a23 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel0_fx_Qxy_process_continue:
001a24 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001a25 e0f0                      	ldi ZH, HIGH(note_table << 1)
001a26 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001a27 0feb                      	add ZL, r27 //add offset
001a28 1df2                      	adc ZH, zero
001a29 91c5                      	lpm r28, Z+ //load bytes
001a2a 91d4                      	lpm r29, Z
001a2b 93c0 2863                 	sts pulse1_fx_Qxy_target, r28 //load the LOW bits for the target period
001a2d 93d0 2864                 	sts pulse1_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
001a2f 95a2                      	swap r26
001a30 70af                      	andi r26, 0x0F //mask effect speed
001a31 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001a32 95a3                      	inc r26 //increment the speed by 1
                                 
001a33 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001a34 937f                      	push r23
001a35 2f6a                      	mov r22, r26 //store the speed data into r27
001a36 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001a37 9f67                      	mul r22, r23
001a38 917f                      	pop r23
001a39 916f                      	pop r22
                                 
001a3a 9416                      	lsr r1 //shift out the fractional bits
001a3b 9407                      	ror r0
001a3c 9416                      	lsr r1
001a3d 9407                      	ror r0
001a3e 9416                      	lsr r1
001a3f 9407                      	ror r0
001a40 9416                      	lsr r1
001a41 9407                      	ror r0
                                 
001a42 9200 2865                 	sts pulse1_fx_Qxy_speed, r0 //store the effect speed
001a44 9210 2866                 	sts pulse1_fx_Qxy_speed+1, r1
001a46 9220 2867                 	sts pulse1_fx_Qxy_total_offset, zero
001a48 9220 2868                 	sts pulse1_fx_Qxy_total_offset+1, zero
001a4a cede                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel0_fx_Rxy:
                                 sound_driver_channel0_fx_Rxy_check_arpeggio_macro:
001a4b 91e0 282d                 	lds ZL, pulse1_arpeggio_macro
001a4d 91f0 282e                 	lds ZH, pulse1_arpeggio_macro+1
001a4f 9630                      	adiw Z, 0
001a50 f009                      	breq sound_driver_channel0_fx_Rxy_check_pitch_macro
001a51 ced7                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_pitch_macro:
001a52 91e0 2835                 	lds ZL, pulse1_pitch_macro
001a54 91f0 2836                 	lds ZH, pulse1_pitch_macro+1
001a56 9630                      	adiw Z, 0
001a57 f009                      	breq sound_driver_channel0_fx_Rxy_check_hi_pitch_macro
001a58 ced0                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_hi_pitch_macro:
001a59 91e0 283b                 	lds ZL, pulse1_hi_pitch_macro
001a5b 91f0 283c                 	lds ZH, pulse1_hi_pitch_macro+1
001a5d 9630                      	adiw Z, 0
001a5e f009                      	breq sound_driver_channel0_fx_Rxy_process
001a5f cec9                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_process:
001a60 2fba                      	mov r27, r26 //copy fx parameters into r27
001a61 70bf                      	andi r27, 0x0F //mask note index offset
001a62 91c0 2807                 	lds r28, pulse1_note //load current note index
001a64 1bcb                      	sub r28, r27
001a65 f408                      	brcc sound_driver_channel0_fx_Rxy_process_continue
001a66 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel0_fx_Rxy_process_continue:
001a67 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001a68 e0f0                      	ldi ZH, HIGH(note_table << 1)
001a69 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001a6a 0fec                      	add ZL, r28 //add offset
001a6b 1df2                      	adc ZH, zero
001a6c 91c5                      	lpm r28, Z+ //load bytes
001a6d 91d4                      	lpm r29, Z
001a6e 93c0 2869                 	sts pulse1_fx_Rxy_target, r28 //load the LOW bits for the target period
001a70 93d0 286a                 	sts pulse1_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
001a72 95a2                      	swap r26
001a73 70af                      	andi r26, 0x0F //mask effect speed
001a74 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001a75 95a3                      	inc r26 //increment the speed by 1
                                 
001a76 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001a77 937f                      	push r23
001a78 2f6a                      	mov r22, r26 //store the speed data into r27
001a79 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001a7a 9f67                      	mul r22, r23
001a7b 917f                      	pop r23
001a7c 916f                      	pop r22
                                 
001a7d 9416                      	lsr r1 //shift out the fractional bits
001a7e 9407                      	ror r0
001a7f 9416                      	lsr r1
001a80 9407                      	ror r0
001a81 9416                      	lsr r1
001a82 9407                      	ror r0
001a83 9416                      	lsr r1
001a84 9407                      	ror r0
                                 
001a85 9200 286b                 	sts pulse1_fx_Rxy_speed, r0 //store the effect speed
001a87 9210 286c                 	sts pulse1_fx_Rxy_speed+1, r1
001a89 9220 286d                 	sts pulse1_fx_Rxy_total_offset, zero
001a8b 9220 286e                 	sts pulse1_fx_Rxy_total_offset+1, zero
001a8d ce9b                      	rjmp sound_driver_channel0_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel0_fx_Sxx:
001a8e 15a2                      	cp r26, zero
001a8f f051                      	breq sound_driver_channel0_fx_Sxx_invalid
001a90 91b0 281e                 	lds r27, song_speed
001a92 17ab                      	cp r26, r27
001a93 f430                      	brsh sound_driver_channel0_fx_Sxx_invalid
001a94 93a0 286f                 	sts pulse1_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001a96 e0b1                      	ldi r27, 0x01
001a97 93b0 2824                 	sts pulse1_pattern_delay_rows, r27
001a99 c169                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Sxx_invalid:
001a9a ce8e                      	rjmp sound_driver_channel0_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel0_fx_Vxx:
001a9b e8ea                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
001a9c e6f4                      	ldi ZH, HIGH(sequences << 1)
001a9d 0fea                      	add ZL, r26 //offset the pointer
001a9e 1df2                      	adc ZH, zero
                                 
001a9f 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
001aa0 95a7                      	ror r26
001aa1 95a7                      	ror r26
001aa2 91b0 2800                 	lds r27, pulse1_param //load r27 with pulse1_param (register $4000)
001aa4 2fcb                      	mov r28, r27 //store a copy of pulse1_param into r28
001aa5 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
001aa6 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
001aa7 c001                      	rjmp sound_driver_channel0_fx_Vxx_store
001aa8 ce80                      	rjmp sound_driver_channel0_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel0_fx_Vxx_store:
001aa9 90a4                      	lpm pulse1_sequence, Z //store the sequence
                                 
001aaa 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
001aab 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
001aac 93c0 2800                 	sts pulse1_param, r28
001aae ce7a                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_Wxx: //DPCM sample speed
001aaf ce79                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Xxx: //DPCM sample retrigger
001ab0 ce78                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Yxx: //DPCM sample offset
001ab1 ce77                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Zxx: //DPCM sample delta counter
001ab2 ce76                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 sound_driver_channel0_note:
001ab3 93b0 2807                 	sts pulse1_note, r27 //store the note index
001ab5 e0a3                      	ldi r26, 0x03
001ab6 e0b2                      	ldi r27, 0x02
001ab7 93b0 282a                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
001ab9 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26
001abb 93b0 2837                 	sts pulse1_pitch_macro_offset, r27
001abd 93b0 283d                 	sts pulse1_hi_pitch_macro_offset, r27
001abf 93b0 2842                 	sts pulse1_duty_macro_offset, r27
001ac1 9220 2833                 	sts pulse1_total_pitch_offset, zero //reset the pitch and hi pitch offset
001ac3 9220 2834                 	sts pulse1_total_pitch_offset+1, zero
001ac5 9220 283a                 	sts pulse1_total_hi_pitch_offset, zero
001ac7 9220 2849                 	sts pulse1_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001ac9 9220 284a                 	sts pulse1_fx_1xx_total+1, zero
001acb 9220 284d                 	sts pulse1_fx_2xx_total, zero
001acd 9220 284e                 	sts pulse1_fx_2xx_total+1, zero
001acf 9220 2855                 	sts pulse1_fx_3xx_total_offset, zero //reset 3xx offset
001ad1 9220 2856                 	sts pulse1_fx_3xx_total_offset+1, zero
001ad3 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001ad5 91b0 0a8d                 	lds r27, TCB0_CCMPH
001ad7 93a0 284f                 	sts pulse1_fx_3xx_start, r26
001ad9 93b0 2850                 	sts pulse1_fx_3xx_start+1, r27
001adb 9220 2801                 	sts pulse1_sweep_param, zero //reset any sweep effect
001add 6097                      	sbr pulse_channel_flags, 7 //set reload flag
001ade 9220 2863                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001ae0 9220 2864                 	sts pulse1_fx_Qxy_target+1, zero
001ae2 9220 2867                 	sts pulse1_fx_Qxy_total_offset, zero
001ae4 9220 2868                 	sts pulse1_fx_Qxy_total_offset+1, zero
001ae6 9220 2869                 	sts pulse1_fx_Rxy_target, zero
001ae8 9220 286a                 	sts pulse1_fx_Rxy_target+1, zero
001aea 9220 286d                 	sts pulse1_fx_Rxy_total_offset, zero
001aec 9220 286e                 	sts pulse1_fx_Rxy_total_offset+1, zero
001aee d0fd                      	rcall sound_driver_channel0_increment_offset
001aef ce39                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_volume:
001af0 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001af1 91a0 2800                 	lds r26, pulse1_param
001af3 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001af4 2bab                      	or r26, r27 //move new VVVV bits into pulse1_param
001af5 93a0 2800                 	sts pulse1_param, r26
001af7 6096                      	sbr pulse_channel_flags, 6
001af8 d0f3                      	rcall sound_driver_channel0_increment_offset
001af9 ce2f                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_delay:
001afa 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001afb 93b0 2824                 	sts pulse1_pattern_delay_rows, r27
001afd d0ee                      	rcall sound_driver_channel0_increment_offset
001afe c104                      	rjmp sound_driver_channel1
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change:
001aff 9220 2828                 	sts pulse1_volume_macro, zero //reset all macro addresses
001b01 9220 2829                 	sts pulse1_volume_macro+1, zero
001b03 9220 282d                 	sts pulse1_arpeggio_macro, zero
001b05 9220 282e                 	sts pulse1_arpeggio_macro+1, zero
001b07 9220 2835                 	sts pulse1_pitch_macro, zero
001b09 9220 2836                 	sts pulse1_pitch_macro+1, zero
001b0b 9220 283b                 	sts pulse1_hi_pitch_macro, zero
001b0d 9220 283c                 	sts pulse1_hi_pitch_macro+1, zero
001b0f 9220 2840                 	sts pulse1_duty_macro, zero
001b11 9220 2841                 	sts pulse1_duty_macro+1, zero
001b13 9220 2833                 	sts pulse1_total_pitch_offset, zero //reset the pitch offset
001b15 9220 2834                 	sts pulse1_total_pitch_offset+1, zero
001b17 9220 283a                 	sts pulse1_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001b19 9631                      	adiw Z, 1 //point to the byte next to the flag
001b1a 91b4                      	lpm r27, Z //store the instrument offset into r27
001b1b e3eb                      	ldi ZL, LOW(instruments) //point Z to instruments table
001b1c e1f1                      	ldi ZH, HIGH(instruments)
001b1d 0feb                      	add ZL, r27 //point Z to offsetted instrument
001b1e 1df2                      	adc ZH, zero
001b1f 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001b20 1fff                      	rol ZH
001b21 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001b22 91b4                      	lpm r27, Z
                                 
001b23 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001b24 1fbb                      	rol r27
001b25 2fea                      	mov ZL, r26
001b26 2ffb                      	mov ZH, r27
001b27 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001b28 9632                      	adiw Z, 2 //point Z to the address of the macro
001b29 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel0_instrument_change_macro_loop:
001b2a 95aa                      	dec r26
001b2b f019                      	breq sound_driver_channel0_instrument_change_exit
001b2c 95b6                      	lsr r27
001b2d f078                      	brcs sound_driver_channel0_instrument_change_load_macro
001b2e cffb                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_exit:
001b2f e0a3                      	ldi r26, 0x03
001b30 e0b2                      	ldi r27, 0x02
001b31 93b0 282a                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
001b33 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26
001b35 93b0 2837                 	sts pulse1_pitch_macro_offset, r27
001b37 93b0 283d                 	sts pulse1_hi_pitch_macro_offset, r27
001b39 93b0 2842                 	sts pulse1_duty_macro_offset, r27
001b3b d0ba                      	rcall sound_driver_channel0_increment_offset_twice
001b3c cdec                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_load_macro:
001b3d 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001b3e 91d5                      	lpm r29, Z+
                                 
001b3f 30a5                      	cpi r26, 5
001b40 f039                      	breq sound_driver_channel0_instrument_change_load_macro_volume
001b41 30a4                      	cpi r26, 4
001b42 f079                      	breq sound_driver_channel0_instrument_change_load_macro_arpeggio
001b43 30a3                      	cpi r26, 3
001b44 f0d9                      	breq sound_driver_channel0_instrument_change_load_macro_pitch
001b45 30a2                      	cpi r26, 2
001b46 f159                      	breq sound_driver_channel0_instrument_change_load_macro_hi_pitch
001b47 c03c                      	rjmp sound_driver_channel0_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel0_instrument_change_load_macro_volume:
001b48 93c0 2828                 	sts pulse1_volume_macro, r28
001b4a 93d0 2829                 	sts pulse1_volume_macro+1, r29
001b4c d041                      	rcall sound_driver_channel0_instrument_change_read_header
001b4d 93c0 282c                 	sts pulse1_volume_macro_release, r28
001b4f 93d0 282b                 	sts pulse1_volume_macro_loop, r29
001b51 cfd8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 	
                                 sound_driver_channel0_instrument_change_load_macro_arpeggio:
001b52 93c0 282d                 	sts pulse1_arpeggio_macro, r28
001b54 93d0 282e                 	sts pulse1_arpeggio_macro+1, r29
001b56 9220 2863                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001b58 9220 2864                 	sts pulse1_fx_Qxy_target+1, zero
001b5a 9220 2869                 	sts pulse1_fx_Rxy_target, zero
001b5c 9220 286a                 	sts pulse1_fx_Rxy_target+1, zero
001b5e d03a                      	rcall sound_driver_channel0_instrument_change_read_header_arpeggio
001b5f cfca                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_pitch:
001b60 93c0 2835                 	sts pulse1_pitch_macro, r28
001b62 93d0 2836                 	sts pulse1_pitch_macro+1, r29
001b64 9220 2863                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001b66 9220 2864                 	sts pulse1_fx_Qxy_target+1, zero
001b68 9220 2869                 	sts pulse1_fx_Rxy_target, zero
001b6a 9220 286a                 	sts pulse1_fx_Rxy_target+1, zero
001b6c d021                      	rcall sound_driver_channel0_instrument_change_read_header
001b6d 93c0 2839                 	sts pulse1_pitch_macro_release, r28
001b6f 93d0 2838                 	sts pulse1_pitch_macro_loop, r29
001b71 cfb8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_hi_pitch:
001b72 93c0 283b                 	sts pulse1_hi_pitch_macro, r28
001b74 93d0 283c                 	sts pulse1_hi_pitch_macro+1, r29
001b76 9220 2863                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001b78 9220 2864                 	sts pulse1_fx_Qxy_target+1, zero
001b7a 9220 2869                 	sts pulse1_fx_Rxy_target, zero
001b7c 9220 286a                 	sts pulse1_fx_Rxy_target+1, zero
001b7e d00f                      	rcall sound_driver_channel0_instrument_change_read_header
001b7f 93c0 283f                 	sts pulse1_hi_pitch_macro_release, r28
001b81 93d0 283e                 	sts pulse1_hi_pitch_macro_loop, r29
001b83 cfa6                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_duty:
001b84 93c0 2840                 	sts pulse1_duty_macro, r28
001b86 93d0 2841                 	sts pulse1_duty_macro+1, r29
001b88 d005                      	rcall sound_driver_channel0_instrument_change_read_header
001b89 93c0 2844                 	sts pulse1_duty_macro_release, r28
001b8b 93d0 2843                 	sts pulse1_duty_macro_loop, r29
001b8d cf9c                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_read_header:
001b8e 93ef                      	push ZL
001b8f 93ff                      	push ZH
001b90 2fec                      	mov ZL, r28
001b91 2ffd                      	mov ZH, r29
001b92 0fee                      	lsl ZL
001b93 1fff                      	rol ZH
001b94 91c5                      	lpm r28, Z+
001b95 91d4                      	lpm r29, Z
001b96 91ff                      	pop ZH
001b97 91ef                      	pop ZL
001b98 9508                      	ret
                                 
                                 sound_driver_channel0_instrument_change_read_header_arpeggio:
001b99 93ef                      	push ZL
001b9a 93ff                      	push ZH
001b9b 2fec                      	mov ZL, r28
001b9c 2ffd                      	mov ZH, r29
001b9d 0fee                      	lsl ZL
001b9e 1fff                      	rol ZH
001b9f 91c5                      	lpm r28, Z+
001ba0 91d5                      	lpm r29, Z+
001ba1 93c0 2831                 	sts pulse1_arpeggio_macro_release, r28
001ba3 93d0 2830                 	sts pulse1_arpeggio_macro_loop, r29
001ba5 91c4                      	lpm r28, Z
001ba6 93c0 2832                 	sts pulse1_arpeggio_macro_mode, r28
001ba8 91ff                      	pop ZH
001ba9 91ef                      	pop ZL
001baa 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel0_release:
                                 sound_driver_channel0_release_volume:
001bab 91b0 282c                 	lds r27, pulse1_volume_macro_release
001bad 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001bae f019                      	breq sound_driver_channel0_release_arpeggio //if the macro has no release flag, check the next macro
001baf 95b3                      	inc r27
001bb0 93b0 282a                 	sts pulse1_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel0_release_arpeggio:
001bb2 91b0 2831                 	lds r27, pulse1_arpeggio_macro_release
001bb4 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001bb5 f019                      	breq sound_driver_channel0_release_pitch
001bb6 95b3                      	inc r27
001bb7 93b0 282f                 	sts pulse1_arpeggio_macro_offset, r27
                                 sound_driver_channel0_release_pitch:
001bb9 91b0 2839                 	lds r27, pulse1_pitch_macro_release
001bbb 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001bbc f019                      	breq sound_driver_channel0_release_hi_pitch
001bbd 95b3                      	inc r27
001bbe 93b0 2837                 	sts pulse1_pitch_macro_offset, r27
                                 sound_driver_channel0_release_hi_pitch:
001bc0 91b0 283f                 	lds r27, pulse1_hi_pitch_macro_release
001bc2 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001bc3 f019                      	breq sound_driver_channel0_release_duty
001bc4 95b3                      	inc r27
001bc5 93b0 283d                 	sts pulse1_hi_pitch_macro_offset, r27
                                 sound_driver_channel0_release_duty:
001bc7 91b0 2844                 	lds r27, pulse1_duty_macro_release
001bc9 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001bca f019                      	breq sound_driver_channel0_release_exit
001bcb 95b3                      	inc r27
001bcc 93b0 2842                 	sts pulse1_duty_macro_offset, r27
                                 sound_driver_channel0_release_exit:
001bce d01d                      	rcall sound_driver_channel0_increment_offset
001bcf cd59                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_next_pattern:
001bd0 91e0 2818                 	lds ZL, song_frames
001bd2 91f0 2819                 	lds ZH, song_frames+1
001bd4 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001bd6 91b0 281b                 	lds r27, song_frame_offset+1
001bd8 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
001bd9 93a0 281a                 	sts song_frame_offset, r26
001bdb 93b0 281b                 	sts song_frame_offset+1, r27
001bdd 0fea                      	add ZL, r26
001bde 1ffb                      	adc ZH, r27
                                 
001bdf 91a5                      	lpm r26, Z+ //load the address of the next pattern
001be0 91b4                      	lpm r27, Z
001be1 0faa                      	lsl r26
001be2 1fbb                      	rol r27
001be3 93a0 2822                 	sts pulse1_pattern, r26
001be5 93b0 2823                 	sts pulse1_pattern+1, r27
                                 
001be7 9220 2826                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001be9 9220 2827                 	sts pulse1_pattern_offset+1, zero
001beb cd3d                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_increment_offset:
001bec 91e0 2826                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
001bee 91f0 2827                 	lds ZH, pulse1_pattern_offset+1
001bf0 9631                      	adiw Z, 1
001bf1 93e0 2826                 	sts pulse1_pattern_offset, ZL
001bf3 93f0 2827                 	sts pulse1_pattern_offset+1, ZH
001bf5 9508                      	ret
                                 
                                 sound_driver_channel0_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001bf6 91e0 2826                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
001bf8 91f0 2827                 	lds ZH, pulse1_pattern_offset+1
001bfa 9632                      	adiw Z, 2 //increment the pointer twice
001bfb 93e0 2826                 	sts pulse1_pattern_offset, ZL
001bfd 93f0 2827                 	sts pulse1_pattern_offset+1, ZH
001bff 9508                      	ret
                                 
                                 sound_driver_channel0_decrement_frame_delay:
001c00 95ba                      	dec r27
001c01 93b0 2825                 	sts pulse1_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel1:
001c03 91a0 2873                 	lds r26, pulse2_pattern_delay_rows
001c05 91b0 2874                 	lds r27, pulse2_pattern_delay_frames
001c07 9610                      	adiw r27:r26, 0
001c08 f009                      	breq sound_driver_channel1_main //if the pattern delay is 0, proceed with sound driver procedures
001c09 c2d3                      	rjmp sound_driver_channel1_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel1_main:
001c0a 91e0 2871                 	lds ZL, pulse2_pattern //current pattern for pulse 2
001c0c 91f0 2872                 	lds ZH, pulse2_pattern+1
001c0e 91a0 2875                 	lds r26, pulse2_pattern_offset //current offset in the pattern for pulse 2
001c10 91b0 2876                 	lds r27, pulse2_pattern_offset+1
001c12 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001c13 1ffb                      	adc ZH, r27
001c14 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel1_check_if_note: //check if data is a note (0x00 - 0x56)
001c15 35b7                      	cpi r27, 0x57
001c16 f408                      	brsh sound_driver_channel1_check_if_volume
001c17 c17c                      	rjmp sound_driver_channel1_note
                                 sound_driver_channel1_check_if_volume: //check if data is volume (0x57-0x66)
001c18 36b7                      	cpi r27, 0x67
001c19 f408                      	brsh sound_driver_channel1_check_if_delay
001c1a c1b6                      	rjmp sound_driver_channel1_volume
                                 sound_driver_channel1_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001c1b 3eb3                      	cpi r27, 0xE3
001c1c f408                      	brsh sound_driver_channel1_check_if_instrument
001c1d c1bd                      	rjmp sound_driver_channel1_delay
                                 sound_driver_channel1_check_if_instrument: //check for instrument flag (0xE3)
001c1e f409                      	brne sound_driver_channel1_check_if_release
001c1f c1c0                      	rjmp sound_driver_channel1_instrument_change 
                                 sound_driver_channel1_check_if_release: //check for note release flag (0xE4)
001c20 3eb4                      	cpi r27, 0xE4
001c21 f409                      	brne sound_driver_channel1_check_if_end
001c22 c269                      	rjmp sound_driver_channel1_release
                                 sound_driver_channel1_check_if_end:
001c23 3fbf                      	cpi r27, 0xFF
001c24 f409                      	brne sound_driver_channel1_check_if_fx
001c25 c28b                      	rjmp sound_driver_channel1_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel1_check_if_fx: //fx flags (0xE5 - 0xFE)
001c26 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001c27 91a4                      	lpm r26, Z //load the fx data into r26
001c28 d2aa                      	rcall sound_driver_channel1_increment_offset_twice
                                 
001c29 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001c2a ece2                      	ldi ZL, LOW(channel1_fx << 1) //load in note table
001c2b e6f4                      	ldi ZH, HIGH(channel1_fx << 1)
001c2c 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001c2d 0feb                      	add ZL, r27 //add offset
001c2e 1df2                      	adc ZH, zero
001c2f 91c5                      	lpm r28, Z+ //load address bytes
001c30 91d4                      	lpm r29, Z
001c31 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001c32 2ffd                      	mov ZH, r29
001c33 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel1_fx_0xy:
001c34 93a0 2894                 	sts pulse2_fx_0xy_sequence, r26
001c36 9220 2895                 	sts pulse2_fx_0xy_sequence+1, zero
001c38 cfd1                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel1_fx_1xx:
001c39 9220 289a                 	sts pulse2_fx_2xx, zero //turn off any 2xx pitch slide down
001c3b 9220 289b                 	sts pulse2_fx_2xx+1, zero
001c3d 9220 2894                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
001c3f 9220 2895                 	sts pulse2_fx_0xy_sequence+1, zero
001c41 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001c42 937f                      	push r23
001c43 2f6a                      	mov r22, r26 //store the rate into r22
001c44 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001c45 9f67                      	mul r22, r23
001c46 917f                      	pop r23
001c47 916f                      	pop r22
                                 
001c48 9416                      	lsr r1 //shift out the fractional bits
001c49 9407                      	ror r0
001c4a 9416                      	lsr r1
001c4b 9407                      	ror r0
001c4c 9416                      	lsr r1
001c4d 9407                      	ror r0
001c4e 9416                      	lsr r1
001c4f 9407                      	ror r0
001c50 9200 2896                 	sts pulse2_fx_1xx, r0
001c52 9210 2897                 	sts pulse2_fx_1xx+1, r1
001c54 cfb5                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel1_fx_2xx:
001c55 9220 2896                 	sts pulse2_fx_1xx, zero //turn off any 1xx pitch slide down
001c57 9220 2897                 	sts pulse2_fx_1xx+1, zero
001c59 9220 2894                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
001c5b 9220 2895                 	sts pulse2_fx_0xy_sequence+1, zero
001c5d 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001c5e 937f                      	push r23
001c5f 2f6a                      	mov r22, r26 //store the rate into r22
001c60 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001c61 9f67                      	mul r22, r23
001c62 917f                      	pop r23
001c63 916f                      	pop r22
                                 
001c64 9416                      	lsr r1 //shift out the fractional bits
001c65 9407                      	ror r0
001c66 9416                      	lsr r1
001c67 9407                      	ror r0
001c68 9416                      	lsr r1
001c69 9407                      	ror r0
001c6a 9416                      	lsr r1
001c6b 9407                      	ror r0
001c6c 9200 289a                 	sts pulse2_fx_2xx, r0
001c6e 9210 289b                 	sts pulse2_fx_2xx+1, r1
001c70 cf99                      	rjmp sound_driver_channel1_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel1_fx_3xx:
001c71 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001c72 937f                      	push r23
001c73 2f6a                      	mov r22, r26 //store the rate into r22
001c74 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001c75 9f67                      	mul r22, r23
001c76 917f                      	pop r23
001c77 916f                      	pop r22
                                 
001c78 9416                      	lsr r1 //shift out the fractional bits
001c79 9407                      	ror r0
001c7a 9416                      	lsr r1
001c7b 9407                      	ror r0
001c7c 9416                      	lsr r1
001c7d 9407                      	ror r0
001c7e 9416                      	lsr r1
001c7f 9407                      	ror r0
001c80 9200 28a2                 	sts pulse2_fx_3xx_speed, r0
001c82 9210 28a3                 	sts pulse2_fx_3xx_speed+1, r1
                                 
001c84 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001c85 c001                      	rjmp sound_driver_channel1_fx_3xx_enabled
001c86 cf83                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_3xx_enabled:
001c87 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001c89 91b0 0a9d                 	lds r27, TCB1_CCMPH
001c8b 93a0 289e                 	sts pulse2_fx_3xx_start, r26
001c8d 93b0 289f                 	sts pulse2_fx_3xx_start+1, r27
                                 
001c8f 9220 28a4                 	sts pulse2_fx_3xx_total_offset, zero
001c91 9220 28a5                 	sts pulse2_fx_3xx_total_offset+1, zero
001c93 cf76                      	rjmp sound_driver_channel1_main
                                 
                                 //VIBRATO
                                 sound_driver_channel1_fx_4xy:
001c94 2fba                      	mov r27, r26
001c95 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001c96 95a2                      	swap r26
001c97 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001c98 93a0 28a6                 	sts pulse2_fx_4xy_speed, r26
001c9a 93b0 28a7                 	sts pulse2_fx_4xy_depth, r27
001c9c 9220 28a8                 	sts pulse2_fx_4xy_phase, zero //reset the phase to 0
001c9e cf6b                      	rjmp sound_driver_channel1_main
                                 
                                 //TREMELO
                                 sound_driver_channel1_fx_7xy:
001c9f 2fba                      	mov r27, r26
001ca0 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001ca1 95a2                      	swap r26
001ca2 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001ca3 93a0 28a9                 	sts pulse2_fx_7xy_speed, r26
001ca5 93b0 28aa                 	sts pulse2_fx_7xy_depth, r27
001ca7 9220 28ab                 	sts pulse2_fx_7xy_phase, zero //reset the phase to 0
001ca9 9220 28ac                 	sts pulse2_fx_7xy_value, zero //reset the tremelo value
001cab cf5e                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel1_fx_Axy:
001cac 93a0 28ad                 	sts pulse2_fx_Axy, r26
001cae cf5b                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel1_fx_Bxx:
001caf 93a0 281f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001cb1 cf58                      	rjmp sound_driver_channel1_main
                                 
                                 //HALT
                                 sound_driver_channel1_fx_Cxx:
001cb2 93b0 2820                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001cb4 cf55                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel1_fx_Dxx:
001cb5 93b0 2821                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001cb7 cf52                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME
                                 sound_driver_channel1_fx_Exx:
001cb8 91b0 2808                 	lds r27, pulse2_param
001cba 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
001cbb 2bba                      	or r27, r26 //move new VVVV bits into pulse2_param
001cbc 93b0 2808                 	sts pulse2_param, r27
001cbe 6092                      	sbr pulse_channel_flags, 2
001cbf cf4a                      	rjmp sound_driver_channel1_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel1_fx_Fxx:
001cc0 93a0 281e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001cc2 cf47                      	rjmp sound_driver_channel1_main
                                 
                                 //DELAY
                                 sound_driver_channel1_fx_Gxx:
001cc3 15a2                      	cp r26, zero
001cc4 f051                      	breq sound_driver_channel1_fx_Gxx_invalid
001cc5 91b0 281e                 	lds r27, song_speed
001cc7 17ab                      	cp r26, r27
001cc8 f430                      	brsh sound_driver_channel1_fx_Gxx_invalid
001cc9 93a0 28ae                 	sts pulse2_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001ccb e0b1                      	ldi r27, 0x01
001ccc 93b0 2873                 	sts pulse2_pattern_delay_rows, r27
001cce c211                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Gxx_invalid:
001ccf cf3a                      	rjmp sound_driver_channel1_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel1_fx_Hxy: //hardware sweep up
001cd0 cf39                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixy: //hardware sweep down
001cd1 cf38                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Hxx: //FDS modulation depth
001cd2 cf37                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixx: //FDS modulation speed
001cd3 cf36                      	rjmp sound_driver_channel1_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel1_fx_Pxx:
001cd4 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001cd5 937f                      	push r23
001cd6 2f6a                      	mov r22, r26
001cd7 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001cd8 9f67                      	mul r22, r23
001cd9 917f                      	pop r23
001cda 916f                      	pop r22
001cdb 9416                      	lsr r1 //shift out the fractional bits
001cdc 9407                      	ror r0
001cdd 9416                      	lsr r1
001cde 9407                      	ror r0
001cdf 9416                      	lsr r1
001ce0 9407                      	ror r0
001ce1 9416                      	lsr r1
001ce2 9407                      	ror r0
001ce3 9200 28b0                 	sts pulse2_fx_Pxx_total, r0
001ce5 9210 28b1                 	sts pulse2_fx_Pxx_total+1, r1
001ce7 cf22                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel1_fx_Qxy:
                                 sound_driver_channel1_fx_Qxy_check_arpeggio_macro:
001ce8 91e0 287c                 	lds ZL, pulse2_arpeggio_macro
001cea 91f0 287d                 	lds ZH, pulse2_arpeggio_macro+1
001cec 9630                      	adiw Z, 0
001ced f009                      	breq sound_driver_channel1_fx_Qxy_check_pitch_macro
001cee cf1b                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_pitch_macro:
001cef 91e0 2884                 	lds ZL, pulse2_pitch_macro
001cf1 91f0 2885                 	lds ZH, pulse2_pitch_macro+1
001cf3 9630                      	adiw Z, 0
001cf4 f009                      	breq sound_driver_channel1_fx_Qxy_check_hi_pitch_macro
001cf5 cf14                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_hi_pitch_macro:
001cf6 91e0 288a                 	lds ZL, pulse2_hi_pitch_macro
001cf8 91f0 288b                 	lds ZH, pulse2_hi_pitch_macro+1
001cfa 9630                      	adiw Z, 0
001cfb f009                      	breq sound_driver_channel1_fx_Qxy_process
001cfc cf0d                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_process:
001cfd 2fba                      	mov r27, r26 //copy fx parameters into r27
001cfe 70bf                      	andi r27, 0x0F //mask note index offset
001cff 91c0 280f                 	lds r28, pulse2_note //load current note index
001d01 0fbc                      	add r27, r28
001d02 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001d03 f008                      	brlo sound_driver_channel1_fx_Qxy_process_continue
001d04 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel1_fx_Qxy_process_continue:
001d05 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001d06 e0f0                      	ldi ZH, HIGH(note_table << 1)
001d07 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001d08 0feb                      	add ZL, r27 //add offset
001d09 1df2                      	adc ZH, zero
001d0a 91c5                      	lpm r28, Z+ //load bytes
001d0b 91d4                      	lpm r29, Z
001d0c 93c0 28b2                 	sts pulse2_fx_Qxy_target, r28 //load the LOW bits for the target period
001d0e 93d0 28b3                 	sts pulse2_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
001d10 95a2                      	swap r26
001d11 70af                      	andi r26, 0x0F //mask effect speed
001d12 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001d13 95a3                      	inc r26 //increment the speed by 1
                                 
001d14 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001d15 937f                      	push r23
001d16 2f6a                      	mov r22, r26 //store the speed data into r27
001d17 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001d18 9f67                      	mul r22, r23
001d19 917f                      	pop r23
001d1a 916f                      	pop r22
                                 
001d1b 9416                      	lsr r1 //shift out the fractional bits
001d1c 9407                      	ror r0
001d1d 9416                      	lsr r1
001d1e 9407                      	ror r0
001d1f 9416                      	lsr r1
001d20 9407                      	ror r0
001d21 9416                      	lsr r1
001d22 9407                      	ror r0
                                 
001d23 9200 28b4                 	sts pulse2_fx_Qxy_speed, r0 //store the effect speed
001d25 9210 28b5                 	sts pulse2_fx_Qxy_speed+1, r1
001d27 9220 28b6                 	sts pulse2_fx_Qxy_total_offset, zero
001d29 9220 28b7                 	sts pulse2_fx_Qxy_total_offset+1, zero
001d2b cede                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel1_fx_Rxy:
                                 sound_driver_channel1_fx_Rxy_check_arpeggio_macro:
001d2c 91e0 287c                 	lds ZL, pulse2_arpeggio_macro
001d2e 91f0 287d                 	lds ZH, pulse2_arpeggio_macro+1
001d30 9630                      	adiw Z, 0
001d31 f009                      	breq sound_driver_channel1_fx_Rxy_check_pitch_macro
001d32 ced7                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_pitch_macro:
001d33 91e0 2884                 	lds ZL, pulse2_pitch_macro
001d35 91f0 2885                 	lds ZH, pulse2_pitch_macro+1
001d37 9630                      	adiw Z, 0
001d38 f009                      	breq sound_driver_channel1_fx_Rxy_check_hi_pitch_macro
001d39 ced0                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_hi_pitch_macro:
001d3a 91e0 288a                 	lds ZL, pulse2_hi_pitch_macro
001d3c 91f0 288b                 	lds ZH, pulse2_hi_pitch_macro+1
001d3e 9630                      	adiw Z, 0
001d3f f009                      	breq sound_driver_channel1_fx_Rxy_process
001d40 cec9                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_process:
001d41 2fba                      	mov r27, r26 //copy fx parameters into r27
001d42 70bf                      	andi r27, 0x0F //mask note index offset
001d43 91c0 280f                 	lds r28, pulse2_note //load current note index
001d45 1bcb                      	sub r28, r27
001d46 f408                      	brcc sound_driver_channel1_fx_Rxy_process_continue
001d47 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel1_fx_Rxy_process_continue:
001d48 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001d49 e0f0                      	ldi ZH, HIGH(note_table << 1)
001d4a 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001d4b 0fec                      	add ZL, r28 //add offset
001d4c 1df2                      	adc ZH, zero
001d4d 91c5                      	lpm r28, Z+ //load bytes
001d4e 91d4                      	lpm r29, Z
001d4f 93c0 28b8                 	sts pulse2_fx_Rxy_target, r28 //load the LOW bits for the target period
001d51 93d0 28b9                 	sts pulse2_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
001d53 95a2                      	swap r26
001d54 70af                      	andi r26, 0x0F //mask effect speed
001d55 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001d56 95a3                      	inc r26 //increment the speed by 1
                                 
001d57 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001d58 937f                      	push r23
001d59 2f6a                      	mov r22, r26 //store the speed data into r27
001d5a eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001d5b 9f67                      	mul r22, r23
001d5c 917f                      	pop r23
001d5d 916f                      	pop r22
                                 
001d5e 9416                      	lsr r1 //shift out the fractional bits
001d5f 9407                      	ror r0
001d60 9416                      	lsr r1
001d61 9407                      	ror r0
001d62 9416                      	lsr r1
001d63 9407                      	ror r0
001d64 9416                      	lsr r1
001d65 9407                      	ror r0
                                 
001d66 9200 28ba                 	sts pulse2_fx_Rxy_speed, r0 //store the effect speed
001d68 9210 28bb                 	sts pulse2_fx_Rxy_speed+1, r1
001d6a 9220 28bc                 	sts pulse2_fx_Rxy_total_offset, zero
001d6c 9220 28bd                 	sts pulse2_fx_Rxy_total_offset+1, zero
001d6e ce9b                      	rjmp sound_driver_channel1_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel1_fx_Sxx:
001d6f 15a2                      	cp r26, zero
001d70 f051                      	breq sound_driver_channel1_fx_Sxx_invalid
001d71 91b0 281e                 	lds r27, song_speed
001d73 17ab                      	cp r26, r27
001d74 f430                      	brsh sound_driver_channel1_fx_Sxx_invalid
001d75 93a0 28be                 	sts pulse2_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001d77 e0b1                      	ldi r27, 0x01
001d78 93b0 2873                 	sts pulse2_pattern_delay_rows, r27
001d7a c165                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Sxx_invalid:
001d7b ce8e                      	rjmp sound_driver_channel1_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel1_fx_Vxx:
001d7c e8ea                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
001d7d e6f4                      	ldi ZH, HIGH(sequences << 1)
001d7e 0fea                      	add ZL, r26 //offset the pointer
001d7f 1df2                      	adc ZH, zero
                                 
001d80 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
001d81 95a7                      	ror r26
001d82 95a7                      	ror r26
001d83 91b0 2808                 	lds r27, pulse2_param //load r27 with pulse2_param (register $4000)
001d85 2fcb                      	mov r28, r27 //store a copy of pulse2_param into r28
001d86 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
001d87 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
001d88 c001                      	rjmp sound_driver_channel1_fx_Vxx_store
001d89 ce80                      	rjmp sound_driver_channel1_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel1_fx_Vxx_store:
001d8a 90d4                      	lpm pulse2_sequence, Z //store the sequence
                                 
001d8b 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
001d8c 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
001d8d 93c0 2808                 	sts pulse2_param, r28
001d8f ce7a                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_Wxx: //DPCM sample speed
001d90 ce79                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Xxx: //DPCM sample retrigger
001d91 ce78                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Yxx: //DPCM sample offset
001d92 ce77                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Zxx: //DPCM sample delta counter
001d93 ce76                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 sound_driver_channel1_note:
001d94 93b0 280f                 	sts pulse2_note, r27 //store the note index
001d96 e0a3                      	ldi r26, 0x03
001d97 e0b2                      	ldi r27, 0x02
001d98 93b0 2879                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
001d9a 93a0 287e                 	sts pulse2_arpeggio_macro_offset, r26
001d9c 93b0 2886                 	sts pulse2_pitch_macro_offset, r27
001d9e 93b0 288c                 	sts pulse2_hi_pitch_macro_offset, r27
001da0 93b0 2891                 	sts pulse2_duty_macro_offset, r27
001da2 9220 2882                 	sts pulse2_total_pitch_offset, zero //reset the pitch and hi pitch offset
001da4 9220 2883                 	sts pulse2_total_pitch_offset+1, zero
001da6 9220 2889                 	sts pulse2_total_hi_pitch_offset, zero
001da8 9220 2898                 	sts pulse2_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001daa 9220 2899                 	sts pulse2_fx_1xx_total+1, zero
001dac 9220 289c                 	sts pulse2_fx_2xx_total, zero
001dae 9220 289d                 	sts pulse2_fx_2xx_total+1, zero
001db0 9220 28a4                 	sts pulse2_fx_3xx_total_offset, zero //reset 3xx offset
001db2 9220 28a5                 	sts pulse2_fx_3xx_total_offset+1, zero
001db4 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001db6 91b0 0a9d                 	lds r27, TCB1_CCMPH
001db8 93a0 289e                 	sts pulse2_fx_3xx_start, r26
001dba 93b0 289f                 	sts pulse2_fx_3xx_start+1, r27
001dbc 9220 2809                 	sts pulse2_sweep_param, zero //reset any sweep effect
001dbe 6093                      	sbr pulse_channel_flags, 3 //set reload flag
001dbf 9220 28b2                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001dc1 9220 28b3                 	sts pulse2_fx_Qxy_target+1, zero
001dc3 9220 28b6                 	sts pulse2_fx_Qxy_total_offset, zero
001dc5 9220 28b7                 	sts pulse2_fx_Qxy_total_offset+1, zero
001dc7 9220 28b8                 	sts pulse2_fx_Rxy_target, zero
001dc9 9220 28b9                 	sts pulse2_fx_Rxy_target+1, zero
001dcb 9220 28bc                 	sts pulse2_fx_Rxy_total_offset, zero
001dcd 9220 28bd                 	sts pulse2_fx_Rxy_total_offset+1, zero
001dcf d0f9                      	rcall sound_driver_channel1_increment_offset
001dd0 ce39                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_volume:
001dd1 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001dd2 91a0 2808                 	lds r26, pulse2_param
001dd4 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001dd5 2bab                      	or r26, r27 //move new VVVV bits into pulse2_param
001dd6 93a0 2808                 	sts pulse2_param, r26
001dd8 6092                      	sbr pulse_channel_flags, 2
001dd9 d0ef                      	rcall sound_driver_channel1_increment_offset
001dda ce2f                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_delay:
001ddb 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001ddc 93b0 2873                 	sts pulse2_pattern_delay_rows, r27
001dde d0ea                      	rcall sound_driver_channel1_increment_offset
001ddf c100                      	rjmp sound_driver_channel2
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change:
001de0 9220 2877                 	sts pulse2_volume_macro, zero //reset all macro addresses
001de2 9220 2878                 	sts pulse2_volume_macro+1, zero
001de4 9220 287c                 	sts pulse2_arpeggio_macro, zero
001de6 9220 287d                 	sts pulse2_arpeggio_macro+1, zero
001de8 9220 2884                 	sts pulse2_pitch_macro, zero
001dea 9220 2885                 	sts pulse2_pitch_macro+1, zero
001dec 9220 288a                 	sts pulse2_hi_pitch_macro, zero
001dee 9220 288b                 	sts pulse2_hi_pitch_macro+1, zero
001df0 9220 288f                 	sts pulse2_duty_macro, zero
001df2 9220 2890                 	sts pulse2_duty_macro+1, zero
001df4 9220 2882                 	sts pulse2_total_pitch_offset, zero //reset the pitch offset
001df6 9220 2883                 	sts pulse2_total_pitch_offset+1, zero
001df8 9220 2889                 	sts pulse2_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001dfa 9631                      	adiw Z, 1 //point to the byte next to the flag
001dfb 91b4                      	lpm r27, Z //store the instrument offset into r27
001dfc e3eb                      	ldi ZL, LOW(instruments) //point Z to instruments table
001dfd e1f1                      	ldi ZH, HIGH(instruments)
001dfe 0feb                      	add ZL, r27 //point Z to offsetted instrument
001dff 1df2                      	adc ZH, zero
001e00 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001e01 1fff                      	rol ZH
001e02 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001e03 91b4                      	lpm r27, Z
                                 
001e04 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001e05 1fbb                      	rol r27
001e06 2fea                      	mov ZL, r26
001e07 2ffb                      	mov ZH, r27
001e08 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001e09 9632                      	adiw Z, 2 //point Z to the address of the macro
001e0a e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel1_instrument_change_macro_loop:
001e0b 95aa                      	dec r26
001e0c f019                      	breq sound_driver_channel1_instrument_change_exit
001e0d 95b6                      	lsr r27
001e0e f078                      	brcs sound_driver_channel1_instrument_change_load_macro
001e0f cffb                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_exit:
001e10 e0a3                      	ldi r26, 0x03
001e11 e0b2                      	ldi r27, 0x02
001e12 93b0 2879                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
001e14 93a0 287e                 	sts pulse2_arpeggio_macro_offset, r26
001e16 93b0 2886                 	sts pulse2_pitch_macro_offset, r27
001e18 93b0 288c                 	sts pulse2_hi_pitch_macro_offset, r27
001e1a 93b0 2891                 	sts pulse2_duty_macro_offset, r27
001e1c d0b6                      	rcall sound_driver_channel1_increment_offset_twice
001e1d cdec                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_load_macro:
001e1e 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001e1f 91d5                      	lpm r29, Z+
                                 
001e20 30a5                      	cpi r26, 5
001e21 f039                      	breq sound_driver_channel1_instrument_change_load_macro_volume
001e22 30a4                      	cpi r26, 4
001e23 f079                      	breq sound_driver_channel1_instrument_change_load_macro_arpeggio
001e24 30a3                      	cpi r26, 3
001e25 f0d9                      	breq sound_driver_channel1_instrument_change_load_macro_pitch
001e26 30a2                      	cpi r26, 2
001e27 f159                      	breq sound_driver_channel1_instrument_change_load_macro_hi_pitch
001e28 c03c                      	rjmp sound_driver_channel1_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel1_instrument_change_load_macro_volume:
001e29 93c0 2877                 	sts pulse2_volume_macro, r28
001e2b 93d0 2878                 	sts pulse2_volume_macro+1, r29
001e2d d041                      	rcall sound_driver_channel1_instrument_change_read_header
001e2e 93c0 287b                 	sts pulse2_volume_macro_release, r28
001e30 93d0 287a                 	sts pulse2_volume_macro_loop, r29
001e32 cfd8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 	
                                 sound_driver_channel1_instrument_change_load_macro_arpeggio:
001e33 93c0 287c                 	sts pulse2_arpeggio_macro, r28
001e35 93d0 287d                 	sts pulse2_arpeggio_macro+1, r29
001e37 9220 28b2                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001e39 9220 28b3                 	sts pulse2_fx_Qxy_target+1, zero
001e3b 9220 28b8                 	sts pulse2_fx_Rxy_target, zero
001e3d 9220 28b9                 	sts pulse2_fx_Rxy_target+1, zero
001e3f d03a                      	rcall sound_driver_channel1_instrument_change_read_header_arpeggio
001e40 cfca                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_pitch:
001e41 93c0 2884                 	sts pulse2_pitch_macro, r28
001e43 93d0 2885                 	sts pulse2_pitch_macro+1, r29
001e45 9220 28b2                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001e47 9220 28b3                 	sts pulse2_fx_Qxy_target+1, zero
001e49 9220 28b8                 	sts pulse2_fx_Rxy_target, zero
001e4b 9220 28b9                 	sts pulse2_fx_Rxy_target+1, zero
001e4d d021                      	rcall sound_driver_channel1_instrument_change_read_header
001e4e 93c0 2888                 	sts pulse2_pitch_macro_release, r28
001e50 93d0 2887                 	sts pulse2_pitch_macro_loop, r29
001e52 cfb8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_hi_pitch:
001e53 93c0 288a                 	sts pulse2_hi_pitch_macro, r28
001e55 93d0 288b                 	sts pulse2_hi_pitch_macro+1, r29
001e57 9220 28b2                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001e59 9220 28b3                 	sts pulse2_fx_Qxy_target+1, zero
001e5b 9220 28b8                 	sts pulse2_fx_Rxy_target, zero
001e5d 9220 28b9                 	sts pulse2_fx_Rxy_target+1, zero
001e5f d00f                      	rcall sound_driver_channel1_instrument_change_read_header
001e60 93c0 288e                 	sts pulse2_hi_pitch_macro_release, r28
001e62 93d0 288d                 	sts pulse2_hi_pitch_macro_loop, r29
001e64 cfa6                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_duty:
001e65 93c0 288f                 	sts pulse2_duty_macro, r28
001e67 93d0 2890                 	sts pulse2_duty_macro+1, r29
001e69 d005                      	rcall sound_driver_channel1_instrument_change_read_header
001e6a 93c0 2893                 	sts pulse2_duty_macro_release, r28
001e6c 93d0 2892                 	sts pulse2_duty_macro_loop, r29
001e6e cf9c                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_read_header:
001e6f 93ef                      	push ZL
001e70 93ff                      	push ZH
001e71 2fec                      	mov ZL, r28
001e72 2ffd                      	mov ZH, r29
001e73 0fee                      	lsl ZL
001e74 1fff                      	rol ZH
001e75 91c5                      	lpm r28, Z+
001e76 91d4                      	lpm r29, Z
001e77 91ff                      	pop ZH
001e78 91ef                      	pop ZL
001e79 9508                      	ret
                                 
                                 sound_driver_channel1_instrument_change_read_header_arpeggio:
001e7a 93ef                      	push ZL
001e7b 93ff                      	push ZH
001e7c 2fec                      	mov ZL, r28
001e7d 2ffd                      	mov ZH, r29
001e7e 0fee                      	lsl ZL
001e7f 1fff                      	rol ZH
001e80 91c5                      	lpm r28, Z+
001e81 91d5                      	lpm r29, Z+
001e82 93c0 2880                 	sts pulse2_arpeggio_macro_release, r28
001e84 93d0 287f                 	sts pulse2_arpeggio_macro_loop, r29
001e86 91c4                      	lpm r28, Z
001e87 93c0 2881                 	sts pulse2_arpeggio_macro_mode, r28
001e89 91ff                      	pop ZH
001e8a 91ef                      	pop ZL
001e8b 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel1_release:
                                 sound_driver_channel1_release_volume:
001e8c 91b0 287b                 	lds r27, pulse2_volume_macro_release
001e8e 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001e8f f019                      	breq sound_driver_channel1_release_arpeggio //if the macro has no release flag, check the next macro
001e90 95b3                      	inc r27
001e91 93b0 2879                 	sts pulse2_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel1_release_arpeggio:
001e93 91b0 2880                 	lds r27, pulse2_arpeggio_macro_release
001e95 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001e96 f019                      	breq sound_driver_channel1_release_pitch
001e97 95b3                      	inc r27
001e98 93b0 287e                 	sts pulse2_arpeggio_macro_offset, r27
                                 sound_driver_channel1_release_pitch:
001e9a 91b0 2888                 	lds r27, pulse2_pitch_macro_release
001e9c 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001e9d f019                      	breq sound_driver_channel1_release_hi_pitch
001e9e 95b3                      	inc r27
001e9f 93b0 2886                 	sts pulse2_pitch_macro_offset, r27
                                 sound_driver_channel1_release_hi_pitch:
001ea1 91b0 288e                 	lds r27, pulse2_hi_pitch_macro_release
001ea3 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001ea4 f019                      	breq sound_driver_channel1_release_duty
001ea5 95b3                      	inc r27
001ea6 93b0 288c                 	sts pulse2_hi_pitch_macro_offset, r27
                                 sound_driver_channel1_release_duty:
001ea8 91b0 2893                 	lds r27, pulse2_duty_macro_release
001eaa 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001eab f019                      	breq sound_driver_channel1_release_exit
001eac 95b3                      	inc r27
001ead 93b0 2891                 	sts pulse2_duty_macro_offset, r27
                                 sound_driver_channel1_release_exit:
001eaf d019                      	rcall sound_driver_channel1_increment_offset
001eb0 cd59                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_next_pattern:
001eb1 91e0 2818                 	lds ZL, song_frames
001eb3 91f0 2819                 	lds ZH, song_frames+1
001eb5 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001eb7 91b0 281b                 	lds r27, song_frame_offset+1
001eb9 9612                      	adiw r27:r26, 2 //offset for channel 1
001eba 0fea                      	add ZL, r26
001ebb 1ffb                      	adc ZH, r27
                                 
001ebc 91a5                      	lpm r26, Z+ //load the address of the next pattern
001ebd 91b4                      	lpm r27, Z
001ebe 0faa                      	lsl r26
001ebf 1fbb                      	rol r27
001ec0 93a0 2871                 	sts pulse2_pattern, r26
001ec2 93b0 2872                 	sts pulse2_pattern+1, r27
                                 
001ec4 9220 2875                 	sts pulse2_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001ec6 9220 2876                 	sts pulse2_pattern_offset+1, zero
001ec8 cd41                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_increment_offset:
001ec9 91e0 2875                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001ecb 91f0 2876                 	lds ZH, pulse2_pattern_offset+1
001ecd 9631                      	adiw Z, 1
001ece 93e0 2875                 	sts pulse2_pattern_offset, ZL
001ed0 93f0 2876                 	sts pulse2_pattern_offset+1, ZH
001ed2 9508                      	ret
                                 
                                 sound_driver_channel1_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001ed3 91e0 2875                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001ed5 91f0 2876                 	lds ZH, pulse2_pattern_offset+1
001ed7 9632                      	adiw Z, 2 //increment the pointer twice
001ed8 93e0 2875                 	sts pulse2_pattern_offset, ZL
001eda 93f0 2876                 	sts pulse2_pattern_offset+1, ZH
001edc 9508                      	ret
                                 
                                 sound_driver_channel1_decrement_frame_delay:
001edd 95ba                      	dec r27
001ede 93b0 2874                 	sts pulse2_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel2:
001ee0 91a0 28c2                 	lds r26, triangle_pattern_delay_rows
001ee2 91b0 28c3                 	lds r27, triangle_pattern_delay_frames
001ee4 9610                      	adiw r27:r26, 0
001ee5 f009                      	breq sound_driver_channel2_main //if the pattern delay is 0, proceed with sound driver procedures
001ee6 c2bb                      	rjmp sound_driver_channel2_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel2_main:
001ee7 91e0 28c0                 	lds ZL, triangle_pattern //current pattern for triangle
001ee9 91f0 28c1                 	lds ZH, triangle_pattern+1
001eeb 91a0 28c4                 	lds r26, triangle_pattern_offset //current offset in the pattern for triangle
001eed 91b0 28c5                 	lds r27, triangle_pattern_offset+1
001eef 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001ef0 1ffb                      	adc ZH, r27
001ef1 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel2_check_if_note: //check if data is a note (0x00 - 0x56)
001ef2 35b7                      	cpi r27, 0x57
001ef3 f408                      	brsh sound_driver_channel2_check_if_volume
001ef4 c160                      	rjmp sound_driver_channel2_note
                                 sound_driver_channel2_check_if_volume: //check if data is volume (0x57-0x66)
001ef5 36b7                      	cpi r27, 0x67
001ef6 f408                      	brsh sound_driver_channel2_check_if_delay
001ef7 c19a                      	rjmp sound_driver_channel2_volume
                                 sound_driver_channel2_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001ef8 3eb3                      	cpi r27, 0xE3
001ef9 f408                      	brsh sound_driver_channel2_check_if_instrument
001efa c1a5                      	rjmp sound_driver_channel2_delay
                                 sound_driver_channel2_check_if_instrument: //check for instrument flag (0xE3)
001efb f409                      	brne sound_driver_channel2_check_if_release
001efc c1a8                      	rjmp sound_driver_channel2_instrument_change 
                                 sound_driver_channel2_check_if_release: //check for note release flag (0xE4)
001efd 3eb4                      	cpi r27, 0xE4
001efe f409                      	brne sound_driver_channel2_check_if_end
001eff c251                      	rjmp sound_driver_channel2_release
                                 sound_driver_channel2_check_if_end:
001f00 3fbf                      	cpi r27, 0xFF
001f01 f409                      	brne sound_driver_channel2_check_if_fx
001f02 c273                      	rjmp sound_driver_channel2_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel2_check_if_fx: //fx flags (0xE5 - 0xFE)
001f03 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001f04 91a4                      	lpm r26, Z //load the fx data into r26
001f05 d292                      	rcall sound_driver_channel2_increment_offset_twice
                                 
001f06 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001f07 efe6                      	ldi ZL, LOW(channel2_fx << 1) //load in note table
001f08 e6f4                      	ldi ZH, HIGH(channel2_fx << 1)
001f09 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001f0a 0feb                      	add ZL, r27 //add offset
001f0b 1df2                      	adc ZH, zero
001f0c 91c5                      	lpm r28, Z+ //load address bytes
001f0d 91d4                      	lpm r29, Z
001f0e 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001f0f 2ffd                      	mov ZH, r29
001f10 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel2_fx_0xy:
001f11 93a0 28e3                 	sts triangle_fx_0xy_sequence, r26
001f13 9220 28e4                 	sts triangle_fx_0xy_sequence+1, zero
001f15 cfd1                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel2_fx_1xx:
001f16 9220 28e9                 	sts triangle_fx_2xx, zero //turn off any 2xx pitch slide down
001f18 9220 28ea                 	sts triangle_fx_2xx+1, zero
001f1a 9220 28e3                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001f1c 9220 28e4                 	sts triangle_fx_0xy_sequence+1, zero
001f1e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001f1f 937f                      	push r23
001f20 2f6a                      	mov r22, r26 //store the rate into r22
001f21 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001f22 9f67                      	mul r22, r23
001f23 917f                      	pop r23
001f24 916f                      	pop r22
                                 
001f25 9416                      	lsr r1 //shift out the fractional bits
001f26 9407                      	ror r0
001f27 9416                      	lsr r1
001f28 9407                      	ror r0
001f29 9416                      	lsr r1
001f2a 9407                      	ror r0
001f2b 9416                      	lsr r1
001f2c 9407                      	ror r0
001f2d 9200 28e5                 	sts triangle_fx_1xx, r0
001f2f 9210 28e6                 	sts triangle_fx_1xx+1, r1
001f31 cfb5                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel2_fx_2xx:
001f32 9220 28e5                 	sts triangle_fx_1xx, zero //turn off any 1xx pitch slide down
001f34 9220 28e6                 	sts triangle_fx_1xx+1, zero
001f36 9220 28e3                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001f38 9220 28e4                 	sts triangle_fx_0xy_sequence+1, zero
001f3a 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001f3b 937f                      	push r23
001f3c 2f6a                      	mov r22, r26 //store the rate into r22
001f3d eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001f3e 9f67                      	mul r22, r23
001f3f 917f                      	pop r23
001f40 916f                      	pop r22
                                 
001f41 9416                      	lsr r1 //shift out the fractional bits
001f42 9407                      	ror r0
001f43 9416                      	lsr r1
001f44 9407                      	ror r0
001f45 9416                      	lsr r1
001f46 9407                      	ror r0
001f47 9416                      	lsr r1
001f48 9407                      	ror r0
001f49 9200 28e9                 	sts triangle_fx_2xx, r0
001f4b 9210 28ea                 	sts triangle_fx_2xx+1, r1
001f4d cf99                      	rjmp sound_driver_channel2_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel2_fx_3xx:
001f4e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001f4f 937f                      	push r23
001f50 2f6a                      	mov r22, r26 //store the rate into r22
001f51 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001f52 9f67                      	mul r22, r23
001f53 917f                      	pop r23
001f54 916f                      	pop r22
                                 
001f55 9416                      	lsr r1 //shift out the fractional bits
001f56 9407                      	ror r0
001f57 9416                      	lsr r1
001f58 9407                      	ror r0
001f59 9416                      	lsr r1
001f5a 9407                      	ror r0
001f5b 9416                      	lsr r1
001f5c 9407                      	ror r0
001f5d 9200 28f1                 	sts triangle_fx_3xx_speed, r0
001f5f 9210 28f2                 	sts triangle_fx_3xx_speed+1, r1
                                 
001f61 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001f62 c001                      	rjmp sound_driver_channel2_fx_3xx_enabled
001f63 cf83                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_3xx_enabled:
001f64 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001f66 91b0 0aad                 	lds r27, TCB2_CCMPH
001f68 93a0 28ed                 	sts triangle_fx_3xx_start, r26
001f6a 93b0 28ee                 	sts triangle_fx_3xx_start+1, r27
                                 
001f6c 9220 28f3                 	sts triangle_fx_3xx_total_offset, zero
001f6e 9220 28f4                 	sts triangle_fx_3xx_total_offset+1, zero
001f70 cf76                      	rjmp sound_driver_channel2_main
                                 
                                 //VIBRATO
                                 sound_driver_channel2_fx_4xy:
001f71 2fba                      	mov r27, r26
001f72 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001f73 95a2                      	swap r26
001f74 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001f75 93a0 28f5                 	sts triangle_fx_4xy_speed, r26
001f77 93b0 28f6                 	sts triangle_fx_4xy_depth, r27
001f79 9220 28f7                 	sts triangle_fx_4xy_phase, zero //reset the phase to 0
001f7b cf6b                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_7xy: //tremelo
001f7c cf6a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Axy: //volume slide
001f7d cf69                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel2_fx_Bxx:
001f7e 93a0 281f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001f80 cf66                      	rjmp sound_driver_channel2_main
                                 
                                 //HALT
                                 sound_driver_channel2_fx_Cxx:
001f81 93b0 2820                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001f83 cf63                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel2_fx_Dxx:
001f84 93b0 2821                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001f86 cf60                      	rjmp sound_driver_channel2_main
                                 
                                 //VOLUME
                                 sound_driver_channel2_fx_Exx:
001f87 15a2                      	cp r26, zero
001f88 f021                      	breq sound_driver_channel2_fx_Exx_disable
                                 sound_driver_channel2_fx_Exx_enable:
001f89 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001f8a 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001f8c cf5a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Exx_disable:
001f8d 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
001f8f 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
001f91 9220 0aad                 	sts TCB2_CCMPH, zero
001f93 cf53                      	rjmp sound_driver_channel2_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel2_fx_Fxx:
001f94 93a0 281e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001f96 cf50                      	rjmp sound_driver_channel2_main
                                 
                                 //DELAY
                                 sound_driver_channel2_fx_Gxx:
001f97 15a2                      	cp r26, zero
001f98 f051                      	breq sound_driver_channel2_fx_Gxx_invalid
001f99 91b0 281e                 	lds r27, song_speed
001f9b 17ab                      	cp r26, r27
001f9c f430                      	brsh sound_driver_channel2_fx_Gxx_invalid
001f9d 93a0 28f8                 	sts triangle_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001f9f e0b1                      	ldi r27, 0x01
001fa0 93b0 28c2                 	sts triangle_pattern_delay_rows, r27
001fa2 c202                      	rjmp sound_driver_channel3
                                 sound_driver_channel2_fx_Gxx_invalid:
001fa3 cf43                      	rjmp sound_driver_channel2_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Hxy: //hardware sweep up
001fa4 cf42                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixy: //hardware sweep down
001fa5 cf41                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Hxx: //FDS modulation depth
001fa6 cf40                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixx: //FDS modulation speed
001fa7 cf3f                      	rjmp sound_driver_channel2_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel2_fx_Pxx:
001fa8 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001fa9 937f                      	push r23
001faa 2f6a                      	mov r22, r26
001fab eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001fac 9f67                      	mul r22, r23
001fad 917f                      	pop r23
001fae 916f                      	pop r22
001faf 9416                      	lsr r1 //shift out the fractional bits
001fb0 9407                      	ror r0
001fb1 9416                      	lsr r1
001fb2 9407                      	ror r0
001fb3 9416                      	lsr r1
001fb4 9407                      	ror r0
001fb5 9416                      	lsr r1
001fb6 9407                      	ror r0
001fb7 9200 28fa                 	sts triangle_fx_Pxx_total, r0
001fb9 9210 28fb                 	sts triangle_fx_Pxx_total+1, r1
001fbb cf2b                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel2_fx_Qxy:
                                 sound_driver_channel2_fx_Qxy_check_arpeggio_macro:
001fbc 91e0 28cb                 	lds ZL, triangle_arpeggio_macro
001fbe 91f0 28cc                 	lds ZH, triangle_arpeggio_macro+1
001fc0 9630                      	adiw Z, 0
001fc1 f009                      	breq sound_driver_channel2_fx_Qxy_check_pitch_macro
001fc2 cf24                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_pitch_macro:
001fc3 91e0 28d3                 	lds ZL, triangle_pitch_macro
001fc5 91f0 28d4                 	lds ZH, triangle_pitch_macro+1
001fc7 9630                      	adiw Z, 0
001fc8 f009                      	breq sound_driver_channel2_fx_Qxy_check_hi_pitch_macro
001fc9 cf1d                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_hi_pitch_macro:
001fca 91e0 28d9                 	lds ZL, triangle_hi_pitch_macro
001fcc 91f0 28da                 	lds ZH, triangle_hi_pitch_macro+1
001fce 9630                      	adiw Z, 0
001fcf f009                      	breq sound_driver_channel2_fx_Qxy_process
001fd0 cf16                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_process:
001fd1 2fba                      	mov r27, r26 //copy fx parameters into r27
001fd2 70bf                      	andi r27, 0x0F //mask note index offset
001fd3 91c0 2812                 	lds r28, triangle_note //load current note index
001fd5 0fbc                      	add r27, r28
001fd6 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001fd7 f008                      	brlo sound_driver_channel2_fx_Qxy_process_continue
001fd8 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel2_fx_Qxy_process_continue:
001fd9 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001fda e0f0                      	ldi ZH, HIGH(note_table << 1)
001fdb 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001fdc 0feb                      	add ZL, r27 //add offset
001fdd 1df2                      	adc ZH, zero
001fde 91c5                      	lpm r28, Z+ //load bytes
001fdf 91d4                      	lpm r29, Z
001fe0 93c0 28fc                 	sts triangle_fx_Qxy_target, r28 //load the LOW bits for the target period
001fe2 93d0 28fd                 	sts triangle_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
001fe4 95a2                      	swap r26
001fe5 70af                      	andi r26, 0x0F //mask effect speed
001fe6 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001fe7 95a3                      	inc r26 //increment the speed by 1
                                 
001fe8 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001fe9 937f                      	push r23
001fea 2f6a                      	mov r22, r26 //store the speed data into r27
001feb eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001fec 9f67                      	mul r22, r23
001fed 917f                      	pop r23
001fee 916f                      	pop r22
                                 
001fef 9416                      	lsr r1 //shift out the fractional bits
001ff0 9407                      	ror r0
001ff1 9416                      	lsr r1
001ff2 9407                      	ror r0
001ff3 9416                      	lsr r1
001ff4 9407                      	ror r0
001ff5 9416                      	lsr r1
001ff6 9407                      	ror r0
                                 
001ff7 9200 28fe                 	sts triangle_fx_Qxy_speed, r0 //store the effect speed
001ff9 9210 28ff                 	sts triangle_fx_Qxy_speed+1, r1
001ffb 9220 2900                 	sts triangle_fx_Qxy_total_offset, zero
001ffd 9220 2901                 	sts triangle_fx_Qxy_total_offset+1, zero
001fff cee7                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel2_fx_Rxy:
                                 sound_driver_channel2_fx_Rxy_check_arpeggio_macro:
002000 91e0 28cb                 	lds ZL, triangle_arpeggio_macro
002002 91f0 28cc                 	lds ZH, triangle_arpeggio_macro+1
002004 9630                      	adiw Z, 0
002005 f009                      	breq sound_driver_channel2_fx_Rxy_check_pitch_macro
002006 cee0                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_pitch_macro:
002007 91e0 28d3                 	lds ZL, triangle_pitch_macro
002009 91f0 28d4                 	lds ZH, triangle_pitch_macro+1
00200b 9630                      	adiw Z, 0
00200c f009                      	breq sound_driver_channel2_fx_Rxy_check_hi_pitch_macro
00200d ced9                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_hi_pitch_macro:
00200e 91e0 28d9                 	lds ZL, triangle_hi_pitch_macro
002010 91f0 28da                 	lds ZH, triangle_hi_pitch_macro+1
002012 9630                      	adiw Z, 0
002013 f009                      	breq sound_driver_channel2_fx_Rxy_process
002014 ced2                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_process:
002015 2fba                      	mov r27, r26 //copy fx parameters into r27
002016 70bf                      	andi r27, 0x0F //mask note index offset
002017 91c0 2812                 	lds r28, triangle_note //load current note index
002019 1bcb                      	sub r28, r27
00201a f408                      	brcc sound_driver_channel2_fx_Rxy_process_continue
00201b e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel2_fx_Rxy_process_continue:
00201c e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
00201d e0f0                      	ldi ZH, HIGH(note_table << 1)
00201e 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
00201f 0fec                      	add ZL, r28 //add offset
002020 1df2                      	adc ZH, zero
002021 91c5                      	lpm r28, Z+ //load bytes
002022 91d4                      	lpm r29, Z
002023 93c0 2902                 	sts triangle_fx_Rxy_target, r28 //load the LOW bits for the target period
002025 93d0 2903                 	sts triangle_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
002027 95a2                      	swap r26
002028 70af                      	andi r26, 0x0F //mask effect speed
002029 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
00202a 95a3                      	inc r26 //increment the speed by 1
                                 
00202b 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00202c 937f                      	push r23
00202d 2f6a                      	mov r22, r26 //store the speed data into r27
00202e eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00202f 9f67                      	mul r22, r23
002030 917f                      	pop r23
002031 916f                      	pop r22
                                 
002032 9416                      	lsr r1 //shift out the fractional bits
002033 9407                      	ror r0
002034 9416                      	lsr r1
002035 9407                      	ror r0
002036 9416                      	lsr r1
002037 9407                      	ror r0
002038 9416                      	lsr r1
002039 9407                      	ror r0
                                 
00203a 9200 2904                 	sts triangle_fx_Rxy_speed, r0 //store the effect speed
00203c 9210 2905                 	sts triangle_fx_Rxy_speed+1, r1
00203e 9220 2906                 	sts triangle_fx_Rxy_total_offset, zero
002040 9220 2907                 	sts triangle_fx_Rxy_total_offset+1, zero
002042 cea4                      	rjmp sound_driver_channel2_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel2_fx_Sxx:
002043 15a2                      	cp r26, zero
002044 f051                      	breq sound_driver_channel2_fx_Sxx_invalid
002045 91b0 281e                 	lds r27, song_speed
002047 17ab                      	cp r26, r27
002048 f430                      	brsh sound_driver_channel2_fx_Sxx_invalid
002049 93a0 2908                 	sts triangle_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
00204b e0b1                      	ldi r27, 0x01
00204c 93b0 28c2                 	sts triangle_pattern_delay_rows, r27
00204e c156                      	rjmp sound_driver_channel3
                                 sound_driver_channel2_fx_Sxx_invalid:
00204f ce97                      	rjmp sound_driver_channel2_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Vxx: //duty
002050 ce96                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Wxx: //DPCM sample speed
002051 ce95                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Xxx: //DPCM sample retrigger
002052 ce94                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Yxx: //DPCM sample offset
002053 ce93                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Zxx: //DPCM sample delta counter
002054 ce92                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 sound_driver_channel2_note:
002055 93b0 2812                 	sts triangle_note, r27 //store the note index
002057 e0a3                      	ldi r26, 0x03
002058 e0b2                      	ldi r27, 0x02
002059 93b0 28c8                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
00205b 93a0 28cd                 	sts triangle_arpeggio_macro_offset, r26
00205d 93b0 28d5                 	sts triangle_pitch_macro_offset, r27
00205f 93b0 28db                 	sts triangle_hi_pitch_macro_offset, r27
002061 93b0 28e0                 	sts triangle_duty_macro_offset, r27
002063 9220 28d1                 	sts triangle_total_pitch_offset, zero //reset the pitch and hi pitch offset
002065 9220 28d1                 	sts triangle_total_pitch_offset, zero
002067 9220 28d8                 	sts triangle_total_hi_pitch_offset, zero
002069 9220 28e7                 	sts triangle_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
00206b 9220 28e8                 	sts triangle_fx_1xx_total+1, zero
00206d 9220 28eb                 	sts triangle_fx_2xx_total, zero
00206f 9220 28ec                 	sts triangle_fx_2xx_total+1, zero
002071 9220 28f3                 	sts triangle_fx_3xx_total_offset, zero //reset 3xx offset
002073 9220 28f4                 	sts triangle_fx_3xx_total_offset+1, zero
002075 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
002077 91b0 0aad                 	lds r27, TCB2_CCMPH
002079 93a0 28ed                 	sts triangle_fx_3xx_start, r26
00207b 93b0 28ee                 	sts triangle_fx_3xx_start+1, r27
00207d 9220 28fc                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00207f 9220 28fd                 	sts triangle_fx_Qxy_target+1, zero
002081 9220 2900                 	sts triangle_fx_Qxy_total_offset, zero
002083 9220 2901                 	sts triangle_fx_Qxy_total_offset+1, zero
002085 9220 2902                 	sts triangle_fx_Rxy_target, zero
002087 9220 2903                 	sts triangle_fx_Rxy_target+1, zero
002089 9220 2906                 	sts triangle_fx_Rxy_total_offset, zero
00208b 9220 2907                 	sts triangle_fx_Rxy_total_offset+1, zero
00208d e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
00208e 93b0 0aa5                 	sts TCB2_INTCTRL, r27
002090 d0fd                      	rcall sound_driver_channel2_increment_offset
002091 ce55                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_volume:
002092 d0fb                      	rcall sound_driver_channel2_increment_offset
002093 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
002094 f021                      	breq sound_driver_channel2_volume_disable
                                 sound_driver_channel2_volume_enable:
002095 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
002096 93b0 0aa5                 	sts TCB2_INTCTRL, r27
002098 ce4e                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_volume_disable:
002099 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
00209b 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
00209d 9220 0aad                 	sts TCB2_CCMPH, zero
00209f ce47                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_delay:
0020a0 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
0020a1 93b0 28c2                 	sts triangle_pattern_delay_rows, r27
0020a3 d0ea                      	rcall sound_driver_channel2_increment_offset
0020a4 c100                      	rjmp sound_driver_channel3
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change:
0020a5 9220 28c6                 	sts triangle_volume_macro, zero //reset all macro addresses
0020a7 9220 28c7                 	sts triangle_volume_macro+1, zero
0020a9 9220 28cb                 	sts triangle_arpeggio_macro, zero
0020ab 9220 28cc                 	sts triangle_arpeggio_macro+1, zero
0020ad 9220 28d3                 	sts triangle_pitch_macro, zero
0020af 9220 28d4                 	sts triangle_pitch_macro+1, zero
0020b1 9220 28d9                 	sts triangle_hi_pitch_macro, zero
0020b3 9220 28da                 	sts triangle_hi_pitch_macro+1, zero
0020b5 9220 28de                 	sts triangle_duty_macro, zero
0020b7 9220 28df                 	sts triangle_duty_macro+1, zero
0020b9 9220 28d1                 	sts triangle_total_pitch_offset, zero //reset the pitch offset
0020bb 9220 28d2                 	sts triangle_total_pitch_offset+1, zero
0020bd 9220 28d8                 	sts triangle_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
0020bf 9631                      	adiw Z, 1 //point to the byte next to the flag
0020c0 91b4                      	lpm r27, Z //store the instrument offset into r27
0020c1 e3eb                      	ldi ZL, LOW(instruments) //point Z to instruments table
0020c2 e1f1                      	ldi ZH, HIGH(instruments)
0020c3 0feb                      	add ZL, r27 //point Z to offsetted instrument
0020c4 1df2                      	adc ZH, zero
0020c5 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
0020c6 1fff                      	rol ZH
0020c7 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
0020c8 91b4                      	lpm r27, Z
                                 
0020c9 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
0020ca 1fbb                      	rol r27
0020cb 2fea                      	mov ZL, r26
0020cc 2ffb                      	mov ZH, r27
0020cd 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
0020ce 9632                      	adiw Z, 2 //point Z to the address of the macro
0020cf e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel2_instrument_change_macro_loop:
0020d0 95aa                      	dec r26
0020d1 f019                      	breq sound_driver_channel2_instrument_change_exit
0020d2 95b6                      	lsr r27
0020d3 f078                      	brcs sound_driver_channel2_instrument_change_load_macro
0020d4 cffb                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_exit:
0020d5 e0a3                      	ldi r26, 0x03
0020d6 e0b2                      	ldi r27, 0x02
0020d7 93b0 28c8                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
0020d9 93a0 28cd                 	sts triangle_arpeggio_macro_offset, r26
0020db 93b0 28d5                 	sts triangle_pitch_macro_offset, r27
0020dd 93b0 28db                 	sts triangle_hi_pitch_macro_offset, r27
0020df 93b0 28e0                 	sts triangle_duty_macro_offset, r27
0020e1 d0b6                      	rcall sound_driver_channel2_increment_offset_twice
0020e2 ce04                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_load_macro:
0020e3 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
0020e4 91d5                      	lpm r29, Z+
                                 
0020e5 30a5                      	cpi r26, 5
0020e6 f039                      	breq sound_driver_channel2_instrument_change_load_macro_volume
0020e7 30a4                      	cpi r26, 4
0020e8 f079                      	breq sound_driver_channel2_instrument_change_load_macro_arpeggio
0020e9 30a3                      	cpi r26, 3
0020ea f0d9                      	breq sound_driver_channel2_instrument_change_load_macro_pitch
0020eb 30a2                      	cpi r26, 2
0020ec f159                      	breq sound_driver_channel2_instrument_change_load_macro_hi_pitch
0020ed c03c                      	rjmp sound_driver_channel2_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel2_instrument_change_load_macro_volume:
0020ee 93c0 28c6                 	sts triangle_volume_macro, r28
0020f0 93d0 28c7                 	sts triangle_volume_macro+1, r29
0020f2 d041                      	rcall sound_driver_channel2_instrument_change_read_header
0020f3 93c0 28ca                 	sts triangle_volume_macro_release, r28
0020f5 93d0 28c9                 	sts triangle_volume_macro_loop, r29
0020f7 cfd8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 	
                                 sound_driver_channel2_instrument_change_load_macro_arpeggio:
0020f8 93c0 28cb                 	sts triangle_arpeggio_macro, r28
0020fa 93d0 28cc                 	sts triangle_arpeggio_macro+1, r29
0020fc 9220 28fc                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0020fe 9220 28fd                 	sts triangle_fx_Qxy_target+1, zero
002100 9220 2902                 	sts triangle_fx_Rxy_target, zero
002102 9220 2903                 	sts triangle_fx_Rxy_target+1, zero
002104 d03a                      	rcall sound_driver_channel2_instrument_change_read_header_arpeggio
002105 cfca                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_pitch:
002106 93c0 28d3                 	sts triangle_pitch_macro, r28
002108 93d0 28d4                 	sts triangle_pitch_macro+1, r29
00210a 9220 28fc                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00210c 9220 28fd                 	sts triangle_fx_Qxy_target+1, zero
00210e 9220 2902                 	sts triangle_fx_Rxy_target, zero
002110 9220 2903                 	sts triangle_fx_Rxy_target+1, zero
002112 d021                      	rcall sound_driver_channel2_instrument_change_read_header
002113 93c0 28d7                 	sts triangle_pitch_macro_release, r28
002115 93d0 28d6                 	sts triangle_pitch_macro_loop, r29
002117 cfb8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_hi_pitch:
002118 93c0 28d9                 	sts triangle_hi_pitch_macro, r28
00211a 93d0 28da                 	sts triangle_hi_pitch_macro+1, r29
00211c 9220 28fc                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00211e 9220 28fd                 	sts triangle_fx_Qxy_target+1, zero
002120 9220 2902                 	sts triangle_fx_Rxy_target, zero
002122 9220 2903                 	sts triangle_fx_Rxy_target+1, zero
002124 d00f                      	rcall sound_driver_channel2_instrument_change_read_header
002125 93c0 28dd                 	sts triangle_hi_pitch_macro_release, r28
002127 93d0 28dc                 	sts triangle_hi_pitch_macro_loop, r29
002129 cfa6                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_duty:
00212a 93c0 28de                 	sts triangle_duty_macro, r28
00212c 93d0 28df                 	sts triangle_duty_macro+1, r29
00212e d005                      	rcall sound_driver_channel2_instrument_change_read_header
00212f 93c0 28e2                 	sts triangle_duty_macro_release, r28
002131 93d0 28e1                 	sts triangle_duty_macro_loop, r29
002133 cf9c                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_read_header:
002134 93ef                      	push ZL
002135 93ff                      	push ZH
002136 2fec                      	mov ZL, r28
002137 2ffd                      	mov ZH, r29
002138 0fee                      	lsl ZL
002139 1fff                      	rol ZH
00213a 91c5                      	lpm r28, Z+
00213b 91d4                      	lpm r29, Z
00213c 91ff                      	pop ZH
00213d 91ef                      	pop ZL
00213e 9508                      	ret
                                 
                                 sound_driver_channel2_instrument_change_read_header_arpeggio:
00213f 93ef                      	push ZL
002140 93ff                      	push ZH
002141 2fec                      	mov ZL, r28
002142 2ffd                      	mov ZH, r29
002143 0fee                      	lsl ZL
002144 1fff                      	rol ZH
002145 91c5                      	lpm r28, Z+
002146 91d5                      	lpm r29, Z+
002147 93c0 28cf                 	sts triangle_arpeggio_macro_release, r28
002149 93d0 28ce                 	sts triangle_arpeggio_macro_loop, r29
00214b 91c4                      	lpm r28, Z
00214c 93c0 28d0                 	sts triangle_arpeggio_macro_mode, r28
00214e 91ff                      	pop ZH
00214f 91ef                      	pop ZL
002150 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel2_release:
                                 sound_driver_channel2_release_volume:
002151 91b0 28ca                 	lds r27, triangle_volume_macro_release
002153 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
002154 f019                      	breq sound_driver_channel2_release_arpeggio //if the macro has no release flag, check the next macro
002155 95b3                      	inc r27
002156 93b0 28c8                 	sts triangle_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel2_release_arpeggio:
002158 91b0 28cf                 	lds r27, triangle_arpeggio_macro_release
00215a 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
00215b f019                      	breq sound_driver_channel2_release_pitch
00215c 95b3                      	inc r27
00215d 93b0 28cd                 	sts triangle_arpeggio_macro_offset, r27
                                 sound_driver_channel2_release_pitch:
00215f 91b0 28d7                 	lds r27, triangle_pitch_macro_release
002161 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
002162 f019                      	breq sound_driver_channel2_release_hi_pitch
002163 95b3                      	inc r27
002164 93b0 28d5                 	sts triangle_pitch_macro_offset, r27
                                 sound_driver_channel2_release_hi_pitch:
002166 91b0 28dd                 	lds r27, triangle_hi_pitch_macro_release
002168 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
002169 f019                      	breq sound_driver_channel2_release_duty
00216a 95b3                      	inc r27
00216b 93b0 28db                 	sts triangle_hi_pitch_macro_offset, r27
                                 sound_driver_channel2_release_duty:
00216d 91b0 28e2                 	lds r27, triangle_duty_macro_release
00216f 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
002170 f019                      	breq sound_driver_channel2_release_exit
002171 95b3                      	inc r27
002172 93b0 28e0                 	sts triangle_duty_macro_offset, r27
                                 sound_driver_channel2_release_exit:
002174 d019                      	rcall sound_driver_channel2_increment_offset
002175 cd71                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_next_pattern:
002176 91e0 2818                 	lds ZL, song_frames
002178 91f0 2819                 	lds ZH, song_frames+1
00217a 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
00217c 91b0 281b                 	lds r27, song_frame_offset+1
00217e 9614                      	adiw r27:r26, 4 //offset for channel 2
00217f 0fea                      	add ZL, r26
002180 1ffb                      	adc ZH, r27
                                 
002181 91a5                      	lpm r26, Z+ //load the address of the next pattern
002182 91b4                      	lpm r27, Z
002183 0faa                      	lsl r26
002184 1fbb                      	rol r27
002185 93a0 28c0                 	sts triangle_pattern, r26
002187 93b0 28c1                 	sts triangle_pattern+1, r27
                                 
002189 9220 28c4                 	sts triangle_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
00218b 9220 28c5                 	sts triangle_pattern_offset+1, zero
00218d cd59                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_increment_offset:
00218e 91e0 28c4                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
002190 91f0 28c5                 	lds ZH, triangle_pattern_offset+1
002192 9631                      	adiw Z, 1
002193 93e0 28c4                 	sts triangle_pattern_offset, ZL
002195 93f0 28c5                 	sts triangle_pattern_offset+1, ZH
002197 9508                      	ret
                                 
                                 sound_driver_channel2_increment_offset_twice: //used for data that takes up 2 bytes worth of space
002198 91e0 28c4                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
00219a 91f0 28c5                 	lds ZH, triangle_pattern_offset+1
00219c 9632                      	adiw Z, 2 //increment the pointer twice
00219d 93e0 28c4                 	sts triangle_pattern_offset, ZL
00219f 93f0 28c5                 	sts triangle_pattern_offset+1, ZH
0021a1 9508                      	ret
                                 
                                 sound_driver_channel2_decrement_frame_delay:
0021a2 95ba                      	dec r27
0021a3 93b0 28c3                 	sts triangle_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel3:
0021a5 91a0 290c                 	lds r26, noise_pattern_delay_rows
0021a7 91b0 290d                 	lds r27, noise_pattern_delay_frames
0021a9 9610                      	adiw r27:r26, 0
0021aa f009                      	breq sound_driver_channel3_main //if the pattern delay is 0, proceed with sound driver procedures
0021ab c2c9                      	rjmp sound_driver_channel3_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel3_main:
0021ac 91e0 290a                 	lds ZL, noise_pattern //current pattern for noise
0021ae 91f0 290b                 	lds ZH, noise_pattern+1
0021b0 91a0 290e                 	lds r26, noise_pattern_offset //current offset in the pattern for noise
0021b2 91b0 290f                 	lds r27, noise_pattern_offset+1
0021b4 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
0021b5 1ffb                      	adc ZH, r27
0021b6 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel3_check_if_note: //check if data is a note (0x00 - 0x56)
0021b7 35b7                      	cpi r27, 0x57
0021b8 f408                      	brsh sound_driver_channel3_check_if_volume
0021b9 c172                      	rjmp sound_driver_channel3_note
                                 sound_driver_channel3_check_if_volume: //check if data is volume (0x57-0x66)
0021ba 36b7                      	cpi r27, 0x67
0021bb f408                      	brsh sound_driver_channel3_check_if_delay
0021bc c1a9                      	rjmp sound_driver_channel3_volume
                                 sound_driver_channel3_check_if_delay: //check if data is a delay (0x67 - 0xE2)
0021bd 3eb3                      	cpi r27, 0xE3
0021be f408                      	brsh sound_driver_channel3_check_if_instrument
0021bf c1af                      	rjmp sound_driver_channel3_delay
                                 sound_driver_channel3_check_if_instrument: //check for instrument flag (0xE3)
0021c0 f409                      	brne sound_driver_channel3_check_if_release
0021c1 c1b2                      	rjmp sound_driver_channel3_instrument_change 
                                 sound_driver_channel3_check_if_release: //check for note release flag (0xE4)
0021c2 3eb4                      	cpi r27, 0xE4
0021c3 f409                      	brne sound_driver_channel3_check_if_end
0021c4 c25b                      	rjmp sound_driver_channel3_release
                                 sound_driver_channel3_check_if_end:
0021c5 3fbf                      	cpi r27, 0xFF
0021c6 f409                      	brne sound_driver_channel3_check_if_fx
0021c7 c27d                      	rjmp sound_driver_channel3_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel3_check_if_fx: //fx flags (0xE5 - 0xFE)
0021c8 9631                      	adiw Z, 1 //point Z to the byte next to the flag
0021c9 91a4                      	lpm r26, Z //load the fx data into r26
0021ca d2a0                      	rcall sound_driver_channel3_increment_offset_twice
                                 
0021cb 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
0021cc e2ea                      	ldi ZL, LOW(channel3_fx << 1) //load in note table
0021cd e6f5                      	ldi ZH, HIGH(channel3_fx << 1)
0021ce 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
0021cf 0feb                      	add ZL, r27 //add offset
0021d0 1df2                      	adc ZH, zero
0021d1 91c5                      	lpm r28, Z+ //load address bytes
0021d2 91d4                      	lpm r29, Z
0021d3 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
0021d4 2ffd                      	mov ZH, r29
0021d5 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel3_fx_0xy:
0021d6 93a0 292d                 	sts noise_fx_0xy_sequence, r26
0021d8 9220 292e                 	sts noise_fx_0xy_sequence+1, zero
0021da cfd1                      	rjmp sound_driver_channel3_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel3_fx_1xx:
0021db 9220 2933                 	sts noise_fx_2xx, zero //turn off any 2xx pitch slide down
0021dd 9220 2934                 	sts noise_fx_2xx+1, zero
0021df 9220 292d                 	sts noise_fx_0xy_sequence, zero //disable any 0xy effect
0021e1 9220 292e                 	sts noise_fx_0xy_sequence+1, zero
0021e3 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0021e4 937f                      	push r23
0021e5 2f6a                      	mov r22, r26 //store the rate into r22
0021e6 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0021e7 9f67                      	mul r22, r23
0021e8 917f                      	pop r23
0021e9 916f                      	pop r22
                                 
0021ea 9416                      	lsr r1 //shift out the fractional bits
0021eb 9407                      	ror r0
0021ec 9416                      	lsr r1
0021ed 9407                      	ror r0
0021ee 9416                      	lsr r1
0021ef 9407                      	ror r0
0021f0 9416                      	lsr r1
0021f1 9407                      	ror r0
0021f2 9200 292f                 	sts noise_fx_1xx, r0
0021f4 9210 2930                 	sts noise_fx_1xx+1, r1
0021f6 cfb5                      	rjmp sound_driver_channel3_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel3_fx_2xx:
0021f7 9220 292f                 	sts noise_fx_1xx, zero //turn off any 1xx pitch slide down
0021f9 9220 2930                 	sts noise_fx_1xx+1, zero
0021fb 9220 292d                 	sts noise_fx_0xy_sequence, zero //disable any 0xy effect
0021fd 9220 292e                 	sts noise_fx_0xy_sequence+1, zero
0021ff 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002200 937f                      	push r23
002201 2f6a                      	mov r22, r26 //store the rate into r22
002202 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002203 9f67                      	mul r22, r23
002204 917f                      	pop r23
002205 916f                      	pop r22
                                 
002206 9416                      	lsr r1 //shift out the fractional bits
002207 9407                      	ror r0
002208 9416                      	lsr r1
002209 9407                      	ror r0
00220a 9416                      	lsr r1
00220b 9407                      	ror r0
00220c 9416                      	lsr r1
00220d 9407                      	ror r0
00220e 9200 2933                 	sts noise_fx_2xx, r0
002210 9210 2934                 	sts noise_fx_2xx+1, r1
002212 cf99                      	rjmp sound_driver_channel3_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel3_fx_3xx:
002213 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002214 937f                      	push r23
002215 2f6a                      	mov r22, r26 //store the rate into r22
002216 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002217 9f67                      	mul r22, r23
002218 917f                      	pop r23
002219 916f                      	pop r22
                                 
00221a 9416                      	lsr r1 //shift out the fractional bits
00221b 9407                      	ror r0
00221c 9416                      	lsr r1
00221d 9407                      	ror r0
00221e 9416                      	lsr r1
00221f 9407                      	ror r0
002220 9416                      	lsr r1
002221 9407                      	ror r0
002222 9200 293b                 	sts noise_fx_3xx_speed, r0
002224 9210 293c                 	sts noise_fx_3xx_speed+1, r1
                                 
002226 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
002227 c001                      	rjmp sound_driver_channel3_fx_3xx_enabled
002228 cf83                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_3xx_enabled:
002229 91a0 0abc                 	lds r26, TCB3_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
00222b 91b0 0abd                 	lds r27, TCB3_CCMPH
00222d 93a0 2937                 	sts noise_fx_3xx_start, r26
00222f 93b0 2938                 	sts noise_fx_3xx_start+1, r27
                                 
002231 9220 293d                 	sts noise_fx_3xx_total_offset, zero
002233 9220 293e                 	sts noise_fx_3xx_total_offset+1, zero
002235 cf76                      	rjmp sound_driver_channel3_main
                                 
                                 //VIBRATO
                                 sound_driver_channel3_fx_4xy:
002236 2fba                      	mov r27, r26
002237 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
002238 95a2                      	swap r26
002239 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
00223a 93a0 293f                 	sts noise_fx_4xy_speed, r26
00223c 93b0 2940                 	sts noise_fx_4xy_depth, r27
00223e 9220 2941                 	sts noise_fx_4xy_phase, zero //reset the phase to 0
002240 cf6b                      	rjmp sound_driver_channel3_main
                                 
                                 //TREMELO
                                 sound_driver_channel3_fx_7xy:
002241 2fba                      	mov r27, r26
002242 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
002243 95a2                      	swap r26
002244 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
002245 93a0 2942                 	sts noise_fx_7xy_speed, r26
002247 93b0 2943                 	sts noise_fx_7xy_depth, r27
002249 9220 2944                 	sts noise_fx_7xy_phase, zero //reset the phase to 0
00224b 9220 2945                 	sts noise_fx_7xy_value, zero //reset the tremelo value
00224d cf5e                      	rjmp sound_driver_channel3_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel3_fx_Axy:
00224e 93a0 2946                 	sts noise_fx_Axy, r26
002250 cf5b                      	rjmp sound_driver_channel3_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel3_fx_Bxx:
002251 93a0 281f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
002253 cf58                      	rjmp sound_driver_channel3_main
                                 
                                 //HALT
                                 sound_driver_channel3_fx_Cxx:
002254 93b0 2820                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
002256 cf55                      	rjmp sound_driver_channel3_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel3_fx_Dxx:
002257 93b0 2821                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
002259 cf52                      	rjmp sound_driver_channel3_main
                                 
                                 //VOLUME
                                 sound_driver_channel3_fx_Exx:
00225a 91b0 2813                 	lds r27, noise_param
00225c 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
00225d 2bba                      	or r27, r26 //move new VVVV bits into noise_param
00225e 93b0 2813                 	sts noise_param, r27
002260 cf4b                      	rjmp sound_driver_channel3_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel3_fx_Fxx:
002261 93a0 281e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
002263 cf48                      	rjmp sound_driver_channel3_main
                                 
                                 //DELAY
                                 sound_driver_channel3_fx_Gxx:
002264 15a2                      	cp r26, zero
002265 f051                      	breq sound_driver_channel3_fx_Gxx_invalid
002266 91b0 281e                 	lds r27, song_speed
002268 17ab                      	cp r26, r27
002269 f430                      	brsh sound_driver_channel3_fx_Gxx_invalid
00226a 93a0 2947                 	sts noise_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
00226c e0b1                      	ldi r27, 0x01
00226d 93b0 290c                 	sts noise_pattern_delay_rows, r27
00226f c208                      	rjmp sound_driver_channel4
                                 sound_driver_channel3_fx_Gxx_invalid:
002270 cf3b                      	rjmp sound_driver_channel3_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel3_fx_Hxy: //hardware sweep up
002271 cf3a                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Ixy: //hardware sweep down
002272 cf39                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Hxx: //FDS modulation depth
002273 cf38                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Ixx: //FDS modulation speed
002274 cf37                      	rjmp sound_driver_channel3_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel3_fx_Pxx:
002275 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002276 937f                      	push r23
002277 2f6a                      	mov r22, r26
002278 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002279 9f67                      	mul r22, r23
00227a 917f                      	pop r23
00227b 916f                      	pop r22
00227c 9416                      	lsr r1 //shift out the fractional bits
00227d 9407                      	ror r0
00227e 9416                      	lsr r1
00227f 9407                      	ror r0
002280 9416                      	lsr r1
002281 9407                      	ror r0
002282 9416                      	lsr r1
002283 9407                      	ror r0
002284 9200 2949                 	sts noise_fx_Pxx_total, r0
002286 9210 294a                 	sts noise_fx_Pxx_total+1, r1
002288 cf23                      	rjmp sound_driver_channel3_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel3_fx_Qxy:
                                 sound_driver_channel3_fx_Qxy_check_arpeggio_macro:
002289 91e0 2915                 	lds ZL, noise_arpeggio_macro
00228b 91f0 2916                 	lds ZH, noise_arpeggio_macro+1
00228d 9630                      	adiw Z, 0
00228e f009                      	breq sound_driver_channel3_fx_Qxy_check_pitch_macro
00228f cf1c                      	rjmp sound_driver_channel3_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Qxy_check_pitch_macro:
002290 91e0 291d                 	lds ZL, noise_pitch_macro
002292 91f0 291e                 	lds ZH, noise_pitch_macro+1
002294 9630                      	adiw Z, 0
002295 f009                      	breq sound_driver_channel3_fx_Qxy_check_hi_pitch_macro
002296 cf15                      	rjmp sound_driver_channel3_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Qxy_check_hi_pitch_macro:
002297 91e0 2923                 	lds ZL, noise_hi_pitch_macro
002299 91f0 2924                 	lds ZH, noise_hi_pitch_macro+1
00229b 9630                      	adiw Z, 0
00229c f009                      	breq sound_driver_channel3_fx_Qxy_process
00229d cf0e                      	rjmp sound_driver_channel3_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Qxy_process:
00229e 2fba                      	mov r27, r26 //copy fx parameters into r27
00229f 70bf                      	andi r27, 0x0F //mask note index offset
0022a0 91c0 2817                 	lds r28, noise_note //load current note index
0022a2 0fbc                      	add r27, r28
0022a3 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
0022a4 f008                      	brlo sound_driver_channel3_fx_Qxy_process_continue
0022a5 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel3_fx_Qxy_process_continue:
0022a6 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0022a7 e0f0                      	ldi ZH, HIGH(note_table << 1)
0022a8 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
0022a9 0feb                      	add ZL, r27 //add offset
0022aa 1df2                      	adc ZH, zero
0022ab 91c5                      	lpm r28, Z+ //load bytes
0022ac 91d4                      	lpm r29, Z
0022ad 93c0 294b                 	sts noise_fx_Qxy_target, r28 //load the LOW bits for the target period
0022af 93d0 294c                 	sts noise_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
0022b1 95a2                      	swap r26
0022b2 70af                      	andi r26, 0x0F //mask effect speed
0022b3 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0022b4 95a3                      	inc r26 //increment the speed by 1
                                 
0022b5 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0022b6 937f                      	push r23
0022b7 2f6a                      	mov r22, r26 //store the speed data into r27
0022b8 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0022b9 9f67                      	mul r22, r23
0022ba 917f                      	pop r23
0022bb 916f                      	pop r22
                                 
0022bc 9416                      	lsr r1 //shift out the fractional bits
0022bd 9407                      	ror r0
0022be 9416                      	lsr r1
0022bf 9407                      	ror r0
0022c0 9416                      	lsr r1
0022c1 9407                      	ror r0
0022c2 9416                      	lsr r1
0022c3 9407                      	ror r0
                                 
0022c4 9200 294d                 	sts noise_fx_Qxy_speed, r0 //store the effect speed
0022c6 9210 294e                 	sts noise_fx_Qxy_speed+1, r1
0022c8 9220 294f                 	sts noise_fx_Qxy_total_offset, zero
0022ca 9220 2950                 	sts noise_fx_Qxy_total_offset+1, zero
0022cc cedf                      	rjmp sound_driver_channel3_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel3_fx_Rxy:
                                 sound_driver_channel3_fx_Rxy_check_arpeggio_macro:
0022cd 91e0 2915                 	lds ZL, noise_arpeggio_macro
0022cf 91f0 2916                 	lds ZH, noise_arpeggio_macro+1
0022d1 9630                      	adiw Z, 0
0022d2 f009                      	breq sound_driver_channel3_fx_Rxy_check_pitch_macro
0022d3 ced8                      	rjmp sound_driver_channel3_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Rxy_check_pitch_macro:
0022d4 91e0 291d                 	lds ZL, noise_pitch_macro
0022d6 91f0 291e                 	lds ZH, noise_pitch_macro+1
0022d8 9630                      	adiw Z, 0
0022d9 f009                      	breq sound_driver_channel3_fx_Rxy_check_hi_pitch_macro
0022da ced1                      	rjmp sound_driver_channel3_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Rxy_check_hi_pitch_macro:
0022db 91e0 2923                 	lds ZL, noise_hi_pitch_macro
0022dd 91f0 2924                 	lds ZH, noise_hi_pitch_macro+1
0022df 9630                      	adiw Z, 0
0022e0 f009                      	breq sound_driver_channel3_fx_Rxy_process
0022e1 ceca                      	rjmp sound_driver_channel3_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Rxy_process:
0022e2 2fba                      	mov r27, r26 //copy fx parameters into r27
0022e3 70bf                      	andi r27, 0x0F //mask note index offset
0022e4 91c0 2817                 	lds r28, noise_note //load current note index
0022e6 1bcb                      	sub r28, r27
0022e7 f408                      	brcc sound_driver_channel3_fx_Rxy_process_continue
0022e8 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel3_fx_Rxy_process_continue:
0022e9 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0022ea e0f0                      	ldi ZH, HIGH(note_table << 1)
0022eb 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
0022ec 0fec                      	add ZL, r28 //add offset
0022ed 1df2                      	adc ZH, zero
0022ee 91c5                      	lpm r28, Z+ //load bytes
0022ef 91d4                      	lpm r29, Z
0022f0 93c0 2951                 	sts noise_fx_Rxy_target, r28 //load the LOW bits for the target period
0022f2 93d0 2952                 	sts noise_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
0022f4 95a2                      	swap r26
0022f5 70af                      	andi r26, 0x0F //mask effect speed
0022f6 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0022f7 95a3                      	inc r26 //increment the speed by 1
                                 
0022f8 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0022f9 937f                      	push r23
0022fa 2f6a                      	mov r22, r26 //store the speed data into r27
0022fb eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0022fc 9f67                      	mul r22, r23
0022fd 917f                      	pop r23
0022fe 916f                      	pop r22
                                 
0022ff 9416                      	lsr r1 //shift out the fractional bits
002300 9407                      	ror r0
002301 9416                      	lsr r1
002302 9407                      	ror r0
002303 9416                      	lsr r1
002304 9407                      	ror r0
002305 9416                      	lsr r1
002306 9407                      	ror r0
                                 
002307 9200 2953                 	sts noise_fx_Rxy_speed, r0 //store the effect speed
002309 9210 2954                 	sts noise_fx_Rxy_speed+1, r1
00230b 9220 2955                 	sts noise_fx_Rxy_total_offset, zero
00230d 9220 2956                 	sts noise_fx_Rxy_total_offset+1, zero
00230f ce9c                      	rjmp sound_driver_channel3_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel3_fx_Sxx:
002310 15a2                      	cp r26, zero
002311 f051                      	breq sound_driver_channel3_fx_Sxx_invalid
002312 91b0 281e                 	lds r27, song_speed
002314 17ab                      	cp r26, r27
002315 f430                      	brsh sound_driver_channel3_fx_Sxx_invalid
002316 93a0 2957                 	sts noise_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
002318 e0b1                      	ldi r27, 0x01
002319 93b0 290c                 	sts noise_pattern_delay_rows, r27
00231b c15c                      	rjmp sound_driver_channel4
                                 sound_driver_channel3_fx_Sxx_invalid:
00231c ce8f                      	rjmp sound_driver_channel3_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel3_fx_Vxx:
00231d 95a6                      	lsr r26
00231e 95a7                      	ror r26 //move mode bit to bit 7
00231f 91b0 2814                 	lds r27, noise_period
002321 77bf                      	andi r27, 0b01111111
002322 2bba                      	or r27, r26 //store the new noise mode
002323 93b0 2813                 	sts noise_param, r27
                                 
002325 776f                      	andi noise_sequence_HIGH, 0b01111111
002326 2b6a                      	or noise_sequence_HIGH, r26
002327 ce84                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_Wxx: //DPCM sample speed
002328 ce83                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Xxx: //DPCM sample retrigger
002329 ce82                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Yxx: //DPCM sample offset
00232a ce81                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Zxx: //DPCM sample delta counter
00232b ce80                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 sound_driver_channel3_note:
00232c 93b0 2817                 	sts noise_note, r27 //store the note index
00232e e0a3                      	ldi r26, 0x03
00232f e0b2                      	ldi r27, 0x02
002330 93b0 2912                 	sts noise_volume_macro_offset, r27 //reset all macro offsets
002332 93a0 2917                 	sts noise_arpeggio_macro_offset, r26
002334 93b0 291f                 	sts noise_pitch_macro_offset, r27
002336 93b0 2925                 	sts noise_hi_pitch_macro_offset, r27
002338 93b0 292a                 	sts noise_duty_macro_offset, r27
00233a 9220 291b                 	sts noise_total_pitch_offset, zero //reset the pitch and hi pitch offset
00233c 9220 291c                 	sts noise_total_pitch_offset+1, zero
00233e 9220 2922                 	sts noise_total_hi_pitch_offset, zero
002340 9220 2931                 	sts noise_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
002342 9220 2932                 	sts noise_fx_1xx_total+1, zero
002344 9220 2935                 	sts noise_fx_2xx_total, zero
002346 9220 2936                 	sts noise_fx_2xx_total+1, zero
002348 9220 293d                 	sts noise_fx_3xx_total_offset, zero //reset 3xx offset
00234a 9220 293e                 	sts noise_fx_3xx_total_offset+1, zero
00234c 91a0 0abc                 	lds r26, TCB3_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
00234e 91b0 0abd                 	lds r27, TCB3_CCMPH
002350 93a0 2937                 	sts noise_fx_3xx_start, r26
002352 93b0 2938                 	sts noise_fx_3xx_start+1, r27
002354 9220 294b                 	sts noise_fx_Qxy_target, zero //reset the Qxy, Rxy effects
002356 9220 294c                 	sts noise_fx_Qxy_target+1, zero
002358 9220 294f                 	sts noise_fx_Qxy_total_offset, zero
00235a 9220 2950                 	sts noise_fx_Qxy_total_offset+1, zero
00235c 9220 2951                 	sts noise_fx_Rxy_target, zero
00235e 9220 2952                 	sts noise_fx_Rxy_target+1, zero
002360 9220 2955                 	sts noise_fx_Rxy_total_offset, zero
002362 9220 2956                 	sts noise_fx_Rxy_total_offset+1, zero
002364 d0fc                      	rcall sound_driver_channel3_increment_offset
002365 ce46                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_volume:
002366 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
002367 91a0 2813                 	lds r26, noise_param
002369 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
00236a 2bab                      	or r26, r27 //move new VVVV bits into noise_param
00236b 93a0 2813                 	sts noise_param, r26
00236d d0f3                      	rcall sound_driver_channel3_increment_offset
00236e ce3d                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_delay:
00236f 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
002370 93b0 290c                 	sts noise_pattern_delay_rows, r27
002372 d0ee                      	rcall sound_driver_channel3_increment_offset
002373 c104                      	rjmp sound_driver_channel4
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change:
002374 9220 2910                 	sts noise_volume_macro, zero //reset all macro addresses
002376 9220 2911                 	sts noise_volume_macro+1, zero
002378 9220 2915                 	sts noise_arpeggio_macro, zero
00237a 9220 2916                 	sts noise_arpeggio_macro+1, zero
00237c 9220 291d                 	sts noise_pitch_macro, zero
00237e 9220 291e                 	sts noise_pitch_macro+1, zero
002380 9220 2923                 	sts noise_hi_pitch_macro, zero
002382 9220 2924                 	sts noise_hi_pitch_macro+1, zero
002384 9220 2928                 	sts noise_duty_macro, zero
002386 9220 2929                 	sts noise_duty_macro+1, zero
002388 9220 291b                 	sts noise_total_pitch_offset, zero //reset the pitch offset
00238a 9220 291c                 	sts noise_total_pitch_offset+1, zero
00238c 9220 2922                 	sts noise_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
00238e 9631                      	adiw Z, 1 //point to the byte next to the flag
00238f 91b4                      	lpm r27, Z //store the instrument offset into r27
002390 e3eb                      	ldi ZL, LOW(instruments) //point Z to instruments table
002391 e1f1                      	ldi ZH, HIGH(instruments)
002392 0feb                      	add ZL, r27 //point Z to offsetted instrument
002393 1df2                      	adc ZH, zero
002394 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
002395 1fff                      	rol ZH
002396 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
002397 91b4                      	lpm r27, Z
                                 
002398 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
002399 1fbb                      	rol r27
00239a 2fea                      	mov ZL, r26
00239b 2ffb                      	mov ZH, r27
00239c 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
00239d 9632                      	adiw Z, 2 //point Z to the address of the macro
00239e e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel3_instrument_change_macro_loop:
00239f 95aa                      	dec r26
0023a0 f019                      	breq sound_driver_channel3_instrument_change_exit
0023a1 95b6                      	lsr r27
0023a2 f078                      	brcs sound_driver_channel3_instrument_change_load_macro
0023a3 cffb                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_exit:
0023a4 e0a3                      	ldi r26, 0x03
0023a5 e0b2                      	ldi r27, 0x02
0023a6 93b0 2912                 	sts noise_volume_macro_offset, r27 //reset all macro offsets
0023a8 93a0 2917                 	sts noise_arpeggio_macro_offset, r26
0023aa 93b0 291f                 	sts noise_pitch_macro_offset, r27
0023ac 93b0 2925                 	sts noise_hi_pitch_macro_offset, r27
0023ae 93b0 292a                 	sts noise_duty_macro_offset, r27
0023b0 d0ba                      	rcall sound_driver_channel3_increment_offset_twice
0023b1 cdfa                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_load_macro:
0023b2 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
0023b3 91d5                      	lpm r29, Z+
                                 
0023b4 30a5                      	cpi r26, 5
0023b5 f039                      	breq sound_driver_channel3_instrument_change_load_macro_volume
0023b6 30a4                      	cpi r26, 4
0023b7 f079                      	breq sound_driver_channel3_instrument_change_load_macro_arpeggio
0023b8 30a3                      	cpi r26, 3
0023b9 f0d9                      	breq sound_driver_channel3_instrument_change_load_macro_pitch
0023ba 30a2                      	cpi r26, 2
0023bb f159                      	breq sound_driver_channel3_instrument_change_load_macro_hi_pitch
0023bc c03c                      	rjmp sound_driver_channel3_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel3_instrument_change_load_macro_volume:
0023bd 93c0 2910                 	sts noise_volume_macro, r28
0023bf 93d0 2911                 	sts noise_volume_macro+1, r29
0023c1 d041                      	rcall sound_driver_channel3_instrument_change_read_header
0023c2 93c0 2914                 	sts noise_volume_macro_release, r28
0023c4 93d0 2913                 	sts noise_volume_macro_loop, r29
0023c6 cfd8                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 	
                                 sound_driver_channel3_instrument_change_load_macro_arpeggio:
0023c7 93c0 2915                 	sts noise_arpeggio_macro, r28
0023c9 93d0 2916                 	sts noise_arpeggio_macro+1, r29
0023cb 9220 294b                 	sts noise_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0023cd 9220 294c                 	sts noise_fx_Qxy_target+1, zero
0023cf 9220 2951                 	sts noise_fx_Rxy_target, zero
0023d1 9220 2952                 	sts noise_fx_Rxy_target+1, zero
0023d3 d03a                      	rcall sound_driver_channel3_instrument_change_read_header_arpeggio
0023d4 cfca                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_pitch:
0023d5 93c0 291d                 	sts noise_pitch_macro, r28
0023d7 93d0 291e                 	sts noise_pitch_macro+1, r29
0023d9 9220 294b                 	sts noise_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0023db 9220 294c                 	sts noise_fx_Qxy_target+1, zero
0023dd 9220 2951                 	sts noise_fx_Rxy_target, zero
0023df 9220 2952                 	sts noise_fx_Rxy_target+1, zero
0023e1 d021                      	rcall sound_driver_channel3_instrument_change_read_header
0023e2 93c0 2921                 	sts noise_pitch_macro_release, r28
0023e4 93d0 2920                 	sts noise_pitch_macro_loop, r29
0023e6 cfb8                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_hi_pitch:
0023e7 93c0 2923                 	sts noise_hi_pitch_macro, r28
0023e9 93d0 2924                 	sts noise_hi_pitch_macro+1, r29
0023eb 9220 294b                 	sts noise_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0023ed 9220 294c                 	sts noise_fx_Qxy_target+1, zero
0023ef 9220 2951                 	sts noise_fx_Rxy_target, zero
0023f1 9220 2952                 	sts noise_fx_Rxy_target+1, zero
0023f3 d00f                      	rcall sound_driver_channel3_instrument_change_read_header
0023f4 93c0 2927                 	sts noise_hi_pitch_macro_release, r28
0023f6 93d0 2926                 	sts noise_hi_pitch_macro_loop, r29
0023f8 cfa6                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_duty:
0023f9 93c0 2928                 	sts noise_duty_macro, r28
0023fb 93d0 2929                 	sts noise_duty_macro+1, r29
0023fd d005                      	rcall sound_driver_channel3_instrument_change_read_header
0023fe 93c0 292c                 	sts noise_duty_macro_release, r28
002400 93d0 292b                 	sts noise_duty_macro_loop, r29
002402 cf9c                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_read_header:
002403 93ef                      	push ZL
002404 93ff                      	push ZH
002405 2fec                      	mov ZL, r28
002406 2ffd                      	mov ZH, r29
002407 0fee                      	lsl ZL
002408 1fff                      	rol ZH
002409 91c5                      	lpm r28, Z+
00240a 91d4                      	lpm r29, Z
00240b 91ff                      	pop ZH
00240c 91ef                      	pop ZL
00240d 9508                      	ret
                                 
                                 sound_driver_channel3_instrument_change_read_header_arpeggio:
00240e 93ef                      	push ZL
00240f 93ff                      	push ZH
002410 2fec                      	mov ZL, r28
002411 2ffd                      	mov ZH, r29
002412 0fee                      	lsl ZL
002413 1fff                      	rol ZH
002414 91c5                      	lpm r28, Z+
002415 91d5                      	lpm r29, Z+
002416 93c0 2919                 	sts noise_arpeggio_macro_release, r28
002418 93d0 2918                 	sts noise_arpeggio_macro_loop, r29
00241a 91c4                      	lpm r28, Z
00241b 93c0 291a                 	sts noise_arpeggio_macro_mode, r28
00241d 91ff                      	pop ZH
00241e 91ef                      	pop ZL
00241f 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel3_release:
                                 sound_driver_channel3_release_volume:
002420 91b0 2914                 	lds r27, noise_volume_macro_release
002422 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
002423 f019                      	breq sound_driver_channel3_release_arpeggio //if the macro has no release flag, check the next macro
002424 95b3                      	inc r27
002425 93b0 2912                 	sts noise_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel3_release_arpeggio:
002427 91b0 2919                 	lds r27, noise_arpeggio_macro_release
002429 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
00242a f019                      	breq sound_driver_channel3_release_pitch
00242b 95b3                      	inc r27
00242c 93b0 2917                 	sts noise_arpeggio_macro_offset, r27
                                 sound_driver_channel3_release_pitch:
00242e 91b0 2921                 	lds r27, noise_pitch_macro_release
002430 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
002431 f019                      	breq sound_driver_channel3_release_hi_pitch
002432 95b3                      	inc r27
002433 93b0 291f                 	sts noise_pitch_macro_offset, r27
                                 sound_driver_channel3_release_hi_pitch:
002435 91b0 2927                 	lds r27, noise_hi_pitch_macro_release
002437 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
002438 f019                      	breq sound_driver_channel3_release_duty
002439 95b3                      	inc r27
00243a 93b0 2925                 	sts noise_hi_pitch_macro_offset, r27
                                 sound_driver_channel3_release_duty:
00243c 91b0 292c                 	lds r27, noise_duty_macro_release
00243e 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
00243f f019                      	breq sound_driver_channel3_release_exit
002440 95b3                      	inc r27
002441 93b0 292a                 	sts noise_duty_macro_offset, r27
                                 sound_driver_channel3_release_exit:
002443 d01d                      	rcall sound_driver_channel3_increment_offset
002444 cd67                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_next_pattern:
002445 91e0 2818                 	lds ZL, song_frames
002447 91f0 2819                 	lds ZH, song_frames+1
002449 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
00244b 91b0 281b                 	lds r27, song_frame_offset+1
00244d 93a0 281a                 	sts song_frame_offset, r26
00244f 93b0 281b                 	sts song_frame_offset+1, r27
002451 9616                      	adiw r27:r26, 6 //offset for channel 3
002452 0fea                      	add ZL, r26
002453 1ffb                      	adc ZH, r27
                                 
002454 91a5                      	lpm r26, Z+ //load the address of the next pattern
002455 91b4                      	lpm r27, Z
002456 0faa                      	lsl r26
002457 1fbb                      	rol r27
002458 93a0 290a                 	sts noise_pattern, r26
00245a 93b0 290b                 	sts noise_pattern+1, r27
                                 
00245c 9220 290e                 	sts noise_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
00245e 9220 290f                 	sts noise_pattern_offset+1, zero
002460 cd4b                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_increment_offset:
002461 91e0 290e                 	lds ZL, noise_pattern_offset //current offset in the pattern for noise
002463 91f0 290f                 	lds ZH, noise_pattern_offset+1
002465 9631                      	adiw Z, 1
002466 93e0 290e                 	sts noise_pattern_offset, ZL
002468 93f0 290f                 	sts noise_pattern_offset+1, ZH
00246a 9508                      	ret
                                 
                                 sound_driver_channel3_increment_offset_twice: //used for data that takes up 2 bytes worth of space
00246b 91e0 290e                 	lds ZL, noise_pattern_offset //current offset in the pattern for noise
00246d 91f0 290f                 	lds ZH, noise_pattern_offset+1
00246f 9632                      	adiw Z, 2 //increment the pointer twice
002470 93e0 290e                 	sts noise_pattern_offset, ZL
002472 93f0 290f                 	sts noise_pattern_offset+1, ZH
002474 9508                      	ret
                                 
                                 sound_driver_channel3_decrement_frame_delay:
002475 95ba                      	dec r27
002476 93b0 290d                 	sts noise_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel4:
                                 
                                 sound_driver_calculate_delays:
002478 91f0 281e                 	lds r31, song_speed
00247a 2fef                      	mov r30, r31
00247b 50e1                      	subi r30, 1
                                 sound_driver_calculate_delays_pulse1:
00247c 91a0 2825                 	lds r26, pulse1_pattern_delay_frames
00247e 11a2                      	cpse r26, zero
00247f c042                      	rjmp sound_driver_calculate_delays_pulse2
002480 c000                      	rjmp sound_driver_calculate_delays_pulse1_main
                                 
                                 sound_driver_calculate_delays_pulse1_main:
002481 2faf                      	mov r26, r31 //move the speed to r26
002482 91b0 2824                 	lds r27, pulse1_pattern_delay_rows //decrement the delay rows
002484 15b2                      	cp r27, zero
002485 f409                      	brne PC+2
002486 c03b                      	rjmp sound_driver_calculate_delays_pulse2
002487 95ba                      	dec r27
002488 93b0 2824                 	sts pulse1_pattern_delay_rows, r27
00248a 11b2                      	cpse r27, zero
00248b c034                      	rjmp sound_driver_calculate_delays_pulse1_store
00248c 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx:
00248d efbf                      	ldi r27, 0xFF
00248e 91c0 286f                 	lds r28, pulse1_fx_Sxx_pre
002490 91d0 2870                 	lds r29, pulse1_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse1_Sxx_check_pre:
002492 17cb                      	cp r28, r27
002493 f009                      	breq sound_driver_calculate_delays_pulse1_Sxx_check_post
002494 c00d                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_pre
                                 sound_driver_calculate_delays_pulse1_Sxx_check_post:
002495 17db                      	cp r29, r27
002496 f009                      	breq sound_driver_calculate_delays_pulse1_Gxx
002497 c015                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx:
002498 91c0 285f                 	lds r28, pulse1_fx_Gxx_pre
00249a 91d0 2860                 	lds r29, pulse1_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse1_Gxx_check_pre:
00249c 17cb                      	cp r28, r27
00249d f009                      	breq sound_driver_calculate_delays_pulse1_Gxx_check_post
00249e c012                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_pre
                                 sound_driver_calculate_delays_pulse1_Gxx_check_post:
00249f 17db                      	cp r29, r27
0024a0 f0f9                      	breq sound_driver_calculate_delays_pulse1_store
0024a1 c01a                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_pre:
0024a2 93b0 286f                 	sts pulse1_fx_Sxx_pre, r27
0024a4 1bec                      	sub r30, r28 //(song speed)-1-Sxx
0024a5 93e0 2870                 	sts pulse1_fx_Sxx_post, r30
0024a7 95ca                      	dec r28
0024a8 93c0 2825                 	sts pulse1_pattern_delay_frames, r28
0024aa 2fef                      	mov r30, r31
0024ab 50e1                      	subi r30, 1
0024ac c015                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_post:
0024ad 93b0 2870                 	sts pulse1_fx_Sxx_post, r27
0024af 2fad                      	mov r26, r29
0024b0 c00f                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx_pre:
0024b1 93b0 285f                 	sts pulse1_fx_Gxx_pre, r27
0024b3 1bec                      	sub r30, r28 //(song speed)-1-Sxx
0024b4 93e0 2860                 	sts pulse1_fx_Gxx_post, r30
0024b6 95ca                      	dec r28
0024b7 93c0 2825                 	sts pulse1_pattern_delay_frames, r28
0024b9 2fef                      	mov r30, r31
0024ba 50e1                      	subi r30, 1
0024bb c006                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse1_Gxx_post:
0024bc 93b0 2860                 	sts pulse1_fx_Gxx_post, r27
0024be 2fad                      	mov r26, r29
0024bf c000                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_store:
0024c0 93a0 2825                 	sts pulse1_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_pulse2:
0024c2 91a0 2874                 	lds r26, pulse2_pattern_delay_frames
0024c4 11a2                      	cpse r26, zero
0024c5 c042                      	rjmp sound_driver_calculate_delays_triangle
0024c6 c000                      	rjmp sound_driver_calculate_delays_pulse2_main
                                 
                                 sound_driver_calculate_delays_pulse2_main:
0024c7 2faf                      	mov r26, r31 //move the speed to r26
0024c8 91b0 2873                 	lds r27, pulse2_pattern_delay_rows //decrement the delay rows
0024ca 15b2                      	cp r27, zero
0024cb f409                      	brne PC+2
0024cc c03b                      	rjmp sound_driver_calculate_delays_triangle
0024cd 95ba                      	dec r27
0024ce 93b0 2873                 	sts pulse2_pattern_delay_rows, r27
0024d0 11b2                      	cpse r27, zero
0024d1 c034                      	rjmp sound_driver_calculate_delays_pulse2_store
0024d2 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx:
0024d3 efbf                      	ldi r27, 0xFF
0024d4 91c0 28be                 	lds r28, pulse2_fx_Sxx_pre
0024d6 91d0 28bf                 	lds r29, pulse2_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse2_Sxx_check_pre:
0024d8 17cb                      	cp r28, r27
0024d9 f009                      	breq sound_driver_calculate_delays_pulse2_Sxx_check_post
0024da c00d                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_pre
                                 sound_driver_calculate_delays_pulse2_Sxx_check_post:
0024db 17db                      	cp r29, r27
0024dc f009                      	breq sound_driver_calculate_delays_pulse2_Gxx
0024dd c015                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx:
0024de 91c0 28ae                 	lds r28, pulse2_fx_Gxx_pre
0024e0 91d0 28af                 	lds r29, pulse2_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse2_Gxx_check_pre:
0024e2 17cb                      	cp r28, r27
0024e3 f009                      	breq sound_driver_calculate_delays_pulse2_Gxx_check_post
0024e4 c012                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_pre
                                 sound_driver_calculate_delays_pulse2_Gxx_check_post:
0024e5 17db                      	cp r29, r27
0024e6 f0f9                      	breq sound_driver_calculate_delays_pulse2_store
0024e7 c01a                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_pre:
0024e8 93b0 28be                 	sts pulse2_fx_Sxx_pre, r27
0024ea 1bec                      	sub r30, r28 //(song speed)-1-Sxx
0024eb 93e0 28bf                 	sts pulse2_fx_Sxx_post, r30
0024ed 95ca                      	dec r28
0024ee 93c0 2874                 	sts pulse2_pattern_delay_frames, r28
0024f0 2fef                      	mov r30, r31
0024f1 50e1                      	subi r30, 1
0024f2 cfcf                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_post:
0024f3 93b0 28bf                 	sts pulse2_fx_Sxx_post, r27
0024f5 2fad                      	mov r26, r29
0024f6 c00f                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx_pre:
0024f7 93b0 28ae                 	sts pulse2_fx_Gxx_pre, r27
0024f9 1bec                      	sub r30, r28 //(song speed)-1-Sxx
0024fa 93e0 28af                 	sts pulse2_fx_Gxx_post, r30
0024fc 95ca                      	dec r28
0024fd 93c0 2874                 	sts pulse2_pattern_delay_frames, r28
0024ff 2fef                      	mov r30, r31
002500 50e1                      	subi r30, 1
002501 cfc0                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse2_Gxx_post:
002502 93b0 28af                 	sts pulse2_fx_Gxx_post, r27
002504 2fad                      	mov r26, r29
002505 c000                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_store:
002506 93a0 2874                 	sts pulse2_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_triangle:
002508 91a0 28c3                 	lds r26, triangle_pattern_delay_frames
00250a 11a2                      	cpse r26, zero
00250b c042                      	rjmp sound_driver_calculate_delays_noise
00250c c000                      	rjmp sound_driver_calculate_delays_triangle_main
                                 
                                 sound_driver_calculate_delays_triangle_main:
00250d 2faf                      	mov r26, r31 //move the speed to r26
00250e 91b0 28c2                 	lds r27, triangle_pattern_delay_rows //decrement the delay rows
002510 15b2                      	cp r27, zero
002511 f409                      	brne PC+2
002512 c03b                      	rjmp sound_driver_calculate_delays_noise
002513 95ba                      	dec r27
002514 93b0 28c2                 	sts triangle_pattern_delay_rows, r27
002516 11b2                      	cpse r27, zero
002517 c034                      	rjmp sound_driver_calculate_delays_triangle_store
002518 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_triangle_Sxx:
002519 efbf                      	ldi r27, 0xFF
00251a 91c0 2908                 	lds r28, triangle_fx_Sxx_pre
00251c 91d0 2909                 	lds r29, triangle_fx_Sxx_post
                                 sound_driver_calculate_delays_triangle_Sxx_check_pre:
00251e 17cb                      	cp r28, r27
00251f f009                      	breq sound_driver_calculate_delays_triangle_Sxx_check_post
002520 c00d                      	rjmp sound_driver_calculate_delays_triangle_Sxx_pre
                                 sound_driver_calculate_delays_triangle_Sxx_check_post:
002521 17db                      	cp r29, r27
002522 f009                      	breq sound_driver_calculate_delays_triangle_Gxx
002523 c015                      	rjmp sound_driver_calculate_delays_triangle_Sxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Gxx:
002524 91c0 28f8                 	lds r28, triangle_fx_Gxx_pre
002526 91d0 28f9                 	lds r29, triangle_fx_Gxx_post
                                 sound_driver_calculate_delays_triangle_Gxx_check_pre:
002528 17cb                      	cp r28, r27
002529 f009                      	breq sound_driver_calculate_delays_triangle_Gxx_check_post
00252a c012                      	rjmp sound_driver_calculate_delays_triangle_Gxx_pre
                                 sound_driver_calculate_delays_triangle_Gxx_check_post:
00252b 17db                      	cp r29, r27
00252c f0f9                      	breq sound_driver_calculate_delays_triangle_store
00252d c01a                      	rjmp sound_driver_calculate_delays_triangle_Gxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_pre:
00252e 93b0 2908                 	sts triangle_fx_Sxx_pre, r27
002530 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002531 93e0 2909                 	sts triangle_fx_Sxx_post, r30
002533 95ca                      	dec r28
002534 93c0 28c3                 	sts triangle_pattern_delay_frames, r28
002536 2fef                      	mov r30, r31
002537 50e1                      	subi r30, 1
002538 c015                      	rjmp sound_driver_calculate_delays_noise
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_post:
002539 93b0 2909                 	sts triangle_fx_Sxx_post, r27
00253b 2fad                      	mov r26, r29
00253c c00f                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_Gxx_pre:
00253d 93b0 28f8                 	sts triangle_fx_Gxx_pre, r27
00253f 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002540 93e0 28f9                 	sts triangle_fx_Gxx_post, r30
002542 95ca                      	dec r28
002543 93c0 28c3                 	sts triangle_pattern_delay_frames, r28
002545 2fef                      	mov r30, r31
002546 50e1                      	subi r30, 1
002547 c006                      	rjmp sound_driver_calculate_delays_noise
                                 	
                                 sound_driver_calculate_delays_triangle_Gxx_post:
002548 93b0 28f9                 	sts triangle_fx_Gxx_post, r27
00254a 2fad                      	mov r26, r29
00254b c000                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_store:
00254c 93a0 28c3                 	sts triangle_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_noise:
00254e 91a0 290d                 	lds r26, noise_pattern_delay_frames
002550 11a2                      	cpse r26, zero
002551 c042                      	rjmp sound_driver_calculate_delays_dpcm
002552 c000                      	rjmp sound_driver_calculate_delays_noise_main
                                 
                                 sound_driver_calculate_delays_noise_main:
002553 2faf                      	mov r26, r31 //move the speed to r26
002554 91b0 290c                 	lds r27, noise_pattern_delay_rows //decrement the delay rows
002556 15b2                      	cp r27, zero
002557 f409                      	brne PC+2
002558 c03b                      	rjmp sound_driver_calculate_delays_dpcm
002559 95ba                      	dec r27
00255a 93b0 290c                 	sts noise_pattern_delay_rows, r27
00255c 11b2                      	cpse r27, zero
00255d c034                      	rjmp sound_driver_calculate_delays_noise_store
00255e 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_noise_Sxx:
00255f efbf                      	ldi r27, 0xFF
002560 91c0 2957                 	lds r28, noise_fx_Sxx_pre
002562 91d0 2958                 	lds r29, noise_fx_Sxx_post
                                 sound_driver_calculate_delays_noise_Sxx_check_pre:
002564 17cb                      	cp r28, r27
002565 f009                      	breq sound_driver_calculate_delays_noise_Sxx_check_post
002566 c00d                      	rjmp sound_driver_calculate_delays_noise_Sxx_pre
                                 sound_driver_calculate_delays_noise_Sxx_check_post:
002567 17db                      	cp r29, r27
002568 f009                      	breq sound_driver_calculate_delays_noise_Gxx
002569 c015                      	rjmp sound_driver_calculate_delays_noise_Sxx_post
                                 
                                 sound_driver_calculate_delays_noise_Gxx:
00256a 91c0 2947                 	lds r28, noise_fx_Gxx_pre
00256c 91d0 2948                 	lds r29, noise_fx_Gxx_post
                                 sound_driver_calculate_delays_noise_Gxx_check_pre:
00256e 17cb                      	cp r28, r27
00256f f009                      	breq sound_driver_calculate_delays_noise_Gxx_check_post
002570 c012                      	rjmp sound_driver_calculate_delays_noise_Gxx_pre
                                 sound_driver_calculate_delays_noise_Gxx_check_post:
002571 17db                      	cp r29, r27
002572 f0f9                      	breq sound_driver_calculate_delays_noise_store
002573 c01a                      	rjmp sound_driver_calculate_delays_noise_Gxx_post
                                 
                                 sound_driver_calculate_delays_noise_Sxx_pre:
002574 93b0 2957                 	sts noise_fx_Sxx_pre, r27
002576 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002577 93e0 2958                 	sts noise_fx_Sxx_post, r30
002579 95ca                      	dec r28
00257a 93c0 290d                 	sts noise_pattern_delay_frames, r28
00257c 2fef                      	mov r30, r31
00257d 50e1                      	subi r30, 1
00257e c015                      	rjmp sound_driver_calculate_delays_dpcm
                                 
                                 sound_driver_calculate_delays_noise_Sxx_post:
00257f 93b0 2958                 	sts noise_fx_Sxx_post, r27
002581 2fad                      	mov r26, r29
002582 c00f                      	rjmp sound_driver_calculate_delays_noise_store
                                 
                                 sound_driver_calculate_delays_noise_Gxx_pre:
002583 93b0 2947                 	sts noise_fx_Gxx_pre, r27
002585 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002586 93e0 2948                 	sts noise_fx_Gxx_post, r30
002588 95ca                      	dec r28
002589 93c0 290d                 	sts noise_pattern_delay_frames, r28
00258b 2fef                      	mov r30, r31
00258c 50e1                      	subi r30, 1
00258d c006                      	rjmp sound_driver_calculate_delays_dpcm
                                 	
                                 sound_driver_calculate_delays_noise_Gxx_post:
00258e 93b0 2948                 	sts noise_fx_Gxx_post, r27
002590 2fad                      	mov r26, r29
002591 c000                      	rjmp sound_driver_calculate_delays_noise_store
                                 
                                 sound_driver_calculate_delays_noise_store:
002592 93a0 290d                 	sts noise_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_dpcm:
                                 
                                 sound_driver_instrument_fx_routine:
                                 sound_driver_instrument_routine_channel0_volume:
002594 91e0 2828                 	lds ZL, pulse1_volume_macro
002596 91f0 2829                 	lds ZH, pulse1_volume_macro+1
002598 9630                      	adiw Z, 0
002599 f1a1                      	breq sound_driver_instrument_routine_channel0_volume_default //if no volume macro is in use, use default multiplier of F
00259a 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
00259b 1fff                      	rol ZH
00259c 91a0 282a                 	lds r26, pulse1_volume_macro_offset
00259e 0fea                      	add ZL, r26
00259f 1df2                      	adc ZH, zero
                                 
0025a0 91b0 282c                 	lds r27, pulse1_volume_macro_release
0025a2 17ba                      	cp r27, r26
0025a3 f429                      	brne sound_driver_instrument_routine_channel0_volume_increment //if the current offset is not equal to the release index, increment the offset
0025a4 91a0 282b                 	lds r26, pulse1_volume_macro_loop
0025a6 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0025a7 f010                      	brlo sound_driver_instrument_routine_channel0_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0025a8 c003                      	rjmp sound_driver_instrument_routine_channel0_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_volume_increment:
0025a9 95a3                      	inc r26 //increment the macro offset
0025aa 93a0 282a                 	sts pulse1_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_volume_read:
0025ac 91b4                      	lpm r27, Z //load volume data into r27
0025ad 3fbf                      	cpi r27, 0xFF //check for macro end flag
0025ae f469                      	brne sound_driver_instrument_routine_channel0_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_release:
0025af 91b0 282c                 	lds r27, pulse1_volume_macro_release
0025b1 3fbf                      	cpi r27, 0xFF
0025b2 f429                      	brne sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_loop:
0025b3 91b0 282b                 	lds r27, pulse1_volume_macro_loop //load the loop index
0025b5 93b0 282a                 	sts pulse1_volume_macro_offset, r27 //store the loop index into the offset
0025b7 cfdc                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index:
0025b8 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
0025b9 93a0 282a                 	sts pulse1_volume_macro_offset, r26
0025bb cfd8                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_calculate:
0025bc e5ee                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
0025bd e6f5                      	ldi ZH, HIGH(volumes << 1)
0025be 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
0025bf 0feb                      	add ZL, r27 //add offset to the table
0025c0 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel0_volume_load:
0025c1 91b0 2800                 	lds r27, pulse1_param //load main volume
0025c3 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
0025c4 91a0 285d                 	lds r26, pulse1_fx_7xy_value
0025c6 30a0                      	cpi r26, 0x00
0025c7 f481                      	brne sound_driver_instrument_routine_channel0_volume_load_7xy
                                 
0025c8 0feb                      	add ZL, r27 //offset the volume table by the main volume
0025c9 1df2                      	adc ZH, zero
0025ca 91b4                      	lpm r27, Z
0025cb 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
0025cd c024                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default:
0025ce 91b0 2800                 	lds r27, pulse1_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
0025d0 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
0025d1 91a0 285d                 	lds r26, pulse1_fx_7xy_value
0025d3 30a0                      	cpi r26, 0x00
0025d4 f4a1                      	brne sound_driver_instrument_routine_channel0_volume_default_7xy
0025d5 93b0 2806                 	sts pulse1_output_volume, r27
0025d7 c01a                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy:
0025d8 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
0025d9 f040                      	brcs sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
0025da f039                      	breq sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
0025db e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
                                 
0025dc 0feb                      	add ZL, r27 //offset the volume table by the main volume
0025dd 1df2                      	adc ZH, zero
0025de 91b4                      	lpm r27, Z
0025df 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
0025e1 c010                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy_overflow:
0025e2 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
0025e3 0feb                      	add ZL, r27 //offset the volume table by the main volume
0025e4 1df2                      	adc ZH, zero
0025e5 91b4                      	lpm r27, Z
0025e6 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
0025e8 c009                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default_7xy:
0025e9 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
0025ea f020                      	brcs sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
0025eb f019                      	breq sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
0025ec 93b0 2806                 	sts pulse1_output_volume, r27
0025ee c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel0_volume_default_7xy_overflow:
0025ef e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
0025f0 93b0 2806                 	sts pulse1_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
0025f2 91e0 282d                 	lds ZL, pulse1_arpeggio_macro
0025f4 91f0 282e                 	lds ZH, pulse1_arpeggio_macro+1
0025f6 9630                      	adiw Z, 0
0025f7 f1d9                      	breq sound_driver_instrument_routine_channel0_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
0025f8 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0025f9 1fff                      	rol ZH
0025fa 91a0 282f                 	lds r26, pulse1_arpeggio_macro_offset
0025fc 0fea                      	add ZL, r26
0025fd 1df2                      	adc ZH, zero
                                 
0025fe 91b0 2831                 	lds r27, pulse1_arpeggio_macro_release
002600 17ba                      	cp r27, r26
002601 f429                      	brne sound_driver_instrument_routine_channel0_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002602 91a0 2830                 	lds r26, pulse1_arpeggio_macro_loop
002604 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002605 f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002606 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_increment:
002607 95a3                      	inc r26 //increment the macro offset
002608 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_read:
00260a 91b4                      	lpm r27, Z //load arpeggio data into r27
00260b 38b0                      	cpi r27, 0x80 //check for macro end flag
00260c f009                      	breq sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag
00260d c041                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_check_mode:
00260e 50a1                      	subi r26, 1 //keep the offset at the end flag
00260f 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26
002611 91b0 2832                 	lds r27, pulse1_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002613 30b1                      	cpi r27, 0x01
002614 f048                      	brlo sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_release:
002615 91b0 2831                 	lds r27, pulse1_arpeggio_macro_release
002617 3fbf                      	cpi r27, 0xFF
002618 f4d1                      	brne sound_driver_instrument_routine_channel0_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_loop:
002619 91b0 2830                 	lds r27, pulse1_arpeggio_macro_loop
00261b 3fbf                      	cpi r27, 0xFF
00261c f499                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
00261d c015                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute:
00261e 91b0 2831                 	lds r27, pulse1_arpeggio_macro_release
002620 3fbf                      	cpi r27, 0xFF
002621 f421                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_check_loop:
002622 91b0 2830                 	lds r27, pulse1_arpeggio_macro_loop //load the loop index
002624 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002625 f451                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop:
002626 91c0 2845                 	lds r28, pulse1_fx_0xy_sequence //check for 0xy effect
002628 91d0 2846                 	lds r29, pulse1_fx_0xy_sequence+1
00262a 9620                      	adiw r29:r28, 0
00262b f469                      	brne sound_driver_instrument_routine_channel0_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
00262c 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
00262d 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26 //store the last valid index into the offset
00262f cfc2                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload:
002630 93b0 282f                 	sts pulse1_arpeggio_macro_offset, r27 //store the loop index into the offset
002632 cfbf                      	rjmp sound_driver_instrument_routine_channel0_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_default:
002633 91c0 2845                 	lds r28, pulse1_fx_0xy_sequence //load 0xy effect
002635 91d0 2846                 	lds r29, pulse1_fx_0xy_sequence+1
002637 9620                      	adiw r29:r28, 0 //check for 0xy effect
002638 f099                      	breq sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel0_arpeggio_default_xy:
002639 95d6                      	lsr r29
00263a 95c7                      	ror r28
00263b 95d7                      	ror r29
00263c 95c7                      	ror r28
00263d 95d7                      	ror r29
00263e 95c7                      	ror r28
00263f 95d7                      	ror r29
002640 95c7                      	ror r28
002641 95d7                      	ror r29
002642 95d2                      	swap r29
                                 
002643 93c0 2845                 	sts pulse1_fx_0xy_sequence, r28 //store the rolled sequence
002645 93d0 2846                 	sts pulse1_fx_0xy_sequence+1, r29
002647 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002648 91a0 2807                 	lds r26, pulse1_note //load the current note index
00264a 0fac                      	add r26, r28 //add the note offset
00264b c02e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
00264c 91a0 2807                 	lds r26, pulse1_note //load the current note index
00264e c02b                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process:
00264f 9220 2833                 	sts pulse1_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002651 9220 2834                 	sts pulse1_total_pitch_offset+1, zero
002653 9220 283a                 	sts pulse1_total_hi_pitch_offset, zero
002655 91a0 2832                 	lds r26, pulse1_arpeggio_macro_mode
002657 30a1                      	cpi r26, 0x01 //absolute mode
002658 f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_absolute
002659 f069                      	breq sound_driver_instrument_routine_channel0_arpeggio_process_fixed
00265a c00e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute:
00265b 91a0 2807                 	lds r26, pulse1_note //load the current note index
00265d 0fab                      	add r26, r27 //offset the note with the arpeggio data
00265e fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
00265f c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_add:
002660 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002661 f0c0                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
002662 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002663 c016                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract:
002664 fda7                      	sbrc r26, 7 //check if result is negative
002665 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002666 c013                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_fixed:
002667 2fab                      	mov r26, r27 //move the arpeggio data into r26
002668 c011                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative:
002669 91a0 2807                 	lds r26, pulse1_note //load the current note index
00266b 0fab                      	add r26, r27 //offset the note with the arpeggio data
00266c fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
00266d c008                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_add:
00266e 93a0 2807                 	sts pulse1_note, r26 //NOTE: relative mode modifies the original note index
002670 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002671 f040                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
002672 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002673 93a0 2807                 	sts pulse1_note, r26
002675 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract:
002676 fda7                      	sbrc r26, 7 //check if result is negative
002677 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002678 93a0 2807                 	sts pulse1_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_load:
00267a e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
00267b e0f0                      	ldi ZH, HIGH(note_table << 1)
00267c 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
00267d 0fea                      	add ZL, r26 //add offset
00267e 1df2                      	adc ZH, zero
00267f 91a5                      	lpm r26, Z+ //load bytes
002680 91b4                      	lpm r27, Z
002681 93a0 0a8c                 	sts TCB0_CCMPL, r26 //load the LOW bits for timer
002683 93b0 0a8d                 	sts TCB0_CCMPH, r27 //load the HIGH bits for timer
002685 93a0 2851                 	sts pulse1_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002687 93b0 2852                 	sts pulse1_fx_3xx_target+1, r27
002689 c000                      	rjmp sound_driver_instrument_routine_channel0_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch:
00268a 91e0 2835                 	lds ZL, pulse1_pitch_macro
00268c 91f0 2836                 	lds ZH, pulse1_pitch_macro+1
00268e 9630                      	adiw Z, 0
00268f f409                      	brne sound_driver_instrument_routine_channel0_pitch_continue
002690 c023                      	rjmp sound_driver_instrument_routine_channel0_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel0_pitch_continue:
002691 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002692 1fff                      	rol ZH
002693 91a0 2837                 	lds r26, pulse1_pitch_macro_offset
002695 0fea                      	add ZL, r26
002696 1df2                      	adc ZH, zero
                                 
002697 91b0 2839                 	lds r27, pulse1_pitch_macro_release
002699 17ba                      	cp r27, r26
00269a f429                      	brne sound_driver_instrument_routine_channel0_pitch_increment //if the current offset is not equal to the release index, increment the offset
00269b 91a0 2838                 	lds r26, pulse1_pitch_macro_loop
00269d 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00269e f010                      	brlo sound_driver_instrument_routine_channel0_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00269f c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_pitch_increment:
0026a0 95a3                      	inc r26 //increment the macro offset
0026a1 93a0 2837                 	sts pulse1_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_pitch_read:
0026a3 91b4                      	lpm r27, Z //load pitch data into r27
0026a4 38b0                      	cpi r27, 0x80 //check for macro end flag
0026a5 f479                      	brne sound_driver_instrument_routine_channel0_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_release:
0026a6 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0026a7 93a0 2837                 	sts pulse1_pitch_macro_offset, r26
0026a9 91b0 2839                 	lds r27, pulse1_pitch_macro_release
0026ab 3fbf                      	cpi r27, 0xFF
0026ac f439                      	brne sound_driver_instrument_routine_channel0_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_loop:
0026ad 91b0 2838                 	lds r27, pulse1_pitch_macro_loop //load the loop index
0026af 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0026b0 f019                      	breq sound_driver_instrument_routine_channel0_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
0026b1 93b0 2837                 	sts pulse1_pitch_macro_offset, r27 //store the loop index into the offset
0026b3 cfd6                      	rjmp sound_driver_instrument_routine_channel0_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_default:
0026b4 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel0_pitch_calculate:
0026b5 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0026b6 937f                      	push r23
0026b7 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
0026b8 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0026b9 0367                      	mulsu r22, r23
0026ba 917f                      	pop r23
0026bb 916f                      	pop r22
                                 
0026bc 9416                      	lsr r1 //shift out the fractional bits
0026bd 9407                      	ror r0
0026be 9416                      	lsr r1
0026bf 9407                      	ror r0
0026c0 9416                      	lsr r1
0026c1 9407                      	ror r0
0026c2 9416                      	lsr r1
0026c3 9407                      	ror r0
0026c4 fe13                      	sbrs r1, 3 //check if result was a negative number
0026c5 c002                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_negative:
0026c6 efb0                      	ldi r27, 0xF0
0026c7 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_offset:
0026c8 91a0 2833                 	lds r26, pulse1_total_pitch_offset
0026ca 91b0 2834                 	lds r27, pulse1_total_pitch_offset+1
0026cc 0e0a                      	add r0, r26
0026cd 1e1b                      	adc r1, r27
0026ce 9200 2833                 	sts pulse1_total_pitch_offset, r0
0026d0 9210 2834                 	sts pulse1_total_pitch_offset+1, r1
0026d2 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
0026d4 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
0026d6 0da0                      	add r26, r0 //offset the timer values
0026d7 1db1                      	adc r27, r1
                                 	
0026d8 91c0 2849                 	lds r28, pulse1_fx_1xx_total
0026da 91d0 284a                 	lds r29, pulse1_fx_1xx_total+1
0026dc 1bac                      	sub r26, r28
0026dd 0bbd                      	sbc r27, r29
0026de 91c0 284d                 	lds r28, pulse1_fx_2xx_total
0026e0 91d0 284e                 	lds r29, pulse1_fx_2xx_total+1
0026e2 0fac                      	add r26, r28
0026e3 1fbd                      	adc r27, r29
0026e4 91c0 2861                 	lds r28, pulse1_fx_Pxx_total
0026e6 91d0 2862                 	lds r29, pulse1_fx_Pxx_total+1
0026e8 0fac                      	add r26, r28
0026e9 1fbd                      	adc r27, r29
0026ea 91c0 2867                 	lds r28, pulse1_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
0026ec 91d0 2868                 	lds r29, pulse1_fx_Qxy_total_offset+1
0026ee 1bac                      	sub r26, r28
0026ef 0bbd                      	sbc r27, r29
0026f0 91c0 286d                 	lds r28, pulse1_fx_Rxy_total_offset
0026f2 91d0 286e                 	lds r29, pulse1_fx_Rxy_total_offset+1
0026f4 0fac                      	add r26, r28
0026f5 1fbd                      	adc r27, r29
                                 
0026f6 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
0026f8 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel0_hi_pitch:
0026fa 91e0 283b                 	lds ZL, pulse1_hi_pitch_macro
0026fc 91f0 283c                 	lds ZH, pulse1_hi_pitch_macro+1
0026fe 9630                      	adiw Z, 0
0026ff f409                      	brne sound_driver_instrument_routine_channel0_hi_pitch_continue
002700 c03c                      	rjmp sound_driver_instrument_routine_channel0_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel0_hi_pitch_continue:
002701 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002702 1fff                      	rol ZH
002703 91a0 283d                 	lds r26, pulse1_hi_pitch_macro_offset
002705 0fea                      	add ZL, r26
002706 1df2                      	adc ZH, zero
                                 
002707 91b0 283f                 	lds r27, pulse1_hi_pitch_macro_release
002709 17ba                      	cp r27, r26
00270a f429                      	brne sound_driver_instrument_routine_channel0_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
00270b 91a0 283e                 	lds r26, pulse1_hi_pitch_macro_loop
00270d 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00270e f010                      	brlo sound_driver_instrument_routine_channel0_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00270f c003                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_increment:
002710 95a3                      	inc r26 //increment the macro offset
002711 93a0 283d                 	sts pulse1_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_hi_pitch_read:
002713 91b4                      	lpm r27, Z //load hi pitch data into r27
002714 38b0                      	cpi r27, 0x80 //check for macro end flag
002715 f489                      	brne sound_driver_instrument_routine_channel0_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_release:
002716 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002717 93a0 283d                 	sts pulse1_hi_pitch_macro_offset, r26
002719 91b0 283f                 	lds r27, pulse1_hi_pitch_macro_release
00271b 3fbf                      	cpi r27, 0xFF
00271c f439                      	brne sound_driver_instrument_routine_channel0_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_loop:
00271d 91b0 283e                 	lds r27, pulse1_hi_pitch_macro_loop //load the loop index
00271f 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002720 f019                      	breq sound_driver_instrument_routine_channel0_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002721 93b0 283d                 	sts pulse1_hi_pitch_macro_offset, r27 //store the loop index into the offset
002723 cfd6                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_default:
002724 91b0 283a                 	lds r27, pulse1_total_hi_pitch_offset
002726 c005                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate:
002727 91a0 283a                 	lds r26, pulse1_total_hi_pitch_offset //load the total hi pitch offset to change
002729 0fba                      	add r27, r26
00272a 93b0 283a                 	sts pulse1_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply:
00272c 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00272d 937f                      	push r23
00272e 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
00272f eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002730 0367                      	mulsu r22, r23
002731 917f                      	pop r23
002732 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_offset:
002733 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
002735 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
002737 0da0                      	add r26, r0 //offset the timer values
002738 1db1                      	adc r27, r1
002739 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
00273b 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel0_duty:
00273d 91e0 2840                 	lds ZL, pulse1_duty_macro
00273f 91f0 2841                 	lds ZH, pulse1_duty_macro+1
002741 9630                      	adiw Z, 0
002742 f1b1                      	breq sound_driver_channel0_fx_routines //if no duty macro is in use, go to the next routine
002743 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002744 1fff                      	rol ZH
002745 91a0 2842                 	lds r26, pulse1_duty_macro_offset
002747 0fea                      	add ZL, r26
002748 1df2                      	adc ZH, zero
                                 
002749 91b0 2844                 	lds r27, pulse1_duty_macro_release
00274b 17ba                      	cp r27, r26
00274c f429                      	brne sound_driver_instrument_routine_channel0_duty_increment //if the current offset is not equal to the release index, increment the offset
00274d 91a0 2843                 	lds r26, pulse1_duty_macro_loop
00274f 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002750 f010                      	brlo sound_driver_instrument_routine_channel0_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002751 c027                      	rjmp sound_driver_channel0_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel0_duty_increment:
002752 95a3                      	inc r26 //increment the macro offset
002753 93a0 2842                 	sts pulse1_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_duty_read:
002755 91b4                      	lpm r27, Z //load pitch data into r27
002756 3fbf                      	cpi r27, 0xFF //check for macro end flag
002757 f471                      	brne sound_driver_instrument_routine_channel0_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_release:
002758 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002759 93a0 2842                 	sts pulse1_duty_macro_offset, r26
00275b 91b0 2844                 	lds r27, pulse1_duty_macro_release
00275d 3fbf                      	cpi r27, 0xFF
00275e f4d1                      	brne sound_driver_channel0_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_loop:
00275f 91b0 2843                 	lds r27, pulse1_duty_macro_loop //load the loop index
002761 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002762 f0b1                      	breq sound_driver_channel0_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
002763 93b0 2842                 	sts pulse1_duty_macro_offset, r27 //store the loop index into the offset
002765 cfd7                      	rjmp sound_driver_instrument_routine_channel0_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_load:
002766 e8ea                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
002767 e6f4                      	ldi ZH, HIGH(sequences << 1)
002768 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
002769 1df2                      	adc ZH, zero
                                 
00276a 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
00276b 95b7                      	ror r27
00276c 95b7                      	ror r27
00276d 91a0 2800                 	lds r26, pulse1_param //load r26 with pulse1_param (register $4000)
00276f 2fca                      	mov r28, r26 //store a copy of pulse1_param into r28
002770 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
002771 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
002772 c001                      	rjmp sound_driver_instrument_routine_channel0_duty_load_store
002773 c005                      	rjmp sound_driver_channel0_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel0_duty_load_store:
002774 90a4                      	lpm pulse1_sequence, Z //store the sequence
                                 
002775 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
002776 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
002777 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_routines:
                                 sound_driver_channel0_fx_1xx_routine:
002779 91e0 2847                 	lds ZL, pulse1_fx_1xx
00277b 91f0 2848                 	lds ZH, pulse1_fx_1xx+1
00277d 9630                      	adiw Z, 0
00277e f051                      	breq sound_driver_channel0_fx_2xx_routine
                                 
00277f 91a0 2849                 	lds r26, pulse1_fx_1xx_total //load the rate to change the pitch by
002781 91b0 284a                 	lds r27, pulse1_fx_1xx_total+1
002783 0fae                      	add r26, ZL //increase the total offset by the rate
002784 1fbf                      	adc r27, ZH
002785 93a0 2849                 	sts pulse1_fx_1xx_total, r26
002787 93b0 284a                 	sts pulse1_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_2xx_routine:
002789 91e0 284b                 	lds ZL, pulse1_fx_2xx
00278b 91f0 284c                 	lds ZH, pulse1_fx_2xx+1
00278d 9630                      	adiw Z, 0
00278e f051                      	breq sound_driver_channel0_fx_3xx_routine
                                 
00278f 91a0 284d                 	lds r26, pulse1_fx_2xx_total //load the rate to change the pitch by
002791 91b0 284e                 	lds r27, pulse1_fx_2xx_total+1
002793 0fae                      	add r26, ZL //increase the total offset by the rate
002794 1fbf                      	adc r27, ZH
002795 93a0 284d                 	sts pulse1_fx_2xx_total, r26
002797 93b0 284e                 	sts pulse1_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_3xx_routine:
002799 91e0 2853                 	lds ZL, pulse1_fx_3xx_speed
00279b 91f0 2854                 	lds ZH, pulse1_fx_3xx_speed+1
00279d 9630                      	adiw Z, 0
00279e f409                      	brne sound_driver_channel0_fx_3xx_routine_check_start
00279f c048                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_check_start:
0027a0 91a0 284f                 	lds r26, pulse1_fx_3xx_start
0027a2 91b0 2850                 	lds r27, pulse1_fx_3xx_start+1
0027a4 9610                      	adiw r26:r27, 0
0027a5 f409                      	brne sound_driver_channel0_fx_3xx_routine_main
0027a6 c041                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_main:
0027a7 91c0 2851                 	lds r28, pulse1_fx_3xx_target
0027a9 91d0 2852                 	lds r29, pulse1_fx_3xx_target+1
                                 
0027ab 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
0027ac 07bd                      	cpc r27, r29
0027ad f011                      	breq sound_driver_channel0_fx_3xx_routine_disable
0027ae f030                      	brlo sound_driver_channel0_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
0027af c01f                      	rjmp sound_driver_channel0_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel0_fx_3xx_routine_disable:
0027b0 9220 284f                 	sts pulse1_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
0027b2 9220 2850                 	sts pulse1_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
0027b4 c033                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_subtract:
0027b5 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
0027b6 0bdb                      	sbc r29, r27
0027b7 91a0 2855                 	lds r26, pulse1_fx_3xx_total_offset
0027b9 91b0 2856                 	lds r27, pulse1_fx_3xx_total_offset+1
                                 
0027bb 0fae                      	add r26, ZL //add the speed to the total offset
0027bc 1fbf                      	adc r27, ZH
0027bd 1bca                      	sub r28, r26 //invert the total difference with the total offset
0027be 0bdb                      	sbc r29, r27
0027bf f380                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0027c0 93a0 2855                 	sts pulse1_fx_3xx_total_offset, r26 //store the new total offset
0027c2 93b0 2856                 	sts pulse1_fx_3xx_total_offset+1, r27
                                 
0027c4 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the current timer period
0027c6 91b0 0a8d                 	lds r27, TCB0_CCMPH
0027c8 1bac                      	sub r26, r28 //offset the current timer period with the total offset
0027c9 0bbd                      	sbc r27, r29
0027ca 93a0 0a8c                 	sts TCB0_CCMPL, r26
0027cc 93b0 0a8d                 	sts TCB0_CCMPH, r27
0027ce c019                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_add:
0027cf 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
0027d0 0bbd                      	sbc r27, r29
0027d1 91c0 2855                 	lds r28, pulse1_fx_3xx_total_offset
0027d3 91d0 2856                 	lds r29, pulse1_fx_3xx_total_offset+1
                                 
0027d5 0fce                      	add r28, ZL //add the speed to the total offset
0027d6 1fdf                      	adc r29, ZH
0027d7 1bac                      	sub r26, r28 //invert the total difference with the total offset
0027d8 0bbd                      	sbc r27, r29
0027d9 f2b0                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0027da 93c0 2855                 	sts pulse1_fx_3xx_total_offset, r28 //store the new total offset
0027dc 93d0 2856                 	sts pulse1_fx_3xx_total_offset+1, r29
                                 
0027de 91c0 0a8c                 	lds r28, TCB0_CCMPL //load the current timer period
0027e0 91d0 0a8d                 	lds r29, TCB0_CCMPH
0027e2 0fca                      	add r28, r26 //offset the current timer period with the total offset
0027e3 1fdb                      	adc r29, r27
0027e4 93c0 0a8c                 	sts TCB0_CCMPL, r28
0027e6 93d0 0a8d                 	sts TCB0_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel0_fx_4xy_routine:
0027e8 91a0 2857                 	lds r26, pulse1_fx_4xy_speed
0027ea 15a2                      	cp r26, zero
0027eb f409                      	brne sound_driver_channel0_fx_4xy_routine_continue
0027ec c05c                      	rjmp sound_driver_channel0_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel0_fx_4xy_routine_continue:
0027ed 91b0 2858                 	lds r27, pulse1_fx_4xy_depth
0027ef 91c0 2859                 	lds r28, pulse1_fx_4xy_phase
0027f1 0fca                      	add r28, r26 //increase the phase by the speed
0027f2 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
0027f3 f008                      	brlo sound_driver_channel0_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
0027f4 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase:
0027f5 93c0 2859                 	sts pulse1_fx_4xy_phase, r28 //store the new phase
0027f7 31c0                      	cpi r28, 16
0027f8 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_0
0027f9 32c0                      	cpi r28, 32
0027fa f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_1
0027fb 33c0                      	cpi r28, 48
0027fc f030                      	brlo sound_driver_channel0_fx_4xy_routine_phase_2
0027fd c007                      	rjmp sound_driver_channel0_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_0:
0027fe 70cf                      	andi r28, 0x0F //mask for values 0-15
0027ff c029                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_1:
002800 6fc0                      	ori r28, 0xF0
002801 95c0                      	com r28 //invert values 0-15
002802 c026                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_2:
002803 70cf                      	andi r28, 0x0F //mask for values 0-15
002804 c003                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_3:
002805 6fc0                      	ori r28, 0xF0
002806 95c0                      	com r28 //invert values 0-15
002807 c000                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_add:
002808 95b2                      	swap r27 //multiply depth by 16
002809 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
00280a e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00280b e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00280c 0fec                      	add ZL, r28 //offset the table by the depth+phase
00280d 1df2                      	adc ZH, zero
00280e 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
00280f 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002810 937f                      	push r23
002811 2f6c                      	mov r22, r28 //store the vibrato value into r22
002812 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002813 9f67                      	mul r22, r23
002814 917f                      	pop r23
002815 916f                      	pop r22
                                 
002816 9416                      	lsr r1 //shift out the fractional bits
002817 9407                      	ror r0
002818 9416                      	lsr r1
002819 9407                      	ror r0
00281a 9416                      	lsr r1
00281b 9407                      	ror r0
00281c 9416                      	lsr r1
00281d 9407                      	ror r0
                                 	
00281e 91a0 0a8c                 	lds r26, TCB0_CCMPL
002820 91b0 0a8d                 	lds r27, TCB0_CCMPH
002822 0da0                      	add r26, r0
002823 1db1                      	adc r27, r1
002824 93a0 0a8c                 	sts TCB0_CCMPL, r26
002826 93b0 0a8d                 	sts TCB0_CCMPH, r27
002828 c020                      	rjmp sound_driver_channel0_fx_7xy_routine
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_subtract:
002829 95b2                      	swap r27 //multiply depth by 16
00282a 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
00282b e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00282c e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00282d 0fec                      	add ZL, r28 //offset the table by the depth+phase
00282e 1df2                      	adc ZH, zero
00282f 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002830 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002831 937f                      	push r23
002832 2f6c                      	mov r22, r28 //store the vibrato value into r22
002833 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002834 9f67                      	mul r22, r23
002835 917f                      	pop r23
002836 916f                      	pop r22
                                 
002837 9416                      	lsr r1 //shift out the fractional bits
002838 9407                      	ror r0
002839 9416                      	lsr r1
00283a 9407                      	ror r0
00283b 9416                      	lsr r1
00283c 9407                      	ror r0
00283d 9416                      	lsr r1
00283e 9407                      	ror r0
                                 
00283f 91a0 0a8c                 	lds r26, TCB0_CCMPL
002841 91b0 0a8d                 	lds r27, TCB0_CCMPH
002843 19a0                      	sub r26, r0
002844 09b1                      	sbc r27, r1
002845 93a0 0a8c                 	sts TCB0_CCMPL, r26
002847 93b0 0a8d                 	sts TCB0_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_7xy_routine:
002849 91a0 285a                 	lds r26, pulse1_fx_7xy_speed
00284b 15a2                      	cp r26, zero
00284c f0f1                      	breq sound_driver_channel0_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
00284d 91b0 285b                 	lds r27, pulse1_fx_7xy_depth
00284f 91c0 285c                 	lds r28, pulse1_fx_7xy_phase
002851 0fca                      	add r28, r26 //increase the phase by the speed
002852 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
002853 f010                      	brlo sound_driver_channel0_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
002854 e0c0                      	ldi r28, 0x00
002855 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase:
002856 93c0 285c                 	sts pulse1_fx_7xy_phase, r28 //store the new phase
002858 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
002859 ffc4                      	sbrs r28, 4
00285a c001                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_0
00285b c002                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel0_fx_7xy_routine_phase_0:
00285c 70cf                      	andi r28, 0x0F //mask for values 0-15
00285d c003                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase_1:
00285e 6fc0                      	ori r28, 0xF0
00285f 95c0                      	com r28 //invert values 0-15
002860 c000                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_load:
002861 95b2                      	swap r27 //multiply depth by 16
002862 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002863 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002864 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002865 0fec                      	add ZL, r28 //offset the table by the depth+phase
002866 1df2                      	adc ZH, zero
002867 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002868 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
002869 93c0 285d                 	sts pulse1_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Axy_routine:
00286b 91b0 285e                 	lds r27, pulse1_fx_Axy
00286d 15b2                      	cp r27, zero
00286e f0e9                      	breq sound_driver_channel0_fx_Qxy_routine //0 means that the effect is not in use
                                 	
00286f 91a0 2805                 	lds r26, pulse1_fractional_volume //load fractional volume representation of the channel
002871 91c0 2800                 	lds r28, pulse1_param //load the integer volume representation of the channel
002873 2fda                      	mov r29, r26 //copy fractional volume into r29
002874 2fec                      	mov r30, r28 //copy the pulse1_param into r30
002875 95e2                      	swap r30
002876 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
002877 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
002878 17ed                      	cp r30, r29 //compare the fractional and integer volumes
002879 f009                      	breq sound_driver_channel0_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel0_fx_Axy_routine_reload:
00287a 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate:
00287b fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
00287c c004                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_addition:
00287d 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
00287e f428                      	brcc sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
00287f efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
002880 c003                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_subtraction:
002881 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002882 f008                      	brcs sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002883 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_store:
002884 93a0 2805                 	sts pulse1_fractional_volume, r26 //store the new fractional volume
002886 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
002887 95a2                      	swap r26
002888 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
002889 2bca                      	or r28, r26 //store the new volume back into pulse1_param
00288a 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel0_fx_Qxy_routine:
00288c 91e0 2863                 	lds ZL, pulse1_fx_Qxy_target
00288e 91f0 2864                 	lds ZH, pulse1_fx_Qxy_target+1
002890 9630                      	adiw Z, 0
002891 f139                      	breq sound_driver_channel0_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002892 91a0 2867                 	lds r26, pulse1_fx_Qxy_total_offset
002894 91b0 2868                 	lds r27, pulse1_fx_Qxy_total_offset+1
002896 91c0 0a8c                 	lds r28, TCB0_CCMPL
002898 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
00289a 1bec                      	sub ZL, r28 //calculate the difference to the target
00289b 0bfd                      	sbc ZH, r29
00289c f408                      	brsh sound_driver_channel0_fx_Qxy_routine_end //if the target has been reached (or passed)
00289d f088                      	brlo sound_driver_channel0_fx_Qxy_routine_add
                                 
                                 sound_driver_channel0_fx_Qxy_routine_end:
00289e 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
00289f 0bbf                      	sbc r27, ZH
                                 
0028a0 91c0 2861                 	lds r28, pulse1_fx_Pxx_total
0028a2 91d0 2862                 	lds r29, pulse1_fx_Pxx_total+1
                                 
0028a4 0fac                      	add r26, r28
0028a5 1fbd                      	adc r27, r29
                                 
0028a6 93a0 2867                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
0028a8 93b0 2868                 	sts pulse1_fx_Qxy_total_offset+1, r27
0028aa 9220 2863                 	sts pulse1_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
0028ac 9220 2864                 	sts pulse1_fx_Qxy_target+1, zero
0028ae c00a                      	rjmp sound_driver_channel0_fx_Rxy_routine
                                 
                                 sound_driver_channel0_fx_Qxy_routine_add:
0028af 91c0 2865                 	lds r28, pulse1_fx_Qxy_speed
0028b1 91d0 2866                 	lds r29, pulse1_fx_Qxy_speed+1
0028b3 0fac                      	add r26, r28 //increase the total offset by the speed
0028b4 1fbd                      	adc r27, r29
0028b5 93a0 2867                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
0028b7 93b0 2868                 	sts pulse1_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Rxy_routine:
0028b9 91e0 2869                 	lds ZL, pulse1_fx_Rxy_target
0028bb 91f0 286a                 	lds ZH, pulse1_fx_Rxy_target+1
0028bd 9630                      	adiw Z, 0
0028be f139                      	breq sound_driver_instrument_routine_channel1_volume //if the effect is not enabled, skip the routine
                                 
0028bf 91a0 286d                 	lds r26, pulse1_fx_Rxy_total_offset
0028c1 91b0 286e                 	lds r27, pulse1_fx_Rxy_total_offset+1
0028c3 91c0 0a8c                 	lds r28, TCB0_CCMPL
0028c5 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
0028c7 1bce                      	sub r28, ZL //calculate the difference to the target
0028c8 0bdf                      	sbc r29, ZH
0028c9 f408                      	brsh sound_driver_channel0_fx_Rxy_routine_end //if the target has been reached (or passed)
0028ca f088                      	brlo sound_driver_channel0_fx_Rxy_routine_add
                                 
                                 sound_driver_channel0_fx_Rxy_routine_end:
0028cb 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
0028cc 0bbd                      	sbc r27, r29
                                 
0028cd 91c0 2861                 	lds r28, pulse1_fx_Pxx_total
0028cf 91d0 2862                 	lds r29, pulse1_fx_Pxx_total+1
                                 
0028d1 0fac                      	add r26, r28
0028d2 1fbd                      	adc r27, r29
                                 
0028d3 93a0 286d                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
0028d5 93b0 286e                 	sts pulse1_fx_Rxy_total_offset+1, r27
0028d7 9220 2869                 	sts pulse1_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
0028d9 9220 286a                 	sts pulse1_fx_Rxy_target+1, zero
0028db c00a                      	rjmp sound_driver_instrument_routine_channel1_volume
                                 
                                 sound_driver_channel0_fx_Rxy_routine_add:
0028dc 91c0 286b                 	lds r28, pulse1_fx_Rxy_speed
0028de 91d0 286c                 	lds r29, pulse1_fx_Rxy_speed+1
0028e0 0fac                      	add r26, r28 //increase the total offset by the speed
0028e1 1fbd                      	adc r27, r29
0028e2 93a0 286d                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
0028e4 93b0 286e                 	sts pulse1_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume:
0028e6 91e0 2877                 	lds ZL, pulse2_volume_macro
0028e8 91f0 2878                 	lds ZH, pulse2_volume_macro+1
0028ea 9630                      	adiw Z, 0
0028eb f1a1                      	breq sound_driver_instrument_routine_channel1_volume_default //if no volume macro is in use, use default multiplier of F
0028ec 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0028ed 1fff                      	rol ZH
0028ee 91a0 2879                 	lds r26, pulse2_volume_macro_offset
0028f0 0fea                      	add ZL, r26
0028f1 1df2                      	adc ZH, zero
                                 
0028f2 91b0 287b                 	lds r27, pulse2_volume_macro_release
0028f4 17ba                      	cp r27, r26
0028f5 f429                      	brne sound_driver_instrument_routine_channel1_volume_increment //if the current offset is not equal to the release index, increment the offset
0028f6 91a0 287a                 	lds r26, pulse2_volume_macro_loop
0028f8 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0028f9 f010                      	brlo sound_driver_instrument_routine_channel1_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0028fa c003                      	rjmp sound_driver_instrument_routine_channel1_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_volume_increment:
0028fb 95a3                      	inc r26 //increment the macro offset
0028fc 93a0 2879                 	sts pulse2_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_volume_read:
0028fe 91b4                      	lpm r27, Z //load volume data into r27
0028ff 3fbf                      	cpi r27, 0xFF //check for macro end flag
002900 f469                      	brne sound_driver_instrument_routine_channel1_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_release:
002901 91b0 287b                 	lds r27, pulse2_volume_macro_release
002903 3fbf                      	cpi r27, 0xFF
002904 f429                      	brne sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_loop:
002905 91b0 287a                 	lds r27, pulse2_volume_macro_loop //load the loop index
002907 93b0 2879                 	sts pulse2_volume_macro_offset, r27 //store the loop index into the offset
002909 cfdc                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index:
00290a 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
00290b 93a0 2879                 	sts pulse2_volume_macro_offset, r26
00290d cfd8                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_calculate:
00290e e5ee                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
00290f e6f5                      	ldi ZH, HIGH(volumes << 1)
002910 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
002911 0feb                      	add ZL, r27 //add offset to the table
002912 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel1_volume_load:
002913 91b0 2808                 	lds r27, pulse2_param //load main volume
002915 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002916 91a0 28ac                 	lds r26, pulse2_fx_7xy_value
002918 30a0                      	cpi r26, 0x00
002919 f481                      	brne sound_driver_instrument_routine_channel1_volume_load_7xy
                                 
00291a 0feb                      	add ZL, r27 //offset the volume table by the main volume
00291b 1df2                      	adc ZH, zero
00291c 91b4                      	lpm r27, Z
00291d 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
00291f c024                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default:
002920 91b0 2808                 	lds r27, pulse2_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
002922 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002923 91a0 28ac                 	lds r26, pulse2_fx_7xy_value
002925 30a0                      	cpi r26, 0x00
002926 f4a1                      	brne sound_driver_instrument_routine_channel1_volume_default_7xy
002927 93b0 280e                 	sts pulse2_output_volume, r27
002929 c01a                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy:
00292a 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
00292b f040                      	brcs sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
00292c f039                      	breq sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
00292d e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
                                 
00292e 0feb                      	add ZL, r27 //offset the volume table by the main volume
00292f 1df2                      	adc ZH, zero
002930 91b4                      	lpm r27, Z
002931 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
002933 c010                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy_overflow:
002934 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002935 0feb                      	add ZL, r27 //offset the volume table by the main volume
002936 1df2                      	adc ZH, zero
002937 91b4                      	lpm r27, Z
002938 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
00293a c009                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default_7xy:
00293b 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
00293c f020                      	brcs sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
00293d f019                      	breq sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
00293e 93b0 280e                 	sts pulse2_output_volume, r27
002940 c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel1_volume_default_7xy_overflow:
002941 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002942 93b0 280e                 	sts pulse2_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002944 91e0 287c                 	lds ZL, pulse2_arpeggio_macro
002946 91f0 287d                 	lds ZH, pulse2_arpeggio_macro+1
002948 9630                      	adiw Z, 0
002949 f1d9                      	breq sound_driver_instrument_routine_channel1_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
00294a 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
00294b 1fff                      	rol ZH
00294c 91a0 287e                 	lds r26, pulse2_arpeggio_macro_offset
00294e 0fea                      	add ZL, r26
00294f 1df2                      	adc ZH, zero
                                 
002950 91b0 2880                 	lds r27, pulse2_arpeggio_macro_release
002952 17ba                      	cp r27, r26
002953 f429                      	brne sound_driver_instrument_routine_channel1_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002954 91a0 287f                 	lds r26, pulse2_arpeggio_macro_loop
002956 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002957 f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002958 c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_increment:
002959 95a3                      	inc r26 //increment the macro offset
00295a 93a0 287e                 	sts pulse2_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_read:
00295c 91b4                      	lpm r27, Z //load arpeggio data into r27
00295d 38b0                      	cpi r27, 0x80 //check for macro end flag
00295e f009                      	breq sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag
00295f c041                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_check_mode:
002960 50a1                      	subi r26, 1 //keep the offset at the end flag
002961 93a0 287e                 	sts pulse2_arpeggio_macro_offset, r26
002963 91b0 2881                 	lds r27, pulse2_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002965 30b1                      	cpi r27, 0x01
002966 f048                      	brlo sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_release:
002967 91b0 2880                 	lds r27, pulse2_arpeggio_macro_release
002969 3fbf                      	cpi r27, 0xFF
00296a f4d1                      	brne sound_driver_instrument_routine_channel1_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_loop:
00296b 91b0 287f                 	lds r27, pulse2_arpeggio_macro_loop
00296d 3fbf                      	cpi r27, 0xFF
00296e f499                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
00296f c015                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute:
002970 91b0 2880                 	lds r27, pulse2_arpeggio_macro_release
002972 3fbf                      	cpi r27, 0xFF
002973 f421                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_check_loop:
002974 91b0 287f                 	lds r27, pulse2_arpeggio_macro_loop //load the loop index
002976 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002977 f451                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop:
002978 91c0 2894                 	lds r28, pulse2_fx_0xy_sequence //check for 0xy effect
00297a 91d0 2895                 	lds r29, pulse2_fx_0xy_sequence+1
00297c 9620                      	adiw r29:r28, 0
00297d f469                      	brne sound_driver_instrument_routine_channel1_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
00297e 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
00297f 93a0 287e                 	sts pulse2_arpeggio_macro_offset, r26 //store the last valid index into the offset
002981 cfc2                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload:
002982 93b0 287e                 	sts pulse2_arpeggio_macro_offset, r27 //store the loop index into the offset
002984 cfbf                      	rjmp sound_driver_instrument_routine_channel1_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_default:
002985 91c0 2894                 	lds r28, pulse2_fx_0xy_sequence //load 0xy effect
002987 91d0 2895                 	lds r29, pulse2_fx_0xy_sequence+1
002989 9620                      	adiw r29:r28, 0 //check for 0xy effect
00298a f099                      	breq sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel1_arpeggio_default_xy:
00298b 95d6                      	lsr r29
00298c 95c7                      	ror r28
00298d 95d7                      	ror r29
00298e 95c7                      	ror r28
00298f 95d7                      	ror r29
002990 95c7                      	ror r28
002991 95d7                      	ror r29
002992 95c7                      	ror r28
002993 95d7                      	ror r29
002994 95d2                      	swap r29
                                 
002995 93c0 2894                 	sts pulse2_fx_0xy_sequence, r28 //store the rolled sequence
002997 93d0 2895                 	sts pulse2_fx_0xy_sequence+1, r29
002999 70cf                      	andi r28, 0x0F //mask out the 4 LSB
00299a 91a0 280f                 	lds r26, pulse2_note //load the current note index
00299c 0fac                      	add r26, r28 //add the note offset
00299d c02e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
00299e 91a0 280f                 	lds r26, pulse2_note //load the current note index
0029a0 c02b                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process:
0029a1 9220 2882                 	sts pulse2_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
0029a3 9220 2883                 	sts pulse2_total_pitch_offset+1, zero
0029a5 9220 2889                 	sts pulse2_total_hi_pitch_offset, zero
0029a7 91a0 2881                 	lds r26, pulse2_arpeggio_macro_mode
0029a9 30a1                      	cpi r26, 0x01 //absolute mode
0029aa f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_absolute
0029ab f069                      	breq sound_driver_instrument_routine_channel1_arpeggio_process_fixed
0029ac c00e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute:
0029ad 91a0 280f                 	lds r26, pulse2_note //load the current note index
0029af 0fab                      	add r26, r27 //offset the note with the arpeggio data
0029b0 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0029b1 c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_add:
0029b2 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0029b3 f0c0                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
0029b4 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0029b5 c016                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract:
0029b6 fda7                      	sbrc r26, 7 //check if result is negative
0029b7 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0029b8 c013                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_fixed:
0029b9 2fab                      	mov r26, r27 //move the arpeggio data into r26
0029ba c011                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative:
0029bb 91a0 280f                 	lds r26, pulse2_note //load the current note index
0029bd 0fab                      	add r26, r27 //offset the note with the arpeggio data
0029be fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0029bf c008                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_add:
0029c0 93a0 280f                 	sts pulse2_note, r26 //NOTE: relative mode modifies the original note index
0029c2 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0029c3 f040                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
0029c4 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0029c5 93a0 280f                 	sts pulse2_note, r26
0029c7 c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract:
0029c8 fda7                      	sbrc r26, 7 //check if result is negative
0029c9 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0029ca 93a0 280f                 	sts pulse2_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_load:
0029cc e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0029cd e0f0                      	ldi ZH, HIGH(note_table << 1)
0029ce 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
0029cf 0fea                      	add ZL, r26 //add offset
0029d0 1df2                      	adc ZH, zero
0029d1 91a5                      	lpm r26, Z+ //load bytes
0029d2 91b4                      	lpm r27, Z
0029d3 93a0 0a9c                 	sts TCB1_CCMPL, r26 //load the LOW bits for timer
0029d5 93b0 0a9d                 	sts TCB1_CCMPH, r27 //load the HIGH bits for timer
0029d7 93a0 28a0                 	sts pulse2_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
0029d9 93b0 28a1                 	sts pulse2_fx_3xx_target+1, r27
0029db c000                      	rjmp sound_driver_instrument_routine_channel1_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch:
0029dc 91e0 2884                 	lds ZL, pulse2_pitch_macro
0029de 91f0 2885                 	lds ZH, pulse2_pitch_macro+1
0029e0 9630                      	adiw Z, 0
0029e1 f409                      	brne sound_driver_instrument_routine_channel1_pitch_continue
0029e2 c023                      	rjmp sound_driver_instrument_routine_channel1_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel1_pitch_continue:
0029e3 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0029e4 1fff                      	rol ZH
0029e5 91a0 2886                 	lds r26, pulse2_pitch_macro_offset
0029e7 0fea                      	add ZL, r26
0029e8 1df2                      	adc ZH, zero
                                 
0029e9 91b0 2888                 	lds r27, pulse2_pitch_macro_release
0029eb 17ba                      	cp r27, r26
0029ec f429                      	brne sound_driver_instrument_routine_channel1_pitch_increment //if the current offset is not equal to the release index, increment the offset
0029ed 91a0 2887                 	lds r26, pulse2_pitch_macro_loop
0029ef 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0029f0 f010                      	brlo sound_driver_instrument_routine_channel1_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0029f1 c003                      	rjmp sound_driver_instrument_routine_channel1_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_pitch_increment:
0029f2 95a3                      	inc r26 //increment the macro offset
0029f3 93a0 2886                 	sts pulse2_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_pitch_read:
0029f5 91b4                      	lpm r27, Z //load pitch data into r27
0029f6 38b0                      	cpi r27, 0x80 //check for macro end flag
0029f7 f479                      	brne sound_driver_instrument_routine_channel1_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_release:
0029f8 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0029f9 93a0 2886                 	sts pulse2_pitch_macro_offset, r26
0029fb 91b0 2888                 	lds r27, pulse2_pitch_macro_release
0029fd 3fbf                      	cpi r27, 0xFF
0029fe f439                      	brne sound_driver_instrument_routine_channel1_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_loop:
0029ff 91b0 2887                 	lds r27, pulse2_pitch_macro_loop //load the loop index
002a01 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002a02 f019                      	breq sound_driver_instrument_routine_channel1_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002a03 93b0 2886                 	sts pulse2_pitch_macro_offset, r27 //store the loop index into the offset
002a05 cfd6                      	rjmp sound_driver_instrument_routine_channel1_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_default:
002a06 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel1_pitch_calculate:
002a07 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002a08 937f                      	push r23
002a09 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
002a0a eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002a0b 0367                      	mulsu r22, r23
002a0c 917f                      	pop r23
002a0d 916f                      	pop r22
                                 
002a0e 9416                      	lsr r1 //shift out the fractional bits
002a0f 9407                      	ror r0
002a10 9416                      	lsr r1
002a11 9407                      	ror r0
002a12 9416                      	lsr r1
002a13 9407                      	ror r0
002a14 9416                      	lsr r1
002a15 9407                      	ror r0
002a16 fe13                      	sbrs r1, 3 //check if result was a negative number
002a17 c002                      	rjmp sound_driver_instrument_routine_channel1_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_negative:
002a18 efb0                      	ldi r27, 0xF0
002a19 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_offset:
002a1a 91a0 2882                 	lds r26, pulse2_total_pitch_offset
002a1c 91b0 2883                 	lds r27, pulse2_total_pitch_offset+1
002a1e 0e0a                      	add r0, r26
002a1f 1e1b                      	adc r1, r27
002a20 9200 2882                 	sts pulse2_total_pitch_offset, r0
002a22 9210 2883                 	sts pulse2_total_pitch_offset+1, r1
002a24 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
002a26 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
002a28 0da0                      	add r26, r0 //offset the timer values
002a29 1db1                      	adc r27, r1
                                 	
002a2a 91c0 2898                 	lds r28, pulse2_fx_1xx_total
002a2c 91d0 2899                 	lds r29, pulse2_fx_1xx_total+1
002a2e 1bac                      	sub r26, r28
002a2f 0bbd                      	sbc r27, r29
002a30 91c0 289c                 	lds r28, pulse2_fx_2xx_total
002a32 91d0 289d                 	lds r29, pulse2_fx_2xx_total+1
002a34 0fac                      	add r26, r28
002a35 1fbd                      	adc r27, r29
002a36 91c0 28b0                 	lds r28, pulse2_fx_Pxx_total
002a38 91d0 28b1                 	lds r29, pulse2_fx_Pxx_total+1
002a3a 0fac                      	add r26, r28
002a3b 1fbd                      	adc r27, r29
002a3c 91c0 28b6                 	lds r28, pulse2_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
002a3e 91d0 28b7                 	lds r29, pulse2_fx_Qxy_total_offset+1
002a40 1bac                      	sub r26, r28
002a41 0bbd                      	sbc r27, r29
002a42 91c0 28bc                 	lds r28, pulse2_fx_Rxy_total_offset
002a44 91d0 28bd                 	lds r29, pulse2_fx_Rxy_total_offset+1
002a46 0fac                      	add r26, r28
002a47 1fbd                      	adc r27, r29
                                 
002a48 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
002a4a 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel1_hi_pitch:
002a4c 91e0 288a                 	lds ZL, pulse2_hi_pitch_macro
002a4e 91f0 288b                 	lds ZH, pulse2_hi_pitch_macro+1
002a50 9630                      	adiw Z, 0
002a51 f409                      	brne sound_driver_instrument_routine_channel1_hi_pitch_continue
002a52 c03c                      	rjmp sound_driver_instrument_routine_channel1_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel1_hi_pitch_continue:
002a53 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002a54 1fff                      	rol ZH
002a55 91a0 288c                 	lds r26, pulse2_hi_pitch_macro_offset
002a57 0fea                      	add ZL, r26
002a58 1df2                      	adc ZH, zero
                                 
002a59 91b0 288e                 	lds r27, pulse2_hi_pitch_macro_release
002a5b 17ba                      	cp r27, r26
002a5c f429                      	brne sound_driver_instrument_routine_channel1_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002a5d 91a0 288d                 	lds r26, pulse2_hi_pitch_macro_loop
002a5f 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002a60 f010                      	brlo sound_driver_instrument_routine_channel1_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002a61 c003                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_increment:
002a62 95a3                      	inc r26 //increment the macro offset
002a63 93a0 288c                 	sts pulse2_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_hi_pitch_read:
002a65 91b4                      	lpm r27, Z //load hi pitch data into r27
002a66 38b0                      	cpi r27, 0x80 //check for macro end flag
002a67 f489                      	brne sound_driver_instrument_routine_channel1_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_release:
002a68 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002a69 93a0 288c                 	sts pulse2_hi_pitch_macro_offset, r26
002a6b 91b0 288e                 	lds r27, pulse2_hi_pitch_macro_release
002a6d 3fbf                      	cpi r27, 0xFF
002a6e f439                      	brne sound_driver_instrument_routine_channel1_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_loop:
002a6f 91b0 288d                 	lds r27, pulse2_hi_pitch_macro_loop //load the loop index
002a71 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002a72 f019                      	breq sound_driver_instrument_routine_channel1_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002a73 93b0 288c                 	sts pulse2_hi_pitch_macro_offset, r27 //store the loop index into the offset
002a75 cfd6                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_default:
002a76 91b0 2889                 	lds r27, pulse2_total_hi_pitch_offset
002a78 c005                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate:
002a79 91a0 2889                 	lds r26, pulse2_total_hi_pitch_offset //load the total hi pitch offset to change
002a7b 0fba                      	add r27, r26
002a7c 93b0 2889                 	sts pulse2_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply:
002a7e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002a7f 937f                      	push r23
002a80 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002a81 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002a82 0367                      	mulsu r22, r23
002a83 917f                      	pop r23
002a84 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_offset:
002a85 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
002a87 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
002a89 0da0                      	add r26, r0 //offset the timer values
002a8a 1db1                      	adc r27, r1
002a8b 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
002a8d 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel1_duty:
002a8f 91e0 288f                 	lds ZL, pulse2_duty_macro
002a91 91f0 2890                 	lds ZH, pulse2_duty_macro+1
002a93 9630                      	adiw Z, 0
002a94 f1b1                      	breq sound_driver_channel1_fx_routines //if no duty macro is in use, go to the next routine
002a95 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002a96 1fff                      	rol ZH
002a97 91a0 2891                 	lds r26, pulse2_duty_macro_offset
002a99 0fea                      	add ZL, r26
002a9a 1df2                      	adc ZH, zero
                                 
002a9b 91b0 2893                 	lds r27, pulse2_duty_macro_release
002a9d 17ba                      	cp r27, r26
002a9e f429                      	brne sound_driver_instrument_routine_channel1_duty_increment //if the current offset is not equal to the release index, increment the offset
002a9f 91a0 2892                 	lds r26, pulse2_duty_macro_loop
002aa1 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002aa2 f010                      	brlo sound_driver_instrument_routine_channel1_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002aa3 c027                      	rjmp sound_driver_channel1_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel1_duty_increment:
002aa4 95a3                      	inc r26 //increment the macro offset
002aa5 93a0 2891                 	sts pulse2_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_duty_read:
002aa7 91b4                      	lpm r27, Z //load pitch data into r27
002aa8 3fbf                      	cpi r27, 0xFF //check for macro end flag
002aa9 f471                      	brne sound_driver_instrument_routine_channel1_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_release:
002aaa 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002aab 93a0 2891                 	sts pulse2_duty_macro_offset, r26
002aad 91b0 2893                 	lds r27, pulse2_duty_macro_release
002aaf 3fbf                      	cpi r27, 0xFF
002ab0 f4d1                      	brne sound_driver_channel1_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_loop:
002ab1 91b0 2892                 	lds r27, pulse2_duty_macro_loop //load the loop index
002ab3 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002ab4 f0b1                      	breq sound_driver_channel1_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
002ab5 93b0 2891                 	sts pulse2_duty_macro_offset, r27 //store the loop index into the offset
002ab7 cfd7                      	rjmp sound_driver_instrument_routine_channel1_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_load:
002ab8 e8ea                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
002ab9 e6f4                      	ldi ZH, HIGH(sequences << 1)
002aba 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
002abb 1df2                      	adc ZH, zero
                                 
002abc 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
002abd 95b7                      	ror r27
002abe 95b7                      	ror r27
002abf 91a0 2808                 	lds r26, pulse2_param //load r26 with pulse2_param (register $4000)
002ac1 2fca                      	mov r28, r26 //store a copy of pulse2_param into r28
002ac2 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
002ac3 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
002ac4 c001                      	rjmp sound_driver_instrument_routine_channel1_duty_load_store
002ac5 c005                      	rjmp sound_driver_channel1_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel1_duty_load_store:
002ac6 90d4                      	lpm pulse2_sequence, Z //store the sequence
                                 
002ac7 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
002ac8 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
002ac9 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_routines:
                                 sound_driver_channel1_fx_1xx_routine:
002acb 91e0 2896                 	lds ZL, pulse2_fx_1xx
002acd 91f0 2897                 	lds ZH, pulse2_fx_1xx+1
002acf 9630                      	adiw Z, 0
002ad0 f051                      	breq sound_driver_channel1_fx_2xx_routine
                                 
002ad1 91a0 2898                 	lds r26, pulse2_fx_1xx_total //load the rate to change the pitch by
002ad3 91b0 2899                 	lds r27, pulse2_fx_1xx_total+1
002ad5 0fae                      	add r26, ZL //increase the total offset by the rate
002ad6 1fbf                      	adc r27, ZH
002ad7 93a0 2898                 	sts pulse2_fx_1xx_total, r26
002ad9 93b0 2899                 	sts pulse2_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_2xx_routine:
002adb 91e0 289a                 	lds ZL, pulse2_fx_2xx
002add 91f0 289b                 	lds ZH, pulse2_fx_2xx+1
002adf 9630                      	adiw Z, 0
002ae0 f051                      	breq sound_driver_channel1_fx_3xx_routine
                                 
002ae1 91a0 289c                 	lds r26, pulse2_fx_2xx_total //load the rate to change the pitch by
002ae3 91b0 289d                 	lds r27, pulse2_fx_2xx_total+1
002ae5 0fae                      	add r26, ZL //increase the total offset by the rate
002ae6 1fbf                      	adc r27, ZH
002ae7 93a0 289c                 	sts pulse2_fx_2xx_total, r26
002ae9 93b0 289d                 	sts pulse2_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_3xx_routine:
002aeb 91e0 28a2                 	lds ZL, pulse2_fx_3xx_speed
002aed 91f0 28a3                 	lds ZH, pulse2_fx_3xx_speed+1
002aef 9630                      	adiw Z, 0
002af0 f409                      	brne sound_driver_channel1_fx_3xx_routine_check_start
002af1 c048                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_check_start:
002af2 91a0 289e                 	lds r26, pulse2_fx_3xx_start
002af4 91b0 289f                 	lds r27, pulse2_fx_3xx_start+1
002af6 9610                      	adiw r26:r27, 0
002af7 f409                      	brne sound_driver_channel1_fx_3xx_routine_main
002af8 c041                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_main:
002af9 91c0 28a0                 	lds r28, pulse2_fx_3xx_target
002afb 91d0 28a1                 	lds r29, pulse2_fx_3xx_target+1
                                 
002afd 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
002afe 07bd                      	cpc r27, r29
002aff f011                      	breq sound_driver_channel1_fx_3xx_routine_disable
002b00 f030                      	brlo sound_driver_channel1_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002b01 c01f                      	rjmp sound_driver_channel1_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel1_fx_3xx_routine_disable:
002b02 9220 289e                 	sts pulse2_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002b04 9220 289f                 	sts pulse2_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002b06 c033                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_subtract:
002b07 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002b08 0bdb                      	sbc r29, r27
002b09 91a0 28a4                 	lds r26, pulse2_fx_3xx_total_offset
002b0b 91b0 28a5                 	lds r27, pulse2_fx_3xx_total_offset+1
                                 
002b0d 0fae                      	add r26, ZL //add the speed to the total offset
002b0e 1fbf                      	adc r27, ZH
002b0f 1bca                      	sub r28, r26 //invert the total difference with the total offset
002b10 0bdb                      	sbc r29, r27
002b11 f380                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002b12 93a0 28a4                 	sts pulse2_fx_3xx_total_offset, r26 //store the new total offset
002b14 93b0 28a5                 	sts pulse2_fx_3xx_total_offset+1, r27
                                 
002b16 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the current timer period
002b18 91b0 0a9d                 	lds r27, TCB1_CCMPH
002b1a 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002b1b 0bbd                      	sbc r27, r29
002b1c 93a0 0a9c                 	sts TCB1_CCMPL, r26
002b1e 93b0 0a9d                 	sts TCB1_CCMPH, r27
002b20 c019                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_add:
002b21 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002b22 0bbd                      	sbc r27, r29
002b23 91c0 28a4                 	lds r28, pulse2_fx_3xx_total_offset
002b25 91d0 28a5                 	lds r29, pulse2_fx_3xx_total_offset+1
                                 
002b27 0fce                      	add r28, ZL //add the speed to the total offset
002b28 1fdf                      	adc r29, ZH
002b29 1bac                      	sub r26, r28 //invert the total difference with the total offset
002b2a 0bbd                      	sbc r27, r29
002b2b f2b0                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002b2c 93c0 28a4                 	sts pulse2_fx_3xx_total_offset, r28 //store the new total offset
002b2e 93d0 28a5                 	sts pulse2_fx_3xx_total_offset+1, r29
                                 
002b30 91c0 0a9c                 	lds r28, TCB1_CCMPL //load the current timer period
002b32 91d0 0a9d                 	lds r29, TCB1_CCMPH
002b34 0fca                      	add r28, r26 //offset the current timer period with the total offset
002b35 1fdb                      	adc r29, r27
002b36 93c0 0a9c                 	sts TCB1_CCMPL, r28
002b38 93d0 0a9d                 	sts TCB1_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel1_fx_4xy_routine:
002b3a 91a0 28a6                 	lds r26, pulse2_fx_4xy_speed
002b3c 15a2                      	cp r26, zero
002b3d f409                      	brne sound_driver_channel1_fx_4xy_routine_continue
002b3e c05c                      	rjmp sound_driver_channel1_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel1_fx_4xy_routine_continue:
002b3f 91b0 28a7                 	lds r27, pulse2_fx_4xy_depth
002b41 91c0 28a8                 	lds r28, pulse2_fx_4xy_phase
002b43 0fca                      	add r28, r26 //increase the phase by the speed
002b44 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
002b45 f008                      	brlo sound_driver_channel1_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002b46 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase:
002b47 93c0 28a8                 	sts pulse2_fx_4xy_phase, r28 //store the new phase
002b49 31c0                      	cpi r28, 16
002b4a f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_0
002b4b 32c0                      	cpi r28, 32
002b4c f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_1
002b4d 33c0                      	cpi r28, 48
002b4e f030                      	brlo sound_driver_channel1_fx_4xy_routine_phase_2
002b4f c007                      	rjmp sound_driver_channel1_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_0:
002b50 70cf                      	andi r28, 0x0F //mask for values 0-15
002b51 c029                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_1:
002b52 6fc0                      	ori r28, 0xF0
002b53 95c0                      	com r28 //invert values 0-15
002b54 c026                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_2:
002b55 70cf                      	andi r28, 0x0F //mask for values 0-15
002b56 c003                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_3:
002b57 6fc0                      	ori r28, 0xF0
002b58 95c0                      	com r28 //invert values 0-15
002b59 c000                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_add:
002b5a 95b2                      	swap r27 //multiply depth by 16
002b5b 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002b5c e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002b5d e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002b5e 0fec                      	add ZL, r28 //offset the table by the depth+phase
002b5f 1df2                      	adc ZH, zero
002b60 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002b61 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002b62 937f                      	push r23
002b63 2f6c                      	mov r22, r28 //store the vibrato value into r22
002b64 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002b65 9f67                      	mul r22, r23
002b66 917f                      	pop r23
002b67 916f                      	pop r22
                                 
002b68 9416                      	lsr r1 //shift out the fractional bits
002b69 9407                      	ror r0
002b6a 9416                      	lsr r1
002b6b 9407                      	ror r0
002b6c 9416                      	lsr r1
002b6d 9407                      	ror r0
002b6e 9416                      	lsr r1
002b6f 9407                      	ror r0
                                 	
002b70 91a0 0a9c                 	lds r26, TCB1_CCMPL
002b72 91b0 0a9d                 	lds r27, TCB1_CCMPH
002b74 0da0                      	add r26, r0
002b75 1db1                      	adc r27, r1
002b76 93a0 0a9c                 	sts TCB1_CCMPL, r26
002b78 93b0 0a9d                 	sts TCB1_CCMPH, r27
002b7a c020                      	rjmp sound_driver_channel1_fx_7xy_routine
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_subtract:
002b7b 95b2                      	swap r27 //multiply depth by 16
002b7c 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002b7d e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002b7e e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002b7f 0fec                      	add ZL, r28 //offset the table by the depth+phase
002b80 1df2                      	adc ZH, zero
002b81 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002b82 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002b83 937f                      	push r23
002b84 2f6c                      	mov r22, r28 //store the vibrato value into r22
002b85 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002b86 9f67                      	mul r22, r23
002b87 917f                      	pop r23
002b88 916f                      	pop r22
                                 
002b89 9416                      	lsr r1 //shift out the fractional bits
002b8a 9407                      	ror r0
002b8b 9416                      	lsr r1
002b8c 9407                      	ror r0
002b8d 9416                      	lsr r1
002b8e 9407                      	ror r0
002b8f 9416                      	lsr r1
002b90 9407                      	ror r0
                                 
002b91 91a0 0a9c                 	lds r26, TCB1_CCMPL
002b93 91b0 0a9d                 	lds r27, TCB1_CCMPH
002b95 19a0                      	sub r26, r0
002b96 09b1                      	sbc r27, r1
002b97 93a0 0a9c                 	sts TCB1_CCMPL, r26
002b99 93b0 0a9d                 	sts TCB1_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_7xy_routine:
002b9b 91a0 28a9                 	lds r26, pulse2_fx_7xy_speed
002b9d 15a2                      	cp r26, zero
002b9e f0f1                      	breq sound_driver_channel1_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
002b9f 91b0 28aa                 	lds r27, pulse2_fx_7xy_depth
002ba1 91c0 28ab                 	lds r28, pulse2_fx_7xy_phase
002ba3 0fca                      	add r28, r26 //increase the phase by the speed
002ba4 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
002ba5 f010                      	brlo sound_driver_channel1_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
002ba6 e0c0                      	ldi r28, 0x00
002ba7 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase:
002ba8 93c0 28ab                 	sts pulse2_fx_7xy_phase, r28 //store the new phase
002baa 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
002bab ffc4                      	sbrs r28, 4
002bac c001                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_0
002bad c002                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel1_fx_7xy_routine_phase_0:
002bae 70cf                      	andi r28, 0x0F //mask for values 0-15
002baf c003                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase_1:
002bb0 6fc0                      	ori r28, 0xF0
002bb1 95c0                      	com r28 //invert values 0-15
002bb2 c000                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_load:
002bb3 95b2                      	swap r27 //multiply depth by 16
002bb4 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002bb5 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002bb6 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002bb7 0fec                      	add ZL, r28 //offset the table by the depth+phase
002bb8 1df2                      	adc ZH, zero
002bb9 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002bba 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
002bbb 93c0 28ac                 	sts pulse2_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Axy_routine:
002bbd 91b0 28ad                 	lds r27, pulse2_fx_Axy
002bbf 15b2                      	cp r27, zero
002bc0 f0e9                      	breq sound_driver_channel1_fx_Qxy_routine //0 means that the effect is not in use
                                 	
002bc1 91a0 280d                 	lds r26, pulse2_fractional_volume //load fractional volume representation of the channel
002bc3 91c0 2808                 	lds r28, pulse2_param //load the integer volume representation of the channel
002bc5 2fda                      	mov r29, r26 //copy fractional volume into r29
002bc6 2fec                      	mov r30, r28 //copy the pulse2_param into r30
002bc7 95e2                      	swap r30
002bc8 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
002bc9 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
002bca 17ed                      	cp r30, r29 //compare the fractional and integer volumes
002bcb f009                      	breq sound_driver_channel1_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel1_fx_Axy_routine_reload:
002bcc 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate:
002bcd fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
002bce c004                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_addition:
002bcf 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002bd0 f428                      	brcc sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002bd1 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
002bd2 c003                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_subtraction:
002bd3 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002bd4 f008                      	brcs sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002bd5 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_store:
002bd6 93a0 280d                 	sts pulse2_fractional_volume, r26 //store the new fractional volume
002bd8 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
002bd9 95a2                      	swap r26
002bda 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
002bdb 2bca                      	or r28, r26 //store the new volume back into pulse2_param
002bdc 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel1_fx_Qxy_routine:
002bde 91e0 28b2                 	lds ZL, pulse2_fx_Qxy_target
002be0 91f0 28b3                 	lds ZH, pulse2_fx_Qxy_target+1
002be2 9630                      	adiw Z, 0
002be3 f139                      	breq sound_driver_channel1_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002be4 91a0 28b6                 	lds r26, pulse2_fx_Qxy_total_offset
002be6 91b0 28b7                 	lds r27, pulse2_fx_Qxy_total_offset+1
002be8 91c0 0a9c                 	lds r28, TCB1_CCMPL
002bea 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
002bec 1bec                      	sub ZL, r28 //calculate the difference to the target
002bed 0bfd                      	sbc ZH, r29
002bee f408                      	brsh sound_driver_channel1_fx_Qxy_routine_end //if the target has been reached (or passed)
002bef f088                      	brlo sound_driver_channel1_fx_Qxy_routine_add
                                 
                                 sound_driver_channel1_fx_Qxy_routine_end:
002bf0 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
002bf1 0bbf                      	sbc r27, ZH
                                 
002bf2 91c0 28b0                 	lds r28, pulse2_fx_Pxx_total
002bf4 91d0 28b1                 	lds r29, pulse2_fx_Pxx_total+1
                                 
002bf6 0fac                      	add r26, r28
002bf7 1fbd                      	adc r27, r29
                                 
002bf8 93a0 28b6                 	sts pulse2_fx_Qxy_total_offset, r26 //store the total offset
002bfa 93b0 28b7                 	sts pulse2_fx_Qxy_total_offset+1, r27
002bfc 9220 28b2                 	sts pulse2_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
002bfe 9220 28b3                 	sts pulse2_fx_Qxy_target+1, zero
002c00 c00a                      	rjmp sound_driver_channel1_fx_Rxy_routine
                                 
                                 sound_driver_channel1_fx_Qxy_routine_add:
002c01 91c0 28b4                 	lds r28, pulse2_fx_Qxy_speed
002c03 91d0 28b5                 	lds r29, pulse2_fx_Qxy_speed+1
002c05 0fac                      	add r26, r28 //increase the total offset by the speed
002c06 1fbd                      	adc r27, r29
002c07 93a0 28b6                 	sts pulse2_fx_Qxy_total_offset, r26 //store the total offset
002c09 93b0 28b7                 	sts pulse2_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Rxy_routine:
002c0b 91e0 28b8                 	lds ZL, pulse2_fx_Rxy_target
002c0d 91f0 28b9                 	lds ZH, pulse2_fx_Rxy_target+1
002c0f 9630                      	adiw Z, 0
002c10 f139                      	breq sound_driver_instrument_routine_channel2_volume //if the effect is not enabled, skip the routine
                                 
002c11 91a0 28bc                 	lds r26, pulse2_fx_Rxy_total_offset
002c13 91b0 28bd                 	lds r27, pulse2_fx_Rxy_total_offset+1
002c15 91c0 0a9c                 	lds r28, TCB1_CCMPL
002c17 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
002c19 1bce                      	sub r28, ZL //calculate the difference to the target
002c1a 0bdf                      	sbc r29, ZH
002c1b f408                      	brsh sound_driver_channel1_fx_Rxy_routine_end //if the target has been reached (or passed)
002c1c f088                      	brlo sound_driver_channel1_fx_Rxy_routine_add
                                 
                                 sound_driver_channel1_fx_Rxy_routine_end:
002c1d 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
002c1e 0bbd                      	sbc r27, r29
                                 
002c1f 91c0 28b0                 	lds r28, pulse2_fx_Pxx_total
002c21 91d0 28b1                 	lds r29, pulse2_fx_Pxx_total+1
                                 
002c23 0fac                      	add r26, r28
002c24 1fbd                      	adc r27, r29
                                 
002c25 93a0 28bc                 	sts pulse2_fx_Rxy_total_offset, r26 //store the total offset
002c27 93b0 28bd                 	sts pulse2_fx_Rxy_total_offset+1, r27
002c29 9220 28b8                 	sts pulse2_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
002c2b 9220 28b9                 	sts pulse2_fx_Rxy_target+1, zero
002c2d c00a                      	rjmp sound_driver_instrument_routine_channel2_volume
                                 
                                 sound_driver_channel1_fx_Rxy_routine_add:
002c2e 91c0 28ba                 	lds r28, pulse2_fx_Rxy_speed
002c30 91d0 28bb                 	lds r29, pulse2_fx_Rxy_speed+1
002c32 0fac                      	add r26, r28 //increase the total offset by the speed
002c33 1fbd                      	adc r27, r29
002c34 93a0 28bc                 	sts pulse2_fx_Rxy_total_offset, r26 //store the total offset
002c36 93b0 28bd                 	sts pulse2_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume:
002c38 91e0 28c6                 	lds ZL, triangle_volume_macro
002c3a 91f0 28c7                 	lds ZH, triangle_volume_macro+1
002c3c 9630                      	adiw Z, 0
002c3d f199                      	breq sound_driver_instrument_routine_channel2_volume_default //if no volume macro is in use, do nothing
002c3e 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002c3f 1fff                      	rol ZH
002c40 91a0 28c8                 	lds r26, triangle_volume_macro_offset
002c42 0fea                      	add ZL, r26
002c43 1df2                      	adc ZH, zero
                                 
002c44 91b0 28ca                 	lds r27, triangle_volume_macro_release
002c46 17ba                      	cp r27, r26
002c47 f429                      	brne sound_driver_instrument_routine_channel2_volume_increment //if the current offset is not equal to the release index, increment the offset
002c48 91a0 28c9                 	lds r26, triangle_volume_macro_loop
002c4a 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002c4b f010                      	brlo sound_driver_instrument_routine_channel2_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002c4c c003                      	rjmp sound_driver_instrument_routine_channel2_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_volume_increment:
002c4d 95a3                      	inc r26 //increment the macro offset
002c4e 93a0 28c8                 	sts triangle_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_volume_read:
002c50 91b4                      	lpm r27, Z //load volume data into r27
002c51 3fbf                      	cpi r27, 0xFF //check for macro end flag
002c52 f469                      	brne sound_driver_instrument_routine_channel2_volume_process //if the data was not the macro end flag
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_release:
002c53 91b0 28ca                 	lds r27, triangle_volume_macro_release
002c55 3fbf                      	cpi r27, 0xFF
002c56 f429                      	brne sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_loop:
002c57 91b0 28c9                 	lds r27, triangle_volume_macro_loop //load the loop index
002c59 93b0 28c8                 	sts triangle_volume_macro_offset, r27 //store the loop index into the offset
002c5b cfdc                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index:
002c5c 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002c5d 93a0 28c8                 	sts triangle_volume_macro_offset, r26
002c5f cfd8                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_process:
002c60 15b2                      	cp r27, zero
002c61 f041                      	breq sound_driver_instrument_routine_channel2_volume_process_disable
                                 sound_driver_instrument_routine_channel2_volume_process_enable:
002c62 91b0 0aa5                 	lds r27, TCB2_INTCTRL
002c64 30b1                      	cpi r27, TCB_CAPT_bm
002c65 f459                      	brne sound_driver_instrument_routine_channel2_volume_default //if the channel has already been muted, don't enable it again
002c66 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
002c67 93b0 0aa5                 	sts TCB2_INTCTRL, r27
002c69 c007                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 sound_driver_instrument_routine_channel2_volume_process_disable:
002c6a 9220 0aa5                 	sts TCB2_INTCTRL, zero
002c6c 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
002c6e 9220 0aad                 	sts TCB2_CCMPH, zero
002c70 c000                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_volume_default:
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002c71 91e0 28cb                 	lds ZL, triangle_arpeggio_macro
002c73 91f0 28cc                 	lds ZH, triangle_arpeggio_macro+1
002c75 9630                      	adiw Z, 0
002c76 f1d9                      	breq sound_driver_instrument_routine_channel2_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002c77 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002c78 1fff                      	rol ZH
002c79 91a0 28cd                 	lds r26, triangle_arpeggio_macro_offset
002c7b 0fea                      	add ZL, r26
002c7c 1df2                      	adc ZH, zero
                                 
002c7d 91b0 28cf                 	lds r27, triangle_arpeggio_macro_release
002c7f 17ba                      	cp r27, r26
002c80 f429                      	brne sound_driver_instrument_routine_channel2_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002c81 91a0 28ce                 	lds r26, triangle_arpeggio_macro_loop
002c83 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002c84 f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002c85 c003                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_increment:
002c86 95a3                      	inc r26 //increment the macro offset
002c87 93a0 28cd                 	sts triangle_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_read:
002c89 91b4                      	lpm r27, Z //load arpeggio data into r27
002c8a 38b0                      	cpi r27, 0x80 //check for macro end flag
002c8b f009                      	breq sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag
002c8c c041                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_check_mode:
002c8d 50a1                      	subi r26, 1 //keep the offset at the end flag
002c8e 93a0 28cd                 	sts triangle_arpeggio_macro_offset, r26
002c90 91b0 28d0                 	lds r27, triangle_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002c92 30b1                      	cpi r27, 0x01
002c93 f048                      	brlo sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_release:
002c94 91b0 28cf                 	lds r27, triangle_arpeggio_macro_release
002c96 3fbf                      	cpi r27, 0xFF
002c97 f4d1                      	brne sound_driver_instrument_routine_channel2_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_loop:
002c98 91b0 28ce                 	lds r27, triangle_arpeggio_macro_loop
002c9a 3fbf                      	cpi r27, 0xFF
002c9b f499                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002c9c c015                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute:
002c9d 91b0 28cf                 	lds r27, triangle_arpeggio_macro_release
002c9f 3fbf                      	cpi r27, 0xFF
002ca0 f421                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_check_loop:
002ca1 91b0 28ce                 	lds r27, triangle_arpeggio_macro_loop //load the loop index
002ca3 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002ca4 f451                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop:
002ca5 91c0 28e3                 	lds r28, triangle_fx_0xy_sequence //check for 0xy effect
002ca7 91d0 28e4                 	lds r29, triangle_fx_0xy_sequence+1
002ca9 9620                      	adiw r29:r28, 0
002caa f469                      	brne sound_driver_instrument_routine_channel2_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002cab 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002cac 93a0 28cd                 	sts triangle_arpeggio_macro_offset, r26 //store the last valid index into the offset
002cae cfc2                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload:
002caf 93b0 28cd                 	sts triangle_arpeggio_macro_offset, r27 //store the loop index into the offset
002cb1 cfbf                      	rjmp sound_driver_instrument_routine_channel2_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_default:
002cb2 91c0 28e3                 	lds r28, triangle_fx_0xy_sequence //load 0xy effect
002cb4 91d0 28e4                 	lds r29, triangle_fx_0xy_sequence+1
002cb6 9620                      	adiw r29:r28, 0 //check for 0xy effect
002cb7 f099                      	breq sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel2_arpeggio_default_xy:
002cb8 95d6                      	lsr r29
002cb9 95c7                      	ror r28
002cba 95d7                      	ror r29
002cbb 95c7                      	ror r28
002cbc 95d7                      	ror r29
002cbd 95c7                      	ror r28
002cbe 95d7                      	ror r29
002cbf 95c7                      	ror r28
002cc0 95d7                      	ror r29
002cc1 95d2                      	swap r29
                                 
002cc2 93c0 28e3                 	sts triangle_fx_0xy_sequence, r28 //store the rolled sequence
002cc4 93d0 28e4                 	sts triangle_fx_0xy_sequence+1, r29
002cc6 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002cc7 91a0 2812                 	lds r26, triangle_note //load the current note index
002cc9 0fac                      	add r26, r28 //add the note offset
002cca c02e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002ccb 91a0 2812                 	lds r26, triangle_note //load the current note index
002ccd c02b                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process:
002cce 9220 28d1                 	sts triangle_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002cd0 9220 28d2                 	sts triangle_total_pitch_offset+1, zero
002cd2 9220 28d8                 	sts triangle_total_hi_pitch_offset, zero
002cd4 91a0 28d0                 	lds r26, triangle_arpeggio_macro_mode
002cd6 30a1                      	cpi r26, 0x01 //absolute mode
002cd7 f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_absolute
002cd8 f069                      	breq sound_driver_instrument_routine_channel2_arpeggio_process_fixed
002cd9 c00e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute:
002cda 91a0 2812                 	lds r26, triangle_note //load the current note index
002cdc 0fab                      	add r26, r27 //offset the note with the arpeggio data
002cdd fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002cde c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_add:
002cdf 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002ce0 f0c0                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
002ce1 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002ce2 c016                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract:
002ce3 fda7                      	sbrc r26, 7 //check if result is negative
002ce4 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002ce5 c013                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_fixed:
002ce6 2fab                      	mov r26, r27 //move the arpeggio data into r26
002ce7 c011                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative:
002ce8 91a0 2812                 	lds r26, triangle_note //load the current note index
002cea 0fab                      	add r26, r27 //offset the note with the arpeggio data
002ceb fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002cec c008                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_add:
002ced 93a0 2812                 	sts triangle_note, r26 //NOTE: relative mode modifies the original note index
002cef 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002cf0 f040                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
002cf1 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002cf2 93a0 2812                 	sts triangle_note, r26
002cf4 c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract:
002cf5 fda7                      	sbrc r26, 7 //check if result is negative
002cf6 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002cf7 93a0 2812                 	sts triangle_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_load:
002cf9 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
002cfa e0f0                      	ldi ZH, HIGH(note_table << 1)
002cfb 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002cfc 0fea                      	add ZL, r26 //add offset
002cfd 1df2                      	adc ZH, zero
002cfe 91a5                      	lpm r26, Z+ //load bytes
002cff 91b4                      	lpm r27, Z
002d00 93a0 0aac                 	sts TCB2_CCMPL, r26 //load the LOW bits for timer
002d02 93b0 0aad                 	sts TCB2_CCMPH, r27 //load the HIGH bits for timer
002d04 93a0 28ef                 	sts triangle_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002d06 93b0 28f0                 	sts triangle_fx_3xx_target+1, r27
002d08 c000                      	rjmp sound_driver_instrument_routine_channel2_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch:
002d09 91e0 28d3                 	lds ZL, triangle_pitch_macro
002d0b 91f0 28d4                 	lds ZH, triangle_pitch_macro+1
002d0d 9630                      	adiw Z, 0
002d0e f409                      	brne sound_driver_instrument_routine_channel2_pitch_continue
002d0f c023                      	rjmp sound_driver_instrument_routine_channel2_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel2_pitch_continue:
002d10 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002d11 1fff                      	rol ZH
002d12 91a0 28d5                 	lds r26, triangle_pitch_macro_offset
002d14 0fea                      	add ZL, r26
002d15 1df2                      	adc ZH, zero
                                 
002d16 91b0 28d7                 	lds r27, triangle_pitch_macro_release
002d18 17ba                      	cp r27, r26
002d19 f429                      	brne sound_driver_instrument_routine_channel2_pitch_increment //if the current offset is not equal to the release index, increment the offset
002d1a 91a0 28d6                 	lds r26, triangle_pitch_macro_loop
002d1c 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002d1d f010                      	brlo sound_driver_instrument_routine_channel2_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002d1e c003                      	rjmp sound_driver_instrument_routine_channel2_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_pitch_increment:
002d1f 95a3                      	inc r26 //increment the macro offset
002d20 93a0 28d5                 	sts triangle_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_pitch_read:
002d22 91b4                      	lpm r27, Z //load pitch data into r27
002d23 38b0                      	cpi r27, 0x80 //check for macro end flag
002d24 f479                      	brne sound_driver_instrument_routine_channel2_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_release:
002d25 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002d26 93a0 28d5                 	sts triangle_pitch_macro_offset, r26
002d28 91b0 28d7                 	lds r27, triangle_pitch_macro_release
002d2a 3fbf                      	cpi r27, 0xFF
002d2b f439                      	brne sound_driver_instrument_routine_channel2_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_loop:
002d2c 91b0 28d6                 	lds r27, triangle_pitch_macro_loop //load the loop index
002d2e 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002d2f f019                      	breq sound_driver_instrument_routine_channel2_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002d30 93b0 28d5                 	sts triangle_pitch_macro_offset, r27 //store the loop index into the offset
002d32 cfd6                      	rjmp sound_driver_instrument_routine_channel2_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_default:
002d33 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel2_pitch_calculate:
002d34 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002d35 937f                      	push r23
002d36 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
002d37 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002d38 0367                      	mulsu r22, r23
002d39 917f                      	pop r23
002d3a 916f                      	pop r22
                                 
002d3b 9416                      	lsr r1 //shift out the fractional bits
002d3c 9407                      	ror r0
002d3d 9416                      	lsr r1
002d3e 9407                      	ror r0
002d3f 9416                      	lsr r1
002d40 9407                      	ror r0
002d41 9416                      	lsr r1
002d42 9407                      	ror r0
002d43 fe13                      	sbrs r1, 3 //check if result was a negative number
002d44 c002                      	rjmp sound_driver_instrument_routine_channel2_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_negative:
002d45 efb0                      	ldi r27, 0xF0
002d46 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_offset:
002d47 91a0 28d1                 	lds r26, triangle_total_pitch_offset
002d49 91b0 28d2                 	lds r27, triangle_total_pitch_offset+1
002d4b 0e0a                      	add r0, r26
002d4c 1e1b                      	adc r1, r27
002d4d 9200 28d1                 	sts triangle_total_pitch_offset, r0
002d4f 9210 28d2                 	sts triangle_total_pitch_offset+1, r1
002d51 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
002d53 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
002d55 0da0                      	add r26, r0 //offset the timer values
002d56 1db1                      	adc r27, r1
                                 	
002d57 91c0 28e7                 	lds r28, triangle_fx_1xx_total
002d59 91d0 28e8                 	lds r29, triangle_fx_1xx_total+1
002d5b 1bac                      	sub r26, r28
002d5c 0bbd                      	sbc r27, r29
002d5d 91c0 28eb                 	lds r28, triangle_fx_2xx_total
002d5f 91d0 28ec                 	lds r29, triangle_fx_2xx_total+1
002d61 0fac                      	add r26, r28
002d62 1fbd                      	adc r27, r29
002d63 91c0 28fa                 	lds r28, triangle_fx_Pxx_total
002d65 91d0 28fb                 	lds r29, triangle_fx_Pxx_total+1
002d67 0fac                      	add r26, r28
002d68 1fbd                      	adc r27, r29
002d69 91c0 2900                 	lds r28, triangle_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
002d6b 91d0 2901                 	lds r29, triangle_fx_Qxy_total_offset+1
002d6d 1bac                      	sub r26, r28
002d6e 0bbd                      	sbc r27, r29
002d6f 91c0 2906                 	lds r28, triangle_fx_Rxy_total_offset
002d71 91d0 2907                 	lds r29, triangle_fx_Rxy_total_offset+1
002d73 0fac                      	add r26, r28
002d74 1fbd                      	adc r27, r29
                                 
002d75 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
002d77 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel2_hi_pitch:
002d79 91e0 28d9                 	lds ZL, triangle_hi_pitch_macro
002d7b 91f0 28da                 	lds ZH, triangle_hi_pitch_macro+1
002d7d 9630                      	adiw Z, 0
002d7e f409                      	brne sound_driver_instrument_routine_channel2_hi_pitch_continue
002d7f c03c                      	rjmp sound_driver_instrument_routine_channel2_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel2_hi_pitch_continue:
002d80 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002d81 1fff                      	rol ZH
002d82 91a0 28db                 	lds r26, triangle_hi_pitch_macro_offset
002d84 0fea                      	add ZL, r26
002d85 1df2                      	adc ZH, zero
                                 
002d86 91b0 28dd                 	lds r27, triangle_hi_pitch_macro_release
002d88 17ba                      	cp r27, r26
002d89 f429                      	brne sound_driver_instrument_routine_channel2_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002d8a 91a0 28dc                 	lds r26, triangle_hi_pitch_macro_loop
002d8c 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002d8d f010                      	brlo sound_driver_instrument_routine_channel2_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002d8e c003                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_increment:
002d8f 95a3                      	inc r26 //increment the macro offset
002d90 93a0 28db                 	sts triangle_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_hi_pitch_read:
002d92 91b4                      	lpm r27, Z //load hi pitch data into r27
002d93 38b0                      	cpi r27, 0x80 //check for macro end flag
002d94 f489                      	brne sound_driver_instrument_routine_channel2_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_release:
002d95 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002d96 93a0 28db                 	sts triangle_hi_pitch_macro_offset, r26
002d98 91b0 28dd                 	lds r27, triangle_hi_pitch_macro_release
002d9a 3fbf                      	cpi r27, 0xFF
002d9b f439                      	brne sound_driver_instrument_routine_channel2_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_loop:
002d9c 91b0 28dc                 	lds r27, triangle_hi_pitch_macro_loop //load the loop index
002d9e 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002d9f f019                      	breq sound_driver_instrument_routine_channel2_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002da0 93b0 28db                 	sts triangle_hi_pitch_macro_offset, r27 //store the loop index into the offset
002da2 cfd6                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_default:
002da3 91b0 28d8                 	lds r27, triangle_total_hi_pitch_offset
002da5 c005                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate:
002da6 91a0 28d8                 	lds r26, triangle_total_hi_pitch_offset //load the total hi pitch offset to change
002da8 0fba                      	add r27, r26
002da9 93b0 28d8                 	sts triangle_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply:
002dab 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002dac 937f                      	push r23
002dad 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002dae eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002daf 0367                      	mulsu r22, r23
002db0 917f                      	pop r23
002db1 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_offset:
002db2 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
002db4 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
002db6 0da0                      	add r26, r0 //offset the timer values
002db7 1db1                      	adc r27, r1
002db8 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
002dba 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: The triangle channel does not have a duty cycle
                                 sound_driver_instrument_routine_channel2_duty:
                                 
                                 
                                 
                                 sound_driver_channel2_fx_routines:
                                 sound_driver_channel2_fx_1xx_routine:
002dbc 91e0 28e5                 	lds ZL, triangle_fx_1xx
002dbe 91f0 28e6                 	lds ZH, triangle_fx_1xx+1
002dc0 9630                      	adiw Z, 0
002dc1 f051                      	breq sound_driver_channel2_fx_2xx_routine
                                 
002dc2 91a0 28e7                 	lds r26, triangle_fx_1xx_total //load the rate to change the pitch by
002dc4 91b0 28e8                 	lds r27, triangle_fx_1xx_total+1
002dc6 0fae                      	add r26, ZL //increase the total offset by the rate
002dc7 1fbf                      	adc r27, ZH
002dc8 93a0 28e7                 	sts triangle_fx_1xx_total, r26
002dca 93b0 28e8                 	sts triangle_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_2xx_routine:
002dcc 91e0 28e9                 	lds ZL, triangle_fx_2xx
002dce 91f0 28ea                 	lds ZH, triangle_fx_2xx+1
002dd0 9630                      	adiw Z, 0
002dd1 f051                      	breq sound_driver_channel2_fx_3xx_routine
                                 
002dd2 91a0 28eb                 	lds r26, triangle_fx_2xx_total //load the rate to change the pitch by
002dd4 91b0 28ec                 	lds r27, triangle_fx_2xx_total+1
002dd6 0fae                      	add r26, ZL //increase the total offset by the rate
002dd7 1fbf                      	adc r27, ZH
002dd8 93a0 28eb                 	sts triangle_fx_2xx_total, r26
002dda 93b0 28ec                 	sts triangle_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_3xx_routine:
002ddc 91e0 28f1                 	lds ZL, triangle_fx_3xx_speed
002dde 91f0 28f2                 	lds ZH, triangle_fx_3xx_speed+1
002de0 9630                      	adiw Z, 0
002de1 f409                      	brne sound_driver_channel2_fx_3xx_routine_check_start
002de2 c048                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_check_start:
002de3 91a0 28ed                 	lds r26, triangle_fx_3xx_start
002de5 91b0 28ee                 	lds r27, triangle_fx_3xx_start+1
002de7 9610                      	adiw r26:r27, 0
002de8 f409                      	brne sound_driver_channel2_fx_3xx_routine_main
002de9 c041                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_main:
002dea 91c0 28ef                 	lds r28, triangle_fx_3xx_target
002dec 91d0 28f0                 	lds r29, triangle_fx_3xx_target+1
                                 
002dee 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
002def 07bd                      	cpc r27, r29
002df0 f011                      	breq sound_driver_channel2_fx_3xx_routine_disable
002df1 f030                      	brlo sound_driver_channel2_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002df2 c01f                      	rjmp sound_driver_channel2_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel2_fx_3xx_routine_disable:
002df3 9220 28ed                 	sts triangle_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002df5 9220 28ee                 	sts triangle_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002df7 c033                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_subtract:
002df8 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002df9 0bdb                      	sbc r29, r27
002dfa 91a0 28f3                 	lds r26, triangle_fx_3xx_total_offset
002dfc 91b0 28f4                 	lds r27, triangle_fx_3xx_total_offset+1
                                 
002dfe 0fae                      	add r26, ZL //add the speed to the total offset
002dff 1fbf                      	adc r27, ZH
002e00 1bca                      	sub r28, r26 //invert the total difference with the total offset
002e01 0bdb                      	sbc r29, r27
002e02 f380                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002e03 93a0 28f3                 	sts triangle_fx_3xx_total_offset, r26 //store the new total offset
002e05 93b0 28f4                 	sts triangle_fx_3xx_total_offset+1, r27
                                 
002e07 91a0 0aac                 	lds r26, TCB2_CCMPL //load the current timer period
002e09 91b0 0aad                 	lds r27, TCB2_CCMPH
002e0b 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002e0c 0bbd                      	sbc r27, r29
002e0d 93a0 0aac                 	sts TCB2_CCMPL, r26
002e0f 93b0 0aad                 	sts TCB2_CCMPH, r27
002e11 c019                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_add:
002e12 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002e13 0bbd                      	sbc r27, r29
002e14 91c0 28f3                 	lds r28, triangle_fx_3xx_total_offset
002e16 91d0 28f4                 	lds r29, triangle_fx_3xx_total_offset+1
                                 
002e18 0fce                      	add r28, ZL //add the speed to the total offset
002e19 1fdf                      	adc r29, ZH
002e1a 1bac                      	sub r26, r28 //invert the total difference with the total offset
002e1b 0bbd                      	sbc r27, r29
002e1c f2b0                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002e1d 93c0 28f3                 	sts triangle_fx_3xx_total_offset, r28 //store the new total offset
002e1f 93d0 28f4                 	sts triangle_fx_3xx_total_offset+1, r29
                                 
002e21 91c0 0aac                 	lds r28, TCB2_CCMPL //load the current timer period
002e23 91d0 0aad                 	lds r29, TCB2_CCMPH
002e25 0fca                      	add r28, r26 //offset the current timer period with the total offset
002e26 1fdb                      	adc r29, r27
002e27 93c0 0aac                 	sts TCB2_CCMPL, r28
002e29 93d0 0aad                 	sts TCB2_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel2_fx_4xy_routine:
002e2b 91a0 28f5                 	lds r26, triangle_fx_4xy_speed
002e2d 15a2                      	cp r26, zero
002e2e f409                      	brne sound_driver_channel2_fx_4xy_routine_continue
002e2f c05c                      	rjmp sound_driver_channel2_fx_Qxy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel2_fx_4xy_routine_continue:
002e30 91b0 28f6                 	lds r27, triangle_fx_4xy_depth
002e32 91c0 28f7                 	lds r28, triangle_fx_4xy_phase
002e34 0fca                      	add r28, r26 //increase the phase by the speed
002e35 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
002e36 f008                      	brlo sound_driver_channel2_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002e37 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase:
002e38 93c0 28f7                 	sts triangle_fx_4xy_phase, r28 //store the new phase
002e3a 31c0                      	cpi r28, 16
002e3b f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_0
002e3c 32c0                      	cpi r28, 32
002e3d f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_1
002e3e 33c0                      	cpi r28, 48
002e3f f030                      	brlo sound_driver_channel2_fx_4xy_routine_phase_2
002e40 c007                      	rjmp sound_driver_channel2_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_0:
002e41 70cf                      	andi r28, 0x0F //mask for values 0-15
002e42 c029                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_1:
002e43 6fc0                      	ori r28, 0xF0
002e44 95c0                      	com r28 //invert values 0-15
002e45 c026                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_2:
002e46 70cf                      	andi r28, 0x0F //mask for values 0-15
002e47 c003                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_3:
002e48 6fc0                      	ori r28, 0xF0
002e49 95c0                      	com r28 //invert values 0-15
002e4a c000                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_add:
002e4b 95b2                      	swap r27 //multiply depth by 16
002e4c 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002e4d e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002e4e e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002e4f 0fec                      	add ZL, r28 //offset the table by the depth+phase
002e50 1df2                      	adc ZH, zero
002e51 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002e52 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002e53 937f                      	push r23
002e54 2f6c                      	mov r22, r28 //store the vibrato value into r22
002e55 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002e56 9f67                      	mul r22, r23
002e57 917f                      	pop r23
002e58 916f                      	pop r22
                                 
002e59 9416                      	lsr r1 //shift out the fractional bits
002e5a 9407                      	ror r0
002e5b 9416                      	lsr r1
002e5c 9407                      	ror r0
002e5d 9416                      	lsr r1
002e5e 9407                      	ror r0
002e5f 9416                      	lsr r1
002e60 9407                      	ror r0
                                 	
002e61 91a0 0aac                 	lds r26, TCB2_CCMPL
002e63 91b0 0aad                 	lds r27, TCB2_CCMPH
002e65 0da0                      	add r26, r0
002e66 1db1                      	adc r27, r1
002e67 93a0 0aac                 	sts TCB2_CCMPL, r26
002e69 93b0 0aad                 	sts TCB2_CCMPH, r27
002e6b c020                      	rjmp sound_driver_channel2_fx_Qxy_routine
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_subtract:
002e6c 95b2                      	swap r27 //multiply depth by 16
002e6d 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002e6e e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002e6f e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002e70 0fec                      	add ZL, r28 //offset the table by the depth+phase
002e71 1df2                      	adc ZH, zero
002e72 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002e73 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002e74 937f                      	push r23
002e75 2f6c                      	mov r22, r28 //store the vibrato value into r22
002e76 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002e77 9f67                      	mul r22, r23
002e78 917f                      	pop r23
002e79 916f                      	pop r22
                                 
002e7a 9416                      	lsr r1 //shift out the fractional bits
002e7b 9407                      	ror r0
002e7c 9416                      	lsr r1
002e7d 9407                      	ror r0
002e7e 9416                      	lsr r1
002e7f 9407                      	ror r0
002e80 9416                      	lsr r1
002e81 9407                      	ror r0
                                 
002e82 91a0 0aac                 	lds r26, TCB2_CCMPL
002e84 91b0 0aad                 	lds r27, TCB2_CCMPH
002e86 19a0                      	sub r26, r0
002e87 09b1                      	sbc r27, r1
002e88 93a0 0aac                 	sts TCB2_CCMPL, r26
002e8a 93b0 0aad                 	sts TCB2_CCMPH, r27
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel2_fx_Qxy_routine:
002e8c 91e0 28fc                 	lds ZL, triangle_fx_Qxy_target
002e8e 91f0 28fd                 	lds ZH, triangle_fx_Qxy_target+1
002e90 9630                      	adiw Z, 0
002e91 f139                      	breq sound_driver_channel2_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002e92 91a0 2900                 	lds r26, triangle_fx_Qxy_total_offset
002e94 91b0 2901                 	lds r27, triangle_fx_Qxy_total_offset+1
002e96 91c0 0aac                 	lds r28, TCB2_CCMPL
002e98 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
002e9a 1bec                      	sub ZL, r28 //calculate the difference to the target
002e9b 0bfd                      	sbc ZH, r29
002e9c f408                      	brsh sound_driver_channel2_fx_Qxy_routine_end //if the target has been reached (or passed)
002e9d f088                      	brlo sound_driver_channel2_fx_Qxy_routine_add
                                 
                                 sound_driver_channel2_fx_Qxy_routine_end:
002e9e 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
002e9f 0bbf                      	sbc r27, ZH
                                 
002ea0 91c0 28fa                 	lds r28, triangle_fx_Pxx_total
002ea2 91d0 28fb                 	lds r29, triangle_fx_Pxx_total+1
                                 
002ea4 0fac                      	add r26, r28
002ea5 1fbd                      	adc r27, r29
                                 
002ea6 93a0 2900                 	sts triangle_fx_Qxy_total_offset, r26 //store the total offset
002ea8 93b0 2901                 	sts triangle_fx_Qxy_total_offset+1, r27
002eaa 9220 28fc                 	sts triangle_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
002eac 9220 28fd                 	sts triangle_fx_Qxy_target+1, zero
002eae c00a                      	rjmp sound_driver_channel2_fx_Rxy_routine
                                 
                                 sound_driver_channel2_fx_Qxy_routine_add:
002eaf 91c0 28fe                 	lds r28, triangle_fx_Qxy_speed
002eb1 91d0 28ff                 	lds r29, triangle_fx_Qxy_speed+1
002eb3 0fac                      	add r26, r28 //increase the total offset by the speed
002eb4 1fbd                      	adc r27, r29
002eb5 93a0 2900                 	sts triangle_fx_Qxy_total_offset, r26 //store the total offset
002eb7 93b0 2901                 	sts triangle_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_Rxy_routine:
002eb9 91e0 2902                 	lds ZL, triangle_fx_Rxy_target
002ebb 91f0 2903                 	lds ZH, triangle_fx_Rxy_target+1
002ebd 9630                      	adiw Z, 0
002ebe f139                      	breq sound_driver_instrument_routine_channel3_volume //if the effect is not enabled, skip the routine
                                 
002ebf 91a0 2906                 	lds r26, triangle_fx_Rxy_total_offset
002ec1 91b0 2907                 	lds r27, triangle_fx_Rxy_total_offset+1
002ec3 91c0 0aac                 	lds r28, TCB2_CCMPL
002ec5 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
002ec7 1bce                      	sub r28, ZL //calculate the difference to the target
002ec8 0bdf                      	sbc r29, ZH
002ec9 f408                      	brsh sound_driver_channel2_fx_Rxy_routine_end //if the target has been reached (or passed)
002eca f088                      	brlo sound_driver_channel2_fx_Rxy_routine_add
                                 
                                 sound_driver_channel2_fx_Rxy_routine_end:
002ecb 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
002ecc 0bbd                      	sbc r27, r29
                                 
002ecd 91c0 28fa                 	lds r28, triangle_fx_Pxx_total
002ecf 91d0 28fb                 	lds r29, triangle_fx_Pxx_total+1
                                 
002ed1 0fac                      	add r26, r28
002ed2 1fbd                      	adc r27, r29
                                 
002ed3 93a0 2906                 	sts triangle_fx_Rxy_total_offset, r26 //store the total offset
002ed5 93b0 2907                 	sts triangle_fx_Rxy_total_offset+1, r27
002ed7 9220 2902                 	sts triangle_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
002ed9 9220 2903                 	sts triangle_fx_Rxy_target+1, zero
002edb c00a                      	rjmp sound_driver_instrument_routine_channel3_volume
                                 
                                 sound_driver_channel2_fx_Rxy_routine_add:
002edc 91c0 2904                 	lds r28, triangle_fx_Rxy_speed
002ede 91d0 2905                 	lds r29, triangle_fx_Rxy_speed+1
002ee0 0fac                      	add r26, r28 //increase the total offset by the speed
002ee1 1fbd                      	adc r27, r29
002ee2 93a0 2906                 	sts triangle_fx_Rxy_total_offset, r26 //store the total offset
002ee4 93b0 2907                 	sts triangle_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume:
002ee6 91e0 2910                 	lds ZL, noise_volume_macro
002ee8 91f0 2911                 	lds ZH, noise_volume_macro+1
002eea 9630                      	adiw Z, 0
002eeb f1a1                      	breq sound_driver_instrument_routine_channel3_volume_default //if no volume macro is in use, use default multiplier of F
002eec 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002eed 1fff                      	rol ZH
002eee 91a0 2912                 	lds r26, noise_volume_macro_offset
002ef0 0fea                      	add ZL, r26
002ef1 1df2                      	adc ZH, zero
                                 
002ef2 91b0 2914                 	lds r27, noise_volume_macro_release
002ef4 17ba                      	cp r27, r26
002ef5 f429                      	brne sound_driver_instrument_routine_channel3_volume_increment //if the current offset is not equal to the release index, increment the offset
002ef6 91a0 2913                 	lds r26, noise_volume_macro_loop
002ef8 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002ef9 f010                      	brlo sound_driver_instrument_routine_channel3_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002efa c003                      	rjmp sound_driver_instrument_routine_channel3_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_volume_increment:
002efb 95a3                      	inc r26 //increment the macro offset
002efc 93a0 2912                 	sts noise_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_volume_read:
002efe 91b4                      	lpm r27, Z //load volume data into r27
002eff 3fbf                      	cpi r27, 0xFF //check for macro end flag
002f00 f469                      	brne sound_driver_instrument_routine_channel3_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_check_release:
002f01 91b0 2914                 	lds r27, noise_volume_macro_release
002f03 3fbf                      	cpi r27, 0xFF
002f04 f429                      	brne sound_driver_instrument_routine_channel3_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_check_loop:
002f05 91b0 2913                 	lds r27, noise_volume_macro_loop //load the loop index
002f07 93b0 2912                 	sts noise_volume_macro_offset, r27 //store the loop index into the offset
002f09 cfdc                      	rjmp sound_driver_instrument_routine_channel3_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_last_index:
002f0a 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002f0b 93a0 2912                 	sts noise_volume_macro_offset, r26
002f0d cfd8                      	rjmp sound_driver_instrument_routine_channel3_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume_calculate:
002f0e e5ee                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
002f0f e6f5                      	ldi ZH, HIGH(volumes << 1)
002f10 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
002f11 0feb                      	add ZL, r27 //add offset to the table
002f12 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel3_volume_load:
002f13 91b0 2813                 	lds r27, noise_param //load main volume
002f15 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002f16 91a0 2945                 	lds r26, noise_fx_7xy_value
002f18 30a0                      	cpi r26, 0x00
002f19 f481                      	brne sound_driver_instrument_routine_channel3_volume_load_7xy
                                 
002f1a 0feb                      	add ZL, r27 //offset the volume table by the main volume
002f1b 1df2                      	adc ZH, zero
002f1c 91b4                      	lpm r27, Z
002f1d 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002f1f c024                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_default:
002f20 91b0 2813                 	lds r27, noise_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
002f22 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002f23 91a0 2945                 	lds r26, noise_fx_7xy_value
002f25 30a0                      	cpi r26, 0x00
002f26 f4a1                      	brne sound_driver_instrument_routine_channel3_volume_default_7xy
002f27 93b0 2816                 	sts noise_output_volume, r27
002f29 c01a                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_load_7xy:
002f2a 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002f2b f040                      	brcs sound_driver_instrument_routine_channel3_volume_load_7xy_overflow
002f2c f039                      	breq sound_driver_instrument_routine_channel3_volume_load_7xy_overflow
002f2d e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
                                 
002f2e 0feb                      	add ZL, r27 //offset the volume table by the main volume
002f2f 1df2                      	adc ZH, zero
002f30 91b4                      	lpm r27, Z
002f31 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002f33 c010                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_load_7xy_overflow:
002f34 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002f35 0feb                      	add ZL, r27 //offset the volume table by the main volume
002f36 1df2                      	adc ZH, zero
002f37 91b4                      	lpm r27, Z
002f38 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002f3a c009                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_default_7xy:
002f3b 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002f3c f020                      	brcs sound_driver_instrument_routine_channel3_volume_default_7xy_overflow
002f3d f019                      	breq sound_driver_instrument_routine_channel3_volume_default_7xy_overflow
002f3e 93b0 2816                 	sts noise_output_volume, r27
002f40 c003                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel3_volume_default_7xy_overflow:
002f41 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002f42 93b0 2816                 	sts noise_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002f44 91e0 2915                 	lds ZL, noise_arpeggio_macro
002f46 91f0 2916                 	lds ZH, noise_arpeggio_macro+1
002f48 9630                      	adiw Z, 0
002f49 f1d9                      	breq sound_driver_instrument_routine_channel3_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002f4a 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002f4b 1fff                      	rol ZH
002f4c 91a0 2917                 	lds r26, noise_arpeggio_macro_offset
002f4e 0fea                      	add ZL, r26
002f4f 1df2                      	adc ZH, zero
                                 
002f50 91b0 2919                 	lds r27, noise_arpeggio_macro_release
002f52 17ba                      	cp r27, r26
002f53 f429                      	brne sound_driver_instrument_routine_channel3_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002f54 91a0 2918                 	lds r26, noise_arpeggio_macro_loop
002f56 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002f57 f010                      	brlo sound_driver_instrument_routine_channel3_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002f58 c003                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_increment:
002f59 95a3                      	inc r26 //increment the macro offset
002f5a 93a0 2917                 	sts noise_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_arpeggio_read:
002f5c 91b4                      	lpm r27, Z //load arpeggio data into r27
002f5d 38b0                      	cpi r27, 0x80 //check for macro end flag
002f5e f009                      	breq sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag
002f5f c041                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_check_mode:
002f60 50a1                      	subi r26, 1 //keep the offset at the end flag
002f61 93a0 2917                 	sts noise_arpeggio_macro_offset, r26
002f63 91b0 291a                 	lds r27, noise_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002f65 30b1                      	cpi r27, 0x01
002f66 f048                      	brlo sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_fixed_relative_check_release:
002f67 91b0 2919                 	lds r27, noise_arpeggio_macro_release
002f69 3fbf                      	cpi r27, 0xFF
002f6a f4d1                      	brne sound_driver_instrument_routine_channel3_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_fixed_relative_check_loop:
002f6b 91b0 2918                 	lds r27, noise_arpeggio_macro_loop
002f6d 3fbf                      	cpi r27, 0xFF
002f6e f499                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002f6f c015                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute:
002f70 91b0 2919                 	lds r27, noise_arpeggio_macro_release
002f72 3fbf                      	cpi r27, 0xFF
002f73 f421                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_check_loop:
002f74 91b0 2918                 	lds r27, noise_arpeggio_macro_loop //load the loop index
002f76 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002f77 f451                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_no_loop:
002f78 91c0 292d                 	lds r28, noise_fx_0xy_sequence //check for 0xy effect
002f7a 91d0 292e                 	lds r29, noise_fx_0xy_sequence+1
002f7c 9620                      	adiw r29:r28, 0
002f7d f469                      	brne sound_driver_instrument_routine_channel3_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002f7e 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002f7f 93a0 2917                 	sts noise_arpeggio_macro_offset, r26 //store the last valid index into the offset
002f81 cfc2                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload:
002f82 93b0 2917                 	sts noise_arpeggio_macro_offset, r27 //store the loop index into the offset
002f84 cfbf                      	rjmp sound_driver_instrument_routine_channel3_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_default:
002f85 91c0 292d                 	lds r28, noise_fx_0xy_sequence //load 0xy effect
002f87 91d0 292e                 	lds r29, noise_fx_0xy_sequence+1
002f89 9620                      	adiw r29:r28, 0 //check for 0xy effect
002f8a f099                      	breq sound_driver_instrument_routine_channel3_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel3_arpeggio_default_xy:
002f8b 95d6                      	lsr r29
002f8c 95c7                      	ror r28
002f8d 95d7                      	ror r29
002f8e 95c7                      	ror r28
002f8f 95d7                      	ror r29
002f90 95c7                      	ror r28
002f91 95d7                      	ror r29
002f92 95c7                      	ror r28
002f93 95d7                      	ror r29
002f94 95d2                      	swap r29
                                 
002f95 93c0 292d                 	sts noise_fx_0xy_sequence, r28 //store the rolled sequence
002f97 93d0 292e                 	sts noise_fx_0xy_sequence+1, r29
002f99 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002f9a 91a0 2817                 	lds r26, noise_note //load the current note index
002f9c 0fac                      	add r26, r28 //add the note offset
002f9d c02e                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel3_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002f9e 91a0 2817                 	lds r26, noise_note //load the current note index
002fa0 c02b                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process:
002fa1 9220 291b                 	sts noise_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002fa3 9220 291c                 	sts noise_total_pitch_offset+1, zero
002fa5 9220 2922                 	sts noise_total_hi_pitch_offset, zero
002fa7 91a0 291a                 	lds r26, noise_arpeggio_macro_mode
002fa9 30a1                      	cpi r26, 0x01 //absolute mode
002faa f010                      	brlo sound_driver_instrument_routine_channel3_arpeggio_process_absolute
002fab f069                      	breq sound_driver_instrument_routine_channel3_arpeggio_process_fixed
002fac c00e                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_absolute:
002fad 91a0 2817                 	lds r26, noise_note //load the current note index
002faf 0fab                      	add r26, r27 //offset the note with the arpeggio data
002fb0 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002fb1 c004                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_absolute_add:
002fb2 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002fb3 f0c0                      	brlo sound_driver_instrument_routine_channel3_arpeggio_process_load //if the result is valid, go load the new note
002fb4 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002fb5 c016                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_absolute_subtract:
002fb6 fda7                      	sbrc r26, 7 //check if result is negative
002fb7 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002fb8 c013                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_fixed:
002fb9 2fab                      	mov r26, r27 //move the arpeggio data into r26
002fba c011                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_relative:
002fbb 91a0 2817                 	lds r26, noise_note //load the current note index
002fbd 0fab                      	add r26, r27 //offset the note with the arpeggio data
002fbe fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002fbf c008                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_relative_add:
002fc0 93a0 2817                 	sts noise_note, r26 //NOTE: relative mode modifies the original note index
002fc2 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002fc3 f040                      	brlo sound_driver_instrument_routine_channel3_arpeggio_process_load //if the result is valid, go load the new note
002fc4 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002fc5 93a0 2817                 	sts noise_note, r26
002fc7 c004                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_relative_subtract:
002fc8 fda7                      	sbrc r26, 7 //check if result is negative
002fc9 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002fca 93a0 2817                 	sts noise_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_load:
002fcc e4e2                      	ldi ZL, LOW(noise_period_table << 1) //load in note table
002fcd e0f1                      	ldi ZH, HIGH(noise_period_table << 1)
002fce 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002fcf 0fea                      	add ZL, r26 //add offset
002fd0 1df2                      	adc ZH, zero
002fd1 91a5                      	lpm r26, Z+ //load bytes
002fd2 91b4                      	lpm r27, Z
002fd3 93a0 0abc                 	sts TCB3_CCMPL, r26 //load the LOW bits for timer
002fd5 93b0 0abd                 	sts TCB3_CCMPH, r27 //load the HIGH bits for timer
002fd7 93a0 2939                 	sts noise_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002fd9 93b0 293a                 	sts noise_fx_3xx_target+1, r27
002fdb c000                      	rjmp sound_driver_instrument_routine_channel3_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch:
002fdc 91e0 291d                 	lds ZL, noise_pitch_macro
002fde 91f0 291e                 	lds ZH, noise_pitch_macro+1
002fe0 9630                      	adiw Z, 0
002fe1 f409                      	brne sound_driver_instrument_routine_channel3_pitch_continue
002fe2 c023                      	rjmp sound_driver_instrument_routine_channel3_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel3_pitch_continue:
002fe3 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002fe4 1fff                      	rol ZH
002fe5 91a0 291f                 	lds r26, noise_pitch_macro_offset
002fe7 0fea                      	add ZL, r26
002fe8 1df2                      	adc ZH, zero
                                 
002fe9 91b0 2921                 	lds r27, noise_pitch_macro_release
002feb 17ba                      	cp r27, r26
002fec f429                      	brne sound_driver_instrument_routine_channel3_pitch_increment //if the current offset is not equal to the release index, increment the offset
002fed 91a0 2920                 	lds r26, noise_pitch_macro_loop
002fef 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002ff0 f010                      	brlo sound_driver_instrument_routine_channel3_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002ff1 c003                      	rjmp sound_driver_instrument_routine_channel3_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_pitch_increment:
002ff2 95a3                      	inc r26 //increment the macro offset
002ff3 93a0 291f                 	sts noise_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_pitch_read:
002ff5 91b4                      	lpm r27, Z //load pitch data into r27
002ff6 38b0                      	cpi r27, 0x80 //check for macro end flag
002ff7 f479                      	brne sound_driver_instrument_routine_channel3_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag_check_release:
002ff8 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002ff9 93a0 291f                 	sts noise_pitch_macro_offset, r26
002ffb 91b0 2921                 	lds r27, noise_pitch_macro_release
002ffd 3fbf                      	cpi r27, 0xFF
002ffe f439                      	brne sound_driver_instrument_routine_channel3_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag_check_loop:
002fff 91b0 2920                 	lds r27, noise_pitch_macro_loop //load the loop index
003001 3fbf                      	cpi r27, 0xFF //check if there is a loop index
003002 f019                      	breq sound_driver_instrument_routine_channel3_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
003003 93b0 291f                 	sts noise_pitch_macro_offset, r27 //store the loop index into the offset
003005 cfd6                      	rjmp sound_driver_instrument_routine_channel3_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch_default:
003006 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel3_pitch_calculate:
003007 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
003008 937f                      	push r23
003009 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
00300a eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00300b 0367                      	mulsu r22, r23
00300c 917f                      	pop r23
00300d 916f                      	pop r22
                                 
00300e 9416                      	lsr r1 //shift out the fractional bits
00300f 9407                      	ror r0
003010 9416                      	lsr r1
003011 9407                      	ror r0
003012 9416                      	lsr r1
003013 9407                      	ror r0
003014 9416                      	lsr r1
003015 9407                      	ror r0
003016 fe13                      	sbrs r1, 3 //check if result was a negative number
003017 c002                      	rjmp sound_driver_instrument_routine_channel3_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel3_pitch_calculate_negative:
003018 efb0                      	ldi r27, 0xF0
003019 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel3_pitch_calculate_offset:
00301a 91a0 291b                 	lds r26, noise_total_pitch_offset
00301c 91b0 291c                 	lds r27, noise_total_pitch_offset+1
00301e 0e0a                      	add r0, r26
00301f 1e1b                      	adc r1, r27
003020 9200 291b                 	sts noise_total_pitch_offset, r0
003022 9210 291c                 	sts noise_total_pitch_offset+1, r1
003024 91a0 0abc                 	lds r26, TCB3_CCMPL //load the low bits for timer
003026 91b0 0abd                 	lds r27, TCB3_CCMPH //load the high bits for timer
003028 0da0                      	add r26, r0 //offset the timer values
003029 1db1                      	adc r27, r1
                                 	
00302a 91c0 2931                 	lds r28, noise_fx_1xx_total
00302c 91d0 2932                 	lds r29, noise_fx_1xx_total+1
00302e 1bac                      	sub r26, r28
00302f 0bbd                      	sbc r27, r29
003030 91c0 2935                 	lds r28, noise_fx_2xx_total
003032 91d0 2936                 	lds r29, noise_fx_2xx_total+1
003034 0fac                      	add r26, r28
003035 1fbd                      	adc r27, r29
003036 91c0 2949                 	lds r28, noise_fx_Pxx_total
003038 91d0 294a                 	lds r29, noise_fx_Pxx_total+1
00303a 0fac                      	add r26, r28
00303b 1fbd                      	adc r27, r29
00303c 91c0 294f                 	lds r28, noise_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
00303e 91d0 2950                 	lds r29, noise_fx_Qxy_total_offset+1
003040 1bac                      	sub r26, r28
003041 0bbd                      	sbc r27, r29
003042 91c0 2955                 	lds r28, noise_fx_Rxy_total_offset
003044 91d0 2956                 	lds r29, noise_fx_Rxy_total_offset+1
003046 0fac                      	add r26, r28
003047 1fbd                      	adc r27, r29
                                 
003048 93a0 0abc                 	sts TCB3_CCMPL, r26 //store the new low bits for timer
00304a 93b0 0abd                 	sts TCB3_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel3_hi_pitch:
00304c 91e0 2923                 	lds ZL, noise_hi_pitch_macro
00304e 91f0 2924                 	lds ZH, noise_hi_pitch_macro+1
003050 9630                      	adiw Z, 0
003051 f409                      	brne sound_driver_instrument_routine_channel3_hi_pitch_continue
003052 c03c                      	rjmp sound_driver_instrument_routine_channel3_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel3_hi_pitch_continue:
003053 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
003054 1fff                      	rol ZH
003055 91a0 2925                 	lds r26, noise_hi_pitch_macro_offset
003057 0fea                      	add ZL, r26
003058 1df2                      	adc ZH, zero
                                 
003059 91b0 2927                 	lds r27, noise_hi_pitch_macro_release
00305b 17ba                      	cp r27, r26
00305c f429                      	brne sound_driver_instrument_routine_channel3_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
00305d 91a0 2926                 	lds r26, noise_hi_pitch_macro_loop
00305f 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
003060 f010                      	brlo sound_driver_instrument_routine_channel3_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
003061 c003                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_increment:
003062 95a3                      	inc r26 //increment the macro offset
003063 93a0 2925                 	sts noise_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_hi_pitch_read:
003065 91b4                      	lpm r27, Z //load hi pitch data into r27
003066 38b0                      	cpi r27, 0x80 //check for macro end flag
003067 f489                      	brne sound_driver_instrument_routine_channel3_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag_check_release:
003068 50a1                      	subi r26, 1 //keep the macro offset at the end flag
003069 93a0 2925                 	sts noise_hi_pitch_macro_offset, r26
00306b 91b0 2927                 	lds r27, noise_hi_pitch_macro_release
00306d 3fbf                      	cpi r27, 0xFF
00306e f439                      	brne sound_driver_instrument_routine_channel3_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag_check_loop:
00306f 91b0 2926                 	lds r27, noise_hi_pitch_macro_loop //load the loop index
003071 3fbf                      	cpi r27, 0xFF //check if there is a loop index
003072 f019                      	breq sound_driver_instrument_routine_channel3_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
003073 93b0 2925                 	sts noise_hi_pitch_macro_offset, r27 //store the loop index into the offset
003075 cfd6                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_default:
003076 91b0 2922                 	lds r27, noise_total_hi_pitch_offset
003078 c005                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate:
003079 91a0 2922                 	lds r26, noise_total_hi_pitch_offset //load the total hi pitch offset to change
00307b 0fba                      	add r27, r26
00307c 93b0 2922                 	sts noise_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate_multiply:
00307e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00307f 937f                      	push r23
003080 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
003081 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
003082 0367                      	mulsu r22, r23
003083 917f                      	pop r23
003084 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate_offset:
003085 91a0 0abc                 	lds r26, TCB3_CCMPL //load the low bits for timer
003087 91b0 0abd                 	lds r27, TCB3_CCMPH //load the high bits for timer
003089 0da0                      	add r26, r0 //offset the timer values
00308a 1db1                      	adc r27, r1
00308b 93a0 0abc                 	sts TCB3_CCMPL, r26 //store the new low bits for timer
00308d 93b0 0abd                 	sts TCB3_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty:
00308f 91e0 2928                 	lds ZL, noise_duty_macro
003091 91f0 2929                 	lds ZH, noise_duty_macro+1
003093 9630                      	adiw Z, 0
003094 f169                      	breq sound_driver_channel3_fx_routines //if no duty macro is in use, go to the next routine
003095 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
003096 1fff                      	rol ZH
003097 91a0 292a                 	lds r26, noise_duty_macro_offset
003099 0fea                      	add ZL, r26
00309a 1df2                      	adc ZH, zero
                                 
00309b 91b0 292c                 	lds r27, noise_duty_macro_release
00309d 17ba                      	cp r27, r26
00309e f429                      	brne sound_driver_instrument_routine_channel3_duty_increment //if the current offset is not equal to the release index, increment the offset
00309f 91a0 292b                 	lds r26, noise_duty_macro_loop
0030a1 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0030a2 f010                      	brlo sound_driver_instrument_routine_channel3_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0030a3 c01e                      	rjmp sound_driver_channel3_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel3_duty_increment:
0030a4 95a3                      	inc r26 //increment the macro offset
0030a5 93a0 292a                 	sts noise_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_duty_read:
0030a7 91b4                      	lpm r27, Z //load pitch data into r27
0030a8 3fbf                      	cpi r27, 0xFF //check for macro end flag
0030a9 f471                      	brne sound_driver_instrument_routine_channel3_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag_check_release:
0030aa 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0030ab 93a0 292a                 	sts noise_duty_macro_offset, r26
0030ad 91b0 292c                 	lds r27, noise_duty_macro_release
0030af 3fbf                      	cpi r27, 0xFF
0030b0 f489                      	brne sound_driver_channel3_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag_check_loop:
0030b1 91b0 292b                 	lds r27, noise_duty_macro_loop //load the loop index
0030b3 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0030b4 f069                      	breq sound_driver_channel3_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
0030b5 93b0 292a                 	sts noise_duty_macro_offset, r27 //store the loop index into the offset
0030b7 cfd7                      	rjmp sound_driver_instrument_routine_channel3_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty_load:
0030b8 95b6                      	lsr r27
0030b9 95b7                      	ror r27 //move mode bit to bit 7
0030ba 91c0 2814                 	lds r28, noise_period
0030bc 77cf                      	andi r28, 0b01111111
0030bd 2bcb                      	or r28, r27 //store the new noise mode
0030be 93c0 2813                 	sts noise_param, r28
                                 
0030c0 776f                      	andi noise_sequence_HIGH, 0b01111111
0030c1 2b6b                      	or noise_sequence_HIGH, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_routines:
                                 sound_driver_channel3_fx_1xx_routine:
0030c2 91e0 292f                 	lds ZL, noise_fx_1xx
0030c4 91f0 2930                 	lds ZH, noise_fx_1xx+1
0030c6 9630                      	adiw Z, 0
0030c7 f051                      	breq sound_driver_channel3_fx_2xx_routine
                                 
0030c8 91a0 2931                 	lds r26, noise_fx_1xx_total //load the rate to change the pitch by
0030ca 91b0 2932                 	lds r27, noise_fx_1xx_total+1
0030cc 0fae                      	add r26, ZL //increase the total offset by the rate
0030cd 1fbf                      	adc r27, ZH
0030ce 93a0 2931                 	sts noise_fx_1xx_total, r26
0030d0 93b0 2932                 	sts noise_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_2xx_routine:
0030d2 91e0 2933                 	lds ZL, noise_fx_2xx
0030d4 91f0 2934                 	lds ZH, noise_fx_2xx+1
0030d6 9630                      	adiw Z, 0
0030d7 f051                      	breq sound_driver_channel3_fx_3xx_routine
                                 
0030d8 91a0 2935                 	lds r26, noise_fx_2xx_total //load the rate to change the pitch by
0030da 91b0 2936                 	lds r27, noise_fx_2xx_total+1
0030dc 0fae                      	add r26, ZL //increase the total offset by the rate
0030dd 1fbf                      	adc r27, ZH
0030de 93a0 2935                 	sts noise_fx_2xx_total, r26
0030e0 93b0 2936                 	sts noise_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_3xx_routine:
0030e2 91e0 293b                 	lds ZL, noise_fx_3xx_speed
0030e4 91f0 293c                 	lds ZH, noise_fx_3xx_speed+1
0030e6 9630                      	adiw Z, 0
0030e7 f409                      	brne sound_driver_channel3_fx_3xx_routine_check_start
0030e8 c048                      	rjmp sound_driver_channel3_fx_4xy_routine
                                 
                                 sound_driver_channel3_fx_3xx_routine_check_start:
0030e9 91a0 2937                 	lds r26, noise_fx_3xx_start
0030eb 91b0 2938                 	lds r27, noise_fx_3xx_start+1
0030ed 9610                      	adiw r26:r27, 0
0030ee f409                      	brne sound_driver_channel3_fx_3xx_routine_main
0030ef c041                      	rjmp sound_driver_channel3_fx_4xy_routine
                                 
                                 sound_driver_channel3_fx_3xx_routine_main:
0030f0 91c0 2939                 	lds r28, noise_fx_3xx_target
0030f2 91d0 293a                 	lds r29, noise_fx_3xx_target+1
                                 
0030f4 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
0030f5 07bd                      	cpc r27, r29
0030f6 f011                      	breq sound_driver_channel3_fx_3xx_routine_disable
0030f7 f030                      	brlo sound_driver_channel3_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
0030f8 c01f                      	rjmp sound_driver_channel3_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel3_fx_3xx_routine_disable:
0030f9 9220 2937                 	sts noise_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
0030fb 9220 2938                 	sts noise_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
0030fd c033                      	rjmp sound_driver_channel3_fx_4xy_routine
                                 
                                 sound_driver_channel3_fx_3xx_routine_subtract:
0030fe 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
0030ff 0bdb                      	sbc r29, r27
003100 91a0 293d                 	lds r26, noise_fx_3xx_total_offset
003102 91b0 293e                 	lds r27, noise_fx_3xx_total_offset+1
                                 
003104 0fae                      	add r26, ZL //add the speed to the total offset
003105 1fbf                      	adc r27, ZH
003106 1bca                      	sub r28, r26 //invert the total difference with the total offset
003107 0bdb                      	sbc r29, r27
003108 f380                      	brlo sound_driver_channel3_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
003109 93a0 293d                 	sts noise_fx_3xx_total_offset, r26 //store the new total offset
00310b 93b0 293e                 	sts noise_fx_3xx_total_offset+1, r27
                                 
00310d 91a0 0abc                 	lds r26, TCB3_CCMPL //load the current timer period
00310f 91b0 0abd                 	lds r27, TCB3_CCMPH
003111 1bac                      	sub r26, r28 //offset the current timer period with the total offset
003112 0bbd                      	sbc r27, r29
003113 93a0 0abc                 	sts TCB3_CCMPL, r26
003115 93b0 0abd                 	sts TCB3_CCMPH, r27
003117 c019                      	rjmp sound_driver_channel3_fx_4xy_routine
                                 
                                 sound_driver_channel3_fx_3xx_routine_add:
003118 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
003119 0bbd                      	sbc r27, r29
00311a 91c0 293d                 	lds r28, noise_fx_3xx_total_offset
00311c 91d0 293e                 	lds r29, noise_fx_3xx_total_offset+1
                                 
00311e 0fce                      	add r28, ZL //add the speed to the total offset
00311f 1fdf                      	adc r29, ZH
003120 1bac                      	sub r26, r28 //invert the total difference with the total offset
003121 0bbd                      	sbc r27, r29
003122 f2b0                      	brlo sound_driver_channel3_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
003123 93c0 293d                 	sts noise_fx_3xx_total_offset, r28 //store the new total offset
003125 93d0 293e                 	sts noise_fx_3xx_total_offset+1, r29
                                 
003127 91c0 0abc                 	lds r28, TCB3_CCMPL //load the current timer period
003129 91d0 0abd                 	lds r29, TCB3_CCMPH
00312b 0fca                      	add r28, r26 //offset the current timer period with the total offset
00312c 1fdb                      	adc r29, r27
00312d 93c0 0abc                 	sts TCB3_CCMPL, r28
00312f 93d0 0abd                 	sts TCB3_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel3_fx_4xy_routine:
003131 91a0 293f                 	lds r26, noise_fx_4xy_speed
003133 15a2                      	cp r26, zero
003134 f409                      	brne sound_driver_channel3_fx_4xy_routine_continue
003135 c05c                      	rjmp sound_driver_channel3_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel3_fx_4xy_routine_continue:
003136 91b0 2940                 	lds r27, noise_fx_4xy_depth
003138 91c0 2941                 	lds r28, noise_fx_4xy_phase
00313a 0fca                      	add r28, r26 //increase the phase by the speed
00313b 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
00313c f008                      	brlo sound_driver_channel3_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
00313d 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase:
00313e 93c0 2941                 	sts noise_fx_4xy_phase, r28 //store the new phase
003140 31c0                      	cpi r28, 16
003141 f028                      	brlo sound_driver_channel3_fx_4xy_routine_phase_0
003142 32c0                      	cpi r28, 32
003143 f028                      	brlo sound_driver_channel3_fx_4xy_routine_phase_1
003144 33c0                      	cpi r28, 48
003145 f030                      	brlo sound_driver_channel3_fx_4xy_routine_phase_2
003146 c007                      	rjmp sound_driver_channel3_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_0:
003147 70cf                      	andi r28, 0x0F //mask for values 0-15
003148 c029                      	rjmp sound_driver_channel3_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_1:
003149 6fc0                      	ori r28, 0xF0
00314a 95c0                      	com r28 //invert values 0-15
00314b c026                      	rjmp sound_driver_channel3_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_2:
00314c 70cf                      	andi r28, 0x0F //mask for values 0-15
00314d c003                      	rjmp sound_driver_channel3_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_3:
00314e 6fc0                      	ori r28, 0xF0
00314f 95c0                      	com r28 //invert values 0-15
003150 c000                      	rjmp sound_driver_channel3_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel3_fx_4xy_routine_load_add:
003151 95b2                      	swap r27 //multiply depth by 16
003152 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
003153 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
003154 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
003155 0fec                      	add ZL, r28 //offset the table by the depth+phase
003156 1df2                      	adc ZH, zero
003157 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
003158 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
003159 937f                      	push r23
00315a 2f6c                      	mov r22, r28 //store the vibrato value into r22
00315b eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00315c 9f67                      	mul r22, r23
00315d 917f                      	pop r23
00315e 916f                      	pop r22
                                 
00315f 9416                      	lsr r1 //shift out the fractional bits
003160 9407                      	ror r0
003161 9416                      	lsr r1
003162 9407                      	ror r0
003163 9416                      	lsr r1
003164 9407                      	ror r0
003165 9416                      	lsr r1
003166 9407                      	ror r0
                                 	
003167 91a0 0abc                 	lds r26, TCB3_CCMPL
003169 91b0 0abd                 	lds r27, TCB3_CCMPH
00316b 0da0                      	add r26, r0
00316c 1db1                      	adc r27, r1
00316d 93a0 0abc                 	sts TCB3_CCMPL, r26
00316f 93b0 0abd                 	sts TCB3_CCMPH, r27
003171 c020                      	rjmp sound_driver_channel3_fx_7xy_routine
                                 
                                 sound_driver_channel3_fx_4xy_routine_load_subtract:
003172 95b2                      	swap r27 //multiply depth by 16
003173 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
003174 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
003175 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
003176 0fec                      	add ZL, r28 //offset the table by the depth+phase
003177 1df2                      	adc ZH, zero
003178 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
003179 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00317a 937f                      	push r23
00317b 2f6c                      	mov r22, r28 //store the vibrato value into r22
00317c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00317d 9f67                      	mul r22, r23
00317e 917f                      	pop r23
00317f 916f                      	pop r22
                                 
003180 9416                      	lsr r1 //shift out the fractional bits
003181 9407                      	ror r0
003182 9416                      	lsr r1
003183 9407                      	ror r0
003184 9416                      	lsr r1
003185 9407                      	ror r0
003186 9416                      	lsr r1
003187 9407                      	ror r0
                                 
003188 91a0 0abc                 	lds r26, TCB3_CCMPL
00318a 91b0 0abd                 	lds r27, TCB3_CCMPH
00318c 19a0                      	sub r26, r0
00318d 09b1                      	sbc r27, r1
00318e 93a0 0abc                 	sts TCB3_CCMPL, r26
003190 93b0 0abd                 	sts TCB3_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_7xy_routine:
003192 91a0 2942                 	lds r26, noise_fx_7xy_speed
003194 15a2                      	cp r26, zero
003195 f0f1                      	breq sound_driver_channel3_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
003196 91b0 2943                 	lds r27, noise_fx_7xy_depth
003198 91c0 2944                 	lds r28, noise_fx_7xy_phase
00319a 0fca                      	add r28, r26 //increase the phase by the speed
00319b 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
00319c f010                      	brlo sound_driver_channel3_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
00319d e0c0                      	ldi r28, 0x00
00319e 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel3_fx_7xy_routine_phase:
00319f 93c0 2944                 	sts noise_fx_7xy_phase, r28 //store the new phase
0031a1 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
0031a2 ffc4                      	sbrs r28, 4
0031a3 c001                      	rjmp sound_driver_channel3_fx_7xy_routine_phase_0
0031a4 c002                      	rjmp sound_driver_channel3_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel3_fx_7xy_routine_phase_0:
0031a5 70cf                      	andi r28, 0x0F //mask for values 0-15
0031a6 c003                      	rjmp sound_driver_channel3_fx_7xy_routine_load
                                 
                                 sound_driver_channel3_fx_7xy_routine_phase_1:
0031a7 6fc0                      	ori r28, 0xF0
0031a8 95c0                      	com r28 //invert values 0-15
0031a9 c000                      	rjmp sound_driver_channel3_fx_7xy_routine_load
                                 
                                 sound_driver_channel3_fx_7xy_routine_load:
0031aa 95b2                      	swap r27 //multiply depth by 16
0031ab 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0031ac e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0031ad e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0031ae 0fec                      	add ZL, r28 //offset the table by the depth+phase
0031af 1df2                      	adc ZH, zero
0031b0 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
0031b1 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
0031b2 93c0 2945                 	sts noise_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Axy_routine:
0031b4 91b0 2946                 	lds r27, noise_fx_Axy
0031b6 15b2                      	cp r27, zero
0031b7 f0e9                      	breq sound_driver_channel3_fx_Qxy_routine //0 means that the effect is not in use
                                 	
0031b8 91a0 2815                 	lds r26, noise_fractional_volume //load fractional volume representation of the channel
0031ba 91c0 2813                 	lds r28, noise_param //load the integer volume representation of the channel
0031bc 2fda                      	mov r29, r26 //copy fractional volume into r29
0031bd 2fec                      	mov r30, r28 //copy the noise_param into r30
0031be 95e2                      	swap r30
0031bf 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
0031c0 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
0031c1 17ed                      	cp r30, r29 //compare the fractional and integer volumes
0031c2 f009                      	breq sound_driver_channel3_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel3_fx_Axy_routine_reload:
0031c3 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate:
0031c4 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
0031c5 c004                      	rjmp sound_driver_channel3_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_addition:
0031c6 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0031c7 f428                      	brcc sound_driver_channel3_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0031c8 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
0031c9 c003                      	rjmp sound_driver_channel3_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_subtraction:
0031ca 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0031cb f008                      	brcs sound_driver_channel3_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0031cc e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_store:
0031cd 93a0 2815                 	sts noise_fractional_volume, r26 //store the new fractional volume
0031cf 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
0031d0 95a2                      	swap r26
0031d1 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
0031d2 2bca                      	or r28, r26 //store the new volume back into noise_param
0031d3 93c0 2813                 	sts noise_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel3_fx_Qxy_routine:
0031d5 91e0 294b                 	lds ZL, noise_fx_Qxy_target
0031d7 91f0 294c                 	lds ZH, noise_fx_Qxy_target+1
0031d9 9630                      	adiw Z, 0
0031da f139                      	breq sound_driver_channel3_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
0031db 91a0 294f                 	lds r26, noise_fx_Qxy_total_offset
0031dd 91b0 2950                 	lds r27, noise_fx_Qxy_total_offset+1
0031df 91c0 0abc                 	lds r28, TCB3_CCMPL
0031e1 91d0 0abd                 	lds r29, TCB3_CCMPH
                                 
0031e3 1bec                      	sub ZL, r28 //calculate the difference to the target
0031e4 0bfd                      	sbc ZH, r29
0031e5 f408                      	brsh sound_driver_channel3_fx_Qxy_routine_end //if the target has been reached (or passed)
0031e6 f088                      	brlo sound_driver_channel3_fx_Qxy_routine_add
                                 
                                 sound_driver_channel3_fx_Qxy_routine_end:
0031e7 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
0031e8 0bbf                      	sbc r27, ZH
                                 
0031e9 91c0 2949                 	lds r28, noise_fx_Pxx_total
0031eb 91d0 294a                 	lds r29, noise_fx_Pxx_total+1
                                 
0031ed 0fac                      	add r26, r28
0031ee 1fbd                      	adc r27, r29
                                 
0031ef 93a0 294f                 	sts noise_fx_Qxy_total_offset, r26 //store the total offset
0031f1 93b0 2950                 	sts noise_fx_Qxy_total_offset+1, r27
0031f3 9220 294b                 	sts noise_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
0031f5 9220 294c                 	sts noise_fx_Qxy_target+1, zero
0031f7 c00a                      	rjmp sound_driver_channel3_fx_Rxy_routine
                                 
                                 sound_driver_channel3_fx_Qxy_routine_add:
0031f8 91c0 294d                 	lds r28, noise_fx_Qxy_speed
0031fa 91d0 294e                 	lds r29, noise_fx_Qxy_speed+1
0031fc 0fac                      	add r26, r28 //increase the total offset by the speed
0031fd 1fbd                      	adc r27, r29
0031fe 93a0 294f                 	sts noise_fx_Qxy_total_offset, r26 //store the total offset
003200 93b0 2950                 	sts noise_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Rxy_routine:
003202 91e0 2951                 	lds ZL, noise_fx_Rxy_target
003204 91f0 2952                 	lds ZH, noise_fx_Rxy_target+1
003206 9630                      	adiw Z, 0
003207 f139                      	breq sound_driver_instrument_routine_channel4_volume //if the effect is not enabled, skip the routine
                                 
003208 91a0 2955                 	lds r26, noise_fx_Rxy_total_offset
00320a 91b0 2956                 	lds r27, noise_fx_Rxy_total_offset+1
00320c 91c0 0abc                 	lds r28, TCB3_CCMPL
00320e 91d0 0abd                 	lds r29, TCB3_CCMPH
                                 
003210 1bce                      	sub r28, ZL //calculate the difference to the target
003211 0bdf                      	sbc r29, ZH
003212 f408                      	brsh sound_driver_channel3_fx_Rxy_routine_end //if the target has been reached (or passed)
003213 f088                      	brlo sound_driver_channel3_fx_Rxy_routine_add
                                 
                                 sound_driver_channel3_fx_Rxy_routine_end:
003214 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
003215 0bbd                      	sbc r27, r29
                                 
003216 91c0 2949                 	lds r28, noise_fx_Pxx_total
003218 91d0 294a                 	lds r29, noise_fx_Pxx_total+1
                                 
00321a 0fac                      	add r26, r28
00321b 1fbd                      	adc r27, r29
                                 
00321c 93a0 2955                 	sts noise_fx_Rxy_total_offset, r26 //store the total offset
00321e 93b0 2956                 	sts noise_fx_Rxy_total_offset+1, r27
003220 9220 2951                 	sts noise_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
003222 9220 2952                 	sts noise_fx_Rxy_target+1, zero
003224 c00a                      	rjmp sound_driver_instrument_routine_channel4_volume
                                 
                                 sound_driver_channel3_fx_Rxy_routine_add:
003225 91c0 2953                 	lds r28, noise_fx_Rxy_speed
003227 91d0 2954                 	lds r29, noise_fx_Rxy_speed+1
003229 0fac                      	add r26, r28 //increase the total offset by the speed
00322a 1fbd                      	adc r27, r29
00322b 93a0 2955                 	sts noise_fx_Rxy_total_offset, r26 //store the total offset
00322d 93b0 2956                 	sts noise_fx_Rxy_total_offset+1, r27
                                 
                                 sound_driver_instrument_routine_channel4_volume:
                                 
                                 sound_driver_exit:
00322f 91ff                      	pop r31
003230 91ef                      	pop r30
003231 91df                      	pop r29
003232 91cf                      	pop r28
003233 940c 1717                 	jmp sequence_1_3 + 3 //+3 is to skip the stack instructions since we already pushed them
                                 
                                 
                                 
                                 //TABLES
003235 7f05
003236 010a
003237 0214
003238 0328
003239 0450
00323a 051e
00323b 0607
00323c 070d
00323d 0806
00323e 090c
00323f 0a18
003240 0b30
003241 0c60
003242 0d24
003243 0e08
003244 0f10                      length: .db $05, $7F, $0A, $01, $14, $02, $28, $03, $50, $04, $1E, $05, $07, $06, $0D, $07, $06, $08, $0C, $09, $18, $0A, $30, $0B, $60, $0C, $24, $0D, $08, $0E, $10, $0F
                                 
                                 //pulse sequences: 12.5%, 25%, 50%, 75%
003245 0301
003246 fc0f                      sequences: .db 0b00000001, 0b00000011, 0b00001111, 0b11111100
                                 
                                 //list of famitracker fx: http://famitracker.com/wiki/index.php?title=Effect_list
                                 channel0_fx:
003247 1953
003248 1958
003249 1974
00324a 1990
00324b 19b3                      	.dw sound_driver_channel0_fx_0xy, sound_driver_channel0_fx_1xx, sound_driver_channel0_fx_2xx, sound_driver_channel0_fx_3xx, sound_driver_channel0_fx_4xy
00324c 19be
00324d 19cb
00324e 19ce
00324f 19d1
003250 19d4                      	.dw sound_driver_channel0_fx_7xy, sound_driver_channel0_fx_Axy, sound_driver_channel0_fx_Bxx, sound_driver_channel0_fx_Cxx, sound_driver_channel0_fx_Dxx
003251 19d7
003252 19df
003253 19e2
003254 19ef
003255 19f0                      	.dw sound_driver_channel0_fx_Exx, sound_driver_channel0_fx_Fxx, sound_driver_channel0_fx_Gxx, sound_driver_channel0_fx_Hxy, sound_driver_channel0_fx_Ixy
003256 19f1
003257 19f2
003258 19f3
003259 1a07
00325a 1a4b                      	.dw sound_driver_channel0_fx_Hxx, sound_driver_channel0_fx_Ixx, sound_driver_channel0_fx_Pxx, sound_driver_channel0_fx_Qxy, sound_driver_channel0_fx_Rxy
00325b 1a8e
00325c 1a9b
00325d 1aaf
00325e 1ab0
00325f 1ab1                      	.dw sound_driver_channel0_fx_Sxx, sound_driver_channel0_fx_Vxx, sound_driver_channel0_fx_Wxx, sound_driver_channel0_fx_Xxx, sound_driver_channel0_fx_Yxx
003260 1ab2                      	.dw sound_driver_channel0_fx_Zxx
                                 
                                 channel1_fx:
003261 1c34
003262 1c39
003263 1c55
003264 1c71
003265 1c94                      	.dw sound_driver_channel1_fx_0xy, sound_driver_channel1_fx_1xx, sound_driver_channel1_fx_2xx, sound_driver_channel1_fx_3xx, sound_driver_channel1_fx_4xy
003266 1c9f
003267 1cac
003268 1caf
003269 1cb2
00326a 1cb5                      	.dw sound_driver_channel1_fx_7xy, sound_driver_channel1_fx_Axy, sound_driver_channel1_fx_Bxx, sound_driver_channel1_fx_Cxx, sound_driver_channel1_fx_Dxx
00326b 1cb8
00326c 1cc0
00326d 1cc3
00326e 1cd0
00326f 1cd1                      	.dw sound_driver_channel1_fx_Exx, sound_driver_channel1_fx_Fxx, sound_driver_channel1_fx_Gxx, sound_driver_channel1_fx_Hxy, sound_driver_channel1_fx_Ixy
003270 1cd2
003271 1cd3
003272 1cd4
003273 1ce8
003274 1d2c                      	.dw sound_driver_channel1_fx_Hxx, sound_driver_channel1_fx_Ixx, sound_driver_channel1_fx_Pxx, sound_driver_channel1_fx_Qxy, sound_driver_channel1_fx_Rxy
003275 1d6f
003276 1d7c
003277 1d90
003278 1d91
003279 1d92                      	.dw sound_driver_channel1_fx_Sxx, sound_driver_channel1_fx_Vxx, sound_driver_channel1_fx_Wxx, sound_driver_channel1_fx_Xxx, sound_driver_channel1_fx_Yxx
00327a 1d93                      	.dw sound_driver_channel1_fx_Zxx
                                 
                                 channel2_fx:
00327b 1f11
00327c 1f16
00327d 1f32
00327e 1f4e
00327f 1f71                      	.dw sound_driver_channel2_fx_0xy, sound_driver_channel2_fx_1xx, sound_driver_channel2_fx_2xx, sound_driver_channel2_fx_3xx, sound_driver_channel2_fx_4xy
003280 1f7c
003281 1f7d
003282 1f7e
003283 1f81
003284 1f84                      	.dw sound_driver_channel2_fx_7xy, sound_driver_channel2_fx_Axy, sound_driver_channel2_fx_Bxx, sound_driver_channel2_fx_Cxx, sound_driver_channel2_fx_Dxx
003285 1f87
003286 1f94
003287 1f97
003288 1fa4
003289 1fa5                      	.dw sound_driver_channel2_fx_Exx, sound_driver_channel2_fx_Fxx, sound_driver_channel2_fx_Gxx, sound_driver_channel2_fx_Hxy, sound_driver_channel2_fx_Ixy
00328a 1fa6
00328b 1fa7
00328c 1fa8
00328d 1fbc
00328e 2000                      	.dw sound_driver_channel2_fx_Hxx, sound_driver_channel2_fx_Ixx, sound_driver_channel2_fx_Pxx, sound_driver_channel2_fx_Qxy, sound_driver_channel2_fx_Rxy
00328f 2043
003290 2050
003291 2051
003292 2052
003293 2053                      	.dw sound_driver_channel2_fx_Sxx, sound_driver_channel2_fx_Vxx, sound_driver_channel2_fx_Wxx, sound_driver_channel2_fx_Xxx, sound_driver_channel2_fx_Yxx
003294 2054                      	.dw sound_driver_channel2_fx_Zxx
                                 
                                 channel3_fx:
003295 21d6
003296 21db
003297 21f7
003298 2213
003299 2236                      	.dw sound_driver_channel3_fx_0xy, sound_driver_channel3_fx_1xx, sound_driver_channel3_fx_2xx, sound_driver_channel3_fx_3xx, sound_driver_channel3_fx_4xy
00329a 2241
00329b 224e
00329c 2251
00329d 2254
00329e 2257                      	.dw sound_driver_channel3_fx_7xy, sound_driver_channel3_fx_Axy, sound_driver_channel3_fx_Bxx, sound_driver_channel3_fx_Cxx, sound_driver_channel3_fx_Dxx
00329f 225a
0032a0 2261
0032a1 2264
0032a2 2271
0032a3 2272                      	.dw sound_driver_channel3_fx_Exx, sound_driver_channel3_fx_Fxx, sound_driver_channel3_fx_Gxx, sound_driver_channel3_fx_Hxy, sound_driver_channel3_fx_Ixy
0032a4 2273
0032a5 2274
0032a6 2275
0032a7 2289
0032a8 22cd                      	.dw sound_driver_channel3_fx_Hxx, sound_driver_channel3_fx_Ixx, sound_driver_channel3_fx_Pxx, sound_driver_channel3_fx_Qxy, sound_driver_channel3_fx_Rxy
0032a9 2310
0032aa 231d
0032ab 2328
0032ac 2329
0032ad 232a                      	.dw sound_driver_channel3_fx_Sxx, sound_driver_channel3_fx_Vxx, sound_driver_channel3_fx_Wxx, sound_driver_channel3_fx_Xxx, sound_driver_channel3_fx_Yxx
0032ae 232b                      	.dw sound_driver_channel3_fx_Zxx
                                 
                                 //famitracker volumes table: http://famitracker.com/wiki/index.php?title=Volume
                                 volumes:
0032af 0000
0032b0 0000
0032b1 0000
0032b2 0000
0032b3 0000
0032b4 0000
0032b5 0000
0032b6 0000                      	.db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
0032b7 0100
0032b8 0101
0032b9 0101
0032ba 0101
0032bb 0101
0032bc 0101
0032bd 0101
0032be 0101                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
0032bf 0100
0032c0 0101
0032c1 0101
0032c2 0101
0032c3 0101
0032c4 0101
0032c5 0101
0032c6 0201                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02
0032c7 0100
0032c8 0101
0032c9 0101
0032ca 0101
0032cb 0101
0032cc 0202
0032cd 0202
0032ce 0302                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03
0032cf 0100
0032d0 0101
0032d1 0101
0032d2 0101
0032d3 0202
0032d4 0202
0032d5 0303
0032d6 0403                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04
0032d7 0100
0032d8 0101
0032d9 0101
0032da 0202
0032db 0302
0032dc 0303
0032dd 0404
0032de 0504                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05
0032df 0100
0032e0 0101
0032e1 0201
0032e2 0202
0032e3 0303
0032e4 0404
0032e5 0504
0032e6 0605                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x06
0032e7 0100
0032e8 0101
0032e9 0201
0032ea 0302
0032eb 0403
0032ec 0504
0032ed 0605
0032ee 0706                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07
0032ef 0100
0032f0 0101
0032f1 0202
0032f2 0303
0032f3 0404
0032f4 0505
0032f5 0606
0032f6 0807                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07, 0x08
0032f7 0100
0032f8 0101
0032f9 0302
0032fa 0403
0032fb 0504
0032fc 0606
0032fd 0707
0032fe 0908                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09
0032ff 0100
003300 0201
003301 0302
003302 0404
003303 0605
003304 0706
003305 0808
003306 0a09                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A
003307 0100
003308 0201
003309 0302
00330a 0504
00330b 0605
00330c 0807
00330d 0908
00330e 0b0a                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B
00330f 0100
003310 0201
003311 0403
003312 0504
003313 0706
003314 0808
003315 0a09
003316 0c0b                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B, 0x0C
003317 0100
003318 0201
003319 0403
00331a 0605
00331b 0706
00331c 0908
00331d 0b0a
00331e 0d0c                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D
00331f 0100
003320 0201
003321 0403
003322 0605
003323 0807
003324 0a09
003325 0c0b
003326 0e0d                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E
003327 0100
003328 0302
003329 0504
00332a 0706
00332b 0908
00332c 0b0a
00332d 0d0c


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega4809" register use summary:
x  :   0 y  :   0 z  : 248 r0 : 192 r1 : 200 r2 : 697 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   6 r11:   4 r12:   9 
r13:   6 r14:   4 r15:   9 r16:   7 r17:   6 r18:   7 r19:   6 r20:   4 
r21:   8 r22: 174 r23: 160 r24:   0 r25:  24 r26: 978 r27:1184 r28: 696 
r29: 373 r30: 375 r31: 337 
Registers used: 25 out of 35 (71.4%)

"ATmega4809" instruction use summary:
.lds  :   0 .sts  :   0 adc   : 148 add   : 194 adiw  : 106 and   :   0 
andi  :  95 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   7 brcs  :  13 break :   0 breq  : 169 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  80 brlt  :   0 brmi  :   0 
brne  : 121 brpl  :   0 brsh  :  31 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :   0 cbr   :   5 
clc   :   0 clh   :   0 cli   :   8 cln   :   0 clr   :   5 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :  16 cp    : 100 cpc   :   9 
cpi   : 168 cpse  :  20 dec   :  35 des   :   0 eor   :   2 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   4 in    :   7 inc   :  48 
jmp   :  10 ld    :   0 ldd   :   0 ldi   : 285 lds   : 724 lpm   : 260 
lsl   :  78 lsr   : 171 mov   : 139 movw  :   0 mul   :  32 muls  :   0 
mulsu :   8 neg   :   0 nop   :   0 or    :  22 ori   :  12 out   :   9 
pop   : 115 push  : 109 rcall :  50 ret   :  32 reti  :   7 rjmp  : 513 
rol   :  53 ror   : 192 sbc   :  48 sbci  :   0 sbi   :   0 sbic  :   0 
sbis  :   0 sbiw  :   0 sbr   :  12 sbrc  :  29 sbrs  :  15 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   :1398 sub   :  66 subi  :  52 swap  :  46 tst   :   0 wdr   :   0 

Instructions used: 52 out of 114 (45.6%)

"ATmega4809" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x00665e  15832  10262  26094   49152  53.1%
[.dseg] 0x002800 0x00295a      0    346    346    6144   5.6%
[.eseg] 0x000000 0x000000      0      0      0     256   0.0%

Assembly complete, 0 errors, 103 warnings
