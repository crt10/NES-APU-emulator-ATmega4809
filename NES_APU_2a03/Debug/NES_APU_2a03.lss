
AVRASM ver. 2.2.8  C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm Wed Jan 20 20:50:15 2021

C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
                                 
                                 
                                 ; NES_APU_2a03.asm
                                 ;
                                 ; Created: 11/29/2020 1:44:10 AM
                                 ; Author : Tennyson Cheng
                                 ;
                                 
                                 .list
                                 
                                 .dseg
002800                           pulse1_param: .byte 1 //$4000 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002801                           pulse1_sweep_param: .byte 1 //$4001 EPPP.NSSS = Enable, Period, Negate, Shift
                                 //NOTE: In order to account for multiplier, we use 16 instead of 11 bits for the timer
002802                           pulse1_timerL: .byte 1 //$4002 LLLL.LLLL = Low 8 bits for timer
002803                           pulse1_timerH: .byte 1 //$4002 HHHH.HHHH = High 8 bits for timer
002804                           pulse1_length: .byte 1 //$4003 000l.llll = Length counter load
002805                           pulse1_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002806                           pulse1_output_volume: .byte 1 //this is the final output volume of pulse 1
002807                           pulse1_note: .byte 1 //the current note index in the note table
                                 
002808                           pulse2_param: .byte 1 //$4004 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002809                           pulse2_sweep_param: .byte 1 //$4005 EPPP.NSSS = Enable, Period, Negate, Shift
00280a                           pulse2_timerL: .byte 1 //$4006 LLLL.LLLL = Low 8 bits for timer
00280b                           pulse2_timerH: .byte 1 //$4006 HHHH.HHHH = High 8 bits for timer
00280c                           pulse2_length: .byte 1 //$4007 000l.llll = Length counter load
00280d                           pulse2_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
00280e                           pulse2_output_volume: .byte 1 //this is the final output volume of pulse 2
00280f                           pulse2_note: .byte 1 //the current note index in the note table
                                 
002810                           triangle_timerL: .byte 1 //$400A LLLL.LLLL = Low 8 bits for timer
002811                           triangle_timerH: .byte 1 //$400A HHHH.HHHH = High 8 bits for time
002812                           triangle_note: .byte 1 //the current note index in the note table
                                 
002813                           song_frames: .byte 2
002815                           song_frame_offset: .byte 2
002817                           song_size: .byte 2
002819                           song_speed: .byte 1
                                 //song_channel_delay_reload: .byte 1 //bit 0-4 represents channels 0-4. a set bit means that there is a delay that needs to be calculated for that channel.
00281a                           song_fx_Bxx: .byte 1
00281b                           song_fx_Cxx: .byte 1
00281c                           song_fx_Dxx: .byte 1
                                 
                                 //PULSE 1
00281d                           pulse1_pattern: .byte 2
00281f                           pulse1_pattern_delay_rows: .byte 1
002820                           pulse1_pattern_delay_frames: .byte 1
002821                           pulse1_pattern_offset: .byte 2
                                 
002823                           pulse1_volume_macro: .byte 2
002825                           pulse1_volume_macro_offset: .byte 1
002826                           pulse1_volume_macro_loop: .byte 1
002827                           pulse1_volume_macro_release: .byte 1
                                 
002828                           pulse1_arpeggio_macro: .byte 2
00282a                           pulse1_arpeggio_macro_offset: .byte 1
00282b                           pulse1_arpeggio_macro_loop: .byte 1
00282c                           pulse1_arpeggio_macro_release: .byte 1
00282d                           pulse1_arpeggio_macro_mode: .byte 1
                                 
00282e                           pulse1_total_pitch_offset: .byte 1 //used to reference the overall change in pitch for the pitch macro
00282f                           pulse1_pitch_macro: .byte 2
002831                           pulse1_pitch_macro_offset: .byte 1
002832                           pulse1_pitch_macro_loop: .byte 1
002833                           pulse1_pitch_macro_release: .byte 1
                                 
002834                           pulse1_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
002835                           pulse1_hi_pitch_macro: .byte 2
002837                           pulse1_hi_pitch_macro_offset: .byte 1
002838                           pulse1_hi_pitch_macro_loop: .byte 1
002839                           pulse1_hi_pitch_macro_release: .byte 1
                                 
00283a                           pulse1_duty_macro: .byte 2
00283c                           pulse1_duty_macro_offset: .byte 1
00283d                           pulse1_duty_macro_loop: .byte 1
00283e                           pulse1_duty_macro_release: .byte 1
                                 
00283f                           pulse1_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002841                           pulse1_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002843                           pulse1_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
002845                           pulse1_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
002847                           pulse1_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
002849                           pulse1_fx_3xx_start: .byte 2 //the starting note period
00284b                           pulse1_fx_3xx_target: .byte 2 //target note period
00284d                           pulse1_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
00284f                           pulse1_fx_3xx_total_offset: .byte 2
002851                           pulse1_fx_4xy_speed: .byte 1
002852                           pulse1_fx_4xy_depth: .byte 1
002853                           pulse1_fx_4xy_phase: .byte 1
002854                           pulse1_fx_7xy_speed: .byte 1
002855                           pulse1_fx_7xy_depth: .byte 1
002856                           pulse1_fx_7xy_phase: .byte 1
002857                           pulse1_fx_7xy_value: .byte 1 //value to offset the volume
002858                           pulse1_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
002859                           pulse1_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
00285a                           pulse1_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
00285b                           pulse1_fx_Pxx: .byte 1 //refers to the fine pitch offset set by the Pxx effect
00285c                           pulse1_fx_Qxy_target: .byte 2 //target note period
00285e                           pulse1_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002860                           pulse1_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002862                           pulse1_fx_Rxy_target: .byte 2 //target note period
002864                           pulse1_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
002866                           pulse1_fx_Rxy_total_offset: .byte 2
002868                           pulse1_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002869                           pulse1_fx_Sxx_post: .byte 1
                                 
                                 //PULSE 2
00286a                           pulse2_pattern: .byte 2
00286c                           pulse2_pattern_delay_rows: .byte 1
00286d                           pulse2_pattern_delay_frames: .byte 1
00286e                           pulse2_pattern_offset: .byte 2
                                 
002870                           pulse2_volume_macro: .byte 2
002872                           pulse2_volume_macro_offset: .byte 1
002873                           pulse2_volume_macro_loop: .byte 1
002874                           pulse2_volume_macro_release: .byte 1
                                 
002875                           pulse2_arpeggio_macro: .byte 2
002877                           pulse2_arpeggio_macro_offset: .byte 1
002878                           pulse2_arpeggio_macro_loop: .byte 1
002879                           pulse2_arpeggio_macro_release: .byte 1
00287a                           pulse2_arpeggio_macro_mode: .byte 1
                                 
00287b                           pulse2_total_pitch_offset: .byte 1 //used to reference the overall change in pitch for the pitch macro
00287c                           pulse2_pitch_macro: .byte 2
00287e                           pulse2_pitch_macro_offset: .byte 1
00287f                           pulse2_pitch_macro_loop: .byte 1
002880                           pulse2_pitch_macro_release: .byte 1
                                 
002881                           pulse2_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
002882                           pulse2_hi_pitch_macro: .byte 2
002884                           pulse2_hi_pitch_macro_offset: .byte 1
002885                           pulse2_hi_pitch_macro_loop: .byte 1
002886                           pulse2_hi_pitch_macro_release: .byte 1
                                 
002887                           pulse2_duty_macro: .byte 2
002889                           pulse2_duty_macro_offset: .byte 1
00288a                           pulse2_duty_macro_loop: .byte 1
00288b                           pulse2_duty_macro_release: .byte 1
                                 
00288c                           pulse2_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
00288e                           pulse2_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002890                           pulse2_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
002892                           pulse2_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
002894                           pulse2_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
002896                           pulse2_fx_3xx_start: .byte 2 //the starting note period
002898                           pulse2_fx_3xx_target: .byte 2 //target note period
00289a                           pulse2_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
00289c                           pulse2_fx_3xx_total_offset: .byte 2
00289e                           pulse2_fx_4xy_speed: .byte 1
00289f                           pulse2_fx_4xy_depth: .byte 1
0028a0                           pulse2_fx_4xy_phase: .byte 1
0028a1                           pulse2_fx_7xy_speed: .byte 1
0028a2                           pulse2_fx_7xy_depth: .byte 1
0028a3                           pulse2_fx_7xy_phase: .byte 1
0028a4                           pulse2_fx_7xy_value: .byte 1 //value to offset the volume
0028a5                           pulse2_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
0028a6                           pulse2_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028a7                           pulse2_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028a8                           pulse2_fx_Pxx: .byte 1 //refers to the fine pitch offset set by the Pxx effect
0028a9                           pulse2_fx_Qxy_target: .byte 2 //target note period
0028ab                           pulse2_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
0028ad                           pulse2_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
0028af                           pulse2_fx_Rxy_target: .byte 2 //target note period
0028b1                           pulse2_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
0028b3                           pulse2_fx_Rxy_total_offset: .byte 2
0028b5                           pulse2_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
0028b6                           pulse2_fx_Sxx_post: .byte 1
                                 
                                 //TRIANGLE
0028b7                           triangle_pattern: .byte 2
0028b9                           triangle_pattern_delay_rows: .byte 1
0028ba                           triangle_pattern_delay_frames: .byte 1
0028bb                           triangle_pattern_offset: .byte 2
                                 
0028bd                           triangle_volume_macro: .byte 2
0028bf                           triangle_volume_macro_offset: .byte 1
0028c0                           triangle_volume_macro_loop: .byte 1
0028c1                           triangle_volume_macro_release: .byte 1
                                 
0028c2                           triangle_arpeggio_macro: .byte 2
0028c4                           triangle_arpeggio_macro_offset: .byte 1
0028c5                           triangle_arpeggio_macro_loop: .byte 1
0028c6                           triangle_arpeggio_macro_release: .byte 1
0028c7                           triangle_arpeggio_macro_mode: .byte 1
                                 
0028c8                           triangle_total_pitch_offset: .byte 1 //used to reference the overall change in pitch for the pitch macro
0028c9                           triangle_pitch_macro: .byte 2
0028cb                           triangle_pitch_macro_offset: .byte 1
0028cc                           triangle_pitch_macro_loop: .byte 1
0028cd                           triangle_pitch_macro_release: .byte 1
                                 
0028ce                           triangle_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
0028cf                           triangle_hi_pitch_macro: .byte 2
0028d1                           triangle_hi_pitch_macro_offset: .byte 1
0028d2                           triangle_hi_pitch_macro_loop: .byte 1
0028d3                           triangle_hi_pitch_macro_release: .byte 1
                                 
0028d4                           triangle_duty_macro: .byte 2
0028d6                           triangle_duty_macro_offset: .byte 1
0028d7                           triangle_duty_macro_loop: .byte 1
0028d8                           triangle_duty_macro_release: .byte 1
                                 
0028d9                           triangle_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
0028db                           triangle_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
0028dd                           triangle_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
0028df                           triangle_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
0028e1                           triangle_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
0028e3                           triangle_fx_3xx_start: .byte 2 //the starting note period
0028e5                           triangle_fx_3xx_target: .byte 2 //target note period
0028e7                           triangle_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028e9                           triangle_fx_3xx_total_offset: .byte 2
0028eb                           triangle_fx_4xy_speed: .byte 1
0028ec                           triangle_fx_4xy_depth: .byte 1
0028ed                           triangle_fx_4xy_phase: .byte 1
0028ee                           triangle_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028ef                           triangle_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028f0                           triangle_fx_Pxx: .byte 1 //refers to the fine pitch offset set by the Pxx effect
0028f1                           triangle_fx_Qxy_target: .byte 2 //target note period
0028f3                           triangle_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
0028f5                           triangle_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
0028f7                           triangle_fx_Rxy_target: .byte 2 //target note period
0028f9                           triangle_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
0028fb                           triangle_fx_Rxy_total_offset: .byte 2
0028fd                           triangle_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
0028fe                           triangle_fx_Sxx_post: .byte 1
                                 
                                 
0028ff                           noise_pattern_delay: .byte 1
002900                           dcpm_pattern_delay: .byte 1
                                 
                                 .cseg
                                 
                                 //NOTE: zero is defined in order to use the cp instruction without the need to load 0x00 into a register beforehand
                                 .def zero = r2
                                 .def pulse_channel_flags = r25 //[pulse1.pulse2] RSlc.RSlc = Reload, Start, Length halt/Loop, Constant volume
                                 .def pulse1_sequence = r10
                                 .def pulse1_length_counter = r11
                                 .def pulse1_sweep = r12 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse1_volume_divider = r16 //0000.PPPP = Period divider
                                 .def pulse1_volume_decay = r17 //0000.dddd = Decay
                                 .def pulse2_sequence = r13
                                 .def pulse2_length_counter = r14
                                 .def pulse2_sweep = r15 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse2_volume_divider = r18 //0000.PPPP = Period divider
                                 .def pulse2_volume_decay = r19 //0000.dddd = Decay
                                 .def triangle_sequence = r20
                                 
                                 reset:
000000 940c 128f                 	jmp init
                                 
                                 .org TCA0_OVF_vect
00000e 940c 1642                 	jmp sound_driver
                                 
                                 .org TCA0_CMP0_vect
000012 940c 156f                 	jmp sequence_0_2
                                 
                                 .org TCA0_CMP1_vect
000014 940c 157a                 	jmp sequence_1_3
                                 
                                 .org TCA0_CMP2_vect
000016 940c 156f                 	jmp sequence_0_2
                                 
                                 .org TCB0_INT_vect
000018 940c 1591                 	jmp pulse1_sequence_routine
                                 
                                 .org TCB1_INT_vect
00001a 940c 15de                 	jmp pulse2_sequence_routine
                                 
                                 .org TCB2_INT_vect
000032 940c 162b                 	jmp triangle_sequence_routine
                                 
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(33): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(61): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(100): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(101): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(102): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(103): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(104): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(105): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(106): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(107): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(108): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(109): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(110): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(111): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(112): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(113): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(114): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(115): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(117): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(118): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(120): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(121): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(122): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(124): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(125): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(126): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(128): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(129): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(130): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(131): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(134): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(135): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(136): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(139): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(141): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(142): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(143): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(150): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(151): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(152): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(157): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(160): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(162): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(163): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(164): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(165): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(166): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(167): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(168): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(169): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(170): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(173): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(174): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(175): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(179): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(180): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(181): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(182): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(184): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(185): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(186): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(187): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(189): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(190): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(191): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(192): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(193): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(194): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(197): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(198): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(199): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(310): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(311): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(312): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(314): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(319): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(320): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(321): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(322): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(323): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(324): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(325): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(326): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(327): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(329): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(333): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(334): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(335): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(336): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(338): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(339): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(341): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(345): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(349): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(350): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(351): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(352): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(354): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(355): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(356): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(359): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(360): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(363): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(364): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(366): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(373): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(374): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
                                 .list
                                 
                                 init:
                                 	//MAIN CLOCK
00128f edc8                      	ldi r28, CPU_CCP_IOREG_gc //protected write
001290 93c0 0034                 	sts CPU_CCP, r28
001292 e0c0                      	ldi r28, 0 << CLKCTRL_PEN_bp //disable prescaler for 20 MHz on main clock
001293 93c0 0061                 	sts CLKCTRL_MCLKCTRLB, r28
                                 
                                 	//ZERO
001295 2422                      	clr zero
                                 
                                 	//MEMORY
001296 e3c0                      	ldi r28, 0b00110000
001297 93c0 2800                 	sts pulse1_param, r28
001299 e8c0                      	ldi r28, 0b10000000
00129a 93c0 2801                 	sts pulse1_sweep_param, r28
00129c efcf                      	ldi r28, 0xFF
00129d 93c0 2802                 	sts pulse1_timerL, r28
00129f 93c0 2803                 	sts pulse1_timerH, r28
0012a1 93c0 2804                 	sts pulse1_length, r28
                                 
0012a3 e3c0                      	ldi r28, 0b00110000
0012a4 93c0 2808                 	sts pulse2_param, r28
0012a6 e8c0                      	ldi r28, 0b10000000
0012a7 93c0 2809                 	sts pulse2_sweep_param, r28
0012a9 efcf                      	ldi r28, 0xFF
0012aa 93c0 280a                 	sts pulse2_timerL, r28
0012ac 93c0 280b                 	sts pulse2_timerH, r28
0012ae 93c0 280c                 	sts pulse2_length, r28
                                 
0012b0 efcf                      	ldi r28, 0xFF
0012b1 93c0 2810                 	sts triangle_timerL, r28
0012b3 93c0 2811                 	sts triangle_timerH, r28
                                 
0012b5 e0c2                      	ldi r28, 0x02
0012b6 93c0 2815                 	sts song_frame_offset, r28
0012b8 9220 2816                 	sts song_frame_offset+1, zero
0012ba efcf                      	ldi r28, 0xFF
0012bb 93c0 281a                 	sts song_fx_Bxx, r28
0012bd 9220 281b                 	sts song_fx_Cxx, zero
0012bf 9220 281c                 	sts song_fx_Dxx, zero
0012c1 e0e2                      	ldi ZL, LOW(song0_frames << 1)
0012c2 e0f3                      	ldi ZH, HIGH(song0_frames << 1)
0012c3 93e0 2813                 	sts song_frames, ZL
0012c5 93f0 2814                 	sts song_frames+1, ZH
0012c7 91c5                      	lpm r28, Z+ //load the song size
0012c8 91d5                      	lpm r29, Z+
0012c9 93c0 2817                 	sts song_size, r28
0012cb 93d0 2818                 	sts song_size+1, r29
0012cd 9220 2819                 	sts song_speed, zero
                                 
                                 	//CHANNEL 0
0012cf 91c5                      	lpm r28, Z+
0012d0 91d5                      	lpm r29, Z+
0012d1 0fcc                      	lsl r28
0012d2 1fdd                      	rol r29
0012d3 93c0 281d                 	sts pulse1_pattern, r28
0012d5 93d0 281e                 	sts pulse1_pattern+1, r29
0012d7 9220 281f                 	sts pulse1_pattern_delay_rows, zero
0012d9 9220 2820                 	sts pulse1_pattern_delay_frames, zero
0012db 9220 2821                 	sts pulse1_pattern_offset, zero
0012dd 9220 2822                 	sts pulse1_pattern_offset+1, zero
                                 
                                 	//CHANNEL 1
0012df 91c5                      	lpm r28, Z+
0012e0 91d5                      	lpm r29, Z+
0012e1 0fcc                      	lsl r28
0012e2 1fdd                      	rol r29
0012e3 93c0 286a                 	sts pulse2_pattern, r28
0012e5 93d0 286b                 	sts pulse2_pattern+1, r29
0012e7 9220 286c                 	sts pulse2_pattern_delay_rows, zero
0012e9 9220 286d                 	sts pulse2_pattern_delay_frames, zero
0012eb 9220 286e                 	sts pulse2_pattern_offset, zero
0012ed 9220 286f                 	sts pulse2_pattern_offset+1, zero
                                 
                                 	//CHANNEL 2
0012ef 91c5                      	lpm r28, Z+
0012f0 91d5                      	lpm r29, Z+
0012f1 0fcc                      	lsl r28
0012f2 1fdd                      	rol r29
0012f3 93c0 28b7                 	sts triangle_pattern, r28
0012f5 93d0 28b8                 	sts triangle_pattern+1, r29
0012f7 9220 28b9                 	sts triangle_pattern_delay_rows, zero
0012f9 9220 28ba                 	sts triangle_pattern_delay_frames, zero
0012fb 9220 28bb                 	sts triangle_pattern_offset, zero
0012fd 9220 28bc                 	sts triangle_pattern_offset+1, zero
                                 
                                 	//CHANNEL 0 instrument macros
0012ff efcf                      	ldi r28, 0xFF
001300 9220 2825                 	sts pulse1_volume_macro_offset, zero
001302 93c0 2826                 	sts pulse1_volume_macro_loop, r28
001304 93c0 2827                 	sts pulse1_volume_macro_release, r28
001306 9220 282a                 	sts pulse1_arpeggio_macro_offset, zero
001308 93c0 282b                 	sts pulse1_arpeggio_macro_loop, r28
00130a 93c0 282c                 	sts pulse1_arpeggio_macro_release, r28
00130c 93c0 282d                 	sts pulse1_arpeggio_macro_mode, r28
00130e 9220 2831                 	sts pulse1_pitch_macro_offset, zero
001310 93c0 2832                 	sts pulse1_pitch_macro_loop, r28
001312 93c0 2833                 	sts pulse1_pitch_macro_release, r28
001314 9220 2837                 	sts pulse1_hi_pitch_macro_offset, zero
001316 93c0 2838                 	sts pulse1_hi_pitch_macro_loop, r28
001318 93c0 2839                 	sts pulse1_hi_pitch_macro_release, r28
00131a 9220 283c                 	sts pulse1_duty_macro_offset, zero
00131c 93c0 283d                 	sts pulse1_duty_macro_loop, r28
00131e 93c0 283e                 	sts pulse1_duty_macro_release, r28
                                 
001320 9220 2823                 	sts pulse1_volume_macro, zero
001322 9220 2824                 	sts pulse1_volume_macro+1, zero
001324 9220 2828                 	sts pulse1_arpeggio_macro, zero
001326 9220 2829                 	sts pulse1_arpeggio_macro+1, zero
001328 9220 282e                 	sts pulse1_total_pitch_offset, zero
00132a 9220 282f                 	sts pulse1_pitch_macro, zero
00132c 9220 2830                 	sts pulse1_pitch_macro+1, zero
00132e 9220 2834                 	sts pulse1_total_hi_pitch_offset, zero
001330 9220 2835                 	sts pulse1_hi_pitch_macro, zero
001332 9220 2836                 	sts pulse1_hi_pitch_macro+1, zero
001334 9220 283a                 	sts pulse1_duty_macro, zero
001336 9220 283b                 	sts pulse1_duty_macro+1, zero
                                 
                                 	//CHANNEL 0 ENVELOPE
001338 e00f                      	ldi pulse1_volume_divider, 0x0F
001339 9110 2800                 	lds pulse1_volume_decay, pulse1_param
00133b 701f                      	andi pulse1_volume_decay, 0x0F //mask for VVVV bits
00133c 9190 2800                 	lds pulse_channel_flags, pulse1_param
00133e 7390                      	andi pulse_channel_flags, 0b00110000
00133f 6490                      	sbr pulse_channel_flags, 0b01000000 //set start flag
001340 9220 2806                 	sts pulse1_output_volume, zero
001342 93c0 2805                 	sts pulse1_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 0 LENGTH
001344 2ebc                      	mov pulse1_length_counter, r28
                                 
                                 	//CHANNEL 0 SEQUENCE
001345 e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
001346 2eac                      	mov pulse1_sequence, r28
                                 
                                 	//CHANNEL 0 SWEEP
001347 90c0 2801                 	lds pulse1_sweep, pulse1_sweep_param
001349 94c2                      	swap pulse1_sweep //swap data from high byte and low byte
00134a 6890                      	sbr pulse_channel_flags, 0b10000000 //set reload flag
                                 
                                 	//CHANNEL 0 FX
00134b efcf                      	ldi r28, 0xFF
00134c 9220 283f                 	sts pulse1_fx_0xy_sequence, zero
00134e 9220 2840                 	sts pulse1_fx_0xy_sequence+1, zero
001350 9220 2841                 	sts pulse1_fx_1xx, zero
001352 9220 2842                 	sts pulse1_fx_1xx+1, zero
001354 9220 2843                 	sts pulse1_fx_1xx_total, zero
001356 9220 2844                 	sts pulse1_fx_1xx_total+1, zero
001358 9220 2845                 	sts pulse1_fx_2xx, zero
00135a 9220 2846                 	sts pulse1_fx_2xx+1, zero
00135c 9220 2847                 	sts pulse1_fx_2xx_total, zero
00135e 9220 2848                 	sts pulse1_fx_2xx_total+1, zero
001360 9220 2849                 	sts pulse1_fx_3xx_start, zero
001362 9220 284a                 	sts pulse1_fx_3xx_start+1, zero
001364 9220 284b                 	sts pulse1_fx_3xx_target, zero
001366 9220 284c                 	sts pulse1_fx_3xx_target+1, zero
001368 9220 284d                 	sts pulse1_fx_3xx_speed, zero
00136a 9220 284e                 	sts pulse1_fx_3xx_speed+1, zero
00136c 9220 284f                 	sts pulse1_fx_3xx_total_offset, zero
00136e 9220 2850                 	sts pulse1_fx_3xx_total_offset+1, zero
001370 9220 2851                 	sts pulse1_fx_4xy_speed, zero
001372 9220 2852                 	sts pulse1_fx_4xy_depth, zero
001374 9220 2853                 	sts pulse1_fx_4xy_phase, zero
001376 9220 2854                 	sts pulse1_fx_7xy_speed, zero
001378 9220 2855                 	sts pulse1_fx_7xy_depth, zero
00137a 9220 2856                 	sts pulse1_fx_7xy_phase, zero
00137c 9220 2857                 	sts pulse1_fx_7xy_value, zero
00137e 9220 2858                 	sts pulse1_fx_Axy, zero
001380 93c0 2859                 	sts pulse1_fx_Gxx_pre, r28
001382 93c0 285a                 	sts pulse1_fx_Gxx_post, r28
001384 9220 285b                 	sts pulse1_fx_Pxx, zero
001386 9220 285c                 	sts pulse1_fx_Qxy_target, zero
001388 9220 285d                 	sts pulse1_fx_Qxy_target+1, zero
00138a 9220 285e                 	sts pulse1_fx_Qxy_speed, zero
00138c 9220 285f                 	sts pulse1_fx_Qxy_speed+1, zero
00138e 9220 2860                 	sts pulse1_fx_Qxy_total_offset, zero
001390 9220 2861                 	sts pulse1_fx_Qxy_total_offset+1, zero
001392 9220 2862                 	sts pulse1_fx_Rxy_target, zero
001394 9220 2863                 	sts pulse1_fx_Rxy_target+1, zero
001396 9220 2864                 	sts pulse1_fx_Rxy_speed, zero
001398 9220 2865                 	sts pulse1_fx_Rxy_speed+1, zero
00139a 9220 2866                 	sts pulse1_fx_Rxy_total_offset, zero
00139c 9220 2867                 	sts pulse1_fx_Rxy_total_offset+1, zero
00139e 93c0 2868                 	sts pulse1_fx_Sxx_pre, r28
0013a0 93c0 2869                 	sts pulse1_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 1 instrument macros
0013a2 efcf                      	ldi r28, 0xFF
0013a3 9220 2872                 	sts pulse2_volume_macro_offset, zero
0013a5 93c0 2873                 	sts pulse2_volume_macro_loop, r28
0013a7 93c0 2874                 	sts pulse2_volume_macro_release, r28
0013a9 9220 2877                 	sts pulse2_arpeggio_macro_offset, zero
0013ab 93c0 2878                 	sts pulse2_arpeggio_macro_loop, r28
0013ad 93c0 2879                 	sts pulse2_arpeggio_macro_release, r28
0013af 93c0 287a                 	sts pulse2_arpeggio_macro_mode, r28
0013b1 9220 287e                 	sts pulse2_pitch_macro_offset, zero
0013b3 93c0 287f                 	sts pulse2_pitch_macro_loop, r28
0013b5 93c0 2880                 	sts pulse2_pitch_macro_release, r28
0013b7 9220 2884                 	sts pulse2_hi_pitch_macro_offset, zero
0013b9 93c0 2885                 	sts pulse2_hi_pitch_macro_loop, r28
0013bb 93c0 2886                 	sts pulse2_hi_pitch_macro_release, r28
0013bd 9220 2889                 	sts pulse2_duty_macro_offset, zero
0013bf 93c0 288a                 	sts pulse2_duty_macro_loop, r28
0013c1 93c0 288b                 	sts pulse2_duty_macro_release, r28
                                 
0013c3 9220 2870                 	sts pulse2_volume_macro, zero
0013c5 9220 2871                 	sts pulse2_volume_macro+1, zero
0013c7 9220 2875                 	sts pulse2_arpeggio_macro, zero
0013c9 9220 2876                 	sts pulse2_arpeggio_macro+1, zero
0013cb 9220 287b                 	sts pulse2_total_pitch_offset, zero
0013cd 9220 287c                 	sts pulse2_pitch_macro, zero
0013cf 9220 287d                 	sts pulse2_pitch_macro+1, zero
0013d1 9220 2881                 	sts pulse2_total_hi_pitch_offset, zero
0013d3 9220 2882                 	sts pulse2_hi_pitch_macro, zero
0013d5 9220 2883                 	sts pulse2_hi_pitch_macro+1, zero
0013d7 9220 2887                 	sts pulse2_duty_macro, zero
0013d9 9220 2888                 	sts pulse2_duty_macro+1, zero
                                 
                                 	//CHANNEL 1 ENVELOPE
0013db e02f                      	ldi pulse2_volume_divider, 0x0F
0013dc 9130 2808                 	lds pulse2_volume_decay, pulse2_param
0013de 703f                      	andi pulse2_volume_decay, 0x0F //mask for VVVV bits
0013df 91d0 2808                 	lds r29, pulse2_param
0013e1 73d0                      	andi r29, 0b00110000
0013e2 62d0                      	sbr r29, 0b0100000 //set start flag
0013e3 95d2                      	swap r29
0013e4 2b9d                      	or pulse_channel_flags, r29
0013e5 9220 280e                 	sts pulse2_output_volume, zero
0013e7 93c0 280d                 	sts pulse2_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 1 LENGTH
0013e9 2eec                      	mov pulse2_length_counter, r28
                                 
                                 	//CHANNEL 1 SEQUENCE
0013ea e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
0013eb 2edc                      	mov pulse2_sequence, r28
                                 
                                 	//CHANNEL 1 SWEEP
0013ec 90f0 2809                 	lds pulse2_sweep, pulse2_sweep_param
0013ee 94f2                      	swap pulse2_sweep //swap data from high byte and low byte
0013ef 6098                      	sbr pulse_channel_flags, 0b00001000 //set reload flag
                                 
                                 	//CHANNEL 1 FX
0013f0 efcf                      	ldi r28, 0xFF
0013f1 9220 288c                 	sts pulse2_fx_0xy_sequence, zero
0013f3 9220 288d                 	sts pulse2_fx_0xy_sequence+1, zero
0013f5 9220 288e                 	sts pulse2_fx_1xx, zero
0013f7 9220 288f                 	sts pulse2_fx_1xx+1, zero
0013f9 9220 2890                 	sts pulse2_fx_1xx_total, zero
0013fb 9220 2891                 	sts pulse2_fx_1xx_total+1, zero
0013fd 9220 2892                 	sts pulse2_fx_2xx, zero
0013ff 9220 2893                 	sts pulse2_fx_2xx+1, zero
001401 9220 2894                 	sts pulse2_fx_2xx_total, zero
001403 9220 2895                 	sts pulse2_fx_2xx_total+1, zero
001405 9220 2896                 	sts pulse2_fx_3xx_start, zero
001407 9220 2897                 	sts pulse2_fx_3xx_start+1, zero
001409 9220 2898                 	sts pulse2_fx_3xx_target, zero
00140b 9220 2899                 	sts pulse2_fx_3xx_target+1, zero
00140d 9220 289a                 	sts pulse2_fx_3xx_speed, zero
00140f 9220 289b                 	sts pulse2_fx_3xx_speed+1, zero
001411 9220 289c                 	sts pulse2_fx_3xx_total_offset, zero
001413 9220 289d                 	sts pulse2_fx_3xx_total_offset+1, zero
001415 9220 289e                 	sts pulse2_fx_4xy_speed, zero
001417 9220 289f                 	sts pulse2_fx_4xy_depth, zero
001419 9220 28a0                 	sts pulse2_fx_4xy_phase, zero
00141b 9220 28a1                 	sts pulse2_fx_7xy_speed, zero
00141d 9220 28a2                 	sts pulse2_fx_7xy_depth, zero
00141f 9220 28a3                 	sts pulse2_fx_7xy_phase, zero
001421 9220 28a4                 	sts pulse2_fx_7xy_value, zero
001423 9220 28a5                 	sts pulse2_fx_Axy, zero
001425 93c0 28a6                 	sts pulse2_fx_Gxx_pre, r28
001427 93c0 28a7                 	sts pulse2_fx_Gxx_post, r28
001429 9220 28a8                 	sts pulse2_fx_Pxx, zero
00142b 9220 28a9                 	sts pulse2_fx_Qxy_target, zero
00142d 9220 28aa                 	sts pulse2_fx_Qxy_target+1, zero
00142f 9220 28ab                 	sts pulse2_fx_Qxy_speed, zero
001431 9220 28ac                 	sts pulse2_fx_Qxy_speed+1, zero
001433 9220 28ad                 	sts pulse2_fx_Qxy_total_offset, zero
001435 9220 28ae                 	sts pulse2_fx_Qxy_total_offset+1, zero
001437 9220 28af                 	sts pulse2_fx_Rxy_target, zero
001439 9220 28b0                 	sts pulse2_fx_Rxy_target+1, zero
00143b 9220 28b1                 	sts pulse2_fx_Rxy_speed, zero
00143d 9220 28b2                 	sts pulse2_fx_Rxy_speed+1, zero
00143f 9220 28b3                 	sts pulse2_fx_Rxy_total_offset, zero
001441 9220 28b4                 	sts pulse2_fx_Rxy_total_offset+1, zero
001443 93c0 28b5                 	sts pulse2_fx_Sxx_pre, r28
001445 93c0 28b6                 	sts pulse2_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 3 instrument macros
001447 efcf                      	ldi r28, 0xFF
001448 9220 28bf                 	sts triangle_volume_macro_offset, zero
00144a 93c0 28c0                 	sts triangle_volume_macro_loop, r28
00144c 93c0 28c1                 	sts triangle_volume_macro_release, r28
00144e 9220 28c4                 	sts triangle_arpeggio_macro_offset, zero
001450 93c0 28c5                 	sts triangle_arpeggio_macro_loop, r28
001452 93c0 28c6                 	sts triangle_arpeggio_macro_release, r28
001454 93c0 28c7                 	sts triangle_arpeggio_macro_mode, r28
001456 9220 28cb                 	sts triangle_pitch_macro_offset, zero
001458 93c0 28cc                 	sts triangle_pitch_macro_loop, r28
00145a 93c0 28cd                 	sts triangle_pitch_macro_release, r28
00145c 9220 28d1                 	sts triangle_hi_pitch_macro_offset, zero
00145e 93c0 28d2                 	sts triangle_hi_pitch_macro_loop, r28
001460 93c0 28d3                 	sts triangle_hi_pitch_macro_release, r28
001462 9220 28d6                 	sts triangle_duty_macro_offset, zero
001464 93c0 28d7                 	sts triangle_duty_macro_loop, r28
001466 93c0 28d8                 	sts triangle_duty_macro_release, r28
                                 
001468 9220 28bd                 	sts triangle_volume_macro, zero
00146a 9220 28be                 	sts triangle_volume_macro+1, zero
00146c 9220 28c2                 	sts triangle_arpeggio_macro, zero
00146e 9220 28c3                 	sts triangle_arpeggio_macro+1, zero
001470 9220 28c8                 	sts triangle_total_pitch_offset, zero
001472 9220 28c9                 	sts triangle_pitch_macro, zero
001474 9220 28ca                 	sts triangle_pitch_macro+1, zero
001476 9220 28ce                 	sts triangle_total_hi_pitch_offset, zero
001478 9220 28cf                 	sts triangle_hi_pitch_macro, zero
00147a 9220 28d0                 	sts triangle_hi_pitch_macro+1, zero
00147c 9220 28d4                 	sts triangle_duty_macro, zero
00147e 9220 28d5                 	sts triangle_duty_macro+1, zero
                                 
                                 	//CHANNEL 3 SEQUENCE
001480 e0c0                      	ldi r28, 0b00000000 //reset sequence to 0
001481 2f4c                      	mov triangle_sequence, r28
                                 
                                 	//CHANNEL 3 FX
001482 efcf                      	ldi r28, 0xFF
001483 9220 28d9                 	sts triangle_fx_0xy_sequence, zero
001485 9220 28da                 	sts triangle_fx_0xy_sequence+1, zero
001487 9220 28db                 	sts triangle_fx_1xx, zero
001489 9220 28dc                 	sts triangle_fx_1xx+1, zero
00148b 9220 28dd                 	sts triangle_fx_1xx_total, zero
00148d 9220 28de                 	sts triangle_fx_1xx_total+1, zero
00148f 9220 28df                 	sts triangle_fx_2xx, zero
001491 9220 28e0                 	sts triangle_fx_2xx+1, zero
001493 9220 28e1                 	sts triangle_fx_2xx_total, zero
001495 9220 28e2                 	sts triangle_fx_2xx_total+1, zero
001497 9220 28e3                 	sts triangle_fx_3xx_start, zero
001499 9220 28e4                 	sts triangle_fx_3xx_start+1, zero
00149b 9220 28e5                 	sts triangle_fx_3xx_target, zero
00149d 9220 28e6                 	sts triangle_fx_3xx_target+1, zero
00149f 9220 28e7                 	sts triangle_fx_3xx_speed, zero
0014a1 9220 28e8                 	sts triangle_fx_3xx_speed+1, zero
0014a3 9220 28e9                 	sts triangle_fx_3xx_total_offset, zero
0014a5 9220 28ea                 	sts triangle_fx_3xx_total_offset+1, zero
0014a7 9220 28eb                 	sts triangle_fx_4xy_speed, zero
0014a9 9220 28ec                 	sts triangle_fx_4xy_depth, zero
0014ab 9220 28ed                 	sts triangle_fx_4xy_phase, zero
0014ad 93c0 28ee                 	sts triangle_fx_Gxx_pre, r28
0014af 93c0 28ef                 	sts triangle_fx_Gxx_post, r28
0014b1 9220 28f0                 	sts triangle_fx_Pxx, zero
0014b3 9220 28f1                 	sts triangle_fx_Qxy_target, zero
0014b5 9220 28f2                 	sts triangle_fx_Qxy_target+1, zero
0014b7 9220 28f3                 	sts triangle_fx_Qxy_speed, zero
0014b9 9220 28f4                 	sts triangle_fx_Qxy_speed+1, zero
0014bb 9220 28f5                 	sts triangle_fx_Qxy_total_offset, zero
0014bd 9220 28f6                 	sts triangle_fx_Qxy_total_offset+1, zero
0014bf 9220 28f7                 	sts triangle_fx_Rxy_target, zero
0014c1 9220 28f8                 	sts triangle_fx_Rxy_target+1, zero
0014c3 9220 28f9                 	sts triangle_fx_Rxy_speed, zero
0014c5 9220 28fa                 	sts triangle_fx_Rxy_speed+1, zero
0014c7 9220 28fb                 	sts triangle_fx_Rxy_total_offset, zero
0014c9 9220 28fc                 	sts triangle_fx_Rxy_total_offset+1, zero
0014cb 93c0 28fd                 	sts triangle_fx_Sxx_pre, r28
0014cd 93c0 28fe                 	sts triangle_fx_Sxx_post, r28
                                 
                                 	//PINS
0014cf efcf                      	ldi r28, 0xFF
0014d0 b9c0                      	out VPORTA_DIR, r28 //set all pins in VPORTA to output
                                 
                                 	//TIMERS
                                 	//Frame Counter
                                 	//NOTE:The frame counter will be defaulted to NTSC mode (60 Hz, 120 Hz, 240 Hz)
                                 	//Each interrupt will be setup to interrupt every 240 Hz clock
                                 	//CMP0 = sequence 0, CMP1 = sequence 1, CMP2 = sequence 2, OVF = sequence 3/sound driver
                                 	//Sequence 3 will clock the sound driver every 60Hz, in which new audio data is read and written to the registers
                                 	//Timer period Calculation: (0.00416666666 * 20000000/64)-1 = 1301.08333125 = 0x0515
                                 	//The ATmega4809 is cofigured to run at 20000000 Hz
                                 	//0.00416666666 seconds is the period for 240 Hz
                                 	//The /64 comes from the prescaler divider used
0014d1 e7c0                      	ldi r28, TCA_SINGLE_CMP0EN_bm | TCA_SINGLE_CMP1EN_bm | TCA_SINGLE_CMP2EN_bm | TCA_SINGLE_WGMODE_NORMAL_gc //interrupt mode
0014d2 93c0 0a01                 	sts TCA0_SINGLE_CTRLB, r28
0014d4 e7c1                      	ldi r28, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP1_bm | TCA_SINGLE_CMP2_bm | TCA_SINGLE_OVF_bm //enable overflow and compare interrupts
0014d5 93c0 0a0a                 	sts TCA0_SINGLE_INTCTRL, r28
0014d7 e1c5                      	ldi r28, 0x15 //set the period for CMP0
0014d8 93c0 0a28                 	sts TCA0_SINGLE_CMP0, r28
0014da e0c5                      	ldi r28, 0x05
0014db 93c0 0a29                 	sts TCA0_SINGLE_CMP0 + 1, r28
0014dd e2cb                      	ldi r28, 0x2B //set the period for CMP1
0014de 93c0 0a2a                 	sts TCA0_SINGLE_CMP1, r28
0014e0 e0ca                      	ldi r28, 0x0A
0014e1 93c0 0a2b                 	sts TCA0_SINGLE_CMP1 + 1, r28
0014e3 e4c1                      	ldi r28, 0x41 //set the period for CMP2
0014e4 93c0 0a2c                 	sts TCA0_SINGLE_CMP2, r28
0014e6 e0cf                      	ldi r28, 0x0F
0014e7 93c0 0a2d                 	sts TCA0_SINGLE_CMP2 + 1, r28
0014e9 e5c7                      	ldi r28, 0x57 //set the period for OVF
0014ea 93c0 0a26                 	sts TCA0_SINGLE_PER, r28
0014ec e1c4                      	ldi r28, 0x14
0014ed 93c0 0a27                 	sts TCA0_SINGLE_PER + 1, r28
0014ef e0cb                      	ldi r28, TCA_SINGLE_CLKSEL_DIV64_gc | TCA_SINGLE_ENABLE_bm //use prescale divider of 64 and enable timer
0014f0 93c0 0a00                 	sts TCA0_SINGLE_CTRLA, r28
                                 
                                 	//NOTE: Channel Timers are clocked (20/2)/(0.8948865) = 11.1746014718 times faster than the NES APU
                                 	//Because of this, we multiply all the NES timer values by 11.1746014718 beforehand
                                 	//Since we rotate the sequence when the timer goes from t-(t-1) to 0, instead of 0 to t like the NES, we add 1 to the NES timers before multiplying
                                 	//The ATmega4809 is configured to run at 20 MHz
                                 	//The /2 comes from the prescaler divider used
                                 	//0.8948865 MHz is the speed of the NTSC NES APU
                                 	//NOTE: This means that any offset to the pitch for the NES timers would be multiplied by 11.1746014718 aswell.
                                 	//Pulse 1
0014f2 e0c0                      	ldi r28, TCB_CNTMODE_INT_gc //interrupt mode
0014f3 93c0 0a81                 	sts TCB0_CTRLB, r28
0014f5 e0c1                      	ldi r28, TCB_CAPT_bm //enable interrupts
0014f6 93c0 0a85                 	sts TCB0_INTCTRL, r28
0014f8 91c0 2802                 	lds r28, pulse1_timerL //load the LOW bits for timer
0014fa 93c0 0a8c                 	sts TCB0_CCMPL, r28
0014fc 91c0 2803                 	lds r28, pulse1_timerH //load the HIGH bits for timer
0014fe 93c0 0a8d                 	sts TCB0_CCMPH, r28
001500 e0c3                      	ldi r28, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
001501 93c0 0a80                 	sts TCB0_CTRLA, r28
                                 
                                 	//PULSE 2
001503 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
001504 93b0 0a91                 	sts TCB1_CTRLB, r27
001506 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001507 93b0 0a95                 	sts TCB1_INTCTRL, r27
001509 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
00150b 93b0 0a9c                 	sts TCB1_CCMPL, r27
00150d 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
00150f 93b0 0a9d                 	sts TCB1_CCMPH, r27
001511 e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
001512 93b0 0a90                 	sts TCB1_CTRLA, r27
                                 
                                 	//NOTE: The triangle timer is clocked at the same speed as the NES CPU, aka twice the NES APU.
                                 	//Therefore, we won't be using a /2 clock divider like we did with the pulse timers.
                                 	//TRIANGLE
001514 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
001515 93b0 0aa1                 	sts TCB2_CTRLB, r27
001517 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001518 93b0 0aa5                 	sts TCB2_INTCTRL, r27
00151a 91b0 2810                 	lds r27, triangle_timerL //load the LOW bits for timer
00151c 93b0 0aac                 	sts TCB2_CCMPL, r27
00151e 91b0 2811                 	lds r27, triangle_timerH //load the HIGH bits for timer
001520 93b0 0aad                 	sts TCB2_CCMPH, r27
001522 e0b1                      	ldi r27, TCB_CLKSEL_CLKDIV1_gc | TCB_ENABLE_bm //use prescaler divider of 1 and enable timer
001523 93b0 0aa0                 	sts TCB2_CTRLA, r27
001525 9478                      	sei //global interrupt enable
                                 
                                 
                                 
                                 //https://wiki.nesdev.com/w/index.php/APU_Mixer
                                 volume_mixer:
001526 91c0 2806                 	lds r28, pulse1_output_volume
001528 91d0 280e                 	lds r29, pulse2_output_volume
                                 
                                 volume_mixer_pulse1:
00152a fea0                      	sbrs pulse1_sequence, 0 //if the sequence output is zero, return
00152b c015                      	rjmp volume_mixer_pulse1_off
                                 
00152c 14b2                      	cp pulse1_length_counter, zero //if length is zero, return
00152d f099                      	breq volume_mixer_pulse1_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
00152e 91e0 0a8c                 	lds r30, TCB0_CCMPL
001530 e5f9                      	ldi r31, 0x059
001531 17ef                      	cp r30, r31
001532 91e0 0a8d                 	lds r30, TCB0_CCMPH
001534 e0f0                      	ldi r31, 0x00
001535 07ef                      	cpc r30, r31
001536 f050                      	brlo volume_mixer_pulse1_off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $5965
001537 91e0 0a8c                 	lds r30, TCB0_CCMPL
001539 e6f6                      	ldi r31, 0x66
00153a 17ef                      	cp r30, r31
00153b 91e0 0a8d                 	lds r30, TCB0_CCMPH
00153d e5f9                      	ldi r31, 0x59
00153e 07ef                      	cpc r30, r31
00153f f408                      	brsh volume_mixer_pulse1_off
001540 c001                      	rjmp volume_mixer_pulse2 //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse1_off:
001541 27cc                      	clr r28
                                 
                                 volume_mixer_pulse2:
001542 fed0                      	sbrs pulse2_sequence, 0 //if the sequence output is zero, return
001543 c015                      	rjmp volume_mixer_pulse2_off
                                 
001544 14e2                      	cp pulse2_length_counter, zero //if length is zero, return
001545 f099                      	breq volume_mixer_pulse2_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
001546 91e0 0a9c                 	lds r30, TCB1_CCMPL
001548 e5f9                      	ldi r31, 0x059
001549 17ef                      	cp r30, r31
00154a 91e0 0a9d                 	lds r30, TCB1_CCMPH
00154c e0f0                      	ldi r31, 0x00
00154d 07ef                      	cpc r30, r31
00154e f050                      	brlo volume_mixer_pulse2_off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $5965
00154f 91e0 0a9c                 	lds r30, TCB1_CCMPL
001551 e6f6                      	ldi r31, 0x66
001552 17ef                      	cp r30, r31
001553 91e0 0a9d                 	lds r30, TCB1_CCMPH
001555 e5f9                      	ldi r31, 0x59
001556 07ef                      	cpc r30, r31
001557 f408                      	brsh volume_mixer_pulse2_off
001558 c001                      	rjmp volume_mixer_pulse_out //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse2_off:
001559 27dd                      	clr r29
                                 
                                 volume_mixer_pulse_out:
00155a 0fcd                      	add r28, r29
00155b e1e6                      	ldi ZL, LOW(pulse_volume_table << 1)
00155c e0f2                      	ldi ZH, HIGH(pulse_volume_table << 1)
00155d 0fec                      	add ZL, r28
00155e 1df2                      	adc ZH, zero
00155f 91c4                      	lpm r28, Z
                                 
                                 volume_mixer_tnd_triangle:
001560 2fd4                      	mov r29, triangle_sequence
001561 fdd4                      	sbrc r29, 4 //check 5th bit
001562 95d0                      	com r29
001563 70df                      	andi r29, 0x0F
001564 2fed                      	mov r30, r29
001565 0fde                      	add r29, r30 //multiply the triangle volume by 3
001566 0fde                      	add r29, r30
                                 
                                 volume_mixer_tnd_out:
001567 e3e6                      	ldi ZL, LOW(tnd_volume_table << 1)
001568 e0f2                      	ldi ZH, HIGH(tnd_volume_table << 1)
001569 0fed                      	add ZL, r29
00156a 1df2                      	adc ZH, zero
00156b 91d4                      	lpm r29, Z
                                 
                                 volume_mixer_output:
00156c 0fcd                      	add r28, r29
00156d b9c1                      	out VPORTA_OUT, r28
00156e cfb7                      	rjmp volume_mixer
                                 
                                 
                                 
                                 //FRAME COUNTER/AUDIO SAMPLE ISR
                                 sequence_0_2:
00156f b7bf                      	in r27, CPU_SREG
001570 93bf                      	push r27
001571 94f8                      	cli
                                 
                                 	//ENVELOPE
001572 d053                      	rcall pulse1_envelope_routine
001573 d09f                      	rcall pulse2_envelope_routine
                                 
001574 e5b0                      	ldi r27, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP2_bm //clear OVF flag
001575 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
001577 91bf                      	pop r27
001578 bfbf                      	out CPU_SREG, r27
001579 9518                      	reti
                                 
                                 sequence_1_3:
00157a b7bf                      	in r27, CPU_SREG
00157b 93bf                      	push r27
00157c 94f8                      	cli
                                 
                                 	//ENVELOPE
00157d d048                      	rcall pulse1_envelope_routine
00157e d094                      	rcall pulse2_envelope_routine
                                 
                                 	//SWEEP
00157f fcc3                      	sbrc pulse1_sweep, 3 //check if the sweep enable bit is cleared
001580 d01b                      	rcall pulse1_sweep_routine
001581 fcf3                      	sbrc pulse2_sweep, 3
001582 d066                      	rcall pulse2_sweep_routine
                                 
                                 	//LENGTH
                                 	//NOTE: The length routine is relatively simple, so we will not be using clocks to rjmp and ret to a seperate lable
                                 sequence_1_3_pulse1_length:
001583 fd95                      	sbrc pulse_channel_flags, 5 //check if the length counter halt bit is cleared
001584 c002                      	rjmp sequence_1_3_pulse2_length
001585 10b2                      	cpse pulse1_length_counter, zero //if length counter is already 0, don't decrement
001586 94ba                      	dec pulse1_length_counter
                                 sequence_1_3_pulse2_length:
001587 fd91                      	sbrc pulse_channel_flags, 1 //check if the length counter halt bit is cleared
001588 c002                      	rjmp sequence_1_3_exit
001589 10e2                      	cpse pulse2_length_counter, zero //if length counter is already 0, don't decrement
00158a 94ea                      	dec pulse2_length_counter
                                 
                                 sequence_1_3_exit:
00158b e2b1                      	ldi r27, TCA_SINGLE_CMP1_bm | TCA_SINGLE_OVF_bm //clear OVF flag
00158c 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
00158e 91bf                      	pop r27
00158f bfbf                      	out CPU_SREG, r27
001590 9518                      	reti
                                 
                                 //PULSE 1 ROUTINES
                                 pulse1_sequence_routine:
001591 b7bf                      	in r27, CPU_SREG
001592 93bf                      	push r27
001593 94f8                      	cli
                                 
001594 0caa                      	lsl pulse1_sequence //shifts sequence to the left
001595 1ca2                      	adc pulse1_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
001596 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
001597 93b0 0a86                 	sts TCB0_INTFLAGS, r27
001599 91bf                      	pop r27
00159a bfbf                      	out CPU_SREG, r27
00159b 9518                      	reti
                                 
                                 pulse1_sweep_routine:
00159c 2dbc                      	mov r27, pulse1_sweep
00159d 70b7                      	andi r27, 0x07 //mask for period divider bits
00159e f4f9                      	brne pulse1_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse1_sweep_routine_action: //if the divider is == 0, update the pulse timer period
00159f 93df                      	push r29
0015a0 2ddc                      	mov r29, pulse1_sweep
0015a1 95d2                      	swap r29
0015a2 70d7                      	andi r29, 0x07 //mask for shift bits
0015a3 f411                      	brne pulse1_sweep_routine_action_main //shift != 0
0015a4 91df                      	pop r29
0015a5 c019                      	rjmp pulse1_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse1_sweep_routine_action_main:
0015a6 91a0 0a8c                 	lds r26, TCB0_CCMPL
0015a8 91b0 0a8d                 	lds r27, TCB0_CCMPH
                                 pulse1_sweep_routine_action_main_loop:
0015aa 95b6                      	lsr r27
0015ab 95a7                      	ror r26
0015ac 95da                      	dec r29
0015ad f7e1                      	brne pulse1_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
0015ae fec7                      	sbrs pulse1_sweep, 7 //check the negate flag
0015af c002                      	rjmp pulse1_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
0015b0 95a0                      	com r26 //pulse1 uses one's complement if the negate flag is set
0015b1 95b0                      	com r27
                                 
                                 pulse1_sweep_routine_action_main_add:
0015b2 91d0 0a8c                 	lds r29, TCB0_CCMPL //perform addition to get new timer period
0015b4 0fad                      	add r26, r29
0015b5 91d0 0a8d                 	lds r29, TCB0_CCMPH
0015b7 1fbd                      	adc r27, r29
                                 
0015b8 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new LOW bits for timer
0015ba 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new HIGH bits for timer
                                 	
0015bc 91df                      	pop r29
0015bd c001                      	rjmp pulse1_sweep_routine_check_reload
                                 
                                 pulse1_sweep_routine_decrement_divider:
0015be 94ca                      	dec pulse1_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse1_sweep_routine_check_reload:
0015bf ff97                      	sbrs pulse_channel_flags, 7 //if the reload flag is set, reload the sweep divider
0015c0 9508                      	ret
                                 
                                 pulse1_sweep_reload:
0015c1 90c0 2801                 	lds pulse1_sweep, pulse1_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
0015c3 94c2                      	swap pulse1_sweep //bring data from high byte to low byte
0015c4 779f                      	cbr pulse_channel_flags, 0b10000000 //clear reload flag
0015c5 9508                      	ret
                                 
                                 
                                 
                                 pulse1_envelope_routine:
0015c6 fd96                      	sbrc pulse_channel_flags, 6 //check if start flag is cleared
0015c7 c010                      	rjmp pulse1_envelope_routine_clear_start
                                 
0015c8 3000                      	cpi pulse1_volume_divider, 0x00 //check if the divider is 0
0015c9 f011                      	breq PC+3 //if the divider == 0, check loop flag
0015ca 950a                      	dec pulse1_volume_divider //if the divider != 0, decrement and return
0015cb 9508                      	ret
                                 
0015cc 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the divider == 0, reset the divider period
0015ce 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
0015cf ff95                      	sbrs pulse_channel_flags, 5 //check if the loop flag is set
0015d0 c002                      	rjmp pulse1_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
0015d1 e01f                      	ldi pulse1_volume_decay, 0x0F //if the loop flag is set, reset decay and return
0015d2 9508                      	ret
                                 
                                 pulse1_envelope_routine_decrement_decay:
0015d3 3010                      	cpi pulse1_volume_decay, 0x00 //check if the decay is 0
0015d4 f409                      	brne PC+2 //if decay != 0, go decrement
0015d5 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
0015d6 951a                      	dec pulse1_volume_decay
0015d7 9508                      	ret
                                 
                                 pulse1_envelope_routine_clear_start:
0015d8 7b9f                      	cbr pulse_channel_flags, 0b01000000 //if the start flag is set, clear it
0015d9 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the start flag is set, reset the divider period
0015db 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
0015dc e01f                      	ldi pulse1_volume_decay, 0x0F //if the start flag is set, reset decay
0015dd 9508                      	ret
                                 
                                 //PULSE 2 ROUTINES
                                 pulse2_sequence_routine:
0015de b7bf                      	in r27, CPU_SREG
0015df 93bf                      	push r27
0015e0 94f8                      	cli
                                 
0015e1 0cdd                      	lsl pulse2_sequence //shifts sequence to the left
0015e2 1cd2                      	adc pulse2_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
0015e3 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
0015e4 93b0 0a96                 	sts TCB1_INTFLAGS, r27
0015e6 91bf                      	pop r27
0015e7 bfbf                      	out CPU_SREG, r27
0015e8 9518                      	reti
                                 
                                 pulse2_sweep_routine:
0015e9 2dbf                      	mov r27, pulse2_sweep
0015ea 70b7                      	andi r27, 0x07 //mask for period divider bits
0015eb f4f9                      	brne pulse2_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse2_sweep_routine_action: //if the divider is == 0, update the pulse timer period
0015ec 93df                      	push r29
0015ed 2ddf                      	mov r29, pulse2_sweep
0015ee 95d2                      	swap r29
0015ef 70d7                      	andi r29, 0x07 //mask for shift bits
0015f0 f411                      	brne pulse2_sweep_routine_action_main //shift != 0
0015f1 91df                      	pop r29
0015f2 c019                      	rjmp pulse2_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse2_sweep_routine_action_main:
0015f3 91a0 0a9c                 	lds r26, TCB1_CCMPL
0015f5 91b0 0a9d                 	lds r27, TCB1_CCMPH
                                 pulse2_sweep_routine_action_main_loop:
0015f7 95b6                      	lsr r27
0015f8 95a7                      	ror r26
0015f9 95da                      	dec r29
0015fa f7e1                      	brne pulse2_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
0015fb fef7                      	sbrs pulse2_sweep, 7 //check the negate flag
0015fc c002                      	rjmp pulse2_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
0015fd 95a0                      	com r26 //pulse2 uses one's complement if the negate flag is set
0015fe 95b0                      	com r27
                                 
                                 pulse2_sweep_routine_action_main_add:
0015ff 91d0 0a9c                 	lds r29, TCB1_CCMPL //perform addition to get new timer period
001601 0fad                      	add r26, r29
001602 91d0 0a9d                 	lds r29, TCB1_CCMPH
001604 1fbd                      	adc r27, r29
                                 
001605 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new LOW bits for timer
001607 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new HIGH bits for timer
                                 	
001609 91df                      	pop r29
00160a c001                      	rjmp pulse2_sweep_routine_check_reload
                                 
                                 pulse2_sweep_routine_decrement_divider:
00160b 94fa                      	dec pulse2_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse2_sweep_routine_check_reload:
00160c ff93                      	sbrs pulse_channel_flags, 3 //if the reload flag is set, reload the sweep divider
00160d 9508                      	ret
                                 
                                 pulse2_sweep_reload:
00160e 90f0 2809                 	lds pulse2_sweep, pulse2_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
001610 94f2                      	swap pulse2_sweep //bring data from high byte to low byte
001611 7f97                      	cbr pulse_channel_flags, 0b00001000 //clear reload flag
001612 9508                      	ret
                                 
                                 
                                 
                                 pulse2_envelope_routine:
001613 fd92                      	sbrc pulse_channel_flags, 2 //check if start flag is cleared
001614 c010                      	rjmp pulse2_envelope_routine_clear_start
                                 
001615 3020                      	cpi pulse2_volume_divider, 0x00 //check if the divider is 0
001616 f011                      	breq PC+3 //if the divider == 0, check loop flag
001617 952a                      	dec pulse2_volume_divider //if the divider != 0, decrement and return
001618 9508                      	ret
                                 
001619 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the divider == 0, reset the divider period
00161b 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
00161c ff91                      	sbrs pulse_channel_flags, 1 //check if the loop flag is set
00161d c002                      	rjmp pulse2_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
00161e e03f                      	ldi pulse2_volume_decay, 0x0F //if the loop flag is set, reset decay and return
00161f 9508                      	ret
                                 
                                 pulse2_envelope_routine_decrement_decay:
001620 3030                      	cpi pulse2_volume_decay, 0x00 //check if the decay is 0
001621 f409                      	brne PC+2 //if decay != 0, go decrement
001622 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
001623 953a                      	dec pulse2_volume_decay
001624 9508                      	ret
                                 
                                 pulse2_envelope_routine_clear_start:
001625 7f9b                      	cbr pulse_channel_flags, 0b00000100 //if the start flag is set, clear it
001626 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the start flag is set, reset the divider period
001628 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
001629 e03f                      	ldi pulse2_volume_decay, 0x0F //if the start flag is set, reset decay
00162a 9508                      	ret
                                 
                                 //TRIANGLE ROUTINES
                                 triangle_sequence_routine:
00162b b7bf                      	in r27, CPU_SREG
00162c 93bf                      	push r27
00162d 94f8                      	cli
                                 
00162e 5f4f                      	subi triangle_sequence, -1 //increment sequence by 1
00162f 714f                      	andi triangle_sequence, 0b00011111 //mask out bits 5, 6 and 7 NOTE: the sequence only needs bits 0-4.
                                 
001630 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
001631 93b0 0aa6                 	sts TCB2_INTFLAGS, r27
001633 91bf                      	pop r27
001634 bfbf                      	out CPU_SREG, r27
001635 9518                      	reti
                                 
                                 //CONVERTERS
                                 //converts and loads 5 bit length to corresponding 8 bit length value into r29
                                 length_converter:
001636 eae6                      	ldi ZL, LOW(length << 1)
001637 e5f3                      	ldi ZH, HIGH(length << 1)
001638 0fed                      	add ZL, r29
001639 1df2                      	adc ZH, zero
00163a 91d4                      	lpm r29, Z
00163b 9508                      	ret
                                 
                                 //loads pulse sequence into r29
                                 duty_cycle_sequences:
00163c ece6                      	ldi ZL, LOW(sequences << 1)
00163d e5f3                      	ldi ZH, HIGH(sequences << 1)
00163e 0fed                      	add ZL, r29
00163f 1df2                      	adc ZH, zero
001640 91d4                      	lpm r29, Z
001641 9508                      	ret
                                 
                                 
                                 
                                 //SOUND DRIVER
                                 sound_driver:
001642 b7bf                      	in r27, CPU_SREG
001643 93bf                      	push r27
001644 94f8                      	cli
001645 93cf                      	push r28
001646 93df                      	push r29
001647 93ef                      	push r30
001648 93ff                      	push r31
                                 
                                 	//SOUND DRIVER
001649 91a0 281a                 	lds r26, song_fx_Bxx
00164b 3faf                      	cpi r26, 0xFF //0xFF means that the flag is disabled
00164c f4a9                      	brne sound_driver_fx_Bxx_routine
00164d 91a0 281b                 	lds r26, song_fx_Cxx
00164f 11a2                      	cpse r26, zero
001650 c073                      	rjmp sound_driver_fx_Cxx_routine
001651 91a0 281c                 	lds r26, song_fx_Dxx
001653 11a2                      	cpse r26, zero
001654 c080                      	rjmp sound_driver_fx_Dxx_routine
                                 
001655 91a0 2815                 	lds r26, song_frame_offset
001657 91b0 2816                 	lds r27, song_frame_offset+1
001659 91c0 2817                 	lds r28, song_size
00165b 91d0 2818                 	lds r29, song_size+1
00165d 17ac                      	cp r26, r28
00165e 07bd                      	cpc r27, r29
00165f f408                      	brsh sound_driver_fx_song_loop
001660 c0d3                      	rjmp sound_driver_channel0
                                 
                                 
                                 sound_driver_fx_song_loop:
001661 e0a0                      	ldi r26, 0x00
                                 sound_driver_fx_Bxx_routine:
001662 91e0 2813                 	lds ZL, song_frames
001664 91f0 2814                 	lds ZH, song_frames+1
001666 27cc                      	clr r28 //initialize r29:r28 to 0
001667 27dd                      	clr r29
001668 95a3                      	inc r26 //increment xx parameter by 1
                                 sound_driver_fx_Bxx_routine_loop:
001669 95aa                      	dec r26
00166a f011                      	breq sound_driver_fx_Bxx_routine_loop_exit //once r26 == 0, r29:r28 will hold Bxx*(5*2).
00166b 962a                      	adiw r29:r28, 10 //increment the offset by 10 because 5 channels, and each address takes 2 bytes (5*2 = 10)
00166c cffc                      	rjmp sound_driver_fx_Bxx_routine_loop
                                 
                                 sound_driver_fx_Bxx_routine_loop_exit:
00166d 9622                      	adiw r29:r28, 2 //add 2 to skip the first 2 bytes (first 2 bytes is the song size)
00166e 93c0 2815                 	sts song_frame_offset, r28
001670 93d0 2816                 	sts song_frame_offset+1, r29
001672 0fec                      	add ZL, r28
001673 1ffd                      	adc ZH, r29
                                 
001674 91a5                      	lpm r26, Z+ //load the address of the frame(pattern)
001675 91b5                      	lpm r27, Z+
001676 0faa                      	lsl r26
001677 1fbb                      	rol r27
001678 93a0 281d                 	sts pulse1_pattern, r26
00167a 93b0 281e                 	sts pulse1_pattern+1, r27
00167c 91a5                      	lpm r26, Z+
00167d 91b5                      	lpm r27, Z+
00167e 0faa                      	lsl r26
00167f 1fbb                      	rol r27
001680 93a0 286a                 	sts pulse2_pattern, r26
001682 93b0 286b                 	sts pulse2_pattern+1, r27
001684 91a5                      	lpm r26, Z+
001685 91b5                      	lpm r27, Z+
001686 0faa                      	lsl r26
001687 1fbb                      	rol r27
001688 93a0 28b7                 	sts triangle_pattern, r26
00168a 93b0 28b8                 	sts triangle_pattern+1, r27
                                 
00168c 9220 2821                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
00168e 9220 2822                 	sts pulse1_pattern_offset+1, zero
001690 9220 281f                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
001692 9220 2820                 	sts pulse1_pattern_delay_frames, zero
001694 9220 286e                 	sts pulse2_pattern_offset, zero
001696 9220 286f                 	sts pulse2_pattern_offset+1, zero
001698 9220 286c                 	sts pulse2_pattern_delay_rows, zero
00169a 9220 286d                 	sts pulse2_pattern_delay_frames, zero
00169c 9220 28bb                 	sts triangle_pattern_offset, zero
00169e 9220 28bc                 	sts triangle_pattern_offset+1, zero
0016a0 9220 28b9                 	sts triangle_pattern_delay_rows, zero
0016a2 9220 28ba                 	sts triangle_pattern_delay_frames, zero
                                 
0016a4 efaf                      	ldi r26, 0xFF
0016a5 93a0 2859                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
0016a7 93a0 285a                 	sts pulse1_fx_Gxx_post, r26
0016a9 93a0 2868                 	sts pulse1_fx_Sxx_pre, r26
0016ab 93a0 2869                 	sts pulse1_fx_Sxx_post, r26
0016ad 93a0 28a6                 	sts pulse2_fx_Gxx_pre, r26
0016af 93a0 28a7                 	sts pulse2_fx_Gxx_post, r26
0016b1 93a0 28b5                 	sts pulse2_fx_Sxx_pre, r26
0016b3 93a0 28b6                 	sts pulse2_fx_Sxx_post, r26
0016b5 93a0 28ee                 	sts triangle_fx_Gxx_pre, r26
0016b7 93a0 28ef                 	sts triangle_fx_Gxx_post, r26
0016b9 93a0 28fd                 	sts triangle_fx_Sxx_pre, r26
0016bb 93a0 28fe                 	sts triangle_fx_Sxx_post, r26
                                 
0016bd 93a0 281a                 	sts song_fx_Bxx, r26 //reset all song effects
0016bf 9220 281b                 	sts song_fx_Cxx, zero
0016c1 9220 281c                 	sts song_fx_Dxx, zero
0016c3 c070                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_fx_Cxx_routine:
0016c4 91ff                      	pop r31
0016c5 91ef                      	pop r30
0016c6 91df                      	pop r29
0016c7 91cf                      	pop r28
0016c8 91bf                      	pop r27
0016c9 bfbf                      	out CPU_SREG, r27
0016ca 94f8                      	cli //disable global interrupts
                                 		
0016cb efaf                      	ldi r26, 0xFF
0016cc 93a0 281a                 	sts song_fx_Bxx, r26 //reset all song effects
0016ce 9220 281b                 	sts song_fx_Cxx, zero
0016d0 9220 281c                 	sts song_fx_Dxx, zero
                                 
0016d2 9220 2806                 	sts pulse1_output_volume, zero //mute all channels
0016d4 9518                      	reti
                                 
                                 sound_driver_fx_Dxx_routine:
0016d5 91e0 2813                 	lds ZL, song_frames
0016d7 91f0 2814                 	lds ZH, song_frames+1
0016d9 91a0 2815                 	lds r26, song_frame_offset //we must offset to the appropriate channel
0016db 91b0 2816                 	lds r27, song_frame_offset+1
0016dd 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
0016de 93a0 2815                 	sts song_frame_offset, r26
0016e0 93b0 2816                 	sts song_frame_offset+1, r27
0016e2 0fea                      	add ZL, r26
0016e3 1ffb                      	adc ZH, r27
                                 
0016e4 91a5                      	lpm r26, Z+ //load the address of the next pattern
0016e5 91b5                      	lpm r27, Z+
0016e6 0faa                      	lsl r26
0016e7 1fbb                      	rol r27
0016e8 93a0 281d                 	sts pulse1_pattern, r26
0016ea 93b0 281e                 	sts pulse1_pattern+1, r27
0016ec 91a5                      	lpm r26, Z+
0016ed 91b5                      	lpm r27, Z+
0016ee 0faa                      	lsl r26
0016ef 1fbb                      	rol r27
0016f0 93a0 286a                 	sts pulse2_pattern, r26
0016f2 93b0 286b                 	sts pulse2_pattern+1, r27
0016f4 91a5                      	lpm r26, Z+
0016f5 91b5                      	lpm r27, Z+
0016f6 0faa                      	lsl r26
0016f7 1fbb                      	rol r27
0016f8 93a0 28b7                 	sts triangle_pattern, r26
0016fa 93b0 28b8                 	sts triangle_pattern+1, r27
                                 
0016fc 9220 2821                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
0016fe 9220 2822                 	sts pulse1_pattern_offset+1, zero
001700 9220 281f                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
001702 9220 2820                 	sts pulse1_pattern_delay_frames, zero
001704 9220 286e                 	sts pulse2_pattern_offset, zero
001706 9220 286f                 	sts pulse2_pattern_offset+1, zero
001708 9220 286c                 	sts pulse2_pattern_delay_rows, zero
00170a 9220 286d                 	sts pulse2_pattern_delay_frames, zero
00170c 9220 28bb                 	sts triangle_pattern_offset, zero
00170e 9220 28bc                 	sts triangle_pattern_offset+1, zero
001710 9220 28b9                 	sts triangle_pattern_delay_rows, zero
001712 9220 28ba                 	sts triangle_pattern_delay_frames, zero
                                 
001714 efaf                      	ldi r26, 0xFF
001715 93a0 2859                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
001717 93a0 285a                 	sts pulse1_fx_Gxx_post, r26
001719 93a0 2868                 	sts pulse1_fx_Sxx_pre, r26
00171b 93a0 2869                 	sts pulse1_fx_Sxx_post, r26
00171d 93a0 28a6                 	sts pulse2_fx_Gxx_pre, r26
00171f 93a0 28a7                 	sts pulse2_fx_Gxx_post, r26
001721 93a0 28b5                 	sts pulse2_fx_Sxx_pre, r26
001723 93a0 28b6                 	sts pulse2_fx_Sxx_post, r26
001725 93a0 28ee                 	sts triangle_fx_Gxx_pre, r26
001727 93a0 28ef                 	sts triangle_fx_Gxx_post, r26
001729 93a0 28fd                 	sts triangle_fx_Sxx_pre, r26
00172b 93a0 28fe                 	sts triangle_fx_Sxx_post, r26
                                 
00172d 93a0 281a                 	sts song_fx_Bxx, r26 //reset all song effects
00172f 9220 281b                 	sts song_fx_Cxx, zero
001731 9220 281c                 	sts song_fx_Dxx, zero
001733 c000                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0:
001734 91a0 281f                 	lds r26, pulse1_pattern_delay_rows
001736 91b0 2820                 	lds r27, pulse1_pattern_delay_frames
001738 9610                      	adiw r27:r26, 0
001739 f009                      	breq sound_driver_channel0_main //if the pattern delay is 0, proceed with sound driver procedures
00173a c2c2                      	rjmp sound_driver_channel0_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel0_main:
00173b 91e0 281d                 	lds ZL, pulse1_pattern //current pattern for pulse 1
00173d 91f0 281e                 	lds ZH, pulse1_pattern+1
00173f 91a0 2821                 	lds r26, pulse1_pattern_offset //current offset in the pattern for pulse 1
001741 91b0 2822                 	lds r27, pulse1_pattern_offset+1
001743 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001744 1ffb                      	adc ZH, r27
001745 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel0_check_if_note: //check if data is a note (0x00 - 0x56)
001746 35b7                      	cpi r27, 0x57
001747 f408                      	brsh sound_driver_channel0_check_if_volume
001748 c16b                      	rjmp sound_driver_channel0_note
                                 sound_driver_channel0_check_if_volume: //check if data is volume (0x57-0x66)
001749 36b7                      	cpi r27, 0x67
00174a f408                      	brsh sound_driver_channel0_check_if_delay
00174b c1a3                      	rjmp sound_driver_channel0_volume
                                 sound_driver_channel0_check_if_delay: //check if data is a delay (0x67 - 0xE2)
00174c 3eb3                      	cpi r27, 0xE3
00174d f408                      	brsh sound_driver_channel0_check_if_instrument
00174e c1aa                      	rjmp sound_driver_channel0_delay
                                 sound_driver_channel0_check_if_instrument: //check for instrument flag (0xE3)
00174f f409                      	brne sound_driver_channel0_check_if_release
001750 c1ad                      	rjmp sound_driver_channel0_instrument_change 
                                 sound_driver_channel0_check_if_release: //check for note release flag (0xE4)
001751 3eb4                      	cpi r27, 0xE4
001752 f409                      	brne sound_driver_channel0_check_if_end
001753 c254                      	rjmp sound_driver_channel0_release
                                 sound_driver_channel0_check_if_end:
001754 3fbf                      	cpi r27, 0xFF
001755 f409                      	brne sound_driver_channel0_check_if_fx
001756 c276                      	rjmp sound_driver_channel0_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel0_check_if_fx: //fx flags (0xE5 - 0xFE)
001757 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001758 91a4                      	lpm r26, Z //load the fx data into r26
001759 d299                      	rcall sound_driver_channel0_increment_offset_twice
                                 
00175a 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
00175b ecea                      	ldi ZL, LOW(channel0_fx << 1) //load in note table
00175c e5f3                      	ldi ZH, HIGH(channel0_fx << 1)
00175d 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
00175e 0feb                      	add ZL, r27 //add offset
00175f 1df2                      	adc ZH, zero
001760 91c5                      	lpm r28, Z+ //load address bytes
001761 91d4                      	lpm r29, Z
001762 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001763 2ffd                      	mov ZH, r29
001764 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel0_fx_0xy:
001765 93a0 283f                 	sts pulse1_fx_0xy_sequence, r26
001767 9220 2840                 	sts pulse1_fx_0xy_sequence+1, zero
001769 cfd1                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel0_fx_1xx:
00176a 9220 2845                 	sts pulse1_fx_2xx, zero //turn off any 2xx pitch slide down
00176c 9220 2846                 	sts pulse1_fx_2xx+1, zero
00176e 9220 283f                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
001770 9220 2840                 	sts pulse1_fx_0xy_sequence+1, zero
001772 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001773 937f                      	push r23
001774 2f6a                      	mov r22, r26 //store the rate into r22
001775 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001776 9f67                      	mul r22, r23
001777 917f                      	pop r23
001778 916f                      	pop r22
                                 
001779 9416                      	lsr r1 //shift out the fractional bits
00177a 9407                      	ror r0
00177b 9416                      	lsr r1
00177c 9407                      	ror r0
00177d 9416                      	lsr r1
00177e 9407                      	ror r0
00177f 9416                      	lsr r1
001780 9407                      	ror r0
001781 9200 2841                 	sts pulse1_fx_1xx, r0
001783 9210 2842                 	sts pulse1_fx_1xx+1, r1
001785 cfb5                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel0_fx_2xx:
001786 9220 2841                 	sts pulse1_fx_1xx, zero //turn off any 1xx pitch slide down
001788 9220 2842                 	sts pulse1_fx_1xx+1, zero
00178a 9220 283f                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
00178c 9220 2840                 	sts pulse1_fx_0xy_sequence+1, zero
00178e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00178f 937f                      	push r23
001790 2f6a                      	mov r22, r26 //store the rate into r22
001791 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001792 9f67                      	mul r22, r23
001793 917f                      	pop r23
001794 916f                      	pop r22
                                 
001795 9416                      	lsr r1 //shift out the fractional bits
001796 9407                      	ror r0
001797 9416                      	lsr r1
001798 9407                      	ror r0
001799 9416                      	lsr r1
00179a 9407                      	ror r0
00179b 9416                      	lsr r1
00179c 9407                      	ror r0
00179d 9200 2845                 	sts pulse1_fx_2xx, r0
00179f 9210 2846                 	sts pulse1_fx_2xx+1, r1
0017a1 cf99                      	rjmp sound_driver_channel0_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel0_fx_3xx:
0017a2 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0017a3 937f                      	push r23
0017a4 2f6a                      	mov r22, r26 //store the rate into r22
0017a5 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0017a6 9f67                      	mul r22, r23
0017a7 917f                      	pop r23
0017a8 916f                      	pop r22
                                 
0017a9 9416                      	lsr r1 //shift out the fractional bits
0017aa 9407                      	ror r0
0017ab 9416                      	lsr r1
0017ac 9407                      	ror r0
0017ad 9416                      	lsr r1
0017ae 9407                      	ror r0
0017af 9416                      	lsr r1
0017b0 9407                      	ror r0
0017b1 9200 284d                 	sts pulse1_fx_3xx_speed, r0
0017b3 9210 284e                 	sts pulse1_fx_3xx_speed+1, r1
                                 
0017b5 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
0017b6 c001                      	rjmp sound_driver_channel0_fx_3xx_enabled
0017b7 cf83                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_3xx_enabled:
0017b8 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
0017ba 91b0 0a8d                 	lds r27, TCB0_CCMPH
0017bc 93a0 2849                 	sts pulse1_fx_3xx_start, r26
0017be 93b0 284a                 	sts pulse1_fx_3xx_start+1, r27
                                 
0017c0 9220 284f                 	sts pulse1_fx_3xx_total_offset, zero
0017c2 9220 2850                 	sts pulse1_fx_3xx_total_offset+1, zero
0017c4 cf76                      	rjmp sound_driver_channel0_main
                                 
                                 //VIBRATO
                                 sound_driver_channel0_fx_4xy:
0017c5 2fba                      	mov r27, r26
0017c6 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
0017c7 95a2                      	swap r26
0017c8 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0017c9 93a0 2851                 	sts pulse1_fx_4xy_speed, r26
0017cb 93b0 2852                 	sts pulse1_fx_4xy_depth, r27
0017cd 9220 2853                 	sts pulse1_fx_4xy_phase, zero //reset the phase to 0
0017cf cf6b                      	rjmp sound_driver_channel0_main
                                 
                                 //TREMELO
                                 sound_driver_channel0_fx_7xy:
0017d0 2fba                      	mov r27, r26
0017d1 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
0017d2 95a2                      	swap r26
0017d3 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0017d4 93a0 2854                 	sts pulse1_fx_7xy_speed, r26
0017d6 93b0 2855                 	sts pulse1_fx_7xy_depth, r27
0017d8 9220 2856                 	sts pulse1_fx_7xy_phase, zero //reset the phase to 0
0017da 9220 2857                 	sts pulse1_fx_7xy_value, zero //reset the tremelo value
0017dc cf5e                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel0_fx_Axy:
0017dd 93a0 2858                 	sts pulse1_fx_Axy, r26
0017df cf5b                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel0_fx_Bxx:
0017e0 93a0 281a                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
0017e2 cf58                      	rjmp sound_driver_channel0_main
                                 
                                 //HALT
                                 sound_driver_channel0_fx_Cxx:
0017e3 93b0 281b                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
0017e5 cf55                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel0_fx_Dxx:
0017e6 93b0 281c                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
0017e8 cf52                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME
                                 sound_driver_channel0_fx_Exx:
0017e9 91b0 2800                 	lds r27, pulse1_param
0017eb 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
0017ec 2bba                      	or r27, r26 //move new VVVV bits into pulse1_param
0017ed 93b0 2800                 	sts pulse1_param, r27
0017ef 6096                      	sbr pulse_channel_flags, 6
0017f0 cf4a                      	rjmp sound_driver_channel0_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel0_fx_Fxx:
0017f1 93a0 2819                 	sts song_speed, r26 //NOTE: only changes to speed are supported
0017f3 cf47                      	rjmp sound_driver_channel0_main
                                 
                                 //DELAY
                                 sound_driver_channel0_fx_Gxx:
0017f4 15a2                      	cp r26, zero
0017f5 f051                      	breq sound_driver_channel0_fx_Gxx_invalid
0017f6 91b0 2819                 	lds r27, song_speed
0017f8 17ab                      	cp r26, r27
0017f9 f430                      	brsh sound_driver_channel0_fx_Gxx_invalid
0017fa 93a0 2859                 	sts pulse1_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
0017fc e0b1                      	ldi r27, 0x01
0017fd 93b0 281f                 	sts pulse1_pattern_delay_rows, r27
0017ff c200                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Gxx_invalid:
001800 cf3a                      	rjmp sound_driver_channel0_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel0_fx_Hxy: //hardware sweep up
001801 cf39                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixy: //hardware sweep down
001802 cf38                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Hxx: //FDS modulation depth
001803 cf37                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixx: //FDS modulation speed
001804 cf36                      	rjmp sound_driver_channel0_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel0_fx_Pxx:
001805 93a0 285b                 	sts pulse1_fx_Pxx, r26
001807 cf33                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel0_fx_Qxy:
                                 sound_driver_channel0_fx_Qxy_check_arpeggio_macro:
001808 91e0 2828                 	lds ZL, pulse1_arpeggio_macro
00180a 91f0 2829                 	lds ZH, pulse1_arpeggio_macro+1
00180c 9630                      	adiw Z, 0
00180d f009                      	breq sound_driver_channel0_fx_Qxy_check_pitch_macro
00180e cf2c                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_pitch_macro:
00180f 91e0 282f                 	lds ZL, pulse1_pitch_macro
001811 91f0 2830                 	lds ZH, pulse1_pitch_macro+1
001813 9630                      	adiw Z, 0
001814 f009                      	breq sound_driver_channel0_fx_Qxy_check_hi_pitch_macro
001815 cf25                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_hi_pitch_macro:
001816 91e0 2835                 	lds ZL, pulse1_hi_pitch_macro
001818 91f0 2836                 	lds ZH, pulse1_hi_pitch_macro+1
00181a 9630                      	adiw Z, 0
00181b f009                      	breq sound_driver_channel0_fx_Qxy_process
00181c cf1e                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_process:
00181d 2fba                      	mov r27, r26 //copy fx parameters into r27
00181e 70bf                      	andi r27, 0x0F //mask note index offset
00181f 91c0 2807                 	lds r28, pulse1_note //load current note index
001821 0fbc                      	add r27, r28
001822 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001823 f008                      	brlo sound_driver_channel0_fx_Qxy_process_continue
001824 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel0_fx_Qxy_process_continue:
001825 e6e8                      	ldi ZL, LOW(note_table << 1) //load in note table
001826 e0f0                      	ldi ZH, HIGH(note_table << 1)
001827 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001828 0feb                      	add ZL, r27 //add offset
001829 1df2                      	adc ZH, zero
00182a 91c5                      	lpm r28, Z+ //load bytes
00182b 91d4                      	lpm r29, Z
00182c 93c0 285c                 	sts pulse1_fx_Qxy_target, r28 //load the LOW bits for the target period
00182e 93d0 285d                 	sts pulse1_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
001830 95a2                      	swap r26
001831 70af                      	andi r26, 0x0F //mask effect speed
001832 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001833 95a3                      	inc r26 //increment the speed by 1
                                 
001834 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001835 937f                      	push r23
001836 2f6a                      	mov r22, r26 //store the speed data into r27
001837 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001838 9f67                      	mul r22, r23
001839 917f                      	pop r23
00183a 916f                      	pop r22
                                 
00183b 9416                      	lsr r1 //shift out the fractional bits
00183c 9407                      	ror r0
00183d 9416                      	lsr r1
00183e 9407                      	ror r0
00183f 9416                      	lsr r1
001840 9407                      	ror r0
001841 9416                      	lsr r1
001842 9407                      	ror r0
                                 
001843 9200 285e                 	sts pulse1_fx_Qxy_speed, r0 //store the effect speed
001845 9210 285f                 	sts pulse1_fx_Qxy_speed+1, r1
001847 9220 2860                 	sts pulse1_fx_Qxy_total_offset, zero
001849 9220 2861                 	sts pulse1_fx_Qxy_total_offset+1, zero
00184b ceef                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel0_fx_Rxy:
                                 sound_driver_channel0_fx_Rxy_check_arpeggio_macro:
00184c 91e0 2828                 	lds ZL, pulse1_arpeggio_macro
00184e 91f0 2829                 	lds ZH, pulse1_arpeggio_macro+1
001850 9630                      	adiw Z, 0
001851 f009                      	breq sound_driver_channel0_fx_Rxy_check_pitch_macro
001852 cee8                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_pitch_macro:
001853 91e0 282f                 	lds ZL, pulse1_pitch_macro
001855 91f0 2830                 	lds ZH, pulse1_pitch_macro+1
001857 9630                      	adiw Z, 0
001858 f009                      	breq sound_driver_channel0_fx_Rxy_check_hi_pitch_macro
001859 cee1                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_hi_pitch_macro:
00185a 91e0 2835                 	lds ZL, pulse1_hi_pitch_macro
00185c 91f0 2836                 	lds ZH, pulse1_hi_pitch_macro+1
00185e 9630                      	adiw Z, 0
00185f f009                      	breq sound_driver_channel0_fx_Rxy_process
001860 ceda                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_process:
001861 2fba                      	mov r27, r26 //copy fx parameters into r27
001862 70bf                      	andi r27, 0x0F //mask note index offset
001863 91c0 2807                 	lds r28, pulse1_note //load current note index
001865 1bcb                      	sub r28, r27
001866 f408                      	brcc sound_driver_channel0_fx_Rxy_process_continue
001867 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel0_fx_Rxy_process_continue:
001868 e6e8                      	ldi ZL, LOW(note_table << 1) //load in note table
001869 e0f0                      	ldi ZH, HIGH(note_table << 1)
00186a 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
00186b 0fec                      	add ZL, r28 //add offset
00186c 1df2                      	adc ZH, zero
00186d 91c5                      	lpm r28, Z+ //load bytes
00186e 91d4                      	lpm r29, Z
00186f 93c0 2862                 	sts pulse1_fx_Rxy_target, r28 //load the LOW bits for the target period
001871 93d0 2863                 	sts pulse1_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
001873 95a2                      	swap r26
001874 70af                      	andi r26, 0x0F //mask effect speed
001875 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001876 95a3                      	inc r26 //increment the speed by 1
                                 
001877 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001878 937f                      	push r23
001879 2f6a                      	mov r22, r26 //store the speed data into r27
00187a eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00187b 9f67                      	mul r22, r23
00187c 917f                      	pop r23
00187d 916f                      	pop r22
                                 
00187e 9416                      	lsr r1 //shift out the fractional bits
00187f 9407                      	ror r0
001880 9416                      	lsr r1
001881 9407                      	ror r0
001882 9416                      	lsr r1
001883 9407                      	ror r0
001884 9416                      	lsr r1
001885 9407                      	ror r0
                                 
001886 9200 2864                 	sts pulse1_fx_Rxy_speed, r0 //store the effect speed
001888 9210 2865                 	sts pulse1_fx_Rxy_speed+1, r1
00188a 9220 2866                 	sts pulse1_fx_Rxy_total_offset, zero
00188c 9220 2867                 	sts pulse1_fx_Rxy_total_offset+1, zero
00188e ceac                      	rjmp sound_driver_channel0_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel0_fx_Sxx:
00188f 15a2                      	cp r26, zero
001890 f051                      	breq sound_driver_channel0_fx_Sxx_invalid
001891 91b0 2819                 	lds r27, song_speed
001893 17ab                      	cp r26, r27
001894 f430                      	brsh sound_driver_channel0_fx_Sxx_invalid
001895 93a0 2868                 	sts pulse1_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001897 e0b1                      	ldi r27, 0x01
001898 93b0 281f                 	sts pulse1_pattern_delay_rows, r27
00189a c165                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Sxx_invalid:
00189b ce9f                      	rjmp sound_driver_channel0_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel0_fx_Vxx:
00189c ece6                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
00189d e5f3                      	ldi ZH, HIGH(sequences << 1)
00189e 0fea                      	add ZL, r26 //offset the pointer
00189f 1df2                      	adc ZH, zero
                                 
0018a0 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
0018a1 95a7                      	ror r26
0018a2 95a7                      	ror r26
0018a3 91b0 2800                 	lds r27, pulse1_param //load r27 with pulse1_param (register $4000)
0018a5 2fcb                      	mov r28, r27 //store a copy of pulse1_param into r28
0018a6 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
0018a7 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
0018a8 c001                      	rjmp sound_driver_channel0_fx_Vxx_store
0018a9 ce91                      	rjmp sound_driver_channel0_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel0_fx_Vxx_store:
0018aa 90a4                      	lpm pulse1_sequence, Z //store the sequence
                                 
0018ab 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
0018ac 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
0018ad 93c0 2800                 	sts pulse1_param, r28
0018af ce8b                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_Wxx: //DPCM sample speed
0018b0 ce8a                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Xxx: //DPCM sample retrigger
0018b1 ce89                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Yxx: //DPCM sample offset
0018b2 ce88                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Zxx: //DPCM sample delta counter
0018b3 ce87                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 sound_driver_channel0_note:
0018b4 93b0 2807                 	sts pulse1_note, r27 //store the note index
0018b6 e0a3                      	ldi r26, 0x03
0018b7 e0b2                      	ldi r27, 0x02
0018b8 93b0 2825                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
0018ba 93a0 282a                 	sts pulse1_arpeggio_macro_offset, r26
0018bc 93b0 2831                 	sts pulse1_pitch_macro_offset, r27
0018be 93b0 2837                 	sts pulse1_hi_pitch_macro_offset, r27
0018c0 93b0 283c                 	sts pulse1_duty_macro_offset, r27
0018c2 9220 282e                 	sts pulse1_total_pitch_offset, zero //reset the pitch and hi pitch offset
0018c4 9220 2834                 	sts pulse1_total_hi_pitch_offset, zero
0018c6 9220 2843                 	sts pulse1_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
0018c8 9220 2844                 	sts pulse1_fx_1xx_total+1, zero
0018ca 9220 2847                 	sts pulse1_fx_2xx_total, zero
0018cc 9220 2848                 	sts pulse1_fx_2xx_total+1, zero
0018ce 9220 284f                 	sts pulse1_fx_3xx_total_offset, zero //reset 3xx offset
0018d0 9220 2850                 	sts pulse1_fx_3xx_total_offset+1, zero
0018d2 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
0018d4 91b0 0a8d                 	lds r27, TCB0_CCMPH
0018d6 93a0 2849                 	sts pulse1_fx_3xx_start, r26
0018d8 93b0 284a                 	sts pulse1_fx_3xx_start+1, r27
0018da 9220 2801                 	sts pulse1_sweep_param, zero //reset any sweep effect
0018dc 6097                      	sbr pulse_channel_flags, 7 //set reload flag
0018dd 9220 285c                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0018df 9220 285d                 	sts pulse1_fx_Qxy_target+1, zero
0018e1 9220 2860                 	sts pulse1_fx_Qxy_total_offset, zero
0018e3 9220 2861                 	sts pulse1_fx_Qxy_total_offset+1, zero
0018e5 9220 2862                 	sts pulse1_fx_Rxy_target, zero
0018e7 9220 2863                 	sts pulse1_fx_Rxy_target+1, zero
0018e9 9220 2866                 	sts pulse1_fx_Rxy_total_offset, zero
0018eb 9220 2867                 	sts pulse1_fx_Rxy_total_offset+1, zero
0018ed d0fb                      	rcall sound_driver_channel0_increment_offset
0018ee ce4c                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_volume:
0018ef 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
0018f0 91a0 2800                 	lds r26, pulse1_param
0018f2 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
0018f3 2bab                      	or r26, r27 //move new VVVV bits into pulse1_param
0018f4 93a0 2800                 	sts pulse1_param, r26
0018f6 6096                      	sbr pulse_channel_flags, 6
0018f7 d0f1                      	rcall sound_driver_channel0_increment_offset
0018f8 ce42                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_delay:
0018f9 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
0018fa 93b0 281f                 	sts pulse1_pattern_delay_rows, r27
0018fc d0ec                      	rcall sound_driver_channel0_increment_offset
0018fd c102                      	rjmp sound_driver_channel1
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change:
0018fe 9220 2823                 	sts pulse1_volume_macro, zero //reset all macro addresses
001900 9220 2824                 	sts pulse1_volume_macro+1, zero
001902 9220 2828                 	sts pulse1_arpeggio_macro, zero
001904 9220 2829                 	sts pulse1_arpeggio_macro+1, zero
001906 9220 282f                 	sts pulse1_pitch_macro, zero
001908 9220 2830                 	sts pulse1_pitch_macro+1, zero
00190a 9220 2835                 	sts pulse1_hi_pitch_macro, zero
00190c 9220 2836                 	sts pulse1_hi_pitch_macro+1, zero
00190e 9220 283a                 	sts pulse1_duty_macro, zero
001910 9220 283b                 	sts pulse1_duty_macro+1, zero
001912 9220 282e                 	sts pulse1_total_pitch_offset, zero //reset the pitch offset
001914 9220 2834                 	sts pulse1_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001916 9631                      	adiw Z, 1 //point to the byte next to the flag
001917 91b4                      	lpm r27, Z //store the instrument offset into r27
001918 e6ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
001919 e1f0                      	ldi ZH, HIGH(instruments)
00191a 0feb                      	add ZL, r27 //point Z to offsetted instrument
00191b 1df2                      	adc ZH, zero
00191c 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
00191d 1fff                      	rol ZH
00191e 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
00191f 91b4                      	lpm r27, Z
                                 
001920 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001921 1fbb                      	rol r27
001922 2fea                      	mov ZL, r26
001923 2ffb                      	mov ZH, r27
001924 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001925 9632                      	adiw Z, 2 //point Z to the address of the macro
001926 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel0_instrument_change_macro_loop:
001927 95aa                      	dec r26
001928 f019                      	breq sound_driver_channel0_instrument_change_exit
001929 95b6                      	lsr r27
00192a f078                      	brcs sound_driver_channel0_instrument_change_load_macro
00192b cffb                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_exit:
00192c e0a3                      	ldi r26, 0x03
00192d e0b2                      	ldi r27, 0x02
00192e 93b0 2825                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
001930 93a0 282a                 	sts pulse1_arpeggio_macro_offset, r26
001932 93b0 2831                 	sts pulse1_pitch_macro_offset, r27
001934 93b0 2837                 	sts pulse1_hi_pitch_macro_offset, r27
001936 93b0 283c                 	sts pulse1_duty_macro_offset, r27
001938 d0ba                      	rcall sound_driver_channel0_increment_offset_twice
001939 ce01                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_load_macro:
00193a 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
00193b 91d5                      	lpm r29, Z+
                                 
00193c 30a5                      	cpi r26, 5
00193d f039                      	breq sound_driver_channel0_instrument_change_load_macro_volume
00193e 30a4                      	cpi r26, 4
00193f f079                      	breq sound_driver_channel0_instrument_change_load_macro_arpeggio
001940 30a3                      	cpi r26, 3
001941 f0d9                      	breq sound_driver_channel0_instrument_change_load_macro_pitch
001942 30a2                      	cpi r26, 2
001943 f159                      	breq sound_driver_channel0_instrument_change_load_macro_hi_pitch
001944 c03c                      	rjmp sound_driver_channel0_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel0_instrument_change_load_macro_volume:
001945 93c0 2823                 	sts pulse1_volume_macro, r28
001947 93d0 2824                 	sts pulse1_volume_macro+1, r29
001949 d041                      	rcall sound_driver_channel0_instrument_change_read_header
00194a 93c0 2827                 	sts pulse1_volume_macro_release, r28
00194c 93d0 2826                 	sts pulse1_volume_macro_loop, r29
00194e cfd8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 	
                                 sound_driver_channel0_instrument_change_load_macro_arpeggio:
00194f 93c0 2828                 	sts pulse1_arpeggio_macro, r28
001951 93d0 2829                 	sts pulse1_arpeggio_macro+1, r29
001953 9220 285c                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001955 9220 285d                 	sts pulse1_fx_Qxy_target+1, zero
001957 9220 2862                 	sts pulse1_fx_Rxy_target, zero
001959 9220 2863                 	sts pulse1_fx_Rxy_target+1, zero
00195b d03a                      	rcall sound_driver_channel0_instrument_change_read_header_arpeggio
00195c cfca                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_pitch:
00195d 93c0 282f                 	sts pulse1_pitch_macro, r28
00195f 93d0 2830                 	sts pulse1_pitch_macro+1, r29
001961 9220 285c                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001963 9220 285d                 	sts pulse1_fx_Qxy_target+1, zero
001965 9220 2862                 	sts pulse1_fx_Rxy_target, zero
001967 9220 2863                 	sts pulse1_fx_Rxy_target+1, zero
001969 d021                      	rcall sound_driver_channel0_instrument_change_read_header
00196a 93c0 2833                 	sts pulse1_pitch_macro_release, r28
00196c 93d0 2832                 	sts pulse1_pitch_macro_loop, r29
00196e cfb8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_hi_pitch:
00196f 93c0 2835                 	sts pulse1_hi_pitch_macro, r28
001971 93d0 2836                 	sts pulse1_hi_pitch_macro+1, r29
001973 9220 285c                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001975 9220 285d                 	sts pulse1_fx_Qxy_target+1, zero
001977 9220 2862                 	sts pulse1_fx_Rxy_target, zero
001979 9220 2863                 	sts pulse1_fx_Rxy_target+1, zero
00197b d00f                      	rcall sound_driver_channel0_instrument_change_read_header
00197c 93c0 2839                 	sts pulse1_hi_pitch_macro_release, r28
00197e 93d0 2838                 	sts pulse1_hi_pitch_macro_loop, r29
001980 cfa6                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_duty:
001981 93c0 283a                 	sts pulse1_duty_macro, r28
001983 93d0 283b                 	sts pulse1_duty_macro+1, r29
001985 d005                      	rcall sound_driver_channel0_instrument_change_read_header
001986 93c0 283e                 	sts pulse1_duty_macro_release, r28
001988 93d0 283d                 	sts pulse1_duty_macro_loop, r29
00198a cf9c                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_read_header:
00198b 93ef                      	push ZL
00198c 93ff                      	push ZH
00198d 2fec                      	mov ZL, r28
00198e 2ffd                      	mov ZH, r29
00198f 0fee                      	lsl ZL
001990 1fff                      	rol ZH
001991 91c5                      	lpm r28, Z+
001992 91d4                      	lpm r29, Z
001993 91ff                      	pop ZH
001994 91ef                      	pop ZL
001995 9508                      	ret
                                 
                                 sound_driver_channel0_instrument_change_read_header_arpeggio:
001996 93ef                      	push ZL
001997 93ff                      	push ZH
001998 2fec                      	mov ZL, r28
001999 2ffd                      	mov ZH, r29
00199a 0fee                      	lsl ZL
00199b 1fff                      	rol ZH
00199c 91c5                      	lpm r28, Z+
00199d 91d5                      	lpm r29, Z+
00199e 93c0 282c                 	sts pulse1_arpeggio_macro_release, r28
0019a0 93d0 282b                 	sts pulse1_arpeggio_macro_loop, r29
0019a2 91c4                      	lpm r28, Z
0019a3 93c0 282d                 	sts pulse1_arpeggio_macro_mode, r28
0019a5 91ff                      	pop ZH
0019a6 91ef                      	pop ZL
0019a7 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel0_release:
                                 sound_driver_channel0_release_volume:
0019a8 91b0 2827                 	lds r27, pulse1_volume_macro_release
0019aa 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
0019ab f019                      	breq sound_driver_channel0_release_arpeggio //if the macro has no release flag, check the next macro
0019ac 95b3                      	inc r27
0019ad 93b0 2825                 	sts pulse1_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel0_release_arpeggio:
0019af 91b0 282c                 	lds r27, pulse1_arpeggio_macro_release
0019b1 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
0019b2 f019                      	breq sound_driver_channel0_release_pitch
0019b3 95b3                      	inc r27
0019b4 93b0 282a                 	sts pulse1_arpeggio_macro_offset, r27
                                 sound_driver_channel0_release_pitch:
0019b6 91b0 2833                 	lds r27, pulse1_pitch_macro_release
0019b8 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
0019b9 f019                      	breq sound_driver_channel0_release_hi_pitch
0019ba 95b3                      	inc r27
0019bb 93b0 2831                 	sts pulse1_pitch_macro_offset, r27
                                 sound_driver_channel0_release_hi_pitch:
0019bd 91b0 2839                 	lds r27, pulse1_hi_pitch_macro_release
0019bf 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
0019c0 f019                      	breq sound_driver_channel0_release_duty
0019c1 95b3                      	inc r27
0019c2 93b0 2837                 	sts pulse1_hi_pitch_macro_offset, r27
                                 sound_driver_channel0_release_duty:
0019c4 91b0 283e                 	lds r27, pulse1_duty_macro_release
0019c6 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
0019c7 f019                      	breq sound_driver_channel0_release_exit
0019c8 95b3                      	inc r27
0019c9 93b0 283c                 	sts pulse1_duty_macro_offset, r27
                                 sound_driver_channel0_release_exit:
0019cb d01d                      	rcall sound_driver_channel0_increment_offset
0019cc cd6e                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_next_pattern:
0019cd 91e0 2813                 	lds ZL, song_frames
0019cf 91f0 2814                 	lds ZH, song_frames+1
0019d1 91a0 2815                 	lds r26, song_frame_offset //we must offset to the appropriate channel
0019d3 91b0 2816                 	lds r27, song_frame_offset+1
0019d5 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
0019d6 93a0 2815                 	sts song_frame_offset, r26
0019d8 93b0 2816                 	sts song_frame_offset+1, r27
0019da 0fea                      	add ZL, r26
0019db 1ffb                      	adc ZH, r27
                                 
0019dc 91a5                      	lpm r26, Z+ //load the address of the next pattern
0019dd 91b4                      	lpm r27, Z
0019de 0faa                      	lsl r26
0019df 1fbb                      	rol r27
0019e0 93a0 281d                 	sts pulse1_pattern, r26
0019e2 93b0 281e                 	sts pulse1_pattern+1, r27
                                 
0019e4 9220 2821                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
0019e6 9220 2822                 	sts pulse1_pattern_offset+1, zero
0019e8 cd52                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_increment_offset:
0019e9 91e0 2821                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
0019eb 91f0 2822                 	lds ZH, pulse1_pattern_offset+1
0019ed 9631                      	adiw Z, 1
0019ee 93e0 2821                 	sts pulse1_pattern_offset, ZL
0019f0 93f0 2822                 	sts pulse1_pattern_offset+1, ZH
0019f2 9508                      	ret
                                 
                                 sound_driver_channel0_increment_offset_twice: //used for data that takes up 2 bytes worth of space
0019f3 91e0 2821                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
0019f5 91f0 2822                 	lds ZH, pulse1_pattern_offset+1
0019f7 9632                      	adiw Z, 2 //increment the pointer twice
0019f8 93e0 2821                 	sts pulse1_pattern_offset, ZL
0019fa 93f0 2822                 	sts pulse1_pattern_offset+1, ZH
0019fc 9508                      	ret
                                 
                                 sound_driver_channel0_decrement_frame_delay:
0019fd 95ba                      	dec r27
0019fe 93b0 2820                 	sts pulse1_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel1:
001a00 91a0 286c                 	lds r26, pulse2_pattern_delay_rows
001a02 91b0 286d                 	lds r27, pulse2_pattern_delay_frames
001a04 9610                      	adiw r27:r26, 0
001a05 f009                      	breq sound_driver_channel1_main //if the pattern delay is 0, proceed with sound driver procedures
001a06 c2be                      	rjmp sound_driver_channel1_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel1_main:
001a07 91e0 286a                 	lds ZL, pulse2_pattern //current pattern for pulse 2
001a09 91f0 286b                 	lds ZH, pulse2_pattern+1
001a0b 91a0 286e                 	lds r26, pulse2_pattern_offset //current offset in the pattern for pulse 2
001a0d 91b0 286f                 	lds r27, pulse2_pattern_offset+1
001a0f 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001a10 1ffb                      	adc ZH, r27
001a11 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel1_check_if_note: //check if data is a note (0x00 - 0x56)
001a12 35b7                      	cpi r27, 0x57
001a13 f408                      	brsh sound_driver_channel1_check_if_volume
001a14 c16b                      	rjmp sound_driver_channel1_note
                                 sound_driver_channel1_check_if_volume: //check if data is volume (0x57-0x66)
001a15 36b7                      	cpi r27, 0x67
001a16 f408                      	brsh sound_driver_channel1_check_if_delay
001a17 c1a3                      	rjmp sound_driver_channel1_volume
                                 sound_driver_channel1_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001a18 3eb3                      	cpi r27, 0xE3
001a19 f408                      	brsh sound_driver_channel1_check_if_instrument
001a1a c1aa                      	rjmp sound_driver_channel1_delay
                                 sound_driver_channel1_check_if_instrument: //check for instrument flag (0xE3)
001a1b f409                      	brne sound_driver_channel1_check_if_release
001a1c c1ad                      	rjmp sound_driver_channel1_instrument_change 
                                 sound_driver_channel1_check_if_release: //check for note release flag (0xE4)
001a1d 3eb4                      	cpi r27, 0xE4
001a1e f409                      	brne sound_driver_channel1_check_if_end
001a1f c254                      	rjmp sound_driver_channel1_release
                                 sound_driver_channel1_check_if_end:
001a20 3fbf                      	cpi r27, 0xFF
001a21 f409                      	brne sound_driver_channel1_check_if_fx
001a22 c276                      	rjmp sound_driver_channel1_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel1_check_if_fx: //fx flags (0xE5 - 0xFE)
001a23 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001a24 91a4                      	lpm r26, Z //load the fx data into r26
001a25 d295                      	rcall sound_driver_channel1_increment_offset_twice
                                 
001a26 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001a27 efee                      	ldi ZL, LOW(channel1_fx << 1) //load in note table
001a28 e5f3                      	ldi ZH, HIGH(channel1_fx << 1)
001a29 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001a2a 0feb                      	add ZL, r27 //add offset
001a2b 1df2                      	adc ZH, zero
001a2c 91c5                      	lpm r28, Z+ //load address bytes
001a2d 91d4                      	lpm r29, Z
001a2e 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001a2f 2ffd                      	mov ZH, r29
001a30 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel1_fx_0xy:
001a31 93a0 288c                 	sts pulse2_fx_0xy_sequence, r26
001a33 9220 288d                 	sts pulse2_fx_0xy_sequence+1, zero
001a35 cfd1                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel1_fx_1xx:
001a36 9220 2892                 	sts pulse2_fx_2xx, zero //turn off any 2xx pitch slide down
001a38 9220 2893                 	sts pulse2_fx_2xx+1, zero
001a3a 9220 288c                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
001a3c 9220 288d                 	sts pulse2_fx_0xy_sequence+1, zero
001a3e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001a3f 937f                      	push r23
001a40 2f6a                      	mov r22, r26 //store the rate into r22
001a41 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001a42 9f67                      	mul r22, r23
001a43 917f                      	pop r23
001a44 916f                      	pop r22
                                 
001a45 9416                      	lsr r1 //shift out the fractional bits
001a46 9407                      	ror r0
001a47 9416                      	lsr r1
001a48 9407                      	ror r0
001a49 9416                      	lsr r1
001a4a 9407                      	ror r0
001a4b 9416                      	lsr r1
001a4c 9407                      	ror r0
001a4d 9200 288e                 	sts pulse2_fx_1xx, r0
001a4f 9210 288f                 	sts pulse2_fx_1xx+1, r1
001a51 cfb5                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel1_fx_2xx:
001a52 9220 288e                 	sts pulse2_fx_1xx, zero //turn off any 1xx pitch slide down
001a54 9220 288f                 	sts pulse2_fx_1xx+1, zero
001a56 9220 288c                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
001a58 9220 288d                 	sts pulse2_fx_0xy_sequence+1, zero
001a5a 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001a5b 937f                      	push r23
001a5c 2f6a                      	mov r22, r26 //store the rate into r22
001a5d eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001a5e 9f67                      	mul r22, r23
001a5f 917f                      	pop r23
001a60 916f                      	pop r22
                                 
001a61 9416                      	lsr r1 //shift out the fractional bits
001a62 9407                      	ror r0
001a63 9416                      	lsr r1
001a64 9407                      	ror r0
001a65 9416                      	lsr r1
001a66 9407                      	ror r0
001a67 9416                      	lsr r1
001a68 9407                      	ror r0
001a69 9200 2892                 	sts pulse2_fx_2xx, r0
001a6b 9210 2893                 	sts pulse2_fx_2xx+1, r1
001a6d cf99                      	rjmp sound_driver_channel1_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel1_fx_3xx:
001a6e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001a6f 937f                      	push r23
001a70 2f6a                      	mov r22, r26 //store the rate into r22
001a71 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001a72 9f67                      	mul r22, r23
001a73 917f                      	pop r23
001a74 916f                      	pop r22
                                 
001a75 9416                      	lsr r1 //shift out the fractional bits
001a76 9407                      	ror r0
001a77 9416                      	lsr r1
001a78 9407                      	ror r0
001a79 9416                      	lsr r1
001a7a 9407                      	ror r0
001a7b 9416                      	lsr r1
001a7c 9407                      	ror r0
001a7d 9200 289a                 	sts pulse2_fx_3xx_speed, r0
001a7f 9210 289b                 	sts pulse2_fx_3xx_speed+1, r1
                                 
001a81 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001a82 c001                      	rjmp sound_driver_channel1_fx_3xx_enabled
001a83 cf83                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_3xx_enabled:
001a84 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001a86 91b0 0a9d                 	lds r27, TCB1_CCMPH
001a88 93a0 2896                 	sts pulse2_fx_3xx_start, r26
001a8a 93b0 2897                 	sts pulse2_fx_3xx_start+1, r27
                                 
001a8c 9220 289c                 	sts pulse2_fx_3xx_total_offset, zero
001a8e 9220 289d                 	sts pulse2_fx_3xx_total_offset+1, zero
001a90 cf76                      	rjmp sound_driver_channel1_main
                                 
                                 //VIBRATO
                                 sound_driver_channel1_fx_4xy:
001a91 2fba                      	mov r27, r26
001a92 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001a93 95a2                      	swap r26
001a94 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001a95 93a0 289e                 	sts pulse2_fx_4xy_speed, r26
001a97 93b0 289f                 	sts pulse2_fx_4xy_depth, r27
001a99 9220 28a0                 	sts pulse2_fx_4xy_phase, zero //reset the phase to 0
001a9b cf6b                      	rjmp sound_driver_channel1_main
                                 
                                 //TREMELO
                                 sound_driver_channel1_fx_7xy:
001a9c 2fba                      	mov r27, r26
001a9d 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001a9e 95a2                      	swap r26
001a9f 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001aa0 93a0 28a1                 	sts pulse2_fx_7xy_speed, r26
001aa2 93b0 28a2                 	sts pulse2_fx_7xy_depth, r27
001aa4 9220 28a3                 	sts pulse2_fx_7xy_phase, zero //reset the phase to 0
001aa6 9220 28a4                 	sts pulse2_fx_7xy_value, zero //reset the tremelo value
001aa8 cf5e                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel1_fx_Axy:
001aa9 93a0 28a5                 	sts pulse2_fx_Axy, r26
001aab cf5b                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel1_fx_Bxx:
001aac 93a0 281a                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001aae cf58                      	rjmp sound_driver_channel1_main
                                 
                                 //HALT
                                 sound_driver_channel1_fx_Cxx:
001aaf 93b0 281b                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001ab1 cf55                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel1_fx_Dxx:
001ab2 93b0 281c                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001ab4 cf52                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME
                                 sound_driver_channel1_fx_Exx:
001ab5 91b0 2808                 	lds r27, pulse2_param
001ab7 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
001ab8 2bba                      	or r27, r26 //move new VVVV bits into pulse2_param
001ab9 93b0 2808                 	sts pulse2_param, r27
001abb 6092                      	sbr pulse_channel_flags, 2
001abc cf4a                      	rjmp sound_driver_channel1_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel1_fx_Fxx:
001abd 93a0 2819                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001abf cf47                      	rjmp sound_driver_channel1_main
                                 
                                 //DELAY
                                 sound_driver_channel1_fx_Gxx:
001ac0 15a2                      	cp r26, zero
001ac1 f051                      	breq sound_driver_channel1_fx_Gxx_invalid
001ac2 91b0 2819                 	lds r27, song_speed
001ac4 17ab                      	cp r26, r27
001ac5 f430                      	brsh sound_driver_channel1_fx_Gxx_invalid
001ac6 93a0 28a6                 	sts pulse2_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001ac8 e0b1                      	ldi r27, 0x01
001ac9 93b0 286c                 	sts pulse2_pattern_delay_rows, r27
001acb c1fc                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Gxx_invalid:
001acc cf3a                      	rjmp sound_driver_channel1_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel1_fx_Hxy: //hardware sweep up
001acd cf39                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixy: //hardware sweep down
001ace cf38                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Hxx: //FDS modulation depth
001acf cf37                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixx: //FDS modulation speed
001ad0 cf36                      	rjmp sound_driver_channel1_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel1_fx_Pxx:
001ad1 93a0 28a8                 	sts pulse2_fx_Pxx, r26
001ad3 cf33                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel1_fx_Qxy:
                                 sound_driver_channel1_fx_Qxy_check_arpeggio_macro:
001ad4 91e0 2875                 	lds ZL, pulse2_arpeggio_macro
001ad6 91f0 2876                 	lds ZH, pulse2_arpeggio_macro+1
001ad8 9630                      	adiw Z, 0
001ad9 f009                      	breq sound_driver_channel1_fx_Qxy_check_pitch_macro
001ada cf2c                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_pitch_macro:
001adb 91e0 287c                 	lds ZL, pulse2_pitch_macro
001add 91f0 287d                 	lds ZH, pulse2_pitch_macro+1
001adf 9630                      	adiw Z, 0
001ae0 f009                      	breq sound_driver_channel1_fx_Qxy_check_hi_pitch_macro
001ae1 cf25                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_hi_pitch_macro:
001ae2 91e0 2882                 	lds ZL, pulse2_hi_pitch_macro
001ae4 91f0 2883                 	lds ZH, pulse2_hi_pitch_macro+1
001ae6 9630                      	adiw Z, 0
001ae7 f009                      	breq sound_driver_channel1_fx_Qxy_process
001ae8 cf1e                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_process:
001ae9 2fba                      	mov r27, r26 //copy fx parameters into r27
001aea 70bf                      	andi r27, 0x0F //mask note index offset
001aeb 91c0 280f                 	lds r28, pulse2_note //load current note index
001aed 0fbc                      	add r27, r28
001aee 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001aef f008                      	brlo sound_driver_channel1_fx_Qxy_process_continue
001af0 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel1_fx_Qxy_process_continue:
001af1 e6e8                      	ldi ZL, LOW(note_table << 1) //load in note table
001af2 e0f0                      	ldi ZH, HIGH(note_table << 1)
001af3 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001af4 0feb                      	add ZL, r27 //add offset
001af5 1df2                      	adc ZH, zero
001af6 91c5                      	lpm r28, Z+ //load bytes
001af7 91d4                      	lpm r29, Z
001af8 93c0 28a9                 	sts pulse2_fx_Qxy_target, r28 //load the LOW bits for the target period
001afa 93d0 28aa                 	sts pulse2_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
001afc 95a2                      	swap r26
001afd 70af                      	andi r26, 0x0F //mask effect speed
001afe 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001aff 95a3                      	inc r26 //increment the speed by 1
                                 
001b00 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001b01 937f                      	push r23
001b02 2f6a                      	mov r22, r26 //store the speed data into r27
001b03 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001b04 9f67                      	mul r22, r23
001b05 917f                      	pop r23
001b06 916f                      	pop r22
                                 
001b07 9416                      	lsr r1 //shift out the fractional bits
001b08 9407                      	ror r0
001b09 9416                      	lsr r1
001b0a 9407                      	ror r0
001b0b 9416                      	lsr r1
001b0c 9407                      	ror r0
001b0d 9416                      	lsr r1
001b0e 9407                      	ror r0
                                 
001b0f 9200 28ab                 	sts pulse2_fx_Qxy_speed, r0 //store the effect speed
001b11 9210 28ac                 	sts pulse2_fx_Qxy_speed+1, r1
001b13 9220 28ad                 	sts pulse2_fx_Qxy_total_offset, zero
001b15 9220 28ae                 	sts pulse2_fx_Qxy_total_offset+1, zero
001b17 ceef                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel1_fx_Rxy:
                                 sound_driver_channel1_fx_Rxy_check_arpeggio_macro:
001b18 91e0 2875                 	lds ZL, pulse2_arpeggio_macro
001b1a 91f0 2876                 	lds ZH, pulse2_arpeggio_macro+1
001b1c 9630                      	adiw Z, 0
001b1d f009                      	breq sound_driver_channel1_fx_Rxy_check_pitch_macro
001b1e cee8                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_pitch_macro:
001b1f 91e0 287c                 	lds ZL, pulse2_pitch_macro
001b21 91f0 287d                 	lds ZH, pulse2_pitch_macro+1
001b23 9630                      	adiw Z, 0
001b24 f009                      	breq sound_driver_channel1_fx_Rxy_check_hi_pitch_macro
001b25 cee1                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_hi_pitch_macro:
001b26 91e0 2882                 	lds ZL, pulse2_hi_pitch_macro
001b28 91f0 2883                 	lds ZH, pulse2_hi_pitch_macro+1
001b2a 9630                      	adiw Z, 0
001b2b f009                      	breq sound_driver_channel1_fx_Rxy_process
001b2c ceda                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_process:
001b2d 2fba                      	mov r27, r26 //copy fx parameters into r27
001b2e 70bf                      	andi r27, 0x0F //mask note index offset
001b2f 91c0 280f                 	lds r28, pulse2_note //load current note index
001b31 1bcb                      	sub r28, r27
001b32 f408                      	brcc sound_driver_channel1_fx_Rxy_process_continue
001b33 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel1_fx_Rxy_process_continue:
001b34 e6e8                      	ldi ZL, LOW(note_table << 1) //load in note table
001b35 e0f0                      	ldi ZH, HIGH(note_table << 1)
001b36 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001b37 0fec                      	add ZL, r28 //add offset
001b38 1df2                      	adc ZH, zero
001b39 91c5                      	lpm r28, Z+ //load bytes
001b3a 91d4                      	lpm r29, Z
001b3b 93c0 28af                 	sts pulse2_fx_Rxy_target, r28 //load the LOW bits for the target period
001b3d 93d0 28b0                 	sts pulse2_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
001b3f 95a2                      	swap r26
001b40 70af                      	andi r26, 0x0F //mask effect speed
001b41 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001b42 95a3                      	inc r26 //increment the speed by 1
                                 
001b43 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001b44 937f                      	push r23
001b45 2f6a                      	mov r22, r26 //store the speed data into r27
001b46 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001b47 9f67                      	mul r22, r23
001b48 917f                      	pop r23
001b49 916f                      	pop r22
                                 
001b4a 9416                      	lsr r1 //shift out the fractional bits
001b4b 9407                      	ror r0
001b4c 9416                      	lsr r1
001b4d 9407                      	ror r0
001b4e 9416                      	lsr r1
001b4f 9407                      	ror r0
001b50 9416                      	lsr r1
001b51 9407                      	ror r0
                                 
001b52 9200 28b1                 	sts pulse2_fx_Rxy_speed, r0 //store the effect speed
001b54 9210 28b2                 	sts pulse2_fx_Rxy_speed+1, r1
001b56 9220 28b3                 	sts pulse2_fx_Rxy_total_offset, zero
001b58 9220 28b4                 	sts pulse2_fx_Rxy_total_offset+1, zero
001b5a ceac                      	rjmp sound_driver_channel1_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel1_fx_Sxx:
001b5b 15a2                      	cp r26, zero
001b5c f051                      	breq sound_driver_channel1_fx_Sxx_invalid
001b5d 91b0 2819                 	lds r27, song_speed
001b5f 17ab                      	cp r26, r27
001b60 f430                      	brsh sound_driver_channel1_fx_Sxx_invalid
001b61 93a0 28b5                 	sts pulse2_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001b63 e0b1                      	ldi r27, 0x01
001b64 93b0 286c                 	sts pulse2_pattern_delay_rows, r27
001b66 c161                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Sxx_invalid:
001b67 ce9f                      	rjmp sound_driver_channel1_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel1_fx_Vxx:
001b68 ece6                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
001b69 e5f3                      	ldi ZH, HIGH(sequences << 1)
001b6a 0fea                      	add ZL, r26 //offset the pointer
001b6b 1df2                      	adc ZH, zero
                                 
001b6c 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
001b6d 95a7                      	ror r26
001b6e 95a7                      	ror r26
001b6f 91b0 2808                 	lds r27, pulse2_param //load r27 with pulse2_param (register $4000)
001b71 2fcb                      	mov r28, r27 //store a copy of pulse2_param into r28
001b72 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
001b73 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
001b74 c001                      	rjmp sound_driver_channel1_fx_Vxx_store
001b75 ce91                      	rjmp sound_driver_channel1_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel1_fx_Vxx_store:
001b76 90d4                      	lpm pulse2_sequence, Z //store the sequence
                                 
001b77 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
001b78 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
001b79 93c0 2808                 	sts pulse2_param, r28
001b7b ce8b                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_Wxx: //DPCM sample speed
001b7c ce8a                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Xxx: //DPCM sample retrigger
001b7d ce89                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Yxx: //DPCM sample offset
001b7e ce88                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Zxx: //DPCM sample delta counter
001b7f ce87                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 sound_driver_channel1_note:
001b80 93b0 280f                 	sts pulse2_note, r27 //store the note index
001b82 e0a3                      	ldi r26, 0x03
001b83 e0b2                      	ldi r27, 0x02
001b84 93b0 2872                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
001b86 93a0 2877                 	sts pulse2_arpeggio_macro_offset, r26
001b88 93b0 287e                 	sts pulse2_pitch_macro_offset, r27
001b8a 93b0 2884                 	sts pulse2_hi_pitch_macro_offset, r27
001b8c 93b0 2889                 	sts pulse2_duty_macro_offset, r27
001b8e 9220 287b                 	sts pulse2_total_pitch_offset, zero //reset the pitch and hi pitch offset
001b90 9220 2881                 	sts pulse2_total_hi_pitch_offset, zero
001b92 9220 2890                 	sts pulse2_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001b94 9220 2891                 	sts pulse2_fx_1xx_total+1, zero
001b96 9220 2894                 	sts pulse2_fx_2xx_total, zero
001b98 9220 2895                 	sts pulse2_fx_2xx_total+1, zero
001b9a 9220 289c                 	sts pulse2_fx_3xx_total_offset, zero //reset 3xx offset
001b9c 9220 289d                 	sts pulse2_fx_3xx_total_offset+1, zero
001b9e 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001ba0 91b0 0a9d                 	lds r27, TCB1_CCMPH
001ba2 93a0 2896                 	sts pulse2_fx_3xx_start, r26
001ba4 93b0 2897                 	sts pulse2_fx_3xx_start+1, r27
001ba6 9220 2809                 	sts pulse2_sweep_param, zero //reset any sweep effect
001ba8 6093                      	sbr pulse_channel_flags, 3 //set reload flag
001ba9 9220 28a9                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001bab 9220 28aa                 	sts pulse2_fx_Qxy_target+1, zero
001bad 9220 28ad                 	sts pulse2_fx_Qxy_total_offset, zero
001baf 9220 28ae                 	sts pulse2_fx_Qxy_total_offset+1, zero
001bb1 9220 28af                 	sts pulse2_fx_Rxy_target, zero
001bb3 9220 28b0                 	sts pulse2_fx_Rxy_target+1, zero
001bb5 9220 28b3                 	sts pulse2_fx_Rxy_total_offset, zero
001bb7 9220 28b4                 	sts pulse2_fx_Rxy_total_offset+1, zero
001bb9 d0f7                      	rcall sound_driver_channel1_increment_offset
001bba ce4c                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_volume:
001bbb 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001bbc 91a0 2808                 	lds r26, pulse2_param
001bbe 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001bbf 2bab                      	or r26, r27 //move new VVVV bits into pulse2_param
001bc0 93a0 2808                 	sts pulse2_param, r26
001bc2 6092                      	sbr pulse_channel_flags, 2
001bc3 d0ed                      	rcall sound_driver_channel1_increment_offset
001bc4 ce42                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_delay:
001bc5 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001bc6 93b0 286c                 	sts pulse2_pattern_delay_rows, r27
001bc8 d0e8                      	rcall sound_driver_channel1_increment_offset
001bc9 c0fe                      	rjmp sound_driver_channel2
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change:
001bca 9220 2870                 	sts pulse2_volume_macro, zero //reset all macro addresses
001bcc 9220 2871                 	sts pulse2_volume_macro+1, zero
001bce 9220 2875                 	sts pulse2_arpeggio_macro, zero
001bd0 9220 2876                 	sts pulse2_arpeggio_macro+1, zero
001bd2 9220 287c                 	sts pulse2_pitch_macro, zero
001bd4 9220 287d                 	sts pulse2_pitch_macro+1, zero
001bd6 9220 2882                 	sts pulse2_hi_pitch_macro, zero
001bd8 9220 2883                 	sts pulse2_hi_pitch_macro+1, zero
001bda 9220 2887                 	sts pulse2_duty_macro, zero
001bdc 9220 2888                 	sts pulse2_duty_macro+1, zero
001bde 9220 287b                 	sts pulse2_total_pitch_offset, zero //reset the pitch offset
001be0 9220 2881                 	sts pulse2_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001be2 9631                      	adiw Z, 1 //point to the byte next to the flag
001be3 91b4                      	lpm r27, Z //store the instrument offset into r27
001be4 e6ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
001be5 e1f0                      	ldi ZH, HIGH(instruments)
001be6 0feb                      	add ZL, r27 //point Z to offsetted instrument
001be7 1df2                      	adc ZH, zero
001be8 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001be9 1fff                      	rol ZH
001bea 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001beb 91b4                      	lpm r27, Z
                                 
001bec 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001bed 1fbb                      	rol r27
001bee 2fea                      	mov ZL, r26
001bef 2ffb                      	mov ZH, r27
001bf0 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001bf1 9632                      	adiw Z, 2 //point Z to the address of the macro
001bf2 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel1_instrument_change_macro_loop:
001bf3 95aa                      	dec r26
001bf4 f019                      	breq sound_driver_channel1_instrument_change_exit
001bf5 95b6                      	lsr r27
001bf6 f078                      	brcs sound_driver_channel1_instrument_change_load_macro
001bf7 cffb                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_exit:
001bf8 e0a3                      	ldi r26, 0x03
001bf9 e0b2                      	ldi r27, 0x02
001bfa 93b0 2872                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
001bfc 93a0 2877                 	sts pulse2_arpeggio_macro_offset, r26
001bfe 93b0 287e                 	sts pulse2_pitch_macro_offset, r27
001c00 93b0 2884                 	sts pulse2_hi_pitch_macro_offset, r27
001c02 93b0 2889                 	sts pulse2_duty_macro_offset, r27
001c04 d0b6                      	rcall sound_driver_channel1_increment_offset_twice
001c05 ce01                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_load_macro:
001c06 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001c07 91d5                      	lpm r29, Z+
                                 
001c08 30a5                      	cpi r26, 5
001c09 f039                      	breq sound_driver_channel1_instrument_change_load_macro_volume
001c0a 30a4                      	cpi r26, 4
001c0b f079                      	breq sound_driver_channel1_instrument_change_load_macro_arpeggio
001c0c 30a3                      	cpi r26, 3
001c0d f0d9                      	breq sound_driver_channel1_instrument_change_load_macro_pitch
001c0e 30a2                      	cpi r26, 2
001c0f f159                      	breq sound_driver_channel1_instrument_change_load_macro_hi_pitch
001c10 c03c                      	rjmp sound_driver_channel1_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel1_instrument_change_load_macro_volume:
001c11 93c0 2870                 	sts pulse2_volume_macro, r28
001c13 93d0 2871                 	sts pulse2_volume_macro+1, r29
001c15 d041                      	rcall sound_driver_channel1_instrument_change_read_header
001c16 93c0 2874                 	sts pulse2_volume_macro_release, r28
001c18 93d0 2873                 	sts pulse2_volume_macro_loop, r29
001c1a cfd8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 	
                                 sound_driver_channel1_instrument_change_load_macro_arpeggio:
001c1b 93c0 2875                 	sts pulse2_arpeggio_macro, r28
001c1d 93d0 2876                 	sts pulse2_arpeggio_macro+1, r29
001c1f 9220 28a9                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001c21 9220 28aa                 	sts pulse2_fx_Qxy_target+1, zero
001c23 9220 28af                 	sts pulse2_fx_Rxy_target, zero
001c25 9220 28b0                 	sts pulse2_fx_Rxy_target+1, zero
001c27 d03a                      	rcall sound_driver_channel1_instrument_change_read_header_arpeggio
001c28 cfca                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_pitch:
001c29 93c0 287c                 	sts pulse2_pitch_macro, r28
001c2b 93d0 287d                 	sts pulse2_pitch_macro+1, r29
001c2d 9220 28a9                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001c2f 9220 28aa                 	sts pulse2_fx_Qxy_target+1, zero
001c31 9220 28af                 	sts pulse2_fx_Rxy_target, zero
001c33 9220 28b0                 	sts pulse2_fx_Rxy_target+1, zero
001c35 d021                      	rcall sound_driver_channel1_instrument_change_read_header
001c36 93c0 2880                 	sts pulse2_pitch_macro_release, r28
001c38 93d0 287f                 	sts pulse2_pitch_macro_loop, r29
001c3a cfb8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_hi_pitch:
001c3b 93c0 2882                 	sts pulse2_hi_pitch_macro, r28
001c3d 93d0 2883                 	sts pulse2_hi_pitch_macro+1, r29
001c3f 9220 28a9                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001c41 9220 28aa                 	sts pulse2_fx_Qxy_target+1, zero
001c43 9220 28af                 	sts pulse2_fx_Rxy_target, zero
001c45 9220 28b0                 	sts pulse2_fx_Rxy_target+1, zero
001c47 d00f                      	rcall sound_driver_channel1_instrument_change_read_header
001c48 93c0 2886                 	sts pulse2_hi_pitch_macro_release, r28
001c4a 93d0 2885                 	sts pulse2_hi_pitch_macro_loop, r29
001c4c cfa6                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_duty:
001c4d 93c0 2887                 	sts pulse2_duty_macro, r28
001c4f 93d0 2888                 	sts pulse2_duty_macro+1, r29
001c51 d005                      	rcall sound_driver_channel1_instrument_change_read_header
001c52 93c0 288b                 	sts pulse2_duty_macro_release, r28
001c54 93d0 288a                 	sts pulse2_duty_macro_loop, r29
001c56 cf9c                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_read_header:
001c57 93ef                      	push ZL
001c58 93ff                      	push ZH
001c59 2fec                      	mov ZL, r28
001c5a 2ffd                      	mov ZH, r29
001c5b 0fee                      	lsl ZL
001c5c 1fff                      	rol ZH
001c5d 91c5                      	lpm r28, Z+
001c5e 91d4                      	lpm r29, Z
001c5f 91ff                      	pop ZH
001c60 91ef                      	pop ZL
001c61 9508                      	ret
                                 
                                 sound_driver_channel1_instrument_change_read_header_arpeggio:
001c62 93ef                      	push ZL
001c63 93ff                      	push ZH
001c64 2fec                      	mov ZL, r28
001c65 2ffd                      	mov ZH, r29
001c66 0fee                      	lsl ZL
001c67 1fff                      	rol ZH
001c68 91c5                      	lpm r28, Z+
001c69 91d5                      	lpm r29, Z+
001c6a 93c0 2879                 	sts pulse2_arpeggio_macro_release, r28
001c6c 93d0 2878                 	sts pulse2_arpeggio_macro_loop, r29
001c6e 91c4                      	lpm r28, Z
001c6f 93c0 287a                 	sts pulse2_arpeggio_macro_mode, r28
001c71 91ff                      	pop ZH
001c72 91ef                      	pop ZL
001c73 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel1_release:
                                 sound_driver_channel1_release_volume:
001c74 91b0 2874                 	lds r27, pulse2_volume_macro_release
001c76 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001c77 f019                      	breq sound_driver_channel1_release_arpeggio //if the macro has no release flag, check the next macro
001c78 95b3                      	inc r27
001c79 93b0 2872                 	sts pulse2_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel1_release_arpeggio:
001c7b 91b0 2879                 	lds r27, pulse2_arpeggio_macro_release
001c7d 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001c7e f019                      	breq sound_driver_channel1_release_pitch
001c7f 95b3                      	inc r27
001c80 93b0 2877                 	sts pulse2_arpeggio_macro_offset, r27
                                 sound_driver_channel1_release_pitch:
001c82 91b0 2880                 	lds r27, pulse2_pitch_macro_release
001c84 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001c85 f019                      	breq sound_driver_channel1_release_hi_pitch
001c86 95b3                      	inc r27
001c87 93b0 287e                 	sts pulse2_pitch_macro_offset, r27
                                 sound_driver_channel1_release_hi_pitch:
001c89 91b0 2886                 	lds r27, pulse2_hi_pitch_macro_release
001c8b 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001c8c f019                      	breq sound_driver_channel1_release_duty
001c8d 95b3                      	inc r27
001c8e 93b0 2884                 	sts pulse2_hi_pitch_macro_offset, r27
                                 sound_driver_channel1_release_duty:
001c90 91b0 288b                 	lds r27, pulse2_duty_macro_release
001c92 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001c93 f019                      	breq sound_driver_channel1_release_exit
001c94 95b3                      	inc r27
001c95 93b0 2889                 	sts pulse2_duty_macro_offset, r27
                                 sound_driver_channel1_release_exit:
001c97 d019                      	rcall sound_driver_channel1_increment_offset
001c98 cd6e                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_next_pattern:
001c99 91e0 2813                 	lds ZL, song_frames
001c9b 91f0 2814                 	lds ZH, song_frames+1
001c9d 91a0 2815                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001c9f 91b0 2816                 	lds r27, song_frame_offset+1
001ca1 9612                      	adiw r27:r26, 2 //offset for channel 1
001ca2 0fea                      	add ZL, r26
001ca3 1ffb                      	adc ZH, r27
                                 
001ca4 91a5                      	lpm r26, Z+ //load the address of the next pattern
001ca5 91b4                      	lpm r27, Z
001ca6 0faa                      	lsl r26
001ca7 1fbb                      	rol r27
001ca8 93a0 286a                 	sts pulse2_pattern, r26
001caa 93b0 286b                 	sts pulse2_pattern+1, r27
                                 
001cac 9220 286e                 	sts pulse2_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001cae 9220 286f                 	sts pulse2_pattern_offset+1, zero
001cb0 cd56                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_increment_offset:
001cb1 91e0 286e                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001cb3 91f0 286f                 	lds ZH, pulse2_pattern_offset+1
001cb5 9631                      	adiw Z, 1
001cb6 93e0 286e                 	sts pulse2_pattern_offset, ZL
001cb8 93f0 286f                 	sts pulse2_pattern_offset+1, ZH
001cba 9508                      	ret
                                 
                                 sound_driver_channel1_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001cbb 91e0 286e                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001cbd 91f0 286f                 	lds ZH, pulse2_pattern_offset+1
001cbf 9632                      	adiw Z, 2 //increment the pointer twice
001cc0 93e0 286e                 	sts pulse2_pattern_offset, ZL
001cc2 93f0 286f                 	sts pulse2_pattern_offset+1, ZH
001cc4 9508                      	ret
                                 
                                 sound_driver_channel1_decrement_frame_delay:
001cc5 95ba                      	dec r27
001cc6 93b0 286d                 	sts pulse2_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel2:
001cc8 91a0 28b9                 	lds r26, triangle_pattern_delay_rows
001cca 91b0 28ba                 	lds r27, triangle_pattern_delay_frames
001ccc 9610                      	adiw r27:r26, 0
001ccd f009                      	breq sound_driver_channel2_main //if the pattern delay is 0, proceed with sound driver procedures
001cce c2a3                      	rjmp sound_driver_channel2_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel2_main:
001ccf 91e0 28b7                 	lds ZL, triangle_pattern //current pattern for triangle
001cd1 91f0 28b8                 	lds ZH, triangle_pattern+1
001cd3 91a0 28bb                 	lds r26, triangle_pattern_offset //current offset in the pattern for triangle
001cd5 91b0 28bc                 	lds r27, triangle_pattern_offset+1
001cd7 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001cd8 1ffb                      	adc ZH, r27
001cd9 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel2_check_if_note: //check if data is a note (0x00 - 0x56)
001cda 35b7                      	cpi r27, 0x57
001cdb f408                      	brsh sound_driver_channel2_check_if_volume
001cdc c14f                      	rjmp sound_driver_channel2_note
                                 sound_driver_channel2_check_if_volume: //check if data is volume (0x57-0x66)
001cdd 36b7                      	cpi r27, 0x67
001cde f408                      	brsh sound_driver_channel2_check_if_delay
001cdf c184                      	rjmp sound_driver_channel2_volume
                                 sound_driver_channel2_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001ce0 3eb3                      	cpi r27, 0xE3
001ce1 f408                      	brsh sound_driver_channel2_check_if_instrument
001ce2 c18f                      	rjmp sound_driver_channel2_delay
                                 sound_driver_channel2_check_if_instrument: //check for instrument flag (0xE3)
001ce3 f409                      	brne sound_driver_channel2_check_if_release
001ce4 c192                      	rjmp sound_driver_channel2_instrument_change 
                                 sound_driver_channel2_check_if_release: //check for note release flag (0xE4)
001ce5 3eb4                      	cpi r27, 0xE4
001ce6 f409                      	brne sound_driver_channel2_check_if_end
001ce7 c239                      	rjmp sound_driver_channel2_release
                                 sound_driver_channel2_check_if_end:
001ce8 3fbf                      	cpi r27, 0xFF
001ce9 f409                      	brne sound_driver_channel2_check_if_fx
001cea c25b                      	rjmp sound_driver_channel2_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel2_check_if_fx: //fx flags (0xE5 - 0xFE)
001ceb 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001cec 91a4                      	lpm r26, Z //load the fx data into r26
001ced d27a                      	rcall sound_driver_channel2_increment_offset_twice
                                 
001cee 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001cef e3e2                      	ldi ZL, LOW(channel2_fx << 1) //load in note table
001cf0 e5f4                      	ldi ZH, HIGH(channel2_fx << 1)
001cf1 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001cf2 0feb                      	add ZL, r27 //add offset
001cf3 1df2                      	adc ZH, zero
001cf4 91c5                      	lpm r28, Z+ //load address bytes
001cf5 91d4                      	lpm r29, Z
001cf6 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001cf7 2ffd                      	mov ZH, r29
001cf8 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel2_fx_0xy:
001cf9 93a0 28d9                 	sts triangle_fx_0xy_sequence, r26
001cfb 9220 28da                 	sts triangle_fx_0xy_sequence+1, zero
001cfd cfd1                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel2_fx_1xx:
001cfe 9220 28df                 	sts triangle_fx_2xx, zero //turn off any 2xx pitch slide down
001d00 9220 28e0                 	sts triangle_fx_2xx+1, zero
001d02 9220 28d9                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001d04 9220 28da                 	sts triangle_fx_0xy_sequence+1, zero
001d06 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001d07 937f                      	push r23
001d08 2f6a                      	mov r22, r26 //store the rate into r22
001d09 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001d0a 9f67                      	mul r22, r23
001d0b 917f                      	pop r23
001d0c 916f                      	pop r22
                                 
001d0d 9416                      	lsr r1 //shift out the fractional bits
001d0e 9407                      	ror r0
001d0f 9416                      	lsr r1
001d10 9407                      	ror r0
001d11 9416                      	lsr r1
001d12 9407                      	ror r0
001d13 9416                      	lsr r1
001d14 9407                      	ror r0
001d15 9200 28db                 	sts triangle_fx_1xx, r0
001d17 9210 28dc                 	sts triangle_fx_1xx+1, r1
001d19 cfb5                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel2_fx_2xx:
001d1a 9220 28db                 	sts triangle_fx_1xx, zero //turn off any 1xx pitch slide down
001d1c 9220 28dc                 	sts triangle_fx_1xx+1, zero
001d1e 9220 28d9                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001d20 9220 28da                 	sts triangle_fx_0xy_sequence+1, zero
001d22 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001d23 937f                      	push r23
001d24 2f6a                      	mov r22, r26 //store the rate into r22
001d25 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001d26 9f67                      	mul r22, r23
001d27 917f                      	pop r23
001d28 916f                      	pop r22
                                 
001d29 9416                      	lsr r1 //shift out the fractional bits
001d2a 9407                      	ror r0
001d2b 9416                      	lsr r1
001d2c 9407                      	ror r0
001d2d 9416                      	lsr r1
001d2e 9407                      	ror r0
001d2f 9416                      	lsr r1
001d30 9407                      	ror r0
001d31 9200 28df                 	sts triangle_fx_2xx, r0
001d33 9210 28e0                 	sts triangle_fx_2xx+1, r1
001d35 cf99                      	rjmp sound_driver_channel2_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel2_fx_3xx:
001d36 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001d37 937f                      	push r23
001d38 2f6a                      	mov r22, r26 //store the rate into r22
001d39 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001d3a 9f67                      	mul r22, r23
001d3b 917f                      	pop r23
001d3c 916f                      	pop r22
                                 
001d3d 9416                      	lsr r1 //shift out the fractional bits
001d3e 9407                      	ror r0
001d3f 9416                      	lsr r1
001d40 9407                      	ror r0
001d41 9416                      	lsr r1
001d42 9407                      	ror r0
001d43 9416                      	lsr r1
001d44 9407                      	ror r0
001d45 9200 28e7                 	sts triangle_fx_3xx_speed, r0
001d47 9210 28e8                 	sts triangle_fx_3xx_speed+1, r1
                                 
001d49 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001d4a c001                      	rjmp sound_driver_channel2_fx_3xx_enabled
001d4b cf83                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_3xx_enabled:
001d4c 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001d4e 91b0 0aad                 	lds r27, TCB2_CCMPH
001d50 93a0 28e3                 	sts triangle_fx_3xx_start, r26
001d52 93b0 28e4                 	sts triangle_fx_3xx_start+1, r27
                                 
001d54 9220 28e9                 	sts triangle_fx_3xx_total_offset, zero
001d56 9220 28ea                 	sts triangle_fx_3xx_total_offset+1, zero
001d58 cf76                      	rjmp sound_driver_channel2_main
                                 
                                 //VIBRATO
                                 sound_driver_channel2_fx_4xy:
001d59 2fba                      	mov r27, r26
001d5a 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001d5b 95a2                      	swap r26
001d5c 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001d5d 93a0 28eb                 	sts triangle_fx_4xy_speed, r26
001d5f 93b0 28ec                 	sts triangle_fx_4xy_depth, r27
001d61 9220 28ed                 	sts triangle_fx_4xy_phase, zero //reset the phase to 0
001d63 cf6b                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_7xy: //tremelo
001d64 cf6a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Axy: //volume slide
001d65 cf69                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel2_fx_Bxx:
001d66 93a0 281a                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001d68 cf66                      	rjmp sound_driver_channel2_main
                                 
                                 //HALT
                                 sound_driver_channel2_fx_Cxx:
001d69 93b0 281b                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001d6b cf63                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel2_fx_Dxx:
001d6c 93b0 281c                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001d6e cf60                      	rjmp sound_driver_channel2_main
                                 
                                 //VOLUME
                                 sound_driver_channel2_fx_Exx:
001d6f 15a2                      	cp r26, zero
001d70 f021                      	breq sound_driver_channel2_fx_Exx_disable
                                 sound_driver_channel2_fx_Exx_enable:
001d71 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001d72 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001d74 cf5a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Exx_disable:
001d75 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
001d77 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
001d79 9220 0aad                 	sts TCB2_CCMPH, zero
001d7b cf53                      	rjmp sound_driver_channel2_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel2_fx_Fxx:
001d7c 93a0 2819                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001d7e cf50                      	rjmp sound_driver_channel2_main
                                 
                                 //DELAY
                                 sound_driver_channel2_fx_Gxx:
001d7f 15a2                      	cp r26, zero
001d80 f051                      	breq sound_driver_channel2_fx_Gxx_invalid
001d81 91b0 2819                 	lds r27, song_speed
001d83 17ab                      	cp r26, r27
001d84 f430                      	brsh sound_driver_channel2_fx_Gxx_invalid
001d85 93a0 28ee                 	sts triangle_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001d87 e0b1                      	ldi r27, 0x01
001d88 93b0 28b9                 	sts triangle_pattern_delay_rows, r27
001d8a c1ea                      	rjmp sound_driver_calculate_delays
                                 sound_driver_channel2_fx_Gxx_invalid:
001d8b cf43                      	rjmp sound_driver_channel2_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Hxy: //hardware sweep up
001d8c cf42                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixy: //hardware sweep down
001d8d cf41                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Hxx: //FDS modulation depth
001d8e cf40                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixx: //FDS modulation speed
001d8f cf3f                      	rjmp sound_driver_channel2_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel2_fx_Pxx:
001d90 93a0 28f0                 	sts triangle_fx_Pxx, r26
001d92 cf3c                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel2_fx_Qxy:
                                 sound_driver_channel2_fx_Qxy_check_arpeggio_macro:
001d93 91e0 28c2                 	lds ZL, triangle_arpeggio_macro
001d95 91f0 28c3                 	lds ZH, triangle_arpeggio_macro+1
001d97 9630                      	adiw Z, 0
001d98 f009                      	breq sound_driver_channel2_fx_Qxy_check_pitch_macro
001d99 cf35                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_pitch_macro:
001d9a 91e0 28c9                 	lds ZL, triangle_pitch_macro
001d9c 91f0 28ca                 	lds ZH, triangle_pitch_macro+1
001d9e 9630                      	adiw Z, 0
001d9f f009                      	breq sound_driver_channel2_fx_Qxy_check_hi_pitch_macro
001da0 cf2e                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_hi_pitch_macro:
001da1 91e0 28cf                 	lds ZL, triangle_hi_pitch_macro
001da3 91f0 28d0                 	lds ZH, triangle_hi_pitch_macro+1
001da5 9630                      	adiw Z, 0
001da6 f009                      	breq sound_driver_channel2_fx_Qxy_process
001da7 cf27                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_process:
001da8 2fba                      	mov r27, r26 //copy fx parameters into r27
001da9 70bf                      	andi r27, 0x0F //mask note index offset
001daa 91c0 2812                 	lds r28, triangle_note //load current note index
001dac 0fbc                      	add r27, r28
001dad 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001dae f008                      	brlo sound_driver_channel2_fx_Qxy_process_continue
001daf e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel2_fx_Qxy_process_continue:
001db0 e6e8                      	ldi ZL, LOW(note_table << 1) //load in note table
001db1 e0f0                      	ldi ZH, HIGH(note_table << 1)
001db2 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001db3 0feb                      	add ZL, r27 //add offset
001db4 1df2                      	adc ZH, zero
001db5 91c5                      	lpm r28, Z+ //load bytes
001db6 91d4                      	lpm r29, Z
001db7 93c0 28f1                 	sts triangle_fx_Qxy_target, r28 //load the LOW bits for the target period
001db9 93d0 28f2                 	sts triangle_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
001dbb 95a2                      	swap r26
001dbc 70af                      	andi r26, 0x0F //mask effect speed
001dbd 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001dbe 95a3                      	inc r26 //increment the speed by 1
                                 
001dbf 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001dc0 937f                      	push r23
001dc1 2f6a                      	mov r22, r26 //store the speed data into r27
001dc2 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001dc3 9f67                      	mul r22, r23
001dc4 917f                      	pop r23
001dc5 916f                      	pop r22
                                 
001dc6 9416                      	lsr r1 //shift out the fractional bits
001dc7 9407                      	ror r0
001dc8 9416                      	lsr r1
001dc9 9407                      	ror r0
001dca 9416                      	lsr r1
001dcb 9407                      	ror r0
001dcc 9416                      	lsr r1
001dcd 9407                      	ror r0
                                 
001dce 9200 28f3                 	sts triangle_fx_Qxy_speed, r0 //store the effect speed
001dd0 9210 28f4                 	sts triangle_fx_Qxy_speed+1, r1
001dd2 9220 28f5                 	sts triangle_fx_Qxy_total_offset, zero
001dd4 9220 28f6                 	sts triangle_fx_Qxy_total_offset+1, zero
001dd6 cef8                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel2_fx_Rxy:
                                 sound_driver_channel2_fx_Rxy_check_arpeggio_macro:
001dd7 91e0 28c2                 	lds ZL, triangle_arpeggio_macro
001dd9 91f0 28c3                 	lds ZH, triangle_arpeggio_macro+1
001ddb 9630                      	adiw Z, 0
001ddc f009                      	breq sound_driver_channel2_fx_Rxy_check_pitch_macro
001ddd cef1                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_pitch_macro:
001dde 91e0 28c9                 	lds ZL, triangle_pitch_macro
001de0 91f0 28ca                 	lds ZH, triangle_pitch_macro+1
001de2 9630                      	adiw Z, 0
001de3 f009                      	breq sound_driver_channel2_fx_Rxy_check_hi_pitch_macro
001de4 ceea                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_hi_pitch_macro:
001de5 91e0 28cf                 	lds ZL, triangle_hi_pitch_macro
001de7 91f0 28d0                 	lds ZH, triangle_hi_pitch_macro+1
001de9 9630                      	adiw Z, 0
001dea f009                      	breq sound_driver_channel2_fx_Rxy_process
001deb cee3                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_process:
001dec 2fba                      	mov r27, r26 //copy fx parameters into r27
001ded 70bf                      	andi r27, 0x0F //mask note index offset
001dee 91c0 2812                 	lds r28, triangle_note //load current note index
001df0 1bcb                      	sub r28, r27
001df1 f408                      	brcc sound_driver_channel2_fx_Rxy_process_continue
001df2 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel2_fx_Rxy_process_continue:
001df3 e6e8                      	ldi ZL, LOW(note_table << 1) //load in note table
001df4 e0f0                      	ldi ZH, HIGH(note_table << 1)
001df5 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001df6 0fec                      	add ZL, r28 //add offset
001df7 1df2                      	adc ZH, zero
001df8 91c5                      	lpm r28, Z+ //load bytes
001df9 91d4                      	lpm r29, Z
001dfa 93c0 28f7                 	sts triangle_fx_Rxy_target, r28 //load the LOW bits for the target period
001dfc 93d0 28f8                 	sts triangle_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
001dfe 95a2                      	swap r26
001dff 70af                      	andi r26, 0x0F //mask effect speed
001e00 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001e01 95a3                      	inc r26 //increment the speed by 1
                                 
001e02 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001e03 937f                      	push r23
001e04 2f6a                      	mov r22, r26 //store the speed data into r27
001e05 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001e06 9f67                      	mul r22, r23
001e07 917f                      	pop r23
001e08 916f                      	pop r22
                                 
001e09 9416                      	lsr r1 //shift out the fractional bits
001e0a 9407                      	ror r0
001e0b 9416                      	lsr r1
001e0c 9407                      	ror r0
001e0d 9416                      	lsr r1
001e0e 9407                      	ror r0
001e0f 9416                      	lsr r1
001e10 9407                      	ror r0
                                 
001e11 9200 28f9                 	sts triangle_fx_Rxy_speed, r0 //store the effect speed
001e13 9210 28fa                 	sts triangle_fx_Rxy_speed+1, r1
001e15 9220 28fb                 	sts triangle_fx_Rxy_total_offset, zero
001e17 9220 28fc                 	sts triangle_fx_Rxy_total_offset+1, zero
001e19 ceb5                      	rjmp sound_driver_channel2_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel2_fx_Sxx:
001e1a 15a2                      	cp r26, zero
001e1b f051                      	breq sound_driver_channel2_fx_Sxx_invalid
001e1c 91b0 2819                 	lds r27, song_speed
001e1e 17ab                      	cp r26, r27
001e1f f430                      	brsh sound_driver_channel2_fx_Sxx_invalid
001e20 93a0 28fd                 	sts triangle_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001e22 e0b1                      	ldi r27, 0x01
001e23 93b0 28b9                 	sts triangle_pattern_delay_rows, r27
001e25 c14f                      	rjmp sound_driver_calculate_delays
                                 sound_driver_channel2_fx_Sxx_invalid:
001e26 cea8                      	rjmp sound_driver_channel2_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Vxx: //duty
001e27 cea7                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Wxx: //DPCM sample speed
001e28 cea6                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Xxx: //DPCM sample retrigger
001e29 cea5                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Yxx: //DPCM sample offset
001e2a cea4                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Zxx: //DPCM sample delta counter
001e2b cea3                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 sound_driver_channel2_note:
001e2c 93b0 2812                 	sts triangle_note, r27 //store the note index
001e2e e0a3                      	ldi r26, 0x03
001e2f e0b2                      	ldi r27, 0x02
001e30 93b0 28bf                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
001e32 93a0 28c4                 	sts triangle_arpeggio_macro_offset, r26
001e34 93b0 28cb                 	sts triangle_pitch_macro_offset, r27
001e36 93b0 28d1                 	sts triangle_hi_pitch_macro_offset, r27
001e38 93b0 28d6                 	sts triangle_duty_macro_offset, r27
001e3a 9220 28c8                 	sts triangle_total_pitch_offset, zero //reset the pitch and hi pitch offset
001e3c 9220 28ce                 	sts triangle_total_hi_pitch_offset, zero
001e3e 9220 28dd                 	sts triangle_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001e40 9220 28de                 	sts triangle_fx_1xx_total+1, zero
001e42 9220 28e1                 	sts triangle_fx_2xx_total, zero
001e44 9220 28e2                 	sts triangle_fx_2xx_total+1, zero
001e46 9220 28e9                 	sts triangle_fx_3xx_total_offset, zero //reset 3xx offset
001e48 9220 28ea                 	sts triangle_fx_3xx_total_offset+1, zero
001e4a 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001e4c 91b0 0aad                 	lds r27, TCB2_CCMPH
001e4e 93a0 28e3                 	sts triangle_fx_3xx_start, r26
001e50 93b0 28e4                 	sts triangle_fx_3xx_start+1, r27
001e52 9220 28f1                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001e54 9220 28f2                 	sts triangle_fx_Qxy_target+1, zero
001e56 9220 28f5                 	sts triangle_fx_Qxy_total_offset, zero
001e58 9220 28f6                 	sts triangle_fx_Qxy_total_offset+1, zero
001e5a 9220 28f7                 	sts triangle_fx_Rxy_target, zero
001e5c 9220 28f8                 	sts triangle_fx_Rxy_target+1, zero
001e5e 9220 28fb                 	sts triangle_fx_Rxy_total_offset, zero
001e60 9220 28fc                 	sts triangle_fx_Rxy_total_offset+1, zero
001e62 d0fb                      	rcall sound_driver_channel2_increment_offset
001e63 ce6b                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_volume:
001e64 d0f9                      	rcall sound_driver_channel2_increment_offset
001e65 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001e66 f021                      	breq sound_driver_channel2_volume_disable
                                 sound_driver_channel2_volume_enable:
001e67 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001e68 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001e6a ce64                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_volume_disable:
001e6b 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
001e6d 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
001e6f 9220 0aad                 	sts TCB2_CCMPH, zero
001e71 ce5d                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_delay:
001e72 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001e73 93b0 28b9                 	sts triangle_pattern_delay_rows, r27
001e75 d0e8                      	rcall sound_driver_channel2_increment_offset
001e76 c0fe                      	rjmp sound_driver_calculate_delays
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change:
001e77 9220 28bd                 	sts triangle_volume_macro, zero //reset all macro addresses
001e79 9220 28be                 	sts triangle_volume_macro+1, zero
001e7b 9220 28c2                 	sts triangle_arpeggio_macro, zero
001e7d 9220 28c3                 	sts triangle_arpeggio_macro+1, zero
001e7f 9220 28c9                 	sts triangle_pitch_macro, zero
001e81 9220 28ca                 	sts triangle_pitch_macro+1, zero
001e83 9220 28cf                 	sts triangle_hi_pitch_macro, zero
001e85 9220 28d0                 	sts triangle_hi_pitch_macro+1, zero
001e87 9220 28d4                 	sts triangle_duty_macro, zero
001e89 9220 28d5                 	sts triangle_duty_macro+1, zero
001e8b 9220 28c8                 	sts triangle_total_pitch_offset, zero //reset the pitch offset
001e8d 9220 28ce                 	sts triangle_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001e8f 9631                      	adiw Z, 1 //point to the byte next to the flag
001e90 91b4                      	lpm r27, Z //store the instrument offset into r27
001e91 e6ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
001e92 e1f0                      	ldi ZH, HIGH(instruments)
001e93 0feb                      	add ZL, r27 //point Z to offsetted instrument
001e94 1df2                      	adc ZH, zero
001e95 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001e96 1fff                      	rol ZH
001e97 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001e98 91b4                      	lpm r27, Z
                                 
001e99 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001e9a 1fbb                      	rol r27
001e9b 2fea                      	mov ZL, r26
001e9c 2ffb                      	mov ZH, r27
001e9d 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001e9e 9632                      	adiw Z, 2 //point Z to the address of the macro
001e9f e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel2_instrument_change_macro_loop:
001ea0 95aa                      	dec r26
001ea1 f019                      	breq sound_driver_channel2_instrument_change_exit
001ea2 95b6                      	lsr r27
001ea3 f078                      	brcs sound_driver_channel2_instrument_change_load_macro
001ea4 cffb                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_exit:
001ea5 e0a3                      	ldi r26, 0x03
001ea6 e0b2                      	ldi r27, 0x02
001ea7 93b0 28bf                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
001ea9 93a0 28c4                 	sts triangle_arpeggio_macro_offset, r26
001eab 93b0 28cb                 	sts triangle_pitch_macro_offset, r27
001ead 93b0 28d1                 	sts triangle_hi_pitch_macro_offset, r27
001eaf 93b0 28d6                 	sts triangle_duty_macro_offset, r27
001eb1 d0b6                      	rcall sound_driver_channel2_increment_offset_twice
001eb2 ce1c                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_load_macro:
001eb3 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001eb4 91d5                      	lpm r29, Z+
                                 
001eb5 30a5                      	cpi r26, 5
001eb6 f039                      	breq sound_driver_channel2_instrument_change_load_macro_volume
001eb7 30a4                      	cpi r26, 4
001eb8 f079                      	breq sound_driver_channel2_instrument_change_load_macro_arpeggio
001eb9 30a3                      	cpi r26, 3
001eba f0d9                      	breq sound_driver_channel2_instrument_change_load_macro_pitch
001ebb 30a2                      	cpi r26, 2
001ebc f159                      	breq sound_driver_channel2_instrument_change_load_macro_hi_pitch
001ebd c03c                      	rjmp sound_driver_channel2_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel2_instrument_change_load_macro_volume:
001ebe 93c0 28bd                 	sts triangle_volume_macro, r28
001ec0 93d0 28be                 	sts triangle_volume_macro+1, r29
001ec2 d041                      	rcall sound_driver_channel2_instrument_change_read_header
001ec3 93c0 28c1                 	sts triangle_volume_macro_release, r28
001ec5 93d0 28c0                 	sts triangle_volume_macro_loop, r29
001ec7 cfd8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 	
                                 sound_driver_channel2_instrument_change_load_macro_arpeggio:
001ec8 93c0 28c2                 	sts triangle_arpeggio_macro, r28
001eca 93d0 28c3                 	sts triangle_arpeggio_macro+1, r29
001ecc 9220 28f1                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001ece 9220 28f2                 	sts triangle_fx_Qxy_target+1, zero
001ed0 9220 28f7                 	sts triangle_fx_Rxy_target, zero
001ed2 9220 28f8                 	sts triangle_fx_Rxy_target+1, zero
001ed4 d03a                      	rcall sound_driver_channel2_instrument_change_read_header_arpeggio
001ed5 cfca                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_pitch:
001ed6 93c0 28c9                 	sts triangle_pitch_macro, r28
001ed8 93d0 28ca                 	sts triangle_pitch_macro+1, r29
001eda 9220 28f1                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001edc 9220 28f2                 	sts triangle_fx_Qxy_target+1, zero
001ede 9220 28f7                 	sts triangle_fx_Rxy_target, zero
001ee0 9220 28f8                 	sts triangle_fx_Rxy_target+1, zero
001ee2 d021                      	rcall sound_driver_channel2_instrument_change_read_header
001ee3 93c0 28cd                 	sts triangle_pitch_macro_release, r28
001ee5 93d0 28cc                 	sts triangle_pitch_macro_loop, r29
001ee7 cfb8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_hi_pitch:
001ee8 93c0 28cf                 	sts triangle_hi_pitch_macro, r28
001eea 93d0 28d0                 	sts triangle_hi_pitch_macro+1, r29
001eec 9220 28f1                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001eee 9220 28f2                 	sts triangle_fx_Qxy_target+1, zero
001ef0 9220 28f7                 	sts triangle_fx_Rxy_target, zero
001ef2 9220 28f8                 	sts triangle_fx_Rxy_target+1, zero
001ef4 d00f                      	rcall sound_driver_channel2_instrument_change_read_header
001ef5 93c0 28d3                 	sts triangle_hi_pitch_macro_release, r28
001ef7 93d0 28d2                 	sts triangle_hi_pitch_macro_loop, r29
001ef9 cfa6                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_duty:
001efa 93c0 28d4                 	sts triangle_duty_macro, r28
001efc 93d0 28d5                 	sts triangle_duty_macro+1, r29
001efe d005                      	rcall sound_driver_channel2_instrument_change_read_header
001eff 93c0 28d8                 	sts triangle_duty_macro_release, r28
001f01 93d0 28d7                 	sts triangle_duty_macro_loop, r29
001f03 cf9c                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_read_header:
001f04 93ef                      	push ZL
001f05 93ff                      	push ZH
001f06 2fec                      	mov ZL, r28
001f07 2ffd                      	mov ZH, r29
001f08 0fee                      	lsl ZL
001f09 1fff                      	rol ZH
001f0a 91c5                      	lpm r28, Z+
001f0b 91d4                      	lpm r29, Z
001f0c 91ff                      	pop ZH
001f0d 91ef                      	pop ZL
001f0e 9508                      	ret
                                 
                                 sound_driver_channel2_instrument_change_read_header_arpeggio:
001f0f 93ef                      	push ZL
001f10 93ff                      	push ZH
001f11 2fec                      	mov ZL, r28
001f12 2ffd                      	mov ZH, r29
001f13 0fee                      	lsl ZL
001f14 1fff                      	rol ZH
001f15 91c5                      	lpm r28, Z+
001f16 91d5                      	lpm r29, Z+
001f17 93c0 28c6                 	sts triangle_arpeggio_macro_release, r28
001f19 93d0 28c5                 	sts triangle_arpeggio_macro_loop, r29
001f1b 91c4                      	lpm r28, Z
001f1c 93c0 28c7                 	sts triangle_arpeggio_macro_mode, r28
001f1e 91ff                      	pop ZH
001f1f 91ef                      	pop ZL
001f20 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel2_release:
                                 sound_driver_channel2_release_volume:
001f21 91b0 28c1                 	lds r27, triangle_volume_macro_release
001f23 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001f24 f019                      	breq sound_driver_channel2_release_arpeggio //if the macro has no release flag, check the next macro
001f25 95b3                      	inc r27
001f26 93b0 28bf                 	sts triangle_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel2_release_arpeggio:
001f28 91b0 28c6                 	lds r27, triangle_arpeggio_macro_release
001f2a 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001f2b f019                      	breq sound_driver_channel2_release_pitch
001f2c 95b3                      	inc r27
001f2d 93b0 28c4                 	sts triangle_arpeggio_macro_offset, r27
                                 sound_driver_channel2_release_pitch:
001f2f 91b0 28cd                 	lds r27, triangle_pitch_macro_release
001f31 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001f32 f019                      	breq sound_driver_channel2_release_hi_pitch
001f33 95b3                      	inc r27
001f34 93b0 28cb                 	sts triangle_pitch_macro_offset, r27
                                 sound_driver_channel2_release_hi_pitch:
001f36 91b0 28d3                 	lds r27, triangle_hi_pitch_macro_release
001f38 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001f39 f019                      	breq sound_driver_channel2_release_duty
001f3a 95b3                      	inc r27
001f3b 93b0 28d1                 	sts triangle_hi_pitch_macro_offset, r27
                                 sound_driver_channel2_release_duty:
001f3d 91b0 28d8                 	lds r27, triangle_duty_macro_release
001f3f 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001f40 f019                      	breq sound_driver_channel2_release_exit
001f41 95b3                      	inc r27
001f42 93b0 28d6                 	sts triangle_duty_macro_offset, r27
                                 sound_driver_channel2_release_exit:
001f44 d019                      	rcall sound_driver_channel2_increment_offset
001f45 cd89                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_next_pattern:
001f46 91e0 2813                 	lds ZL, song_frames
001f48 91f0 2814                 	lds ZH, song_frames+1
001f4a 91a0 2815                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001f4c 91b0 2816                 	lds r27, song_frame_offset+1
001f4e 9614                      	adiw r27:r26, 4 //offset for channel 2
001f4f 0fea                      	add ZL, r26
001f50 1ffb                      	adc ZH, r27
                                 
001f51 91a5                      	lpm r26, Z+ //load the address of the next pattern
001f52 91b4                      	lpm r27, Z
001f53 0faa                      	lsl r26
001f54 1fbb                      	rol r27
001f55 93a0 28b7                 	sts triangle_pattern, r26
001f57 93b0 28b8                 	sts triangle_pattern+1, r27
                                 
001f59 9220 28bb                 	sts triangle_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001f5b 9220 28bc                 	sts triangle_pattern_offset+1, zero
001f5d cd71                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_increment_offset:
001f5e 91e0 28bb                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
001f60 91f0 28bc                 	lds ZH, triangle_pattern_offset+1
001f62 9631                      	adiw Z, 1
001f63 93e0 28bb                 	sts triangle_pattern_offset, ZL
001f65 93f0 28bc                 	sts triangle_pattern_offset+1, ZH
001f67 9508                      	ret
                                 
                                 sound_driver_channel2_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001f68 91e0 28bb                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
001f6a 91f0 28bc                 	lds ZH, triangle_pattern_offset+1
001f6c 9632                      	adiw Z, 2 //increment the pointer twice
001f6d 93e0 28bb                 	sts triangle_pattern_offset, ZL
001f6f 93f0 28bc                 	sts triangle_pattern_offset+1, ZH
001f71 9508                      	ret
                                 
                                 sound_driver_channel2_decrement_frame_delay:
001f72 95ba                      	dec r27
001f73 93b0 28ba                 	sts triangle_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_calculate_delays:
001f75 91f0 2819                 	lds r31, song_speed
001f77 2fef                      	mov r30, r31
001f78 50e1                      	subi r30, 1
                                 sound_driver_calculate_delays_pulse1:
001f79 91a0 2820                 	lds r26, pulse1_pattern_delay_frames
001f7b 11a2                      	cpse r26, zero
001f7c c042                      	rjmp sound_driver_calculate_delays_pulse2
001f7d c000                      	rjmp sound_driver_calculate_delays_pulse1_main
                                 
                                 sound_driver_calculate_delays_pulse1_main:
001f7e 2faf                      	mov r26, r31 //move the speed to r26
001f7f 91b0 281f                 	lds r27, pulse1_pattern_delay_rows //decrement the delay rows
001f81 15b2                      	cp r27, zero
001f82 f409                      	brne PC+2
001f83 c03b                      	rjmp sound_driver_calculate_delays_pulse2
001f84 95ba                      	dec r27
001f85 93b0 281f                 	sts pulse1_pattern_delay_rows, r27
001f87 11b2                      	cpse r27, zero
001f88 c034                      	rjmp sound_driver_calculate_delays_pulse1_store
001f89 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx:
001f8a efbf                      	ldi r27, 0xFF
001f8b 91c0 2868                 	lds r28, pulse1_fx_Sxx_pre
001f8d 91d0 2869                 	lds r29, pulse1_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse1_Sxx_check_pre:
001f8f 17cb                      	cp r28, r27
001f90 f009                      	breq sound_driver_calculate_delays_pulse1_Sxx_check_post
001f91 c00d                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_pre
                                 sound_driver_calculate_delays_pulse1_Sxx_check_post:
001f92 17db                      	cp r29, r27
001f93 f009                      	breq sound_driver_calculate_delays_pulse1_Gxx
001f94 c015                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx:
001f95 91c0 2859                 	lds r28, pulse1_fx_Gxx_pre
001f97 91d0 285a                 	lds r29, pulse1_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse1_Gxx_check_pre:
001f99 17cb                      	cp r28, r27
001f9a f009                      	breq sound_driver_calculate_delays_pulse1_Gxx_check_post
001f9b c012                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_pre
                                 sound_driver_calculate_delays_pulse1_Gxx_check_post:
001f9c 17db                      	cp r29, r27
001f9d f0f9                      	breq sound_driver_calculate_delays_pulse1_store
001f9e c01a                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_pre:
001f9f 93b0 2868                 	sts pulse1_fx_Sxx_pre, r27
001fa1 1bec                      	sub r30, r28 //(song speed)-1-Sxx
001fa2 93e0 2869                 	sts pulse1_fx_Sxx_post, r30
001fa4 95ca                      	dec r28
001fa5 93c0 2820                 	sts pulse1_pattern_delay_frames, r28
001fa7 2fef                      	mov r30, r31
001fa8 50e1                      	subi r30, 1
001fa9 c015                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_post:
001faa 93b0 2869                 	sts pulse1_fx_Sxx_post, r27
001fac 2fad                      	mov r26, r29
001fad c00f                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx_pre:
001fae 93b0 2859                 	sts pulse1_fx_Gxx_pre, r27
001fb0 1bec                      	sub r30, r28 //(song speed)-1-Sxx
001fb1 93e0 285a                 	sts pulse1_fx_Gxx_post, r30
001fb3 95ca                      	dec r28
001fb4 93c0 2820                 	sts pulse1_pattern_delay_frames, r28
001fb6 2fef                      	mov r30, r31
001fb7 50e1                      	subi r30, 1
001fb8 c006                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse1_Gxx_post:
001fb9 93b0 285a                 	sts pulse1_fx_Gxx_post, r27
001fbb 2fad                      	mov r26, r29
001fbc c000                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_store:
001fbd 93a0 2820                 	sts pulse1_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_pulse2:
001fbf 91a0 286d                 	lds r26, pulse2_pattern_delay_frames
001fc1 11a2                      	cpse r26, zero
001fc2 c042                      	rjmp sound_driver_calculate_delays_triangle
001fc3 c000                      	rjmp sound_driver_calculate_delays_pulse2_main
                                 
                                 sound_driver_calculate_delays_pulse2_main:
001fc4 2faf                      	mov r26, r31 //move the speed to r26
001fc5 91b0 286c                 	lds r27, pulse2_pattern_delay_rows //decrement the delay rows
001fc7 15b2                      	cp r27, zero
001fc8 f409                      	brne PC+2
001fc9 c03b                      	rjmp sound_driver_calculate_delays_triangle
001fca 95ba                      	dec r27
001fcb 93b0 286c                 	sts pulse2_pattern_delay_rows, r27
001fcd 11b2                      	cpse r27, zero
001fce c034                      	rjmp sound_driver_calculate_delays_pulse2_store
001fcf 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx:
001fd0 efbf                      	ldi r27, 0xFF
001fd1 91c0 28b5                 	lds r28, pulse2_fx_Sxx_pre
001fd3 91d0 28b6                 	lds r29, pulse2_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse2_Sxx_check_pre:
001fd5 17cb                      	cp r28, r27
001fd6 f009                      	breq sound_driver_calculate_delays_pulse2_Sxx_check_post
001fd7 c00d                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_pre
                                 sound_driver_calculate_delays_pulse2_Sxx_check_post:
001fd8 17db                      	cp r29, r27
001fd9 f009                      	breq sound_driver_calculate_delays_pulse2_Gxx
001fda c015                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx:
001fdb 91c0 28a6                 	lds r28, pulse2_fx_Gxx_pre
001fdd 91d0 28a7                 	lds r29, pulse2_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse2_Gxx_check_pre:
001fdf 17cb                      	cp r28, r27
001fe0 f009                      	breq sound_driver_calculate_delays_pulse2_Gxx_check_post
001fe1 c012                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_pre
                                 sound_driver_calculate_delays_pulse2_Gxx_check_post:
001fe2 17db                      	cp r29, r27
001fe3 f0f9                      	breq sound_driver_calculate_delays_pulse2_store
001fe4 c01a                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_pre:
001fe5 93b0 28b5                 	sts pulse2_fx_Sxx_pre, r27
001fe7 1bec                      	sub r30, r28 //(song speed)-1-Sxx
001fe8 93e0 28b6                 	sts pulse2_fx_Sxx_post, r30
001fea 95ca                      	dec r28
001feb 93c0 286d                 	sts pulse2_pattern_delay_frames, r28
001fed 2fef                      	mov r30, r31
001fee 50e1                      	subi r30, 1
001fef cfcf                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_post:
001ff0 93b0 28b6                 	sts pulse2_fx_Sxx_post, r27
001ff2 2fad                      	mov r26, r29
001ff3 c00f                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx_pre:
001ff4 93b0 28a6                 	sts pulse2_fx_Gxx_pre, r27
001ff6 1bec                      	sub r30, r28 //(song speed)-1-Sxx
001ff7 93e0 28a7                 	sts pulse2_fx_Gxx_post, r30
001ff9 95ca                      	dec r28
001ffa 93c0 286d                 	sts pulse2_pattern_delay_frames, r28
001ffc 2fef                      	mov r30, r31
001ffd 50e1                      	subi r30, 1
001ffe cfc0                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse2_Gxx_post:
001fff 93b0 28a7                 	sts pulse2_fx_Gxx_post, r27
002001 2fad                      	mov r26, r29
002002 c000                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_store:
002003 93a0 286d                 	sts pulse2_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_triangle:
002005 91a0 28ba                 	lds r26, triangle_pattern_delay_frames
002007 11a2                      	cpse r26, zero
002008 c042                      	rjmp sound_driver_calculate_delays_noise
002009 c000                      	rjmp sound_driver_calculate_delays_triangle_main
                                 
                                 sound_driver_calculate_delays_triangle_main:
00200a 2faf                      	mov r26, r31 //move the speed to r26
00200b 91b0 28b9                 	lds r27, triangle_pattern_delay_rows //decrement the delay rows
00200d 15b2                      	cp r27, zero
00200e f409                      	brne PC+2
00200f c03b                      	rjmp sound_driver_calculate_delays_noise
002010 95ba                      	dec r27
002011 93b0 28b9                 	sts triangle_pattern_delay_rows, r27
002013 11b2                      	cpse r27, zero
002014 c034                      	rjmp sound_driver_calculate_delays_triangle_store
002015 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_triangle_Sxx:
002016 efbf                      	ldi r27, 0xFF
002017 91c0 28fd                 	lds r28, triangle_fx_Sxx_pre
002019 91d0 28fe                 	lds r29, triangle_fx_Sxx_post
                                 sound_driver_calculate_delays_triangle_Sxx_check_pre:
00201b 17cb                      	cp r28, r27
00201c f009                      	breq sound_driver_calculate_delays_triangle_Sxx_check_post
00201d c00d                      	rjmp sound_driver_calculate_delays_triangle_Sxx_pre
                                 sound_driver_calculate_delays_triangle_Sxx_check_post:
00201e 17db                      	cp r29, r27
00201f f009                      	breq sound_driver_calculate_delays_triangle_Gxx
002020 c015                      	rjmp sound_driver_calculate_delays_triangle_Sxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Gxx:
002021 91c0 28ee                 	lds r28, triangle_fx_Gxx_pre
002023 91d0 28ef                 	lds r29, triangle_fx_Gxx_post
                                 sound_driver_calculate_delays_triangle_Gxx_check_pre:
002025 17cb                      	cp r28, r27
002026 f009                      	breq sound_driver_calculate_delays_triangle_Gxx_check_post
002027 c012                      	rjmp sound_driver_calculate_delays_triangle_Gxx_pre
                                 sound_driver_calculate_delays_triangle_Gxx_check_post:
002028 17db                      	cp r29, r27
002029 f0f9                      	breq sound_driver_calculate_delays_triangle_store
00202a c01a                      	rjmp sound_driver_calculate_delays_triangle_Gxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_pre:
00202b 93b0 28fd                 	sts triangle_fx_Sxx_pre, r27
00202d 1bec                      	sub r30, r28 //(song speed)-1-Sxx
00202e 93e0 28fe                 	sts triangle_fx_Sxx_post, r30
002030 95ca                      	dec r28
002031 93c0 28ba                 	sts triangle_pattern_delay_frames, r28
002033 2fef                      	mov r30, r31
002034 50e1                      	subi r30, 1
002035 c015                      	rjmp sound_driver_calculate_delays_noise
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_post:
002036 93b0 28fe                 	sts triangle_fx_Sxx_post, r27
002038 2fad                      	mov r26, r29
002039 c00f                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_Gxx_pre:
00203a 93b0 28ee                 	sts triangle_fx_Gxx_pre, r27
00203c 1bec                      	sub r30, r28 //(song speed)-1-Sxx
00203d 93e0 28ef                 	sts triangle_fx_Gxx_post, r30
00203f 95ca                      	dec r28
002040 93c0 28ba                 	sts triangle_pattern_delay_frames, r28
002042 2fef                      	mov r30, r31
002043 50e1                      	subi r30, 1
002044 c006                      	rjmp sound_driver_calculate_delays_noise
                                 	
                                 sound_driver_calculate_delays_triangle_Gxx_post:
002045 93b0 28ef                 	sts triangle_fx_Gxx_post, r27
002047 2fad                      	mov r26, r29
002048 c000                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_store:
002049 93a0 28ba                 	sts triangle_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_noise:
                                 
                                 sound_driver_instrument_fx_routine:
                                 sound_driver_instrument_routine_channel0_volume:
00204b 91e0 2823                 	lds ZL, pulse1_volume_macro
00204d 91f0 2824                 	lds ZH, pulse1_volume_macro+1
00204f 9630                      	adiw Z, 0
002050 f1a1                      	breq sound_driver_instrument_routine_channel0_volume_default //if no volume macro is in use, use default multiplier of F
002051 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002052 1fff                      	rol ZH
002053 91a0 2825                 	lds r26, pulse1_volume_macro_offset
002055 0fea                      	add ZL, r26
002056 1df2                      	adc ZH, zero
                                 
002057 91b0 2827                 	lds r27, pulse1_volume_macro_release
002059 17ba                      	cp r27, r26
00205a f429                      	brne sound_driver_instrument_routine_channel0_volume_increment //if the current offset is not equal to the release index, increment the offset
00205b 91a0 2826                 	lds r26, pulse1_volume_macro_loop
00205d 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00205e f010                      	brlo sound_driver_instrument_routine_channel0_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00205f c003                      	rjmp sound_driver_instrument_routine_channel0_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_volume_increment:
002060 95a3                      	inc r26 //increment the macro offset
002061 93a0 2825                 	sts pulse1_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_volume_read:
002063 91b4                      	lpm r27, Z //load volume data into r27
002064 3fbf                      	cpi r27, 0xFF //check for macro end flag
002065 f469                      	brne sound_driver_instrument_routine_channel0_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_release:
002066 91b0 2827                 	lds r27, pulse1_volume_macro_release
002068 3fbf                      	cpi r27, 0xFF
002069 f429                      	brne sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_loop:
00206a 91b0 2826                 	lds r27, pulse1_volume_macro_loop //load the loop index
00206c 93b0 2825                 	sts pulse1_volume_macro_offset, r27 //store the loop index into the offset
00206e cfdc                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index:
00206f 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002070 93a0 2825                 	sts pulse1_volume_macro_offset, r26
002072 cfd8                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_calculate:
002073 e6e6                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
002074 e5f4                      	ldi ZH, HIGH(volumes << 1)
002075 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
002076 0feb                      	add ZL, r27 //add offset to the table
002077 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel0_volume_load:
002078 91b0 2800                 	lds r27, pulse1_param //load main volume
00207a 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
00207b 91a0 2857                 	lds r26, pulse1_fx_7xy_value
00207d 30a0                      	cpi r26, 0x00
00207e f481                      	brne sound_driver_instrument_routine_channel0_volume_load_7xy
                                 
00207f 0feb                      	add ZL, r27 //offset the volume table by the main volume
002080 1df2                      	adc ZH, zero
002081 91b4                      	lpm r27, Z
002082 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
002084 c024                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default:
002085 91b0 2800                 	lds r27, pulse1_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
002087 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002088 91a0 2857                 	lds r26, pulse1_fx_7xy_value
00208a 30a0                      	cpi r26, 0x00
00208b f4a1                      	brne sound_driver_instrument_routine_channel0_volume_default_7xy
00208c 93b0 2806                 	sts pulse1_output_volume, r27
00208e c01a                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy:
00208f 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002090 f040                      	brcs sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
002091 f039                      	breq sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
002092 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
                                 
002093 0feb                      	add ZL, r27 //offset the volume table by the main volume
002094 1df2                      	adc ZH, zero
002095 91b4                      	lpm r27, Z
002096 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
002098 c010                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy_overflow:
002099 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
00209a 0feb                      	add ZL, r27 //offset the volume table by the main volume
00209b 1df2                      	adc ZH, zero
00209c 91b4                      	lpm r27, Z
00209d 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
00209f c009                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default_7xy:
0020a0 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
0020a1 f020                      	brcs sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
0020a2 f019                      	breq sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
0020a3 93b0 2806                 	sts pulse1_output_volume, r27
0020a5 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel0_volume_default_7xy_overflow:
0020a6 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
0020a7 93b0 2806                 	sts pulse1_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
0020a9 91e0 2828                 	lds ZL, pulse1_arpeggio_macro
0020ab 91f0 2829                 	lds ZH, pulse1_arpeggio_macro+1
0020ad 9630                      	adiw Z, 0
0020ae f1d9                      	breq sound_driver_instrument_routine_channel0_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
0020af 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0020b0 1fff                      	rol ZH
0020b1 91a0 282a                 	lds r26, pulse1_arpeggio_macro_offset
0020b3 0fea                      	add ZL, r26
0020b4 1df2                      	adc ZH, zero
                                 
0020b5 91b0 282c                 	lds r27, pulse1_arpeggio_macro_release
0020b7 17ba                      	cp r27, r26
0020b8 f429                      	brne sound_driver_instrument_routine_channel0_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
0020b9 91a0 282b                 	lds r26, pulse1_arpeggio_macro_loop
0020bb 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0020bc f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
0020bd c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_increment:
0020be 95a3                      	inc r26 //increment the macro offset
0020bf 93a0 282a                 	sts pulse1_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_read:
0020c1 91b4                      	lpm r27, Z //load arpeggio data into r27
0020c2 38b0                      	cpi r27, 0x80 //check for macro end flag
0020c3 f009                      	breq sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag
0020c4 c041                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_check_mode:
0020c5 50a1                      	subi r26, 1 //keep the offset at the end flag
0020c6 93a0 282a                 	sts pulse1_arpeggio_macro_offset, r26
0020c8 91b0 282d                 	lds r27, pulse1_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
0020ca 30b1                      	cpi r27, 0x01
0020cb f048                      	brlo sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_release:
0020cc 91b0 282c                 	lds r27, pulse1_arpeggio_macro_release
0020ce 3fbf                      	cpi r27, 0xFF
0020cf f4d1                      	brne sound_driver_instrument_routine_channel0_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_loop:
0020d0 91b0 282b                 	lds r27, pulse1_arpeggio_macro_loop
0020d2 3fbf                      	cpi r27, 0xFF
0020d3 f499                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
0020d4 c015                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute:
0020d5 91b0 282c                 	lds r27, pulse1_arpeggio_macro_release
0020d7 3fbf                      	cpi r27, 0xFF
0020d8 f421                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_check_loop:
0020d9 91b0 282b                 	lds r27, pulse1_arpeggio_macro_loop //load the loop index
0020db 3fbf                      	cpi r27, 0xFF //check if loop flag exists
0020dc f451                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop:
0020dd 91c0 283f                 	lds r28, pulse1_fx_0xy_sequence //check for 0xy effect
0020df 91d0 2840                 	lds r29, pulse1_fx_0xy_sequence+1
0020e1 9620                      	adiw r29:r28, 0
0020e2 f469                      	brne sound_driver_instrument_routine_channel0_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
0020e3 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
0020e4 93a0 282a                 	sts pulse1_arpeggio_macro_offset, r26 //store the last valid index into the offset
0020e6 cfc2                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload:
0020e7 93b0 282a                 	sts pulse1_arpeggio_macro_offset, r27 //store the loop index into the offset
0020e9 cfbf                      	rjmp sound_driver_instrument_routine_channel0_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_default:
0020ea 91c0 283f                 	lds r28, pulse1_fx_0xy_sequence //load 0xy effect
0020ec 91d0 2840                 	lds r29, pulse1_fx_0xy_sequence+1
0020ee 9620                      	adiw r29:r28, 0 //check for 0xy effect
0020ef f099                      	breq sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel0_arpeggio_default_xy:
0020f0 95d6                      	lsr r29
0020f1 95c7                      	ror r28
0020f2 95d7                      	ror r29
0020f3 95c7                      	ror r28
0020f4 95d7                      	ror r29
0020f5 95c7                      	ror r28
0020f6 95d7                      	ror r29
0020f7 95c7                      	ror r28
0020f8 95d7                      	ror r29
0020f9 95d2                      	swap r29
                                 
0020fa 93c0 283f                 	sts pulse1_fx_0xy_sequence, r28 //store the rolled sequence
0020fc 93d0 2840                 	sts pulse1_fx_0xy_sequence+1, r29
0020fe 70cf                      	andi r28, 0x0F //mask out the 4 LSB
0020ff 91a0 2807                 	lds r26, pulse1_note //load the current note index
002101 0fac                      	add r26, r28 //add the note offset
002102 c02c                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002103 91a0 2807                 	lds r26, pulse1_note //load the current note index
002105 c029                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process:
002106 9220 282e                 	sts pulse1_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002108 9220 2834                 	sts pulse1_total_hi_pitch_offset, zero
00210a 91a0 282d                 	lds r26, pulse1_arpeggio_macro_mode
00210c 30a1                      	cpi r26, 0x01 //absolute mode
00210d f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_absolute
00210e f069                      	breq sound_driver_instrument_routine_channel0_arpeggio_process_fixed
00210f c00e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute:
002110 91a0 2807                 	lds r26, pulse1_note //load the current note index
002112 0fab                      	add r26, r27 //offset the note with the arpeggio data
002113 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002114 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_add:
002115 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002116 f0c0                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
002117 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002118 c016                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract:
002119 fda7                      	sbrc r26, 7 //check if result is negative
00211a e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
00211b c013                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_fixed:
00211c 2fab                      	mov r26, r27 //move the arpeggio data into r26
00211d c011                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative:
00211e 91a0 2807                 	lds r26, pulse1_note //load the current note index
002120 0fab                      	add r26, r27 //offset the note with the arpeggio data
002121 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002122 c008                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_add:
002123 93a0 2807                 	sts pulse1_note, r26 //NOTE: relative mode modifies the original note index
002125 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002126 f040                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
002127 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002128 93a0 2807                 	sts pulse1_note, r26
00212a c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract:
00212b fda7                      	sbrc r26, 7 //check if result is negative
00212c e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
00212d 93a0 2807                 	sts pulse1_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_load:
00212f e6e8                      	ldi ZL, LOW(note_table << 1) //load in note table
002130 e0f0                      	ldi ZH, HIGH(note_table << 1)
002131 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002132 0fea                      	add ZL, r26 //add offset
002133 1df2                      	adc ZH, zero
002134 91a5                      	lpm r26, Z+ //load bytes
002135 91b4                      	lpm r27, Z
002136 93a0 0a8c                 	sts TCB0_CCMPL, r26 //load the LOW bits for timer
002138 93b0 0a8d                 	sts TCB0_CCMPH, r27 //load the HIGH bits for timer
00213a 93a0 284b                 	sts pulse1_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
00213c 93b0 284c                 	sts pulse1_fx_3xx_target+1, r27
00213e c000                      	rjmp sound_driver_instrument_routine_channel0_pitch
                                 
                                 
                                 
                                 //NOTE: There is a limitation with the pitch routines in that the total pitch can not be offset by 127 in both,
                                 //the positive and negative direction, from the original note pitch. This shouldn't be too much of a problem as
                                 //most songs that use instruments with the pitch macro, do not stray that far from the original note pitch.
                                 //In the case of hi pitch, the total pitch can not be offset by 127*16 from the original pitch. This is also
                                 //not a big deal as you can easily reach the entire note range with an offset of up to 127*16.
                                 sound_driver_instrument_routine_channel0_pitch:
00213f 91e0 282f                 	lds ZL, pulse1_pitch_macro
002141 91f0 2830                 	lds ZH, pulse1_pitch_macro+1
002143 9630                      	adiw Z, 0
002144 f409                      	brne sound_driver_instrument_routine_channel0_pitch_continue
002145 c023                      	rjmp sound_driver_instrument_routine_channel0_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel0_pitch_continue:
002146 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002147 1fff                      	rol ZH
002148 91a0 2831                 	lds r26, pulse1_pitch_macro_offset
00214a 0fea                      	add ZL, r26
00214b 1df2                      	adc ZH, zero
                                 
00214c 91b0 2833                 	lds r27, pulse1_pitch_macro_release
00214e 17ba                      	cp r27, r26
00214f f429                      	brne sound_driver_instrument_routine_channel0_pitch_increment //if the current offset is not equal to the release index, increment the offset
002150 91a0 2832                 	lds r26, pulse1_pitch_macro_loop
002152 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002153 f010                      	brlo sound_driver_instrument_routine_channel0_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002154 c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_pitch_increment:
002155 95a3                      	inc r26 //increment the macro offset
002156 93a0 2831                 	sts pulse1_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_pitch_read:
002158 91b4                      	lpm r27, Z //load pitch data into r27
002159 38b0                      	cpi r27, 0x80 //check for macro end flag
00215a f489                      	brne sound_driver_instrument_routine_channel0_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_release:
00215b 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00215c 93a0 2831                 	sts pulse1_pitch_macro_offset, r26
00215e 91b0 2833                 	lds r27, pulse1_pitch_macro_release
002160 3fbf                      	cpi r27, 0xFF
002161 f439                      	brne sound_driver_instrument_routine_channel0_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_loop:
002162 91b0 2832                 	lds r27, pulse1_pitch_macro_loop //load the loop index
002164 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002165 f019                      	breq sound_driver_instrument_routine_channel0_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002166 93b0 2831                 	sts pulse1_pitch_macro_offset, r27 //store the loop index into the offset
002168 cfd6                      	rjmp sound_driver_instrument_routine_channel0_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_default:
002169 91b0 282e                 	lds r27, pulse1_total_pitch_offset
00216b c005                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate:
00216c 91a0 282e                 	lds r26, pulse1_total_pitch_offset //load the total pitch offset to change
00216e 0fba                      	add r27, r26
00216f 93b0 282e                 	sts pulse1_total_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_multiply:
                                 	//NOTE: The Pxx effect is processed with the pitch instrument macro because the calculations are the same
002171 91a0 285b                 	lds r26, pulse1_fx_Pxx
002173 0fba                      	add r27, r26
                                 
002174 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002175 937f                      	push r23
002176 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
002177 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002178 0367                      	mulsu r22, r23
002179 917f                      	pop r23
00217a 916f                      	pop r22
                                 
00217b 9416                      	lsr r1 //shift out the fractional bits
00217c 9407                      	ror r0
00217d 9416                      	lsr r1
00217e 9407                      	ror r0
00217f 9416                      	lsr r1
002180 9407                      	ror r0
002181 9416                      	lsr r1
002182 9407                      	ror r0
002183 fe13                      	sbrs r1, 3 //check if result was a negative number
002184 c002                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_negative:
002185 efb0                      	ldi r27, 0xF0
002186 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_offset:
002187 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
002189 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
00218b 0da0                      	add r26, r0 //offset the timer values
00218c 1db1                      	adc r27, r1
                                 	
00218d 91c0 2843                 	lds r28, pulse1_fx_1xx_total
00218f 91d0 2844                 	lds r29, pulse1_fx_1xx_total+1
002191 1bac                      	sub r26, r28
002192 0bbd                      	sbc r27, r29
002193 91c0 2847                 	lds r28, pulse1_fx_2xx_total
002195 91d0 2848                 	lds r29, pulse1_fx_2xx_total+1
002197 0fac                      	add r26, r28
002198 1fbd                      	adc r27, r29
002199 91c0 2860                 	lds r28, pulse1_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
00219b 91d0 2861                 	lds r29, pulse1_fx_Qxy_total_offset+1
00219d 1bac                      	sub r26, r28
00219e 0bbd                      	sbc r27, r29
00219f 91c0 2866                 	lds r28, pulse1_fx_Rxy_total_offset
0021a1 91d0 2867                 	lds r29, pulse1_fx_Rxy_total_offset+1
0021a3 0fac                      	add r26, r28
0021a4 1fbd                      	adc r27, r29
                                 
0021a5 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
0021a7 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel0_hi_pitch:
0021a9 91e0 2835                 	lds ZL, pulse1_hi_pitch_macro
0021ab 91f0 2836                 	lds ZH, pulse1_hi_pitch_macro+1
0021ad 9630                      	adiw Z, 0
0021ae f409                      	brne sound_driver_instrument_routine_channel0_hi_pitch_continue
0021af c03c                      	rjmp sound_driver_instrument_routine_channel0_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel0_hi_pitch_continue:
0021b0 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0021b1 1fff                      	rol ZH
0021b2 91a0 2837                 	lds r26, pulse1_hi_pitch_macro_offset
0021b4 0fea                      	add ZL, r26
0021b5 1df2                      	adc ZH, zero
                                 
0021b6 91b0 2839                 	lds r27, pulse1_hi_pitch_macro_release
0021b8 17ba                      	cp r27, r26
0021b9 f429                      	brne sound_driver_instrument_routine_channel0_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
0021ba 91a0 2838                 	lds r26, pulse1_hi_pitch_macro_loop
0021bc 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0021bd f010                      	brlo sound_driver_instrument_routine_channel0_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0021be c003                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_increment:
0021bf 95a3                      	inc r26 //increment the macro offset
0021c0 93a0 2837                 	sts pulse1_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_hi_pitch_read:
0021c2 91b4                      	lpm r27, Z //load hi pitch data into r27
0021c3 38b0                      	cpi r27, 0x80 //check for macro end flag
0021c4 f489                      	brne sound_driver_instrument_routine_channel0_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_release:
0021c5 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0021c6 93a0 2837                 	sts pulse1_hi_pitch_macro_offset, r26
0021c8 91b0 2839                 	lds r27, pulse1_hi_pitch_macro_release
0021ca 3fbf                      	cpi r27, 0xFF
0021cb f439                      	brne sound_driver_instrument_routine_channel0_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_loop:
0021cc 91b0 2838                 	lds r27, pulse1_hi_pitch_macro_loop //load the loop index
0021ce 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0021cf f019                      	breq sound_driver_instrument_routine_channel0_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
0021d0 93b0 2837                 	sts pulse1_hi_pitch_macro_offset, r27 //store the loop index into the offset
0021d2 cfd6                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_default:
0021d3 91b0 2834                 	lds r27, pulse1_total_hi_pitch_offset
0021d5 c005                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate:
0021d6 91a0 2834                 	lds r26, pulse1_total_hi_pitch_offset //load the total hi pitch offset to change
0021d8 0fba                      	add r27, r26
0021d9 93b0 2834                 	sts pulse1_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply:
0021db 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0021dc 937f                      	push r23
0021dd 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
0021de eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0021df 0367                      	mulsu r22, r23
0021e0 917f                      	pop r23
0021e1 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_offset:
0021e2 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
0021e4 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
0021e6 0da0                      	add r26, r0 //offset the timer values
0021e7 1db1                      	adc r27, r1
0021e8 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
0021ea 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel0_duty:
0021ec 91e0 283a                 	lds ZL, pulse1_duty_macro
0021ee 91f0 283b                 	lds ZH, pulse1_duty_macro+1
0021f0 9630                      	adiw Z, 0
0021f1 f1b1                      	breq sound_driver_channel0_fx_routines //if no duty macro is in use, go to the next routine
0021f2 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0021f3 1fff                      	rol ZH
0021f4 91a0 283c                 	lds r26, pulse1_duty_macro_offset
0021f6 0fea                      	add ZL, r26
0021f7 1df2                      	adc ZH, zero
                                 
0021f8 91b0 283e                 	lds r27, pulse1_duty_macro_release
0021fa 17ba                      	cp r27, r26
0021fb f429                      	brne sound_driver_instrument_routine_channel0_duty_increment //if the current offset is not equal to the release index, increment the offset
0021fc 91a0 283d                 	lds r26, pulse1_duty_macro_loop
0021fe 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0021ff f010                      	brlo sound_driver_instrument_routine_channel0_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002200 c027                      	rjmp sound_driver_channel0_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel0_duty_increment:
002201 95a3                      	inc r26 //increment the macro offset
002202 93a0 283c                 	sts pulse1_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_duty_read:
002204 91b4                      	lpm r27, Z //load pitch data into r27
002205 3fbf                      	cpi r27, 0xFF //check for macro end flag
002206 f471                      	brne sound_driver_instrument_routine_channel0_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_release:
002207 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002208 93a0 283c                 	sts pulse1_duty_macro_offset, r26
00220a 91b0 283e                 	lds r27, pulse1_duty_macro_release
00220c 3fbf                      	cpi r27, 0xFF
00220d f4d1                      	brne sound_driver_channel0_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_loop:
00220e 91b0 283d                 	lds r27, pulse1_duty_macro_loop //load the loop index
002210 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002211 f0b1                      	breq sound_driver_channel0_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
002212 93b0 283c                 	sts pulse1_duty_macro_offset, r27 //store the loop index into the offset
002214 cfd7                      	rjmp sound_driver_instrument_routine_channel0_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_load:
002215 ece6                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
002216 e5f3                      	ldi ZH, HIGH(sequences << 1)
002217 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
002218 1df2                      	adc ZH, zero
                                 
002219 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
00221a 95b7                      	ror r27
00221b 95b7                      	ror r27
00221c 91a0 2800                 	lds r26, pulse1_param //load r26 with pulse1_param (register $4000)
00221e 2fca                      	mov r28, r26 //store a copy of pulse1_param into r28
00221f 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
002220 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
002221 c001                      	rjmp sound_driver_instrument_routine_channel0_duty_load_store
002222 c005                      	rjmp sound_driver_channel0_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel0_duty_load_store:
002223 90a4                      	lpm pulse1_sequence, Z //store the sequence
                                 
002224 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
002225 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
002226 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_routines:
                                 sound_driver_channel0_fx_1xx_routine:
002228 91e0 2841                 	lds ZL, pulse1_fx_1xx
00222a 91f0 2842                 	lds ZH, pulse1_fx_1xx+1
00222c 9630                      	adiw Z, 0
00222d f051                      	breq sound_driver_channel0_fx_2xx_routine
                                 
00222e 91a0 2843                 	lds r26, pulse1_fx_1xx_total //load the rate to change the pitch by
002230 91b0 2844                 	lds r27, pulse1_fx_1xx_total+1
002232 0fae                      	add r26, ZL //increase the total offset by the rate
002233 1fbf                      	adc r27, ZH
002234 93a0 2843                 	sts pulse1_fx_1xx_total, r26
002236 93b0 2844                 	sts pulse1_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_2xx_routine:
002238 91e0 2845                 	lds ZL, pulse1_fx_2xx
00223a 91f0 2846                 	lds ZH, pulse1_fx_2xx+1
00223c 9630                      	adiw Z, 0
00223d f051                      	breq sound_driver_channel0_fx_3xx_routine
                                 
00223e 91a0 2847                 	lds r26, pulse1_fx_2xx_total //load the rate to change the pitch by
002240 91b0 2848                 	lds r27, pulse1_fx_2xx_total+1
002242 0fae                      	add r26, ZL //increase the total offset by the rate
002243 1fbf                      	adc r27, ZH
002244 93a0 2847                 	sts pulse1_fx_2xx_total, r26
002246 93b0 2848                 	sts pulse1_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_3xx_routine:
002248 91e0 284d                 	lds ZL, pulse1_fx_3xx_speed
00224a 91f0 284e                 	lds ZH, pulse1_fx_3xx_speed+1
00224c 9630                      	adiw Z, 0
00224d f409                      	brne sound_driver_channel0_fx_3xx_routine_check_start
00224e c048                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_check_start:
00224f 91a0 2849                 	lds r26, pulse1_fx_3xx_start
002251 91b0 284a                 	lds r27, pulse1_fx_3xx_start+1
002253 9610                      	adiw r26:r27, 0
002254 f409                      	brne sound_driver_channel0_fx_3xx_routine_main
002255 c041                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_main:
002256 91c0 284b                 	lds r28, pulse1_fx_3xx_target
002258 91d0 284c                 	lds r29, pulse1_fx_3xx_target+1
                                 
00225a 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
00225b 07bd                      	cpc r27, r29
00225c f011                      	breq sound_driver_channel0_fx_3xx_routine_disable
00225d f030                      	brlo sound_driver_channel0_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
00225e c01f                      	rjmp sound_driver_channel0_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel0_fx_3xx_routine_disable:
00225f 9220 2849                 	sts pulse1_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002261 9220 284a                 	sts pulse1_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002263 c033                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_subtract:
002264 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002265 0bdb                      	sbc r29, r27
002266 91a0 284f                 	lds r26, pulse1_fx_3xx_total_offset
002268 91b0 2850                 	lds r27, pulse1_fx_3xx_total_offset+1
                                 
00226a 0fae                      	add r26, ZL //add the speed to the total offset
00226b 1fbf                      	adc r27, ZH
00226c 1bca                      	sub r28, r26 //invert the total difference with the total offset
00226d 0bdb                      	sbc r29, r27
00226e f380                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
00226f 93a0 284f                 	sts pulse1_fx_3xx_total_offset, r26 //store the new total offset
002271 93b0 2850                 	sts pulse1_fx_3xx_total_offset+1, r27
                                 
002273 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the current timer period
002275 91b0 0a8d                 	lds r27, TCB0_CCMPH
002277 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002278 0bbd                      	sbc r27, r29
002279 93a0 0a8c                 	sts TCB0_CCMPL, r26
00227b 93b0 0a8d                 	sts TCB0_CCMPH, r27
00227d c019                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_add:
00227e 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
00227f 0bbd                      	sbc r27, r29
002280 91c0 284f                 	lds r28, pulse1_fx_3xx_total_offset
002282 91d0 2850                 	lds r29, pulse1_fx_3xx_total_offset+1
                                 
002284 0fce                      	add r28, ZL //add the speed to the total offset
002285 1fdf                      	adc r29, ZH
002286 1bac                      	sub r26, r28 //invert the total difference with the total offset
002287 0bbd                      	sbc r27, r29
002288 f2b0                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002289 93c0 284f                 	sts pulse1_fx_3xx_total_offset, r28 //store the new total offset
00228b 93d0 2850                 	sts pulse1_fx_3xx_total_offset+1, r29
                                 
00228d 91c0 0a8c                 	lds r28, TCB0_CCMPL //load the current timer period
00228f 91d0 0a8d                 	lds r29, TCB0_CCMPH
002291 0fca                      	add r28, r26 //offset the current timer period with the total offset
002292 1fdb                      	adc r29, r27
002293 93c0 0a8c                 	sts TCB0_CCMPL, r28
002295 93d0 0a8d                 	sts TCB0_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel0_fx_4xy_routine:
002297 91a0 2851                 	lds r26, pulse1_fx_4xy_speed
002299 15a2                      	cp r26, zero
00229a f409                      	brne sound_driver_channel0_fx_4xy_routine_continue
00229b c05c                      	rjmp sound_driver_channel0_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel0_fx_4xy_routine_continue:
00229c 91b0 2852                 	lds r27, pulse1_fx_4xy_depth
00229e 91c0 2853                 	lds r28, pulse1_fx_4xy_phase
0022a0 0fca                      	add r28, r26 //increase the phase by the speed
0022a1 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
0022a2 f008                      	brlo sound_driver_channel0_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
0022a3 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase:
0022a4 93c0 2853                 	sts pulse1_fx_4xy_phase, r28 //store the new phase
0022a6 31c0                      	cpi r28, 16
0022a7 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_0
0022a8 32c0                      	cpi r28, 32
0022a9 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_1
0022aa 33c0                      	cpi r28, 48
0022ab f030                      	brlo sound_driver_channel0_fx_4xy_routine_phase_2
0022ac c007                      	rjmp sound_driver_channel0_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_0:
0022ad 70cf                      	andi r28, 0x0F //mask for values 0-15
0022ae c029                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_1:
0022af 6fc0                      	ori r28, 0xF0
0022b0 95c0                      	com r28 //invert values 0-15
0022b1 c026                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_2:
0022b2 70cf                      	andi r28, 0x0F //mask for values 0-15
0022b3 c003                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_3:
0022b4 6fc0                      	ori r28, 0xF0
0022b5 95c0                      	com r28 //invert values 0-15
0022b6 c000                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_add:
0022b7 95b2                      	swap r27 //multiply depth by 16
0022b8 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0022b9 e1e6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0022ba e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0022bb 0fec                      	add ZL, r28 //offset the table by the depth+phase
0022bc 1df2                      	adc ZH, zero
0022bd 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
0022be 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0022bf 937f                      	push r23
0022c0 2f6c                      	mov r22, r28 //store the vibrato value into r22
0022c1 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0022c2 9f67                      	mul r22, r23
0022c3 917f                      	pop r23
0022c4 916f                      	pop r22
                                 
0022c5 9416                      	lsr r1 //shift out the fractional bits
0022c6 9407                      	ror r0
0022c7 9416                      	lsr r1
0022c8 9407                      	ror r0
0022c9 9416                      	lsr r1
0022ca 9407                      	ror r0
0022cb 9416                      	lsr r1
0022cc 9407                      	ror r0
                                 	
0022cd 91a0 0a8c                 	lds r26, TCB0_CCMPL
0022cf 91b0 0a8d                 	lds r27, TCB0_CCMPH
0022d1 0da0                      	add r26, r0
0022d2 1db1                      	adc r27, r1
0022d3 93a0 0a8c                 	sts TCB0_CCMPL, r26
0022d5 93b0 0a8d                 	sts TCB0_CCMPH, r27
0022d7 c020                      	rjmp sound_driver_channel0_fx_7xy_routine
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_subtract:
0022d8 95b2                      	swap r27 //multiply depth by 16
0022d9 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
0022da e1e6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0022db e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0022dc 0fec                      	add ZL, r28 //offset the table by the depth+phase
0022dd 1df2                      	adc ZH, zero
0022de 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
0022df 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0022e0 937f                      	push r23
0022e1 2f6c                      	mov r22, r28 //store the vibrato value into r22
0022e2 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0022e3 9f67                      	mul r22, r23
0022e4 917f                      	pop r23
0022e5 916f                      	pop r22
                                 
0022e6 9416                      	lsr r1 //shift out the fractional bits
0022e7 9407                      	ror r0
0022e8 9416                      	lsr r1
0022e9 9407                      	ror r0
0022ea 9416                      	lsr r1
0022eb 9407                      	ror r0
0022ec 9416                      	lsr r1
0022ed 9407                      	ror r0
                                 
0022ee 91a0 0a8c                 	lds r26, TCB0_CCMPL
0022f0 91b0 0a8d                 	lds r27, TCB0_CCMPH
0022f2 19a0                      	sub r26, r0
0022f3 09b1                      	sbc r27, r1
0022f4 93a0 0a8c                 	sts TCB0_CCMPL, r26
0022f6 93b0 0a8d                 	sts TCB0_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_7xy_routine:
0022f8 91a0 2854                 	lds r26, pulse1_fx_7xy_speed
0022fa 15a2                      	cp r26, zero
0022fb f0f1                      	breq sound_driver_channel0_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
0022fc 91b0 2855                 	lds r27, pulse1_fx_7xy_depth
0022fe 91c0 2856                 	lds r28, pulse1_fx_7xy_phase
002300 0fca                      	add r28, r26 //increase the phase by the speed
002301 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
002302 f010                      	brlo sound_driver_channel0_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
002303 e0c0                      	ldi r28, 0x00
002304 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase:
002305 93c0 2856                 	sts pulse1_fx_7xy_phase, r28 //store the new phase
002307 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
002308 ffc4                      	sbrs r28, 4
002309 c001                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_0
00230a c002                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel0_fx_7xy_routine_phase_0:
00230b 70cf                      	andi r28, 0x0F //mask for values 0-15
00230c c003                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase_1:
00230d 6fc0                      	ori r28, 0xF0
00230e 95c0                      	com r28 //invert values 0-15
00230f c000                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_load:
002310 95b2                      	swap r27 //multiply depth by 16
002311 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002312 e1e6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002313 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002314 0fec                      	add ZL, r28 //offset the table by the depth+phase
002315 1df2                      	adc ZH, zero
002316 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002317 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
002318 93c0 2857                 	sts pulse1_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Axy_routine:
00231a 91b0 2858                 	lds r27, pulse1_fx_Axy
00231c 15b2                      	cp r27, zero
00231d f0e9                      	breq sound_driver_channel0_fx_Qxy_routine //0 means that the effect is not in use
                                 	
00231e 91a0 2805                 	lds r26, pulse1_fractional_volume //load fractional volume representation of the channel
002320 91c0 2800                 	lds r28, pulse1_param //load the integer volume representation of the channel
002322 2fda                      	mov r29, r26 //copy fractional volume into r29
002323 2fec                      	mov r30, r28 //copy the pulse1_param into r30
002324 95e2                      	swap r30
002325 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
002326 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
002327 17ed                      	cp r30, r29 //compare the fractional and integer volumes
002328 f009                      	breq sound_driver_channel0_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel0_fx_Axy_routine_reload:
002329 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate:
00232a fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
00232b c004                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_addition:
00232c 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
00232d f428                      	brcc sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
00232e efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
00232f c003                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_subtraction:
002330 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002331 f008                      	brcs sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002332 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_store:
002333 93a0 2805                 	sts pulse1_fractional_volume, r26 //store the new fractional volume
002335 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
002336 95a2                      	swap r26
002337 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
002338 2bca                      	or r28, r26 //store the new volume back into pulse1_param
002339 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel0_fx_Qxy_routine:
00233b 91e0 285c                 	lds ZL, pulse1_fx_Qxy_target
00233d 91f0 285d                 	lds ZH, pulse1_fx_Qxy_target+1
00233f 9630                      	adiw Z, 0
002340 f199                      	breq sound_driver_channel0_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002341 91a0 2860                 	lds r26, pulse1_fx_Qxy_total_offset
002343 91b0 2861                 	lds r27, pulse1_fx_Qxy_total_offset+1
002345 91c0 0a8c                 	lds r28, TCB0_CCMPL
002347 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
002349 1bec                      	sub ZL, r28 //calculate the difference to the target
00234a 0bfd                      	sbc ZH, r29
00234b f408                      	brsh sound_driver_channel0_fx_Qxy_routine_end //if the target has been reached (or passed)
00234c f0e8                      	brlo sound_driver_channel0_fx_Qxy_routine_add
                                 
                                 sound_driver_channel0_fx_Qxy_routine_end:
00234d 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
00234e 0bbf                      	sbc r27, ZH
                                 
00234f 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002350 937f                      	push r23
002351 9160 285b                 	lds r22, pulse1_fx_Pxx
002353 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002354 9f67                      	mul r22, r23
002355 917f                      	pop r23
002356 916f                      	pop r22
002357 9416                      	lsr r1 //shift out the fractional bits
002358 9407                      	ror r0
002359 9416                      	lsr r1
00235a 9407                      	ror r0
00235b 9416                      	lsr r1
00235c 9407                      	ror r0
00235d 9416                      	lsr r1
00235e 9407                      	ror r0
                                 
00235f 0da0                      	add r26, r0
002360 1db2                      	adc r27, zero
                                 
002361 93a0 2860                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
002363 93b0 2861                 	sts pulse1_fx_Qxy_total_offset+1, r27
002365 9220 285c                 	sts pulse1_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
002367 9220 285d                 	sts pulse1_fx_Qxy_target+1, zero
002369 c00a                      	rjmp sound_driver_channel0_fx_Rxy_routine
                                 
                                 sound_driver_channel0_fx_Qxy_routine_add:
00236a 91c0 285e                 	lds r28, pulse1_fx_Qxy_speed
00236c 91d0 285f                 	lds r29, pulse1_fx_Qxy_speed+1
00236e 0fac                      	add r26, r28 //increase the total offset by the speed
00236f 1fbd                      	adc r27, r29
002370 93a0 2860                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
002372 93b0 2861                 	sts pulse1_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Rxy_routine:
002374 91e0 2862                 	lds ZL, pulse1_fx_Rxy_target
002376 91f0 2863                 	lds ZH, pulse1_fx_Rxy_target+1
002378 9630                      	adiw Z, 0
002379 f199                      	breq sound_driver_instrument_routine_channel1_volume //if the effect is not enabled, skip the routine
                                 
00237a 91a0 2866                 	lds r26, pulse1_fx_Rxy_total_offset
00237c 91b0 2867                 	lds r27, pulse1_fx_Rxy_total_offset+1
00237e 91c0 0a8c                 	lds r28, TCB0_CCMPL
002380 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
002382 1bce                      	sub r28, ZL //calculate the difference to the target
002383 0bdf                      	sbc r29, ZH
002384 f408                      	brsh sound_driver_channel0_fx_Rxy_routine_end //if the target has been reached (or passed)
002385 f0e8                      	brlo sound_driver_channel0_fx_Rxy_routine_add
                                 
                                 sound_driver_channel0_fx_Rxy_routine_end:
002386 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
002387 0bbd                      	sbc r27, r29
                                 
002388 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002389 937f                      	push r23
00238a 9160 285b                 	lds r22, pulse1_fx_Pxx
00238c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00238d 9f67                      	mul r22, r23
00238e 917f                      	pop r23
00238f 916f                      	pop r22
002390 9416                      	lsr r1 //shift out the fractional bits
002391 9407                      	ror r0
002392 9416                      	lsr r1
002393 9407                      	ror r0
002394 9416                      	lsr r1
002395 9407                      	ror r0
002396 9416                      	lsr r1
002397 9407                      	ror r0
                                 
002398 0da0                      	add r26, r0
002399 1db2                      	adc r27, zero
                                 
00239a 93a0 2866                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
00239c 93b0 2867                 	sts pulse1_fx_Rxy_total_offset+1, r27
00239e 9220 2862                 	sts pulse1_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
0023a0 9220 2863                 	sts pulse1_fx_Rxy_target+1, zero
0023a2 c00a                      	rjmp sound_driver_instrument_routine_channel1_volume
                                 
                                 sound_driver_channel0_fx_Rxy_routine_add:
0023a3 91c0 2864                 	lds r28, pulse1_fx_Rxy_speed
0023a5 91d0 2865                 	lds r29, pulse1_fx_Rxy_speed+1
0023a7 0fac                      	add r26, r28 //increase the total offset by the speed
0023a8 1fbd                      	adc r27, r29
0023a9 93a0 2866                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
0023ab 93b0 2867                 	sts pulse1_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume:
0023ad 91e0 2870                 	lds ZL, pulse2_volume_macro
0023af 91f0 2871                 	lds ZH, pulse2_volume_macro+1
0023b1 9630                      	adiw Z, 0
0023b2 f1a1                      	breq sound_driver_instrument_routine_channel1_volume_default //if no volume macro is in use, use default multiplier of F
0023b3 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0023b4 1fff                      	rol ZH
0023b5 91a0 2872                 	lds r26, pulse2_volume_macro_offset
0023b7 0fea                      	add ZL, r26
0023b8 1df2                      	adc ZH, zero
                                 
0023b9 91b0 2874                 	lds r27, pulse2_volume_macro_release
0023bb 17ba                      	cp r27, r26
0023bc f429                      	brne sound_driver_instrument_routine_channel1_volume_increment //if the current offset is not equal to the release index, increment the offset
0023bd 91a0 2873                 	lds r26, pulse2_volume_macro_loop
0023bf 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0023c0 f010                      	brlo sound_driver_instrument_routine_channel1_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0023c1 c003                      	rjmp sound_driver_instrument_routine_channel1_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_volume_increment:
0023c2 95a3                      	inc r26 //increment the macro offset
0023c3 93a0 2872                 	sts pulse2_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_volume_read:
0023c5 91b4                      	lpm r27, Z //load volume data into r27
0023c6 3fbf                      	cpi r27, 0xFF //check for macro end flag
0023c7 f469                      	brne sound_driver_instrument_routine_channel1_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_release:
0023c8 91b0 2874                 	lds r27, pulse2_volume_macro_release
0023ca 3fbf                      	cpi r27, 0xFF
0023cb f429                      	brne sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_loop:
0023cc 91b0 2873                 	lds r27, pulse2_volume_macro_loop //load the loop index
0023ce 93b0 2872                 	sts pulse2_volume_macro_offset, r27 //store the loop index into the offset
0023d0 cfdc                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index:
0023d1 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
0023d2 93a0 2872                 	sts pulse2_volume_macro_offset, r26
0023d4 cfd8                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_calculate:
0023d5 e6e6                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
0023d6 e5f4                      	ldi ZH, HIGH(volumes << 1)
0023d7 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
0023d8 0feb                      	add ZL, r27 //add offset to the table
0023d9 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel1_volume_load:
0023da 91b0 2808                 	lds r27, pulse2_param //load main volume
0023dc 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
0023dd 91a0 28a4                 	lds r26, pulse2_fx_7xy_value
0023df 30a0                      	cpi r26, 0x00
0023e0 f481                      	brne sound_driver_instrument_routine_channel1_volume_load_7xy
                                 
0023e1 0feb                      	add ZL, r27 //offset the volume table by the main volume
0023e2 1df2                      	adc ZH, zero
0023e3 91b4                      	lpm r27, Z
0023e4 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
0023e6 c024                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default:
0023e7 91b0 2808                 	lds r27, pulse2_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
0023e9 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
0023ea 91a0 28a4                 	lds r26, pulse2_fx_7xy_value
0023ec 30a0                      	cpi r26, 0x00
0023ed f4a1                      	brne sound_driver_instrument_routine_channel1_volume_default_7xy
0023ee 93b0 280e                 	sts pulse2_output_volume, r27
0023f0 c01a                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy:
0023f1 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
0023f2 f040                      	brcs sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
0023f3 f039                      	breq sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
0023f4 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
                                 
0023f5 0feb                      	add ZL, r27 //offset the volume table by the main volume
0023f6 1df2                      	adc ZH, zero
0023f7 91b4                      	lpm r27, Z
0023f8 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
0023fa c010                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy_overflow:
0023fb e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
0023fc 0feb                      	add ZL, r27 //offset the volume table by the main volume
0023fd 1df2                      	adc ZH, zero
0023fe 91b4                      	lpm r27, Z
0023ff 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
002401 c009                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default_7xy:
002402 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002403 f020                      	brcs sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
002404 f019                      	breq sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
002405 93b0 280e                 	sts pulse2_output_volume, r27
002407 c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel1_volume_default_7xy_overflow:
002408 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002409 93b0 280e                 	sts pulse2_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
00240b 91e0 2875                 	lds ZL, pulse2_arpeggio_macro
00240d 91f0 2876                 	lds ZH, pulse2_arpeggio_macro+1
00240f 9630                      	adiw Z, 0
002410 f1d9                      	breq sound_driver_instrument_routine_channel1_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002411 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002412 1fff                      	rol ZH
002413 91a0 2877                 	lds r26, pulse2_arpeggio_macro_offset
002415 0fea                      	add ZL, r26
002416 1df2                      	adc ZH, zero
                                 
002417 91b0 2879                 	lds r27, pulse2_arpeggio_macro_release
002419 17ba                      	cp r27, r26
00241a f429                      	brne sound_driver_instrument_routine_channel1_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
00241b 91a0 2878                 	lds r26, pulse2_arpeggio_macro_loop
00241d 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00241e f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
00241f c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_increment:
002420 95a3                      	inc r26 //increment the macro offset
002421 93a0 2877                 	sts pulse2_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_read:
002423 91b4                      	lpm r27, Z //load arpeggio data into r27
002424 38b0                      	cpi r27, 0x80 //check for macro end flag
002425 f009                      	breq sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag
002426 c041                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_check_mode:
002427 50a1                      	subi r26, 1 //keep the offset at the end flag
002428 93a0 2877                 	sts pulse2_arpeggio_macro_offset, r26
00242a 91b0 287a                 	lds r27, pulse2_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
00242c 30b1                      	cpi r27, 0x01
00242d f048                      	brlo sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_release:
00242e 91b0 2879                 	lds r27, pulse2_arpeggio_macro_release
002430 3fbf                      	cpi r27, 0xFF
002431 f4d1                      	brne sound_driver_instrument_routine_channel1_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_loop:
002432 91b0 2878                 	lds r27, pulse2_arpeggio_macro_loop
002434 3fbf                      	cpi r27, 0xFF
002435 f499                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002436 c015                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute:
002437 91b0 2879                 	lds r27, pulse2_arpeggio_macro_release
002439 3fbf                      	cpi r27, 0xFF
00243a f421                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_check_loop:
00243b 91b0 2878                 	lds r27, pulse2_arpeggio_macro_loop //load the loop index
00243d 3fbf                      	cpi r27, 0xFF //check if loop flag exists
00243e f451                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop:
00243f 91c0 288c                 	lds r28, pulse2_fx_0xy_sequence //check for 0xy effect
002441 91d0 288d                 	lds r29, pulse2_fx_0xy_sequence+1
002443 9620                      	adiw r29:r28, 0
002444 f469                      	brne sound_driver_instrument_routine_channel1_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002445 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002446 93a0 2877                 	sts pulse2_arpeggio_macro_offset, r26 //store the last valid index into the offset
002448 cfc2                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload:
002449 93b0 2877                 	sts pulse2_arpeggio_macro_offset, r27 //store the loop index into the offset
00244b cfbf                      	rjmp sound_driver_instrument_routine_channel1_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_default:
00244c 91c0 288c                 	lds r28, pulse2_fx_0xy_sequence //load 0xy effect
00244e 91d0 288d                 	lds r29, pulse2_fx_0xy_sequence+1
002450 9620                      	adiw r29:r28, 0 //check for 0xy effect
002451 f099                      	breq sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel1_arpeggio_default_xy:
002452 95d6                      	lsr r29
002453 95c7                      	ror r28
002454 95d7                      	ror r29
002455 95c7                      	ror r28
002456 95d7                      	ror r29
002457 95c7                      	ror r28
002458 95d7                      	ror r29
002459 95c7                      	ror r28
00245a 95d7                      	ror r29
00245b 95d2                      	swap r29
                                 
00245c 93c0 288c                 	sts pulse2_fx_0xy_sequence, r28 //store the rolled sequence
00245e 93d0 288d                 	sts pulse2_fx_0xy_sequence+1, r29
002460 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002461 91a0 280f                 	lds r26, pulse2_note //load the current note index
002463 0fac                      	add r26, r28 //add the note offset
002464 c02c                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002465 91a0 280f                 	lds r26, pulse2_note //load the current note index
002467 c029                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process:
002468 9220 287b                 	sts pulse2_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
00246a 9220 2881                 	sts pulse2_total_hi_pitch_offset, zero
00246c 91a0 287a                 	lds r26, pulse2_arpeggio_macro_mode
00246e 30a1                      	cpi r26, 0x01 //absolute mode
00246f f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_absolute
002470 f069                      	breq sound_driver_instrument_routine_channel1_arpeggio_process_fixed
002471 c00e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute:
002472 91a0 280f                 	lds r26, pulse2_note //load the current note index
002474 0fab                      	add r26, r27 //offset the note with the arpeggio data
002475 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002476 c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_add:
002477 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002478 f0c0                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
002479 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
00247a c016                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract:
00247b fda7                      	sbrc r26, 7 //check if result is negative
00247c e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
00247d c013                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_fixed:
00247e 2fab                      	mov r26, r27 //move the arpeggio data into r26
00247f c011                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative:
002480 91a0 280f                 	lds r26, pulse2_note //load the current note index
002482 0fab                      	add r26, r27 //offset the note with the arpeggio data
002483 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002484 c008                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_add:
002485 93a0 280f                 	sts pulse2_note, r26 //NOTE: relative mode modifies the original note index
002487 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002488 f040                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
002489 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
00248a 93a0 280f                 	sts pulse2_note, r26
00248c c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract:
00248d fda7                      	sbrc r26, 7 //check if result is negative
00248e e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
00248f 93a0 280f                 	sts pulse2_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_load:
002491 e6e8                      	ldi ZL, LOW(note_table << 1) //load in note table
002492 e0f0                      	ldi ZH, HIGH(note_table << 1)
002493 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002494 0fea                      	add ZL, r26 //add offset
002495 1df2                      	adc ZH, zero
002496 91a5                      	lpm r26, Z+ //load bytes
002497 91b4                      	lpm r27, Z
002498 93a0 0a9c                 	sts TCB1_CCMPL, r26 //load the LOW bits for timer
00249a 93b0 0a9d                 	sts TCB1_CCMPH, r27 //load the HIGH bits for timer
00249c 93a0 2898                 	sts pulse2_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
00249e 93b0 2899                 	sts pulse2_fx_3xx_target+1, r27
0024a0 c000                      	rjmp sound_driver_instrument_routine_channel1_pitch
                                 
                                 
                                 
                                 //NOTE: There is a limitation with the pitch routines in that the total pitch can not be offset by 127 in both,
                                 //the positive and negative direction, from the original note pitch. This shouldn't be too much of a problem as
                                 //most songs that use instruments with the pitch macro, do not stray that far from the original note pitch.
                                 //In the case of hi pitch, the total pitch can not be offset by 127*16 from the original pitch. This is also
                                 //not a big deal as you can easily reach the entire note range with an offset of up to 127*16.
                                 sound_driver_instrument_routine_channel1_pitch:
0024a1 91e0 287c                 	lds ZL, pulse2_pitch_macro
0024a3 91f0 287d                 	lds ZH, pulse2_pitch_macro+1
0024a5 9630                      	adiw Z, 0
0024a6 f409                      	brne sound_driver_instrument_routine_channel1_pitch_continue
0024a7 c023                      	rjmp sound_driver_instrument_routine_channel1_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel1_pitch_continue:
0024a8 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0024a9 1fff                      	rol ZH
0024aa 91a0 287e                 	lds r26, pulse2_pitch_macro_offset
0024ac 0fea                      	add ZL, r26
0024ad 1df2                      	adc ZH, zero
                                 
0024ae 91b0 2880                 	lds r27, pulse2_pitch_macro_release
0024b0 17ba                      	cp r27, r26
0024b1 f429                      	brne sound_driver_instrument_routine_channel1_pitch_increment //if the current offset is not equal to the release index, increment the offset
0024b2 91a0 287f                 	lds r26, pulse2_pitch_macro_loop
0024b4 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0024b5 f010                      	brlo sound_driver_instrument_routine_channel1_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0024b6 c003                      	rjmp sound_driver_instrument_routine_channel1_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_pitch_increment:
0024b7 95a3                      	inc r26 //increment the macro offset
0024b8 93a0 287e                 	sts pulse2_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_pitch_read:
0024ba 91b4                      	lpm r27, Z //load pitch data into r27
0024bb 38b0                      	cpi r27, 0x80 //check for macro end flag
0024bc f489                      	brne sound_driver_instrument_routine_channel1_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_release:
0024bd 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0024be 93a0 287e                 	sts pulse2_pitch_macro_offset, r26
0024c0 91b0 2880                 	lds r27, pulse2_pitch_macro_release
0024c2 3fbf                      	cpi r27, 0xFF
0024c3 f439                      	brne sound_driver_instrument_routine_channel1_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_loop:
0024c4 91b0 287f                 	lds r27, pulse2_pitch_macro_loop //load the loop index
0024c6 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0024c7 f019                      	breq sound_driver_instrument_routine_channel1_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
0024c8 93b0 287e                 	sts pulse2_pitch_macro_offset, r27 //store the loop index into the offset
0024ca cfd6                      	rjmp sound_driver_instrument_routine_channel1_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_default:
0024cb 91b0 287b                 	lds r27, pulse2_total_pitch_offset
0024cd c005                      	rjmp sound_driver_instrument_routine_channel1_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate:
0024ce 91a0 287b                 	lds r26, pulse2_total_pitch_offset //load the total pitch offset to change
0024d0 0fba                      	add r27, r26
0024d1 93b0 287b                 	sts pulse2_total_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_multiply:
                                 	//NOTE: The Pxx effect is processed with the pitch instrument macro because the calculations are the same
0024d3 91a0 28a8                 	lds r26, pulse2_fx_Pxx
0024d5 0fba                      	add r27, r26
                                 
0024d6 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0024d7 937f                      	push r23
0024d8 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
0024d9 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0024da 0367                      	mulsu r22, r23
0024db 917f                      	pop r23
0024dc 916f                      	pop r22
                                 
0024dd 9416                      	lsr r1 //shift out the fractional bits
0024de 9407                      	ror r0
0024df 9416                      	lsr r1
0024e0 9407                      	ror r0
0024e1 9416                      	lsr r1
0024e2 9407                      	ror r0
0024e3 9416                      	lsr r1
0024e4 9407                      	ror r0
0024e5 fe13                      	sbrs r1, 3 //check if result was a negative number
0024e6 c002                      	rjmp sound_driver_instrument_routine_channel1_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_negative:
0024e7 efb0                      	ldi r27, 0xF0
0024e8 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_offset:
0024e9 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
0024eb 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
0024ed 0da0                      	add r26, r0 //offset the timer values
0024ee 1db1                      	adc r27, r1
                                 	
0024ef 91c0 2890                 	lds r28, pulse2_fx_1xx_total
0024f1 91d0 2891                 	lds r29, pulse2_fx_1xx_total+1
0024f3 1bac                      	sub r26, r28
0024f4 0bbd                      	sbc r27, r29
0024f5 91c0 2894                 	lds r28, pulse2_fx_2xx_total
0024f7 91d0 2895                 	lds r29, pulse2_fx_2xx_total+1
0024f9 0fac                      	add r26, r28
0024fa 1fbd                      	adc r27, r29
0024fb 91c0 28ad                 	lds r28, pulse2_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
0024fd 91d0 28ae                 	lds r29, pulse2_fx_Qxy_total_offset+1
0024ff 1bac                      	sub r26, r28
002500 0bbd                      	sbc r27, r29
002501 91c0 28b3                 	lds r28, pulse2_fx_Rxy_total_offset
002503 91d0 28b4                 	lds r29, pulse2_fx_Rxy_total_offset+1
002505 0fac                      	add r26, r28
002506 1fbd                      	adc r27, r29
                                 
002507 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
002509 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel1_hi_pitch:
00250b 91e0 2882                 	lds ZL, pulse2_hi_pitch_macro
00250d 91f0 2883                 	lds ZH, pulse2_hi_pitch_macro+1
00250f 9630                      	adiw Z, 0
002510 f409                      	brne sound_driver_instrument_routine_channel1_hi_pitch_continue
002511 c03c                      	rjmp sound_driver_instrument_routine_channel1_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel1_hi_pitch_continue:
002512 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002513 1fff                      	rol ZH
002514 91a0 2884                 	lds r26, pulse2_hi_pitch_macro_offset
002516 0fea                      	add ZL, r26
002517 1df2                      	adc ZH, zero
                                 
002518 91b0 2886                 	lds r27, pulse2_hi_pitch_macro_release
00251a 17ba                      	cp r27, r26
00251b f429                      	brne sound_driver_instrument_routine_channel1_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
00251c 91a0 2885                 	lds r26, pulse2_hi_pitch_macro_loop
00251e 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00251f f010                      	brlo sound_driver_instrument_routine_channel1_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002520 c003                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_increment:
002521 95a3                      	inc r26 //increment the macro offset
002522 93a0 2884                 	sts pulse2_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_hi_pitch_read:
002524 91b4                      	lpm r27, Z //load hi pitch data into r27
002525 38b0                      	cpi r27, 0x80 //check for macro end flag
002526 f489                      	brne sound_driver_instrument_routine_channel1_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_release:
002527 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002528 93a0 2884                 	sts pulse2_hi_pitch_macro_offset, r26
00252a 91b0 2886                 	lds r27, pulse2_hi_pitch_macro_release
00252c 3fbf                      	cpi r27, 0xFF
00252d f439                      	brne sound_driver_instrument_routine_channel1_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_loop:
00252e 91b0 2885                 	lds r27, pulse2_hi_pitch_macro_loop //load the loop index
002530 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002531 f019                      	breq sound_driver_instrument_routine_channel1_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002532 93b0 2884                 	sts pulse2_hi_pitch_macro_offset, r27 //store the loop index into the offset
002534 cfd6                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_default:
002535 91b0 2881                 	lds r27, pulse2_total_hi_pitch_offset
002537 c005                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate:
002538 91a0 2881                 	lds r26, pulse2_total_hi_pitch_offset //load the total hi pitch offset to change
00253a 0fba                      	add r27, r26
00253b 93b0 2881                 	sts pulse2_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply:
00253d 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00253e 937f                      	push r23
00253f 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002540 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002541 0367                      	mulsu r22, r23
002542 917f                      	pop r23
002543 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_offset:
002544 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
002546 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
002548 0da0                      	add r26, r0 //offset the timer values
002549 1db1                      	adc r27, r1
00254a 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
00254c 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel1_duty:
00254e 91e0 2887                 	lds ZL, pulse2_duty_macro
002550 91f0 2888                 	lds ZH, pulse2_duty_macro+1
002552 9630                      	adiw Z, 0
002553 f1b1                      	breq sound_driver_channel1_fx_routines //if no duty macro is in use, go to the next routine
002554 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002555 1fff                      	rol ZH
002556 91a0 2889                 	lds r26, pulse2_duty_macro_offset
002558 0fea                      	add ZL, r26
002559 1df2                      	adc ZH, zero
                                 
00255a 91b0 288b                 	lds r27, pulse2_duty_macro_release
00255c 17ba                      	cp r27, r26
00255d f429                      	brne sound_driver_instrument_routine_channel1_duty_increment //if the current offset is not equal to the release index, increment the offset
00255e 91a0 288a                 	lds r26, pulse2_duty_macro_loop
002560 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002561 f010                      	brlo sound_driver_instrument_routine_channel1_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002562 c027                      	rjmp sound_driver_channel1_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel1_duty_increment:
002563 95a3                      	inc r26 //increment the macro offset
002564 93a0 2889                 	sts pulse2_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_duty_read:
002566 91b4                      	lpm r27, Z //load pitch data into r27
002567 3fbf                      	cpi r27, 0xFF //check for macro end flag
002568 f471                      	brne sound_driver_instrument_routine_channel1_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_release:
002569 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00256a 93a0 2889                 	sts pulse2_duty_macro_offset, r26
00256c 91b0 288b                 	lds r27, pulse2_duty_macro_release
00256e 3fbf                      	cpi r27, 0xFF
00256f f4d1                      	brne sound_driver_channel1_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_loop:
002570 91b0 288a                 	lds r27, pulse2_duty_macro_loop //load the loop index
002572 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002573 f0b1                      	breq sound_driver_channel1_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
002574 93b0 2889                 	sts pulse2_duty_macro_offset, r27 //store the loop index into the offset
002576 cfd7                      	rjmp sound_driver_instrument_routine_channel1_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_load:
002577 ece6                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
002578 e5f3                      	ldi ZH, HIGH(sequences << 1)
002579 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
00257a 1df2                      	adc ZH, zero
                                 
00257b 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
00257c 95b7                      	ror r27
00257d 95b7                      	ror r27
00257e 91a0 2808                 	lds r26, pulse2_param //load r26 with pulse2_param (register $4000)
002580 2fca                      	mov r28, r26 //store a copy of pulse2_param into r28
002581 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
002582 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
002583 c001                      	rjmp sound_driver_instrument_routine_channel1_duty_load_store
002584 c005                      	rjmp sound_driver_channel1_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel1_duty_load_store:
002585 90d4                      	lpm pulse2_sequence, Z //store the sequence
                                 
002586 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
002587 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
002588 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_routines:
                                 sound_driver_channel1_fx_1xx_routine:
00258a 91e0 288e                 	lds ZL, pulse2_fx_1xx
00258c 91f0 288f                 	lds ZH, pulse2_fx_1xx+1
00258e 9630                      	adiw Z, 0
00258f f051                      	breq sound_driver_channel1_fx_2xx_routine
                                 
002590 91a0 2890                 	lds r26, pulse2_fx_1xx_total //load the rate to change the pitch by
002592 91b0 2891                 	lds r27, pulse2_fx_1xx_total+1
002594 0fae                      	add r26, ZL //increase the total offset by the rate
002595 1fbf                      	adc r27, ZH
002596 93a0 2890                 	sts pulse2_fx_1xx_total, r26
002598 93b0 2891                 	sts pulse2_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_2xx_routine:
00259a 91e0 2892                 	lds ZL, pulse2_fx_2xx
00259c 91f0 2893                 	lds ZH, pulse2_fx_2xx+1
00259e 9630                      	adiw Z, 0
00259f f051                      	breq sound_driver_channel1_fx_3xx_routine
                                 
0025a0 91a0 2894                 	lds r26, pulse2_fx_2xx_total //load the rate to change the pitch by
0025a2 91b0 2895                 	lds r27, pulse2_fx_2xx_total+1
0025a4 0fae                      	add r26, ZL //increase the total offset by the rate
0025a5 1fbf                      	adc r27, ZH
0025a6 93a0 2894                 	sts pulse2_fx_2xx_total, r26
0025a8 93b0 2895                 	sts pulse2_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_3xx_routine:
0025aa 91e0 289a                 	lds ZL, pulse2_fx_3xx_speed
0025ac 91f0 289b                 	lds ZH, pulse2_fx_3xx_speed+1
0025ae 9630                      	adiw Z, 0
0025af f409                      	brne sound_driver_channel1_fx_3xx_routine_check_start
0025b0 c048                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_check_start:
0025b1 91a0 2896                 	lds r26, pulse2_fx_3xx_start
0025b3 91b0 2897                 	lds r27, pulse2_fx_3xx_start+1
0025b5 9610                      	adiw r26:r27, 0
0025b6 f409                      	brne sound_driver_channel1_fx_3xx_routine_main
0025b7 c041                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_main:
0025b8 91c0 2898                 	lds r28, pulse2_fx_3xx_target
0025ba 91d0 2899                 	lds r29, pulse2_fx_3xx_target+1
                                 
0025bc 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
0025bd 07bd                      	cpc r27, r29
0025be f011                      	breq sound_driver_channel1_fx_3xx_routine_disable
0025bf f030                      	brlo sound_driver_channel1_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
0025c0 c01f                      	rjmp sound_driver_channel1_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel1_fx_3xx_routine_disable:
0025c1 9220 2896                 	sts pulse2_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
0025c3 9220 2897                 	sts pulse2_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
0025c5 c033                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_subtract:
0025c6 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
0025c7 0bdb                      	sbc r29, r27
0025c8 91a0 289c                 	lds r26, pulse2_fx_3xx_total_offset
0025ca 91b0 289d                 	lds r27, pulse2_fx_3xx_total_offset+1
                                 
0025cc 0fae                      	add r26, ZL //add the speed to the total offset
0025cd 1fbf                      	adc r27, ZH
0025ce 1bca                      	sub r28, r26 //invert the total difference with the total offset
0025cf 0bdb                      	sbc r29, r27
0025d0 f380                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0025d1 93a0 289c                 	sts pulse2_fx_3xx_total_offset, r26 //store the new total offset
0025d3 93b0 289d                 	sts pulse2_fx_3xx_total_offset+1, r27
                                 
0025d5 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the current timer period
0025d7 91b0 0a9d                 	lds r27, TCB1_CCMPH
0025d9 1bac                      	sub r26, r28 //offset the current timer period with the total offset
0025da 0bbd                      	sbc r27, r29
0025db 93a0 0a9c                 	sts TCB1_CCMPL, r26
0025dd 93b0 0a9d                 	sts TCB1_CCMPH, r27
0025df c019                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_add:
0025e0 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
0025e1 0bbd                      	sbc r27, r29
0025e2 91c0 289c                 	lds r28, pulse2_fx_3xx_total_offset
0025e4 91d0 289d                 	lds r29, pulse2_fx_3xx_total_offset+1
                                 
0025e6 0fce                      	add r28, ZL //add the speed to the total offset
0025e7 1fdf                      	adc r29, ZH
0025e8 1bac                      	sub r26, r28 //invert the total difference with the total offset
0025e9 0bbd                      	sbc r27, r29
0025ea f2b0                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0025eb 93c0 289c                 	sts pulse2_fx_3xx_total_offset, r28 //store the new total offset
0025ed 93d0 289d                 	sts pulse2_fx_3xx_total_offset+1, r29
                                 
0025ef 91c0 0a9c                 	lds r28, TCB1_CCMPL //load the current timer period
0025f1 91d0 0a9d                 	lds r29, TCB1_CCMPH
0025f3 0fca                      	add r28, r26 //offset the current timer period with the total offset
0025f4 1fdb                      	adc r29, r27
0025f5 93c0 0a9c                 	sts TCB1_CCMPL, r28
0025f7 93d0 0a9d                 	sts TCB1_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel1_fx_4xy_routine:
0025f9 91a0 289e                 	lds r26, pulse2_fx_4xy_speed
0025fb 15a2                      	cp r26, zero
0025fc f409                      	brne sound_driver_channel1_fx_4xy_routine_continue
0025fd c05c                      	rjmp sound_driver_channel1_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel1_fx_4xy_routine_continue:
0025fe 91b0 289f                 	lds r27, pulse2_fx_4xy_depth
002600 91c0 28a0                 	lds r28, pulse2_fx_4xy_phase
002602 0fca                      	add r28, r26 //increase the phase by the speed
002603 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
002604 f008                      	brlo sound_driver_channel1_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002605 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase:
002606 93c0 28a0                 	sts pulse2_fx_4xy_phase, r28 //store the new phase
002608 31c0                      	cpi r28, 16
002609 f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_0
00260a 32c0                      	cpi r28, 32
00260b f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_1
00260c 33c0                      	cpi r28, 48
00260d f030                      	brlo sound_driver_channel1_fx_4xy_routine_phase_2
00260e c007                      	rjmp sound_driver_channel1_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_0:
00260f 70cf                      	andi r28, 0x0F //mask for values 0-15
002610 c029                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_1:
002611 6fc0                      	ori r28, 0xF0
002612 95c0                      	com r28 //invert values 0-15
002613 c026                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_2:
002614 70cf                      	andi r28, 0x0F //mask for values 0-15
002615 c003                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_3:
002616 6fc0                      	ori r28, 0xF0
002617 95c0                      	com r28 //invert values 0-15
002618 c000                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_add:
002619 95b2                      	swap r27 //multiply depth by 16
00261a 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
00261b e1e6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00261c e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00261d 0fec                      	add ZL, r28 //offset the table by the depth+phase
00261e 1df2                      	adc ZH, zero
00261f 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002620 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002621 937f                      	push r23
002622 2f6c                      	mov r22, r28 //store the vibrato value into r22
002623 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002624 9f67                      	mul r22, r23
002625 917f                      	pop r23
002626 916f                      	pop r22
                                 
002627 9416                      	lsr r1 //shift out the fractional bits
002628 9407                      	ror r0
002629 9416                      	lsr r1
00262a 9407                      	ror r0
00262b 9416                      	lsr r1
00262c 9407                      	ror r0
00262d 9416                      	lsr r1
00262e 9407                      	ror r0
                                 	
00262f 91a0 0a9c                 	lds r26, TCB1_CCMPL
002631 91b0 0a9d                 	lds r27, TCB1_CCMPH
002633 0da0                      	add r26, r0
002634 1db1                      	adc r27, r1
002635 93a0 0a9c                 	sts TCB1_CCMPL, r26
002637 93b0 0a9d                 	sts TCB1_CCMPH, r27
002639 c020                      	rjmp sound_driver_channel1_fx_7xy_routine
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_subtract:
00263a 95b2                      	swap r27 //multiply depth by 16
00263b 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
00263c e1e6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00263d e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00263e 0fec                      	add ZL, r28 //offset the table by the depth+phase
00263f 1df2                      	adc ZH, zero
002640 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002641 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002642 937f                      	push r23
002643 2f6c                      	mov r22, r28 //store the vibrato value into r22
002644 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002645 9f67                      	mul r22, r23
002646 917f                      	pop r23
002647 916f                      	pop r22
                                 
002648 9416                      	lsr r1 //shift out the fractional bits
002649 9407                      	ror r0
00264a 9416                      	lsr r1
00264b 9407                      	ror r0
00264c 9416                      	lsr r1
00264d 9407                      	ror r0
00264e 9416                      	lsr r1
00264f 9407                      	ror r0
                                 
002650 91a0 0a9c                 	lds r26, TCB1_CCMPL
002652 91b0 0a9d                 	lds r27, TCB1_CCMPH
002654 19a0                      	sub r26, r0
002655 09b1                      	sbc r27, r1
002656 93a0 0a9c                 	sts TCB1_CCMPL, r26
002658 93b0 0a9d                 	sts TCB1_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_7xy_routine:
00265a 91a0 28a1                 	lds r26, pulse2_fx_7xy_speed
00265c 15a2                      	cp r26, zero
00265d f0f1                      	breq sound_driver_channel1_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
00265e 91b0 28a2                 	lds r27, pulse2_fx_7xy_depth
002660 91c0 28a3                 	lds r28, pulse2_fx_7xy_phase
002662 0fca                      	add r28, r26 //increase the phase by the speed
002663 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
002664 f010                      	brlo sound_driver_channel1_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
002665 e0c0                      	ldi r28, 0x00
002666 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase:
002667 93c0 28a3                 	sts pulse2_fx_7xy_phase, r28 //store the new phase
002669 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
00266a ffc4                      	sbrs r28, 4
00266b c001                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_0
00266c c002                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel1_fx_7xy_routine_phase_0:
00266d 70cf                      	andi r28, 0x0F //mask for values 0-15
00266e c003                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase_1:
00266f 6fc0                      	ori r28, 0xF0
002670 95c0                      	com r28 //invert values 0-15
002671 c000                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_load:
002672 95b2                      	swap r27 //multiply depth by 16
002673 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002674 e1e6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002675 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002676 0fec                      	add ZL, r28 //offset the table by the depth+phase
002677 1df2                      	adc ZH, zero
002678 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002679 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
00267a 93c0 28a4                 	sts pulse2_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Axy_routine:
00267c 91b0 28a5                 	lds r27, pulse2_fx_Axy
00267e 15b2                      	cp r27, zero
00267f f0e9                      	breq sound_driver_channel1_fx_Qxy_routine //0 means that the effect is not in use
                                 	
002680 91a0 280d                 	lds r26, pulse2_fractional_volume //load fractional volume representation of the channel
002682 91c0 2808                 	lds r28, pulse2_param //load the integer volume representation of the channel
002684 2fda                      	mov r29, r26 //copy fractional volume into r29
002685 2fec                      	mov r30, r28 //copy the pulse2_param into r30
002686 95e2                      	swap r30
002687 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
002688 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
002689 17ed                      	cp r30, r29 //compare the fractional and integer volumes
00268a f009                      	breq sound_driver_channel1_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel1_fx_Axy_routine_reload:
00268b 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate:
00268c fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
00268d c004                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_addition:
00268e 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
00268f f428                      	brcc sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002690 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
002691 c003                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_subtraction:
002692 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002693 f008                      	brcs sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002694 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_store:
002695 93a0 280d                 	sts pulse2_fractional_volume, r26 //store the new fractional volume
002697 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
002698 95a2                      	swap r26
002699 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
00269a 2bca                      	or r28, r26 //store the new volume back into pulse2_param
00269b 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel1_fx_Qxy_routine:
00269d 91e0 28a9                 	lds ZL, pulse2_fx_Qxy_target
00269f 91f0 28aa                 	lds ZH, pulse2_fx_Qxy_target+1
0026a1 9630                      	adiw Z, 0
0026a2 f199                      	breq sound_driver_channel1_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
0026a3 91a0 28ad                 	lds r26, pulse2_fx_Qxy_total_offset
0026a5 91b0 28ae                 	lds r27, pulse2_fx_Qxy_total_offset+1
0026a7 91c0 0a9c                 	lds r28, TCB1_CCMPL
0026a9 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
0026ab 1bec                      	sub ZL, r28 //calculate the difference to the target
0026ac 0bfd                      	sbc ZH, r29
0026ad f408                      	brsh sound_driver_channel1_fx_Qxy_routine_end //if the target has been reached (or passed)
0026ae f0e8                      	brlo sound_driver_channel1_fx_Qxy_routine_add
                                 
                                 sound_driver_channel1_fx_Qxy_routine_end:
0026af 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
0026b0 0bbf                      	sbc r27, ZH
                                 
0026b1 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0026b2 937f                      	push r23
0026b3 9160 28a8                 	lds r22, pulse2_fx_Pxx
0026b5 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0026b6 9f67                      	mul r22, r23
0026b7 917f                      	pop r23
0026b8 916f                      	pop r22
0026b9 9416                      	lsr r1 //shift out the fractional bits
0026ba 9407                      	ror r0
0026bb 9416                      	lsr r1
0026bc 9407                      	ror r0
0026bd 9416                      	lsr r1
0026be 9407                      	ror r0
0026bf 9416                      	lsr r1
0026c0 9407                      	ror r0
                                 
0026c1 0da0                      	add r26, r0
0026c2 1db2                      	adc r27, zero
                                 
0026c3 93a0 28ad                 	sts pulse2_fx_Qxy_total_offset, r26 //store the total offset
0026c5 93b0 28ae                 	sts pulse2_fx_Qxy_total_offset+1, r27
0026c7 9220 28a9                 	sts pulse2_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
0026c9 9220 28aa                 	sts pulse2_fx_Qxy_target+1, zero
0026cb c00a                      	rjmp sound_driver_channel1_fx_Rxy_routine
                                 
                                 sound_driver_channel1_fx_Qxy_routine_add:
0026cc 91c0 28ab                 	lds r28, pulse2_fx_Qxy_speed
0026ce 91d0 28ac                 	lds r29, pulse2_fx_Qxy_speed+1
0026d0 0fac                      	add r26, r28 //increase the total offset by the speed
0026d1 1fbd                      	adc r27, r29
0026d2 93a0 28ad                 	sts pulse2_fx_Qxy_total_offset, r26 //store the total offset
0026d4 93b0 28ae                 	sts pulse2_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Rxy_routine:
0026d6 91e0 28af                 	lds ZL, pulse2_fx_Rxy_target
0026d8 91f0 28b0                 	lds ZH, pulse2_fx_Rxy_target+1
0026da 9630                      	adiw Z, 0
0026db f199                      	breq sound_driver_instrument_routine_channel2_volume //if the effect is not enabled, skip the routine
                                 
0026dc 91a0 28b3                 	lds r26, pulse2_fx_Rxy_total_offset
0026de 91b0 28b4                 	lds r27, pulse2_fx_Rxy_total_offset+1
0026e0 91c0 0a9c                 	lds r28, TCB1_CCMPL
0026e2 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
0026e4 1bce                      	sub r28, ZL //calculate the difference to the target
0026e5 0bdf                      	sbc r29, ZH
0026e6 f408                      	brsh sound_driver_channel1_fx_Rxy_routine_end //if the target has been reached (or passed)
0026e7 f0e8                      	brlo sound_driver_channel1_fx_Rxy_routine_add
                                 
                                 sound_driver_channel1_fx_Rxy_routine_end:
0026e8 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
0026e9 0bbd                      	sbc r27, r29
                                 
0026ea 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0026eb 937f                      	push r23
0026ec 9160 28a8                 	lds r22, pulse2_fx_Pxx
0026ee eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0026ef 9f67                      	mul r22, r23
0026f0 917f                      	pop r23
0026f1 916f                      	pop r22
0026f2 9416                      	lsr r1 //shift out the fractional bits
0026f3 9407                      	ror r0
0026f4 9416                      	lsr r1
0026f5 9407                      	ror r0
0026f6 9416                      	lsr r1
0026f7 9407                      	ror r0
0026f8 9416                      	lsr r1
0026f9 9407                      	ror r0
                                 
0026fa 0da0                      	add r26, r0
0026fb 1db2                      	adc r27, zero
                                 
0026fc 93a0 28b3                 	sts pulse2_fx_Rxy_total_offset, r26 //store the total offset
0026fe 93b0 28b4                 	sts pulse2_fx_Rxy_total_offset+1, r27
002700 9220 28af                 	sts pulse2_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
002702 9220 28b0                 	sts pulse2_fx_Rxy_target+1, zero
002704 c00a                      	rjmp sound_driver_instrument_routine_channel2_volume
                                 
                                 sound_driver_channel1_fx_Rxy_routine_add:
002705 91c0 28b1                 	lds r28, pulse2_fx_Rxy_speed
002707 91d0 28b2                 	lds r29, pulse2_fx_Rxy_speed+1
002709 0fac                      	add r26, r28 //increase the total offset by the speed
00270a 1fbd                      	adc r27, r29
00270b 93a0 28b3                 	sts pulse2_fx_Rxy_total_offset, r26 //store the total offset
00270d 93b0 28b4                 	sts pulse2_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume:
00270f 91e0 28bd                 	lds ZL, triangle_volume_macro
002711 91f0 28be                 	lds ZH, triangle_volume_macro+1
002713 9630                      	adiw Z, 0
002714 f199                      	breq sound_driver_instrument_routine_channel2_volume_default //if no volume macro is in use, do nothing
002715 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002716 1fff                      	rol ZH
002717 91a0 28bf                 	lds r26, triangle_volume_macro_offset
002719 0fea                      	add ZL, r26
00271a 1df2                      	adc ZH, zero
                                 
00271b 91b0 28c1                 	lds r27, triangle_volume_macro_release
00271d 17ba                      	cp r27, r26
00271e f429                      	brne sound_driver_instrument_routine_channel2_volume_increment //if the current offset is not equal to the release index, increment the offset
00271f 91a0 28c0                 	lds r26, triangle_volume_macro_loop
002721 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002722 f010                      	brlo sound_driver_instrument_routine_channel2_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002723 c003                      	rjmp sound_driver_instrument_routine_channel2_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_volume_increment:
002724 95a3                      	inc r26 //increment the macro offset
002725 93a0 28bf                 	sts triangle_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_volume_read:
002727 91b4                      	lpm r27, Z //load volume data into r27
002728 3fbf                      	cpi r27, 0xFF //check for macro end flag
002729 f469                      	brne sound_driver_instrument_routine_channel2_volume_process //if the data was not the macro end flag
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_release:
00272a 91b0 28c1                 	lds r27, triangle_volume_macro_release
00272c 3fbf                      	cpi r27, 0xFF
00272d f429                      	brne sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_loop:
00272e 91b0 28c0                 	lds r27, triangle_volume_macro_loop //load the loop index
002730 93b0 28bf                 	sts triangle_volume_macro_offset, r27 //store the loop index into the offset
002732 cfdc                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index:
002733 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002734 93a0 28bf                 	sts triangle_volume_macro_offset, r26
002736 cfd8                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_process:
002737 15b2                      	cp r27, zero
002738 f041                      	breq sound_driver_instrument_routine_channel2_volume_process_disable
                                 sound_driver_instrument_routine_channel2_volume_process_enable:
002739 91b0 0aa5                 	lds r27, TCB2_INTCTRL
00273b 30b1                      	cpi r27, TCB_CAPT_bm
00273c f459                      	brne sound_driver_instrument_routine_channel2_volume_default //if the channel has already been muted, don't enable it again
00273d e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
00273e 93b0 0aa5                 	sts TCB2_INTCTRL, r27
002740 c007                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 sound_driver_instrument_routine_channel2_volume_process_disable:
002741 9220 0aa5                 	sts TCB2_INTCTRL, zero
002743 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
002745 9220 0aad                 	sts TCB2_CCMPH, zero
002747 c000                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_volume_default:
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002748 91e0 28c2                 	lds ZL, triangle_arpeggio_macro
00274a 91f0 28c3                 	lds ZH, triangle_arpeggio_macro+1
00274c 9630                      	adiw Z, 0
00274d f1d9                      	breq sound_driver_instrument_routine_channel2_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
00274e 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
00274f 1fff                      	rol ZH
002750 91a0 28c4                 	lds r26, triangle_arpeggio_macro_offset
002752 0fea                      	add ZL, r26
002753 1df2                      	adc ZH, zero
                                 
002754 91b0 28c6                 	lds r27, triangle_arpeggio_macro_release
002756 17ba                      	cp r27, r26
002757 f429                      	brne sound_driver_instrument_routine_channel2_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002758 91a0 28c5                 	lds r26, triangle_arpeggio_macro_loop
00275a 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00275b f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
00275c c003                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_increment:
00275d 95a3                      	inc r26 //increment the macro offset
00275e 93a0 28c4                 	sts triangle_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_read:
002760 91b4                      	lpm r27, Z //load arpeggio data into r27
002761 38b0                      	cpi r27, 0x80 //check for macro end flag
002762 f009                      	breq sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag
002763 c041                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_check_mode:
002764 50a1                      	subi r26, 1 //keep the offset at the end flag
002765 93a0 28c4                 	sts triangle_arpeggio_macro_offset, r26
002767 91b0 28c7                 	lds r27, triangle_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002769 30b1                      	cpi r27, 0x01
00276a f048                      	brlo sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_release:
00276b 91b0 28c6                 	lds r27, triangle_arpeggio_macro_release
00276d 3fbf                      	cpi r27, 0xFF
00276e f4d1                      	brne sound_driver_instrument_routine_channel2_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_loop:
00276f 91b0 28c5                 	lds r27, triangle_arpeggio_macro_loop
002771 3fbf                      	cpi r27, 0xFF
002772 f499                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002773 c015                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute:
002774 91b0 28c6                 	lds r27, triangle_arpeggio_macro_release
002776 3fbf                      	cpi r27, 0xFF
002777 f421                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_check_loop:
002778 91b0 28c5                 	lds r27, triangle_arpeggio_macro_loop //load the loop index
00277a 3fbf                      	cpi r27, 0xFF //check if loop flag exists
00277b f451                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop:
00277c 91c0 28d9                 	lds r28, triangle_fx_0xy_sequence //check for 0xy effect
00277e 91d0 28da                 	lds r29, triangle_fx_0xy_sequence+1
002780 9620                      	adiw r29:r28, 0
002781 f469                      	brne sound_driver_instrument_routine_channel2_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002782 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002783 93a0 28c4                 	sts triangle_arpeggio_macro_offset, r26 //store the last valid index into the offset
002785 cfc2                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload:
002786 93b0 28c4                 	sts triangle_arpeggio_macro_offset, r27 //store the loop index into the offset
002788 cfbf                      	rjmp sound_driver_instrument_routine_channel2_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_default:
002789 91c0 28d9                 	lds r28, triangle_fx_0xy_sequence //load 0xy effect
00278b 91d0 28da                 	lds r29, triangle_fx_0xy_sequence+1
00278d 9620                      	adiw r29:r28, 0 //check for 0xy effect
00278e f099                      	breq sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel2_arpeggio_default_xy:
00278f 95d6                      	lsr r29
002790 95c7                      	ror r28
002791 95d7                      	ror r29
002792 95c7                      	ror r28
002793 95d7                      	ror r29
002794 95c7                      	ror r28
002795 95d7                      	ror r29
002796 95c7                      	ror r28
002797 95d7                      	ror r29
002798 95d2                      	swap r29
                                 
002799 93c0 28d9                 	sts triangle_fx_0xy_sequence, r28 //store the rolled sequence
00279b 93d0 28da                 	sts triangle_fx_0xy_sequence+1, r29
00279d 70cf                      	andi r28, 0x0F //mask out the 4 LSB
00279e 91a0 2812                 	lds r26, triangle_note //load the current note index
0027a0 0fac                      	add r26, r28 //add the note offset
0027a1 c02c                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
0027a2 91a0 2812                 	lds r26, triangle_note //load the current note index
0027a4 c029                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process:
0027a5 9220 28c8                 	sts triangle_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
0027a7 9220 28ce                 	sts triangle_total_hi_pitch_offset, zero
0027a9 91a0 28c7                 	lds r26, triangle_arpeggio_macro_mode
0027ab 30a1                      	cpi r26, 0x01 //absolute mode
0027ac f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_absolute
0027ad f069                      	breq sound_driver_instrument_routine_channel2_arpeggio_process_fixed
0027ae c00e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute:
0027af 91a0 2812                 	lds r26, triangle_note //load the current note index
0027b1 0fab                      	add r26, r27 //offset the note with the arpeggio data
0027b2 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0027b3 c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_add:
0027b4 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0027b5 f0c0                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
0027b6 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0027b7 c016                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract:
0027b8 fda7                      	sbrc r26, 7 //check if result is negative
0027b9 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0027ba c013                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_fixed:
0027bb 2fab                      	mov r26, r27 //move the arpeggio data into r26
0027bc c011                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative:
0027bd 91a0 2812                 	lds r26, triangle_note //load the current note index
0027bf 0fab                      	add r26, r27 //offset the note with the arpeggio data
0027c0 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0027c1 c008                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_add:
0027c2 93a0 2812                 	sts triangle_note, r26 //NOTE: relative mode modifies the original note index
0027c4 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0027c5 f040                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
0027c6 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0027c7 93a0 2812                 	sts triangle_note, r26
0027c9 c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract:
0027ca fda7                      	sbrc r26, 7 //check if result is negative
0027cb e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0027cc 93a0 2812                 	sts triangle_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_load:
0027ce e6e8                      	ldi ZL, LOW(note_table << 1) //load in note table
0027cf e0f0                      	ldi ZH, HIGH(note_table << 1)
0027d0 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
0027d1 0fea                      	add ZL, r26 //add offset
0027d2 1df2                      	adc ZH, zero
0027d3 91a5                      	lpm r26, Z+ //load bytes
0027d4 91b4                      	lpm r27, Z
0027d5 93a0 0aac                 	sts TCB2_CCMPL, r26 //load the LOW bits for timer
0027d7 93b0 0aad                 	sts TCB2_CCMPH, r27 //load the HIGH bits for timer
0027d9 93a0 28e5                 	sts triangle_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
0027db 93b0 28e6                 	sts triangle_fx_3xx_target+1, r27
0027dd c000                      	rjmp sound_driver_instrument_routine_channel2_pitch
                                 
                                 
                                 
                                 //NOTE: There is a limitation with the pitch routines in that the total pitch can not be offset by 127 in both,
                                 //the positive and negative direction, from the original note pitch. This shouldn't be too much of a problem as
                                 //most songs that use instruments with the pitch macro, do not stray that far from the original note pitch.
                                 //In the case of hi pitch, the total pitch can not be offset by 127*16 from the original pitch. This is also
                                 //not a big deal as you can easily reach the entire note range with an offset of up to 127*16.
                                 sound_driver_instrument_routine_channel2_pitch:
0027de 91e0 28c9                 	lds ZL, triangle_pitch_macro
0027e0 91f0 28ca                 	lds ZH, triangle_pitch_macro+1
0027e2 9630                      	adiw Z, 0
0027e3 f409                      	brne sound_driver_instrument_routine_channel2_pitch_continue
0027e4 c023                      	rjmp sound_driver_instrument_routine_channel2_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel2_pitch_continue:
0027e5 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0027e6 1fff                      	rol ZH
0027e7 91a0 28cb                 	lds r26, triangle_pitch_macro_offset
0027e9 0fea                      	add ZL, r26
0027ea 1df2                      	adc ZH, zero
                                 
0027eb 91b0 28cd                 	lds r27, triangle_pitch_macro_release
0027ed 17ba                      	cp r27, r26
0027ee f429                      	brne sound_driver_instrument_routine_channel2_pitch_increment //if the current offset is not equal to the release index, increment the offset
0027ef 91a0 28cc                 	lds r26, triangle_pitch_macro_loop
0027f1 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0027f2 f010                      	brlo sound_driver_instrument_routine_channel2_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0027f3 c003                      	rjmp sound_driver_instrument_routine_channel2_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_pitch_increment:
0027f4 95a3                      	inc r26 //increment the macro offset
0027f5 93a0 28cb                 	sts triangle_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_pitch_read:
0027f7 91b4                      	lpm r27, Z //load pitch data into r27
0027f8 38b0                      	cpi r27, 0x80 //check for macro end flag
0027f9 f489                      	brne sound_driver_instrument_routine_channel2_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_release:
0027fa 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0027fb 93a0 28cb                 	sts triangle_pitch_macro_offset, r26
0027fd 91b0 28cd                 	lds r27, triangle_pitch_macro_release
0027ff 3fbf                      	cpi r27, 0xFF
002800 f439                      	brne sound_driver_instrument_routine_channel2_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_loop:
002801 91b0 28cc                 	lds r27, triangle_pitch_macro_loop //load the loop index
002803 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002804 f019                      	breq sound_driver_instrument_routine_channel2_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002805 93b0 28cb                 	sts triangle_pitch_macro_offset, r27 //store the loop index into the offset
002807 cfd6                      	rjmp sound_driver_instrument_routine_channel2_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_default:
002808 91b0 28c8                 	lds r27, triangle_total_pitch_offset
00280a c005                      	rjmp sound_driver_instrument_routine_channel2_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate:
00280b 91a0 28c8                 	lds r26, triangle_total_pitch_offset //load the total pitch offset to change
00280d 0fba                      	add r27, r26
00280e 93b0 28c8                 	sts triangle_total_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_multiply:
                                 	//NOTE: The Pxx effect is processed with the pitch instrument macro because the calculations are the same
002810 91a0 28f0                 	lds r26, triangle_fx_Pxx
002812 0fba                      	add r27, r26
                                 
002813 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002814 937f                      	push r23
002815 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
002816 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002817 0367                      	mulsu r22, r23
002818 917f                      	pop r23
002819 916f                      	pop r22
                                 
00281a 9416                      	lsr r1 //shift out the fractional bits
00281b 9407                      	ror r0
00281c 9416                      	lsr r1
00281d 9407                      	ror r0
00281e 9416                      	lsr r1
00281f 9407                      	ror r0
002820 9416                      	lsr r1
002821 9407                      	ror r0
002822 fe13                      	sbrs r1, 3 //check if result was a negative number
002823 c002                      	rjmp sound_driver_instrument_routine_channel2_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_negative:
002824 efb0                      	ldi r27, 0xF0
002825 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_offset:
002826 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
002828 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
00282a 0da0                      	add r26, r0 //offset the timer values
00282b 1db1                      	adc r27, r1
                                 	
00282c 91c0 28dd                 	lds r28, triangle_fx_1xx_total
00282e 91d0 28de                 	lds r29, triangle_fx_1xx_total+1
002830 1bac                      	sub r26, r28
002831 0bbd                      	sbc r27, r29
002832 91c0 28e1                 	lds r28, triangle_fx_2xx_total
002834 91d0 28e2                 	lds r29, triangle_fx_2xx_total+1
002836 0fac                      	add r26, r28
002837 1fbd                      	adc r27, r29
002838 91c0 28f5                 	lds r28, triangle_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
00283a 91d0 28f6                 	lds r29, triangle_fx_Qxy_total_offset+1
00283c 1bac                      	sub r26, r28
00283d 0bbd                      	sbc r27, r29
00283e 91c0 28fb                 	lds r28, triangle_fx_Rxy_total_offset
002840 91d0 28fc                 	lds r29, triangle_fx_Rxy_total_offset+1
002842 0fac                      	add r26, r28
002843 1fbd                      	adc r27, r29
                                 
002844 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
002846 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel2_hi_pitch:
002848 91e0 28cf                 	lds ZL, triangle_hi_pitch_macro
00284a 91f0 28d0                 	lds ZH, triangle_hi_pitch_macro+1
00284c 9630                      	adiw Z, 0
00284d f409                      	brne sound_driver_instrument_routine_channel2_hi_pitch_continue
00284e c03c                      	rjmp sound_driver_instrument_routine_channel2_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel2_hi_pitch_continue:
00284f 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002850 1fff                      	rol ZH
002851 91a0 28d1                 	lds r26, triangle_hi_pitch_macro_offset
002853 0fea                      	add ZL, r26
002854 1df2                      	adc ZH, zero
                                 
002855 91b0 28d3                 	lds r27, triangle_hi_pitch_macro_release
002857 17ba                      	cp r27, r26
002858 f429                      	brne sound_driver_instrument_routine_channel2_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002859 91a0 28d2                 	lds r26, triangle_hi_pitch_macro_loop
00285b 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00285c f010                      	brlo sound_driver_instrument_routine_channel2_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00285d c003                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_increment:
00285e 95a3                      	inc r26 //increment the macro offset
00285f 93a0 28d1                 	sts triangle_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_hi_pitch_read:
002861 91b4                      	lpm r27, Z //load hi pitch data into r27
002862 38b0                      	cpi r27, 0x80 //check for macro end flag
002863 f489                      	brne sound_driver_instrument_routine_channel2_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_release:
002864 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002865 93a0 28d1                 	sts triangle_hi_pitch_macro_offset, r26
002867 91b0 28d3                 	lds r27, triangle_hi_pitch_macro_release
002869 3fbf                      	cpi r27, 0xFF
00286a f439                      	brne sound_driver_instrument_routine_channel2_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_loop:
00286b 91b0 28d2                 	lds r27, triangle_hi_pitch_macro_loop //load the loop index
00286d 3fbf                      	cpi r27, 0xFF //check if there is a loop index
00286e f019                      	breq sound_driver_instrument_routine_channel2_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
00286f 93b0 28d1                 	sts triangle_hi_pitch_macro_offset, r27 //store the loop index into the offset
002871 cfd6                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_default:
002872 91b0 28ce                 	lds r27, triangle_total_hi_pitch_offset
002874 c005                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate:
002875 91a0 28ce                 	lds r26, triangle_total_hi_pitch_offset //load the total hi pitch offset to change
002877 0fba                      	add r27, r26
002878 93b0 28ce                 	sts triangle_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply:
00287a 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00287b 937f                      	push r23
00287c 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
00287d eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00287e 0367                      	mulsu r22, r23
00287f 917f                      	pop r23
002880 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_offset:
002881 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
002883 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
002885 0da0                      	add r26, r0 //offset the timer values
002886 1db1                      	adc r27, r1
002887 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
002889 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: The triangle channel does not have a duty cycle
                                 sound_driver_instrument_routine_channel2_duty:
                                 
                                 
                                 
                                 sound_driver_channel2_fx_routines:
                                 sound_driver_channel2_fx_1xx_routine:
00288b 91e0 28db                 	lds ZL, triangle_fx_1xx
00288d 91f0 28dc                 	lds ZH, triangle_fx_1xx+1
00288f 9630                      	adiw Z, 0
002890 f051                      	breq sound_driver_channel2_fx_2xx_routine
                                 
002891 91a0 28dd                 	lds r26, triangle_fx_1xx_total //load the rate to change the pitch by
002893 91b0 28de                 	lds r27, triangle_fx_1xx_total+1
002895 0fae                      	add r26, ZL //increase the total offset by the rate
002896 1fbf                      	adc r27, ZH
002897 93a0 28dd                 	sts triangle_fx_1xx_total, r26
002899 93b0 28de                 	sts triangle_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_2xx_routine:
00289b 91e0 28df                 	lds ZL, triangle_fx_2xx
00289d 91f0 28e0                 	lds ZH, triangle_fx_2xx+1
00289f 9630                      	adiw Z, 0
0028a0 f051                      	breq sound_driver_channel2_fx_3xx_routine
                                 
0028a1 91a0 28e1                 	lds r26, triangle_fx_2xx_total //load the rate to change the pitch by
0028a3 91b0 28e2                 	lds r27, triangle_fx_2xx_total+1
0028a5 0fae                      	add r26, ZL //increase the total offset by the rate
0028a6 1fbf                      	adc r27, ZH
0028a7 93a0 28e1                 	sts triangle_fx_2xx_total, r26
0028a9 93b0 28e2                 	sts triangle_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_3xx_routine:
0028ab 91e0 28e7                 	lds ZL, triangle_fx_3xx_speed
0028ad 91f0 28e8                 	lds ZH, triangle_fx_3xx_speed+1
0028af 9630                      	adiw Z, 0
0028b0 f409                      	brne sound_driver_channel2_fx_3xx_routine_check_start
0028b1 c048                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_check_start:
0028b2 91a0 28e3                 	lds r26, triangle_fx_3xx_start
0028b4 91b0 28e4                 	lds r27, triangle_fx_3xx_start+1
0028b6 9610                      	adiw r26:r27, 0
0028b7 f409                      	brne sound_driver_channel2_fx_3xx_routine_main
0028b8 c041                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_main:
0028b9 91c0 28e5                 	lds r28, triangle_fx_3xx_target
0028bb 91d0 28e6                 	lds r29, triangle_fx_3xx_target+1
                                 
0028bd 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
0028be 07bd                      	cpc r27, r29
0028bf f011                      	breq sound_driver_channel2_fx_3xx_routine_disable
0028c0 f030                      	brlo sound_driver_channel2_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
0028c1 c01f                      	rjmp sound_driver_channel2_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel2_fx_3xx_routine_disable:
0028c2 9220 28e3                 	sts triangle_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
0028c4 9220 28e4                 	sts triangle_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
0028c6 c033                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_subtract:
0028c7 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
0028c8 0bdb                      	sbc r29, r27
0028c9 91a0 28e9                 	lds r26, triangle_fx_3xx_total_offset
0028cb 91b0 28ea                 	lds r27, triangle_fx_3xx_total_offset+1
                                 
0028cd 0fae                      	add r26, ZL //add the speed to the total offset
0028ce 1fbf                      	adc r27, ZH
0028cf 1bca                      	sub r28, r26 //invert the total difference with the total offset
0028d0 0bdb                      	sbc r29, r27
0028d1 f380                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0028d2 93a0 28e9                 	sts triangle_fx_3xx_total_offset, r26 //store the new total offset
0028d4 93b0 28ea                 	sts triangle_fx_3xx_total_offset+1, r27
                                 
0028d6 91a0 0aac                 	lds r26, TCB2_CCMPL //load the current timer period
0028d8 91b0 0aad                 	lds r27, TCB2_CCMPH
0028da 1bac                      	sub r26, r28 //offset the current timer period with the total offset
0028db 0bbd                      	sbc r27, r29
0028dc 93a0 0aac                 	sts TCB2_CCMPL, r26
0028de 93b0 0aad                 	sts TCB2_CCMPH, r27
0028e0 c019                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_add:
0028e1 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
0028e2 0bbd                      	sbc r27, r29
0028e3 91c0 28e9                 	lds r28, triangle_fx_3xx_total_offset
0028e5 91d0 28ea                 	lds r29, triangle_fx_3xx_total_offset+1
                                 
0028e7 0fce                      	add r28, ZL //add the speed to the total offset
0028e8 1fdf                      	adc r29, ZH
0028e9 1bac                      	sub r26, r28 //invert the total difference with the total offset
0028ea 0bbd                      	sbc r27, r29
0028eb f2b0                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0028ec 93c0 28e9                 	sts triangle_fx_3xx_total_offset, r28 //store the new total offset
0028ee 93d0 28ea                 	sts triangle_fx_3xx_total_offset+1, r29
                                 
0028f0 91c0 0aac                 	lds r28, TCB2_CCMPL //load the current timer period
0028f2 91d0 0aad                 	lds r29, TCB2_CCMPH
0028f4 0fca                      	add r28, r26 //offset the current timer period with the total offset
0028f5 1fdb                      	adc r29, r27
0028f6 93c0 0aac                 	sts TCB2_CCMPL, r28
0028f8 93d0 0aad                 	sts TCB2_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel2_fx_4xy_routine:
0028fa 91a0 28eb                 	lds r26, triangle_fx_4xy_speed
0028fc 15a2                      	cp r26, zero
0028fd f409                      	brne sound_driver_channel2_fx_4xy_routine_continue
0028fe c05c                      	rjmp sound_driver_channel2_fx_Qxy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel2_fx_4xy_routine_continue:
0028ff 91b0 28ec                 	lds r27, triangle_fx_4xy_depth
002901 91c0 28ed                 	lds r28, triangle_fx_4xy_phase
002903 0fca                      	add r28, r26 //increase the phase by the speed
002904 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
002905 f008                      	brlo sound_driver_channel2_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002906 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase:
002907 93c0 28ed                 	sts triangle_fx_4xy_phase, r28 //store the new phase
002909 31c0                      	cpi r28, 16
00290a f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_0
00290b 32c0                      	cpi r28, 32
00290c f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_1
00290d 33c0                      	cpi r28, 48
00290e f030                      	brlo sound_driver_channel2_fx_4xy_routine_phase_2
00290f c007                      	rjmp sound_driver_channel2_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_0:
002910 70cf                      	andi r28, 0x0F //mask for values 0-15
002911 c029                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_1:
002912 6fc0                      	ori r28, 0xF0
002913 95c0                      	com r28 //invert values 0-15
002914 c026                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_2:
002915 70cf                      	andi r28, 0x0F //mask for values 0-15
002916 c003                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_3:
002917 6fc0                      	ori r28, 0xF0
002918 95c0                      	com r28 //invert values 0-15
002919 c000                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_add:
00291a 95b2                      	swap r27 //multiply depth by 16
00291b 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
00291c e1e6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00291d e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00291e 0fec                      	add ZL, r28 //offset the table by the depth+phase
00291f 1df2                      	adc ZH, zero
002920 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002921 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002922 937f                      	push r23
002923 2f6c                      	mov r22, r28 //store the vibrato value into r22
002924 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002925 9f67                      	mul r22, r23
002926 917f                      	pop r23
002927 916f                      	pop r22
                                 
002928 9416                      	lsr r1 //shift out the fractional bits
002929 9407                      	ror r0
00292a 9416                      	lsr r1
00292b 9407                      	ror r0
00292c 9416                      	lsr r1
00292d 9407                      	ror r0
00292e 9416                      	lsr r1
00292f 9407                      	ror r0
                                 	
002930 91a0 0aac                 	lds r26, TCB2_CCMPL
002932 91b0 0aad                 	lds r27, TCB2_CCMPH
002934 0da0                      	add r26, r0
002935 1db1                      	adc r27, r1
002936 93a0 0aac                 	sts TCB2_CCMPL, r26
002938 93b0 0aad                 	sts TCB2_CCMPH, r27
00293a c020                      	rjmp sound_driver_channel2_fx_Qxy_routine
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_subtract:
00293b 95b2                      	swap r27 //multiply depth by 16
00293c 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
00293d e1e6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00293e e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00293f 0fec                      	add ZL, r28 //offset the table by the depth+phase
002940 1df2                      	adc ZH, zero
002941 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002942 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002943 937f                      	push r23
002944 2f6c                      	mov r22, r28 //store the vibrato value into r22
002945 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002946 9f67                      	mul r22, r23
002947 917f                      	pop r23
002948 916f                      	pop r22
                                 
002949 9416                      	lsr r1 //shift out the fractional bits
00294a 9407                      	ror r0
00294b 9416                      	lsr r1
00294c 9407                      	ror r0
00294d 9416                      	lsr r1
00294e 9407                      	ror r0
00294f 9416                      	lsr r1
002950 9407                      	ror r0
                                 
002951 91a0 0aac                 	lds r26, TCB2_CCMPL
002953 91b0 0aad                 	lds r27, TCB2_CCMPH
002955 19a0                      	sub r26, r0
002956 09b1                      	sbc r27, r1
002957 93a0 0aac                 	sts TCB2_CCMPL, r26
002959 93b0 0aad                 	sts TCB2_CCMPH, r27
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel2_fx_Qxy_routine:
00295b 91e0 28f1                 	lds ZL, triangle_fx_Qxy_target
00295d 91f0 28f2                 	lds ZH, triangle_fx_Qxy_target+1
00295f 9630                      	adiw Z, 0
002960 f199                      	breq sound_driver_channel2_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002961 91a0 28f5                 	lds r26, triangle_fx_Qxy_total_offset
002963 91b0 28f6                 	lds r27, triangle_fx_Qxy_total_offset+1
002965 91c0 0aac                 	lds r28, TCB2_CCMPL
002967 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
002969 1bec                      	sub ZL, r28 //calculate the difference to the target
00296a 0bfd                      	sbc ZH, r29
00296b f408                      	brsh sound_driver_channel2_fx_Qxy_routine_end //if the target has been reached (or passed)
00296c f0e8                      	brlo sound_driver_channel2_fx_Qxy_routine_add
                                 
                                 sound_driver_channel2_fx_Qxy_routine_end:
00296d 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
00296e 0bbf                      	sbc r27, ZH
                                 
00296f 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002970 937f                      	push r23
002971 9160 28f0                 	lds r22, triangle_fx_Pxx
002973 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002974 9f67                      	mul r22, r23
002975 917f                      	pop r23
002976 916f                      	pop r22
002977 9416                      	lsr r1 //shift out the fractional bits
002978 9407                      	ror r0
002979 9416                      	lsr r1
00297a 9407                      	ror r0
00297b 9416                      	lsr r1
00297c 9407                      	ror r0
00297d 9416                      	lsr r1
00297e 9407                      	ror r0
                                 
00297f 0da0                      	add r26, r0
002980 1db2                      	adc r27, zero
                                 
002981 93a0 28f5                 	sts triangle_fx_Qxy_total_offset, r26 //store the total offset
002983 93b0 28f6                 	sts triangle_fx_Qxy_total_offset+1, r27
002985 9220 28f1                 	sts triangle_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
002987 9220 28f2                 	sts triangle_fx_Qxy_target+1, zero
002989 c00a                      	rjmp sound_driver_channel2_fx_Rxy_routine
                                 
                                 sound_driver_channel2_fx_Qxy_routine_add:
00298a 91c0 28f3                 	lds r28, triangle_fx_Qxy_speed
00298c 91d0 28f4                 	lds r29, triangle_fx_Qxy_speed+1
00298e 0fac                      	add r26, r28 //increase the total offset by the speed
00298f 1fbd                      	adc r27, r29
002990 93a0 28f5                 	sts triangle_fx_Qxy_total_offset, r26 //store the total offset
002992 93b0 28f6                 	sts triangle_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_Rxy_routine:
002994 91e0 28f7                 	lds ZL, triangle_fx_Rxy_target
002996 91f0 28f8                 	lds ZH, triangle_fx_Rxy_target+1
002998 9630                      	adiw Z, 0
002999 f199                      	breq sound_driver_instrument_routine_channel3_volume //if the effect is not enabled, skip the routine
                                 
00299a 91a0 28fb                 	lds r26, triangle_fx_Rxy_total_offset
00299c 91b0 28fc                 	lds r27, triangle_fx_Rxy_total_offset+1
00299e 91c0 0aac                 	lds r28, TCB2_CCMPL
0029a0 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
0029a2 1bce                      	sub r28, ZL //calculate the difference to the target
0029a3 0bdf                      	sbc r29, ZH
0029a4 f408                      	brsh sound_driver_channel2_fx_Rxy_routine_end //if the target has been reached (or passed)
0029a5 f0e8                      	brlo sound_driver_channel2_fx_Rxy_routine_add
                                 
                                 sound_driver_channel2_fx_Rxy_routine_end:
0029a6 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
0029a7 0bbd                      	sbc r27, r29
                                 
0029a8 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0029a9 937f                      	push r23
0029aa 9160 28f0                 	lds r22, triangle_fx_Pxx
0029ac eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0029ad 9f67                      	mul r22, r23
0029ae 917f                      	pop r23
0029af 916f                      	pop r22
0029b0 9416                      	lsr r1 //shift out the fractional bits
0029b1 9407                      	ror r0
0029b2 9416                      	lsr r1
0029b3 9407                      	ror r0
0029b4 9416                      	lsr r1
0029b5 9407                      	ror r0
0029b6 9416                      	lsr r1
0029b7 9407                      	ror r0
                                 
0029b8 0da0                      	add r26, r0
0029b9 1db2                      	adc r27, zero
                                 
0029ba 93a0 28fb                 	sts triangle_fx_Rxy_total_offset, r26 //store the total offset
0029bc 93b0 28fc                 	sts triangle_fx_Rxy_total_offset+1, r27
0029be 9220 28f7                 	sts triangle_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
0029c0 9220 28f8                 	sts triangle_fx_Rxy_target+1, zero
0029c2 c00a                      	rjmp sound_driver_instrument_routine_channel3_volume
                                 
                                 sound_driver_channel2_fx_Rxy_routine_add:
0029c3 91c0 28f9                 	lds r28, triangle_fx_Rxy_speed
0029c5 91d0 28fa                 	lds r29, triangle_fx_Rxy_speed+1
0029c7 0fac                      	add r26, r28 //increase the total offset by the speed
0029c8 1fbd                      	adc r27, r29
0029c9 93a0 28fb                 	sts triangle_fx_Rxy_total_offset, r26 //store the total offset
0029cb 93b0 28fc                 	sts triangle_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume:
                                 
                                 sound_driver_exit:
0029cd 91ff                      	pop r31
0029ce 91ef                      	pop r30
0029cf 91df                      	pop r29
0029d0 91cf                      	pop r28
0029d1 940c 157d                 	jmp sequence_1_3 + 3 //+3 is to skip the stack instructions since we already pushed them
                                 
                                 
                                 
                                 //TABLES
0029d3 7f05
0029d4 010a
0029d5 0214
0029d6 0328
0029d7 0450
0029d8 051e
0029d9 0607
0029da 070d
0029db 0806
0029dc 090c
0029dd 0a18
0029de 0b30
0029df 0c60
0029e0 0d24
0029e1 0e08
0029e2 0f10                      length: .db $05, $7F, $0A, $01, $14, $02, $28, $03, $50, $04, $1E, $05, $07, $06, $0D, $07, $06, $08, $0C, $09, $18, $0A, $30, $0B, $60, $0C, $24, $0D, $08, $0E, $10, $0F
                                 
                                 //pulse sequences: 12.5%, 25%, 50%, 75%
0029e3 0301
0029e4 fc0f                      sequences: .db 0b00000001, 0b00000011, 0b00001111, 0b11111100
                                 
                                 //list of famitracker fx: http://famitracker.com/wiki/index.php?title=Effect_list
                                 channel0_fx:
0029e5 1765
0029e6 176a
0029e7 1786
0029e8 17a2
0029e9 17c5                      	.dw sound_driver_channel0_fx_0xy, sound_driver_channel0_fx_1xx, sound_driver_channel0_fx_2xx, sound_driver_channel0_fx_3xx, sound_driver_channel0_fx_4xy
0029ea 17d0
0029eb 17dd
0029ec 17e0
0029ed 17e3
0029ee 17e6                      	.dw sound_driver_channel0_fx_7xy, sound_driver_channel0_fx_Axy, sound_driver_channel0_fx_Bxx, sound_driver_channel0_fx_Cxx, sound_driver_channel0_fx_Dxx
0029ef 17e9
0029f0 17f1
0029f1 17f4
0029f2 1801
0029f3 1802                      	.dw sound_driver_channel0_fx_Exx, sound_driver_channel0_fx_Fxx, sound_driver_channel0_fx_Gxx, sound_driver_channel0_fx_Hxy, sound_driver_channel0_fx_Ixy
0029f4 1803
0029f5 1804
0029f6 1805
0029f7 1808
0029f8 184c                      	.dw sound_driver_channel0_fx_Hxx, sound_driver_channel0_fx_Ixx, sound_driver_channel0_fx_Pxx, sound_driver_channel0_fx_Qxy, sound_driver_channel0_fx_Rxy
0029f9 188f
0029fa 189c
0029fb 18b0
0029fc 18b1
0029fd 18b2                      	.dw sound_driver_channel0_fx_Sxx, sound_driver_channel0_fx_Vxx, sound_driver_channel0_fx_Wxx, sound_driver_channel0_fx_Xxx, sound_driver_channel0_fx_Yxx
0029fe 18b3                      	.dw sound_driver_channel0_fx_Zxx
                                 
                                 channel1_fx:
0029ff 1a31
002a00 1a36
002a01 1a52
002a02 1a6e
002a03 1a91                      	.dw sound_driver_channel1_fx_0xy, sound_driver_channel1_fx_1xx, sound_driver_channel1_fx_2xx, sound_driver_channel1_fx_3xx, sound_driver_channel1_fx_4xy
002a04 1a9c
002a05 1aa9
002a06 1aac
002a07 1aaf
002a08 1ab2                      	.dw sound_driver_channel1_fx_7xy, sound_driver_channel1_fx_Axy, sound_driver_channel1_fx_Bxx, sound_driver_channel1_fx_Cxx, sound_driver_channel1_fx_Dxx
002a09 1ab5
002a0a 1abd
002a0b 1ac0
002a0c 1acd
002a0d 1ace                      	.dw sound_driver_channel1_fx_Exx, sound_driver_channel1_fx_Fxx, sound_driver_channel1_fx_Gxx, sound_driver_channel1_fx_Hxy, sound_driver_channel1_fx_Ixy
002a0e 1acf
002a0f 1ad0
002a10 1ad1
002a11 1ad4
002a12 1b18                      	.dw sound_driver_channel1_fx_Hxx, sound_driver_channel1_fx_Ixx, sound_driver_channel1_fx_Pxx, sound_driver_channel1_fx_Qxy, sound_driver_channel1_fx_Rxy
002a13 1b5b
002a14 1b68
002a15 1b7c
002a16 1b7d
002a17 1b7e                      	.dw sound_driver_channel1_fx_Sxx, sound_driver_channel1_fx_Vxx, sound_driver_channel1_fx_Wxx, sound_driver_channel1_fx_Xxx, sound_driver_channel1_fx_Yxx
002a18 1b7f                      	.dw sound_driver_channel1_fx_Zxx
                                 
                                 channel2_fx:
002a19 1cf9
002a1a 1cfe
002a1b 1d1a
002a1c 1d36
002a1d 1d59                      	.dw sound_driver_channel2_fx_0xy, sound_driver_channel2_fx_1xx, sound_driver_channel2_fx_2xx, sound_driver_channel2_fx_3xx, sound_driver_channel2_fx_4xy
002a1e 1d64
002a1f 1d65
002a20 1d66
002a21 1d69
002a22 1d6c                      	.dw sound_driver_channel2_fx_7xy, sound_driver_channel2_fx_Axy, sound_driver_channel2_fx_Bxx, sound_driver_channel2_fx_Cxx, sound_driver_channel2_fx_Dxx
002a23 1d6f
002a24 1d7c
002a25 1d7f
002a26 1d8c
002a27 1d8d                      	.dw sound_driver_channel2_fx_Exx, sound_driver_channel2_fx_Fxx, sound_driver_channel2_fx_Gxx, sound_driver_channel2_fx_Hxy, sound_driver_channel2_fx_Ixy
002a28 1d8e
002a29 1d8f
002a2a 1d90
002a2b 1d93
002a2c 1dd7                      	.dw sound_driver_channel2_fx_Hxx, sound_driver_channel2_fx_Ixx, sound_driver_channel2_fx_Pxx, sound_driver_channel2_fx_Qxy, sound_driver_channel2_fx_Rxy
002a2d 1e1a
002a2e 1e27
002a2f 1e28
002a30 1e29
002a31 1e2a                      	.dw sound_driver_channel2_fx_Sxx, sound_driver_channel2_fx_Vxx, sound_driver_channel2_fx_Wxx, sound_driver_channel2_fx_Xxx, sound_driver_channel2_fx_Yxx
002a32 1e2b                      	.dw sound_driver_channel2_fx_Zxx
                                 
                                 //famitracker volumes table: http://famitracker.com/wiki/index.php?title=Volume
                                 volumes:
002a33 0000
002a34 0000
002a35 0000
002a36 0000
002a37 0000
002a38 0000
002a39 0000
002a3a 0000                      	.db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
002a3b 0100
002a3c 0101
002a3d 0101
002a3e 0101
002a3f 0101
002a40 0101
002a41 0101
002a42 0101                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
002a43 0100
002a44 0101
002a45 0101
002a46 0101
002a47 0101
002a48 0101
002a49 0101
002a4a 0201                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02
002a4b 0100
002a4c 0101
002a4d 0101
002a4e 0101
002a4f 0101
002a50 0202
002a51 0202
002a52 0302                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03
002a53 0100
002a54 0101
002a55 0101
002a56 0101
002a57 0202
002a58 0202
002a59 0303
002a5a 0403                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04
002a5b 0100
002a5c 0101
002a5d 0101
002a5e 0202
002a5f 0302
002a60 0303
002a61 0404
002a62 0504                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05
002a63 0100
002a64 0101
002a65 0201
002a66 0202
002a67 0303
002a68 0404
002a69 0504
002a6a 0605                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x06
002a6b 0100
002a6c 0101
002a6d 0201
002a6e 0302
002a6f 0403
002a70 0504
002a71 0605
002a72 0706                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07
002a73 0100
002a74 0101
002a75 0202
002a76 0303
002a77 0404
002a78 0505
002a79 0606
002a7a 0807                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07, 0x08
002a7b 0100
002a7c 0101
002a7d 0302
002a7e 0403
002a7f 0504
002a80 0606
002a81 0707
002a82 0908                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09
002a83 0100
002a84 0201
002a85 0302
002a86 0404
002a87 0605
002a88 0706
002a89 0808
002a8a 0a09                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A
002a8b 0100
002a8c 0201
002a8d 0302
002a8e 0504
002a8f 0605
002a90 0807
002a91 0908
002a92 0b0a                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B
002a93 0100
002a94 0201
002a95 0403
002a96 0504
002a97 0706
002a98 0808
002a99 0a09
002a9a 0c0b                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B, 0x0C
002a9b 0100
002a9c 0201
002a9d 0403
002a9e 0605
002a9f 0706
002aa0 0908
002aa1 0b0a
002aa2 0d0c                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D
002aa3 0100
002aa4 0201
002aa5 0403
002aa6 0605
002aa7 0807
002aa8 0a09
002aa9 0c0b
002aaa 0e0d                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E
002aab 0100
002aac 0302
002aad 0504
002aae 0706
002aaf 0908
002ab0 0b0a
002ab1 0d0c


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega4809" register use summary:
x  :   0 y  :   0 z  : 187 r0 : 153 r1 : 153 r2 : 520 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   6 r11:   4 r12:   9 
r13:   6 r14:   4 r15:   9 r16:   7 r17:   6 r18:   7 r19:   6 r20:   4 
r21:   0 r22: 132 r23: 132 r24:   0 r25:  24 r26: 729 r27: 882 r28: 517 
r29: 275 r30: 289 r31: 261 
Registers used: 24 out of 35 (68.6%)

"ATmega4809" instruction use summary:
.lds  :   0 .sts  :   0 adc   : 107 add   : 147 adiw  :  80 and   :   0 
andi  :  71 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   5 brcs  :   9 break :   0 breq  : 127 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  60 brlt  :   0 brmi  :   0 
brne  :  92 brpl  :   0 brsh  :  24 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :   0 cbr   :   4 
clc   :   0 clh   :   0 cli   :   7 cln   :   0 clr   :   5 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :  13 cp    :  76 cpc   :   8 
cpi   : 126 cpse  :  17 dec   :  29 des   :   0 eor   :   0 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   3 in    :   6 inc   :  36 
jmp   :   9 ld    :   0 ldd   :   0 ldi   : 225 lds   : 540 lpm   : 197 
lsl   :  58 lsr   : 136 mov   : 102 movw  :   0 mul   :  27 muls  :   0 
mulsu :   6 neg   :   0 nop   :   0 or    :  14 ori   :   8 out   :   8 
pop   :  96 push  :  90 rcall :  39 ret   :  28 reti  :   6 rjmp  : 388 
rol   :  38 ror   : 154 sbc   :  36 sbci  :   0 sbi   :   0 sbic  :   0 
sbis  :   0 sbiw  :   0 sbr   :  10 sbrc  :  21 sbrs  :  13 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   :1035 sub   :  49 subi  :  39 swap  :  35 tst   :   0 wdr   :   0 

Instructions used: 51 out of 114 (44.7%)

"ATmega4809" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x005566  11944   9846  21790   49152  44.3%
[.dseg] 0x002800 0x002901      0    257    257    6144   4.2%
[.eseg] 0x000000 0x000000      0      0      0     256   0.0%

Assembly complete, 0 errors, 107 warnings
