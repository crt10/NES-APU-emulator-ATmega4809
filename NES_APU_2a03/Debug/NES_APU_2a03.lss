
AVRASM ver. 2.2.8  C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm Thu May 20 18:22:22 2021

C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
                                 
                                 
                                 ; NES_APU_2a03.asm
                                 ;
                                 ; Created: 11/29/2020 1:44:10 AM
                                 ; Author : Tennyson Cheng
                                 ;
                                 
                                 .list
                                 
                                 .dseg
002800                           pulse1_param: .byte 1 //$4000 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002801                           pulse1_sweep_param: .byte 1 //$4001 EPPP.NSSS = Enable, Period, Negate, Shift
                                 //NOTE: In order to account for multiplier, we use 16 instead of 11 bits for the timer
002802                           pulse1_timerL: .byte 1 //$4002 LLLL.LLLL = Low 8 bits for timer
002803                           pulse1_timerH: .byte 1 //$4002 HHHH.HHHH = High 8 bits for timer
002804                           pulse1_length: .byte 1 //$4003 000l.llll = Length counter load
002805                           pulse1_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002806                           pulse1_output_volume: .byte 1 //this is the final output volume of pulse 1
002807                           pulse1_note: .byte 1 //the current note index in the note table
                                 
002808                           pulse2_param: .byte 1 //$4004 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002809                           pulse2_sweep_param: .byte 1 //$4005 EPPP.NSSS = Enable, Period, Negate, Shift
00280a                           pulse2_timerL: .byte 1 //$4006 LLLL.LLLL = Low 8 bits for timer
00280b                           pulse2_timerH: .byte 1 //$4006 HHHH.HHHH = High 8 bits for timer
00280c                           pulse2_length: .byte 1 //$4007 000l.llll = Length counter load
00280d                           pulse2_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
00280e                           pulse2_output_volume: .byte 1 //this is the final output volume of pulse 2
00280f                           pulse2_note: .byte 1 //the current note index in the note table
                                 
002810                           triangle_timerL: .byte 1 //$400A LLLL.LLLL = Low 8 bits for timer
002811                           triangle_timerH: .byte 1 //$400A HHHH.HHHH = High 8 bits for time
002812                           triangle_note: .byte 1 //the current note index in the note table
                                 
002813                           noise_param: .byte 1 //$400C 00lc.vvvv = Length counter halt/Loop flag, Constant volume flag, Volume
002814                           noise_period: .byte 1 //$400E M000.PPPP = Mode, Period
002815                           noise_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002816                           noise_output_volume: .byte 1 //this is the final output volume of pulse 2
002817                           noise_note: .byte 1 //the current note index in the period table
002818                           noise_adjusted_note: .byte 1 //the resultant note index after the arpeggio macro
                                 
002819                           song_frames: .byte 2
00281b                           song_frame_offset: .byte 2
00281d                           song_size: .byte 2
00281f                           song_speed: .byte 1
                                 //song_channel_delay_reload: .byte 1 //bit 0-4 represents channels 0-4. a set bit means that there is a delay that needs to be calculated for that channel.
002820                           song_fx_Bxx: .byte 1
002821                           song_fx_Cxx: .byte 1
002822                           song_fx_Dxx: .byte 1
                                 
                                 //PULSE 1
002823                           pulse1_pattern: .byte 2
002825                           pulse1_pattern_delay_rows: .byte 1
002826                           pulse1_pattern_delay_frames: .byte 1
002827                           pulse1_pattern_offset: .byte 2
                                 
002829                           pulse1_volume_macro: .byte 2
00282b                           pulse1_volume_macro_offset: .byte 1
00282c                           pulse1_volume_macro_loop: .byte 1
00282d                           pulse1_volume_macro_release: .byte 1
                                 
00282e                           pulse1_arpeggio_macro: .byte 2
002830                           pulse1_arpeggio_macro_offset: .byte 1
002831                           pulse1_arpeggio_macro_loop: .byte 1
002832                           pulse1_arpeggio_macro_release: .byte 1
002833                           pulse1_arpeggio_macro_mode: .byte 1
                                 
002834                           pulse1_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002836                           pulse1_pitch_macro: .byte 2
002838                           pulse1_pitch_macro_offset: .byte 1
002839                           pulse1_pitch_macro_loop: .byte 1
00283a                           pulse1_pitch_macro_release: .byte 1
                                 
00283b                           pulse1_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00283c                           pulse1_hi_pitch_macro: .byte 2
00283e                           pulse1_hi_pitch_macro_offset: .byte 1
00283f                           pulse1_hi_pitch_macro_loop: .byte 1
002840                           pulse1_hi_pitch_macro_release: .byte 1
                                 
002841                           pulse1_duty_macro: .byte 2
002843                           pulse1_duty_macro_offset: .byte 1
002844                           pulse1_duty_macro_loop: .byte 1
002845                           pulse1_duty_macro_release: .byte 1
                                 
002846                           pulse1_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002848                           pulse1_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
00284a                           pulse1_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00284c                           pulse1_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
00284e                           pulse1_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
002850                           pulse1_fx_3xx_start: .byte 2 //the starting note period
002852                           pulse1_fx_3xx_target: .byte 2 //target note period
002854                           pulse1_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
002856                           pulse1_fx_3xx_total_offset: .byte 2
002858                           pulse1_fx_4xy_speed: .byte 1
002859                           pulse1_fx_4xy_depth: .byte 1
00285a                           pulse1_fx_4xy_phase: .byte 1
00285b                           pulse1_fx_7xy_speed: .byte 1
00285c                           pulse1_fx_7xy_depth: .byte 1
00285d                           pulse1_fx_7xy_phase: .byte 1
00285e                           pulse1_fx_7xy_value: .byte 1 //value to offset the volume
00285f                           pulse1_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
002860                           pulse1_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002861                           pulse1_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002862                           pulse1_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
002864                           pulse1_fx_Qxy_target_note: .byte 1 //target note index
002865                           pulse1_fx_Qxy_target: .byte 2 //target note period
002867                           pulse1_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002869                           pulse1_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
00286b                           pulse1_fx_Rxy_target_note: .byte 1 //target note index
00286c                           pulse1_fx_Rxy_target: .byte 2 //target note period
00286e                           pulse1_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
002870                           pulse1_fx_Rxy_total_offset: .byte 2
002872                           pulse1_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002873                           pulse1_fx_Sxx_post: .byte 1
                                 
                                 //PULSE 2
002874                           pulse2_pattern: .byte 2
002876                           pulse2_pattern_delay_rows: .byte 1
002877                           pulse2_pattern_delay_frames: .byte 1
002878                           pulse2_pattern_offset: .byte 2
                                 
00287a                           pulse2_volume_macro: .byte 2
00287c                           pulse2_volume_macro_offset: .byte 1
00287d                           pulse2_volume_macro_loop: .byte 1
00287e                           pulse2_volume_macro_release: .byte 1
                                 
00287f                           pulse2_arpeggio_macro: .byte 2
002881                           pulse2_arpeggio_macro_offset: .byte 1
002882                           pulse2_arpeggio_macro_loop: .byte 1
002883                           pulse2_arpeggio_macro_release: .byte 1
002884                           pulse2_arpeggio_macro_mode: .byte 1
                                 
002885                           pulse2_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002887                           pulse2_pitch_macro: .byte 2
002889                           pulse2_pitch_macro_offset: .byte 1
00288a                           pulse2_pitch_macro_loop: .byte 1
00288b                           pulse2_pitch_macro_release: .byte 1
                                 
00288c                           pulse2_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00288d                           pulse2_hi_pitch_macro: .byte 2
00288f                           pulse2_hi_pitch_macro_offset: .byte 1
002890                           pulse2_hi_pitch_macro_loop: .byte 1
002891                           pulse2_hi_pitch_macro_release: .byte 1
                                 
002892                           pulse2_duty_macro: .byte 2
002894                           pulse2_duty_macro_offset: .byte 1
002895                           pulse2_duty_macro_loop: .byte 1
002896                           pulse2_duty_macro_release: .byte 1
                                 
002897                           pulse2_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002899                           pulse2_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
00289b                           pulse2_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00289d                           pulse2_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
00289f                           pulse2_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
0028a1                           pulse2_fx_3xx_start: .byte 2 //the starting note period
0028a3                           pulse2_fx_3xx_target: .byte 2 //target note period
0028a5                           pulse2_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028a7                           pulse2_fx_3xx_total_offset: .byte 2
0028a9                           pulse2_fx_4xy_speed: .byte 1
0028aa                           pulse2_fx_4xy_depth: .byte 1
0028ab                           pulse2_fx_4xy_phase: .byte 1
0028ac                           pulse2_fx_7xy_speed: .byte 1
0028ad                           pulse2_fx_7xy_depth: .byte 1
0028ae                           pulse2_fx_7xy_phase: .byte 1
0028af                           pulse2_fx_7xy_value: .byte 1 //value to offset the volume
0028b0                           pulse2_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
0028b1                           pulse2_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028b2                           pulse2_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028b3                           pulse2_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
0028b5                           pulse2_fx_Qxy_target_note: .byte 1 //target note index
0028b6                           pulse2_fx_Qxy_target: .byte 2 //target note period
0028b8                           pulse2_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
0028ba                           pulse2_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
0028bc                           pulse2_fx_Rxy_target_note: .byte 1 //target note index
0028bd                           pulse2_fx_Rxy_target: .byte 2 //target note period
0028bf                           pulse2_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
0028c1                           pulse2_fx_Rxy_total_offset: .byte 2
0028c3                           pulse2_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
0028c4                           pulse2_fx_Sxx_post: .byte 1
                                 
                                 //TRIANGLE
0028c5                           triangle_pattern: .byte 2
0028c7                           triangle_pattern_delay_rows: .byte 1
0028c8                           triangle_pattern_delay_frames: .byte 1
0028c9                           triangle_pattern_offset: .byte 2
                                 
0028cb                           triangle_volume_macro: .byte 2
0028cd                           triangle_volume_macro_offset: .byte 1
0028ce                           triangle_volume_macro_loop: .byte 1
0028cf                           triangle_volume_macro_release: .byte 1
                                 
0028d0                           triangle_arpeggio_macro: .byte 2
0028d2                           triangle_arpeggio_macro_offset: .byte 1
0028d3                           triangle_arpeggio_macro_loop: .byte 1
0028d4                           triangle_arpeggio_macro_release: .byte 1
0028d5                           triangle_arpeggio_macro_mode: .byte 1
                                 
0028d6                           triangle_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
0028d8                           triangle_pitch_macro: .byte 2
0028da                           triangle_pitch_macro_offset: .byte 1
0028db                           triangle_pitch_macro_loop: .byte 1
0028dc                           triangle_pitch_macro_release: .byte 1
                                 
0028dd                           triangle_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
0028de                           triangle_hi_pitch_macro: .byte 2
0028e0                           triangle_hi_pitch_macro_offset: .byte 1
0028e1                           triangle_hi_pitch_macro_loop: .byte 1
0028e2                           triangle_hi_pitch_macro_release: .byte 1
                                 
0028e3                           triangle_duty_macro: .byte 2
0028e5                           triangle_duty_macro_offset: .byte 1
0028e6                           triangle_duty_macro_loop: .byte 1
0028e7                           triangle_duty_macro_release: .byte 1
                                 
0028e8                           triangle_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
0028ea                           triangle_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
0028ec                           triangle_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
0028ee                           triangle_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
0028f0                           triangle_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
0028f2                           triangle_fx_3xx_start: .byte 2 //the starting note period
0028f4                           triangle_fx_3xx_target: .byte 2 //target note period
0028f6                           triangle_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028f8                           triangle_fx_3xx_total_offset: .byte 2
0028fa                           triangle_fx_4xy_speed: .byte 1
0028fb                           triangle_fx_4xy_depth: .byte 1
0028fc                           triangle_fx_4xy_phase: .byte 1
0028fd                           triangle_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028fe                           triangle_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028ff                           triangle_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
002901                           triangle_fx_Qxy_target_note: .byte 1 //target note index
002902                           triangle_fx_Qxy_target: .byte 2 //target note period
002904                           triangle_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002906                           triangle_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002908                           triangle_fx_Rxy_target_note: .byte 1 //target note index
002909                           triangle_fx_Rxy_target: .byte 2 //target note period
00290b                           triangle_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
00290d                           triangle_fx_Rxy_total_offset: .byte 2
00290f                           triangle_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002910                           triangle_fx_Sxx_post: .byte 1
                                 
                                 //NOISE
002911                           noise_pattern: .byte 2
002913                           noise_pattern_delay_rows: .byte 1
002914                           noise_pattern_delay_frames: .byte 1
002915                           noise_pattern_offset: .byte 2
                                 
002917                           noise_volume_macro: .byte 2
002919                           noise_volume_macro_offset: .byte 1
00291a                           noise_volume_macro_loop: .byte 1
00291b                           noise_volume_macro_release: .byte 1
                                 
00291c                           noise_arpeggio_macro: .byte 2
00291e                           noise_arpeggio_macro_offset: .byte 1
00291f                           noise_arpeggio_macro_loop: .byte 1
002920                           noise_arpeggio_macro_release: .byte 1
002921                           noise_arpeggio_macro_mode: .byte 1
                                 
002922                           noise_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002924                           noise_pitch_macro: .byte 2
002926                           noise_pitch_macro_offset: .byte 1
002927                           noise_pitch_macro_loop: .byte 1
002928                           noise_pitch_macro_release: .byte 1
                                 
002929                           noise_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00292a                           noise_hi_pitch_macro: .byte 2
00292c                           noise_hi_pitch_macro_offset: .byte 1
00292d                           noise_hi_pitch_macro_loop: .byte 1
00292e                           noise_hi_pitch_macro_release: .byte 1
                                 
00292f                           noise_duty_macro: .byte 2
002931                           noise_duty_macro_offset: .byte 1
002932                           noise_duty_macro_loop: .byte 1
002933                           noise_duty_macro_release: .byte 1
                                 
002934                           noise_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002936                           noise_fx_1xx: .byte 1 //refers to the rate in which to subtract the pitch from by the 1xx
002937                           noise_fx_1xx_total: .byte 1 //the total pitch offset for 1xx
002938                           noise_fx_2xx: .byte 1 //refers to the rate in which to add to the pitch by the 2xx
002939                           noise_fx_2xx_total: .byte 1 //the total pitch offset for 2xx
00293a                           noise_fx_4xy_speed: .byte 1
00293b                           noise_fx_4xy_depth: .byte 1
00293c                           noise_fx_4xy_phase: .byte 1
00293d                           noise_fx_4xy_offset: .byte 1
00293e                           noise_fx_7xy_speed: .byte 1
00293f                           noise_fx_7xy_depth: .byte 1
002940                           noise_fx_7xy_phase: .byte 1
002941                           noise_fx_7xy_value: .byte 1 //value to offset the volume
002942                           noise_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
002943                           noise_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002944                           noise_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002945                           noise_fx_Pxx_total: .byte 1 //refers to the fine pitch offset set by the Pxx effect
002946                           noise_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002947                           noise_fx_Sxx_post: .byte 1
                                 
                                 //DPCM
002948                           dpcm_pattern: .byte 2
00294a                           dpcm_pattern_delay_rows: .byte 1
00294b                           dpcm_pattern_delay_frames: .byte 1
00294c                           dpcm_pattern_offset: .byte 2
                                 
00294e                           dpcm_sample: .byte 2
002950                           dpcm_sample_offset: .byte 2
                                 
002952                           dpcm_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002953                           dpcm_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002954                           dpcm_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002955                           dpcm_fx_Sxx_post: .byte 1
                                 
                                 .cseg
                                 
                                 //NOTE: zero is defined in order to use the cp instruction without the need to load 0x00 into a register beforehand
                                 //NOTE: same idea with one
                                 .def zero = r2
                                 .def one = r3
                                 .def frame_sequence = r4
                                 .def pulse_channel_flags = r25 //[pulse1.pulse2] RSlc.RSlc = Reload, Start, Length halt/Loop, Constant volume
                                 .def pulse1_sequence = r7
                                 .def pulse1_length_counter = r8
                                 .def pulse1_sweep = r9 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse1_volume_divider = r16 //0000.PPPP = Period divider
                                 .def pulse1_volume_decay = r17 //0000.dddd = Decay
                                 .def pulse2_sequence = r10
                                 .def pulse2_length_counter = r11
                                 .def pulse2_sweep = r12 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse2_volume_divider = r18 //0000.PPPP = Period divider
                                 .def pulse2_volume_decay = r19 //0000.dddd = Decay
                                 .def triangle_sequence = r20
                                 .def noise_sequence_LOW = r21
                                 .def noise_sequence_HIGH = r22
                                 .def dpcm_shift = r13
                                 .def dpcm_bit_counter = r14
                                 .def dpcm_period = r15
                                 .def dpcm_length_LOW = r23
                                 .def dpcm_length_HIGH = r24
                                 
                                 
                                 reset:
000000 940c 1258                 	jmp init
                                 
                                 .org RTC_CNT_vect
000006 940c 15fc                 	jmp frame_counter_routine
                                 
                                 .org TCB0_INT_vect
000018 940c 1624                 	jmp pulse1_sequence_routine
                                 
                                 .org TCB1_INT_vect
00001a 940c 1671                 	jmp pulse2_sequence_routine
                                 
                                 .org TCB2_INT_vect
000032 940c 16be                 	jmp triangle_sequence_routine
                                 
                                 .org TCB3_INT_vect
000048 940c 16c9                 	jmp noise_sequence_routine
                                 
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(33): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(48): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(74): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(75): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(76): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(77): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(78): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(79): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(80): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(81): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(82): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(83): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(84): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(85): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(88): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(89): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(92): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(94): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(96): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(97): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(101): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(104): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(106): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(111): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(112): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(113): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(114): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(118): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(119): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(121): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(123): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(124): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(125): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(129): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(130): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(137): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(163): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(223): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(224): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(225): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(230): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(233): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(237): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(238): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(239): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(240): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(246): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(248): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(249): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(250): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(251): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(252): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
                                 .list
                                 
                                 init:
                                 	//MAIN CLOCK
001258 edc8                      	ldi r28, CPU_CCP_IOREG_gc //protected write
001259 93c0 0034                 	sts CPU_CCP, r28
00125b e0c0                      	ldi r28, 0 << CLKCTRL_PEN_bp //disable prescaler for 20 MHz on main clock
00125c 93c0 0061                 	sts CLKCTRL_MCLKCTRLB, r28
                                 
                                 	//ZERO
00125e 2422                      	clr zero
                                 	//ONE
00125f e0c1                      	ldi r28, 1
001260 2e3c                      	mov one, r28
                                 	//FRAME SEQUENCE
001261 2c42                      	mov frame_sequence, zero
                                 
                                 	//MEMORY
001262 e3c0                      	ldi r28, 0b00110000
001263 93c0 2800                 	sts pulse1_param, r28
001265 e8c0                      	ldi r28, 0b10000000
001266 93c0 2801                 	sts pulse1_sweep_param, r28
001268 efcf                      	ldi r28, 0xFF
001269 93c0 2802                 	sts pulse1_timerL, r28
00126b 93c0 2803                 	sts pulse1_timerH, r28
00126d 93c0 2804                 	sts pulse1_length, r28
                                 
00126f e3c0                      	ldi r28, 0b00110000
001270 93c0 2808                 	sts pulse2_param, r28
001272 e8c0                      	ldi r28, 0b10000000
001273 93c0 2809                 	sts pulse2_sweep_param, r28
001275 efcf                      	ldi r28, 0xFF
001276 93c0 280a                 	sts pulse2_timerL, r28
001278 93c0 280b                 	sts pulse2_timerH, r28
00127a 93c0 280c                 	sts pulse2_length, r28
                                 
00127c efcf                      	ldi r28, 0xFF
00127d 93c0 2810                 	sts triangle_timerL, r28
00127f 93c0 2811                 	sts triangle_timerH, r28
                                 
001281 e3c0                      	ldi r28, 0b00110000
001282 93c0 2813                 	sts noise_param, r28
001284 e0cf                      	ldi r28, 0b00001111
001285 93c0 2814                 	sts noise_period, r28
                                 
001287 e0c2                      	ldi r28, 0x02
001288 93c0 281b                 	sts song_frame_offset, r28
00128a 9220 281c                 	sts song_frame_offset+1, zero
00128c efcf                      	ldi r28, 0xFF
00128d 93c0 2820                 	sts song_fx_Bxx, r28
00128f 9220 2821                 	sts song_fx_Cxx, zero
001291 9220 2822                 	sts song_fx_Dxx, zero
001293 e4ee                      	ldi ZL, LOW(song0_frames << 1)
001294 e0f3                      	ldi ZH, HIGH(song0_frames << 1)
001295 93e0 2819                 	sts song_frames, ZL
001297 93f0 281a                 	sts song_frames+1, ZH
001299 91c5                      	lpm r28, Z+ //load the song size
00129a 91d5                      	lpm r29, Z+
00129b 93c0 281d                 	sts song_size, r28
00129d 93d0 281e                 	sts song_size+1, r29
00129f 9220 281f                 	sts song_speed, zero
                                 
                                 	//CHANNEL 0
0012a1 91c5                      	lpm r28, Z+
0012a2 91d5                      	lpm r29, Z+
0012a3 0fcc                      	lsl r28
0012a4 1fdd                      	rol r29
0012a5 93c0 2823                 	sts pulse1_pattern, r28
0012a7 93d0 2824                 	sts pulse1_pattern+1, r29
0012a9 9220 2825                 	sts pulse1_pattern_delay_rows, zero
0012ab 9220 2826                 	sts pulse1_pattern_delay_frames, zero
0012ad 9220 2827                 	sts pulse1_pattern_offset, zero
0012af 9220 2828                 	sts pulse1_pattern_offset+1, zero
                                 
                                 	//CHANNEL 1
0012b1 91c5                      	lpm r28, Z+
0012b2 91d5                      	lpm r29, Z+
0012b3 0fcc                      	lsl r28
0012b4 1fdd                      	rol r29
0012b5 93c0 2874                 	sts pulse2_pattern, r28
0012b7 93d0 2875                 	sts pulse2_pattern+1, r29
0012b9 9220 2876                 	sts pulse2_pattern_delay_rows, zero
0012bb 9220 2877                 	sts pulse2_pattern_delay_frames, zero
0012bd 9220 2878                 	sts pulse2_pattern_offset, zero
0012bf 9220 2879                 	sts pulse2_pattern_offset+1, zero
                                 
                                 	//CHANNEL 2
0012c1 91c5                      	lpm r28, Z+
0012c2 91d5                      	lpm r29, Z+
0012c3 0fcc                      	lsl r28
0012c4 1fdd                      	rol r29
0012c5 93c0 28c5                 	sts triangle_pattern, r28
0012c7 93d0 28c6                 	sts triangle_pattern+1, r29
0012c9 9220 28c7                 	sts triangle_pattern_delay_rows, zero
0012cb 9220 28c8                 	sts triangle_pattern_delay_frames, zero
0012cd 9220 28c9                 	sts triangle_pattern_offset, zero
0012cf 9220 28ca                 	sts triangle_pattern_offset+1, zero
                                 
                                 	//CHANNEL 3
0012d1 91c5                      	lpm r28, Z+
0012d2 91d5                      	lpm r29, Z+
0012d3 0fcc                      	lsl r28
0012d4 1fdd                      	rol r29
0012d5 93c0 2911                 	sts noise_pattern, r28
0012d7 93d0 2912                 	sts noise_pattern+1, r29
0012d9 9220 2913                 	sts noise_pattern_delay_rows, zero
0012db 9220 2914                 	sts noise_pattern_delay_frames, zero
0012dd 9220 2915                 	sts noise_pattern_offset, zero
0012df 9220 2916                 	sts noise_pattern_offset+1, zero
                                 
                                 	//CHANNEL 4
0012e1 91c5                      	lpm r28, Z+
0012e2 91d5                      	lpm r29, Z+
0012e3 0fcc                      	lsl r28
0012e4 1fdd                      	rol r29
0012e5 93c0 2948                 	sts dpcm_pattern, r28
0012e7 93d0 2949                 	sts dpcm_pattern+1, r29
0012e9 9220 294a                 	sts dpcm_pattern_delay_rows, zero
0012eb 9220 294b                 	sts dpcm_pattern_delay_frames, zero
0012ed 9220 294c                 	sts dpcm_pattern_offset, zero
0012ef 9220 294d                 	sts dpcm_pattern_offset+1, zero
                                 
                                 	//CHANNEL 0 instrument macros
0012f1 efcf                      	ldi r28, 0xFF
0012f2 9220 282b                 	sts pulse1_volume_macro_offset, zero
0012f4 93c0 282c                 	sts pulse1_volume_macro_loop, r28
0012f6 93c0 282d                 	sts pulse1_volume_macro_release, r28
0012f8 9220 2830                 	sts pulse1_arpeggio_macro_offset, zero
0012fa 93c0 2831                 	sts pulse1_arpeggio_macro_loop, r28
0012fc 93c0 2832                 	sts pulse1_arpeggio_macro_release, r28
0012fe 93c0 2833                 	sts pulse1_arpeggio_macro_mode, r28
001300 9220 2838                 	sts pulse1_pitch_macro_offset, zero
001302 93c0 2839                 	sts pulse1_pitch_macro_loop, r28
001304 93c0 283a                 	sts pulse1_pitch_macro_release, r28
001306 9220 283e                 	sts pulse1_hi_pitch_macro_offset, zero
001308 93c0 283f                 	sts pulse1_hi_pitch_macro_loop, r28
00130a 93c0 2840                 	sts pulse1_hi_pitch_macro_release, r28
00130c 9220 2843                 	sts pulse1_duty_macro_offset, zero
00130e 93c0 2844                 	sts pulse1_duty_macro_loop, r28
001310 93c0 2845                 	sts pulse1_duty_macro_release, r28
                                 
001312 9220 2829                 	sts pulse1_volume_macro, zero
001314 9220 282a                 	sts pulse1_volume_macro+1, zero
001316 9220 282e                 	sts pulse1_arpeggio_macro, zero
001318 9220 282f                 	sts pulse1_arpeggio_macro+1, zero
00131a 9220 2834                 	sts pulse1_total_pitch_offset, zero
00131c 9220 2835                 	sts pulse1_total_pitch_offset+1, zero
00131e 9220 2836                 	sts pulse1_pitch_macro, zero
001320 9220 2837                 	sts pulse1_pitch_macro+1, zero
001322 9220 283b                 	sts pulse1_total_hi_pitch_offset, zero
001324 9220 283c                 	sts pulse1_hi_pitch_macro, zero
001326 9220 283d                 	sts pulse1_hi_pitch_macro+1, zero
001328 9220 2841                 	sts pulse1_duty_macro, zero
00132a 9220 2842                 	sts pulse1_duty_macro+1, zero
                                 
                                 	//CHANNEL 0 ENVELOPE
00132c e00f                      	ldi pulse1_volume_divider, 0x0F
00132d 9110 2800                 	lds pulse1_volume_decay, pulse1_param
00132f 701f                      	andi pulse1_volume_decay, 0x0F //mask for VVVV bits
001330 9190 2800                 	lds pulse_channel_flags, pulse1_param
001332 7390                      	andi pulse_channel_flags, 0b00110000
001333 6490                      	sbr pulse_channel_flags, 0b01000000 //set start flag
001334 9220 2806                 	sts pulse1_output_volume, zero
001336 93c0 2805                 	sts pulse1_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 0 LENGTH
001338 2e8c                      	mov pulse1_length_counter, r28
                                 
                                 	//CHANNEL 0 SEQUENCE
001339 e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
00133a 2e7c                      	mov pulse1_sequence, r28
                                 
                                 	//CHANNEL 0 SWEEP
00133b 9090 2801                 	lds pulse1_sweep, pulse1_sweep_param
00133d 9492                      	swap pulse1_sweep //swap data from high byte and low byte
00133e 6890                      	sbr pulse_channel_flags, 0b10000000 //set reload flag
                                 
                                 	//CHANNEL 0 FX
00133f efcf                      	ldi r28, 0xFF
001340 9220 2846                 	sts pulse1_fx_0xy_sequence, zero
001342 9220 2847                 	sts pulse1_fx_0xy_sequence+1, zero
001344 9220 2848                 	sts pulse1_fx_1xx, zero
001346 9220 2849                 	sts pulse1_fx_1xx+1, zero
001348 9220 284a                 	sts pulse1_fx_1xx_total, zero
00134a 9220 284b                 	sts pulse1_fx_1xx_total+1, zero
00134c 9220 284c                 	sts pulse1_fx_2xx, zero
00134e 9220 284d                 	sts pulse1_fx_2xx+1, zero
001350 9220 284e                 	sts pulse1_fx_2xx_total, zero
001352 9220 284f                 	sts pulse1_fx_2xx_total+1, zero
001354 9220 2850                 	sts pulse1_fx_3xx_start, zero
001356 9220 2851                 	sts pulse1_fx_3xx_start+1, zero
001358 9220 2852                 	sts pulse1_fx_3xx_target, zero
00135a 9220 2853                 	sts pulse1_fx_3xx_target+1, zero
00135c 9220 2854                 	sts pulse1_fx_3xx_speed, zero
00135e 9220 2855                 	sts pulse1_fx_3xx_speed+1, zero
001360 9220 2856                 	sts pulse1_fx_3xx_total_offset, zero
001362 9220 2857                 	sts pulse1_fx_3xx_total_offset+1, zero
001364 9220 2858                 	sts pulse1_fx_4xy_speed, zero
001366 9220 2859                 	sts pulse1_fx_4xy_depth, zero
001368 9220 285a                 	sts pulse1_fx_4xy_phase, zero
00136a 9220 285b                 	sts pulse1_fx_7xy_speed, zero
00136c 9220 285c                 	sts pulse1_fx_7xy_depth, zero
00136e 9220 285d                 	sts pulse1_fx_7xy_phase, zero
001370 9220 285e                 	sts pulse1_fx_7xy_value, zero
001372 9220 285f                 	sts pulse1_fx_Axy, zero
001374 93c0 2860                 	sts pulse1_fx_Gxx_pre, r28
001376 93c0 2861                 	sts pulse1_fx_Gxx_post, r28
001378 9220 2862                 	sts pulse1_fx_Pxx_total, zero
00137a 9220 2863                 	sts pulse1_fx_Pxx_total+1, zero
00137c 9220 2864                 	sts pulse1_fx_Qxy_target_note, zero
00137e 9220 2865                 	sts pulse1_fx_Qxy_target, zero
001380 9220 2866                 	sts pulse1_fx_Qxy_target+1, zero
001382 9220 2867                 	sts pulse1_fx_Qxy_speed, zero
001384 9220 2868                 	sts pulse1_fx_Qxy_speed+1, zero
001386 9220 2869                 	sts pulse1_fx_Qxy_total_offset, zero
001388 9220 286a                 	sts pulse1_fx_Qxy_total_offset+1, zero
00138a 9220 286b                 	sts pulse1_fx_Rxy_target_note, zero
00138c 9220 286c                 	sts pulse1_fx_Rxy_target, zero
00138e 9220 286d                 	sts pulse1_fx_Rxy_target+1, zero
001390 9220 286e                 	sts pulse1_fx_Rxy_speed, zero
001392 9220 286f                 	sts pulse1_fx_Rxy_speed+1, zero
001394 9220 2870                 	sts pulse1_fx_Rxy_total_offset, zero
001396 9220 2871                 	sts pulse1_fx_Rxy_total_offset+1, zero
001398 93c0 2872                 	sts pulse1_fx_Sxx_pre, r28
00139a 93c0 2873                 	sts pulse1_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 1 instrument macros
00139c efcf                      	ldi r28, 0xFF
00139d 9220 287c                 	sts pulse2_volume_macro_offset, zero
00139f 93c0 287d                 	sts pulse2_volume_macro_loop, r28
0013a1 93c0 287e                 	sts pulse2_volume_macro_release, r28
0013a3 9220 2881                 	sts pulse2_arpeggio_macro_offset, zero
0013a5 93c0 2882                 	sts pulse2_arpeggio_macro_loop, r28
0013a7 93c0 2883                 	sts pulse2_arpeggio_macro_release, r28
0013a9 93c0 2884                 	sts pulse2_arpeggio_macro_mode, r28
0013ab 9220 2889                 	sts pulse2_pitch_macro_offset, zero
0013ad 93c0 288a                 	sts pulse2_pitch_macro_loop, r28
0013af 93c0 288b                 	sts pulse2_pitch_macro_release, r28
0013b1 9220 288f                 	sts pulse2_hi_pitch_macro_offset, zero
0013b3 93c0 2890                 	sts pulse2_hi_pitch_macro_loop, r28
0013b5 93c0 2891                 	sts pulse2_hi_pitch_macro_release, r28
0013b7 9220 2894                 	sts pulse2_duty_macro_offset, zero
0013b9 93c0 2895                 	sts pulse2_duty_macro_loop, r28
0013bb 93c0 2896                 	sts pulse2_duty_macro_release, r28
                                 
0013bd 9220 287a                 	sts pulse2_volume_macro, zero
0013bf 9220 287b                 	sts pulse2_volume_macro+1, zero
0013c1 9220 287f                 	sts pulse2_arpeggio_macro, zero
0013c3 9220 2880                 	sts pulse2_arpeggio_macro+1, zero
0013c5 9220 2885                 	sts pulse2_total_pitch_offset, zero
0013c7 9220 2886                 	sts pulse2_total_pitch_offset+1, zero
0013c9 9220 2887                 	sts pulse2_pitch_macro, zero
0013cb 9220 2888                 	sts pulse2_pitch_macro+1, zero
0013cd 9220 288c                 	sts pulse2_total_hi_pitch_offset, zero
0013cf 9220 288d                 	sts pulse2_hi_pitch_macro, zero
0013d1 9220 288e                 	sts pulse2_hi_pitch_macro+1, zero
0013d3 9220 2892                 	sts pulse2_duty_macro, zero
0013d5 9220 2893                 	sts pulse2_duty_macro+1, zero
                                 
                                 	//CHANNEL 1 ENVELOPE
0013d7 e02f                      	ldi pulse2_volume_divider, 0x0F
0013d8 9130 2808                 	lds pulse2_volume_decay, pulse2_param
0013da 703f                      	andi pulse2_volume_decay, 0x0F //mask for VVVV bits
0013db 91d0 2808                 	lds r29, pulse2_param
0013dd 73d0                      	andi r29, 0b00110000
0013de 62d0                      	sbr r29, 0b0100000 //set start flag
0013df 95d2                      	swap r29
0013e0 2b9d                      	or pulse_channel_flags, r29
0013e1 9220 280e                 	sts pulse2_output_volume, zero
0013e3 93c0 280d                 	sts pulse2_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 1 LENGTH
0013e5 2ebc                      	mov pulse2_length_counter, r28
                                 
                                 	//CHANNEL 1 SEQUENCE
0013e6 e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
0013e7 2eac                      	mov pulse2_sequence, r28
                                 
                                 	//CHANNEL 1 SWEEP
0013e8 90c0 2809                 	lds pulse2_sweep, pulse2_sweep_param
0013ea 94c2                      	swap pulse2_sweep //swap data from high byte and low byte
0013eb 6098                      	sbr pulse_channel_flags, 0b00001000 //set reload flag
                                 
                                 	//CHANNEL 1 FX
0013ec efcf                      	ldi r28, 0xFF
0013ed 9220 2897                 	sts pulse2_fx_0xy_sequence, zero
0013ef 9220 2898                 	sts pulse2_fx_0xy_sequence+1, zero
0013f1 9220 2899                 	sts pulse2_fx_1xx, zero
0013f3 9220 289a                 	sts pulse2_fx_1xx+1, zero
0013f5 9220 289b                 	sts pulse2_fx_1xx_total, zero
0013f7 9220 289c                 	sts pulse2_fx_1xx_total+1, zero
0013f9 9220 289d                 	sts pulse2_fx_2xx, zero
0013fb 9220 289e                 	sts pulse2_fx_2xx+1, zero
0013fd 9220 289f                 	sts pulse2_fx_2xx_total, zero
0013ff 9220 28a0                 	sts pulse2_fx_2xx_total+1, zero
001401 9220 28a1                 	sts pulse2_fx_3xx_start, zero
001403 9220 28a2                 	sts pulse2_fx_3xx_start+1, zero
001405 9220 28a3                 	sts pulse2_fx_3xx_target, zero
001407 9220 28a4                 	sts pulse2_fx_3xx_target+1, zero
001409 9220 28a5                 	sts pulse2_fx_3xx_speed, zero
00140b 9220 28a6                 	sts pulse2_fx_3xx_speed+1, zero
00140d 9220 28a7                 	sts pulse2_fx_3xx_total_offset, zero
00140f 9220 28a8                 	sts pulse2_fx_3xx_total_offset+1, zero
001411 9220 28a9                 	sts pulse2_fx_4xy_speed, zero
001413 9220 28aa                 	sts pulse2_fx_4xy_depth, zero
001415 9220 28ab                 	sts pulse2_fx_4xy_phase, zero
001417 9220 28ac                 	sts pulse2_fx_7xy_speed, zero
001419 9220 28ad                 	sts pulse2_fx_7xy_depth, zero
00141b 9220 28ae                 	sts pulse2_fx_7xy_phase, zero
00141d 9220 28af                 	sts pulse2_fx_7xy_value, zero
00141f 9220 28b0                 	sts pulse2_fx_Axy, zero
001421 93c0 28b1                 	sts pulse2_fx_Gxx_pre, r28
001423 93c0 28b2                 	sts pulse2_fx_Gxx_post, r28
001425 9220 28b3                 	sts pulse2_fx_Pxx_total, zero
001427 9220 28b4                 	sts pulse2_fx_Pxx_total+1, zero
001429 9220 28b5                 	sts pulse2_fx_Qxy_target_note, zero
00142b 9220 28b6                 	sts pulse2_fx_Qxy_target, zero
00142d 9220 28b7                 	sts pulse2_fx_Qxy_target+1, zero
00142f 9220 28b8                 	sts pulse2_fx_Qxy_speed, zero
001431 9220 28b9                 	sts pulse2_fx_Qxy_speed+1, zero
001433 9220 28ba                 	sts pulse2_fx_Qxy_total_offset, zero
001435 9220 28bb                 	sts pulse2_fx_Qxy_total_offset+1, zero
001437 9220 28bc                 	sts pulse2_fx_Rxy_target_note, zero
001439 9220 28bd                 	sts pulse2_fx_Rxy_target, zero
00143b 9220 28be                 	sts pulse2_fx_Rxy_target+1, zero
00143d 9220 28bf                 	sts pulse2_fx_Rxy_speed, zero
00143f 9220 28c0                 	sts pulse2_fx_Rxy_speed+1, zero
001441 9220 28c1                 	sts pulse2_fx_Rxy_total_offset, zero
001443 9220 28c2                 	sts pulse2_fx_Rxy_total_offset+1, zero
001445 93c0 28c3                 	sts pulse2_fx_Sxx_pre, r28
001447 93c0 28c4                 	sts pulse2_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 2 instrument macros
001449 efcf                      	ldi r28, 0xFF
00144a 9220 28cd                 	sts triangle_volume_macro_offset, zero
00144c 93c0 28ce                 	sts triangle_volume_macro_loop, r28
00144e 93c0 28cf                 	sts triangle_volume_macro_release, r28
001450 9220 28d2                 	sts triangle_arpeggio_macro_offset, zero
001452 93c0 28d3                 	sts triangle_arpeggio_macro_loop, r28
001454 93c0 28d4                 	sts triangle_arpeggio_macro_release, r28
001456 93c0 28d5                 	sts triangle_arpeggio_macro_mode, r28
001458 9220 28da                 	sts triangle_pitch_macro_offset, zero
00145a 93c0 28db                 	sts triangle_pitch_macro_loop, r28
00145c 93c0 28dc                 	sts triangle_pitch_macro_release, r28
00145e 9220 28e0                 	sts triangle_hi_pitch_macro_offset, zero
001460 93c0 28e1                 	sts triangle_hi_pitch_macro_loop, r28
001462 93c0 28e2                 	sts triangle_hi_pitch_macro_release, r28
001464 9220 28e5                 	sts triangle_duty_macro_offset, zero
001466 93c0 28e6                 	sts triangle_duty_macro_loop, r28
001468 93c0 28e7                 	sts triangle_duty_macro_release, r28
                                 
00146a 9220 28cb                 	sts triangle_volume_macro, zero
00146c 9220 28cc                 	sts triangle_volume_macro+1, zero
00146e 9220 28d0                 	sts triangle_arpeggio_macro, zero
001470 9220 28d1                 	sts triangle_arpeggio_macro+1, zero
001472 9220 28d6                 	sts triangle_total_pitch_offset, zero
001474 9220 28d7                 	sts triangle_total_pitch_offset+1, zero
001476 9220 28d8                 	sts triangle_pitch_macro, zero
001478 9220 28d9                 	sts triangle_pitch_macro+1, zero
00147a 9220 28dd                 	sts triangle_total_hi_pitch_offset, zero
00147c 9220 28de                 	sts triangle_hi_pitch_macro, zero
00147e 9220 28df                 	sts triangle_hi_pitch_macro+1, zero
001480 9220 28e3                 	sts triangle_duty_macro, zero
001482 9220 28e4                 	sts triangle_duty_macro+1, zero
                                 
                                 	//CHANNEL 2 SEQUENCE
001484 e0c0                      	ldi r28, 0b00000000 //reset sequence to 0
001485 2f4c                      	mov triangle_sequence, r28
                                 
                                 	//CHANNEL 2 FX
001486 efcf                      	ldi r28, 0xFF
001487 9220 28e8                 	sts triangle_fx_0xy_sequence, zero
001489 9220 28e9                 	sts triangle_fx_0xy_sequence+1, zero
00148b 9220 28ea                 	sts triangle_fx_1xx, zero
00148d 9220 28eb                 	sts triangle_fx_1xx+1, zero
00148f 9220 28ec                 	sts triangle_fx_1xx_total, zero
001491 9220 28ed                 	sts triangle_fx_1xx_total+1, zero
001493 9220 28ee                 	sts triangle_fx_2xx, zero
001495 9220 28ef                 	sts triangle_fx_2xx+1, zero
001497 9220 28f0                 	sts triangle_fx_2xx_total, zero
001499 9220 28f1                 	sts triangle_fx_2xx_total+1, zero
00149b 9220 28f2                 	sts triangle_fx_3xx_start, zero
00149d 9220 28f3                 	sts triangle_fx_3xx_start+1, zero
00149f 9220 28f4                 	sts triangle_fx_3xx_target, zero
0014a1 9220 28f5                 	sts triangle_fx_3xx_target+1, zero
0014a3 9220 28f6                 	sts triangle_fx_3xx_speed, zero
0014a5 9220 28f7                 	sts triangle_fx_3xx_speed+1, zero
0014a7 9220 28f8                 	sts triangle_fx_3xx_total_offset, zero
0014a9 9220 28f9                 	sts triangle_fx_3xx_total_offset+1, zero
0014ab 9220 28fa                 	sts triangle_fx_4xy_speed, zero
0014ad 9220 28fb                 	sts triangle_fx_4xy_depth, zero
0014af 9220 28fc                 	sts triangle_fx_4xy_phase, zero
0014b1 93c0 28fd                 	sts triangle_fx_Gxx_pre, r28
0014b3 93c0 28fe                 	sts triangle_fx_Gxx_post, r28
0014b5 9220 28ff                 	sts triangle_fx_Pxx_total, zero
0014b7 9220 2900                 	sts triangle_fx_Pxx_total+1, zero
0014b9 9220 2901                 	sts triangle_fx_Qxy_target_note, zero
0014bb 9220 2902                 	sts triangle_fx_Qxy_target, zero
0014bd 9220 2903                 	sts triangle_fx_Qxy_target+1, zero
0014bf 9220 2904                 	sts triangle_fx_Qxy_speed, zero
0014c1 9220 2905                 	sts triangle_fx_Qxy_speed+1, zero
0014c3 9220 2906                 	sts triangle_fx_Qxy_total_offset, zero
0014c5 9220 2907                 	sts triangle_fx_Qxy_total_offset+1, zero
0014c7 9220 2908                 	sts triangle_fx_Rxy_target_note, zero
0014c9 9220 2909                 	sts triangle_fx_Rxy_target, zero
0014cb 9220 290a                 	sts triangle_fx_Rxy_target+1, zero
0014cd 9220 290b                 	sts triangle_fx_Rxy_speed, zero
0014cf 9220 290c                 	sts triangle_fx_Rxy_speed+1, zero
0014d1 9220 290d                 	sts triangle_fx_Rxy_total_offset, zero
0014d3 9220 290e                 	sts triangle_fx_Rxy_total_offset+1, zero
0014d5 93c0 290f                 	sts triangle_fx_Sxx_pre, r28
0014d7 93c0 2910                 	sts triangle_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 3 instrument macros
0014d9 efcf                      	ldi r28, 0xFF
0014da 9220 2919                 	sts noise_volume_macro_offset, zero
0014dc 93c0 291a                 	sts noise_volume_macro_loop, r28
0014de 93c0 291b                 	sts noise_volume_macro_release, r28
0014e0 9220 291e                 	sts noise_arpeggio_macro_offset, zero
0014e2 93c0 291f                 	sts noise_arpeggio_macro_loop, r28
0014e4 93c0 2920                 	sts noise_arpeggio_macro_release, r28
0014e6 93c0 2921                 	sts noise_arpeggio_macro_mode, r28
0014e8 9220 2926                 	sts noise_pitch_macro_offset, zero
0014ea 93c0 2927                 	sts noise_pitch_macro_loop, r28
0014ec 93c0 2928                 	sts noise_pitch_macro_release, r28
0014ee 9220 292c                 	sts noise_hi_pitch_macro_offset, zero
0014f0 93c0 292d                 	sts noise_hi_pitch_macro_loop, r28
0014f2 93c0 292e                 	sts noise_hi_pitch_macro_release, r28
0014f4 9220 2931                 	sts noise_duty_macro_offset, zero
0014f6 93c0 2932                 	sts noise_duty_macro_loop, r28
0014f8 93c0 2933                 	sts noise_duty_macro_release, r28
                                 
0014fa 9220 2917                 	sts noise_volume_macro, zero
0014fc 9220 2918                 	sts noise_volume_macro+1, zero
0014fe 9220 291c                 	sts noise_arpeggio_macro, zero
001500 9220 291d                 	sts noise_arpeggio_macro+1, zero
001502 9220 2922                 	sts noise_total_pitch_offset, zero
001504 9220 2923                 	sts noise_total_pitch_offset+1, zero
001506 9220 2924                 	sts noise_pitch_macro, zero
001508 9220 2925                 	sts noise_pitch_macro+1, zero
00150a 9220 2929                 	sts noise_total_hi_pitch_offset, zero
00150c 9220 292a                 	sts noise_hi_pitch_macro, zero
00150e 9220 292b                 	sts noise_hi_pitch_macro+1, zero
001510 9220 292f                 	sts noise_duty_macro, zero
001512 9220 2930                 	sts noise_duty_macro+1, zero
                                 
                                 	//CHANNEL 3 VOLUME
001514 9220 2816                 	sts noise_output_volume, zero
001516 93c0 2815                 	sts noise_fractional_volume, r28 //initialize fractional volume to max value
                                 
                                 	//CHANNEL 3 SEQUENCE
001518 e0c1                      	ldi r28, 0b00000001 //noise sequence is reset to 0x0001
001519 2f5c                      	mov noise_sequence_LOW, r28
00151a 2d62                      	mov noise_sequence_HIGH, zero
                                 
                                 	//CHANNEL 3 FX
00151b efcf                      	ldi r28, 0xFF
00151c 9220 2934                 	sts noise_fx_0xy_sequence, zero
00151e 9220 2935                 	sts noise_fx_0xy_sequence+1, zero
001520 9220 2936                 	sts noise_fx_1xx, zero
001522 9220 2937                 	sts noise_fx_1xx_total, zero
001524 9220 2938                 	sts noise_fx_2xx, zero
001526 9220 2939                 	sts noise_fx_2xx_total, zero
001528 9220 293a                 	sts noise_fx_4xy_speed, zero
00152a 9220 293b                 	sts noise_fx_4xy_depth, zero
00152c 9220 293c                 	sts noise_fx_4xy_phase, zero
00152e 9220 293d                 	sts noise_fx_4xy_offset, zero
001530 9220 293e                 	sts noise_fx_7xy_speed, zero
001532 9220 293f                 	sts noise_fx_7xy_depth, zero
001534 9220 2940                 	sts noise_fx_7xy_phase, zero
001536 9220 2941                 	sts noise_fx_7xy_value, zero
001538 9220 2942                 	sts noise_fx_Axy, zero
00153a 93c0 2943                 	sts noise_fx_Gxx_pre, r28
00153c 93c0 2944                 	sts noise_fx_Gxx_post, r28
00153e 9220 2945                 	sts noise_fx_Pxx_total, zero
001540 93c0 2946                 	sts noise_fx_Sxx_pre, r28
001542 93c0 2947                 	sts noise_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 4 SAMPLE
001544 9220 294e                 	sts dpcm_sample, zero
001546 9220 294f                 	sts dpcm_sample+1, zero
001548 9220 2950                 	sts dpcm_sample_offset, zero
00154a 9220 2951                 	sts dpcm_sample_offset+1, zero
00154c 2cd2                      	mov dpcm_shift, zero
00154d 2ce2                      	mov dpcm_bit_counter, zero
00154e 2cf2                      	mov dpcm_period, zero
00154f 2d72                      	mov dpcm_length_LOW, zero
001550 2d82                      	mov dpcm_length_HIGH, zero
                                 
                                 	//CHANNEL 4 FX
001551 93c0 2943                 	sts noise_fx_Gxx_pre, r28
001553 93c0 2944                 	sts noise_fx_Gxx_post, r28
001555 93c0 2946                 	sts noise_fx_Sxx_pre, r28
001557 93c0 2947                 	sts noise_fx_Sxx_post, r28
                                 
                                 	//PINS
001559 efcf                      	ldi r28, 0xFF
00155a b9c0                      	out VPORTA_DIR, r28 //set all pins in VPORTA to output
                                 
                                 	//TIMERS
                                 
                                 	//NOTE: Channel Timers are clocked (20/2)/(0.8948865) = 11.1746014718 times faster than the NES APU
                                 	//Because of this, we multiply all the NES timer values by 11.1746014718 beforehand
                                 	//Since we rotate the sequence when the timer goes from t-(t-1) to 0, instead of 0 to t like the NES, we add 1 to the NES timers before multiplying
                                 	//The ATmega4809 is configured to run at 20 MHz
                                 	//The /2 comes from the prescaler divider used
                                 	//0.8948865 MHz is the speed of the NTSC NES APU
                                 	//NOTE: This means that any offset to the pitch for the NES timers would be multiplied by 11.1746014718 aswell.
                                 	//Pulse 1
00155b e0c0                      	ldi r28, TCB_CNTMODE_INT_gc //interrupt mode
00155c 93c0 0a81                 	sts TCB0_CTRLB, r28
00155e e0c1                      	ldi r28, TCB_CAPT_bm //enable interrupts
00155f 93c0 0a85                 	sts TCB0_INTCTRL, r28
001561 91c0 2802                 	lds r28, pulse1_timerL //load the LOW bits for timer
001563 93c0 0a8c                 	sts TCB0_CCMPL, r28
001565 91c0 2803                 	lds r28, pulse1_timerH //load the HIGH bits for timer
001567 93c0 0a8d                 	sts TCB0_CCMPH, r28
001569 e0c3                      	ldi r28, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
00156a 93c0 0a80                 	sts TCB0_CTRLA, r28
                                 
                                 	//PULSE 2
00156c e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
00156d 93b0 0a91                 	sts TCB1_CTRLB, r27
00156f e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001570 93b0 0a95                 	sts TCB1_INTCTRL, r27
001572 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
001574 93b0 0a9c                 	sts TCB1_CCMPL, r27
001576 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
001578 93b0 0a9d                 	sts TCB1_CCMPH, r27
00157a e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
00157b 93b0 0a90                 	sts TCB1_CTRLA, r27
                                 
                                 	//NOTE: The triangle timer is clocked at the same speed as the NES CPU, aka twice the NES APU.
                                 	//Therefore, we won't be using a /2 clock divider like we did with the pulse timers.
                                 	//TRIANGLE
00157d e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
00157e 93b0 0aa1                 	sts TCB2_CTRLB, r27
001580 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
                                 	//sts TCB2_INTCTRL, r27 //keep interrupts disabled to mute channel since triangle doesn't have volume bits
001581 91b0 2810                 	lds r27, triangle_timerL //load the LOW bits for timer
001583 93b0 0aac                 	sts TCB2_CCMPL, r27
001585 91b0 2811                 	lds r27, triangle_timerH //load the HIGH bits for timer
001587 93b0 0aad                 	sts TCB2_CCMPH, r27
001589 e0b1                      	ldi r27, TCB_CLKSEL_CLKDIV1_gc | TCB_ENABLE_bm //use prescaler divider of 1 and enable timer
00158a 93b0 0aa0                 	sts TCB2_CTRLA, r27
00158c 9478                      	sei //global interrupt enable
                                 
                                 	//NOISE
00158d e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
00158e 93b0 0ab1                 	sts TCB3_CTRLB, r27
001590 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001591 93b0 0ab5                 	sts TCB3_INTCTRL, r27
001593 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
001595 93b0 0abc                 	sts TCB3_CCMPL, r27
001597 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
001599 93b0 0abd                 	sts TCB3_CCMPH, r27
00159b e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
00159c 93b0 0ab0                 	sts TCB3_CTRLA, r27
                                 
                                 	//DPCM
                                 /*	ldi r28, TCA_SINGLE_CMP0EN_bm | TCA_SINGLE_CMP1EN_bm | TCA_SINGLE_CMP2EN_bm | TCA_SINGLE_WGMODE_NORMAL_gc //interrupt mode
                                 	sts TCA0_SINGLE_CTRLB, r28
                                 	ldi r28, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP1_bm | TCA_SINGLE_CMP2_bm | TCA_SINGLE_OVF_bm //enable overflow and compare interrupts
                                 	sts TCA0_SINGLE_INTCTRL, r28
                                 	ldi r28, 0x15 //set the period for CMP0
                                 	sts TCA0_SINGLE_CMP0, r28
                                 	ldi r28, 0x05
                                 	sts TCA0_SINGLE_CMP0 + 1, r28
                                 	ldi r28, 0x2B //set the period for CMP1
                                 	sts TCA0_SINGLE_CMP1, r28
                                 	ldi r28, 0x0A
                                 	sts TCA0_SINGLE_CMP1 + 1, r28
                                 	ldi r28, 0x41 //set the period for CMP2
                                 	sts TCA0_SINGLE_CMP2, r28
                                 	ldi r28, 0x0F
                                 	sts TCA0_SINGLE_CMP2 + 1, r28
                                 	ldi r28, 0x57 //set the period for OVF
                                 	sts TCA0_SINGLE_PER, r28
                                 	ldi r28, 0x14
                                 	sts TCA0_SINGLE_PER + 1, r28
                                 	ldi r28, TCA_SINGLE_CLKSEL_DIV64_gc | TCA_SINGLE_ENABLE_bm //use prescale divider of 64 and enable timer
                                 	sts TCA0_SINGLE_CTRLA, r28*/
                                 
                                 	//RTC
                                 	//Frame Counter
                                 	//NOTE:The frame counter will be defaulted to NTSC mode (60 Hz, 120 Hz, 240 Hz)
                                 	//Interrupts will be setup to interrupt every 240 Hz clock
                                 	//The 4th consecutive interrupt will clock the sound driver every 60Hz, in which new audio data is read and written to the registers
                                 	//1st and 2nd interrupt will execute sequence 0 and 2. 3rd and 4th interrupt will execute sequence 1 and 3.
                                 	//Timer period Calculation: (0.00416666666 * 32768/8)-1 = 16.0666666394 = 0x0010
                                 	//The RTC timer is clocked at 32768 Hz
                                 	//0.00416666666 seconds is the period for 240 Hz
                                 	//The /8 comes from the prescaler divider used
00159e e0b0                      	ldi r27, RTC_CLKSEL_INT32K_gc //internal 32kHz oscillator
00159f 93b0 0147                 	sts RTC_CLKSEL, r27
0015a1 e1b0                      	ldi r27, 0x10
0015a2 e0c0                      	ldi r28, 0x00
0015a3 93b0 014a                 	sts RTC_PER, r27
0015a5 93c0 014b                 	sts RTC_PER + 1, r28
0015a7 e0b1                      	ldi r27, RTC_OVF_bm //overflow interrupts
0015a8 93b0 0142                 	sts RTC_INTCTRL, r27
0015aa e1b9                      	ldi r27, RTC_PRESCALER_DIV8_gc | RTC_PITEN_bm //use prescaler divider of 2 and enable RTC
0015ab 93b0 0140                 	sts RTC_CTRLA, r27
                                 
                                 
                                 
                                 //https://wiki.nesdev.com/w/index.php/APU_Mixer
                                 volume_mixer:
0015ad 91c0 2806                 	lds r28, pulse1_output_volume
0015af 91d0 280e                 	lds r29, pulse2_output_volume
                                 
                                 volume_mixer_pulse1:
0015b1 fe70                      	sbrs pulse1_sequence, 0 //if the sequence output is zero, return
0015b2 c015                      	rjmp volume_mixer_pulse1_off
                                 
0015b3 1482                      	cp pulse1_length_counter, zero //if length is zero, return
0015b4 f099                      	breq volume_mixer_pulse1_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
0015b5 91e0 0a8c                 	lds r30, TCB0_CCMPL
0015b7 e5f9                      	ldi r31, 0x59
0015b8 17ef                      	cp r30, r31
0015b9 91e0 0a8d                 	lds r30, TCB0_CCMPH
0015bb e0f0                      	ldi r31, 0x00
0015bc 07ef                      	cpc r30, r31
0015bd f050                      	brlo volume_mixer_pulse1_off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $595A
0015be 91e0 0a8c                 	lds r30, TCB0_CCMPL
0015c0 e5fa                      	ldi r31, 0x5A
0015c1 17ef                      	cp r30, r31
0015c2 91e0 0a8d                 	lds r30, TCB0_CCMPH
0015c4 e5f9                      	ldi r31, 0x59
0015c5 07ef                      	cpc r30, r31
0015c6 f408                      	brsh volume_mixer_pulse1_off
0015c7 c001                      	rjmp volume_mixer_pulse2 //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse1_off:
0015c8 27cc                      	clr r28
                                 
                                 volume_mixer_pulse2:
0015c9 fea0                      	sbrs pulse2_sequence, 0 //if the sequence output is zero, return
0015ca c015                      	rjmp volume_mixer_pulse2_off
                                 
0015cb 14b2                      	cp pulse2_length_counter, zero //if length is zero, return
0015cc f099                      	breq volume_mixer_pulse2_off
                                 
0015cd 91e0 0a9c                 	lds r30, TCB1_CCMPL
0015cf e5f9                      	ldi r31, 0x59
0015d0 17ef                      	cp r30, r31
0015d1 91e0 0a9d                 	lds r30, TCB1_CCMPH
0015d3 e0f0                      	ldi r31, 0x00
0015d4 07ef                      	cpc r30, r31
0015d5 f050                      	brlo volume_mixer_pulse2_off
                                 
0015d6 91e0 0a9c                 	lds r30, TCB1_CCMPL
0015d8 e5fa                      	ldi r31, 0x5A
0015d9 17ef                      	cp r30, r31
0015da 91e0 0a9d                 	lds r30, TCB1_CCMPH
0015dc e5f9                      	ldi r31, 0x59
0015dd 07ef                      	cpc r30, r31
0015de f408                      	brsh volume_mixer_pulse2_off
0015df c001                      	rjmp volume_mixer_pulse_out //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse2_off:
0015e0 27dd                      	clr r29
                                 
                                 volume_mixer_pulse_out:
0015e1 0fcd                      	add r28, r29
0015e2 e6e2                      	ldi ZL, LOW(pulse_volume_table << 1)
0015e3 e0f2                      	ldi ZH, HIGH(pulse_volume_table << 1)
0015e4 0fec                      	add ZL, r28
0015e5 1df2                      	adc ZH, zero
0015e6 91c4                      	lpm r28, Z
                                 
                                 volume_mixer_tnd_triangle:
0015e7 2fd4                      	mov r29, triangle_sequence
0015e8 fdd4                      	sbrc r29, 4 //check 5th bit
0015e9 95d0                      	com r29
0015ea 70df                      	andi r29, 0x0F
0015eb 2fed                      	mov r30, r29
0015ec 0fde                      	add r29, r30 //multiply the triangle volume by 3
0015ed 0fde                      	add r29, r30
                                 
                                 volume_mixer_tnd_noise:
0015ee ff50                      	sbrs noise_sequence_LOW, 0 //check 0th bit, skip if set
0015ef c004                      	rjmp volume_mixer_tnd_out
0015f0 91e0 2816                 	lds r30, noise_output_volume
0015f2 0fee                      	lsl r30 //multiply noise volume by 2
0015f3 0fde                      	add r29, r30
                                 
                                 volume_mixer_tnd_out:
0015f4 e8e2                      	ldi ZL, LOW(tnd_volume_table << 1)
0015f5 e0f2                      	ldi ZH, HIGH(tnd_volume_table << 1)
0015f6 0fed                      	add ZL, r29
0015f7 1df2                      	adc ZH, zero
0015f8 91d4                      	lpm r29, Z
                                 
                                 volume_mixer_output:
0015f9 0fcd                      	add r28, r29
0015fa b9c1                      	out VPORTA_OUT, r28
0015fb cfb1                      	rjmp volume_mixer
                                 
                                 
                                 
                                 //FRAME COUNTER/AUDIO SAMPLE ISR
                                 frame_counter_routine:
0015fc b7bf                      	in r27, CPU_SREG
0015fd 93bf                      	push r27
0015fe 94f8                      	cli
                                 
0015ff 2da4                      	mov r26, frame_sequence
001600 0c43                      	add frame_sequence, one
001601 30a0                      	cpi r26, 0x00
001602 f029                      	breq sequence_0_2
001603 30a1                      	cpi r26, 0x01
001604 f059                      	breq sequence_1_3
001605 30a2                      	cpi r26, 0x02
001606 f009                      	breq sequence_0_2
001607 c0f3                      	rjmp sound_driver
                                 
                                 sequence_0_2:
                                 	//ENVELOPE
001608 d050                      	rcall pulse1_envelope_routine
001609 d09c                      	rcall pulse2_envelope_routine
                                 
00160a e0b3                      	ldi r27, RTC_CMP_bm | RTC_OVF_bm //clear OVF flag
00160b 93b0 0143                 	sts RTC_INTFLAGS, r27
00160d 91bf                      	pop r27
00160e bfbf                      	out CPU_SREG, r27
00160f 9518                      	reti
                                 
                                 sequence_1_3:
                                 	//ENVELOPE
001610 d048                      	rcall pulse1_envelope_routine
001611 d094                      	rcall pulse2_envelope_routine
                                 
                                 	//SWEEP
001612 fc93                      	sbrc pulse1_sweep, 3 //check if the sweep enable bit is cleared
001613 d01b                      	rcall pulse1_sweep_routine
001614 fcc3                      	sbrc pulse2_sweep, 3
001615 d066                      	rcall pulse2_sweep_routine
                                 
                                 	//LENGTH
                                 	//NOTE: The length routine is relatively simple, so we will not be using clocks to rjmp and ret to a seperate lable
                                 sequence_1_3_pulse1_length:
001616 fd95                      	sbrc pulse_channel_flags, 5 //check if the length counter halt bit is cleared
001617 c002                      	rjmp sequence_1_3_pulse2_length
001618 1082                      	cpse pulse1_length_counter, zero //if length counter is already 0, don't decrement
001619 948a                      	dec pulse1_length_counter
                                 sequence_1_3_pulse2_length:
00161a fd91                      	sbrc pulse_channel_flags, 1 //check if the length counter halt bit is cleared
00161b c002                      	rjmp sequence_1_3_exit
00161c 10b2                      	cpse pulse2_length_counter, zero //if length counter is already 0, don't decrement
00161d 94ba                      	dec pulse2_length_counter
                                 
                                 sequence_1_3_exit:
00161e e0b1                      	ldi r27, RTC_OVF_bm //clear OVF flag
00161f 93b0 0143                 	sts RTC_INTFLAGS, r27
001621 91bf                      	pop r27
001622 bfbf                      	out CPU_SREG, r27
001623 9518                      	reti
                                 
                                 //PULSE 1 ROUTINES
                                 pulse1_sequence_routine:
001624 b7bf                      	in r27, CPU_SREG
001625 93bf                      	push r27
001626 94f8                      	cli
                                 
001627 0c77                      	lsl pulse1_sequence //shifts sequence to the left
001628 1c72                      	adc pulse1_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
001629 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
00162a 93b0 0a86                 	sts TCB0_INTFLAGS, r27
00162c 91bf                      	pop r27
00162d bfbf                      	out CPU_SREG, r27
00162e 9518                      	reti
                                 
                                 pulse1_sweep_routine:
00162f 2db9                      	mov r27, pulse1_sweep
001630 70b7                      	andi r27, 0x07 //mask for period divider bits
001631 f4f9                      	brne pulse1_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse1_sweep_routine_action: //if the divider is == 0, update the pulse timer period
001632 93df                      	push r29
001633 2dd9                      	mov r29, pulse1_sweep
001634 95d2                      	swap r29
001635 70d7                      	andi r29, 0x07 //mask for shift bits
001636 f411                      	brne pulse1_sweep_routine_action_main //shift != 0
001637 91df                      	pop r29
001638 c019                      	rjmp pulse1_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse1_sweep_routine_action_main:
001639 91a0 0a8c                 	lds r26, TCB0_CCMPL
00163b 91b0 0a8d                 	lds r27, TCB0_CCMPH
                                 pulse1_sweep_routine_action_main_loop:
00163d 95b6                      	lsr r27
00163e 95a7                      	ror r26
00163f 95da                      	dec r29
001640 f7e1                      	brne pulse1_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
001641 fe97                      	sbrs pulse1_sweep, 7 //check the negate flag
001642 c002                      	rjmp pulse1_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
001643 95a0                      	com r26 //pulse1 uses one's complement if the negate flag is set
001644 95b0                      	com r27
                                 
                                 pulse1_sweep_routine_action_main_add:
001645 91d0 0a8c                 	lds r29, TCB0_CCMPL //perform addition to get new timer period
001647 0fad                      	add r26, r29
001648 91d0 0a8d                 	lds r29, TCB0_CCMPH
00164a 1fbd                      	adc r27, r29
                                 
00164b 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new LOW bits for timer
00164d 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new HIGH bits for timer
                                 	
00164f 91df                      	pop r29
001650 c001                      	rjmp pulse1_sweep_routine_check_reload
                                 
                                 pulse1_sweep_routine_decrement_divider:
001651 949a                      	dec pulse1_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse1_sweep_routine_check_reload:
001652 ff97                      	sbrs pulse_channel_flags, 7 //if the reload flag is set, reload the sweep divider
001653 9508                      	ret
                                 
                                 pulse1_sweep_reload:
001654 9090 2801                 	lds pulse1_sweep, pulse1_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
001656 9492                      	swap pulse1_sweep //bring data from high byte to low byte
001657 779f                      	cbr pulse_channel_flags, 0b10000000 //clear reload flag
001658 9508                      	ret
                                 
                                 
                                 
                                 pulse1_envelope_routine:
001659 fd96                      	sbrc pulse_channel_flags, 6 //check if start flag is cleared
00165a c010                      	rjmp pulse1_envelope_routine_clear_start
                                 
00165b 3000                      	cpi pulse1_volume_divider, 0x00 //check if the divider is 0
00165c f011                      	breq PC+3 //if the divider == 0, check loop flag
00165d 950a                      	dec pulse1_volume_divider //if the divider != 0, decrement and return
00165e 9508                      	ret
                                 
00165f 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the divider == 0, reset the divider period
001661 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
001662 ff95                      	sbrs pulse_channel_flags, 5 //check if the loop flag is set
001663 c002                      	rjmp pulse1_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
001664 e01f                      	ldi pulse1_volume_decay, 0x0F //if the loop flag is set, reset decay and return
001665 9508                      	ret
                                 
                                 pulse1_envelope_routine_decrement_decay:
001666 3010                      	cpi pulse1_volume_decay, 0x00 //check if the decay is 0
001667 f409                      	brne PC+2 //if decay != 0, go decrement
001668 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
001669 951a                      	dec pulse1_volume_decay
00166a 9508                      	ret
                                 
                                 pulse1_envelope_routine_clear_start:
00166b 7b9f                      	cbr pulse_channel_flags, 0b01000000 //if the start flag is set, clear it
00166c 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the start flag is set, reset the divider period
00166e 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
00166f e01f                      	ldi pulse1_volume_decay, 0x0F //if the start flag is set, reset decay
001670 9508                      	ret
                                 
                                 //PULSE 2 ROUTINES
                                 pulse2_sequence_routine:
001671 b7bf                      	in r27, CPU_SREG
001672 93bf                      	push r27
001673 94f8                      	cli
                                 
001674 0caa                      	lsl pulse2_sequence //shifts sequence to the left
001675 1ca2                      	adc pulse2_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
001676 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
001677 93b0 0a96                 	sts TCB1_INTFLAGS, r27
001679 91bf                      	pop r27
00167a bfbf                      	out CPU_SREG, r27
00167b 9518                      	reti
                                 
                                 pulse2_sweep_routine:
00167c 2dbc                      	mov r27, pulse2_sweep
00167d 70b7                      	andi r27, 0x07 //mask for period divider bits
00167e f4f9                      	brne pulse2_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse2_sweep_routine_action: //if the divider is == 0, update the pulse timer period
00167f 93df                      	push r29
001680 2ddc                      	mov r29, pulse2_sweep
001681 95d2                      	swap r29
001682 70d7                      	andi r29, 0x07 //mask for shift bits
001683 f411                      	brne pulse2_sweep_routine_action_main //shift != 0
001684 91df                      	pop r29
001685 c019                      	rjmp pulse2_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse2_sweep_routine_action_main:
001686 91a0 0a9c                 	lds r26, TCB1_CCMPL
001688 91b0 0a9d                 	lds r27, TCB1_CCMPH
                                 pulse2_sweep_routine_action_main_loop:
00168a 95b6                      	lsr r27
00168b 95a7                      	ror r26
00168c 95da                      	dec r29
00168d f7e1                      	brne pulse2_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
00168e fec7                      	sbrs pulse2_sweep, 7 //check the negate flag
00168f c002                      	rjmp pulse2_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
001690 95a0                      	com r26 //pulse2 uses one's complement if the negate flag is set
001691 95b0                      	com r27
                                 
                                 pulse2_sweep_routine_action_main_add:
001692 91d0 0a9c                 	lds r29, TCB1_CCMPL //perform addition to get new timer period
001694 0fad                      	add r26, r29
001695 91d0 0a9d                 	lds r29, TCB1_CCMPH
001697 1fbd                      	adc r27, r29
                                 
001698 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new LOW bits for timer
00169a 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new HIGH bits for timer
                                 	
00169c 91df                      	pop r29
00169d c001                      	rjmp pulse2_sweep_routine_check_reload
                                 
                                 pulse2_sweep_routine_decrement_divider:
00169e 94ca                      	dec pulse2_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse2_sweep_routine_check_reload:
00169f ff93                      	sbrs pulse_channel_flags, 3 //if the reload flag is set, reload the sweep divider
0016a0 9508                      	ret
                                 
                                 pulse2_sweep_reload:
0016a1 90c0 2809                 	lds pulse2_sweep, pulse2_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
0016a3 94c2                      	swap pulse2_sweep //bring data from high byte to low byte
0016a4 7f97                      	cbr pulse_channel_flags, 0b00001000 //clear reload flag
0016a5 9508                      	ret
                                 
                                 
                                 
                                 pulse2_envelope_routine:
0016a6 fd92                      	sbrc pulse_channel_flags, 2 //check if start flag is cleared
0016a7 c010                      	rjmp pulse2_envelope_routine_clear_start
                                 
0016a8 3020                      	cpi pulse2_volume_divider, 0x00 //check if the divider is 0
0016a9 f011                      	breq PC+3 //if the divider == 0, check loop flag
0016aa 952a                      	dec pulse2_volume_divider //if the divider != 0, decrement and return
0016ab 9508                      	ret
                                 
0016ac 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the divider == 0, reset the divider period
0016ae 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
0016af ff91                      	sbrs pulse_channel_flags, 1 //check if the loop flag is set
0016b0 c002                      	rjmp pulse2_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
0016b1 e03f                      	ldi pulse2_volume_decay, 0x0F //if the loop flag is set, reset decay and return
0016b2 9508                      	ret
                                 
                                 pulse2_envelope_routine_decrement_decay:
0016b3 3030                      	cpi pulse2_volume_decay, 0x00 //check if the decay is 0
0016b4 f409                      	brne PC+2 //if decay != 0, go decrement
0016b5 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
0016b6 953a                      	dec pulse2_volume_decay
0016b7 9508                      	ret
                                 
                                 pulse2_envelope_routine_clear_start:
0016b8 7f9b                      	cbr pulse_channel_flags, 0b00000100 //if the start flag is set, clear it
0016b9 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the start flag is set, reset the divider period
0016bb 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
0016bc e03f                      	ldi pulse2_volume_decay, 0x0F //if the start flag is set, reset decay
0016bd 9508                      	ret
                                 
                                 //TRIANGLE ROUTINES
                                 triangle_sequence_routine:
0016be b7bf                      	in r27, CPU_SREG
0016bf 93bf                      	push r27
0016c0 94f8                      	cli
                                 
0016c1 5f4f                      	subi triangle_sequence, -1 //increment sequence by 1
0016c2 714f                      	andi triangle_sequence, 0b00011111 //mask out bits 5, 6 and 7 NOTE: the sequence only needs bits 0-4.
                                 
0016c3 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
0016c4 93b0 0aa6                 	sts TCB2_INTFLAGS, r27
0016c6 91bf                      	pop r27
0016c7 bfbf                      	out CPU_SREG, r27
0016c8 9518                      	reti
                                 
                                 //NOISE ROUTINES
                                 noise_sequence_routine:
0016c9 b7bf                      	in r27, CPU_SREG
0016ca 93bf                      	push r27
0016cb 94f8                      	cli
                                 
0016cc 2fa5                      	mov r26, noise_sequence_LOW
0016cd fd67                      	sbrc noise_sequence_HIGH, 7 //skip if MODE bit is clear
0016ce c00b                      	rjmp noise_sequence_routine_mode_set
                                 
                                 noise_sequence_routine_mode_clear:
0016cf 95a6                      	lsr r26 //move the 1th bit to the 0th bit place
0016d0 27a5                      	eor r26, noise_sequence_LOW
0016d1 fda0                      	sbrc r26, 0 //skip if the EOR of bit 0 and 1 is clear
0016d2 c003                      	rjmp noise_sequence_routine_mode_clear_EOR_set
                                 
                                 noise_sequence_routine_mode_clear_EOR_clear:
0016d3 9566                      	lsr noise_sequence_HIGH
0016d4 9557                      	ror noise_sequence_LOW
0016d5 c013                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_clear_EOR_set:
0016d6 9566                      	lsr noise_sequence_HIGH
0016d7 9557                      	ror noise_sequence_LOW
0016d8 6460                      	ori noise_sequence_HIGH, 0b01000000 //set the 14th bit
0016d9 c00f                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_set:
0016da 0faa                      	lsl r26
0016db 1faa                      	rol r26
0016dc 1faa                      	rol r26 //move the 6th bit to the 0th bit place
0016dd 27a5                      	eor r26, noise_sequence_LOW
0016de fda0                      	sbrc r26, 0 //skip if the EOR of bit 0 and 1 is clear
0016df c005                      	rjmp noise_sequence_routine_mode_set_EOR_set
                                 
                                 noise_sequence_routine_mode_set_EOR_clear:
0016e0 776f                      	cbr noise_sequence_HIGH, 0b10000000 //clear the MODE flag
0016e1 9566                      	lsr noise_sequence_HIGH
0016e2 9557                      	ror noise_sequence_LOW
0016e3 6860                      	sbr noise_sequence_HIGH, 0b10000000 //set the MODE flag
0016e4 c004                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_set_EOR_set:
0016e5 9566                      	lsr noise_sequence_HIGH
0016e6 9557                      	ror noise_sequence_LOW
0016e7 6860                      	sbr noise_sequence_HIGH, 0b10000000 //set the MODE flag
0016e8 c000                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_exit:
0016e9 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
0016ea 93b0 0ab6                 	sts TCB3_INTFLAGS, r27
0016ec 91bf                      	pop r27
0016ed bfbf                      	out CPU_SREG, r27
0016ee 9518                      	reti
                                 
                                 //CONVERTERS
                                 //converts and loads 5 bit length to corresponding 8 bit length value into r29
                                 length_converter:
0016ef edec                      	ldi ZL, LOW(length << 1)
0016f0 e6f0                      	ldi ZH, HIGH(length << 1)
0016f1 0fed                      	add ZL, r29
0016f2 1df2                      	adc ZH, zero
0016f3 91d4                      	lpm r29, Z
0016f4 9508                      	ret
                                 
                                 //loads pulse sequence into r29
                                 duty_cycle_sequences:
0016f5 efec                      	ldi ZL, LOW(sequences << 1)
0016f6 e6f0                      	ldi ZH, HIGH(sequences << 1)
0016f7 0fed                      	add ZL, r29
0016f8 1df2                      	adc ZH, zero
0016f9 91d4                      	lpm r29, Z
0016fa 9508                      	ret
                                 
                                 
                                 
                                 //SOUND DRIVER
                                 sound_driver:
0016fb 2c42                      	mov frame_sequence, zero
0016fc 93cf                      	push r28
0016fd 93df                      	push r29
0016fe 93ef                      	push r30
0016ff 93ff                      	push r31
                                 
                                 	//SOUND DRIVER
001700 91a0 2820                 	lds r26, song_fx_Bxx
001702 3faf                      	cpi r26, 0xFF //0xFF means that the flag is disabled
001703 f4a9                      	brne sound_driver_fx_Bxx_routine
001704 91a0 2821                 	lds r26, song_fx_Cxx
001706 11a2                      	cpse r26, zero
001707 c0a3                      	rjmp sound_driver_fx_Cxx_routine
001708 91a0 2822                 	lds r26, song_fx_Dxx
00170a 11a2                      	cpse r26, zero
00170b c0ae                      	rjmp sound_driver_fx_Dxx_routine
                                 
00170c 91a0 281b                 	lds r26, song_frame_offset
00170e 91b0 281c                 	lds r27, song_frame_offset+1
001710 91c0 281d                 	lds r28, song_size
001712 91d0 281e                 	lds r29, song_size+1
001714 17ac                      	cp r26, r28
001715 07bd                      	cpc r27, r29
001716 f408                      	brsh sound_driver_fx_song_loop
001717 c131                      	rjmp sound_driver_channel0
                                 
                                 
                                 sound_driver_fx_song_loop:
001718 e0a0                      	ldi r26, 0x00
                                 sound_driver_fx_Bxx_routine:
001719 91e0 2819                 	lds ZL, song_frames
00171b 91f0 281a                 	lds ZH, song_frames+1
00171d 27cc                      	clr r28 //initialize r29:r28 to 0
00171e 27dd                      	clr r29
00171f 95a3                      	inc r26 //increment xx parameter by 1
                                 sound_driver_fx_Bxx_routine_loop:
001720 95aa                      	dec r26
001721 f011                      	breq sound_driver_fx_Bxx_routine_loop_exit //once r26 == 0, r29:r28 will hold Bxx*(5*2).
001722 962a                      	adiw r29:r28, 10 //increment the offset by 10 because 5 channels, and each address takes 2 bytes (5*2 = 10)
001723 cffc                      	rjmp sound_driver_fx_Bxx_routine_loop
                                 
                                 sound_driver_fx_Bxx_routine_loop_exit:
001724 9622                      	adiw r29:r28, 2 //add 2 to skip the first 2 bytes (first 2 bytes is the song size)
001725 93c0 281b                 	sts song_frame_offset, r28
001727 93d0 281c                 	sts song_frame_offset+1, r29
001729 0fec                      	add ZL, r28
00172a 1ffd                      	adc ZH, r29
                                 
00172b 91a5                      	lpm r26, Z+ //load the address of the frame(pattern)
00172c 91b5                      	lpm r27, Z+
00172d 0faa                      	lsl r26
00172e 1fbb                      	rol r27
00172f 93a0 2823                 	sts pulse1_pattern, r26
001731 93b0 2824                 	sts pulse1_pattern+1, r27
001733 91a5                      	lpm r26, Z+
001734 91b5                      	lpm r27, Z+
001735 0faa                      	lsl r26
001736 1fbb                      	rol r27
001737 93a0 2874                 	sts pulse2_pattern, r26
001739 93b0 2875                 	sts pulse2_pattern+1, r27
00173b 91a5                      	lpm r26, Z+
00173c 91b5                      	lpm r27, Z+
00173d 0faa                      	lsl r26
00173e 1fbb                      	rol r27
00173f 93a0 28c5                 	sts triangle_pattern, r26
001741 93b0 28c6                 	sts triangle_pattern+1, r27
001743 91a5                      	lpm r26, Z+
001744 91b5                      	lpm r27, Z+
001745 0faa                      	lsl r26
001746 1fbb                      	rol r27
001747 93a0 2911                 	sts noise_pattern, r26
001749 93b0 2912                 	sts noise_pattern+1, r27
00174b 91a5                      	lpm r26, Z+
00174c 91b5                      	lpm r27, Z+
00174d 0faa                      	lsl r26
00174e 1fbb                      	rol r27
00174f 93a0 2948                 	sts dpcm_pattern, r26
001751 93b0 2949                 	sts dpcm_pattern+1, r27
                                 
001753 9220 2827                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001755 9220 2828                 	sts pulse1_pattern_offset+1, zero
001757 9220 2825                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
001759 9220 2826                 	sts pulse1_pattern_delay_frames, zero
00175b 9220 2878                 	sts pulse2_pattern_offset, zero
00175d 9220 2879                 	sts pulse2_pattern_offset+1, zero
00175f 9220 2876                 	sts pulse2_pattern_delay_rows, zero
001761 9220 2877                 	sts pulse2_pattern_delay_frames, zero
001763 9220 28c9                 	sts triangle_pattern_offset, zero
001765 9220 28ca                 	sts triangle_pattern_offset+1, zero
001767 9220 28c7                 	sts triangle_pattern_delay_rows, zero
001769 9220 28c8                 	sts triangle_pattern_delay_frames, zero
00176b 9220 2915                 	sts noise_pattern_offset, zero
00176d 9220 2916                 	sts noise_pattern_offset+1, zero
00176f 9220 2913                 	sts noise_pattern_delay_rows, zero
001771 9220 2914                 	sts noise_pattern_delay_frames, zero
001773 9220 294c                 	sts dpcm_pattern_offset, zero
001775 9220 294c                 	sts dpcm_pattern_offset, zero
001777 9220 294a                 	sts dpcm_pattern_delay_rows, zero
001779 9220 294b                 	sts dpcm_pattern_delay_frames, zero
                                 
00177b efaf                      	ldi r26, 0xFF
00177c 93a0 2860                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
00177e 93a0 2861                 	sts pulse1_fx_Gxx_post, r26
001780 93a0 2872                 	sts pulse1_fx_Sxx_pre, r26
001782 93a0 2873                 	sts pulse1_fx_Sxx_post, r26
001784 93a0 28b1                 	sts pulse2_fx_Gxx_pre, r26
001786 93a0 28b2                 	sts pulse2_fx_Gxx_post, r26
001788 93a0 28c3                 	sts pulse2_fx_Sxx_pre, r26
00178a 93a0 28c4                 	sts pulse2_fx_Sxx_post, r26
00178c 93a0 28fd                 	sts triangle_fx_Gxx_pre, r26
00178e 93a0 28fe                 	sts triangle_fx_Gxx_post, r26
001790 93a0 290f                 	sts triangle_fx_Sxx_pre, r26
001792 93a0 2910                 	sts triangle_fx_Sxx_post, r26
001794 93a0 2943                 	sts noise_fx_Gxx_pre, r26
001796 93a0 2944                 	sts noise_fx_Gxx_post, r26
001798 93a0 2946                 	sts noise_fx_Sxx_pre, r26
00179a 93a0 2947                 	sts noise_fx_Sxx_post, r26
00179c 93a0 2952                 	sts dpcm_fx_Gxx_pre, r26
00179e 93a0 2953                 	sts dpcm_fx_Gxx_post, r26
0017a0 93a0 2954                 	sts dpcm_fx_Sxx_pre, r26
0017a2 93a0 2955                 	sts dpcm_fx_Sxx_post, r26
                                 
0017a4 93a0 2820                 	sts song_fx_Bxx, r26 //reset all song effects
0017a6 9220 2821                 	sts song_fx_Cxx, zero
0017a8 9220 2822                 	sts song_fx_Dxx, zero
0017aa c09e                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_fx_Cxx_routine:
0017ab 91ff                      	pop r31
0017ac 91ef                      	pop r30
0017ad 91df                      	pop r29
0017ae 91cf                      	pop r28
0017af 91bf                      	pop r27
0017b0 bfbf                      	out CPU_SREG, r27
0017b1 94f8                      	cli //disable global interrupts
                                 		
0017b2 efaf                      	ldi r26, 0xFF
0017b3 93a0 2820                 	sts song_fx_Bxx, r26 //reset all song effects
0017b5 9220 2821                 	sts song_fx_Cxx, zero
0017b7 9220 2822                 	sts song_fx_Dxx, zero
0017b9 9518                      	reti
                                 
                                 sound_driver_fx_Dxx_routine:
0017ba 91e0 2819                 	lds ZL, song_frames
0017bc 91f0 281a                 	lds ZH, song_frames+1
0017be 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
0017c0 91b0 281c                 	lds r27, song_frame_offset+1
0017c2 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
0017c3 93a0 281b                 	sts song_frame_offset, r26
0017c5 93b0 281c                 	sts song_frame_offset+1, r27
0017c7 0fea                      	add ZL, r26
0017c8 1ffb                      	adc ZH, r27
                                 
0017c9 91a5                      	lpm r26, Z+ //load the address of the next pattern
0017ca 91b5                      	lpm r27, Z+
0017cb 0faa                      	lsl r26
0017cc 1fbb                      	rol r27
0017cd 93a0 2823                 	sts pulse1_pattern, r26
0017cf 93b0 2824                 	sts pulse1_pattern+1, r27
0017d1 91a5                      	lpm r26, Z+
0017d2 91b5                      	lpm r27, Z+
0017d3 0faa                      	lsl r26
0017d4 1fbb                      	rol r27
0017d5 93a0 2874                 	sts pulse2_pattern, r26
0017d7 93b0 2875                 	sts pulse2_pattern+1, r27
0017d9 91a5                      	lpm r26, Z+
0017da 91b5                      	lpm r27, Z+
0017db 0faa                      	lsl r26
0017dc 1fbb                      	rol r27
0017dd 93a0 28c5                 	sts triangle_pattern, r26
0017df 93b0 28c6                 	sts triangle_pattern+1, r27
0017e1 91a5                      	lpm r26, Z+
0017e2 91b5                      	lpm r27, Z+
0017e3 0faa                      	lsl r26
0017e4 1fbb                      	rol r27
0017e5 93a0 2911                 	sts noise_pattern, r26
0017e7 93b0 2912                 	sts noise_pattern+1, r27
0017e9 91a5                      	lpm r26, Z+
0017ea 91b5                      	lpm r27, Z+
0017eb 0faa                      	lsl r26
0017ec 1fbb                      	rol r27
0017ed 93a0 2948                 	sts dpcm_pattern, r26
0017ef 93b0 2949                 	sts dpcm_pattern+1, r27
                                 
0017f1 9220 2827                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
0017f3 9220 2828                 	sts pulse1_pattern_offset+1, zero
0017f5 9220 2825                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
0017f7 9220 2826                 	sts pulse1_pattern_delay_frames, zero
0017f9 9220 2878                 	sts pulse2_pattern_offset, zero
0017fb 9220 2879                 	sts pulse2_pattern_offset+1, zero
0017fd 9220 2876                 	sts pulse2_pattern_delay_rows, zero
0017ff 9220 2877                 	sts pulse2_pattern_delay_frames, zero
001801 9220 28c9                 	sts triangle_pattern_offset, zero
001803 9220 28ca                 	sts triangle_pattern_offset+1, zero
001805 9220 28c7                 	sts triangle_pattern_delay_rows, zero
001807 9220 28c8                 	sts triangle_pattern_delay_frames, zero
001809 9220 2915                 	sts noise_pattern_offset, zero
00180b 9220 2916                 	sts noise_pattern_offset+1, zero
00180d 9220 2913                 	sts noise_pattern_delay_rows, zero
00180f 9220 2914                 	sts noise_pattern_delay_frames, zero
001811 9220 294c                 	sts dpcm_pattern_offset, zero
001813 9220 294c                 	sts dpcm_pattern_offset, zero
001815 9220 294a                 	sts dpcm_pattern_delay_rows, zero
001817 9220 294b                 	sts dpcm_pattern_delay_frames, zero
                                 
001819 efaf                      	ldi r26, 0xFF
00181a 93a0 2860                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
00181c 93a0 2861                 	sts pulse1_fx_Gxx_post, r26
00181e 93a0 2872                 	sts pulse1_fx_Sxx_pre, r26
001820 93a0 2873                 	sts pulse1_fx_Sxx_post, r26
001822 93a0 28b1                 	sts pulse2_fx_Gxx_pre, r26
001824 93a0 28b2                 	sts pulse2_fx_Gxx_post, r26
001826 93a0 28c3                 	sts pulse2_fx_Sxx_pre, r26
001828 93a0 28c4                 	sts pulse2_fx_Sxx_post, r26
00182a 93a0 28fd                 	sts triangle_fx_Gxx_pre, r26
00182c 93a0 28fe                 	sts triangle_fx_Gxx_post, r26
00182e 93a0 290f                 	sts triangle_fx_Sxx_pre, r26
001830 93a0 2910                 	sts triangle_fx_Sxx_post, r26
001832 93a0 2943                 	sts noise_fx_Gxx_pre, r26
001834 93a0 2944                 	sts noise_fx_Gxx_post, r26
001836 93a0 2946                 	sts noise_fx_Sxx_pre, r26
001838 93a0 2947                 	sts noise_fx_Sxx_post, r26
00183a 93a0 2952                 	sts dpcm_fx_Gxx_pre, r26
00183c 93a0 2953                 	sts dpcm_fx_Gxx_post, r26
00183e 93a0 2954                 	sts dpcm_fx_Sxx_pre, r26
001840 93a0 2955                 	sts dpcm_fx_Sxx_post, r26
                                 
001842 93a0 2820                 	sts song_fx_Bxx, r26 //reset all song effects
001844 9220 2821                 	sts song_fx_Cxx, zero
001846 9220 2822                 	sts song_fx_Dxx, zero
001848 c000                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0:
001849 91a0 2825                 	lds r26, pulse1_pattern_delay_rows
00184b 91b0 2826                 	lds r27, pulse1_pattern_delay_frames
00184d 9610                      	adiw r27:r26, 0
00184e f009                      	breq sound_driver_channel0_main //if the pattern delay is 0, proceed with sound driver procedures
00184f c2e4                      	rjmp sound_driver_channel0_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel0_main:
001850 91e0 2823                 	lds ZL, pulse1_pattern //current pattern for pulse 1
001852 91f0 2824                 	lds ZH, pulse1_pattern+1
001854 91a0 2827                 	lds r26, pulse1_pattern_offset //current offset in the pattern for pulse 1
001856 91b0 2828                 	lds r27, pulse1_pattern_offset+1
001858 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001859 1ffb                      	adc ZH, r27
00185a 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel0_check_if_note: //check if data is a note (0x00 - 0x56)
00185b 35b7                      	cpi r27, 0x57
00185c f408                      	brsh sound_driver_channel0_check_if_volume
00185d c17c                      	rjmp sound_driver_channel0_note
                                 sound_driver_channel0_check_if_volume: //check if data is volume (0x57-0x66)
00185e 36b7                      	cpi r27, 0x67
00185f f408                      	brsh sound_driver_channel0_check_if_delay
001860 c1ba                      	rjmp sound_driver_channel0_volume
                                 sound_driver_channel0_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001861 3eb3                      	cpi r27, 0xE3
001862 f408                      	brsh sound_driver_channel0_check_if_instrument
001863 c1c1                      	rjmp sound_driver_channel0_delay
                                 sound_driver_channel0_check_if_instrument: //check for instrument flag (0xE3)
001864 f409                      	brne sound_driver_channel0_check_if_release
001865 c1c4                      	rjmp sound_driver_channel0_instrument_change 
                                 sound_driver_channel0_check_if_release: //check for note release flag (0xE4)
001866 3eb4                      	cpi r27, 0xE4
001867 f409                      	brne sound_driver_channel0_check_if_end
001868 c26d                      	rjmp sound_driver_channel0_release
                                 sound_driver_channel0_check_if_end:
001869 3fbf                      	cpi r27, 0xFF
00186a f409                      	brne sound_driver_channel0_check_if_fx
00186b c28f                      	rjmp sound_driver_channel0_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel0_check_if_fx: //fx flags (0xE5 - 0xFE)
00186c 9631                      	adiw Z, 1 //point Z to the byte next to the flag
00186d 91a4                      	lpm r26, Z //load the fx data into r26
00186e d2bb                      	rcall sound_driver_channel0_increment_offset_twice
                                 
00186f 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001870 e0e0                      	ldi ZL, LOW(channel0_fx << 1) //load in note table
001871 e6f1                      	ldi ZH, HIGH(channel0_fx << 1)
001872 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001873 0feb                      	add ZL, r27 //add offset
001874 1df2                      	adc ZH, zero
001875 91c5                      	lpm r28, Z+ //load address bytes
001876 91d4                      	lpm r29, Z
001877 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001878 2ffd                      	mov ZH, r29
001879 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel0_fx_0xy:
00187a 93a0 2846                 	sts pulse1_fx_0xy_sequence, r26
00187c 9220 2847                 	sts pulse1_fx_0xy_sequence+1, zero
00187e cfd1                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel0_fx_1xx:
00187f 9220 284c                 	sts pulse1_fx_2xx, zero //turn off any 2xx pitch slide down
001881 9220 284d                 	sts pulse1_fx_2xx+1, zero
001883 9220 2846                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
001885 9220 2847                 	sts pulse1_fx_0xy_sequence+1, zero
001887 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001888 937f                      	push r23
001889 2f6a                      	mov r22, r26 //store the rate into r22
00188a eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00188b 9f67                      	mul r22, r23
00188c 917f                      	pop r23
00188d 916f                      	pop r22
                                 
00188e 9416                      	lsr r1 //shift out the fractional bits
00188f 9407                      	ror r0
001890 9416                      	lsr r1
001891 9407                      	ror r0
001892 9416                      	lsr r1
001893 9407                      	ror r0
001894 9416                      	lsr r1
001895 9407                      	ror r0
001896 9200 2848                 	sts pulse1_fx_1xx, r0
001898 9210 2849                 	sts pulse1_fx_1xx+1, r1
00189a cfb5                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel0_fx_2xx:
00189b 9220 2848                 	sts pulse1_fx_1xx, zero //turn off any 1xx pitch slide down
00189d 9220 2849                 	sts pulse1_fx_1xx+1, zero
00189f 9220 2846                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
0018a1 9220 2847                 	sts pulse1_fx_0xy_sequence+1, zero
0018a3 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0018a4 937f                      	push r23
0018a5 2f6a                      	mov r22, r26 //store the rate into r22
0018a6 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0018a7 9f67                      	mul r22, r23
0018a8 917f                      	pop r23
0018a9 916f                      	pop r22
                                 
0018aa 9416                      	lsr r1 //shift out the fractional bits
0018ab 9407                      	ror r0
0018ac 9416                      	lsr r1
0018ad 9407                      	ror r0
0018ae 9416                      	lsr r1
0018af 9407                      	ror r0
0018b0 9416                      	lsr r1
0018b1 9407                      	ror r0
0018b2 9200 284c                 	sts pulse1_fx_2xx, r0
0018b4 9210 284d                 	sts pulse1_fx_2xx+1, r1
0018b6 cf99                      	rjmp sound_driver_channel0_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel0_fx_3xx:
0018b7 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0018b8 937f                      	push r23
0018b9 2f6a                      	mov r22, r26 //store the rate into r22
0018ba eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0018bb 9f67                      	mul r22, r23
0018bc 917f                      	pop r23
0018bd 916f                      	pop r22
                                 
0018be 9416                      	lsr r1 //shift out the fractional bits
0018bf 9407                      	ror r0
0018c0 9416                      	lsr r1
0018c1 9407                      	ror r0
0018c2 9416                      	lsr r1
0018c3 9407                      	ror r0
0018c4 9416                      	lsr r1
0018c5 9407                      	ror r0
0018c6 9200 2854                 	sts pulse1_fx_3xx_speed, r0
0018c8 9210 2855                 	sts pulse1_fx_3xx_speed+1, r1
                                 
0018ca 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
0018cb c001                      	rjmp sound_driver_channel0_fx_3xx_enabled
0018cc cf83                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_3xx_enabled:
0018cd 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
0018cf 91b0 0a8d                 	lds r27, TCB0_CCMPH
0018d1 93a0 2850                 	sts pulse1_fx_3xx_start, r26
0018d3 93b0 2851                 	sts pulse1_fx_3xx_start+1, r27
                                 
0018d5 9220 2856                 	sts pulse1_fx_3xx_total_offset, zero
0018d7 9220 2857                 	sts pulse1_fx_3xx_total_offset+1, zero
0018d9 cf76                      	rjmp sound_driver_channel0_main
                                 
                                 //VIBRATO
                                 sound_driver_channel0_fx_4xy:
0018da 2fba                      	mov r27, r26
0018db 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
0018dc 95a2                      	swap r26
0018dd 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0018de 93a0 2858                 	sts pulse1_fx_4xy_speed, r26
0018e0 93b0 2859                 	sts pulse1_fx_4xy_depth, r27
0018e2 9220 285a                 	sts pulse1_fx_4xy_phase, zero //reset the phase to 0
0018e4 cf6b                      	rjmp sound_driver_channel0_main
                                 
                                 //TREMELO
                                 sound_driver_channel0_fx_7xy:
0018e5 2fba                      	mov r27, r26
0018e6 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
0018e7 95a2                      	swap r26
0018e8 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0018e9 93a0 285b                 	sts pulse1_fx_7xy_speed, r26
0018eb 93b0 285c                 	sts pulse1_fx_7xy_depth, r27
0018ed 9220 285d                 	sts pulse1_fx_7xy_phase, zero //reset the phase to 0
0018ef 9220 285e                 	sts pulse1_fx_7xy_value, zero //reset the tremelo value
0018f1 cf5e                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel0_fx_Axy:
0018f2 93a0 285f                 	sts pulse1_fx_Axy, r26
0018f4 cf5b                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel0_fx_Bxx:
0018f5 93a0 2820                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
0018f7 cf58                      	rjmp sound_driver_channel0_main
                                 
                                 //HALT
                                 sound_driver_channel0_fx_Cxx:
0018f8 93b0 2821                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
0018fa cf55                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel0_fx_Dxx:
0018fb 93b0 2822                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
0018fd cf52                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME
                                 sound_driver_channel0_fx_Exx:
0018fe 91b0 2800                 	lds r27, pulse1_param
001900 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
001901 2bba                      	or r27, r26 //move new VVVV bits into pulse1_param
001902 93b0 2800                 	sts pulse1_param, r27
001904 6096                      	sbr pulse_channel_flags, 6
001905 cf4a                      	rjmp sound_driver_channel0_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel0_fx_Fxx:
001906 93a0 281f                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001908 cf47                      	rjmp sound_driver_channel0_main
                                 
                                 //DELAY
                                 sound_driver_channel0_fx_Gxx:
001909 15a2                      	cp r26, zero
00190a f051                      	breq sound_driver_channel0_fx_Gxx_invalid
00190b 91b0 281f                 	lds r27, song_speed
00190d 17ab                      	cp r26, r27
00190e f430                      	brsh sound_driver_channel0_fx_Gxx_invalid
00190f 93a0 2860                 	sts pulse1_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001911 e0b1                      	ldi r27, 0x01
001912 93b0 2825                 	sts pulse1_pattern_delay_rows, r27
001914 c222                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Gxx_invalid:
001915 cf3a                      	rjmp sound_driver_channel0_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel0_fx_Hxy: //hardware sweep up
001916 cf39                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixy: //hardware sweep down
001917 cf38                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Hxx: //FDS modulation depth
001918 cf37                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixx: //FDS modulation speed
001919 cf36                      	rjmp sound_driver_channel0_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel0_fx_Pxx:
00191a 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00191b 937f                      	push r23
00191c 2f6a                      	mov r22, r26
00191d eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00191e 0367                      	mulsu r22, r23
00191f 917f                      	pop r23
001920 916f                      	pop r22
001921 9416                      	lsr r1 //shift out the fractional bits
001922 9407                      	ror r0
001923 9416                      	lsr r1
001924 9407                      	ror r0
001925 9416                      	lsr r1
001926 9407                      	ror r0
001927 9416                      	lsr r1
001928 9407                      	ror r0
001929 fe13                      	sbrs r1, 3 //check if result was a negative number
00192a c002                      	rjmp sound_driver_channel0_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel0_fx_Pxx_negative:
00192b efb0                      	ldi r27, 0xF0
00192c 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel0_fx_Pxx_store:
00192d 9200 2862                 	sts pulse1_fx_Pxx_total, r0
00192f 9210 2863                 	sts pulse1_fx_Pxx_total+1, r1
001931 cf1e                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel0_fx_Qxy:
                                 sound_driver_channel0_fx_Qxy_check_arpeggio_macro:
001932 91e0 282e                 	lds ZL, pulse1_arpeggio_macro
001934 91f0 282f                 	lds ZH, pulse1_arpeggio_macro+1
001936 9630                      	adiw Z, 0
001937 f009                      	breq sound_driver_channel0_fx_Qxy_check_pitch_macro
001938 cf17                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_pitch_macro:
001939 91e0 2836                 	lds ZL, pulse1_pitch_macro
00193b 91f0 2837                 	lds ZH, pulse1_pitch_macro+1
00193d 9630                      	adiw Z, 0
00193e f009                      	breq sound_driver_channel0_fx_Qxy_check_hi_pitch_macro
00193f cf10                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_hi_pitch_macro:
001940 91e0 283c                 	lds ZL, pulse1_hi_pitch_macro
001942 91f0 283d                 	lds ZH, pulse1_hi_pitch_macro+1
001944 9630                      	adiw Z, 0
001945 f009                      	breq sound_driver_channel0_fx_Qxy_process
001946 cf09                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_process:
001947 2fba                      	mov r27, r26 //copy fx parameters into r27
001948 70bf                      	andi r27, 0x0F //mask note index offset
001949 91c0 2864                 	lds r28, pulse1_fx_Qxy_target_note //load current note index
00194b 0fbc                      	add r27, r28
00194c 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
00194d f008                      	brlo sound_driver_channel0_fx_Qxy_process_continue
00194e e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel0_fx_Qxy_process_continue:
00194f 93b0 2864                 	sts pulse1_fx_Qxy_target_note, r27
001951 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001952 e0f0                      	ldi ZH, HIGH(note_table << 1)
001953 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001954 0feb                      	add ZL, r27 //add offset
001955 1df2                      	adc ZH, zero
001956 91c5                      	lpm r28, Z+ //load bytes
001957 91d4                      	lpm r29, Z
001958 93c0 2865                 	sts pulse1_fx_Qxy_target, r28 //load the LOW bits for the target period
00195a 93d0 2866                 	sts pulse1_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel0_fx_Qxy_process_speed:
00195c 95a2                      	swap r26
00195d 70af                      	andi r26, 0x0F //mask effect speed
00195e 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
00195f 95a3                      	inc r26 //increment the speed by 1
                                 
001960 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001961 937f                      	push r23
001962 2f6a                      	mov r22, r26 //store the speed data into r27
001963 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001964 9f67                      	mul r22, r23
001965 917f                      	pop r23
001966 916f                      	pop r22
                                 
001967 9416                      	lsr r1 //shift out the fractional bits
001968 9407                      	ror r0
001969 9416                      	lsr r1
00196a 9407                      	ror r0
00196b 9416                      	lsr r1
00196c 9407                      	ror r0
00196d 9416                      	lsr r1
00196e 9407                      	ror r0
                                 
00196f 9200 2867                 	sts pulse1_fx_Qxy_speed, r0 //store the effect speed
001971 9210 2868                 	sts pulse1_fx_Qxy_speed+1, r1
001973 cedc                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel0_fx_Rxy:
                                 sound_driver_channel0_fx_Rxy_check_arpeggio_macro:
001974 91e0 282e                 	lds ZL, pulse1_arpeggio_macro
001976 91f0 282f                 	lds ZH, pulse1_arpeggio_macro+1
001978 9630                      	adiw Z, 0
001979 f009                      	breq sound_driver_channel0_fx_Rxy_check_pitch_macro
00197a ced5                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_pitch_macro:
00197b 91e0 2836                 	lds ZL, pulse1_pitch_macro
00197d 91f0 2837                 	lds ZH, pulse1_pitch_macro+1
00197f 9630                      	adiw Z, 0
001980 f009                      	breq sound_driver_channel0_fx_Rxy_check_hi_pitch_macro
001981 cece                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_hi_pitch_macro:
001982 91e0 283c                 	lds ZL, pulse1_hi_pitch_macro
001984 91f0 283d                 	lds ZH, pulse1_hi_pitch_macro+1
001986 9630                      	adiw Z, 0
001987 f009                      	breq sound_driver_channel0_fx_Rxy_process
001988 cec7                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_process:
001989 2fba                      	mov r27, r26 //copy fx parameters into r27
00198a 70bf                      	andi r27, 0x0F //mask note index offset
00198b 91c0 286b                 	lds r28, pulse1_fx_Rxy_target_note //load current note index
00198d 1bcb                      	sub r28, r27
00198e f408                      	brcc sound_driver_channel0_fx_Rxy_process_continue
00198f e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel0_fx_Rxy_process_continue:
001990 93c0 286b                 	sts pulse1_fx_Rxy_target_note, r28
001992 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001993 e0f0                      	ldi ZH, HIGH(note_table << 1)
001994 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001995 0fec                      	add ZL, r28 //add offset
001996 1df2                      	adc ZH, zero
001997 91c5                      	lpm r28, Z+ //load bytes
001998 91d4                      	lpm r29, Z
001999 93c0 286c                 	sts pulse1_fx_Rxy_target, r28 //load the LOW bits for the target period
00199b 93d0 286d                 	sts pulse1_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel0_fx_Rxy_process_speed:
00199d 95a2                      	swap r26
00199e 70af                      	andi r26, 0x0F //mask effect speed
00199f 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0019a0 95a3                      	inc r26 //increment the speed by 1
                                 
0019a1 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0019a2 937f                      	push r23
0019a3 2f6a                      	mov r22, r26 //store the speed data into r27
0019a4 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0019a5 9f67                      	mul r22, r23
0019a6 917f                      	pop r23
0019a7 916f                      	pop r22
                                 
0019a8 9416                      	lsr r1 //shift out the fractional bits
0019a9 9407                      	ror r0
0019aa 9416                      	lsr r1
0019ab 9407                      	ror r0
0019ac 9416                      	lsr r1
0019ad 9407                      	ror r0
0019ae 9416                      	lsr r1
0019af 9407                      	ror r0
                                 
0019b0 9200 286e                 	sts pulse1_fx_Rxy_speed, r0 //store the effect speed
0019b2 9210 286f                 	sts pulse1_fx_Rxy_speed+1, r1
0019b4 ce9b                      	rjmp sound_driver_channel0_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel0_fx_Sxx:
0019b5 15a2                      	cp r26, zero
0019b6 f051                      	breq sound_driver_channel0_fx_Sxx_invalid
0019b7 91b0 281f                 	lds r27, song_speed
0019b9 17ab                      	cp r26, r27
0019ba f430                      	brsh sound_driver_channel0_fx_Sxx_invalid
0019bb 93a0 2872                 	sts pulse1_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
0019bd e0b1                      	ldi r27, 0x01
0019be 93b0 2825                 	sts pulse1_pattern_delay_rows, r27
0019c0 c176                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Sxx_invalid:
0019c1 ce8e                      	rjmp sound_driver_channel0_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel0_fx_Vxx:
0019c2 efec                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
0019c3 e6f0                      	ldi ZH, HIGH(sequences << 1)
0019c4 0fea                      	add ZL, r26 //offset the pointer
0019c5 1df2                      	adc ZH, zero
                                 
0019c6 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
0019c7 95a7                      	ror r26
0019c8 95a7                      	ror r26
0019c9 91b0 2800                 	lds r27, pulse1_param //load r27 with pulse1_param (register $4000)
0019cb 2fcb                      	mov r28, r27 //store a copy of pulse1_param into r28
0019cc 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
0019cd 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
0019ce c001                      	rjmp sound_driver_channel0_fx_Vxx_store
0019cf ce80                      	rjmp sound_driver_channel0_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel0_fx_Vxx_store:
0019d0 9074                      	lpm pulse1_sequence, Z //store the sequence
                                 
0019d1 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
0019d2 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
0019d3 93c0 2800                 	sts pulse1_param, r28
0019d5 ce7a                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_Wxx: //DPCM sample speed
0019d6 ce79                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Xxx: //DPCM sample retrigger
0019d7 ce78                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Yxx: //DPCM sample offset
0019d8 ce77                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Zxx: //DPCM sample delta counter
0019d9 ce76                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 sound_driver_channel0_note:
0019da 93b0 2807                 	sts pulse1_note, r27 //store the note index
0019dc 93b0 2864                 	sts pulse1_fx_Qxy_target_note, r27
0019de 93b0 286b                 	sts pulse1_fx_Rxy_target_note, r27
0019e0 e0a3                      	ldi r26, 0x03
0019e1 e0b2                      	ldi r27, 0x02
0019e2 93b0 282b                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
0019e4 93a0 2830                 	sts pulse1_arpeggio_macro_offset, r26
0019e6 93b0 2838                 	sts pulse1_pitch_macro_offset, r27
0019e8 93b0 283e                 	sts pulse1_hi_pitch_macro_offset, r27
0019ea 93b0 2843                 	sts pulse1_duty_macro_offset, r27
0019ec 9220 2834                 	sts pulse1_total_pitch_offset, zero //reset the pitch and hi pitch offset
0019ee 9220 2835                 	sts pulse1_total_pitch_offset+1, zero
0019f0 9220 283b                 	sts pulse1_total_hi_pitch_offset, zero
0019f2 9220 284a                 	sts pulse1_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
0019f4 9220 284b                 	sts pulse1_fx_1xx_total+1, zero
0019f6 9220 284e                 	sts pulse1_fx_2xx_total, zero
0019f8 9220 284f                 	sts pulse1_fx_2xx_total+1, zero
0019fa 9220 2856                 	sts pulse1_fx_3xx_total_offset, zero //reset 3xx offset
0019fc 9220 2857                 	sts pulse1_fx_3xx_total_offset+1, zero
0019fe 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001a00 91b0 0a8d                 	lds r27, TCB0_CCMPH
001a02 93a0 2850                 	sts pulse1_fx_3xx_start, r26
001a04 93b0 2851                 	sts pulse1_fx_3xx_start+1, r27
001a06 9220 2801                 	sts pulse1_sweep_param, zero //reset any sweep effect
001a08 6097                      	sbr pulse_channel_flags, 7 //set reload flag
001a09 9220 2865                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001a0b 9220 2866                 	sts pulse1_fx_Qxy_target+1, zero
001a0d 9220 2869                 	sts pulse1_fx_Qxy_total_offset, zero
001a0f 9220 286a                 	sts pulse1_fx_Qxy_total_offset+1, zero
001a11 9220 286c                 	sts pulse1_fx_Rxy_target, zero
001a13 9220 286d                 	sts pulse1_fx_Rxy_target+1, zero
001a15 9220 2870                 	sts pulse1_fx_Rxy_total_offset, zero
001a17 9220 2871                 	sts pulse1_fx_Rxy_total_offset+1, zero
001a19 d106                      	rcall sound_driver_channel0_increment_offset
001a1a ce35                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_volume:
001a1b 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001a1c 91a0 2800                 	lds r26, pulse1_param
001a1e 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001a1f 2bab                      	or r26, r27 //move new VVVV bits into pulse1_param
001a20 93a0 2800                 	sts pulse1_param, r26
001a22 6096                      	sbr pulse_channel_flags, 6
001a23 d0fc                      	rcall sound_driver_channel0_increment_offset
001a24 ce2b                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_delay:
001a25 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001a26 93b0 2825                 	sts pulse1_pattern_delay_rows, r27
001a28 d0f7                      	rcall sound_driver_channel0_increment_offset
001a29 c10d                      	rjmp sound_driver_channel1
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change:
001a2a 9220 2829                 	sts pulse1_volume_macro, zero //reset all macro addresses
001a2c 9220 282a                 	sts pulse1_volume_macro+1, zero
001a2e 9220 282e                 	sts pulse1_arpeggio_macro, zero
001a30 9220 282f                 	sts pulse1_arpeggio_macro+1, zero
001a32 9220 2836                 	sts pulse1_pitch_macro, zero
001a34 9220 2837                 	sts pulse1_pitch_macro+1, zero
001a36 9220 283c                 	sts pulse1_hi_pitch_macro, zero
001a38 9220 283d                 	sts pulse1_hi_pitch_macro+1, zero
001a3a 9220 2841                 	sts pulse1_duty_macro, zero
001a3c 9220 2842                 	sts pulse1_duty_macro+1, zero
001a3e 9220 2834                 	sts pulse1_total_pitch_offset, zero //reset the pitch offset
001a40 9220 2835                 	sts pulse1_total_pitch_offset+1, zero
001a42 9220 283b                 	sts pulse1_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001a44 9631                      	adiw Z, 1 //point to the byte next to the flag
001a45 91b4                      	lpm r27, Z //store the instrument offset into r27
001a46 e9ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
001a47 e1f1                      	ldi ZH, HIGH(instruments)
001a48 0feb                      	add ZL, r27 //point Z to offsetted instrument
001a49 1df2                      	adc ZH, zero
001a4a 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001a4b 1fff                      	rol ZH
001a4c 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001a4d 91b4                      	lpm r27, Z
                                 
001a4e 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001a4f 1fbb                      	rol r27
001a50 2fea                      	mov ZL, r26
001a51 2ffb                      	mov ZH, r27
001a52 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001a53 9632                      	adiw Z, 2 //point Z to the address of the macro
001a54 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel0_instrument_change_macro_loop:
001a55 95aa                      	dec r26
001a56 f019                      	breq sound_driver_channel0_instrument_change_exit
001a57 95b6                      	lsr r27
001a58 f078                      	brcs sound_driver_channel0_instrument_change_load_macro
001a59 cffb                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_exit:
001a5a e0a3                      	ldi r26, 0x03
001a5b e0b2                      	ldi r27, 0x02
001a5c 93b0 282b                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
001a5e 93a0 2830                 	sts pulse1_arpeggio_macro_offset, r26
001a60 93b0 2838                 	sts pulse1_pitch_macro_offset, r27
001a62 93b0 283e                 	sts pulse1_hi_pitch_macro_offset, r27
001a64 93b0 2843                 	sts pulse1_duty_macro_offset, r27
001a66 d0c3                      	rcall sound_driver_channel0_increment_offset_twice
001a67 cde8                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_load_macro:
001a68 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001a69 91d5                      	lpm r29, Z+
                                 
001a6a 30a5                      	cpi r26, 5
001a6b f039                      	breq sound_driver_channel0_instrument_change_load_macro_volume
001a6c 30a4                      	cpi r26, 4
001a6d f079                      	breq sound_driver_channel0_instrument_change_load_macro_arpeggio
001a6e 30a3                      	cpi r26, 3
001a6f f0d9                      	breq sound_driver_channel0_instrument_change_load_macro_pitch
001a70 30a2                      	cpi r26, 2
001a71 f159                      	breq sound_driver_channel0_instrument_change_load_macro_hi_pitch
001a72 c03c                      	rjmp sound_driver_channel0_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel0_instrument_change_load_macro_volume:
001a73 93c0 2829                 	sts pulse1_volume_macro, r28
001a75 93d0 282a                 	sts pulse1_volume_macro+1, r29
001a77 d041                      	rcall sound_driver_channel0_instrument_change_read_header
001a78 93c0 282d                 	sts pulse1_volume_macro_release, r28
001a7a 93d0 282c                 	sts pulse1_volume_macro_loop, r29
001a7c cfd8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 	
                                 sound_driver_channel0_instrument_change_load_macro_arpeggio:
001a7d 93c0 282e                 	sts pulse1_arpeggio_macro, r28
001a7f 93d0 282f                 	sts pulse1_arpeggio_macro+1, r29
001a81 9220 2865                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001a83 9220 2866                 	sts pulse1_fx_Qxy_target+1, zero
001a85 9220 286c                 	sts pulse1_fx_Rxy_target, zero
001a87 9220 286d                 	sts pulse1_fx_Rxy_target+1, zero
001a89 d03a                      	rcall sound_driver_channel0_instrument_change_read_header_arpeggio
001a8a cfca                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_pitch:
001a8b 93c0 2836                 	sts pulse1_pitch_macro, r28
001a8d 93d0 2837                 	sts pulse1_pitch_macro+1, r29
001a8f 9220 2865                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001a91 9220 2866                 	sts pulse1_fx_Qxy_target+1, zero
001a93 9220 286c                 	sts pulse1_fx_Rxy_target, zero
001a95 9220 286d                 	sts pulse1_fx_Rxy_target+1, zero
001a97 d021                      	rcall sound_driver_channel0_instrument_change_read_header
001a98 93c0 283a                 	sts pulse1_pitch_macro_release, r28
001a9a 93d0 2839                 	sts pulse1_pitch_macro_loop, r29
001a9c cfb8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_hi_pitch:
001a9d 93c0 283c                 	sts pulse1_hi_pitch_macro, r28
001a9f 93d0 283d                 	sts pulse1_hi_pitch_macro+1, r29
001aa1 9220 2865                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001aa3 9220 2866                 	sts pulse1_fx_Qxy_target+1, zero
001aa5 9220 286c                 	sts pulse1_fx_Rxy_target, zero
001aa7 9220 286d                 	sts pulse1_fx_Rxy_target+1, zero
001aa9 d00f                      	rcall sound_driver_channel0_instrument_change_read_header
001aaa 93c0 2840                 	sts pulse1_hi_pitch_macro_release, r28
001aac 93d0 283f                 	sts pulse1_hi_pitch_macro_loop, r29
001aae cfa6                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_duty:
001aaf 93c0 2841                 	sts pulse1_duty_macro, r28
001ab1 93d0 2842                 	sts pulse1_duty_macro+1, r29
001ab3 d005                      	rcall sound_driver_channel0_instrument_change_read_header
001ab4 93c0 2845                 	sts pulse1_duty_macro_release, r28
001ab6 93d0 2844                 	sts pulse1_duty_macro_loop, r29
001ab8 cf9c                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_read_header:
001ab9 93ef                      	push ZL
001aba 93ff                      	push ZH
001abb 2fec                      	mov ZL, r28
001abc 2ffd                      	mov ZH, r29
001abd 0fee                      	lsl ZL
001abe 1fff                      	rol ZH
001abf 91c5                      	lpm r28, Z+
001ac0 91d4                      	lpm r29, Z
001ac1 91ff                      	pop ZH
001ac2 91ef                      	pop ZL
001ac3 9508                      	ret
                                 
                                 sound_driver_channel0_instrument_change_read_header_arpeggio:
001ac4 93ef                      	push ZL
001ac5 93ff                      	push ZH
001ac6 2fec                      	mov ZL, r28
001ac7 2ffd                      	mov ZH, r29
001ac8 0fee                      	lsl ZL
001ac9 1fff                      	rol ZH
001aca 91c5                      	lpm r28, Z+
001acb 91d5                      	lpm r29, Z+
001acc 93c0 2832                 	sts pulse1_arpeggio_macro_release, r28
001ace 93d0 2831                 	sts pulse1_arpeggio_macro_loop, r29
001ad0 91c4                      	lpm r28, Z
001ad1 93c0 2833                 	sts pulse1_arpeggio_macro_mode, r28
001ad3 91ff                      	pop ZH
001ad4 91ef                      	pop ZL
001ad5 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel0_release:
                                 sound_driver_channel0_release_volume:
001ad6 91b0 282d                 	lds r27, pulse1_volume_macro_release
001ad8 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001ad9 f019                      	breq sound_driver_channel0_release_arpeggio //if the macro has no release flag, check the next macro
001ada 95b3                      	inc r27
001adb 93b0 282b                 	sts pulse1_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel0_release_arpeggio:
001add 91b0 2832                 	lds r27, pulse1_arpeggio_macro_release
001adf 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001ae0 f019                      	breq sound_driver_channel0_release_pitch
001ae1 95b3                      	inc r27
001ae2 93b0 2830                 	sts pulse1_arpeggio_macro_offset, r27
                                 sound_driver_channel0_release_pitch:
001ae4 91b0 283a                 	lds r27, pulse1_pitch_macro_release
001ae6 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001ae7 f019                      	breq sound_driver_channel0_release_hi_pitch
001ae8 95b3                      	inc r27
001ae9 93b0 2838                 	sts pulse1_pitch_macro_offset, r27
                                 sound_driver_channel0_release_hi_pitch:
001aeb 91b0 2840                 	lds r27, pulse1_hi_pitch_macro_release
001aed 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001aee f019                      	breq sound_driver_channel0_release_duty
001aef 95b3                      	inc r27
001af0 93b0 283e                 	sts pulse1_hi_pitch_macro_offset, r27
                                 sound_driver_channel0_release_duty:
001af2 91b0 2845                 	lds r27, pulse1_duty_macro_release
001af4 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001af5 f019                      	breq sound_driver_channel0_release_exit
001af6 95b3                      	inc r27
001af7 93b0 2843                 	sts pulse1_duty_macro_offset, r27
                                 sound_driver_channel0_release_exit:
001af9 d026                      	rcall sound_driver_channel0_increment_offset
001afa cd55                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_next_pattern:
001afb 91e0 2819                 	lds ZL, song_frames
001afd 91f0 281a                 	lds ZH, song_frames+1
001aff 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001b01 91b0 281c                 	lds r27, song_frame_offset+1
001b03 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
001b04 93a0 281b                 	sts song_frame_offset, r26
001b06 93b0 281c                 	sts song_frame_offset+1, r27
                                 
001b08 91c0 281d                 	lds r28, song_size
001b0a 91d0 281e                 	lds r29, song_size+1
001b0c 17ac                      	cp r26, r28
001b0d 07bd                      	cpc r27, r29
001b0e f010                      	brlo sound_driver_channel0_next_pattern_exists
001b0f 940c 3068                 	jmp sound_driver_exit
                                 
                                 sound_driver_channel0_next_pattern_exists:
001b11 0fea                      	add ZL, r26
001b12 1ffb                      	adc ZH, r27
                                 
001b13 91a5                      	lpm r26, Z+ //load the address of the next pattern
001b14 91b4                      	lpm r27, Z
001b15 0faa                      	lsl r26
001b16 1fbb                      	rol r27
001b17 93a0 2823                 	sts pulse1_pattern, r26
001b19 93b0 2824                 	sts pulse1_pattern+1, r27
                                 
001b1b 9220 2827                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001b1d 9220 2828                 	sts pulse1_pattern_offset+1, zero
001b1f cd30                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_increment_offset:
001b20 91e0 2827                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
001b22 91f0 2828                 	lds ZH, pulse1_pattern_offset+1
001b24 9631                      	adiw Z, 1
001b25 93e0 2827                 	sts pulse1_pattern_offset, ZL
001b27 93f0 2828                 	sts pulse1_pattern_offset+1, ZH
001b29 9508                      	ret
                                 
                                 sound_driver_channel0_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001b2a 91e0 2827                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
001b2c 91f0 2828                 	lds ZH, pulse1_pattern_offset+1
001b2e 9632                      	adiw Z, 2 //increment the pointer twice
001b2f 93e0 2827                 	sts pulse1_pattern_offset, ZL
001b31 93f0 2828                 	sts pulse1_pattern_offset+1, ZH
001b33 9508                      	ret
                                 
                                 sound_driver_channel0_decrement_frame_delay:
001b34 95ba                      	dec r27
001b35 93b0 2826                 	sts pulse1_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel1:
001b37 91a0 2876                 	lds r26, pulse2_pattern_delay_rows
001b39 91b0 2877                 	lds r27, pulse2_pattern_delay_frames
001b3b 9610                      	adiw r27:r26, 0
001b3c f009                      	breq sound_driver_channel1_main //if the pattern delay is 0, proceed with sound driver procedures
001b3d c2d7                      	rjmp sound_driver_channel1_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel1_main:
001b3e 91e0 2874                 	lds ZL, pulse2_pattern //current pattern for pulse 2
001b40 91f0 2875                 	lds ZH, pulse2_pattern+1
001b42 91a0 2878                 	lds r26, pulse2_pattern_offset //current offset in the pattern for pulse 2
001b44 91b0 2879                 	lds r27, pulse2_pattern_offset+1
001b46 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001b47 1ffb                      	adc ZH, r27
001b48 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel1_check_if_note: //check if data is a note (0x00 - 0x56)
001b49 35b7                      	cpi r27, 0x57
001b4a f408                      	brsh sound_driver_channel1_check_if_volume
001b4b c17c                      	rjmp sound_driver_channel1_note
                                 sound_driver_channel1_check_if_volume: //check if data is volume (0x57-0x66)
001b4c 36b7                      	cpi r27, 0x67
001b4d f408                      	brsh sound_driver_channel1_check_if_delay
001b4e c1ba                      	rjmp sound_driver_channel1_volume
                                 sound_driver_channel1_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001b4f 3eb3                      	cpi r27, 0xE3
001b50 f408                      	brsh sound_driver_channel1_check_if_instrument
001b51 c1c1                      	rjmp sound_driver_channel1_delay
                                 sound_driver_channel1_check_if_instrument: //check for instrument flag (0xE3)
001b52 f409                      	brne sound_driver_channel1_check_if_release
001b53 c1c4                      	rjmp sound_driver_channel1_instrument_change 
                                 sound_driver_channel1_check_if_release: //check for note release flag (0xE4)
001b54 3eb4                      	cpi r27, 0xE4
001b55 f409                      	brne sound_driver_channel1_check_if_end
001b56 c26d                      	rjmp sound_driver_channel1_release
                                 sound_driver_channel1_check_if_end:
001b57 3fbf                      	cpi r27, 0xFF
001b58 f409                      	brne sound_driver_channel1_check_if_fx
001b59 c28f                      	rjmp sound_driver_channel1_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel1_check_if_fx: //fx flags (0xE5 - 0xFE)
001b5a 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001b5b 91a4                      	lpm r26, Z //load the fx data into r26
001b5c d2ae                      	rcall sound_driver_channel1_increment_offset_twice
                                 
001b5d 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001b5e e3e4                      	ldi ZL, LOW(channel1_fx << 1) //load in note table
001b5f e6f1                      	ldi ZH, HIGH(channel1_fx << 1)
001b60 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001b61 0feb                      	add ZL, r27 //add offset
001b62 1df2                      	adc ZH, zero
001b63 91c5                      	lpm r28, Z+ //load address bytes
001b64 91d4                      	lpm r29, Z
001b65 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001b66 2ffd                      	mov ZH, r29
001b67 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel1_fx_0xy:
001b68 93a0 2897                 	sts pulse2_fx_0xy_sequence, r26
001b6a 9220 2898                 	sts pulse2_fx_0xy_sequence+1, zero
001b6c cfd1                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel1_fx_1xx:
001b6d 9220 289d                 	sts pulse2_fx_2xx, zero //turn off any 2xx pitch slide down
001b6f 9220 289e                 	sts pulse2_fx_2xx+1, zero
001b71 9220 2897                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
001b73 9220 2898                 	sts pulse2_fx_0xy_sequence+1, zero
001b75 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001b76 937f                      	push r23
001b77 2f6a                      	mov r22, r26 //store the rate into r22
001b78 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001b79 9f67                      	mul r22, r23
001b7a 917f                      	pop r23
001b7b 916f                      	pop r22
                                 
001b7c 9416                      	lsr r1 //shift out the fractional bits
001b7d 9407                      	ror r0
001b7e 9416                      	lsr r1
001b7f 9407                      	ror r0
001b80 9416                      	lsr r1
001b81 9407                      	ror r0
001b82 9416                      	lsr r1
001b83 9407                      	ror r0
001b84 9200 2899                 	sts pulse2_fx_1xx, r0
001b86 9210 289a                 	sts pulse2_fx_1xx+1, r1
001b88 cfb5                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel1_fx_2xx:
001b89 9220 2899                 	sts pulse2_fx_1xx, zero //turn off any 1xx pitch slide down
001b8b 9220 289a                 	sts pulse2_fx_1xx+1, zero
001b8d 9220 2897                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
001b8f 9220 2898                 	sts pulse2_fx_0xy_sequence+1, zero
001b91 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001b92 937f                      	push r23
001b93 2f6a                      	mov r22, r26 //store the rate into r22
001b94 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001b95 9f67                      	mul r22, r23
001b96 917f                      	pop r23
001b97 916f                      	pop r22
                                 
001b98 9416                      	lsr r1 //shift out the fractional bits
001b99 9407                      	ror r0
001b9a 9416                      	lsr r1
001b9b 9407                      	ror r0
001b9c 9416                      	lsr r1
001b9d 9407                      	ror r0
001b9e 9416                      	lsr r1
001b9f 9407                      	ror r0
001ba0 9200 289d                 	sts pulse2_fx_2xx, r0
001ba2 9210 289e                 	sts pulse2_fx_2xx+1, r1
001ba4 cf99                      	rjmp sound_driver_channel1_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel1_fx_3xx:
001ba5 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001ba6 937f                      	push r23
001ba7 2f6a                      	mov r22, r26 //store the rate into r22
001ba8 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001ba9 9f67                      	mul r22, r23
001baa 917f                      	pop r23
001bab 916f                      	pop r22
                                 
001bac 9416                      	lsr r1 //shift out the fractional bits
001bad 9407                      	ror r0
001bae 9416                      	lsr r1
001baf 9407                      	ror r0
001bb0 9416                      	lsr r1
001bb1 9407                      	ror r0
001bb2 9416                      	lsr r1
001bb3 9407                      	ror r0
001bb4 9200 28a5                 	sts pulse2_fx_3xx_speed, r0
001bb6 9210 28a6                 	sts pulse2_fx_3xx_speed+1, r1
                                 
001bb8 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001bb9 c001                      	rjmp sound_driver_channel1_fx_3xx_enabled
001bba cf83                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_3xx_enabled:
001bbb 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001bbd 91b0 0a9d                 	lds r27, TCB1_CCMPH
001bbf 93a0 28a1                 	sts pulse2_fx_3xx_start, r26
001bc1 93b0 28a2                 	sts pulse2_fx_3xx_start+1, r27
                                 
001bc3 9220 28a7                 	sts pulse2_fx_3xx_total_offset, zero
001bc5 9220 28a8                 	sts pulse2_fx_3xx_total_offset+1, zero
001bc7 cf76                      	rjmp sound_driver_channel1_main
                                 
                                 //VIBRATO
                                 sound_driver_channel1_fx_4xy:
001bc8 2fba                      	mov r27, r26
001bc9 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001bca 95a2                      	swap r26
001bcb 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001bcc 93a0 28a9                 	sts pulse2_fx_4xy_speed, r26
001bce 93b0 28aa                 	sts pulse2_fx_4xy_depth, r27
001bd0 9220 28ab                 	sts pulse2_fx_4xy_phase, zero //reset the phase to 0
001bd2 cf6b                      	rjmp sound_driver_channel1_main
                                 
                                 //TREMELO
                                 sound_driver_channel1_fx_7xy:
001bd3 2fba                      	mov r27, r26
001bd4 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001bd5 95a2                      	swap r26
001bd6 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001bd7 93a0 28ac                 	sts pulse2_fx_7xy_speed, r26
001bd9 93b0 28ad                 	sts pulse2_fx_7xy_depth, r27
001bdb 9220 28ae                 	sts pulse2_fx_7xy_phase, zero //reset the phase to 0
001bdd 9220 28af                 	sts pulse2_fx_7xy_value, zero //reset the tremelo value
001bdf cf5e                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel1_fx_Axy:
001be0 93a0 28b0                 	sts pulse2_fx_Axy, r26
001be2 cf5b                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel1_fx_Bxx:
001be3 93a0 2820                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001be5 cf58                      	rjmp sound_driver_channel1_main
                                 
                                 //HALT
                                 sound_driver_channel1_fx_Cxx:
001be6 93b0 2821                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001be8 cf55                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel1_fx_Dxx:
001be9 93b0 2822                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001beb cf52                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME
                                 sound_driver_channel1_fx_Exx:
001bec 91b0 2808                 	lds r27, pulse2_param
001bee 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
001bef 2bba                      	or r27, r26 //move new VVVV bits into pulse2_param
001bf0 93b0 2808                 	sts pulse2_param, r27
001bf2 6092                      	sbr pulse_channel_flags, 2
001bf3 cf4a                      	rjmp sound_driver_channel1_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel1_fx_Fxx:
001bf4 93a0 281f                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001bf6 cf47                      	rjmp sound_driver_channel1_main
                                 
                                 //DELAY
                                 sound_driver_channel1_fx_Gxx:
001bf7 15a2                      	cp r26, zero
001bf8 f051                      	breq sound_driver_channel1_fx_Gxx_invalid
001bf9 91b0 281f                 	lds r27, song_speed
001bfb 17ab                      	cp r26, r27
001bfc f430                      	brsh sound_driver_channel1_fx_Gxx_invalid
001bfd 93a0 28b1                 	sts pulse2_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001bff e0b1                      	ldi r27, 0x01
001c00 93b0 2876                 	sts pulse2_pattern_delay_rows, r27
001c02 c215                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Gxx_invalid:
001c03 cf3a                      	rjmp sound_driver_channel1_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel1_fx_Hxy: //hardware sweep up
001c04 cf39                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixy: //hardware sweep down
001c05 cf38                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Hxx: //FDS modulation depth
001c06 cf37                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixx: //FDS modulation speed
001c07 cf36                      	rjmp sound_driver_channel1_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel1_fx_Pxx:
001c08 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001c09 937f                      	push r23
001c0a 2f6a                      	mov r22, r26
001c0b eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001c0c 0367                      	mulsu r22, r23
001c0d 917f                      	pop r23
001c0e 916f                      	pop r22
001c0f 9416                      	lsr r1 //shift out the fractional bits
001c10 9407                      	ror r0
001c11 9416                      	lsr r1
001c12 9407                      	ror r0
001c13 9416                      	lsr r1
001c14 9407                      	ror r0
001c15 9416                      	lsr r1
001c16 9407                      	ror r0
001c17 fe13                      	sbrs r1, 3 //check if result was a negative number
001c18 c002                      	rjmp sound_driver_channel1_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel1_fx_Pxx_negative:
001c19 efb0                      	ldi r27, 0xF0
001c1a 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel1_fx_Pxx_store:
001c1b 9200 28b3                 	sts pulse2_fx_Pxx_total, r0
001c1d 9210 28b4                 	sts pulse2_fx_Pxx_total+1, r1
001c1f cf1e                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel1_fx_Qxy:
                                 sound_driver_channel1_fx_Qxy_check_arpeggio_macro:
001c20 91e0 287f                 	lds ZL, pulse2_arpeggio_macro
001c22 91f0 2880                 	lds ZH, pulse2_arpeggio_macro+1
001c24 9630                      	adiw Z, 0
001c25 f009                      	breq sound_driver_channel1_fx_Qxy_check_pitch_macro
001c26 cf17                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_pitch_macro:
001c27 91e0 2887                 	lds ZL, pulse2_pitch_macro
001c29 91f0 2888                 	lds ZH, pulse2_pitch_macro+1
001c2b 9630                      	adiw Z, 0
001c2c f009                      	breq sound_driver_channel1_fx_Qxy_check_hi_pitch_macro
001c2d cf10                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_hi_pitch_macro:
001c2e 91e0 288d                 	lds ZL, pulse2_hi_pitch_macro
001c30 91f0 288e                 	lds ZH, pulse2_hi_pitch_macro+1
001c32 9630                      	adiw Z, 0
001c33 f009                      	breq sound_driver_channel1_fx_Qxy_process
001c34 cf09                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_process:
001c35 2fba                      	mov r27, r26 //copy fx parameters into r27
001c36 70bf                      	andi r27, 0x0F //mask note index offset
001c37 91c0 28b5                 	lds r28, pulse2_fx_Qxy_target_note //load current note index
001c39 0fbc                      	add r27, r28
001c3a 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001c3b f008                      	brlo sound_driver_channel1_fx_Qxy_process_continue
001c3c e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel1_fx_Qxy_process_continue:
001c3d 93b0 28b5                 	sts pulse2_fx_Qxy_target_note, r27
001c3f e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001c40 e0f0                      	ldi ZH, HIGH(note_table << 1)
001c41 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001c42 0feb                      	add ZL, r27 //add offset
001c43 1df2                      	adc ZH, zero
001c44 91c5                      	lpm r28, Z+ //load bytes
001c45 91d4                      	lpm r29, Z
001c46 93c0 28b6                 	sts pulse2_fx_Qxy_target, r28 //load the LOW bits for the target period
001c48 93d0 28b7                 	sts pulse2_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel1_fx_Qxy_process_speed:
001c4a 95a2                      	swap r26
001c4b 70af                      	andi r26, 0x0F //mask effect speed
001c4c 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001c4d 95a3                      	inc r26 //increment the speed by 1
                                 
001c4e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001c4f 937f                      	push r23
001c50 2f6a                      	mov r22, r26 //store the speed data into r27
001c51 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001c52 9f67                      	mul r22, r23
001c53 917f                      	pop r23
001c54 916f                      	pop r22
                                 
001c55 9416                      	lsr r1 //shift out the fractional bits
001c56 9407                      	ror r0
001c57 9416                      	lsr r1
001c58 9407                      	ror r0
001c59 9416                      	lsr r1
001c5a 9407                      	ror r0
001c5b 9416                      	lsr r1
001c5c 9407                      	ror r0
                                 
001c5d 9200 28b8                 	sts pulse2_fx_Qxy_speed, r0 //store the effect speed
001c5f 9210 28b9                 	sts pulse2_fx_Qxy_speed+1, r1
001c61 cedc                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel1_fx_Rxy:
                                 sound_driver_channel1_fx_Rxy_check_arpeggio_macro:
001c62 91e0 287f                 	lds ZL, pulse2_arpeggio_macro
001c64 91f0 2880                 	lds ZH, pulse2_arpeggio_macro+1
001c66 9630                      	adiw Z, 0
001c67 f009                      	breq sound_driver_channel1_fx_Rxy_check_pitch_macro
001c68 ced5                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_pitch_macro:
001c69 91e0 2887                 	lds ZL, pulse2_pitch_macro
001c6b 91f0 2888                 	lds ZH, pulse2_pitch_macro+1
001c6d 9630                      	adiw Z, 0
001c6e f009                      	breq sound_driver_channel1_fx_Rxy_check_hi_pitch_macro
001c6f cece                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_hi_pitch_macro:
001c70 91e0 288d                 	lds ZL, pulse2_hi_pitch_macro
001c72 91f0 288e                 	lds ZH, pulse2_hi_pitch_macro+1
001c74 9630                      	adiw Z, 0
001c75 f009                      	breq sound_driver_channel1_fx_Rxy_process
001c76 cec7                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_process:
001c77 2fba                      	mov r27, r26 //copy fx parameters into r27
001c78 70bf                      	andi r27, 0x0F //mask note index offset
001c79 91c0 28bc                 	lds r28, pulse2_fx_Rxy_target_note //load current note index
001c7b 1bcb                      	sub r28, r27
001c7c f408                      	brcc sound_driver_channel1_fx_Rxy_process_continue
001c7d e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel1_fx_Rxy_process_continue:
001c7e 93c0 28bc                 	sts pulse2_fx_Rxy_target_note, r28
001c80 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001c81 e0f0                      	ldi ZH, HIGH(note_table << 1)
001c82 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001c83 0fec                      	add ZL, r28 //add offset
001c84 1df2                      	adc ZH, zero
001c85 91c5                      	lpm r28, Z+ //load bytes
001c86 91d4                      	lpm r29, Z
001c87 93c0 28bd                 	sts pulse2_fx_Rxy_target, r28 //load the LOW bits for the target period
001c89 93d0 28be                 	sts pulse2_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel1_fx_Rxy_process_speed:
001c8b 95a2                      	swap r26
001c8c 70af                      	andi r26, 0x0F //mask effect speed
001c8d 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001c8e 95a3                      	inc r26 //increment the speed by 1
                                 
001c8f 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001c90 937f                      	push r23
001c91 2f6a                      	mov r22, r26 //store the speed data into r27
001c92 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001c93 9f67                      	mul r22, r23
001c94 917f                      	pop r23
001c95 916f                      	pop r22
                                 
001c96 9416                      	lsr r1 //shift out the fractional bits
001c97 9407                      	ror r0
001c98 9416                      	lsr r1
001c99 9407                      	ror r0
001c9a 9416                      	lsr r1
001c9b 9407                      	ror r0
001c9c 9416                      	lsr r1
001c9d 9407                      	ror r0
                                 
001c9e 9200 28bf                 	sts pulse2_fx_Rxy_speed, r0 //store the effect speed
001ca0 9210 28c0                 	sts pulse2_fx_Rxy_speed+1, r1
001ca2 ce9b                      	rjmp sound_driver_channel1_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel1_fx_Sxx:
001ca3 15a2                      	cp r26, zero
001ca4 f051                      	breq sound_driver_channel1_fx_Sxx_invalid
001ca5 91b0 281f                 	lds r27, song_speed
001ca7 17ab                      	cp r26, r27
001ca8 f430                      	brsh sound_driver_channel1_fx_Sxx_invalid
001ca9 93a0 28c3                 	sts pulse2_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001cab e0b1                      	ldi r27, 0x01
001cac 93b0 2876                 	sts pulse2_pattern_delay_rows, r27
001cae c169                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Sxx_invalid:
001caf ce8e                      	rjmp sound_driver_channel1_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel1_fx_Vxx:
001cb0 efec                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
001cb1 e6f0                      	ldi ZH, HIGH(sequences << 1)
001cb2 0fea                      	add ZL, r26 //offset the pointer
001cb3 1df2                      	adc ZH, zero
                                 
001cb4 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
001cb5 95a7                      	ror r26
001cb6 95a7                      	ror r26
001cb7 91b0 2808                 	lds r27, pulse2_param //load r27 with pulse2_param (register $4000)
001cb9 2fcb                      	mov r28, r27 //store a copy of pulse2_param into r28
001cba 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
001cbb 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
001cbc c001                      	rjmp sound_driver_channel1_fx_Vxx_store
001cbd ce80                      	rjmp sound_driver_channel1_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel1_fx_Vxx_store:
001cbe 90a4                      	lpm pulse2_sequence, Z //store the sequence
                                 
001cbf 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
001cc0 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
001cc1 93c0 2808                 	sts pulse2_param, r28
001cc3 ce7a                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_Wxx: //DPCM sample speed
001cc4 ce79                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Xxx: //DPCM sample retrigger
001cc5 ce78                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Yxx: //DPCM sample offset
001cc6 ce77                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Zxx: //DPCM sample delta counter
001cc7 ce76                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 sound_driver_channel1_note:
001cc8 93b0 280f                 	sts pulse2_note, r27 //store the note index
001cca 93b0 28b5                 	sts pulse2_fx_Qxy_target_note, r27
001ccc 93b0 28bc                 	sts pulse2_fx_Rxy_target_note, r27
001cce e0a3                      	ldi r26, 0x03
001ccf e0b2                      	ldi r27, 0x02
001cd0 93b0 287c                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
001cd2 93a0 2881                 	sts pulse2_arpeggio_macro_offset, r26
001cd4 93b0 2889                 	sts pulse2_pitch_macro_offset, r27
001cd6 93b0 288f                 	sts pulse2_hi_pitch_macro_offset, r27
001cd8 93b0 2894                 	sts pulse2_duty_macro_offset, r27
001cda 9220 2885                 	sts pulse2_total_pitch_offset, zero //reset the pitch and hi pitch offset
001cdc 9220 2886                 	sts pulse2_total_pitch_offset+1, zero
001cde 9220 288c                 	sts pulse2_total_hi_pitch_offset, zero
001ce0 9220 289b                 	sts pulse2_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001ce2 9220 289c                 	sts pulse2_fx_1xx_total+1, zero
001ce4 9220 289f                 	sts pulse2_fx_2xx_total, zero
001ce6 9220 28a0                 	sts pulse2_fx_2xx_total+1, zero
001ce8 9220 28a7                 	sts pulse2_fx_3xx_total_offset, zero //reset 3xx offset
001cea 9220 28a8                 	sts pulse2_fx_3xx_total_offset+1, zero
001cec 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001cee 91b0 0a9d                 	lds r27, TCB1_CCMPH
001cf0 93a0 28a1                 	sts pulse2_fx_3xx_start, r26
001cf2 93b0 28a2                 	sts pulse2_fx_3xx_start+1, r27
001cf4 9220 2809                 	sts pulse2_sweep_param, zero //reset any sweep effect
001cf6 6093                      	sbr pulse_channel_flags, 3 //set reload flag
001cf7 9220 28b6                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001cf9 9220 28b7                 	sts pulse2_fx_Qxy_target+1, zero
001cfb 9220 28ba                 	sts pulse2_fx_Qxy_total_offset, zero
001cfd 9220 28bb                 	sts pulse2_fx_Qxy_total_offset+1, zero
001cff 9220 28bd                 	sts pulse2_fx_Rxy_target, zero
001d01 9220 28be                 	sts pulse2_fx_Rxy_target+1, zero
001d03 9220 28c1                 	sts pulse2_fx_Rxy_total_offset, zero
001d05 9220 28c2                 	sts pulse2_fx_Rxy_total_offset+1, zero
001d07 d0f9                      	rcall sound_driver_channel1_increment_offset
001d08 ce35                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_volume:
001d09 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001d0a 91a0 2808                 	lds r26, pulse2_param
001d0c 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001d0d 2bab                      	or r26, r27 //move new VVVV bits into pulse2_param
001d0e 93a0 2808                 	sts pulse2_param, r26
001d10 6092                      	sbr pulse_channel_flags, 2
001d11 d0ef                      	rcall sound_driver_channel1_increment_offset
001d12 ce2b                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_delay:
001d13 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001d14 93b0 2876                 	sts pulse2_pattern_delay_rows, r27
001d16 d0ea                      	rcall sound_driver_channel1_increment_offset
001d17 c100                      	rjmp sound_driver_channel2
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change:
001d18 9220 287a                 	sts pulse2_volume_macro, zero //reset all macro addresses
001d1a 9220 287b                 	sts pulse2_volume_macro+1, zero
001d1c 9220 287f                 	sts pulse2_arpeggio_macro, zero
001d1e 9220 2880                 	sts pulse2_arpeggio_macro+1, zero
001d20 9220 2887                 	sts pulse2_pitch_macro, zero
001d22 9220 2888                 	sts pulse2_pitch_macro+1, zero
001d24 9220 288d                 	sts pulse2_hi_pitch_macro, zero
001d26 9220 288e                 	sts pulse2_hi_pitch_macro+1, zero
001d28 9220 2892                 	sts pulse2_duty_macro, zero
001d2a 9220 2893                 	sts pulse2_duty_macro+1, zero
001d2c 9220 2885                 	sts pulse2_total_pitch_offset, zero //reset the pitch offset
001d2e 9220 2886                 	sts pulse2_total_pitch_offset+1, zero
001d30 9220 288c                 	sts pulse2_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001d32 9631                      	adiw Z, 1 //point to the byte next to the flag
001d33 91b4                      	lpm r27, Z //store the instrument offset into r27
001d34 e9ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
001d35 e1f1                      	ldi ZH, HIGH(instruments)
001d36 0feb                      	add ZL, r27 //point Z to offsetted instrument
001d37 1df2                      	adc ZH, zero
001d38 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001d39 1fff                      	rol ZH
001d3a 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001d3b 91b4                      	lpm r27, Z
                                 
001d3c 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001d3d 1fbb                      	rol r27
001d3e 2fea                      	mov ZL, r26
001d3f 2ffb                      	mov ZH, r27
001d40 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001d41 9632                      	adiw Z, 2 //point Z to the address of the macro
001d42 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel1_instrument_change_macro_loop:
001d43 95aa                      	dec r26
001d44 f019                      	breq sound_driver_channel1_instrument_change_exit
001d45 95b6                      	lsr r27
001d46 f078                      	brcs sound_driver_channel1_instrument_change_load_macro
001d47 cffb                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_exit:
001d48 e0a3                      	ldi r26, 0x03
001d49 e0b2                      	ldi r27, 0x02
001d4a 93b0 287c                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
001d4c 93a0 2881                 	sts pulse2_arpeggio_macro_offset, r26
001d4e 93b0 2889                 	sts pulse2_pitch_macro_offset, r27
001d50 93b0 288f                 	sts pulse2_hi_pitch_macro_offset, r27
001d52 93b0 2894                 	sts pulse2_duty_macro_offset, r27
001d54 d0b6                      	rcall sound_driver_channel1_increment_offset_twice
001d55 cde8                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_load_macro:
001d56 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001d57 91d5                      	lpm r29, Z+
                                 
001d58 30a5                      	cpi r26, 5
001d59 f039                      	breq sound_driver_channel1_instrument_change_load_macro_volume
001d5a 30a4                      	cpi r26, 4
001d5b f079                      	breq sound_driver_channel1_instrument_change_load_macro_arpeggio
001d5c 30a3                      	cpi r26, 3
001d5d f0d9                      	breq sound_driver_channel1_instrument_change_load_macro_pitch
001d5e 30a2                      	cpi r26, 2
001d5f f159                      	breq sound_driver_channel1_instrument_change_load_macro_hi_pitch
001d60 c03c                      	rjmp sound_driver_channel1_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel1_instrument_change_load_macro_volume:
001d61 93c0 287a                 	sts pulse2_volume_macro, r28
001d63 93d0 287b                 	sts pulse2_volume_macro+1, r29
001d65 d041                      	rcall sound_driver_channel1_instrument_change_read_header
001d66 93c0 287e                 	sts pulse2_volume_macro_release, r28
001d68 93d0 287d                 	sts pulse2_volume_macro_loop, r29
001d6a cfd8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 	
                                 sound_driver_channel1_instrument_change_load_macro_arpeggio:
001d6b 93c0 287f                 	sts pulse2_arpeggio_macro, r28
001d6d 93d0 2880                 	sts pulse2_arpeggio_macro+1, r29
001d6f 9220 28b6                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001d71 9220 28b7                 	sts pulse2_fx_Qxy_target+1, zero
001d73 9220 28bd                 	sts pulse2_fx_Rxy_target, zero
001d75 9220 28be                 	sts pulse2_fx_Rxy_target+1, zero
001d77 d03a                      	rcall sound_driver_channel1_instrument_change_read_header_arpeggio
001d78 cfca                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_pitch:
001d79 93c0 2887                 	sts pulse2_pitch_macro, r28
001d7b 93d0 2888                 	sts pulse2_pitch_macro+1, r29
001d7d 9220 28b6                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001d7f 9220 28b7                 	sts pulse2_fx_Qxy_target+1, zero
001d81 9220 28bd                 	sts pulse2_fx_Rxy_target, zero
001d83 9220 28be                 	sts pulse2_fx_Rxy_target+1, zero
001d85 d021                      	rcall sound_driver_channel1_instrument_change_read_header
001d86 93c0 288b                 	sts pulse2_pitch_macro_release, r28
001d88 93d0 288a                 	sts pulse2_pitch_macro_loop, r29
001d8a cfb8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_hi_pitch:
001d8b 93c0 288d                 	sts pulse2_hi_pitch_macro, r28
001d8d 93d0 288e                 	sts pulse2_hi_pitch_macro+1, r29
001d8f 9220 28b6                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001d91 9220 28b7                 	sts pulse2_fx_Qxy_target+1, zero
001d93 9220 28bd                 	sts pulse2_fx_Rxy_target, zero
001d95 9220 28be                 	sts pulse2_fx_Rxy_target+1, zero
001d97 d00f                      	rcall sound_driver_channel1_instrument_change_read_header
001d98 93c0 2891                 	sts pulse2_hi_pitch_macro_release, r28
001d9a 93d0 2890                 	sts pulse2_hi_pitch_macro_loop, r29
001d9c cfa6                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_duty:
001d9d 93c0 2892                 	sts pulse2_duty_macro, r28
001d9f 93d0 2893                 	sts pulse2_duty_macro+1, r29
001da1 d005                      	rcall sound_driver_channel1_instrument_change_read_header
001da2 93c0 2896                 	sts pulse2_duty_macro_release, r28
001da4 93d0 2895                 	sts pulse2_duty_macro_loop, r29
001da6 cf9c                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_read_header:
001da7 93ef                      	push ZL
001da8 93ff                      	push ZH
001da9 2fec                      	mov ZL, r28
001daa 2ffd                      	mov ZH, r29
001dab 0fee                      	lsl ZL
001dac 1fff                      	rol ZH
001dad 91c5                      	lpm r28, Z+
001dae 91d4                      	lpm r29, Z
001daf 91ff                      	pop ZH
001db0 91ef                      	pop ZL
001db1 9508                      	ret
                                 
                                 sound_driver_channel1_instrument_change_read_header_arpeggio:
001db2 93ef                      	push ZL
001db3 93ff                      	push ZH
001db4 2fec                      	mov ZL, r28
001db5 2ffd                      	mov ZH, r29
001db6 0fee                      	lsl ZL
001db7 1fff                      	rol ZH
001db8 91c5                      	lpm r28, Z+
001db9 91d5                      	lpm r29, Z+
001dba 93c0 2883                 	sts pulse2_arpeggio_macro_release, r28
001dbc 93d0 2882                 	sts pulse2_arpeggio_macro_loop, r29
001dbe 91c4                      	lpm r28, Z
001dbf 93c0 2884                 	sts pulse2_arpeggio_macro_mode, r28
001dc1 91ff                      	pop ZH
001dc2 91ef                      	pop ZL
001dc3 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel1_release:
                                 sound_driver_channel1_release_volume:
001dc4 91b0 287e                 	lds r27, pulse2_volume_macro_release
001dc6 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001dc7 f019                      	breq sound_driver_channel1_release_arpeggio //if the macro has no release flag, check the next macro
001dc8 95b3                      	inc r27
001dc9 93b0 287c                 	sts pulse2_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel1_release_arpeggio:
001dcb 91b0 2883                 	lds r27, pulse2_arpeggio_macro_release
001dcd 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001dce f019                      	breq sound_driver_channel1_release_pitch
001dcf 95b3                      	inc r27
001dd0 93b0 2881                 	sts pulse2_arpeggio_macro_offset, r27
                                 sound_driver_channel1_release_pitch:
001dd2 91b0 288b                 	lds r27, pulse2_pitch_macro_release
001dd4 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001dd5 f019                      	breq sound_driver_channel1_release_hi_pitch
001dd6 95b3                      	inc r27
001dd7 93b0 2889                 	sts pulse2_pitch_macro_offset, r27
                                 sound_driver_channel1_release_hi_pitch:
001dd9 91b0 2891                 	lds r27, pulse2_hi_pitch_macro_release
001ddb 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001ddc f019                      	breq sound_driver_channel1_release_duty
001ddd 95b3                      	inc r27
001dde 93b0 288f                 	sts pulse2_hi_pitch_macro_offset, r27
                                 sound_driver_channel1_release_duty:
001de0 91b0 2896                 	lds r27, pulse2_duty_macro_release
001de2 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001de3 f019                      	breq sound_driver_channel1_release_exit
001de4 95b3                      	inc r27
001de5 93b0 2894                 	sts pulse2_duty_macro_offset, r27
                                 sound_driver_channel1_release_exit:
001de7 d019                      	rcall sound_driver_channel1_increment_offset
001de8 cd55                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_next_pattern:
001de9 91e0 2819                 	lds ZL, song_frames
001deb 91f0 281a                 	lds ZH, song_frames+1
001ded 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001def 91b0 281c                 	lds r27, song_frame_offset+1
001df1 9612                      	adiw r27:r26, 2 //offset for channel 1
001df2 0fea                      	add ZL, r26
001df3 1ffb                      	adc ZH, r27
                                 
001df4 91a5                      	lpm r26, Z+ //load the address of the next pattern
001df5 91b4                      	lpm r27, Z
001df6 0faa                      	lsl r26
001df7 1fbb                      	rol r27
001df8 93a0 2874                 	sts pulse2_pattern, r26
001dfa 93b0 2875                 	sts pulse2_pattern+1, r27
                                 
001dfc 9220 2878                 	sts pulse2_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001dfe 9220 2879                 	sts pulse2_pattern_offset+1, zero
001e00 cd3d                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_increment_offset:
001e01 91e0 2878                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001e03 91f0 2879                 	lds ZH, pulse2_pattern_offset+1
001e05 9631                      	adiw Z, 1
001e06 93e0 2878                 	sts pulse2_pattern_offset, ZL
001e08 93f0 2879                 	sts pulse2_pattern_offset+1, ZH
001e0a 9508                      	ret
                                 
                                 sound_driver_channel1_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001e0b 91e0 2878                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001e0d 91f0 2879                 	lds ZH, pulse2_pattern_offset+1
001e0f 9632                      	adiw Z, 2 //increment the pointer twice
001e10 93e0 2878                 	sts pulse2_pattern_offset, ZL
001e12 93f0 2879                 	sts pulse2_pattern_offset+1, ZH
001e14 9508                      	ret
                                 
                                 sound_driver_channel1_decrement_frame_delay:
001e15 95ba                      	dec r27
001e16 93b0 2877                 	sts pulse2_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel2:
001e18 91a0 28c7                 	lds r26, triangle_pattern_delay_rows
001e1a 91b0 28c8                 	lds r27, triangle_pattern_delay_frames
001e1c 9610                      	adiw r27:r26, 0
001e1d f009                      	breq sound_driver_channel2_main //if the pattern delay is 0, proceed with sound driver procedures
001e1e c2bf                      	rjmp sound_driver_channel2_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel2_main:
001e1f 91e0 28c5                 	lds ZL, triangle_pattern //current pattern for triangle
001e21 91f0 28c6                 	lds ZH, triangle_pattern+1
001e23 91a0 28c9                 	lds r26, triangle_pattern_offset //current offset in the pattern for triangle
001e25 91b0 28ca                 	lds r27, triangle_pattern_offset+1
001e27 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001e28 1ffb                      	adc ZH, r27
001e29 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel2_check_if_note: //check if data is a note (0x00 - 0x56)
001e2a 35b7                      	cpi r27, 0x57
001e2b f408                      	brsh sound_driver_channel2_check_if_volume
001e2c c160                      	rjmp sound_driver_channel2_note
                                 sound_driver_channel2_check_if_volume: //check if data is volume (0x57-0x66)
001e2d 36b7                      	cpi r27, 0x67
001e2e f408                      	brsh sound_driver_channel2_check_if_delay
001e2f c19e                      	rjmp sound_driver_channel2_volume
                                 sound_driver_channel2_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001e30 3eb3                      	cpi r27, 0xE3
001e31 f408                      	brsh sound_driver_channel2_check_if_instrument
001e32 c1a9                      	rjmp sound_driver_channel2_delay
                                 sound_driver_channel2_check_if_instrument: //check for instrument flag (0xE3)
001e33 f409                      	brne sound_driver_channel2_check_if_release
001e34 c1ac                      	rjmp sound_driver_channel2_instrument_change 
                                 sound_driver_channel2_check_if_release: //check for note release flag (0xE4)
001e35 3eb4                      	cpi r27, 0xE4
001e36 f409                      	brne sound_driver_channel2_check_if_end
001e37 c255                      	rjmp sound_driver_channel2_release
                                 sound_driver_channel2_check_if_end:
001e38 3fbf                      	cpi r27, 0xFF
001e39 f409                      	brne sound_driver_channel2_check_if_fx
001e3a c277                      	rjmp sound_driver_channel2_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel2_check_if_fx: //fx flags (0xE5 - 0xFE)
001e3b 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001e3c 91a4                      	lpm r26, Z //load the fx data into r26
001e3d d296                      	rcall sound_driver_channel2_increment_offset_twice
                                 
001e3e 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001e3f e6e8                      	ldi ZL, LOW(channel2_fx << 1) //load in note table
001e40 e6f1                      	ldi ZH, HIGH(channel2_fx << 1)
001e41 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001e42 0feb                      	add ZL, r27 //add offset
001e43 1df2                      	adc ZH, zero
001e44 91c5                      	lpm r28, Z+ //load address bytes
001e45 91d4                      	lpm r29, Z
001e46 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001e47 2ffd                      	mov ZH, r29
001e48 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel2_fx_0xy:
001e49 93a0 28e8                 	sts triangle_fx_0xy_sequence, r26
001e4b 9220 28e9                 	sts triangle_fx_0xy_sequence+1, zero
001e4d cfd1                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel2_fx_1xx:
001e4e 9220 28ee                 	sts triangle_fx_2xx, zero //turn off any 2xx pitch slide down
001e50 9220 28ef                 	sts triangle_fx_2xx+1, zero
001e52 9220 28e8                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001e54 9220 28e9                 	sts triangle_fx_0xy_sequence+1, zero
001e56 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001e57 937f                      	push r23
001e58 2f6a                      	mov r22, r26 //store the rate into r22
001e59 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001e5a 9f67                      	mul r22, r23
001e5b 917f                      	pop r23
001e5c 916f                      	pop r22
                                 
001e5d 9416                      	lsr r1 //shift out the fractional bits
001e5e 9407                      	ror r0
001e5f 9416                      	lsr r1
001e60 9407                      	ror r0
001e61 9416                      	lsr r1
001e62 9407                      	ror r0
001e63 9416                      	lsr r1
001e64 9407                      	ror r0
001e65 9200 28ea                 	sts triangle_fx_1xx, r0
001e67 9210 28eb                 	sts triangle_fx_1xx+1, r1
001e69 cfb5                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel2_fx_2xx:
001e6a 9220 28ea                 	sts triangle_fx_1xx, zero //turn off any 1xx pitch slide down
001e6c 9220 28eb                 	sts triangle_fx_1xx+1, zero
001e6e 9220 28e8                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001e70 9220 28e9                 	sts triangle_fx_0xy_sequence+1, zero
001e72 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001e73 937f                      	push r23
001e74 2f6a                      	mov r22, r26 //store the rate into r22
001e75 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001e76 9f67                      	mul r22, r23
001e77 917f                      	pop r23
001e78 916f                      	pop r22
                                 
001e79 9416                      	lsr r1 //shift out the fractional bits
001e7a 9407                      	ror r0
001e7b 9416                      	lsr r1
001e7c 9407                      	ror r0
001e7d 9416                      	lsr r1
001e7e 9407                      	ror r0
001e7f 9416                      	lsr r1
001e80 9407                      	ror r0
001e81 9200 28ee                 	sts triangle_fx_2xx, r0
001e83 9210 28ef                 	sts triangle_fx_2xx+1, r1
001e85 cf99                      	rjmp sound_driver_channel2_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel2_fx_3xx:
001e86 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001e87 937f                      	push r23
001e88 2f6a                      	mov r22, r26 //store the rate into r22
001e89 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001e8a 9f67                      	mul r22, r23
001e8b 917f                      	pop r23
001e8c 916f                      	pop r22
                                 
001e8d 9416                      	lsr r1 //shift out the fractional bits
001e8e 9407                      	ror r0
001e8f 9416                      	lsr r1
001e90 9407                      	ror r0
001e91 9416                      	lsr r1
001e92 9407                      	ror r0
001e93 9416                      	lsr r1
001e94 9407                      	ror r0
001e95 9200 28f6                 	sts triangle_fx_3xx_speed, r0
001e97 9210 28f7                 	sts triangle_fx_3xx_speed+1, r1
                                 
001e99 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001e9a c001                      	rjmp sound_driver_channel2_fx_3xx_enabled
001e9b cf83                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_3xx_enabled:
001e9c 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001e9e 91b0 0aad                 	lds r27, TCB2_CCMPH
001ea0 93a0 28f2                 	sts triangle_fx_3xx_start, r26
001ea2 93b0 28f3                 	sts triangle_fx_3xx_start+1, r27
                                 
001ea4 9220 28f8                 	sts triangle_fx_3xx_total_offset, zero
001ea6 9220 28f9                 	sts triangle_fx_3xx_total_offset+1, zero
001ea8 cf76                      	rjmp sound_driver_channel2_main
                                 
                                 //VIBRATO
                                 sound_driver_channel2_fx_4xy:
001ea9 2fba                      	mov r27, r26
001eaa 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001eab 95a2                      	swap r26
001eac 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001ead 93a0 28fa                 	sts triangle_fx_4xy_speed, r26
001eaf 93b0 28fb                 	sts triangle_fx_4xy_depth, r27
001eb1 9220 28fc                 	sts triangle_fx_4xy_phase, zero //reset the phase to 0
001eb3 cf6b                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_7xy: //tremelo
001eb4 cf6a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Axy: //volume slide
001eb5 cf69                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel2_fx_Bxx:
001eb6 93a0 2820                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001eb8 cf66                      	rjmp sound_driver_channel2_main
                                 
                                 //HALT
                                 sound_driver_channel2_fx_Cxx:
001eb9 93b0 2821                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001ebb cf63                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel2_fx_Dxx:
001ebc 93b0 2822                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001ebe cf60                      	rjmp sound_driver_channel2_main
                                 
                                 //VOLUME
                                 sound_driver_channel2_fx_Exx:
001ebf 15a2                      	cp r26, zero
001ec0 f021                      	breq sound_driver_channel2_fx_Exx_disable
                                 sound_driver_channel2_fx_Exx_enable:
001ec1 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001ec2 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001ec4 cf5a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Exx_disable:
001ec5 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
001ec7 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
001ec9 9220 0aad                 	sts TCB2_CCMPH, zero
001ecb cf53                      	rjmp sound_driver_channel2_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel2_fx_Fxx:
001ecc 93a0 281f                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001ece cf50                      	rjmp sound_driver_channel2_main
                                 
                                 //DELAY
                                 sound_driver_channel2_fx_Gxx:
001ecf 15a2                      	cp r26, zero
001ed0 f051                      	breq sound_driver_channel2_fx_Gxx_invalid
001ed1 91b0 281f                 	lds r27, song_speed
001ed3 17ab                      	cp r26, r27
001ed4 f430                      	brsh sound_driver_channel2_fx_Gxx_invalid
001ed5 93a0 28fd                 	sts triangle_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001ed7 e0b1                      	ldi r27, 0x01
001ed8 93b0 28c7                 	sts triangle_pattern_delay_rows, r27
001eda c206                      	rjmp sound_driver_channel3
                                 sound_driver_channel2_fx_Gxx_invalid:
001edb cf43                      	rjmp sound_driver_channel2_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Hxy: //hardware sweep up
001edc cf42                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixy: //hardware sweep down
001edd cf41                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Hxx: //FDS modulation depth
001ede cf40                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixx: //FDS modulation speed
001edf cf3f                      	rjmp sound_driver_channel2_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel2_fx_Pxx:
001ee0 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001ee1 937f                      	push r23
001ee2 2f6a                      	mov r22, r26
001ee3 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001ee4 0367                      	mulsu r22, r23
001ee5 917f                      	pop r23
001ee6 916f                      	pop r22
001ee7 9416                      	lsr r1 //shift out the fractional bits
001ee8 9407                      	ror r0
001ee9 9416                      	lsr r1
001eea 9407                      	ror r0
001eeb 9416                      	lsr r1
001eec 9407                      	ror r0
001eed 9416                      	lsr r1
001eee 9407                      	ror r0
001eef fe13                      	sbrs r1, 3 //check if result was a negative number
001ef0 c002                      	rjmp sound_driver_channel2_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel2_fx_Pxx_negative:
001ef1 efb0                      	ldi r27, 0xF0
001ef2 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel2_fx_Pxx_store:
001ef3 9200 28ff                 	sts triangle_fx_Pxx_total, r0
001ef5 9210 2900                 	sts triangle_fx_Pxx_total+1, r1
001ef7 cf27                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel2_fx_Qxy:
                                 sound_driver_channel2_fx_Qxy_check_arpeggio_macro:
001ef8 91e0 28d0                 	lds ZL, triangle_arpeggio_macro
001efa 91f0 28d1                 	lds ZH, triangle_arpeggio_macro+1
001efc 9630                      	adiw Z, 0
001efd f009                      	breq sound_driver_channel2_fx_Qxy_check_pitch_macro
001efe cf20                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_pitch_macro:
001eff 91e0 28d8                 	lds ZL, triangle_pitch_macro
001f01 91f0 28d9                 	lds ZH, triangle_pitch_macro+1
001f03 9630                      	adiw Z, 0
001f04 f009                      	breq sound_driver_channel2_fx_Qxy_check_hi_pitch_macro
001f05 cf19                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_hi_pitch_macro:
001f06 91e0 28de                 	lds ZL, triangle_hi_pitch_macro
001f08 91f0 28df                 	lds ZH, triangle_hi_pitch_macro+1
001f0a 9630                      	adiw Z, 0
001f0b f009                      	breq sound_driver_channel2_fx_Qxy_process
001f0c cf12                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_process:
001f0d 2fba                      	mov r27, r26 //copy fx parameters into r27
001f0e 70bf                      	andi r27, 0x0F //mask note index offset
001f0f 91c0 2901                 	lds r28, triangle_fx_Qxy_target_note //load current note index
001f11 0fbc                      	add r27, r28
001f12 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001f13 f008                      	brlo sound_driver_channel2_fx_Qxy_process_continue
001f14 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel2_fx_Qxy_process_continue:
001f15 93b0 2901                 	sts triangle_fx_Qxy_target_note, r27
001f17 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001f18 e0f0                      	ldi ZH, HIGH(note_table << 1)
001f19 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001f1a 0feb                      	add ZL, r27 //add offset
001f1b 1df2                      	adc ZH, zero
001f1c 91c5                      	lpm r28, Z+ //load bytes
001f1d 91d4                      	lpm r29, Z
001f1e 93c0 2902                 	sts triangle_fx_Qxy_target, r28 //load the LOW bits for the target period
001f20 93d0 2903                 	sts triangle_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel2_fx_Qxy_process_speed:
001f22 95a2                      	swap r26
001f23 70af                      	andi r26, 0x0F //mask effect speed
001f24 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001f25 95a3                      	inc r26 //increment the speed by 1
                                 
001f26 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001f27 937f                      	push r23
001f28 2f6a                      	mov r22, r26 //store the speed data into r27
001f29 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001f2a 9f67                      	mul r22, r23
001f2b 917f                      	pop r23
001f2c 916f                      	pop r22
                                 
001f2d 9416                      	lsr r1 //shift out the fractional bits
001f2e 9407                      	ror r0
001f2f 9416                      	lsr r1
001f30 9407                      	ror r0
001f31 9416                      	lsr r1
001f32 9407                      	ror r0
001f33 9416                      	lsr r1
001f34 9407                      	ror r0
                                 
001f35 9200 2904                 	sts triangle_fx_Qxy_speed, r0 //store the effect speed
001f37 9210 2905                 	sts triangle_fx_Qxy_speed+1, r1
001f39 cee5                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel2_fx_Rxy:
                                 sound_driver_channel2_fx_Rxy_check_arpeggio_macro:
001f3a 91e0 28d0                 	lds ZL, triangle_arpeggio_macro
001f3c 91f0 28d1                 	lds ZH, triangle_arpeggio_macro+1
001f3e 9630                      	adiw Z, 0
001f3f f009                      	breq sound_driver_channel2_fx_Rxy_check_pitch_macro
001f40 cede                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_pitch_macro:
001f41 91e0 28d8                 	lds ZL, triangle_pitch_macro
001f43 91f0 28d9                 	lds ZH, triangle_pitch_macro+1
001f45 9630                      	adiw Z, 0
001f46 f009                      	breq sound_driver_channel2_fx_Rxy_check_hi_pitch_macro
001f47 ced7                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_hi_pitch_macro:
001f48 91e0 28de                 	lds ZL, triangle_hi_pitch_macro
001f4a 91f0 28df                 	lds ZH, triangle_hi_pitch_macro+1
001f4c 9630                      	adiw Z, 0
001f4d f009                      	breq sound_driver_channel2_fx_Rxy_process
001f4e ced0                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_process:
001f4f 2fba                      	mov r27, r26 //copy fx parameters into r27
001f50 70bf                      	andi r27, 0x0F //mask note index offset
001f51 91c0 2908                 	lds r28, triangle_fx_Rxy_target_note //load current note index
001f53 1bcb                      	sub r28, r27
001f54 f408                      	brcc sound_driver_channel2_fx_Rxy_process_continue
001f55 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel2_fx_Rxy_process_continue:
001f56 93c0 2908                 	sts triangle_fx_Rxy_target_note, r28
001f58 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001f59 e0f0                      	ldi ZH, HIGH(note_table << 1)
001f5a 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001f5b 0fec                      	add ZL, r28 //add offset
001f5c 1df2                      	adc ZH, zero
001f5d 91c5                      	lpm r28, Z+ //load bytes
001f5e 91d4                      	lpm r29, Z
001f5f 93c0 2909                 	sts triangle_fx_Rxy_target, r28 //load the LOW bits for the target period
001f61 93d0 290a                 	sts triangle_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel2_fx_Rxy_process_speed:
001f63 95a2                      	swap r26
001f64 70af                      	andi r26, 0x0F //mask effect speed
001f65 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001f66 95a3                      	inc r26 //increment the speed by 1
                                 
001f67 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001f68 937f                      	push r23
001f69 2f6a                      	mov r22, r26 //store the speed data into r27
001f6a eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001f6b 9f67                      	mul r22, r23
001f6c 917f                      	pop r23
001f6d 916f                      	pop r22
                                 
001f6e 9416                      	lsr r1 //shift out the fractional bits
001f6f 9407                      	ror r0
001f70 9416                      	lsr r1
001f71 9407                      	ror r0
001f72 9416                      	lsr r1
001f73 9407                      	ror r0
001f74 9416                      	lsr r1
001f75 9407                      	ror r0
                                 
001f76 9200 290b                 	sts triangle_fx_Rxy_speed, r0 //store the effect speed
001f78 9210 290c                 	sts triangle_fx_Rxy_speed+1, r1
001f7a cea4                      	rjmp sound_driver_channel2_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel2_fx_Sxx:
001f7b 15a2                      	cp r26, zero
001f7c f051                      	breq sound_driver_channel2_fx_Sxx_invalid
001f7d 91b0 281f                 	lds r27, song_speed
001f7f 17ab                      	cp r26, r27
001f80 f430                      	brsh sound_driver_channel2_fx_Sxx_invalid
001f81 93a0 290f                 	sts triangle_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001f83 e0b1                      	ldi r27, 0x01
001f84 93b0 28c7                 	sts triangle_pattern_delay_rows, r27
001f86 c15a                      	rjmp sound_driver_channel3
                                 sound_driver_channel2_fx_Sxx_invalid:
001f87 ce97                      	rjmp sound_driver_channel2_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Vxx: //duty
001f88 ce96                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Wxx: //DPCM sample speed
001f89 ce95                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Xxx: //DPCM sample retrigger
001f8a ce94                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Yxx: //DPCM sample offset
001f8b ce93                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Zxx: //DPCM sample delta counter
001f8c ce92                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 sound_driver_channel2_note:
001f8d 93b0 2812                 	sts triangle_note, r27 //store the note index
001f8f 93b0 2901                 	sts triangle_fx_Qxy_target_note, r27
001f91 93b0 2908                 	sts triangle_fx_Rxy_target_note, r27
001f93 e0a3                      	ldi r26, 0x03
001f94 e0b2                      	ldi r27, 0x02
001f95 93b0 28cd                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
001f97 93a0 28d2                 	sts triangle_arpeggio_macro_offset, r26
001f99 93b0 28da                 	sts triangle_pitch_macro_offset, r27
001f9b 93b0 28e0                 	sts triangle_hi_pitch_macro_offset, r27
001f9d 93b0 28e5                 	sts triangle_duty_macro_offset, r27
001f9f 9220 28d6                 	sts triangle_total_pitch_offset, zero //reset the pitch and hi pitch offset
001fa1 9220 28d7                 	sts triangle_total_pitch_offset+1, zero
001fa3 9220 28dd                 	sts triangle_total_hi_pitch_offset, zero
001fa5 9220 28ec                 	sts triangle_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001fa7 9220 28ed                 	sts triangle_fx_1xx_total+1, zero
001fa9 9220 28f0                 	sts triangle_fx_2xx_total, zero
001fab 9220 28f1                 	sts triangle_fx_2xx_total+1, zero
001fad 9220 28f8                 	sts triangle_fx_3xx_total_offset, zero //reset 3xx offset
001faf 9220 28f9                 	sts triangle_fx_3xx_total_offset+1, zero
001fb1 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001fb3 91b0 0aad                 	lds r27, TCB2_CCMPH
001fb5 93a0 28f2                 	sts triangle_fx_3xx_start, r26
001fb7 93b0 28f3                 	sts triangle_fx_3xx_start+1, r27
001fb9 9220 2902                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001fbb 9220 2903                 	sts triangle_fx_Qxy_target+1, zero
001fbd 9220 2906                 	sts triangle_fx_Qxy_total_offset, zero
001fbf 9220 2907                 	sts triangle_fx_Qxy_total_offset+1, zero
001fc1 9220 2909                 	sts triangle_fx_Rxy_target, zero
001fc3 9220 290a                 	sts triangle_fx_Rxy_target+1, zero
001fc5 9220 290d                 	sts triangle_fx_Rxy_total_offset, zero
001fc7 9220 290e                 	sts triangle_fx_Rxy_total_offset+1, zero
001fc9 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001fca 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001fcc d0fd                      	rcall sound_driver_channel2_increment_offset
001fcd ce51                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_volume:
001fce d0fb                      	rcall sound_driver_channel2_increment_offset
001fcf 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001fd0 f021                      	breq sound_driver_channel2_volume_disable
                                 sound_driver_channel2_volume_enable:
001fd1 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001fd2 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001fd4 ce4a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_volume_disable:
001fd5 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
001fd7 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
001fd9 9220 0aad                 	sts TCB2_CCMPH, zero
001fdb ce43                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_delay:
001fdc 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001fdd 93b0 28c7                 	sts triangle_pattern_delay_rows, r27
001fdf d0ea                      	rcall sound_driver_channel2_increment_offset
001fe0 c100                      	rjmp sound_driver_channel3
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change:
001fe1 9220 28cb                 	sts triangle_volume_macro, zero //reset all macro addresses
001fe3 9220 28cc                 	sts triangle_volume_macro+1, zero
001fe5 9220 28d0                 	sts triangle_arpeggio_macro, zero
001fe7 9220 28d1                 	sts triangle_arpeggio_macro+1, zero
001fe9 9220 28d8                 	sts triangle_pitch_macro, zero
001feb 9220 28d9                 	sts triangle_pitch_macro+1, zero
001fed 9220 28de                 	sts triangle_hi_pitch_macro, zero
001fef 9220 28df                 	sts triangle_hi_pitch_macro+1, zero
001ff1 9220 28e3                 	sts triangle_duty_macro, zero
001ff3 9220 28e4                 	sts triangle_duty_macro+1, zero
001ff5 9220 28d6                 	sts triangle_total_pitch_offset, zero //reset the pitch offset
001ff7 9220 28d7                 	sts triangle_total_pitch_offset+1, zero
001ff9 9220 28dd                 	sts triangle_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001ffb 9631                      	adiw Z, 1 //point to the byte next to the flag
001ffc 91b4                      	lpm r27, Z //store the instrument offset into r27
001ffd e9ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
001ffe e1f1                      	ldi ZH, HIGH(instruments)
001fff 0feb                      	add ZL, r27 //point Z to offsetted instrument
002000 1df2                      	adc ZH, zero
002001 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
002002 1fff                      	rol ZH
002003 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
002004 91b4                      	lpm r27, Z
                                 
002005 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
002006 1fbb                      	rol r27
002007 2fea                      	mov ZL, r26
002008 2ffb                      	mov ZH, r27
002009 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
00200a 9632                      	adiw Z, 2 //point Z to the address of the macro
00200b e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel2_instrument_change_macro_loop:
00200c 95aa                      	dec r26
00200d f019                      	breq sound_driver_channel2_instrument_change_exit
00200e 95b6                      	lsr r27
00200f f078                      	brcs sound_driver_channel2_instrument_change_load_macro
002010 cffb                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_exit:
002011 e0a3                      	ldi r26, 0x03
002012 e0b2                      	ldi r27, 0x02
002013 93b0 28cd                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
002015 93a0 28d2                 	sts triangle_arpeggio_macro_offset, r26
002017 93b0 28da                 	sts triangle_pitch_macro_offset, r27
002019 93b0 28e0                 	sts triangle_hi_pitch_macro_offset, r27
00201b 93b0 28e5                 	sts triangle_duty_macro_offset, r27
00201d d0b6                      	rcall sound_driver_channel2_increment_offset_twice
00201e ce00                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_load_macro:
00201f 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
002020 91d5                      	lpm r29, Z+
                                 
002021 30a5                      	cpi r26, 5
002022 f039                      	breq sound_driver_channel2_instrument_change_load_macro_volume
002023 30a4                      	cpi r26, 4
002024 f079                      	breq sound_driver_channel2_instrument_change_load_macro_arpeggio
002025 30a3                      	cpi r26, 3
002026 f0d9                      	breq sound_driver_channel2_instrument_change_load_macro_pitch
002027 30a2                      	cpi r26, 2
002028 f159                      	breq sound_driver_channel2_instrument_change_load_macro_hi_pitch
002029 c03c                      	rjmp sound_driver_channel2_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel2_instrument_change_load_macro_volume:
00202a 93c0 28cb                 	sts triangle_volume_macro, r28
00202c 93d0 28cc                 	sts triangle_volume_macro+1, r29
00202e d041                      	rcall sound_driver_channel2_instrument_change_read_header
00202f 93c0 28cf                 	sts triangle_volume_macro_release, r28
002031 93d0 28ce                 	sts triangle_volume_macro_loop, r29
002033 cfd8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 	
                                 sound_driver_channel2_instrument_change_load_macro_arpeggio:
002034 93c0 28d0                 	sts triangle_arpeggio_macro, r28
002036 93d0 28d1                 	sts triangle_arpeggio_macro+1, r29
002038 9220 2902                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00203a 9220 2903                 	sts triangle_fx_Qxy_target+1, zero
00203c 9220 2909                 	sts triangle_fx_Rxy_target, zero
00203e 9220 290a                 	sts triangle_fx_Rxy_target+1, zero
002040 d03a                      	rcall sound_driver_channel2_instrument_change_read_header_arpeggio
002041 cfca                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_pitch:
002042 93c0 28d8                 	sts triangle_pitch_macro, r28
002044 93d0 28d9                 	sts triangle_pitch_macro+1, r29
002046 9220 2902                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
002048 9220 2903                 	sts triangle_fx_Qxy_target+1, zero
00204a 9220 2909                 	sts triangle_fx_Rxy_target, zero
00204c 9220 290a                 	sts triangle_fx_Rxy_target+1, zero
00204e d021                      	rcall sound_driver_channel2_instrument_change_read_header
00204f 93c0 28dc                 	sts triangle_pitch_macro_release, r28
002051 93d0 28db                 	sts triangle_pitch_macro_loop, r29
002053 cfb8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_hi_pitch:
002054 93c0 28de                 	sts triangle_hi_pitch_macro, r28
002056 93d0 28df                 	sts triangle_hi_pitch_macro+1, r29
002058 9220 2902                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00205a 9220 2903                 	sts triangle_fx_Qxy_target+1, zero
00205c 9220 2909                 	sts triangle_fx_Rxy_target, zero
00205e 9220 290a                 	sts triangle_fx_Rxy_target+1, zero
002060 d00f                      	rcall sound_driver_channel2_instrument_change_read_header
002061 93c0 28e2                 	sts triangle_hi_pitch_macro_release, r28
002063 93d0 28e1                 	sts triangle_hi_pitch_macro_loop, r29
002065 cfa6                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_duty:
002066 93c0 28e3                 	sts triangle_duty_macro, r28
002068 93d0 28e4                 	sts triangle_duty_macro+1, r29
00206a d005                      	rcall sound_driver_channel2_instrument_change_read_header
00206b 93c0 28e7                 	sts triangle_duty_macro_release, r28
00206d 93d0 28e6                 	sts triangle_duty_macro_loop, r29
00206f cf9c                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_read_header:
002070 93ef                      	push ZL
002071 93ff                      	push ZH
002072 2fec                      	mov ZL, r28
002073 2ffd                      	mov ZH, r29
002074 0fee                      	lsl ZL
002075 1fff                      	rol ZH
002076 91c5                      	lpm r28, Z+
002077 91d4                      	lpm r29, Z
002078 91ff                      	pop ZH
002079 91ef                      	pop ZL
00207a 9508                      	ret
                                 
                                 sound_driver_channel2_instrument_change_read_header_arpeggio:
00207b 93ef                      	push ZL
00207c 93ff                      	push ZH
00207d 2fec                      	mov ZL, r28
00207e 2ffd                      	mov ZH, r29
00207f 0fee                      	lsl ZL
002080 1fff                      	rol ZH
002081 91c5                      	lpm r28, Z+
002082 91d5                      	lpm r29, Z+
002083 93c0 28d4                 	sts triangle_arpeggio_macro_release, r28
002085 93d0 28d3                 	sts triangle_arpeggio_macro_loop, r29
002087 91c4                      	lpm r28, Z
002088 93c0 28d5                 	sts triangle_arpeggio_macro_mode, r28
00208a 91ff                      	pop ZH
00208b 91ef                      	pop ZL
00208c 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel2_release:
                                 sound_driver_channel2_release_volume:
00208d 91b0 28cf                 	lds r27, triangle_volume_macro_release
00208f 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
002090 f019                      	breq sound_driver_channel2_release_arpeggio //if the macro has no release flag, check the next macro
002091 95b3                      	inc r27
002092 93b0 28cd                 	sts triangle_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel2_release_arpeggio:
002094 91b0 28d4                 	lds r27, triangle_arpeggio_macro_release
002096 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
002097 f019                      	breq sound_driver_channel2_release_pitch
002098 95b3                      	inc r27
002099 93b0 28d2                 	sts triangle_arpeggio_macro_offset, r27
                                 sound_driver_channel2_release_pitch:
00209b 91b0 28dc                 	lds r27, triangle_pitch_macro_release
00209d 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
00209e f019                      	breq sound_driver_channel2_release_hi_pitch
00209f 95b3                      	inc r27
0020a0 93b0 28da                 	sts triangle_pitch_macro_offset, r27
                                 sound_driver_channel2_release_hi_pitch:
0020a2 91b0 28e2                 	lds r27, triangle_hi_pitch_macro_release
0020a4 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
0020a5 f019                      	breq sound_driver_channel2_release_duty
0020a6 95b3                      	inc r27
0020a7 93b0 28e0                 	sts triangle_hi_pitch_macro_offset, r27
                                 sound_driver_channel2_release_duty:
0020a9 91b0 28e7                 	lds r27, triangle_duty_macro_release
0020ab 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
0020ac f019                      	breq sound_driver_channel2_release_exit
0020ad 95b3                      	inc r27
0020ae 93b0 28e5                 	sts triangle_duty_macro_offset, r27
                                 sound_driver_channel2_release_exit:
0020b0 d019                      	rcall sound_driver_channel2_increment_offset
0020b1 cd6d                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_next_pattern:
0020b2 91e0 2819                 	lds ZL, song_frames
0020b4 91f0 281a                 	lds ZH, song_frames+1
0020b6 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
0020b8 91b0 281c                 	lds r27, song_frame_offset+1
0020ba 9614                      	adiw r27:r26, 4 //offset for channel 2
0020bb 0fea                      	add ZL, r26
0020bc 1ffb                      	adc ZH, r27
                                 
0020bd 91a5                      	lpm r26, Z+ //load the address of the next pattern
0020be 91b4                      	lpm r27, Z
0020bf 0faa                      	lsl r26
0020c0 1fbb                      	rol r27
0020c1 93a0 28c5                 	sts triangle_pattern, r26
0020c3 93b0 28c6                 	sts triangle_pattern+1, r27
                                 
0020c5 9220 28c9                 	sts triangle_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
0020c7 9220 28ca                 	sts triangle_pattern_offset+1, zero
0020c9 cd55                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_increment_offset:
0020ca 91e0 28c9                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
0020cc 91f0 28ca                 	lds ZH, triangle_pattern_offset+1
0020ce 9631                      	adiw Z, 1
0020cf 93e0 28c9                 	sts triangle_pattern_offset, ZL
0020d1 93f0 28ca                 	sts triangle_pattern_offset+1, ZH
0020d3 9508                      	ret
                                 
                                 sound_driver_channel2_increment_offset_twice: //used for data that takes up 2 bytes worth of space
0020d4 91e0 28c9                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
0020d6 91f0 28ca                 	lds ZH, triangle_pattern_offset+1
0020d8 9632                      	adiw Z, 2 //increment the pointer twice
0020d9 93e0 28c9                 	sts triangle_pattern_offset, ZL
0020db 93f0 28ca                 	sts triangle_pattern_offset+1, ZH
0020dd 9508                      	ret
                                 
                                 sound_driver_channel2_decrement_frame_delay:
0020de 95ba                      	dec r27
0020df 93b0 28c8                 	sts triangle_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel3:
0020e1 91a0 2913                 	lds r26, noise_pattern_delay_rows
0020e3 91b0 2914                 	lds r27, noise_pattern_delay_frames
0020e5 9610                      	adiw r27:r26, 0
0020e6 f009                      	breq sound_driver_channel3_main //if the pattern delay is 0, proceed with sound driver procedures
0020e7 c1b9                      	rjmp sound_driver_channel3_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel3_main:
0020e8 91e0 2911                 	lds ZL, noise_pattern //current pattern for noise
0020ea 91f0 2912                 	lds ZH, noise_pattern+1
0020ec 91a0 2915                 	lds r26, noise_pattern_offset //current offset in the pattern for noise
0020ee 91b0 2916                 	lds r27, noise_pattern_offset+1
0020f0 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
0020f1 1ffb                      	adc ZH, r27
0020f2 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel3_check_if_note: //check if data is a note (0x00 - 0x56)
0020f3 35b7                      	cpi r27, 0x57
0020f4 f408                      	brsh sound_driver_channel3_check_if_volume
0020f5 c096                      	rjmp sound_driver_channel3_note
                                 sound_driver_channel3_check_if_volume: //check if data is volume (0x57-0x66)
0020f6 36b7                      	cpi r27, 0x67
0020f7 f408                      	brsh sound_driver_channel3_check_if_delay
0020f8 c0b1                      	rjmp sound_driver_channel3_volume
                                 sound_driver_channel3_check_if_delay: //check if data is a delay (0x67 - 0xE2)
0020f9 3eb3                      	cpi r27, 0xE3
0020fa f408                      	brsh sound_driver_channel3_check_if_instrument
0020fb c0b7                      	rjmp sound_driver_channel3_delay
                                 sound_driver_channel3_check_if_instrument: //check for instrument flag (0xE3)
0020fc f409                      	brne sound_driver_channel3_check_if_release
0020fd c0ba                      	rjmp sound_driver_channel3_instrument_change 
                                 sound_driver_channel3_check_if_release: //check for note release flag (0xE4)
0020fe 3eb4                      	cpi r27, 0xE4
0020ff f409                      	brne sound_driver_channel3_check_if_end
002100 c14b                      	rjmp sound_driver_channel3_release
                                 sound_driver_channel3_check_if_end:
002101 3fbf                      	cpi r27, 0xFF
002102 f409                      	brne sound_driver_channel3_check_if_fx
002103 c16d                      	rjmp sound_driver_channel3_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel3_check_if_fx: //fx flags (0xE5 - 0xFE)
002104 9631                      	adiw Z, 1 //point Z to the byte next to the flag
002105 91a4                      	lpm r26, Z //load the fx data into r26
002106 d190                      	rcall sound_driver_channel3_increment_offset_twice
                                 
002107 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
002108 e9ec                      	ldi ZL, LOW(channel3_fx << 1) //load in note table
002109 e6f1                      	ldi ZH, HIGH(channel3_fx << 1)
00210a 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
00210b 0feb                      	add ZL, r27 //add offset
00210c 1df2                      	adc ZH, zero
00210d 91c5                      	lpm r28, Z+ //load address bytes
00210e 91d4                      	lpm r29, Z
00210f 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
002110 2ffd                      	mov ZH, r29
002111 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel3_fx_0xy:
002112 93a0 2934                 	sts noise_fx_0xy_sequence, r26
002114 9220 2935                 	sts noise_fx_0xy_sequence+1, zero
002116 cfd1                      	rjmp sound_driver_channel3_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel3_fx_1xx:
002117 9220 2938                 	sts noise_fx_2xx, zero //turn off any 2xx pitch slide down
002119 9220 2934                 	sts noise_fx_0xy_sequence, zero //disable any 0xy effect
00211b 9220 2935                 	sts noise_fx_0xy_sequence+1, zero
00211d 93a0 2936                 	sts noise_fx_1xx, r26
00211f cfc8                      	rjmp sound_driver_channel3_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel3_fx_2xx:
002120 9220 2936                 	sts noise_fx_1xx, zero //turn off any 1xx pitch slide down
002122 9220 2934                 	sts noise_fx_0xy_sequence, zero //disable any 0xy effect
002124 9220 2935                 	sts noise_fx_0xy_sequence+1, zero
002126 93a0 2938                 	sts noise_fx_2xx, r26
002128 cfbf                      	rjmp sound_driver_channel3_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel3_fx_3xx:
002129 cfbe                      	rjmp sound_driver_channel3_main
                                 
                                 //VIBRATO
                                 sound_driver_channel3_fx_4xy:
00212a 2fba                      	mov r27, r26
00212b 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
00212c 95a2                      	swap r26
00212d 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
00212e 93a0 293a                 	sts noise_fx_4xy_speed, r26
002130 93b0 293b                 	sts noise_fx_4xy_depth, r27
002132 9220 293c                 	sts noise_fx_4xy_phase, zero //reset the phase to 0
002134 9220 293d                 	sts noise_fx_4xy_offset, zero
002136 cfb1                      	rjmp sound_driver_channel3_main
                                 
                                 //TREMELO
                                 sound_driver_channel3_fx_7xy:
002137 2fba                      	mov r27, r26
002138 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
002139 95a2                      	swap r26
00213a 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
00213b 93a0 293e                 	sts noise_fx_7xy_speed, r26
00213d 93b0 293f                 	sts noise_fx_7xy_depth, r27
00213f 9220 2940                 	sts noise_fx_7xy_phase, zero //reset the phase to 0
002141 9220 2941                 	sts noise_fx_7xy_value, zero //reset the tremelo value
002143 cfa4                      	rjmp sound_driver_channel3_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel3_fx_Axy:
002144 93a0 2942                 	sts noise_fx_Axy, r26
002146 cfa1                      	rjmp sound_driver_channel3_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel3_fx_Bxx:
002147 93a0 2820                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
002149 cf9e                      	rjmp sound_driver_channel3_main
                                 
                                 //HALT
                                 sound_driver_channel3_fx_Cxx:
00214a 93b0 2821                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
00214c cf9b                      	rjmp sound_driver_channel3_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel3_fx_Dxx:
00214d 93b0 2822                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
00214f cf98                      	rjmp sound_driver_channel3_main
                                 
                                 //VOLUME
                                 sound_driver_channel3_fx_Exx:
002150 91b0 2813                 	lds r27, noise_param
002152 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
002153 2bba                      	or r27, r26 //move new VVVV bits into noise_param
002154 93b0 2813                 	sts noise_param, r27
002156 cf91                      	rjmp sound_driver_channel3_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel3_fx_Fxx:
002157 93a0 281f                 	sts song_speed, r26 //NOTE: only changes to speed are supported
002159 cf8e                      	rjmp sound_driver_channel3_main
                                 
                                 //DELAY
                                 sound_driver_channel3_fx_Gxx:
00215a 15a2                      	cp r26, zero
00215b f051                      	breq sound_driver_channel3_fx_Gxx_invalid
00215c 91b0 281f                 	lds r27, song_speed
00215e 17ab                      	cp r26, r27
00215f f430                      	brsh sound_driver_channel3_fx_Gxx_invalid
002160 93a0 2943                 	sts noise_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
002162 e0b1                      	ldi r27, 0x01
002163 93b0 2913                 	sts noise_pattern_delay_rows, r27
002165 c13e                      	rjmp sound_driver_channel4
                                 sound_driver_channel3_fx_Gxx_invalid:
002166 cf81                      	rjmp sound_driver_channel3_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel3_fx_Hxy: //hardware sweep up
002167 cf80                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Ixy: //hardware sweep down
002168 cf7f                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Hxx: //FDS modulation depth
002169 cf7e                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Ixx: //FDS modulation speed
00216a cf7d                      	rjmp sound_driver_channel3_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel3_fx_Pxx:
00216b 93a0 2945                 	sts noise_fx_Pxx_total, r26
00216d cf7a                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_Qxy: //note slide up
00216e cf79                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Rxy: //note slide down
00216f cf78                      	rjmp sound_driver_channel3_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel3_fx_Sxx:
002170 15a2                      	cp r26, zero
002171 f051                      	breq sound_driver_channel3_fx_Sxx_invalid
002172 91b0 281f                 	lds r27, song_speed
002174 17ab                      	cp r26, r27
002175 f430                      	brsh sound_driver_channel3_fx_Sxx_invalid
002176 93a0 2946                 	sts noise_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
002178 e0b1                      	ldi r27, 0x01
002179 93b0 2913                 	sts noise_pattern_delay_rows, r27
00217b c128                      	rjmp sound_driver_channel4
                                 sound_driver_channel3_fx_Sxx_invalid:
00217c cf6b                      	rjmp sound_driver_channel3_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel3_fx_Vxx:
00217d 95a6                      	lsr r26
00217e 95a7                      	ror r26 //move mode bit to bit 7
00217f 91b0 2814                 	lds r27, noise_period
002181 77bf                      	andi r27, 0b01111111
002182 2bba                      	or r27, r26 //store the new noise mode
002183 93b0 2813                 	sts noise_param, r27
                                 
002185 776f                      	andi noise_sequence_HIGH, 0b01111111
002186 2b6a                      	or noise_sequence_HIGH, r26
002187 cf60                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_Wxx: //DPCM sample speed
002188 cf5f                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Xxx: //DPCM sample retrigger
002189 cf5e                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Yxx: //DPCM sample offset
00218a cf5d                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Zxx: //DPCM sample delta counter
00218b cf5c                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 sound_driver_channel3_note:
00218c 93b0 2817                 	sts noise_note, r27
00218e 93b0 2818                 	sts noise_adjusted_note, r27
002190 e0a3                      	ldi r26, 0x03
002191 e0b2                      	ldi r27, 0x02
002192 93b0 2919                 	sts noise_volume_macro_offset, r27 //reset all macro offsets
002194 93a0 291e                 	sts noise_arpeggio_macro_offset, r26
002196 93b0 2926                 	sts noise_pitch_macro_offset, r27
002198 93b0 292c                 	sts noise_hi_pitch_macro_offset, r27
00219a 93b0 2931                 	sts noise_duty_macro_offset, r27
00219c 9220 2922                 	sts noise_total_pitch_offset, zero //reset the pitch and hi pitch offset
00219e 9220 2923                 	sts noise_total_pitch_offset+1, zero
0021a0 9220 2929                 	sts noise_total_hi_pitch_offset, zero
0021a2 9220 2937                 	sts noise_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
0021a4 9220 2939                 	sts noise_fx_2xx_total, zero
0021a6 9220 293d                 	sts noise_fx_4xy_offset, zero
0021a8 d0e4                      	rcall sound_driver_channel3_increment_offset
0021a9 cf3e                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_volume:
0021aa 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
0021ab 91a0 2813                 	lds r26, noise_param
0021ad 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
0021ae 2bab                      	or r26, r27 //move new VVVV bits into noise_param
0021af 93a0 2813                 	sts noise_param, r26
0021b1 d0db                      	rcall sound_driver_channel3_increment_offset
0021b2 cf35                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_delay:
0021b3 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
0021b4 93b0 2913                 	sts noise_pattern_delay_rows, r27
0021b6 d0d6                      	rcall sound_driver_channel3_increment_offset
0021b7 c0ec                      	rjmp sound_driver_channel4
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change:
0021b8 9220 2917                 	sts noise_volume_macro, zero //reset all macro addresses
0021ba 9220 2918                 	sts noise_volume_macro+1, zero
0021bc 9220 291c                 	sts noise_arpeggio_macro, zero
0021be 9220 291d                 	sts noise_arpeggio_macro+1, zero
0021c0 9220 2924                 	sts noise_pitch_macro, zero
0021c2 9220 2925                 	sts noise_pitch_macro+1, zero
0021c4 9220 292a                 	sts noise_hi_pitch_macro, zero
0021c6 9220 292b                 	sts noise_hi_pitch_macro+1, zero
0021c8 9220 292f                 	sts noise_duty_macro, zero
0021ca 9220 2930                 	sts noise_duty_macro+1, zero
0021cc 9220 2922                 	sts noise_total_pitch_offset, zero //reset the pitch offset
0021ce 9220 2923                 	sts noise_total_pitch_offset+1, zero
0021d0 9220 2929                 	sts noise_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
0021d2 9631                      	adiw Z, 1 //point to the byte next to the flag
0021d3 91b4                      	lpm r27, Z //store the instrument offset into r27
0021d4 e9ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
0021d5 e1f1                      	ldi ZH, HIGH(instruments)
0021d6 0feb                      	add ZL, r27 //point Z to offsetted instrument
0021d7 1df2                      	adc ZH, zero
0021d8 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
0021d9 1fff                      	rol ZH
0021da 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
0021db 91b4                      	lpm r27, Z
                                 
0021dc 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
0021dd 1fbb                      	rol r27
0021de 2fea                      	mov ZL, r26
0021df 2ffb                      	mov ZH, r27
0021e0 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
0021e1 9632                      	adiw Z, 2 //point Z to the address of the macro
0021e2 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel3_instrument_change_macro_loop:
0021e3 95aa                      	dec r26
0021e4 f019                      	breq sound_driver_channel3_instrument_change_exit
0021e5 95b6                      	lsr r27
0021e6 f078                      	brcs sound_driver_channel3_instrument_change_load_macro
0021e7 cffb                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_exit:
0021e8 e0a3                      	ldi r26, 0x03
0021e9 e0b2                      	ldi r27, 0x02
0021ea 93b0 2919                 	sts noise_volume_macro_offset, r27 //reset all macro offsets
0021ec 93a0 291e                 	sts noise_arpeggio_macro_offset, r26
0021ee 93b0 2926                 	sts noise_pitch_macro_offset, r27
0021f0 93b0 292c                 	sts noise_hi_pitch_macro_offset, r27
0021f2 93b0 2931                 	sts noise_duty_macro_offset, r27
0021f4 d0a2                      	rcall sound_driver_channel3_increment_offset_twice
0021f5 cef2                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_load_macro:
0021f6 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
0021f7 91d5                      	lpm r29, Z+
                                 
0021f8 30a5                      	cpi r26, 5
0021f9 f039                      	breq sound_driver_channel3_instrument_change_load_macro_volume
0021fa 30a4                      	cpi r26, 4
0021fb f079                      	breq sound_driver_channel3_instrument_change_load_macro_arpeggio
0021fc 30a3                      	cpi r26, 3
0021fd f099                      	breq sound_driver_channel3_instrument_change_load_macro_pitch
0021fe 30a2                      	cpi r26, 2
0021ff f0d9                      	breq sound_driver_channel3_instrument_change_load_macro_hi_pitch
002200 c024                      	rjmp sound_driver_channel3_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel3_instrument_change_load_macro_volume:
002201 93c0 2917                 	sts noise_volume_macro, r28
002203 93d0 2918                 	sts noise_volume_macro+1, r29
002205 d029                      	rcall sound_driver_channel3_instrument_change_read_header
002206 93c0 291b                 	sts noise_volume_macro_release, r28
002208 93d0 291a                 	sts noise_volume_macro_loop, r29
00220a cfd8                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 	
                                 sound_driver_channel3_instrument_change_load_macro_arpeggio:
00220b 93c0 291c                 	sts noise_arpeggio_macro, r28
00220d 93d0 291d                 	sts noise_arpeggio_macro+1, r29
00220f d02a                      	rcall sound_driver_channel3_instrument_change_read_header_arpeggio
002210 cfd2                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_pitch:
002211 93c0 2924                 	sts noise_pitch_macro, r28
002213 93d0 2925                 	sts noise_pitch_macro+1, r29
002215 d019                      	rcall sound_driver_channel3_instrument_change_read_header
002216 93c0 2928                 	sts noise_pitch_macro_release, r28
002218 93d0 2927                 	sts noise_pitch_macro_loop, r29
00221a cfc8                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_hi_pitch:
00221b 93c0 292a                 	sts noise_hi_pitch_macro, r28
00221d 93d0 292b                 	sts noise_hi_pitch_macro+1, r29
00221f d00f                      	rcall sound_driver_channel3_instrument_change_read_header
002220 93c0 292e                 	sts noise_hi_pitch_macro_release, r28
002222 93d0 292d                 	sts noise_hi_pitch_macro_loop, r29
002224 cfbe                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_duty:
002225 93c0 292f                 	sts noise_duty_macro, r28
002227 93d0 2930                 	sts noise_duty_macro+1, r29
002229 d005                      	rcall sound_driver_channel3_instrument_change_read_header
00222a 93c0 2933                 	sts noise_duty_macro_release, r28
00222c 93d0 2932                 	sts noise_duty_macro_loop, r29
00222e cfb4                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_read_header:
00222f 93ef                      	push ZL
002230 93ff                      	push ZH
002231 2fec                      	mov ZL, r28
002232 2ffd                      	mov ZH, r29
002233 0fee                      	lsl ZL
002234 1fff                      	rol ZH
002235 91c5                      	lpm r28, Z+
002236 91d4                      	lpm r29, Z
002237 91ff                      	pop ZH
002238 91ef                      	pop ZL
002239 9508                      	ret
                                 
                                 sound_driver_channel3_instrument_change_read_header_arpeggio:
00223a 93ef                      	push ZL
00223b 93ff                      	push ZH
00223c 2fec                      	mov ZL, r28
00223d 2ffd                      	mov ZH, r29
00223e 0fee                      	lsl ZL
00223f 1fff                      	rol ZH
002240 91c5                      	lpm r28, Z+
002241 91d5                      	lpm r29, Z+
002242 93c0 2920                 	sts noise_arpeggio_macro_release, r28
002244 93d0 291f                 	sts noise_arpeggio_macro_loop, r29
002246 91c4                      	lpm r28, Z
002247 93c0 2921                 	sts noise_arpeggio_macro_mode, r28
002249 91ff                      	pop ZH
00224a 91ef                      	pop ZL
00224b 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel3_release:
                                 sound_driver_channel3_release_volume:
00224c 91b0 291b                 	lds r27, noise_volume_macro_release
00224e 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
00224f f019                      	breq sound_driver_channel3_release_arpeggio //if the macro has no release flag, check the next macro
002250 95b3                      	inc r27
002251 93b0 2919                 	sts noise_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel3_release_arpeggio:
002253 91b0 2920                 	lds r27, noise_arpeggio_macro_release
002255 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
002256 f019                      	breq sound_driver_channel3_release_pitch
002257 95b3                      	inc r27
002258 93b0 291e                 	sts noise_arpeggio_macro_offset, r27
                                 sound_driver_channel3_release_pitch:
00225a 91b0 2928                 	lds r27, noise_pitch_macro_release
00225c 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
00225d f019                      	breq sound_driver_channel3_release_hi_pitch
00225e 95b3                      	inc r27
00225f 93b0 2926                 	sts noise_pitch_macro_offset, r27
                                 sound_driver_channel3_release_hi_pitch:
002261 91b0 292e                 	lds r27, noise_hi_pitch_macro_release
002263 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
002264 f019                      	breq sound_driver_channel3_release_duty
002265 95b3                      	inc r27
002266 93b0 292c                 	sts noise_hi_pitch_macro_offset, r27
                                 sound_driver_channel3_release_duty:
002268 91b0 2933                 	lds r27, noise_duty_macro_release
00226a 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
00226b f019                      	breq sound_driver_channel3_release_exit
00226c 95b3                      	inc r27
00226d 93b0 2931                 	sts noise_duty_macro_offset, r27
                                 sound_driver_channel3_release_exit:
00226f d01d                      	rcall sound_driver_channel3_increment_offset
002270 ce77                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_next_pattern:
002271 91e0 2819                 	lds ZL, song_frames
002273 91f0 281a                 	lds ZH, song_frames+1
002275 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
002277 91b0 281c                 	lds r27, song_frame_offset+1
002279 93a0 281b                 	sts song_frame_offset, r26
00227b 93b0 281c                 	sts song_frame_offset+1, r27
00227d 9616                      	adiw r27:r26, 6 //offset for channel 3
00227e 0fea                      	add ZL, r26
00227f 1ffb                      	adc ZH, r27
                                 
002280 91a5                      	lpm r26, Z+ //load the address of the next pattern
002281 91b4                      	lpm r27, Z
002282 0faa                      	lsl r26
002283 1fbb                      	rol r27
002284 93a0 2911                 	sts noise_pattern, r26
002286 93b0 2912                 	sts noise_pattern+1, r27
                                 
002288 9220 2915                 	sts noise_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
00228a 9220 2916                 	sts noise_pattern_offset+1, zero
00228c ce5b                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_increment_offset:
00228d 91e0 2915                 	lds ZL, noise_pattern_offset //current offset in the pattern for noise
00228f 91f0 2916                 	lds ZH, noise_pattern_offset+1
002291 9631                      	adiw Z, 1
002292 93e0 2915                 	sts noise_pattern_offset, ZL
002294 93f0 2916                 	sts noise_pattern_offset+1, ZH
002296 9508                      	ret
                                 
                                 sound_driver_channel3_increment_offset_twice: //used for data that takes up 2 bytes worth of space
002297 91e0 2915                 	lds ZL, noise_pattern_offset //current offset in the pattern for noise
002299 91f0 2916                 	lds ZH, noise_pattern_offset+1
00229b 9632                      	adiw Z, 2 //increment the pointer twice
00229c 93e0 2915                 	sts noise_pattern_offset, ZL
00229e 93f0 2916                 	sts noise_pattern_offset+1, ZH
0022a0 9508                      	ret
                                 
                                 sound_driver_channel3_decrement_frame_delay:
0022a1 95ba                      	dec r27
0022a2 93b0 2914                 	sts noise_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel4:
0022a4 91a0 294a                 	lds r26, dpcm_pattern_delay_rows
0022a6 91b0 294b                 	lds r27, dpcm_pattern_delay_frames
0022a8 9610                      	adiw r27:r26, 0
0022a9 f009                      	breq sound_driver_channel4_main //if the pattern delay is 0, proceed with sound driver procedures
0022aa c0bd                      	rjmp sound_driver_channel4_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel4_main:
0022ab 91e0 2948                 	lds ZL, dpcm_pattern //current pattern for dpcm
0022ad 91f0 2949                 	lds ZH, dpcm_pattern+1
0022af 91a0 294c                 	lds r26, dpcm_pattern_offset //current offset in the pattern for dpcm
0022b1 91b0 294d                 	lds r27, dpcm_pattern_offset+1
0022b3 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
0022b4 1ffb                      	adc ZH, r27
0022b5 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel4_check_if_note: //check if data is a note (0x00 - 0x56)
0022b6 35b7                      	cpi r27, 0x57
0022b7 f408                      	brsh sound_driver_channel4_check_if_volume
0022b8 c056                      	rjmp sound_driver_channel4_note
                                 sound_driver_channel4_check_if_volume: //check if data is volume (0x57-0x66)
0022b9 36b7                      	cpi r27, 0x67
0022ba f408                      	brsh sound_driver_channel4_check_if_delay
0022bb c071                      	rjmp sound_driver_channel4_volume
                                 sound_driver_channel4_check_if_delay: //check if data is a delay (0x67 - 0xE2)
0022bc 3eb3                      	cpi r27, 0xE3
0022bd f408                      	brsh sound_driver_channel4_check_if_instrument
0022be c070                      	rjmp sound_driver_channel4_delay
                                 sound_driver_channel4_check_if_instrument: //check for instrument flag (0xE3)
0022bf f409                      	brne sound_driver_channel4_check_if_release
0022c0 c073                      	rjmp sound_driver_channel4_instrument_change 
                                 sound_driver_channel4_check_if_release: //check for note release flag (0xE4)
0022c1 3eb4                      	cpi r27, 0xE4
0022c2 f409                      	brne sound_driver_channel4_check_if_end
0022c3 c072                      	rjmp sound_driver_channel4_release
                                 sound_driver_channel4_check_if_end:
0022c4 3fbf                      	cpi r27, 0xFF
0022c5 f409                      	brne sound_driver_channel4_check_if_fx
0022c6 c071                      	rjmp sound_driver_channel4_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel4_check_if_fx: //fx flags (0xE5 - 0xFE)
0022c7 9631                      	adiw Z, 1 //point Z to the byte next to the flag
0022c8 91a4                      	lpm r26, Z //load the fx data into r26
0022c9 d094                      	rcall sound_driver_channel4_increment_offset_twice
                                 
0022ca 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
0022cb ede0                      	ldi ZL, LOW(channel4_fx << 1) //load in note table
0022cc e6f1                      	ldi ZH, HIGH(channel4_fx << 1)
0022cd 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
0022ce 0feb                      	add ZL, r27 //add offset
0022cf 1df2                      	adc ZH, zero
0022d0 91c5                      	lpm r28, Z+ //load address bytes
0022d1 91d4                      	lpm r29, Z
0022d2 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
0022d3 2ffd                      	mov ZH, r29
0022d4 9409                      	ijmp
                                 
                                 
                                 
                                 sound_driver_channel4_fx_0xy: //arpeggio
0022d5 cfd5                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_1xx: //pitch slide up
0022d6 cfd4                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_2xx: //pitch slide down
0022d7 cfd3                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_3xx: //automatic portamento
0022d8 cfd2                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_4xy: //vibrato
0022d9 cfd1                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_7xy: //tremelo
0022da cfd0                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Axy: //volume slide
0022db cfcf                      	rjmp sound_driver_channel4_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel4_fx_Bxx:
0022dc 93a0 2820                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
0022de cfcc                      	rjmp sound_driver_channel4_main
                                 
                                 //HALT
                                 sound_driver_channel4_fx_Cxx:
0022df 93b0 2821                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
0022e1 cfc9                      	rjmp sound_driver_channel4_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel4_fx_Dxx:
0022e2 93b0 2822                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
0022e4 cfc6                      	rjmp sound_driver_channel4_main
                                 
                                 sound_driver_channel4_fx_Exx: //volume
0022e5 cfc5                      	rjmp sound_driver_channel4_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel4_fx_Fxx:
0022e6 93a0 281f                 	sts song_speed, r26 //NOTE: only changes to speed are supported
0022e8 cfc2                      	rjmp sound_driver_channel4_main
                                 
                                 //DELAY
                                 sound_driver_channel4_fx_Gxx:
0022e9 15a2                      	cp r26, zero
0022ea f051                      	breq sound_driver_channel4_fx_Gxx_invalid
0022eb 91b0 281f                 	lds r27, song_speed
0022ed 17ab                      	cp r26, r27
0022ee f430                      	brsh sound_driver_channel4_fx_Gxx_invalid
0022ef 93a0 2952                 	sts dpcm_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
0022f1 e0b1                      	ldi r27, 0x01
0022f2 93b0 294a                 	sts dpcm_pattern_delay_rows, r27
0022f4 c076                      	rjmp sound_driver_calculate_delays
                                 sound_driver_channel4_fx_Gxx_invalid:
0022f5 cfb5                      	rjmp sound_driver_channel4_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel4_fx_Hxy: //hardware sweep up
0022f6 cfb4                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Ixy: //hardware sweep down
0022f7 cfb3                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Hxx: //FDS modulation depth
0022f8 cfb2                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Ixx: //FDS modulation speed
0022f9 cfb1                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Pxx: //fine pitch
0022fa cfb0                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Qxy: //note slide up
0022fb cfaf                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Rxy: //note slide down
0022fc cfae                      	rjmp sound_driver_channel4_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel4_fx_Sxx:
0022fd 15a2                      	cp r26, zero
0022fe f051                      	breq sound_driver_channel4_fx_Sxx_invalid
0022ff 91b0 281f                 	lds r27, song_speed
002301 17ab                      	cp r26, r27
002302 f430                      	brsh sound_driver_channel4_fx_Sxx_invalid
002303 93a0 2954                 	sts dpcm_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
002305 e0b1                      	ldi r27, 0x01
002306 93b0 294a                 	sts dpcm_pattern_delay_rows, r27
002308 c062                      	rjmp sound_driver_calculate_delays
                                 sound_driver_channel4_fx_Sxx_invalid:
002309 cfa1                      	rjmp sound_driver_channel4_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel4_fx_Vxx: //duty
00230a cfa0                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Wxx: //DPCM sample speed
00230b cf9f                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Xxx: //DPCM sample retrigger
00230c cf9e                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Yxx: //DPCM sample offset
00230d cf9d                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Zxx: //DPCM sample delta counter
00230e cf9c                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_note:
00230f 9631                      	adiw Z, 1 //point to the byte next to the flag
002310 90f4                      	lpm dpcm_period, Z //store the DPCM sample rate
002311 e3eb                      	ldi ZL, LOW(dpcm_samples) //point Z to dpcm_samples table
002312 e1f0                      	ldi ZH, HIGH(dpcm_samples)
002313 0feb                      	add ZL, r27 //point Z to offsetted sample
002314 1df2                      	adc ZH, zero
002315 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the samples's address
002316 1fff                      	rol ZH
002317 91a5                      	lpm r26, Z+ //r26:r27 now points to the sample
002318 91b4                      	lpm r27, Z
                                 
002319 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the sample's data
00231a 1fbb                      	rol r27
00231b 2fea                      	mov ZL, r26
00231c 2ffb                      	mov ZH, r27
00231d 91b4                      	lpm r27, Z //get sample length
00231e ef70                      	ldi dpcm_length_LOW, 0b11110000
00231f e08f                      	ldi dpcm_length_HIGH, 0b00001111
002320 95b2                      	swap r27
002321 237b                      	and dpcm_length_LOW, r27
002322 238b                      	and dpcm_length_HIGH, r27
                                 
002323 93e0 294e                 	sts dpcm_sample, ZL //store address to sample
002325 93f0 294f                 	sts dpcm_sample+1, ZH
002327 9230 2950                 	sts dpcm_sample_offset, one //start sample offset at 1 (0th byte was used for sample length)
002329 9220 2951                 	sts dpcm_sample_offset+1, zero
                                 
00232b d032                      	rcall sound_driver_channel4_increment_offset_twice
00232c cf7e                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_volume:
00232d d026                      	rcall sound_driver_channel4_increment_offset
00232e cf7c                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_delay:
00232f 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
002330 93b0 294a                 	sts dpcm_pattern_delay_rows, r27
002332 d021                      	rcall sound_driver_channel4_increment_offset
002333 c037                      	rjmp sound_driver_calculate_delays
                                 
                                 
                                 
                                 sound_driver_channel4_instrument_change:
002334 d029                      	rcall sound_driver_channel4_increment_offset_twice
002335 cf75                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_release:
002336 d01d                      	rcall sound_driver_channel4_increment_offset
002337 cf73                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_next_pattern:
002338 91e0 2819                 	lds ZL, song_frames
00233a 91f0 281a                 	lds ZH, song_frames+1
00233c 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
00233e 91b0 281c                 	lds r27, song_frame_offset+1
002340 93a0 281b                 	sts song_frame_offset, r26
002342 93b0 281c                 	sts song_frame_offset+1, r27
002344 9618                      	adiw r27:r26, 8 //offset for channel 4
002345 0fea                      	add ZL, r26
002346 1ffb                      	adc ZH, r27
                                 
002347 91a5                      	lpm r26, Z+ //load the address of the next pattern
002348 91b4                      	lpm r27, Z
002349 0faa                      	lsl r26
00234a 1fbb                      	rol r27
00234b 93a0 2948                 	sts dpcm_pattern, r26
00234d 93b0 2949                 	sts dpcm_pattern+1, r27
                                 
00234f 9220 294c                 	sts dpcm_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
002351 9220 294d                 	sts dpcm_pattern_offset+1, zero
002353 cf57                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_increment_offset:
002354 91e0 294c                 	lds ZL, dpcm_pattern_offset //current offset in the pattern for dpcm
002356 91f0 294d                 	lds ZH, dpcm_pattern_offset+1
002358 9631                      	adiw Z, 1
002359 93e0 294c                 	sts dpcm_pattern_offset, ZL
00235b 93f0 294d                 	sts dpcm_pattern_offset+1, ZH
00235d 9508                      	ret
                                 
                                 sound_driver_channel4_increment_offset_twice: //used for data that takes up 2 bytes worth of space
00235e 91e0 294c                 	lds ZL, dpcm_pattern_offset //current offset in the pattern for dpcm
002360 91f0 294d                 	lds ZH, dpcm_pattern_offset+1
002362 9632                      	adiw Z, 2 //increment the pointer twice
002363 93e0 294c                 	sts dpcm_pattern_offset, ZL
002365 93f0 294d                 	sts dpcm_pattern_offset+1, ZH
002367 9508                      	ret
                                 
                                 sound_driver_channel4_decrement_frame_delay:
002368 95ba                      	dec r27
002369 93b0 294b                 	sts dpcm_pattern_delay_frames, r27
                                 sound_driver_calculate_delays:
00236b 91f0 281f                 	lds r31, song_speed
00236d 2fef                      	mov r30, r31
00236e 50e1                      	subi r30, 1
                                 
                                 sound_driver_calculate_delays_pulse1:
00236f 91a0 2826                 	lds r26, pulse1_pattern_delay_frames
002371 11a2                      	cpse r26, zero
002372 c042                      	rjmp sound_driver_calculate_delays_pulse2
002373 c000                      	rjmp sound_driver_calculate_delays_pulse1_main
                                 
                                 sound_driver_calculate_delays_pulse1_main:
002374 2faf                      	mov r26, r31 //move the speed to r26
002375 91b0 2825                 	lds r27, pulse1_pattern_delay_rows //decrement the delay rows
002377 15b2                      	cp r27, zero
002378 f409                      	brne PC+2
002379 c03b                      	rjmp sound_driver_calculate_delays_pulse2
00237a 95ba                      	dec r27
00237b 93b0 2825                 	sts pulse1_pattern_delay_rows, r27
00237d 11b2                      	cpse r27, zero
00237e c034                      	rjmp sound_driver_calculate_delays_pulse1_store
00237f 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx:
002380 efbf                      	ldi r27, 0xFF
002381 91c0 2872                 	lds r28, pulse1_fx_Sxx_pre
002383 91d0 2873                 	lds r29, pulse1_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse1_Sxx_check_pre:
002385 17cb                      	cp r28, r27
002386 f009                      	breq sound_driver_calculate_delays_pulse1_Sxx_check_post
002387 c00d                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_pre
                                 sound_driver_calculate_delays_pulse1_Sxx_check_post:
002388 17db                      	cp r29, r27
002389 f009                      	breq sound_driver_calculate_delays_pulse1_Gxx
00238a c012                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx:
00238b 91c0 2860                 	lds r28, pulse1_fx_Gxx_pre
00238d 91d0 2861                 	lds r29, pulse1_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse1_Gxx_check_pre:
00238f 17cb                      	cp r28, r27
002390 f009                      	breq sound_driver_calculate_delays_pulse1_Gxx_check_post
002391 c012                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_pre
                                 sound_driver_calculate_delays_pulse1_Gxx_check_post:
002392 17db                      	cp r29, r27
002393 f0f9                      	breq sound_driver_calculate_delays_pulse1_store
002394 c017                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_pre:
002395 93b0 2872                 	sts pulse1_fx_Sxx_pre, r27
002397 93c0 2873                 	sts pulse1_fx_Sxx_post, r28
002399 95ca                      	dec r28
00239a 93c0 2826                 	sts pulse1_pattern_delay_frames, r28
00239c c018                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_post:
00239d 93b0 2873                 	sts pulse1_fx_Sxx_post, r27
00239f 1bed                      	sub r30, r29 //(song speed)-1-Sxx
0023a0 2fae                      	mov r26, r30
0023a1 2fef                      	mov r30, r31
0023a2 50e1                      	subi r30, 1
0023a3 c00f                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx_pre:
0023a4 93b0 2860                 	sts pulse1_fx_Gxx_pre, r27
0023a6 93c0 2861                 	sts pulse1_fx_Gxx_post, r28
0023a8 95ca                      	dec r28
0023a9 93c0 2826                 	sts pulse1_pattern_delay_frames, r28
0023ab c009                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse1_Gxx_post:
0023ac 93b0 2861                 	sts pulse1_fx_Gxx_post, r27
0023ae 1bed                      	sub r30, r29 //(song speed)-1-Gxx
0023af 2fae                      	mov r26, r30
0023b0 2fef                      	mov r30, r31
0023b1 50e1                      	subi r30, 1
0023b2 c000                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_store:
0023b3 93a0 2826                 	sts pulse1_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_pulse2:
0023b5 91a0 2877                 	lds r26, pulse2_pattern_delay_frames
0023b7 11a2                      	cpse r26, zero
0023b8 c042                      	rjmp sound_driver_calculate_delays_triangle
0023b9 c000                      	rjmp sound_driver_calculate_delays_pulse2_main
                                 
                                 sound_driver_calculate_delays_pulse2_main:
0023ba 2faf                      	mov r26, r31 //move the speed to r26
0023bb 91b0 2876                 	lds r27, pulse2_pattern_delay_rows //decrement the delay rows
0023bd 15b2                      	cp r27, zero
0023be f409                      	brne PC+2
0023bf c03b                      	rjmp sound_driver_calculate_delays_triangle
0023c0 95ba                      	dec r27
0023c1 93b0 2876                 	sts pulse2_pattern_delay_rows, r27
0023c3 11b2                      	cpse r27, zero
0023c4 c034                      	rjmp sound_driver_calculate_delays_pulse2_store
0023c5 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx:
0023c6 efbf                      	ldi r27, 0xFF
0023c7 91c0 28c3                 	lds r28, pulse2_fx_Sxx_pre
0023c9 91d0 28c4                 	lds r29, pulse2_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse2_Sxx_check_pre:
0023cb 17cb                      	cp r28, r27
0023cc f009                      	breq sound_driver_calculate_delays_pulse2_Sxx_check_post
0023cd c00d                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_pre
                                 sound_driver_calculate_delays_pulse2_Sxx_check_post:
0023ce 17db                      	cp r29, r27
0023cf f009                      	breq sound_driver_calculate_delays_pulse2_Gxx
0023d0 c012                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx:
0023d1 91c0 28b1                 	lds r28, pulse2_fx_Gxx_pre
0023d3 91d0 28b2                 	lds r29, pulse2_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse2_Gxx_check_pre:
0023d5 17cb                      	cp r28, r27
0023d6 f009                      	breq sound_driver_calculate_delays_pulse2_Gxx_check_post
0023d7 c012                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_pre
                                 sound_driver_calculate_delays_pulse2_Gxx_check_post:
0023d8 17db                      	cp r29, r27
0023d9 f0f9                      	breq sound_driver_calculate_delays_pulse2_store
0023da c017                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_pre:
0023db 93b0 28c3                 	sts pulse2_fx_Sxx_pre, r27
0023dd 93c0 28c4                 	sts pulse2_fx_Sxx_post, r28
0023df 95ca                      	dec r28
0023e0 93c0 2877                 	sts pulse2_pattern_delay_frames, r28
0023e2 cfd2                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_post:
0023e3 93b0 28c4                 	sts pulse2_fx_Sxx_post, r27
0023e5 1bed                      	sub r30, r29 //(song speed)-1-Sxx
0023e6 2fae                      	mov r26, r30
0023e7 2fef                      	mov r30, r31
0023e8 50e1                      	subi r30, 1
0023e9 c00f                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx_pre:
0023ea 93b0 28b1                 	sts pulse2_fx_Gxx_pre, r27
0023ec 93c0 28b2                 	sts pulse2_fx_Gxx_post, r28
0023ee 95ca                      	dec r28
0023ef 93c0 2877                 	sts pulse2_pattern_delay_frames, r28
0023f1 cfc3                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse2_Gxx_post:
0023f2 93b0 28b2                 	sts pulse2_fx_Gxx_post, r27 //(song speed)-1-Gxx
0023f4 1bed                      	sub r30, r29
0023f5 2fae                      	mov r26, r30
0023f6 2fef                      	mov r30, r31
0023f7 50e1                      	subi r30, 1
0023f8 c000                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_store:
0023f9 93a0 2877                 	sts pulse2_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_triangle:
0023fb 91a0 28c8                 	lds r26, triangle_pattern_delay_frames
0023fd 11a2                      	cpse r26, zero
0023fe c042                      	rjmp sound_driver_calculate_delays_noise
0023ff c000                      	rjmp sound_driver_calculate_delays_triangle_main
                                 
                                 sound_driver_calculate_delays_triangle_main:
002400 2faf                      	mov r26, r31 //move the speed to r26
002401 91b0 28c7                 	lds r27, triangle_pattern_delay_rows //decrement the delay rows
002403 15b2                      	cp r27, zero
002404 f409                      	brne PC+2
002405 c03b                      	rjmp sound_driver_calculate_delays_noise
002406 95ba                      	dec r27
002407 93b0 28c7                 	sts triangle_pattern_delay_rows, r27
002409 11b2                      	cpse r27, zero
00240a c034                      	rjmp sound_driver_calculate_delays_triangle_store
00240b 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_triangle_Sxx:
00240c efbf                      	ldi r27, 0xFF
00240d 91c0 290f                 	lds r28, triangle_fx_Sxx_pre
00240f 91d0 2910                 	lds r29, triangle_fx_Sxx_post
                                 sound_driver_calculate_delays_triangle_Sxx_check_pre:
002411 17cb                      	cp r28, r27
002412 f009                      	breq sound_driver_calculate_delays_triangle_Sxx_check_post
002413 c00d                      	rjmp sound_driver_calculate_delays_triangle_Sxx_pre
                                 sound_driver_calculate_delays_triangle_Sxx_check_post:
002414 17db                      	cp r29, r27
002415 f009                      	breq sound_driver_calculate_delays_triangle_Gxx
002416 c012                      	rjmp sound_driver_calculate_delays_triangle_Sxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Gxx:
002417 91c0 28fd                 	lds r28, triangle_fx_Gxx_pre
002419 91d0 28fe                 	lds r29, triangle_fx_Gxx_post
                                 sound_driver_calculate_delays_triangle_Gxx_check_pre:
00241b 17cb                      	cp r28, r27
00241c f009                      	breq sound_driver_calculate_delays_triangle_Gxx_check_post
00241d c012                      	rjmp sound_driver_calculate_delays_triangle_Gxx_pre
                                 sound_driver_calculate_delays_triangle_Gxx_check_post:
00241e 17db                      	cp r29, r27
00241f f0f9                      	breq sound_driver_calculate_delays_triangle_store
002420 c017                      	rjmp sound_driver_calculate_delays_triangle_Gxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_pre:
002421 93b0 290f                 	sts triangle_fx_Sxx_pre, r27
002423 93c0 2910                 	sts triangle_fx_Sxx_post, r28
002425 95ca                      	dec r28
002426 93c0 28c8                 	sts triangle_pattern_delay_frames, r28
002428 c018                      	rjmp sound_driver_calculate_delays_noise
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_post:
002429 93b0 2910                 	sts triangle_fx_Sxx_post, r27
00242b 1bed                      	sub r30, r29 //(song speed)-1-Sxx
00242c 2fae                      	mov r26, r30
00242d 2fef                      	mov r30, r31
00242e 50e1                      	subi r30, 1
00242f c00f                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_Gxx_pre:
002430 93b0 28fd                 	sts triangle_fx_Gxx_pre, r27
002432 93c0 28fe                 	sts triangle_fx_Gxx_post, r28
002434 95ca                      	dec r28
002435 93c0 28c8                 	sts triangle_pattern_delay_frames, r28
002437 c009                      	rjmp sound_driver_calculate_delays_noise
                                 	
                                 sound_driver_calculate_delays_triangle_Gxx_post:
002438 93b0 28fe                 	sts triangle_fx_Gxx_post, r27 //(song speed)-1-Gxx
00243a 1bed                      	sub r30, r29
00243b 2fae                      	mov r26, r30
00243c 2fef                      	mov r30, r31
00243d 50e1                      	subi r30, 1
00243e c000                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_store:
00243f 93a0 28c8                 	sts triangle_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_noise:
002441 91a0 2914                 	lds r26, noise_pattern_delay_frames
002443 11a2                      	cpse r26, zero
002444 c042                      	rjmp sound_driver_calculate_delays_dpcm
002445 c000                      	rjmp sound_driver_calculate_delays_noise_main
                                 
                                 sound_driver_calculate_delays_noise_main:
002446 2faf                      	mov r26, r31 //move the speed to r26
002447 91b0 2913                 	lds r27, noise_pattern_delay_rows //decrement the delay rows
002449 15b2                      	cp r27, zero
00244a f409                      	brne PC+2
00244b c03b                      	rjmp sound_driver_calculate_delays_dpcm
00244c 95ba                      	dec r27
00244d 93b0 2913                 	sts noise_pattern_delay_rows, r27
00244f 11b2                      	cpse r27, zero
002450 c034                      	rjmp sound_driver_calculate_delays_noise_store
002451 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_noise_Sxx:
002452 efbf                      	ldi r27, 0xFF
002453 91c0 2946                 	lds r28, noise_fx_Sxx_pre
002455 91d0 2947                 	lds r29, noise_fx_Sxx_post
                                 sound_driver_calculate_delays_noise_Sxx_check_pre:
002457 17cb                      	cp r28, r27
002458 f009                      	breq sound_driver_calculate_delays_noise_Sxx_check_post
002459 c00d                      	rjmp sound_driver_calculate_delays_noise_Sxx_pre
                                 sound_driver_calculate_delays_noise_Sxx_check_post:
00245a 17db                      	cp r29, r27
00245b f009                      	breq sound_driver_calculate_delays_noise_Gxx
00245c c012                      	rjmp sound_driver_calculate_delays_noise_Sxx_post
                                 
                                 sound_driver_calculate_delays_noise_Gxx:
00245d 91c0 2943                 	lds r28, noise_fx_Gxx_pre
00245f 91d0 2944                 	lds r29, noise_fx_Gxx_post
                                 sound_driver_calculate_delays_noise_Gxx_check_pre:
002461 17cb                      	cp r28, r27
002462 f009                      	breq sound_driver_calculate_delays_noise_Gxx_check_post
002463 c012                      	rjmp sound_driver_calculate_delays_noise_Gxx_pre
                                 sound_driver_calculate_delays_noise_Gxx_check_post:
002464 17db                      	cp r29, r27
002465 f0f9                      	breq sound_driver_calculate_delays_noise_store
002466 c017                      	rjmp sound_driver_calculate_delays_noise_Gxx_post
                                 
                                 sound_driver_calculate_delays_noise_Sxx_pre:
002467 93b0 2946                 	sts noise_fx_Sxx_pre, r27
002469 93c0 2947                 	sts noise_fx_Sxx_post, r28
00246b 95ca                      	dec r28
00246c 93c0 2914                 	sts noise_pattern_delay_frames, r28
00246e c018                      	rjmp sound_driver_calculate_delays_dpcm
                                 
                                 sound_driver_calculate_delays_noise_Sxx_post:
00246f 93b0 2947                 	sts noise_fx_Sxx_post, r27
002471 1bed                      	sub r30, r29 //(song speed)-1-Sxx
002472 2fae                      	mov r26, r30
002473 2fef                      	mov r30, r31
002474 50e1                      	subi r30, 1
002475 c00f                      	rjmp sound_driver_calculate_delays_noise_store
                                 
                                 sound_driver_calculate_delays_noise_Gxx_pre:
002476 93b0 2943                 	sts noise_fx_Gxx_pre, r27
002478 93c0 2944                 	sts noise_fx_Gxx_post, r28
00247a 95ca                      	dec r28
00247b 93c0 2914                 	sts noise_pattern_delay_frames, r28
00247d c009                      	rjmp sound_driver_calculate_delays_dpcm
                                 	
                                 sound_driver_calculate_delays_noise_Gxx_post:
00247e 93b0 2944                 	sts noise_fx_Gxx_post, r27 //(song speed)-1-Gxx
002480 1bed                      	sub r30, r29
002481 2fae                      	mov r26, r30
002482 2fef                      	mov r30, r31
002483 50e1                      	subi r30, 1
002484 c000                      	rjmp sound_driver_calculate_delays_noise_store
                                 
                                 sound_driver_calculate_delays_noise_store:
002485 93a0 2914                 	sts noise_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_dpcm:
002487 91a0 294b                 	lds r26, dpcm_pattern_delay_frames
002489 11a2                      	cpse r26, zero
00248a c042                      	rjmp sound_driver_instrument_fx_routine
00248b c000                      	rjmp sound_driver_calculate_delays_dpcm_main
                                 
                                 sound_driver_calculate_delays_dpcm_main:
00248c 2faf                      	mov r26, r31 //move the speed to r26
00248d 91b0 294a                 	lds r27, dpcm_pattern_delay_rows //decrement the delay rows
00248f 15b2                      	cp r27, zero
002490 f409                      	brne PC+2
002491 c03b                      	rjmp sound_driver_instrument_fx_routine
002492 95ba                      	dec r27
002493 93b0 294a                 	sts dpcm_pattern_delay_rows, r27
002495 11b2                      	cpse r27, zero
002496 c034                      	rjmp sound_driver_calculate_delays_dpcm_store
002497 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_dpcm_Sxx:
002498 efbf                      	ldi r27, 0xFF
002499 91c0 2954                 	lds r28, dpcm_fx_Sxx_pre
00249b 91d0 2955                 	lds r29, dpcm_fx_Sxx_post
                                 sound_driver_calculate_delays_dpcm_Sxx_check_pre:
00249d 17cb                      	cp r28, r27
00249e f009                      	breq sound_driver_calculate_delays_dpcm_Sxx_check_post
00249f c00d                      	rjmp sound_driver_calculate_delays_dpcm_Sxx_pre
                                 sound_driver_calculate_delays_dpcm_Sxx_check_post:
0024a0 17db                      	cp r29, r27
0024a1 f009                      	breq sound_driver_calculate_delays_dpcm_Gxx
0024a2 c012                      	rjmp sound_driver_calculate_delays_dpcm_Sxx_post
                                 
                                 sound_driver_calculate_delays_dpcm_Gxx:
0024a3 91c0 2952                 	lds r28, dpcm_fx_Gxx_pre
0024a5 91d0 2953                 	lds r29, dpcm_fx_Gxx_post
                                 sound_driver_calculate_delays_dpcm_Gxx_check_pre:
0024a7 17cb                      	cp r28, r27
0024a8 f009                      	breq sound_driver_calculate_delays_dpcm_Gxx_check_post
0024a9 c012                      	rjmp sound_driver_calculate_delays_dpcm_Gxx_pre
                                 sound_driver_calculate_delays_dpcm_Gxx_check_post:
0024aa 17db                      	cp r29, r27
0024ab f0f9                      	breq sound_driver_calculate_delays_dpcm_store
0024ac c017                      	rjmp sound_driver_calculate_delays_dpcm_Gxx_post
                                 
                                 sound_driver_calculate_delays_dpcm_Sxx_pre:
0024ad 93b0 2954                 	sts dpcm_fx_Sxx_pre, r27
0024af 93c0 2955                 	sts dpcm_fx_Sxx_post, r28
0024b1 95ca                      	dec r28
0024b2 93c0 294b                 	sts dpcm_pattern_delay_frames, r28
0024b4 c018                      	rjmp sound_driver_instrument_fx_routine
                                 
                                 sound_driver_calculate_delays_dpcm_Sxx_post:
0024b5 93b0 2955                 	sts dpcm_fx_Sxx_post, r27
0024b7 1bed                      	sub r30, r29 //(song speed)-1-Sxx
0024b8 2fae                      	mov r26, r30
0024b9 2fef                      	mov r30, r31
0024ba 50e1                      	subi r30, 1
0024bb c00f                      	rjmp sound_driver_calculate_delays_dpcm_store
                                 
                                 sound_driver_calculate_delays_dpcm_Gxx_pre:
0024bc 93b0 2952                 	sts dpcm_fx_Gxx_pre, r27
0024be 93c0 2953                 	sts dpcm_fx_Gxx_post, r28
0024c0 95ca                      	dec r28
0024c1 93c0 294b                 	sts dpcm_pattern_delay_frames, r28
0024c3 c009                      	rjmp sound_driver_instrument_fx_routine
                                 	
                                 sound_driver_calculate_delays_dpcm_Gxx_post:
0024c4 93b0 2953                 	sts dpcm_fx_Gxx_post, r27 //(song speed)-1-Gxx
0024c6 1bed                      	sub r30, r29
0024c7 2fae                      	mov r26, r30
0024c8 2fef                      	mov r30, r31
0024c9 50e1                      	subi r30, 1
0024ca c000                      	rjmp sound_driver_calculate_delays_dpcm_store
                                 
                                 sound_driver_calculate_delays_dpcm_store:
0024cb 93a0 294b                 	sts dpcm_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_instrument_fx_routine:
                                 sound_driver_instrument_routine_channel0_volume:
0024cd 91e0 2829                 	lds ZL, pulse1_volume_macro
0024cf 91f0 282a                 	lds ZH, pulse1_volume_macro+1
0024d1 9630                      	adiw Z, 0
0024d2 f1a1                      	breq sound_driver_instrument_routine_channel0_volume_default //if no volume macro is in use, use default multiplier of F
0024d3 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0024d4 1fff                      	rol ZH
0024d5 91a0 282b                 	lds r26, pulse1_volume_macro_offset
0024d7 0fea                      	add ZL, r26
0024d8 1df2                      	adc ZH, zero
                                 
0024d9 91b0 282d                 	lds r27, pulse1_volume_macro_release
0024db 17ba                      	cp r27, r26
0024dc f429                      	brne sound_driver_instrument_routine_channel0_volume_increment //if the current offset is not equal to the release index, increment the offset
0024dd 91a0 282c                 	lds r26, pulse1_volume_macro_loop
0024df 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0024e0 f010                      	brlo sound_driver_instrument_routine_channel0_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0024e1 c003                      	rjmp sound_driver_instrument_routine_channel0_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_volume_increment:
0024e2 95a3                      	inc r26 //increment the macro offset
0024e3 93a0 282b                 	sts pulse1_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_volume_read:
0024e5 91b4                      	lpm r27, Z //load volume data into r27
0024e6 3fbf                      	cpi r27, 0xFF //check for macro end flag
0024e7 f469                      	brne sound_driver_instrument_routine_channel0_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_release:
0024e8 91b0 282d                 	lds r27, pulse1_volume_macro_release
0024ea 3fbf                      	cpi r27, 0xFF
0024eb f429                      	brne sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_loop:
0024ec 91b0 282c                 	lds r27, pulse1_volume_macro_loop //load the loop index
0024ee 93b0 282b                 	sts pulse1_volume_macro_offset, r27 //store the loop index into the offset
0024f0 cfdc                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index:
0024f1 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
0024f2 93a0 282b                 	sts pulse1_volume_macro_offset, r26
0024f4 cfd8                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_calculate:
0024f5 e0e4                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
0024f6 e6f2                      	ldi ZH, HIGH(volumes << 1)
0024f7 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
0024f8 0feb                      	add ZL, r27 //add offset to the table
0024f9 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel0_volume_load:
0024fa 91b0 2800                 	lds r27, pulse1_param //load main volume
0024fc 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
0024fd 91a0 285e                 	lds r26, pulse1_fx_7xy_value
0024ff 30a0                      	cpi r26, 0x00
002500 f481                      	brne sound_driver_instrument_routine_channel0_volume_load_7xy
                                 
002501 0feb                      	add ZL, r27 //offset the volume table by the main volume
002502 1df2                      	adc ZH, zero
002503 91b4                      	lpm r27, Z
002504 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
002506 c023                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default:
002507 91b0 2800                 	lds r27, pulse1_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
002509 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
00250a 91a0 285e                 	lds r26, pulse1_fx_7xy_value
00250c 30a0                      	cpi r26, 0x00
00250d f499                      	brne sound_driver_instrument_routine_channel0_volume_default_7xy
00250e 93b0 2806                 	sts pulse1_output_volume, r27
002510 c019                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy:
002511 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002512 f038                      	brcs sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
002513 f031                      	breq sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
                                 
002514 0feb                      	add ZL, r27 //offset the volume table by the main volume
002515 1df2                      	adc ZH, zero
002516 91b4                      	lpm r27, Z
002517 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
002519 c010                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy_overflow:
00251a e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
00251b 0feb                      	add ZL, r27 //offset the volume table by the main volume
00251c 1df2                      	adc ZH, zero
00251d 91b4                      	lpm r27, Z
00251e 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
002520 c009                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default_7xy:
002521 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002522 f020                      	brcs sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
002523 f019                      	breq sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
002524 93b0 2806                 	sts pulse1_output_volume, r27
002526 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel0_volume_default_7xy_overflow:
002527 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002528 93b0 2806                 	sts pulse1_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
00252a 91e0 282e                 	lds ZL, pulse1_arpeggio_macro
00252c 91f0 282f                 	lds ZH, pulse1_arpeggio_macro+1
00252e 9630                      	adiw Z, 0
00252f f1d9                      	breq sound_driver_instrument_routine_channel0_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002530 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002531 1fff                      	rol ZH
002532 91a0 2830                 	lds r26, pulse1_arpeggio_macro_offset
002534 0fea                      	add ZL, r26
002535 1df2                      	adc ZH, zero
                                 
002536 91b0 2832                 	lds r27, pulse1_arpeggio_macro_release
002538 17ba                      	cp r27, r26
002539 f429                      	brne sound_driver_instrument_routine_channel0_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
00253a 91a0 2831                 	lds r26, pulse1_arpeggio_macro_loop
00253c 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00253d f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
00253e c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_increment:
00253f 95a3                      	inc r26 //increment the macro offset
002540 93a0 2830                 	sts pulse1_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_read:
002542 91b4                      	lpm r27, Z //load arpeggio data into r27
002543 38b0                      	cpi r27, 0x80 //check for macro end flag
002544 f009                      	breq sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag
002545 c041                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_check_mode:
002546 50a1                      	subi r26, 1 //keep the offset at the end flag
002547 93a0 2830                 	sts pulse1_arpeggio_macro_offset, r26
002549 91b0 2833                 	lds r27, pulse1_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
00254b 30b1                      	cpi r27, 0x01
00254c f048                      	brlo sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_release:
00254d 91b0 2832                 	lds r27, pulse1_arpeggio_macro_release
00254f 3fbf                      	cpi r27, 0xFF
002550 f4d1                      	brne sound_driver_instrument_routine_channel0_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_loop:
002551 91b0 2831                 	lds r27, pulse1_arpeggio_macro_loop
002553 3fbf                      	cpi r27, 0xFF
002554 f499                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002555 c015                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute:
002556 91b0 2832                 	lds r27, pulse1_arpeggio_macro_release
002558 3fbf                      	cpi r27, 0xFF
002559 f421                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_check_loop:
00255a 91b0 2831                 	lds r27, pulse1_arpeggio_macro_loop //load the loop index
00255c 3fbf                      	cpi r27, 0xFF //check if loop flag exists
00255d f451                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop:
00255e 91c0 2846                 	lds r28, pulse1_fx_0xy_sequence //check for 0xy effect
002560 91d0 2847                 	lds r29, pulse1_fx_0xy_sequence+1
002562 9620                      	adiw r29:r28, 0
002563 f469                      	brne sound_driver_instrument_routine_channel0_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002564 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002565 93a0 2830                 	sts pulse1_arpeggio_macro_offset, r26 //store the last valid index into the offset
002567 cfc2                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload:
002568 93b0 2830                 	sts pulse1_arpeggio_macro_offset, r27 //store the loop index into the offset
00256a cfbf                      	rjmp sound_driver_instrument_routine_channel0_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_default:
00256b 91c0 2846                 	lds r28, pulse1_fx_0xy_sequence //load 0xy effect
00256d 91d0 2847                 	lds r29, pulse1_fx_0xy_sequence+1
00256f 9620                      	adiw r29:r28, 0 //check for 0xy effect
002570 f099                      	breq sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel0_arpeggio_default_0xy:
002571 95d6                      	lsr r29
002572 95c7                      	ror r28
002573 95d7                      	ror r29
002574 95c7                      	ror r28
002575 95d7                      	ror r29
002576 95c7                      	ror r28
002577 95d7                      	ror r29
002578 95c7                      	ror r28
002579 95d7                      	ror r29
00257a 95d2                      	swap r29
                                 
00257b 93c0 2846                 	sts pulse1_fx_0xy_sequence, r28 //store the rolled sequence
00257d 93d0 2847                 	sts pulse1_fx_0xy_sequence+1, r29
00257f 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002580 91a0 2807                 	lds r26, pulse1_note //load the current note index
002582 0fac                      	add r26, r28 //add the note offset
002583 c02e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002584 91a0 2807                 	lds r26, pulse1_note //load the current note index
002586 c02b                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process:
002587 9220 2834                 	sts pulse1_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002589 9220 2835                 	sts pulse1_total_pitch_offset+1, zero
00258b 9220 283b                 	sts pulse1_total_hi_pitch_offset, zero
00258d 91a0 2833                 	lds r26, pulse1_arpeggio_macro_mode
00258f 30a1                      	cpi r26, 0x01 //absolute mode
002590 f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_absolute
002591 f069                      	breq sound_driver_instrument_routine_channel0_arpeggio_process_fixed
002592 c00e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute:
002593 91a0 2807                 	lds r26, pulse1_note //load the current note index
002595 0fab                      	add r26, r27 //offset the note with the arpeggio data
002596 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002597 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_add:
002598 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002599 f0c0                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
00259a e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
00259b c016                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract:
00259c fda7                      	sbrc r26, 7 //check if result is negative
00259d e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
00259e c013                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_fixed:
00259f 2fab                      	mov r26, r27 //move the arpeggio data into r26
0025a0 c011                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative:
0025a1 91a0 2807                 	lds r26, pulse1_note //load the current note index
0025a3 0fab                      	add r26, r27 //offset the note with the arpeggio data
0025a4 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0025a5 c008                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_add:
0025a6 93a0 2807                 	sts pulse1_note, r26 //NOTE: relative mode modifies the original note index
0025a8 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0025a9 f040                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
0025aa e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0025ab 93a0 2807                 	sts pulse1_note, r26
0025ad c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract:
0025ae fda7                      	sbrc r26, 7 //check if result is negative
0025af e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0025b0 93a0 2807                 	sts pulse1_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_load:
0025b2 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0025b3 e0f0                      	ldi ZH, HIGH(note_table << 1)
0025b4 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
0025b5 0fea                      	add ZL, r26 //add offset
0025b6 1df2                      	adc ZH, zero
0025b7 91a5                      	lpm r26, Z+ //load bytes
0025b8 91b4                      	lpm r27, Z
0025b9 93a0 0a8c                 	sts TCB0_CCMPL, r26 //load the LOW bits for timer
0025bb 93b0 0a8d                 	sts TCB0_CCMPH, r27 //load the HIGH bits for timer
0025bd 93a0 2852                 	sts pulse1_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
0025bf 93b0 2853                 	sts pulse1_fx_3xx_target+1, r27
0025c1 c000                      	rjmp sound_driver_instrument_routine_channel0_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch:
0025c2 91e0 2836                 	lds ZL, pulse1_pitch_macro
0025c4 91f0 2837                 	lds ZH, pulse1_pitch_macro+1
0025c6 9630                      	adiw Z, 0
0025c7 f409                      	brne sound_driver_instrument_routine_channel0_pitch_continue
0025c8 c023                      	rjmp sound_driver_instrument_routine_channel0_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel0_pitch_continue:
0025c9 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0025ca 1fff                      	rol ZH
0025cb 91a0 2838                 	lds r26, pulse1_pitch_macro_offset
0025cd 0fea                      	add ZL, r26
0025ce 1df2                      	adc ZH, zero
                                 
0025cf 91b0 283a                 	lds r27, pulse1_pitch_macro_release
0025d1 17ba                      	cp r27, r26
0025d2 f429                      	brne sound_driver_instrument_routine_channel0_pitch_increment //if the current offset is not equal to the release index, increment the offset
0025d3 91a0 2839                 	lds r26, pulse1_pitch_macro_loop
0025d5 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0025d6 f010                      	brlo sound_driver_instrument_routine_channel0_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0025d7 c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_pitch_increment:
0025d8 95a3                      	inc r26 //increment the macro offset
0025d9 93a0 2838                 	sts pulse1_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_pitch_read:
0025db 91b4                      	lpm r27, Z //load pitch data into r27
0025dc 38b0                      	cpi r27, 0x80 //check for macro end flag
0025dd f479                      	brne sound_driver_instrument_routine_channel0_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_release:
0025de 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0025df 93a0 2838                 	sts pulse1_pitch_macro_offset, r26
0025e1 91b0 283a                 	lds r27, pulse1_pitch_macro_release
0025e3 3fbf                      	cpi r27, 0xFF
0025e4 f439                      	brne sound_driver_instrument_routine_channel0_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_loop:
0025e5 91b0 2839                 	lds r27, pulse1_pitch_macro_loop //load the loop index
0025e7 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0025e8 f019                      	breq sound_driver_instrument_routine_channel0_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
0025e9 93b0 2838                 	sts pulse1_pitch_macro_offset, r27 //store the loop index into the offset
0025eb cfd6                      	rjmp sound_driver_instrument_routine_channel0_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_default:
0025ec e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel0_pitch_calculate:
0025ed 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0025ee 937f                      	push r23
0025ef 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
0025f0 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0025f1 0367                      	mulsu r22, r23
0025f2 917f                      	pop r23
0025f3 916f                      	pop r22
                                 
0025f4 9416                      	lsr r1 //shift out the fractional bits
0025f5 9407                      	ror r0
0025f6 9416                      	lsr r1
0025f7 9407                      	ror r0
0025f8 9416                      	lsr r1
0025f9 9407                      	ror r0
0025fa 9416                      	lsr r1
0025fb 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_check_negative:
0025fc fe13                      	sbrs r1, 3 //check if result was a negative number
0025fd c007                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_negative:
0025fe efc0                      	ldi r28, 0xF0
0025ff 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_check_divisible_8:
002600 70b7                      	andi r27, 0b00000111
002601 f019                      	breq sound_driver_instrument_routine_channel0_pitch_calculate_offset
                                 
002602 e0b1                      	ldi r27, 0x01
002603 0e0b                      	add r0, r27
002604 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_offset:
002605 91a0 2834                 	lds r26, pulse1_total_pitch_offset
002607 91b0 2835                 	lds r27, pulse1_total_pitch_offset+1
002609 0e0a                      	add r0, r26
00260a 1e1b                      	adc r1, r27
00260b 9200 2834                 	sts pulse1_total_pitch_offset, r0
00260d 9210 2835                 	sts pulse1_total_pitch_offset+1, r1
00260f 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
002611 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
002613 0da0                      	add r26, r0 //offset the timer values
002614 1db1                      	adc r27, r1
                                 	
002615 91c0 284a                 	lds r28, pulse1_fx_1xx_total
002617 91d0 284b                 	lds r29, pulse1_fx_1xx_total+1
002619 1bac                      	sub r26, r28
00261a 0bbd                      	sbc r27, r29
00261b 91c0 284e                 	lds r28, pulse1_fx_2xx_total
00261d 91d0 284f                 	lds r29, pulse1_fx_2xx_total+1
00261f 0fac                      	add r26, r28
002620 1fbd                      	adc r27, r29
002621 91c0 2862                 	lds r28, pulse1_fx_Pxx_total
002623 91d0 2863                 	lds r29, pulse1_fx_Pxx_total+1
002625 0fac                      	add r26, r28
002626 1fbd                      	adc r27, r29
002627 91c0 2869                 	lds r28, pulse1_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
002629 91d0 286a                 	lds r29, pulse1_fx_Qxy_total_offset+1
00262b 1bac                      	sub r26, r28
00262c 0bbd                      	sbc r27, r29
00262d 91c0 2870                 	lds r28, pulse1_fx_Rxy_total_offset
00262f 91d0 2871                 	lds r29, pulse1_fx_Rxy_total_offset+1
002631 0fac                      	add r26, r28
002632 1fbd                      	adc r27, r29
                                 
002633 e5c9                      	ldi r28, 0x59
002634 e0d0                      	ldi r29, 0x00
002635 17ac                      	cp r26, r28
002636 07bd                      	cpc r27, r29
002637 f030                      	brlo sound_driver_instrument_routine_channel0_pitch_min
                                 
002638 e5ca                      	ldi r28, 0x5A
002639 e5d9                      	ldi r29, 0x59
00263a 17ac                      	cp r26, r28
00263b 07bd                      	cpc r27, r29
00263c f420                      	brsh sound_driver_instrument_routine_channel0_pitch_max
00263d c006                      	rjmp sound_driver_instrument_routine_channel0_pitch_store
                                 
                                 sound_driver_instrument_routine_channel0_pitch_min:
00263e e5c9                      	ldi r28, 0x59
00263f e0d0                      	ldi r29, 0x00
002640 c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_store
                                 
                                 sound_driver_instrument_routine_channel0_pitch_max:
002641 e5c9                      	ldi r28, 0x59
002642 e5d9                      	ldi r29, 0x59
002643 c000                      	rjmp sound_driver_instrument_routine_channel0_pitch_store
                                 
                                 sound_driver_instrument_routine_channel0_pitch_store:
002644 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
002646 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel0_hi_pitch:
002648 91e0 283c                 	lds ZL, pulse1_hi_pitch_macro
00264a 91f0 283d                 	lds ZH, pulse1_hi_pitch_macro+1
00264c 9630                      	adiw Z, 0
00264d f409                      	brne sound_driver_instrument_routine_channel0_hi_pitch_continue
00264e c03c                      	rjmp sound_driver_instrument_routine_channel0_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel0_hi_pitch_continue:
00264f 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002650 1fff                      	rol ZH
002651 91a0 283e                 	lds r26, pulse1_hi_pitch_macro_offset
002653 0fea                      	add ZL, r26
002654 1df2                      	adc ZH, zero
                                 
002655 91b0 2840                 	lds r27, pulse1_hi_pitch_macro_release
002657 17ba                      	cp r27, r26
002658 f429                      	brne sound_driver_instrument_routine_channel0_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002659 91a0 283f                 	lds r26, pulse1_hi_pitch_macro_loop
00265b 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00265c f010                      	brlo sound_driver_instrument_routine_channel0_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00265d c003                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_increment:
00265e 95a3                      	inc r26 //increment the macro offset
00265f 93a0 283e                 	sts pulse1_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_hi_pitch_read:
002661 91b4                      	lpm r27, Z //load hi pitch data into r27
002662 38b0                      	cpi r27, 0x80 //check for macro end flag
002663 f489                      	brne sound_driver_instrument_routine_channel0_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_release:
002664 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002665 93a0 283e                 	sts pulse1_hi_pitch_macro_offset, r26
002667 91b0 2840                 	lds r27, pulse1_hi_pitch_macro_release
002669 3fbf                      	cpi r27, 0xFF
00266a f439                      	brne sound_driver_instrument_routine_channel0_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_loop:
00266b 91b0 283f                 	lds r27, pulse1_hi_pitch_macro_loop //load the loop index
00266d 3fbf                      	cpi r27, 0xFF //check if there is a loop index
00266e f019                      	breq sound_driver_instrument_routine_channel0_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
00266f 93b0 283e                 	sts pulse1_hi_pitch_macro_offset, r27 //store the loop index into the offset
002671 cfd6                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_default:
002672 91b0 283b                 	lds r27, pulse1_total_hi_pitch_offset
002674 c005                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate:
002675 91a0 283b                 	lds r26, pulse1_total_hi_pitch_offset //load the total hi pitch offset to change
002677 0fba                      	add r27, r26
002678 93b0 283b                 	sts pulse1_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply:
00267a 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00267b 937f                      	push r23
00267c 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
00267d eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00267e 0367                      	mulsu r22, r23
00267f 917f                      	pop r23
002680 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_offset:
002681 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
002683 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
002685 0da0                      	add r26, r0 //offset the timer values
002686 1db1                      	adc r27, r1
002687 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
002689 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel0_duty:
00268b 91e0 2841                 	lds ZL, pulse1_duty_macro
00268d 91f0 2842                 	lds ZH, pulse1_duty_macro+1
00268f 9630                      	adiw Z, 0
002690 f1b1                      	breq sound_driver_channel0_fx_routines //if no duty macro is in use, go to the next routine
002691 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002692 1fff                      	rol ZH
002693 91a0 2843                 	lds r26, pulse1_duty_macro_offset
002695 0fea                      	add ZL, r26
002696 1df2                      	adc ZH, zero
                                 
002697 91b0 2845                 	lds r27, pulse1_duty_macro_release
002699 17ba                      	cp r27, r26
00269a f429                      	brne sound_driver_instrument_routine_channel0_duty_increment //if the current offset is not equal to the release index, increment the offset
00269b 91a0 2844                 	lds r26, pulse1_duty_macro_loop
00269d 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00269e f010                      	brlo sound_driver_instrument_routine_channel0_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00269f c027                      	rjmp sound_driver_channel0_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel0_duty_increment:
0026a0 95a3                      	inc r26 //increment the macro offset
0026a1 93a0 2843                 	sts pulse1_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_duty_read:
0026a3 91b4                      	lpm r27, Z //load pitch data into r27
0026a4 3fbf                      	cpi r27, 0xFF //check for macro end flag
0026a5 f471                      	brne sound_driver_instrument_routine_channel0_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_release:
0026a6 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0026a7 93a0 2843                 	sts pulse1_duty_macro_offset, r26
0026a9 91b0 2845                 	lds r27, pulse1_duty_macro_release
0026ab 3fbf                      	cpi r27, 0xFF
0026ac f4d1                      	brne sound_driver_channel0_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_loop:
0026ad 91b0 2844                 	lds r27, pulse1_duty_macro_loop //load the loop index
0026af 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0026b0 f0b1                      	breq sound_driver_channel0_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
0026b1 93b0 2843                 	sts pulse1_duty_macro_offset, r27 //store the loop index into the offset
0026b3 cfd7                      	rjmp sound_driver_instrument_routine_channel0_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_load:
0026b4 efec                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
0026b5 e6f0                      	ldi ZH, HIGH(sequences << 1)
0026b6 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
0026b7 1df2                      	adc ZH, zero
                                 
0026b8 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
0026b9 95b7                      	ror r27
0026ba 95b7                      	ror r27
0026bb 91a0 2800                 	lds r26, pulse1_param //load r26 with pulse1_param (register $4000)
0026bd 2fca                      	mov r28, r26 //store a copy of pulse1_param into r28
0026be 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
0026bf 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
0026c0 c001                      	rjmp sound_driver_instrument_routine_channel0_duty_load_store
0026c1 c005                      	rjmp sound_driver_channel0_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel0_duty_load_store:
0026c2 9074                      	lpm pulse1_sequence, Z //store the sequence
                                 
0026c3 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
0026c4 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
0026c5 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_routines:
                                 sound_driver_channel0_fx_1xx_routine:
0026c7 91e0 2848                 	lds ZL, pulse1_fx_1xx
0026c9 91f0 2849                 	lds ZH, pulse1_fx_1xx+1
0026cb 9630                      	adiw Z, 0
0026cc f051                      	breq sound_driver_channel0_fx_2xx_routine
                                 
0026cd 91a0 284a                 	lds r26, pulse1_fx_1xx_total //load the rate to change the pitch by
0026cf 91b0 284b                 	lds r27, pulse1_fx_1xx_total+1
0026d1 0fae                      	add r26, ZL //increase the total offset by the rate
0026d2 1fbf                      	adc r27, ZH
0026d3 93a0 284a                 	sts pulse1_fx_1xx_total, r26
0026d5 93b0 284b                 	sts pulse1_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_2xx_routine:
0026d7 91e0 284c                 	lds ZL, pulse1_fx_2xx
0026d9 91f0 284d                 	lds ZH, pulse1_fx_2xx+1
0026db 9630                      	adiw Z, 0
0026dc f051                      	breq sound_driver_channel0_fx_3xx_routine
                                 
0026dd 91a0 284e                 	lds r26, pulse1_fx_2xx_total //load the rate to change the pitch by
0026df 91b0 284f                 	lds r27, pulse1_fx_2xx_total+1
0026e1 0fae                      	add r26, ZL //increase the total offset by the rate
0026e2 1fbf                      	adc r27, ZH
0026e3 93a0 284e                 	sts pulse1_fx_2xx_total, r26
0026e5 93b0 284f                 	sts pulse1_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_3xx_routine:
0026e7 91e0 2854                 	lds ZL, pulse1_fx_3xx_speed
0026e9 91f0 2855                 	lds ZH, pulse1_fx_3xx_speed+1
0026eb 9630                      	adiw Z, 0
0026ec f409                      	brne sound_driver_channel0_fx_3xx_routine_check_start
0026ed c048                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_check_start:
0026ee 91a0 2850                 	lds r26, pulse1_fx_3xx_start
0026f0 91b0 2851                 	lds r27, pulse1_fx_3xx_start+1
0026f2 9610                      	adiw r26:r27, 0
0026f3 f409                      	brne sound_driver_channel0_fx_3xx_routine_main
0026f4 c041                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_main:
0026f5 91c0 2852                 	lds r28, pulse1_fx_3xx_target
0026f7 91d0 2853                 	lds r29, pulse1_fx_3xx_target+1
                                 
0026f9 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
0026fa 07bd                      	cpc r27, r29
0026fb f011                      	breq sound_driver_channel0_fx_3xx_routine_disable
0026fc f030                      	brlo sound_driver_channel0_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
0026fd c01f                      	rjmp sound_driver_channel0_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel0_fx_3xx_routine_disable:
0026fe 9220 2850                 	sts pulse1_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002700 9220 2851                 	sts pulse1_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002702 c033                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_subtract:
002703 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002704 0bdb                      	sbc r29, r27
002705 91a0 2856                 	lds r26, pulse1_fx_3xx_total_offset
002707 91b0 2857                 	lds r27, pulse1_fx_3xx_total_offset+1
                                 
002709 0fae                      	add r26, ZL //add the speed to the total offset
00270a 1fbf                      	adc r27, ZH
00270b 1bca                      	sub r28, r26 //invert the total difference with the total offset
00270c 0bdb                      	sbc r29, r27
00270d f380                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
00270e 93a0 2856                 	sts pulse1_fx_3xx_total_offset, r26 //store the new total offset
002710 93b0 2857                 	sts pulse1_fx_3xx_total_offset+1, r27
                                 
002712 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the current timer period
002714 91b0 0a8d                 	lds r27, TCB0_CCMPH
002716 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002717 0bbd                      	sbc r27, r29
002718 93a0 0a8c                 	sts TCB0_CCMPL, r26
00271a 93b0 0a8d                 	sts TCB0_CCMPH, r27
00271c c019                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_add:
00271d 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
00271e 0bbd                      	sbc r27, r29
00271f 91c0 2856                 	lds r28, pulse1_fx_3xx_total_offset
002721 91d0 2857                 	lds r29, pulse1_fx_3xx_total_offset+1
                                 
002723 0fce                      	add r28, ZL //add the speed to the total offset
002724 1fdf                      	adc r29, ZH
002725 1bac                      	sub r26, r28 //invert the total difference with the total offset
002726 0bbd                      	sbc r27, r29
002727 f2b0                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002728 93c0 2856                 	sts pulse1_fx_3xx_total_offset, r28 //store the new total offset
00272a 93d0 2857                 	sts pulse1_fx_3xx_total_offset+1, r29
                                 
00272c 91c0 0a8c                 	lds r28, TCB0_CCMPL //load the current timer period
00272e 91d0 0a8d                 	lds r29, TCB0_CCMPH
002730 0fca                      	add r28, r26 //offset the current timer period with the total offset
002731 1fdb                      	adc r29, r27
002732 93c0 0a8c                 	sts TCB0_CCMPL, r28
002734 93d0 0a8d                 	sts TCB0_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel0_fx_4xy_routine:
002736 91a0 2858                 	lds r26, pulse1_fx_4xy_speed
002738 15a2                      	cp r26, zero
002739 f409                      	brne sound_driver_channel0_fx_4xy_routine_continue
00273a c05c                      	rjmp sound_driver_channel0_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel0_fx_4xy_routine_continue:
00273b 91b0 2859                 	lds r27, pulse1_fx_4xy_depth
00273d 91c0 285a                 	lds r28, pulse1_fx_4xy_phase
00273f 0fca                      	add r28, r26 //increase the phase by the speed
002740 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002741 f008                      	brlo sound_driver_channel0_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002742 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase:
002743 93c0 285a                 	sts pulse1_fx_4xy_phase, r28 //store the new phase
002745 31c0                      	cpi r28, 16
002746 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_0
002747 32c0                      	cpi r28, 32
002748 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_1
002749 33c0                      	cpi r28, 48
00274a f030                      	brlo sound_driver_channel0_fx_4xy_routine_phase_2
00274b c007                      	rjmp sound_driver_channel0_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_0:
00274c 70cf                      	andi r28, 0x0F //mask for values 0-15
00274d c029                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_1:
00274e 6fc0                      	ori r28, 0xF0
00274f 95c0                      	com r28 //invert values 0-15
002750 c026                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_2:
002751 70cf                      	andi r28, 0x0F //mask for values 0-15
002752 c003                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_3:
002753 6fc0                      	ori r28, 0xF0
002754 95c0                      	com r28 //invert values 0-15
002755 c000                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_add:
002756 95b2                      	swap r27 //multiply depth by 16
002757 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002758 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002759 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00275a 0fec                      	add ZL, r28 //offset the table by the depth+phase
00275b 1df2                      	adc ZH, zero
00275c 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
00275d 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00275e 937f                      	push r23
00275f 2f6c                      	mov r22, r28 //store the vibrato value into r22
002760 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002761 9f67                      	mul r22, r23
002762 917f                      	pop r23
002763 916f                      	pop r22
                                 
002764 9416                      	lsr r1 //shift out the fractional bits
002765 9407                      	ror r0
002766 9416                      	lsr r1
002767 9407                      	ror r0
002768 9416                      	lsr r1
002769 9407                      	ror r0
00276a 9416                      	lsr r1
00276b 9407                      	ror r0
                                 	
00276c 91a0 0a8c                 	lds r26, TCB0_CCMPL
00276e 91b0 0a8d                 	lds r27, TCB0_CCMPH
002770 0da0                      	add r26, r0
002771 1db1                      	adc r27, r1
002772 93a0 0a8c                 	sts TCB0_CCMPL, r26
002774 93b0 0a8d                 	sts TCB0_CCMPH, r27
002776 c020                      	rjmp sound_driver_channel0_fx_7xy_routine
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_subtract:
002777 95b2                      	swap r27 //multiply depth by 16
002778 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002779 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00277a e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00277b 0fec                      	add ZL, r28 //offset the table by the depth+phase
00277c 1df2                      	adc ZH, zero
00277d 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
00277e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00277f 937f                      	push r23
002780 2f6c                      	mov r22, r28 //store the vibrato value into r22
002781 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002782 9f67                      	mul r22, r23
002783 917f                      	pop r23
002784 916f                      	pop r22
                                 
002785 9416                      	lsr r1 //shift out the fractional bits
002786 9407                      	ror r0
002787 9416                      	lsr r1
002788 9407                      	ror r0
002789 9416                      	lsr r1
00278a 9407                      	ror r0
00278b 9416                      	lsr r1
00278c 9407                      	ror r0
                                 
00278d 91a0 0a8c                 	lds r26, TCB0_CCMPL
00278f 91b0 0a8d                 	lds r27, TCB0_CCMPH
002791 19a0                      	sub r26, r0
002792 09b1                      	sbc r27, r1
002793 93a0 0a8c                 	sts TCB0_CCMPL, r26
002795 93b0 0a8d                 	sts TCB0_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_7xy_routine:
002797 91a0 285b                 	lds r26, pulse1_fx_7xy_speed
002799 15a2                      	cp r26, zero
00279a f0e9                      	breq sound_driver_channel0_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
00279b 91b0 285c                 	lds r27, pulse1_fx_7xy_depth
00279d 91c0 285d                 	lds r28, pulse1_fx_7xy_phase
00279f 0fca                      	add r28, r26 //increase the phase by the speed
0027a0 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
0027a1 f008                      	brlo sound_driver_channel0_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
0027a2 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase:
0027a3 93c0 285d                 	sts pulse1_fx_7xy_phase, r28 //store the new phase
0027a5 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
0027a6 ffc4                      	sbrs r28, 4
0027a7 c001                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_0
0027a8 c002                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel0_fx_7xy_routine_phase_0:
0027a9 70cf                      	andi r28, 0x0F //mask for values 0-15
0027aa c003                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase_1:
0027ab 6fc0                      	ori r28, 0xF0
0027ac 95c0                      	com r28 //invert values 0-15
0027ad c000                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_load:
0027ae 95b2                      	swap r27 //multiply depth by 16
0027af 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0027b0 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0027b1 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0027b2 0fec                      	add ZL, r28 //offset the table by the depth+phase
0027b3 1df2                      	adc ZH, zero
0027b4 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
0027b5 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
0027b6 93c0 285e                 	sts pulse1_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Axy_routine:
0027b8 91b0 285f                 	lds r27, pulse1_fx_Axy
0027ba 15b2                      	cp r27, zero
0027bb f0e9                      	breq sound_driver_channel0_fx_Qxy_routine //0 means that the effect is not in use
                                 	
0027bc 91a0 2805                 	lds r26, pulse1_fractional_volume //load fractional volume representation of the channel
0027be 91c0 2800                 	lds r28, pulse1_param //load the integer volume representation of the channel
0027c0 2fda                      	mov r29, r26 //copy fractional volume into r29
0027c1 2fec                      	mov r30, r28 //copy the pulse1_param into r30
0027c2 95e2                      	swap r30
0027c3 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
0027c4 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
0027c5 17ed                      	cp r30, r29 //compare the fractional and integer volumes
0027c6 f009                      	breq sound_driver_channel0_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel0_fx_Axy_routine_reload:
0027c7 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate:
0027c8 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
0027c9 c004                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_addition:
0027ca 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0027cb f428                      	brcc sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0027cc efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
0027cd c003                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_subtraction:
0027ce 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0027cf f008                      	brcs sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0027d0 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_store:
0027d1 93a0 2805                 	sts pulse1_fractional_volume, r26 //store the new fractional volume
0027d3 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
0027d4 95a2                      	swap r26
0027d5 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
0027d6 2bca                      	or r28, r26 //store the new volume back into pulse1_param
0027d7 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel0_fx_Qxy_routine:
0027d9 91e0 2865                 	lds ZL, pulse1_fx_Qxy_target
0027db 91f0 2866                 	lds ZH, pulse1_fx_Qxy_target+1
0027dd 9630                      	adiw Z, 0
0027de f119                      	breq sound_driver_channel0_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
0027df 91a0 2869                 	lds r26, pulse1_fx_Qxy_total_offset
0027e1 91b0 286a                 	lds r27, pulse1_fx_Qxy_total_offset+1
0027e3 91c0 0a8c                 	lds r28, TCB0_CCMPL
0027e5 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
0027e7 1bec                      	sub ZL, r28 //calculate the difference to the target
0027e8 0bfd                      	sbc ZH, r29
0027e9 f408                      	brsh sound_driver_channel0_fx_Qxy_routine_end //if the target has been reached (or passed)
0027ea f068                      	brlo sound_driver_channel0_fx_Qxy_routine_add
                                 
                                 sound_driver_channel0_fx_Qxy_routine_end:
0027eb 9220 2869                 	sts pulse1_fx_Qxy_total_offset, zero //turn off the effect
0027ed 9220 286a                 	sts pulse1_fx_Qxy_total_offset+1, zero
0027ef 9220 2865                 	sts pulse1_fx_Qxy_target, zero
0027f1 9220 2866                 	sts pulse1_fx_Qxy_target+1, zero
0027f3 91b0 2864                 	lds r27, pulse1_fx_Qxy_target_note
0027f5 93b0 2807                 	sts pulse1_note, r27 //replace the note with the final target note
0027f7 c00a                      	rjmp sound_driver_channel0_fx_Rxy_routine
                                 
                                 sound_driver_channel0_fx_Qxy_routine_add:
0027f8 91c0 2867                 	lds r28, pulse1_fx_Qxy_speed
0027fa 91d0 2868                 	lds r29, pulse1_fx_Qxy_speed+1
0027fc 0fac                      	add r26, r28 //increase the total offset by the speed
0027fd 1fbd                      	adc r27, r29
0027fe 93a0 2869                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
002800 93b0 286a                 	sts pulse1_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Rxy_routine:
002802 91e0 286c                 	lds ZL, pulse1_fx_Rxy_target
002804 91f0 286d                 	lds ZH, pulse1_fx_Rxy_target+1
002806 9630                      	adiw Z, 0
002807 f119                      	breq sound_driver_instrument_routine_channel1_volume //if the effect is not enabled, skip the routine
                                 
002808 91a0 2870                 	lds r26, pulse1_fx_Rxy_total_offset
00280a 91b0 2871                 	lds r27, pulse1_fx_Rxy_total_offset+1
00280c 91c0 0a8c                 	lds r28, TCB0_CCMPL
00280e 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
002810 1bce                      	sub r28, ZL //calculate the difference to the target
002811 0bdf                      	sbc r29, ZH
002812 f408                      	brsh sound_driver_channel0_fx_Rxy_routine_end //if the target has been reached (or passed)
002813 f068                      	brlo sound_driver_channel0_fx_Rxy_routine_add
                                 
                                 sound_driver_channel0_fx_Rxy_routine_end:
002814 9220 2870                 	sts pulse1_fx_Rxy_total_offset, zero //disable the effect
002816 9220 2871                 	sts pulse1_fx_Rxy_total_offset+1, zero
002818 9220 286c                 	sts pulse1_fx_Rxy_target, zero
00281a 9220 286d                 	sts pulse1_fx_Rxy_target+1, zero
00281c 91b0 286b                 	lds r27, pulse1_fx_Rxy_target_note
00281e 93b0 2807                 	sts pulse1_note, r27 //replace the note with the final target note
002820 c00a                      	rjmp sound_driver_instrument_routine_channel1_volume
                                 
                                 sound_driver_channel0_fx_Rxy_routine_add:
002821 91c0 286e                 	lds r28, pulse1_fx_Rxy_speed
002823 91d0 286f                 	lds r29, pulse1_fx_Rxy_speed+1
002825 0fac                      	add r26, r28 //increase the total offset by the speed
002826 1fbd                      	adc r27, r29
002827 93a0 2870                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
002829 93b0 2871                 	sts pulse1_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume:
00282b 91e0 287a                 	lds ZL, pulse2_volume_macro
00282d 91f0 287b                 	lds ZH, pulse2_volume_macro+1
00282f 9630                      	adiw Z, 0
002830 f1a1                      	breq sound_driver_instrument_routine_channel1_volume_default //if no volume macro is in use, use default multiplier of F
002831 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002832 1fff                      	rol ZH
002833 91a0 287c                 	lds r26, pulse2_volume_macro_offset
002835 0fea                      	add ZL, r26
002836 1df2                      	adc ZH, zero
                                 
002837 91b0 287e                 	lds r27, pulse2_volume_macro_release
002839 17ba                      	cp r27, r26
00283a f429                      	brne sound_driver_instrument_routine_channel1_volume_increment //if the current offset is not equal to the release index, increment the offset
00283b 91a0 287d                 	lds r26, pulse2_volume_macro_loop
00283d 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00283e f010                      	brlo sound_driver_instrument_routine_channel1_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00283f c003                      	rjmp sound_driver_instrument_routine_channel1_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_volume_increment:
002840 95a3                      	inc r26 //increment the macro offset
002841 93a0 287c                 	sts pulse2_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_volume_read:
002843 91b4                      	lpm r27, Z //load volume data into r27
002844 3fbf                      	cpi r27, 0xFF //check for macro end flag
002845 f469                      	brne sound_driver_instrument_routine_channel1_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_release:
002846 91b0 287e                 	lds r27, pulse2_volume_macro_release
002848 3fbf                      	cpi r27, 0xFF
002849 f429                      	brne sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_loop:
00284a 91b0 287d                 	lds r27, pulse2_volume_macro_loop //load the loop index
00284c 93b0 287c                 	sts pulse2_volume_macro_offset, r27 //store the loop index into the offset
00284e cfdc                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index:
00284f 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002850 93a0 287c                 	sts pulse2_volume_macro_offset, r26
002852 cfd8                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_calculate:
002853 e0e4                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
002854 e6f2                      	ldi ZH, HIGH(volumes << 1)
002855 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
002856 0feb                      	add ZL, r27 //add offset to the table
002857 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel1_volume_load:
002858 91b0 2808                 	lds r27, pulse2_param //load main volume
00285a 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
00285b 91a0 28af                 	lds r26, pulse2_fx_7xy_value
00285d 30a0                      	cpi r26, 0x00
00285e f481                      	brne sound_driver_instrument_routine_channel1_volume_load_7xy
                                 
00285f 0feb                      	add ZL, r27 //offset the volume table by the main volume
002860 1df2                      	adc ZH, zero
002861 91b4                      	lpm r27, Z
002862 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
002864 c023                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default:
002865 91b0 2808                 	lds r27, pulse2_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
002867 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002868 91a0 28af                 	lds r26, pulse2_fx_7xy_value
00286a 30a0                      	cpi r26, 0x00
00286b f499                      	brne sound_driver_instrument_routine_channel1_volume_default_7xy
00286c 93b0 280e                 	sts pulse2_output_volume, r27
00286e c019                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy:
00286f 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002870 f038                      	brcs sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
002871 f031                      	breq sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
                                 
002872 0feb                      	add ZL, r27 //offset the volume table by the main volume
002873 1df2                      	adc ZH, zero
002874 91b4                      	lpm r27, Z
002875 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
002877 c010                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy_overflow:
002878 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002879 0feb                      	add ZL, r27 //offset the volume table by the main volume
00287a 1df2                      	adc ZH, zero
00287b 91b4                      	lpm r27, Z
00287c 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
00287e c009                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default_7xy:
00287f 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002880 f020                      	brcs sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
002881 f019                      	breq sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
002882 93b0 280e                 	sts pulse2_output_volume, r27
002884 c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel1_volume_default_7xy_overflow:
002885 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002886 93b0 280e                 	sts pulse2_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002888 91e0 287f                 	lds ZL, pulse2_arpeggio_macro
00288a 91f0 2880                 	lds ZH, pulse2_arpeggio_macro+1
00288c 9630                      	adiw Z, 0
00288d f1d9                      	breq sound_driver_instrument_routine_channel1_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
00288e 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
00288f 1fff                      	rol ZH
002890 91a0 2881                 	lds r26, pulse2_arpeggio_macro_offset
002892 0fea                      	add ZL, r26
002893 1df2                      	adc ZH, zero
                                 
002894 91b0 2883                 	lds r27, pulse2_arpeggio_macro_release
002896 17ba                      	cp r27, r26
002897 f429                      	brne sound_driver_instrument_routine_channel1_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002898 91a0 2882                 	lds r26, pulse2_arpeggio_macro_loop
00289a 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00289b f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
00289c c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_increment:
00289d 95a3                      	inc r26 //increment the macro offset
00289e 93a0 2881                 	sts pulse2_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_read:
0028a0 91b4                      	lpm r27, Z //load arpeggio data into r27
0028a1 38b0                      	cpi r27, 0x80 //check for macro end flag
0028a2 f009                      	breq sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag
0028a3 c041                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_check_mode:
0028a4 50a1                      	subi r26, 1 //keep the offset at the end flag
0028a5 93a0 2881                 	sts pulse2_arpeggio_macro_offset, r26
0028a7 91b0 2884                 	lds r27, pulse2_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
0028a9 30b1                      	cpi r27, 0x01
0028aa f048                      	brlo sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_release:
0028ab 91b0 2883                 	lds r27, pulse2_arpeggio_macro_release
0028ad 3fbf                      	cpi r27, 0xFF
0028ae f4d1                      	brne sound_driver_instrument_routine_channel1_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_loop:
0028af 91b0 2882                 	lds r27, pulse2_arpeggio_macro_loop
0028b1 3fbf                      	cpi r27, 0xFF
0028b2 f499                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
0028b3 c015                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute:
0028b4 91b0 2883                 	lds r27, pulse2_arpeggio_macro_release
0028b6 3fbf                      	cpi r27, 0xFF
0028b7 f421                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_check_loop:
0028b8 91b0 2882                 	lds r27, pulse2_arpeggio_macro_loop //load the loop index
0028ba 3fbf                      	cpi r27, 0xFF //check if loop flag exists
0028bb f451                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop:
0028bc 91c0 2897                 	lds r28, pulse2_fx_0xy_sequence //check for 0xy effect
0028be 91d0 2898                 	lds r29, pulse2_fx_0xy_sequence+1
0028c0 9620                      	adiw r29:r28, 0
0028c1 f469                      	brne sound_driver_instrument_routine_channel1_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
0028c2 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
0028c3 93a0 2881                 	sts pulse2_arpeggio_macro_offset, r26 //store the last valid index into the offset
0028c5 cfc2                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload:
0028c6 93b0 2881                 	sts pulse2_arpeggio_macro_offset, r27 //store the loop index into the offset
0028c8 cfbf                      	rjmp sound_driver_instrument_routine_channel1_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_default:
0028c9 91c0 2897                 	lds r28, pulse2_fx_0xy_sequence //load 0xy effect
0028cb 91d0 2898                 	lds r29, pulse2_fx_0xy_sequence+1
0028cd 9620                      	adiw r29:r28, 0 //check for 0xy effect
0028ce f099                      	breq sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel1_arpeggio_default_0xy:
0028cf 95d6                      	lsr r29
0028d0 95c7                      	ror r28
0028d1 95d7                      	ror r29
0028d2 95c7                      	ror r28
0028d3 95d7                      	ror r29
0028d4 95c7                      	ror r28
0028d5 95d7                      	ror r29
0028d6 95c7                      	ror r28
0028d7 95d7                      	ror r29
0028d8 95d2                      	swap r29
                                 
0028d9 93c0 2897                 	sts pulse2_fx_0xy_sequence, r28 //store the rolled sequence
0028db 93d0 2898                 	sts pulse2_fx_0xy_sequence+1, r29
0028dd 70cf                      	andi r28, 0x0F //mask out the 4 LSB
0028de 91a0 280f                 	lds r26, pulse2_note //load the current note index
0028e0 0fac                      	add r26, r28 //add the note offset
0028e1 c02e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
0028e2 91a0 280f                 	lds r26, pulse2_note //load the current note index
0028e4 c02b                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process:
0028e5 9220 2885                 	sts pulse2_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
0028e7 9220 2886                 	sts pulse2_total_pitch_offset+1, zero
0028e9 9220 288c                 	sts pulse2_total_hi_pitch_offset, zero
0028eb 91a0 2884                 	lds r26, pulse2_arpeggio_macro_mode
0028ed 30a1                      	cpi r26, 0x01 //absolute mode
0028ee f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_absolute
0028ef f069                      	breq sound_driver_instrument_routine_channel1_arpeggio_process_fixed
0028f0 c00e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute:
0028f1 91a0 280f                 	lds r26, pulse2_note //load the current note index
0028f3 0fab                      	add r26, r27 //offset the note with the arpeggio data
0028f4 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0028f5 c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_add:
0028f6 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0028f7 f0c0                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
0028f8 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0028f9 c016                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract:
0028fa fda7                      	sbrc r26, 7 //check if result is negative
0028fb e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0028fc c013                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_fixed:
0028fd 2fab                      	mov r26, r27 //move the arpeggio data into r26
0028fe c011                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative:
0028ff 91a0 280f                 	lds r26, pulse2_note //load the current note index
002901 0fab                      	add r26, r27 //offset the note with the arpeggio data
002902 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002903 c008                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_add:
002904 93a0 280f                 	sts pulse2_note, r26 //NOTE: relative mode modifies the original note index
002906 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002907 f040                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
002908 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002909 93a0 280f                 	sts pulse2_note, r26
00290b c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract:
00290c fda7                      	sbrc r26, 7 //check if result is negative
00290d e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
00290e 93a0 280f                 	sts pulse2_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_load:
002910 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
002911 e0f0                      	ldi ZH, HIGH(note_table << 1)
002912 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002913 0fea                      	add ZL, r26 //add offset
002914 1df2                      	adc ZH, zero
002915 91a5                      	lpm r26, Z+ //load bytes
002916 91b4                      	lpm r27, Z
002917 93a0 0a9c                 	sts TCB1_CCMPL, r26 //load the LOW bits for timer
002919 93b0 0a9d                 	sts TCB1_CCMPH, r27 //load the HIGH bits for timer
00291b 93a0 28a3                 	sts pulse2_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
00291d 93b0 28a4                 	sts pulse2_fx_3xx_target+1, r27
00291f c000                      	rjmp sound_driver_instrument_routine_channel1_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch:
002920 91e0 2887                 	lds ZL, pulse2_pitch_macro
002922 91f0 2888                 	lds ZH, pulse2_pitch_macro+1
002924 9630                      	adiw Z, 0
002925 f409                      	brne sound_driver_instrument_routine_channel1_pitch_continue
002926 c023                      	rjmp sound_driver_instrument_routine_channel1_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel1_pitch_continue:
002927 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002928 1fff                      	rol ZH
002929 91a0 2889                 	lds r26, pulse2_pitch_macro_offset
00292b 0fea                      	add ZL, r26
00292c 1df2                      	adc ZH, zero
                                 
00292d 91b0 288b                 	lds r27, pulse2_pitch_macro_release
00292f 17ba                      	cp r27, r26
002930 f429                      	brne sound_driver_instrument_routine_channel1_pitch_increment //if the current offset is not equal to the release index, increment the offset
002931 91a0 288a                 	lds r26, pulse2_pitch_macro_loop
002933 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002934 f010                      	brlo sound_driver_instrument_routine_channel1_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002935 c003                      	rjmp sound_driver_instrument_routine_channel1_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_pitch_increment:
002936 95a3                      	inc r26 //increment the macro offset
002937 93a0 2889                 	sts pulse2_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_pitch_read:
002939 91b4                      	lpm r27, Z //load pitch data into r27
00293a 38b0                      	cpi r27, 0x80 //check for macro end flag
00293b f479                      	brne sound_driver_instrument_routine_channel1_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_release:
00293c 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00293d 93a0 2889                 	sts pulse2_pitch_macro_offset, r26
00293f 91b0 288b                 	lds r27, pulse2_pitch_macro_release
002941 3fbf                      	cpi r27, 0xFF
002942 f439                      	brne sound_driver_instrument_routine_channel1_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_loop:
002943 91b0 288a                 	lds r27, pulse2_pitch_macro_loop //load the loop index
002945 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002946 f019                      	breq sound_driver_instrument_routine_channel1_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002947 93b0 2889                 	sts pulse2_pitch_macro_offset, r27 //store the loop index into the offset
002949 cfd6                      	rjmp sound_driver_instrument_routine_channel1_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_default:
00294a e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel1_pitch_calculate:
00294b 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00294c 937f                      	push r23
00294d 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
00294e eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00294f 0367                      	mulsu r22, r23
002950 917f                      	pop r23
002951 916f                      	pop r22
                                 
002952 9416                      	lsr r1 //shift out the fractional bits
002953 9407                      	ror r0
002954 9416                      	lsr r1
002955 9407                      	ror r0
002956 9416                      	lsr r1
002957 9407                      	ror r0
002958 9416                      	lsr r1
002959 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_check_negative:
00295a fe13                      	sbrs r1, 3 //check if result was a negative number
00295b c007                      	rjmp sound_driver_instrument_routine_channel1_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_negative:
00295c efc0                      	ldi r28, 0xF0
00295d 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_check_divisible_8:
00295e 70b7                      	andi r27, 0b00000111
00295f f019                      	breq sound_driver_instrument_routine_channel1_pitch_calculate_offset
                                 
002960 e0b1                      	ldi r27, 0x01
002961 0e0b                      	add r0, r27
002962 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_offset:
002963 91a0 2885                 	lds r26, pulse2_total_pitch_offset
002965 91b0 2886                 	lds r27, pulse2_total_pitch_offset+1
002967 0e0a                      	add r0, r26
002968 1e1b                      	adc r1, r27
002969 9200 2885                 	sts pulse2_total_pitch_offset, r0
00296b 9210 2886                 	sts pulse2_total_pitch_offset+1, r1
00296d 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
00296f 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
002971 0da0                      	add r26, r0 //offset the timer values
002972 1db1                      	adc r27, r1
                                 	
002973 91c0 289b                 	lds r28, pulse2_fx_1xx_total
002975 91d0 289c                 	lds r29, pulse2_fx_1xx_total+1
002977 1bac                      	sub r26, r28
002978 0bbd                      	sbc r27, r29
002979 91c0 289f                 	lds r28, pulse2_fx_2xx_total
00297b 91d0 28a0                 	lds r29, pulse2_fx_2xx_total+1
00297d 0fac                      	add r26, r28
00297e 1fbd                      	adc r27, r29
00297f 91c0 28b3                 	lds r28, pulse2_fx_Pxx_total
002981 91d0 28b4                 	lds r29, pulse2_fx_Pxx_total+1
002983 0fac                      	add r26, r28
002984 1fbd                      	adc r27, r29
002985 91c0 28ba                 	lds r28, pulse2_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
002987 91d0 28bb                 	lds r29, pulse2_fx_Qxy_total_offset+1
002989 1bac                      	sub r26, r28
00298a 0bbd                      	sbc r27, r29
00298b 91c0 28c1                 	lds r28, pulse2_fx_Rxy_total_offset
00298d 91d0 28c2                 	lds r29, pulse2_fx_Rxy_total_offset+1
00298f 0fac                      	add r26, r28
002990 1fbd                      	adc r27, r29
                                 
002991 e5c9                      	ldi r28, 0x59
002992 e0d0                      	ldi r29, 0x00
002993 17ac                      	cp r26, r28
002994 07bd                      	cpc r27, r29
002995 f030                      	brlo sound_driver_instrument_routine_channel1_pitch_min
                                 
002996 e5ca                      	ldi r28, 0x5A
002997 e5d9                      	ldi r29, 0x59
002998 17ac                      	cp r26, r28
002999 07bd                      	cpc r27, r29
00299a f420                      	brsh sound_driver_instrument_routine_channel1_pitch_max
00299b c006                      	rjmp sound_driver_instrument_routine_channel1_pitch_store
                                 
                                 sound_driver_instrument_routine_channel1_pitch_min:
00299c e5c9                      	ldi r28, 0x59
00299d e0d0                      	ldi r29, 0x00
00299e c003                      	rjmp sound_driver_instrument_routine_channel1_pitch_store
                                 
                                 sound_driver_instrument_routine_channel1_pitch_max:
00299f e5c9                      	ldi r28, 0x59
0029a0 e5d9                      	ldi r29, 0x59
0029a1 c000                      	rjmp sound_driver_instrument_routine_channel1_pitch_store
                                 
                                 sound_driver_instrument_routine_channel1_pitch_store:
0029a2 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
0029a4 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel1_hi_pitch:
0029a6 91e0 288d                 	lds ZL, pulse2_hi_pitch_macro
0029a8 91f0 288e                 	lds ZH, pulse2_hi_pitch_macro+1
0029aa 9630                      	adiw Z, 0
0029ab f409                      	brne sound_driver_instrument_routine_channel1_hi_pitch_continue
0029ac c03c                      	rjmp sound_driver_instrument_routine_channel1_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel1_hi_pitch_continue:
0029ad 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0029ae 1fff                      	rol ZH
0029af 91a0 288f                 	lds r26, pulse2_hi_pitch_macro_offset
0029b1 0fea                      	add ZL, r26
0029b2 1df2                      	adc ZH, zero
                                 
0029b3 91b0 2891                 	lds r27, pulse2_hi_pitch_macro_release
0029b5 17ba                      	cp r27, r26
0029b6 f429                      	brne sound_driver_instrument_routine_channel1_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
0029b7 91a0 2890                 	lds r26, pulse2_hi_pitch_macro_loop
0029b9 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0029ba f010                      	brlo sound_driver_instrument_routine_channel1_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0029bb c003                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_increment:
0029bc 95a3                      	inc r26 //increment the macro offset
0029bd 93a0 288f                 	sts pulse2_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_hi_pitch_read:
0029bf 91b4                      	lpm r27, Z //load hi pitch data into r27
0029c0 38b0                      	cpi r27, 0x80 //check for macro end flag
0029c1 f489                      	brne sound_driver_instrument_routine_channel1_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_release:
0029c2 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0029c3 93a0 288f                 	sts pulse2_hi_pitch_macro_offset, r26
0029c5 91b0 2891                 	lds r27, pulse2_hi_pitch_macro_release
0029c7 3fbf                      	cpi r27, 0xFF
0029c8 f439                      	brne sound_driver_instrument_routine_channel1_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_loop:
0029c9 91b0 2890                 	lds r27, pulse2_hi_pitch_macro_loop //load the loop index
0029cb 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0029cc f019                      	breq sound_driver_instrument_routine_channel1_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
0029cd 93b0 288f                 	sts pulse2_hi_pitch_macro_offset, r27 //store the loop index into the offset
0029cf cfd6                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_default:
0029d0 91b0 288c                 	lds r27, pulse2_total_hi_pitch_offset
0029d2 c005                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate:
0029d3 91a0 288c                 	lds r26, pulse2_total_hi_pitch_offset //load the total hi pitch offset to change
0029d5 0fba                      	add r27, r26
0029d6 93b0 288c                 	sts pulse2_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply:
0029d8 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0029d9 937f                      	push r23
0029da 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
0029db eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0029dc 0367                      	mulsu r22, r23
0029dd 917f                      	pop r23
0029de 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_offset:
0029df 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
0029e1 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
0029e3 0da0                      	add r26, r0 //offset the timer values
0029e4 1db1                      	adc r27, r1
0029e5 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
0029e7 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel1_duty:
0029e9 91e0 2892                 	lds ZL, pulse2_duty_macro
0029eb 91f0 2893                 	lds ZH, pulse2_duty_macro+1
0029ed 9630                      	adiw Z, 0
0029ee f1b1                      	breq sound_driver_channel1_fx_routines //if no duty macro is in use, go to the next routine
0029ef 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0029f0 1fff                      	rol ZH
0029f1 91a0 2894                 	lds r26, pulse2_duty_macro_offset
0029f3 0fea                      	add ZL, r26
0029f4 1df2                      	adc ZH, zero
                                 
0029f5 91b0 2896                 	lds r27, pulse2_duty_macro_release
0029f7 17ba                      	cp r27, r26
0029f8 f429                      	brne sound_driver_instrument_routine_channel1_duty_increment //if the current offset is not equal to the release index, increment the offset
0029f9 91a0 2895                 	lds r26, pulse2_duty_macro_loop
0029fb 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0029fc f010                      	brlo sound_driver_instrument_routine_channel1_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0029fd c027                      	rjmp sound_driver_channel1_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel1_duty_increment:
0029fe 95a3                      	inc r26 //increment the macro offset
0029ff 93a0 2894                 	sts pulse2_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_duty_read:
002a01 91b4                      	lpm r27, Z //load pitch data into r27
002a02 3fbf                      	cpi r27, 0xFF //check for macro end flag
002a03 f471                      	brne sound_driver_instrument_routine_channel1_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_release:
002a04 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002a05 93a0 2894                 	sts pulse2_duty_macro_offset, r26
002a07 91b0 2896                 	lds r27, pulse2_duty_macro_release
002a09 3fbf                      	cpi r27, 0xFF
002a0a f4d1                      	brne sound_driver_channel1_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_loop:
002a0b 91b0 2895                 	lds r27, pulse2_duty_macro_loop //load the loop index
002a0d 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002a0e f0b1                      	breq sound_driver_channel1_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
002a0f 93b0 2894                 	sts pulse2_duty_macro_offset, r27 //store the loop index into the offset
002a11 cfd7                      	rjmp sound_driver_instrument_routine_channel1_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_load:
002a12 efec                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
002a13 e6f0                      	ldi ZH, HIGH(sequences << 1)
002a14 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
002a15 1df2                      	adc ZH, zero
                                 
002a16 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
002a17 95b7                      	ror r27
002a18 95b7                      	ror r27
002a19 91a0 2808                 	lds r26, pulse2_param //load r26 with pulse2_param (register $4000)
002a1b 2fca                      	mov r28, r26 //store a copy of pulse2_param into r28
002a1c 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
002a1d 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
002a1e c001                      	rjmp sound_driver_instrument_routine_channel1_duty_load_store
002a1f c005                      	rjmp sound_driver_channel1_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel1_duty_load_store:
002a20 90a4                      	lpm pulse2_sequence, Z //store the sequence
                                 
002a21 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
002a22 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
002a23 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_routines:
                                 sound_driver_channel1_fx_1xx_routine:
002a25 91e0 2899                 	lds ZL, pulse2_fx_1xx
002a27 91f0 289a                 	lds ZH, pulse2_fx_1xx+1
002a29 9630                      	adiw Z, 0
002a2a f051                      	breq sound_driver_channel1_fx_2xx_routine
                                 
002a2b 91a0 289b                 	lds r26, pulse2_fx_1xx_total //load the rate to change the pitch by
002a2d 91b0 289c                 	lds r27, pulse2_fx_1xx_total+1
002a2f 0fae                      	add r26, ZL //increase the total offset by the rate
002a30 1fbf                      	adc r27, ZH
002a31 93a0 289b                 	sts pulse2_fx_1xx_total, r26
002a33 93b0 289c                 	sts pulse2_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_2xx_routine:
002a35 91e0 289d                 	lds ZL, pulse2_fx_2xx
002a37 91f0 289e                 	lds ZH, pulse2_fx_2xx+1
002a39 9630                      	adiw Z, 0
002a3a f051                      	breq sound_driver_channel1_fx_3xx_routine
                                 
002a3b 91a0 289f                 	lds r26, pulse2_fx_2xx_total //load the rate to change the pitch by
002a3d 91b0 28a0                 	lds r27, pulse2_fx_2xx_total+1
002a3f 0fae                      	add r26, ZL //increase the total offset by the rate
002a40 1fbf                      	adc r27, ZH
002a41 93a0 289f                 	sts pulse2_fx_2xx_total, r26
002a43 93b0 28a0                 	sts pulse2_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_3xx_routine:
002a45 91e0 28a5                 	lds ZL, pulse2_fx_3xx_speed
002a47 91f0 28a6                 	lds ZH, pulse2_fx_3xx_speed+1
002a49 9630                      	adiw Z, 0
002a4a f409                      	brne sound_driver_channel1_fx_3xx_routine_check_start
002a4b c048                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_check_start:
002a4c 91a0 28a1                 	lds r26, pulse2_fx_3xx_start
002a4e 91b0 28a2                 	lds r27, pulse2_fx_3xx_start+1
002a50 9610                      	adiw r26:r27, 0
002a51 f409                      	brne sound_driver_channel1_fx_3xx_routine_main
002a52 c041                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_main:
002a53 91c0 28a3                 	lds r28, pulse2_fx_3xx_target
002a55 91d0 28a4                 	lds r29, pulse2_fx_3xx_target+1
                                 
002a57 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
002a58 07bd                      	cpc r27, r29
002a59 f011                      	breq sound_driver_channel1_fx_3xx_routine_disable
002a5a f030                      	brlo sound_driver_channel1_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002a5b c01f                      	rjmp sound_driver_channel1_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel1_fx_3xx_routine_disable:
002a5c 9220 28a1                 	sts pulse2_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002a5e 9220 28a2                 	sts pulse2_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002a60 c033                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_subtract:
002a61 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002a62 0bdb                      	sbc r29, r27
002a63 91a0 28a7                 	lds r26, pulse2_fx_3xx_total_offset
002a65 91b0 28a8                 	lds r27, pulse2_fx_3xx_total_offset+1
                                 
002a67 0fae                      	add r26, ZL //add the speed to the total offset
002a68 1fbf                      	adc r27, ZH
002a69 1bca                      	sub r28, r26 //invert the total difference with the total offset
002a6a 0bdb                      	sbc r29, r27
002a6b f380                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002a6c 93a0 28a7                 	sts pulse2_fx_3xx_total_offset, r26 //store the new total offset
002a6e 93b0 28a8                 	sts pulse2_fx_3xx_total_offset+1, r27
                                 
002a70 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the current timer period
002a72 91b0 0a9d                 	lds r27, TCB1_CCMPH
002a74 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002a75 0bbd                      	sbc r27, r29
002a76 93a0 0a9c                 	sts TCB1_CCMPL, r26
002a78 93b0 0a9d                 	sts TCB1_CCMPH, r27
002a7a c019                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_add:
002a7b 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002a7c 0bbd                      	sbc r27, r29
002a7d 91c0 28a7                 	lds r28, pulse2_fx_3xx_total_offset
002a7f 91d0 28a8                 	lds r29, pulse2_fx_3xx_total_offset+1
                                 
002a81 0fce                      	add r28, ZL //add the speed to the total offset
002a82 1fdf                      	adc r29, ZH
002a83 1bac                      	sub r26, r28 //invert the total difference with the total offset
002a84 0bbd                      	sbc r27, r29
002a85 f2b0                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002a86 93c0 28a7                 	sts pulse2_fx_3xx_total_offset, r28 //store the new total offset
002a88 93d0 28a8                 	sts pulse2_fx_3xx_total_offset+1, r29
                                 
002a8a 91c0 0a9c                 	lds r28, TCB1_CCMPL //load the current timer period
002a8c 91d0 0a9d                 	lds r29, TCB1_CCMPH
002a8e 0fca                      	add r28, r26 //offset the current timer period with the total offset
002a8f 1fdb                      	adc r29, r27
002a90 93c0 0a9c                 	sts TCB1_CCMPL, r28
002a92 93d0 0a9d                 	sts TCB1_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel1_fx_4xy_routine:
002a94 91a0 28a9                 	lds r26, pulse2_fx_4xy_speed
002a96 15a2                      	cp r26, zero
002a97 f409                      	brne sound_driver_channel1_fx_4xy_routine_continue
002a98 c05c                      	rjmp sound_driver_channel1_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel1_fx_4xy_routine_continue:
002a99 91b0 28aa                 	lds r27, pulse2_fx_4xy_depth
002a9b 91c0 28ab                 	lds r28, pulse2_fx_4xy_phase
002a9d 0fca                      	add r28, r26 //increase the phase by the speed
002a9e 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002a9f f008                      	brlo sound_driver_channel1_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002aa0 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase:
002aa1 93c0 28ab                 	sts pulse2_fx_4xy_phase, r28 //store the new phase
002aa3 31c0                      	cpi r28, 16
002aa4 f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_0
002aa5 32c0                      	cpi r28, 32
002aa6 f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_1
002aa7 33c0                      	cpi r28, 48
002aa8 f030                      	brlo sound_driver_channel1_fx_4xy_routine_phase_2
002aa9 c007                      	rjmp sound_driver_channel1_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_0:
002aaa 70cf                      	andi r28, 0x0F //mask for values 0-15
002aab c029                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_1:
002aac 6fc0                      	ori r28, 0xF0
002aad 95c0                      	com r28 //invert values 0-15
002aae c026                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_2:
002aaf 70cf                      	andi r28, 0x0F //mask for values 0-15
002ab0 c003                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_3:
002ab1 6fc0                      	ori r28, 0xF0
002ab2 95c0                      	com r28 //invert values 0-15
002ab3 c000                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_add:
002ab4 95b2                      	swap r27 //multiply depth by 16
002ab5 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002ab6 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002ab7 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002ab8 0fec                      	add ZL, r28 //offset the table by the depth+phase
002ab9 1df2                      	adc ZH, zero
002aba 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002abb 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002abc 937f                      	push r23
002abd 2f6c                      	mov r22, r28 //store the vibrato value into r22
002abe eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002abf 9f67                      	mul r22, r23
002ac0 917f                      	pop r23
002ac1 916f                      	pop r22
                                 
002ac2 9416                      	lsr r1 //shift out the fractional bits
002ac3 9407                      	ror r0
002ac4 9416                      	lsr r1
002ac5 9407                      	ror r0
002ac6 9416                      	lsr r1
002ac7 9407                      	ror r0
002ac8 9416                      	lsr r1
002ac9 9407                      	ror r0
                                 	
002aca 91a0 0a9c                 	lds r26, TCB1_CCMPL
002acc 91b0 0a9d                 	lds r27, TCB1_CCMPH
002ace 0da0                      	add r26, r0
002acf 1db1                      	adc r27, r1
002ad0 93a0 0a9c                 	sts TCB1_CCMPL, r26
002ad2 93b0 0a9d                 	sts TCB1_CCMPH, r27
002ad4 c020                      	rjmp sound_driver_channel1_fx_7xy_routine
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_subtract:
002ad5 95b2                      	swap r27 //multiply depth by 16
002ad6 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002ad7 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002ad8 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002ad9 0fec                      	add ZL, r28 //offset the table by the depth+phase
002ada 1df2                      	adc ZH, zero
002adb 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002adc 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002add 937f                      	push r23
002ade 2f6c                      	mov r22, r28 //store the vibrato value into r22
002adf eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002ae0 9f67                      	mul r22, r23
002ae1 917f                      	pop r23
002ae2 916f                      	pop r22
                                 
002ae3 9416                      	lsr r1 //shift out the fractional bits
002ae4 9407                      	ror r0
002ae5 9416                      	lsr r1
002ae6 9407                      	ror r0
002ae7 9416                      	lsr r1
002ae8 9407                      	ror r0
002ae9 9416                      	lsr r1
002aea 9407                      	ror r0
                                 
002aeb 91a0 0a9c                 	lds r26, TCB1_CCMPL
002aed 91b0 0a9d                 	lds r27, TCB1_CCMPH
002aef 19a0                      	sub r26, r0
002af0 09b1                      	sbc r27, r1
002af1 93a0 0a9c                 	sts TCB1_CCMPL, r26
002af3 93b0 0a9d                 	sts TCB1_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_7xy_routine:
002af5 91a0 28ac                 	lds r26, pulse2_fx_7xy_speed
002af7 15a2                      	cp r26, zero
002af8 f0e9                      	breq sound_driver_channel1_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
002af9 91b0 28ad                 	lds r27, pulse2_fx_7xy_depth
002afb 91c0 28ae                 	lds r28, pulse2_fx_7xy_phase
002afd 0fca                      	add r28, r26 //increase the phase by the speed
002afe 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002aff f008                      	brlo sound_driver_channel1_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
002b00 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase:
002b01 93c0 28ae                 	sts pulse2_fx_7xy_phase, r28 //store the new phase
002b03 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
002b04 ffc4                      	sbrs r28, 4
002b05 c001                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_0
002b06 c002                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel1_fx_7xy_routine_phase_0:
002b07 70cf                      	andi r28, 0x0F //mask for values 0-15
002b08 c003                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase_1:
002b09 6fc0                      	ori r28, 0xF0
002b0a 95c0                      	com r28 //invert values 0-15
002b0b c000                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_load:
002b0c 95b2                      	swap r27 //multiply depth by 16
002b0d 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002b0e e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002b0f e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002b10 0fec                      	add ZL, r28 //offset the table by the depth+phase
002b11 1df2                      	adc ZH, zero
002b12 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002b13 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
002b14 93c0 28af                 	sts pulse2_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Axy_routine:
002b16 91b0 28b0                 	lds r27, pulse2_fx_Axy
002b18 15b2                      	cp r27, zero
002b19 f0e9                      	breq sound_driver_channel1_fx_Qxy_routine //0 means that the effect is not in use
                                 	
002b1a 91a0 280d                 	lds r26, pulse2_fractional_volume //load fractional volume representation of the channel
002b1c 91c0 2808                 	lds r28, pulse2_param //load the integer volume representation of the channel
002b1e 2fda                      	mov r29, r26 //copy fractional volume into r29
002b1f 2fec                      	mov r30, r28 //copy the pulse2_param into r30
002b20 95e2                      	swap r30
002b21 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
002b22 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
002b23 17ed                      	cp r30, r29 //compare the fractional and integer volumes
002b24 f009                      	breq sound_driver_channel1_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel1_fx_Axy_routine_reload:
002b25 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate:
002b26 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
002b27 c004                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_addition:
002b28 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002b29 f428                      	brcc sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002b2a efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
002b2b c003                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_subtraction:
002b2c 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002b2d f008                      	brcs sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002b2e e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_store:
002b2f 93a0 280d                 	sts pulse2_fractional_volume, r26 //store the new fractional volume
002b31 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
002b32 95a2                      	swap r26
002b33 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
002b34 2bca                      	or r28, r26 //store the new volume back into pulse2_param
002b35 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel1_fx_Qxy_routine:
002b37 91e0 28b6                 	lds ZL, pulse2_fx_Qxy_target
002b39 91f0 28b7                 	lds ZH, pulse2_fx_Qxy_target+1
002b3b 9630                      	adiw Z, 0
002b3c f119                      	breq sound_driver_channel1_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002b3d 91a0 28ba                 	lds r26, pulse2_fx_Qxy_total_offset
002b3f 91b0 28bb                 	lds r27, pulse2_fx_Qxy_total_offset+1
002b41 91c0 0a9c                 	lds r28, TCB1_CCMPL
002b43 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
002b45 1bec                      	sub ZL, r28 //calculate the difference to the target
002b46 0bfd                      	sbc ZH, r29
002b47 f408                      	brsh sound_driver_channel1_fx_Qxy_routine_end //if the target has been reached (or passed)
002b48 f068                      	brlo sound_driver_channel1_fx_Qxy_routine_add
                                 
                                 sound_driver_channel1_fx_Qxy_routine_end:
002b49 9220 28ba                 	sts pulse2_fx_Qxy_total_offset, zero //turn off the effect
002b4b 9220 28bb                 	sts pulse2_fx_Qxy_total_offset+1, zero
002b4d 9220 28b6                 	sts pulse2_fx_Qxy_target, zero
002b4f 9220 28b7                 	sts pulse2_fx_Qxy_target+1, zero
002b51 91b0 28b5                 	lds r27, pulse2_fx_Qxy_target_note
002b53 93b0 280f                 	sts pulse2_note, r27 //replace the note with the final target note
002b55 c00a                      	rjmp sound_driver_channel1_fx_Rxy_routine
                                 
                                 sound_driver_channel1_fx_Qxy_routine_add:
002b56 91c0 28b8                 	lds r28, pulse2_fx_Qxy_speed
002b58 91d0 28b9                 	lds r29, pulse2_fx_Qxy_speed+1
002b5a 0fac                      	add r26, r28 //increase the total offset by the speed
002b5b 1fbd                      	adc r27, r29
002b5c 93a0 28ba                 	sts pulse2_fx_Qxy_total_offset, r26 //store the total offset
002b5e 93b0 28bb                 	sts pulse2_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Rxy_routine:
002b60 91e0 28bd                 	lds ZL, pulse2_fx_Rxy_target
002b62 91f0 28be                 	lds ZH, pulse2_fx_Rxy_target+1
002b64 9630                      	adiw Z, 0
002b65 f119                      	breq sound_driver_instrument_routine_channel2_volume //if the effect is not enabled, skip the routine
                                 
002b66 91a0 28c1                 	lds r26, pulse2_fx_Rxy_total_offset
002b68 91b0 28c2                 	lds r27, pulse2_fx_Rxy_total_offset+1
002b6a 91c0 0a9c                 	lds r28, TCB1_CCMPL
002b6c 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
002b6e 1bce                      	sub r28, ZL //calculate the difference to the target
002b6f 0bdf                      	sbc r29, ZH
002b70 f408                      	brsh sound_driver_channel1_fx_Rxy_routine_end //if the target has been reached (or passed)
002b71 f068                      	brlo sound_driver_channel1_fx_Rxy_routine_add
                                 
                                 sound_driver_channel1_fx_Rxy_routine_end:
002b72 9220 28c1                 	sts pulse2_fx_Rxy_total_offset, zero //disable the effect
002b74 9220 28c2                 	sts pulse2_fx_Rxy_total_offset+1, zero
002b76 9220 28bd                 	sts pulse2_fx_Rxy_target, zero
002b78 9220 28be                 	sts pulse2_fx_Rxy_target+1, zero
002b7a 91b0 28bc                 	lds r27, pulse2_fx_Rxy_target_note
002b7c 93b0 280f                 	sts pulse2_note, r27 //replace the note with the final target note
002b7e c00a                      	rjmp sound_driver_instrument_routine_channel2_volume
                                 
                                 sound_driver_channel1_fx_Rxy_routine_add:
002b7f 91c0 28bf                 	lds r28, pulse2_fx_Rxy_speed
002b81 91d0 28c0                 	lds r29, pulse2_fx_Rxy_speed+1
002b83 0fac                      	add r26, r28 //increase the total offset by the speed
002b84 1fbd                      	adc r27, r29
002b85 93a0 28c1                 	sts pulse2_fx_Rxy_total_offset, r26 //store the total offset
002b87 93b0 28c2                 	sts pulse2_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume:
002b89 91e0 28cb                 	lds ZL, triangle_volume_macro
002b8b 91f0 28cc                 	lds ZH, triangle_volume_macro+1
002b8d 9630                      	adiw Z, 0
002b8e f199                      	breq sound_driver_instrument_routine_channel2_volume_default //if no volume macro is in use, do nothing
002b8f 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002b90 1fff                      	rol ZH
002b91 91a0 28cd                 	lds r26, triangle_volume_macro_offset
002b93 0fea                      	add ZL, r26
002b94 1df2                      	adc ZH, zero
                                 
002b95 91b0 28cf                 	lds r27, triangle_volume_macro_release
002b97 17ba                      	cp r27, r26
002b98 f429                      	brne sound_driver_instrument_routine_channel2_volume_increment //if the current offset is not equal to the release index, increment the offset
002b99 91a0 28ce                 	lds r26, triangle_volume_macro_loop
002b9b 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002b9c f010                      	brlo sound_driver_instrument_routine_channel2_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002b9d c003                      	rjmp sound_driver_instrument_routine_channel2_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_volume_increment:
002b9e 95a3                      	inc r26 //increment the macro offset
002b9f 93a0 28cd                 	sts triangle_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_volume_read:
002ba1 91b4                      	lpm r27, Z //load volume data into r27
002ba2 3fbf                      	cpi r27, 0xFF //check for macro end flag
002ba3 f469                      	brne sound_driver_instrument_routine_channel2_volume_process //if the data was not the macro end flag
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_release:
002ba4 91b0 28cf                 	lds r27, triangle_volume_macro_release
002ba6 3fbf                      	cpi r27, 0xFF
002ba7 f429                      	brne sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_loop:
002ba8 91b0 28ce                 	lds r27, triangle_volume_macro_loop //load the loop index
002baa 93b0 28cd                 	sts triangle_volume_macro_offset, r27 //store the loop index into the offset
002bac cfdc                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index:
002bad 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002bae 93a0 28cd                 	sts triangle_volume_macro_offset, r26
002bb0 cfd8                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_process:
002bb1 15b2                      	cp r27, zero
002bb2 f041                      	breq sound_driver_instrument_routine_channel2_volume_process_disable
                                 sound_driver_instrument_routine_channel2_volume_process_enable:
002bb3 91b0 0aa5                 	lds r27, TCB2_INTCTRL
002bb5 30b1                      	cpi r27, TCB_CAPT_bm
002bb6 f459                      	brne sound_driver_instrument_routine_channel2_volume_default //if the channel has already been muted, don't enable it again
002bb7 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
002bb8 93b0 0aa5                 	sts TCB2_INTCTRL, r27
002bba c007                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 sound_driver_instrument_routine_channel2_volume_process_disable:
002bbb 9220 0aa5                 	sts TCB2_INTCTRL, zero
002bbd 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
002bbf 9220 0aad                 	sts TCB2_CCMPH, zero
002bc1 c000                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_volume_default:
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002bc2 91e0 28d0                 	lds ZL, triangle_arpeggio_macro
002bc4 91f0 28d1                 	lds ZH, triangle_arpeggio_macro+1
002bc6 9630                      	adiw Z, 0
002bc7 f1d9                      	breq sound_driver_instrument_routine_channel2_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002bc8 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002bc9 1fff                      	rol ZH
002bca 91a0 28d2                 	lds r26, triangle_arpeggio_macro_offset
002bcc 0fea                      	add ZL, r26
002bcd 1df2                      	adc ZH, zero
                                 
002bce 91b0 28d4                 	lds r27, triangle_arpeggio_macro_release
002bd0 17ba                      	cp r27, r26
002bd1 f429                      	brne sound_driver_instrument_routine_channel2_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002bd2 91a0 28d3                 	lds r26, triangle_arpeggio_macro_loop
002bd4 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002bd5 f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002bd6 c003                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_increment:
002bd7 95a3                      	inc r26 //increment the macro offset
002bd8 93a0 28d2                 	sts triangle_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_read:
002bda 91b4                      	lpm r27, Z //load arpeggio data into r27
002bdb 38b0                      	cpi r27, 0x80 //check for macro end flag
002bdc f009                      	breq sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag
002bdd c041                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_check_mode:
002bde 50a1                      	subi r26, 1 //keep the offset at the end flag
002bdf 93a0 28d2                 	sts triangle_arpeggio_macro_offset, r26
002be1 91b0 28d5                 	lds r27, triangle_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002be3 30b1                      	cpi r27, 0x01
002be4 f048                      	brlo sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_release:
002be5 91b0 28d4                 	lds r27, triangle_arpeggio_macro_release
002be7 3fbf                      	cpi r27, 0xFF
002be8 f4d1                      	brne sound_driver_instrument_routine_channel2_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_loop:
002be9 91b0 28d3                 	lds r27, triangle_arpeggio_macro_loop
002beb 3fbf                      	cpi r27, 0xFF
002bec f499                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002bed c015                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute:
002bee 91b0 28d4                 	lds r27, triangle_arpeggio_macro_release
002bf0 3fbf                      	cpi r27, 0xFF
002bf1 f421                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_check_loop:
002bf2 91b0 28d3                 	lds r27, triangle_arpeggio_macro_loop //load the loop index
002bf4 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002bf5 f451                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop:
002bf6 91c0 28e8                 	lds r28, triangle_fx_0xy_sequence //check for 0xy effect
002bf8 91d0 28e9                 	lds r29, triangle_fx_0xy_sequence+1
002bfa 9620                      	adiw r29:r28, 0
002bfb f469                      	brne sound_driver_instrument_routine_channel2_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002bfc 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002bfd 93a0 28d2                 	sts triangle_arpeggio_macro_offset, r26 //store the last valid index into the offset
002bff cfc2                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload:
002c00 93b0 28d2                 	sts triangle_arpeggio_macro_offset, r27 //store the loop index into the offset
002c02 cfbf                      	rjmp sound_driver_instrument_routine_channel2_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_default:
002c03 91c0 28e8                 	lds r28, triangle_fx_0xy_sequence //load 0xy effect
002c05 91d0 28e9                 	lds r29, triangle_fx_0xy_sequence+1
002c07 9620                      	adiw r29:r28, 0 //check for 0xy effect
002c08 f099                      	breq sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel2_arpeggio_default_0xy:
002c09 95d6                      	lsr r29
002c0a 95c7                      	ror r28
002c0b 95d7                      	ror r29
002c0c 95c7                      	ror r28
002c0d 95d7                      	ror r29
002c0e 95c7                      	ror r28
002c0f 95d7                      	ror r29
002c10 95c7                      	ror r28
002c11 95d7                      	ror r29
002c12 95d2                      	swap r29
                                 
002c13 93c0 28e8                 	sts triangle_fx_0xy_sequence, r28 //store the rolled sequence
002c15 93d0 28e9                 	sts triangle_fx_0xy_sequence+1, r29
002c17 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002c18 91a0 2812                 	lds r26, triangle_note //load the current note index
002c1a 0fac                      	add r26, r28 //add the note offset
002c1b c02e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002c1c 91a0 2812                 	lds r26, triangle_note //load the current note index
002c1e c02b                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process:
002c1f 9220 28d6                 	sts triangle_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002c21 9220 28d7                 	sts triangle_total_pitch_offset+1, zero
002c23 9220 28dd                 	sts triangle_total_hi_pitch_offset, zero
002c25 91a0 28d5                 	lds r26, triangle_arpeggio_macro_mode
002c27 30a1                      	cpi r26, 0x01 //absolute mode
002c28 f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_absolute
002c29 f069                      	breq sound_driver_instrument_routine_channel2_arpeggio_process_fixed
002c2a c00e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute:
002c2b 91a0 2812                 	lds r26, triangle_note //load the current note index
002c2d 0fab                      	add r26, r27 //offset the note with the arpeggio data
002c2e fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002c2f c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_add:
002c30 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002c31 f0c0                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
002c32 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002c33 c016                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract:
002c34 fda7                      	sbrc r26, 7 //check if result is negative
002c35 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002c36 c013                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_fixed:
002c37 2fab                      	mov r26, r27 //move the arpeggio data into r26
002c38 c011                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative:
002c39 91a0 2812                 	lds r26, triangle_note //load the current note index
002c3b 0fab                      	add r26, r27 //offset the note with the arpeggio data
002c3c fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002c3d c008                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_add:
002c3e 93a0 2812                 	sts triangle_note, r26 //NOTE: relative mode modifies the original note index
002c40 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002c41 f040                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
002c42 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002c43 93a0 2812                 	sts triangle_note, r26
002c45 c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract:
002c46 fda7                      	sbrc r26, 7 //check if result is negative
002c47 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002c48 93a0 2812                 	sts triangle_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_load:
002c4a e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
002c4b e0f0                      	ldi ZH, HIGH(note_table << 1)
002c4c 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002c4d 0fea                      	add ZL, r26 //add offset
002c4e 1df2                      	adc ZH, zero
002c4f 91a5                      	lpm r26, Z+ //load bytes
002c50 91b4                      	lpm r27, Z
002c51 93a0 0aac                 	sts TCB2_CCMPL, r26 //load the LOW bits for timer
002c53 93b0 0aad                 	sts TCB2_CCMPH, r27 //load the HIGH bits for timer
002c55 93a0 28f4                 	sts triangle_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002c57 93b0 28f5                 	sts triangle_fx_3xx_target+1, r27
002c59 c000                      	rjmp sound_driver_instrument_routine_channel2_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch:
002c5a 91e0 28d8                 	lds ZL, triangle_pitch_macro
002c5c 91f0 28d9                 	lds ZH, triangle_pitch_macro+1
002c5e 9630                      	adiw Z, 0
002c5f f409                      	brne sound_driver_instrument_routine_channel2_pitch_continue
002c60 c023                      	rjmp sound_driver_instrument_routine_channel2_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel2_pitch_continue:
002c61 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002c62 1fff                      	rol ZH
002c63 91a0 28da                 	lds r26, triangle_pitch_macro_offset
002c65 0fea                      	add ZL, r26
002c66 1df2                      	adc ZH, zero
                                 
002c67 91b0 28dc                 	lds r27, triangle_pitch_macro_release
002c69 17ba                      	cp r27, r26
002c6a f429                      	brne sound_driver_instrument_routine_channel2_pitch_increment //if the current offset is not equal to the release index, increment the offset
002c6b 91a0 28db                 	lds r26, triangle_pitch_macro_loop
002c6d 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002c6e f010                      	brlo sound_driver_instrument_routine_channel2_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002c6f c003                      	rjmp sound_driver_instrument_routine_channel2_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_pitch_increment:
002c70 95a3                      	inc r26 //increment the macro offset
002c71 93a0 28da                 	sts triangle_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_pitch_read:
002c73 91b4                      	lpm r27, Z //load pitch data into r27
002c74 38b0                      	cpi r27, 0x80 //check for macro end flag
002c75 f479                      	brne sound_driver_instrument_routine_channel2_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_release:
002c76 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002c77 93a0 28da                 	sts triangle_pitch_macro_offset, r26
002c79 91b0 28dc                 	lds r27, triangle_pitch_macro_release
002c7b 3fbf                      	cpi r27, 0xFF
002c7c f439                      	brne sound_driver_instrument_routine_channel2_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_loop:
002c7d 91b0 28db                 	lds r27, triangle_pitch_macro_loop //load the loop index
002c7f 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002c80 f019                      	breq sound_driver_instrument_routine_channel2_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002c81 93b0 28da                 	sts triangle_pitch_macro_offset, r27 //store the loop index into the offset
002c83 cfd6                      	rjmp sound_driver_instrument_routine_channel2_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_default:
002c84 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel2_pitch_calculate:
002c85 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002c86 937f                      	push r23
002c87 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
002c88 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002c89 0367                      	mulsu r22, r23
002c8a 917f                      	pop r23
002c8b 916f                      	pop r22
                                 
002c8c 9416                      	lsr r1 //shift out the fractional bits
002c8d 9407                      	ror r0
002c8e 9416                      	lsr r1
002c8f 9407                      	ror r0
002c90 9416                      	lsr r1
002c91 9407                      	ror r0
002c92 9416                      	lsr r1
002c93 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_check_negative:
002c94 fe13                      	sbrs r1, 3 //check if result was a negative number
002c95 c007                      	rjmp sound_driver_instrument_routine_channel2_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_negative:
002c96 efc0                      	ldi r28, 0xF0
002c97 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_check_divisible_8:
002c98 70b7                      	andi r27, 0b00000111
002c99 f019                      	breq sound_driver_instrument_routine_channel2_pitch_calculate_offset
                                 
002c9a e0b1                      	ldi r27, 0x01
002c9b 0e0b                      	add r0, r27
002c9c 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_offset:
002c9d 91a0 28d6                 	lds r26, triangle_total_pitch_offset
002c9f 91b0 28d7                 	lds r27, triangle_total_pitch_offset+1
002ca1 0e0a                      	add r0, r26
002ca2 1e1b                      	adc r1, r27
002ca3 9200 28d6                 	sts triangle_total_pitch_offset, r0
002ca5 9210 28d7                 	sts triangle_total_pitch_offset+1, r1
002ca7 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
002ca9 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
002cab 0da0                      	add r26, r0 //offset the timer values
002cac 1db1                      	adc r27, r1
                                 	
002cad 91c0 28ec                 	lds r28, triangle_fx_1xx_total
002caf 91d0 28ed                 	lds r29, triangle_fx_1xx_total+1
002cb1 1bac                      	sub r26, r28
002cb2 0bbd                      	sbc r27, r29
002cb3 91c0 28f0                 	lds r28, triangle_fx_2xx_total
002cb5 91d0 28f1                 	lds r29, triangle_fx_2xx_total+1
002cb7 0fac                      	add r26, r28
002cb8 1fbd                      	adc r27, r29
002cb9 91c0 28ff                 	lds r28, triangle_fx_Pxx_total
002cbb 91d0 2900                 	lds r29, triangle_fx_Pxx_total+1
002cbd 0fac                      	add r26, r28
002cbe 1fbd                      	adc r27, r29
002cbf 91c0 2906                 	lds r28, triangle_fx_Qxy_total_offset
002cc1 91d0 2907                 	lds r29, triangle_fx_Qxy_total_offset+1
002cc3 1bac                      	sub r26, r28
002cc4 0bbd                      	sbc r27, r29
002cc5 91c0 290d                 	lds r28, triangle_fx_Rxy_total_offset
002cc7 91d0 290e                 	lds r29, triangle_fx_Rxy_total_offset+1
002cc9 0fac                      	add r26, r28
002cca 1fbd                      	adc r27, r29
                                 
002ccb e5c9                      	ldi r28, 0x59
002ccc e0d0                      	ldi r29, 0x00
002ccd 17ac                      	cp r26, r28
002cce 07bd                      	cpc r27, r29
002ccf f030                      	brlo sound_driver_instrument_routine_channel2_pitch_min
                                 
002cd0 e5ca                      	ldi r28, 0x5A
002cd1 e5d9                      	ldi r29, 0x59
002cd2 17ac                      	cp r26, r28
002cd3 07bd                      	cpc r27, r29
002cd4 f420                      	brsh sound_driver_instrument_routine_channel2_pitch_max
002cd5 c006                      	rjmp sound_driver_instrument_routine_channel2_pitch_store
                                 
                                 sound_driver_instrument_routine_channel2_pitch_min:
002cd6 e5c9                      	ldi r28, 0x59
002cd7 e0d0                      	ldi r29, 0x00
002cd8 c003                      	rjmp sound_driver_instrument_routine_channel2_pitch_store
                                 
                                 sound_driver_instrument_routine_channel2_pitch_max:
002cd9 e5c9                      	ldi r28, 0x59
002cda e5d9                      	ldi r29, 0x59
002cdb c000                      	rjmp sound_driver_instrument_routine_channel2_pitch_store
                                 
                                 sound_driver_instrument_routine_channel2_pitch_store:
002cdc 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
002cde 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel2_hi_pitch:
002ce0 91e0 28de                 	lds ZL, triangle_hi_pitch_macro
002ce2 91f0 28df                 	lds ZH, triangle_hi_pitch_macro+1
002ce4 9630                      	adiw Z, 0
002ce5 f409                      	brne sound_driver_instrument_routine_channel2_hi_pitch_continue
002ce6 c03c                      	rjmp sound_driver_instrument_routine_channel2_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel2_hi_pitch_continue:
002ce7 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002ce8 1fff                      	rol ZH
002ce9 91a0 28e0                 	lds r26, triangle_hi_pitch_macro_offset
002ceb 0fea                      	add ZL, r26
002cec 1df2                      	adc ZH, zero
                                 
002ced 91b0 28e2                 	lds r27, triangle_hi_pitch_macro_release
002cef 17ba                      	cp r27, r26
002cf0 f429                      	brne sound_driver_instrument_routine_channel2_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002cf1 91a0 28e1                 	lds r26, triangle_hi_pitch_macro_loop
002cf3 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002cf4 f010                      	brlo sound_driver_instrument_routine_channel2_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002cf5 c003                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_increment:
002cf6 95a3                      	inc r26 //increment the macro offset
002cf7 93a0 28e0                 	sts triangle_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_hi_pitch_read:
002cf9 91b4                      	lpm r27, Z //load hi pitch data into r27
002cfa 38b0                      	cpi r27, 0x80 //check for macro end flag
002cfb f489                      	brne sound_driver_instrument_routine_channel2_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_release:
002cfc 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002cfd 93a0 28e0                 	sts triangle_hi_pitch_macro_offset, r26
002cff 91b0 28e2                 	lds r27, triangle_hi_pitch_macro_release
002d01 3fbf                      	cpi r27, 0xFF
002d02 f439                      	brne sound_driver_instrument_routine_channel2_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_loop:
002d03 91b0 28e1                 	lds r27, triangle_hi_pitch_macro_loop //load the loop index
002d05 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002d06 f019                      	breq sound_driver_instrument_routine_channel2_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002d07 93b0 28e0                 	sts triangle_hi_pitch_macro_offset, r27 //store the loop index into the offset
002d09 cfd6                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_default:
002d0a 91b0 28dd                 	lds r27, triangle_total_hi_pitch_offset
002d0c c005                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate:
002d0d 91a0 28dd                 	lds r26, triangle_total_hi_pitch_offset //load the total hi pitch offset to change
002d0f 0fba                      	add r27, r26
002d10 93b0 28dd                 	sts triangle_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply:
002d12 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002d13 937f                      	push r23
002d14 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002d15 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002d16 0367                      	mulsu r22, r23
002d17 917f                      	pop r23
002d18 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_offset:
002d19 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
002d1b 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
002d1d 0da0                      	add r26, r0 //offset the timer values
002d1e 1db1                      	adc r27, r1
002d1f 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
002d21 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: The triangle channel does not have a duty cycle
                                 sound_driver_instrument_routine_channel2_duty:
                                 
                                 
                                 
                                 sound_driver_channel2_fx_routines:
                                 sound_driver_channel2_fx_1xx_routine:
002d23 91e0 28ea                 	lds ZL, triangle_fx_1xx
002d25 91f0 28eb                 	lds ZH, triangle_fx_1xx+1
002d27 9630                      	adiw Z, 0
002d28 f051                      	breq sound_driver_channel2_fx_2xx_routine
                                 
002d29 91a0 28ec                 	lds r26, triangle_fx_1xx_total //load the rate to change the pitch by
002d2b 91b0 28ed                 	lds r27, triangle_fx_1xx_total+1
002d2d 0fae                      	add r26, ZL //increase the total offset by the rate
002d2e 1fbf                      	adc r27, ZH
002d2f 93a0 28ec                 	sts triangle_fx_1xx_total, r26
002d31 93b0 28ed                 	sts triangle_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_2xx_routine:
002d33 91e0 28ee                 	lds ZL, triangle_fx_2xx
002d35 91f0 28ef                 	lds ZH, triangle_fx_2xx+1
002d37 9630                      	adiw Z, 0
002d38 f051                      	breq sound_driver_channel2_fx_3xx_routine
                                 
002d39 91a0 28f0                 	lds r26, triangle_fx_2xx_total //load the rate to change the pitch by
002d3b 91b0 28f1                 	lds r27, triangle_fx_2xx_total+1
002d3d 0fae                      	add r26, ZL //increase the total offset by the rate
002d3e 1fbf                      	adc r27, ZH
002d3f 93a0 28f0                 	sts triangle_fx_2xx_total, r26
002d41 93b0 28f1                 	sts triangle_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_3xx_routine:
002d43 91e0 28f6                 	lds ZL, triangle_fx_3xx_speed
002d45 91f0 28f7                 	lds ZH, triangle_fx_3xx_speed+1
002d47 9630                      	adiw Z, 0
002d48 f409                      	brne sound_driver_channel2_fx_3xx_routine_check_start
002d49 c048                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_check_start:
002d4a 91a0 28f2                 	lds r26, triangle_fx_3xx_start
002d4c 91b0 28f3                 	lds r27, triangle_fx_3xx_start+1
002d4e 9610                      	adiw r26:r27, 0
002d4f f409                      	brne sound_driver_channel2_fx_3xx_routine_main
002d50 c041                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_main:
002d51 91c0 28f4                 	lds r28, triangle_fx_3xx_target
002d53 91d0 28f5                 	lds r29, triangle_fx_3xx_target+1
                                 
002d55 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
002d56 07bd                      	cpc r27, r29
002d57 f011                      	breq sound_driver_channel2_fx_3xx_routine_disable
002d58 f030                      	brlo sound_driver_channel2_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002d59 c01f                      	rjmp sound_driver_channel2_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel2_fx_3xx_routine_disable:
002d5a 9220 28f2                 	sts triangle_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002d5c 9220 28f3                 	sts triangle_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002d5e c033                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_subtract:
002d5f 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002d60 0bdb                      	sbc r29, r27
002d61 91a0 28f8                 	lds r26, triangle_fx_3xx_total_offset
002d63 91b0 28f9                 	lds r27, triangle_fx_3xx_total_offset+1
                                 
002d65 0fae                      	add r26, ZL //add the speed to the total offset
002d66 1fbf                      	adc r27, ZH
002d67 1bca                      	sub r28, r26 //invert the total difference with the total offset
002d68 0bdb                      	sbc r29, r27
002d69 f380                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002d6a 93a0 28f8                 	sts triangle_fx_3xx_total_offset, r26 //store the new total offset
002d6c 93b0 28f9                 	sts triangle_fx_3xx_total_offset+1, r27
                                 
002d6e 91a0 0aac                 	lds r26, TCB2_CCMPL //load the current timer period
002d70 91b0 0aad                 	lds r27, TCB2_CCMPH
002d72 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002d73 0bbd                      	sbc r27, r29
002d74 93a0 0aac                 	sts TCB2_CCMPL, r26
002d76 93b0 0aad                 	sts TCB2_CCMPH, r27
002d78 c019                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_add:
002d79 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002d7a 0bbd                      	sbc r27, r29
002d7b 91c0 28f8                 	lds r28, triangle_fx_3xx_total_offset
002d7d 91d0 28f9                 	lds r29, triangle_fx_3xx_total_offset+1
                                 
002d7f 0fce                      	add r28, ZL //add the speed to the total offset
002d80 1fdf                      	adc r29, ZH
002d81 1bac                      	sub r26, r28 //invert the total difference with the total offset
002d82 0bbd                      	sbc r27, r29
002d83 f2b0                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002d84 93c0 28f8                 	sts triangle_fx_3xx_total_offset, r28 //store the new total offset
002d86 93d0 28f9                 	sts triangle_fx_3xx_total_offset+1, r29
                                 
002d88 91c0 0aac                 	lds r28, TCB2_CCMPL //load the current timer period
002d8a 91d0 0aad                 	lds r29, TCB2_CCMPH
002d8c 0fca                      	add r28, r26 //offset the current timer period with the total offset
002d8d 1fdb                      	adc r29, r27
002d8e 93c0 0aac                 	sts TCB2_CCMPL, r28
002d90 93d0 0aad                 	sts TCB2_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel2_fx_4xy_routine:
002d92 91a0 28fa                 	lds r26, triangle_fx_4xy_speed
002d94 15a2                      	cp r26, zero
002d95 f409                      	brne sound_driver_channel2_fx_4xy_routine_continue
002d96 c05c                      	rjmp sound_driver_channel2_fx_Qxy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel2_fx_4xy_routine_continue:
002d97 91b0 28fb                 	lds r27, triangle_fx_4xy_depth
002d99 91c0 28fc                 	lds r28, triangle_fx_4xy_phase
002d9b 0fca                      	add r28, r26 //increase the phase by the speed
002d9c 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002d9d f008                      	brlo sound_driver_channel2_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002d9e e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase:
002d9f 93c0 28fc                 	sts triangle_fx_4xy_phase, r28 //store the new phase
002da1 31c0                      	cpi r28, 16
002da2 f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_0
002da3 32c0                      	cpi r28, 32
002da4 f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_1
002da5 33c0                      	cpi r28, 48
002da6 f030                      	brlo sound_driver_channel2_fx_4xy_routine_phase_2
002da7 c007                      	rjmp sound_driver_channel2_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_0:
002da8 70cf                      	andi r28, 0x0F //mask for values 0-15
002da9 c029                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_1:
002daa 6fc0                      	ori r28, 0xF0
002dab 95c0                      	com r28 //invert values 0-15
002dac c026                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_2:
002dad 70cf                      	andi r28, 0x0F //mask for values 0-15
002dae c003                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_3:
002daf 6fc0                      	ori r28, 0xF0
002db0 95c0                      	com r28 //invert values 0-15
002db1 c000                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_add:
002db2 95b2                      	swap r27 //multiply depth by 16
002db3 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002db4 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002db5 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002db6 0fec                      	add ZL, r28 //offset the table by the depth+phase
002db7 1df2                      	adc ZH, zero
002db8 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002db9 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002dba 937f                      	push r23
002dbb 2f6c                      	mov r22, r28 //store the vibrato value into r22
002dbc eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002dbd 9f67                      	mul r22, r23
002dbe 917f                      	pop r23
002dbf 916f                      	pop r22
                                 
002dc0 9416                      	lsr r1 //shift out the fractional bits
002dc1 9407                      	ror r0
002dc2 9416                      	lsr r1
002dc3 9407                      	ror r0
002dc4 9416                      	lsr r1
002dc5 9407                      	ror r0
002dc6 9416                      	lsr r1
002dc7 9407                      	ror r0
                                 	
002dc8 91a0 0aac                 	lds r26, TCB2_CCMPL
002dca 91b0 0aad                 	lds r27, TCB2_CCMPH
002dcc 0da0                      	add r26, r0
002dcd 1db1                      	adc r27, r1
002dce 93a0 0aac                 	sts TCB2_CCMPL, r26
002dd0 93b0 0aad                 	sts TCB2_CCMPH, r27
002dd2 c020                      	rjmp sound_driver_channel2_fx_Qxy_routine
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_subtract:
002dd3 95b2                      	swap r27 //multiply depth by 16
002dd4 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002dd5 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002dd6 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002dd7 0fec                      	add ZL, r28 //offset the table by the depth+phase
002dd8 1df2                      	adc ZH, zero
002dd9 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002dda 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002ddb 937f                      	push r23
002ddc 2f6c                      	mov r22, r28 //store the vibrato value into r22
002ddd eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002dde 9f67                      	mul r22, r23
002ddf 917f                      	pop r23
002de0 916f                      	pop r22
                                 
002de1 9416                      	lsr r1 //shift out the fractional bits
002de2 9407                      	ror r0
002de3 9416                      	lsr r1
002de4 9407                      	ror r0
002de5 9416                      	lsr r1
002de6 9407                      	ror r0
002de7 9416                      	lsr r1
002de8 9407                      	ror r0
                                 
002de9 91a0 0aac                 	lds r26, TCB2_CCMPL
002deb 91b0 0aad                 	lds r27, TCB2_CCMPH
002ded 19a0                      	sub r26, r0
002dee 09b1                      	sbc r27, r1
002def 93a0 0aac                 	sts TCB2_CCMPL, r26
002df1 93b0 0aad                 	sts TCB2_CCMPH, r27
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel2_fx_Qxy_routine:
002df3 91e0 2902                 	lds ZL, triangle_fx_Qxy_target
002df5 91f0 2903                 	lds ZH, triangle_fx_Qxy_target+1
002df7 9630                      	adiw Z, 0
002df8 f119                      	breq sound_driver_channel2_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002df9 91a0 2906                 	lds r26, triangle_fx_Qxy_total_offset
002dfb 91b0 2907                 	lds r27, triangle_fx_Qxy_total_offset+1
002dfd 91c0 0aac                 	lds r28, TCB2_CCMPL
002dff 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
002e01 1bec                      	sub ZL, r28 //calculate the difference to the target
002e02 0bfd                      	sbc ZH, r29
002e03 f408                      	brsh sound_driver_channel2_fx_Qxy_routine_end //if the target has been reached (or passed)
002e04 f068                      	brlo sound_driver_channel2_fx_Qxy_routine_add
                                 
                                 sound_driver_channel2_fx_Qxy_routine_end:
002e05 9220 2906                 	sts triangle_fx_Qxy_total_offset, zero //turn off the effect
002e07 9220 2907                 	sts triangle_fx_Qxy_total_offset+1, zero
002e09 9220 2902                 	sts triangle_fx_Qxy_target, zero
002e0b 9220 2903                 	sts triangle_fx_Qxy_target+1, zero
002e0d 91b0 2901                 	lds r27, triangle_fx_Qxy_target_note
002e0f 93b0 2812                 	sts triangle_note, r27 //replace the note with the final target note
002e11 c00a                      	rjmp sound_driver_channel2_fx_Rxy_routine
                                 
                                 sound_driver_channel2_fx_Qxy_routine_add:
002e12 91c0 2904                 	lds r28, triangle_fx_Qxy_speed
002e14 91d0 2905                 	lds r29, triangle_fx_Qxy_speed+1
002e16 0fac                      	add r26, r28 //increase the total offset by the speed
002e17 1fbd                      	adc r27, r29
002e18 93a0 2906                 	sts triangle_fx_Qxy_total_offset, r26 //store the total offset
002e1a 93b0 2907                 	sts triangle_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_Rxy_routine:
002e1c 91e0 2909                 	lds ZL, triangle_fx_Rxy_target
002e1e 91f0 290a                 	lds ZH, triangle_fx_Rxy_target+1
002e20 9630                      	adiw Z, 0
002e21 f119                      	breq sound_driver_instrument_routine_channel3_volume //if the effect is not enabled, skip the routine
                                 
002e22 91a0 290d                 	lds r26, triangle_fx_Rxy_total_offset
002e24 91b0 290e                 	lds r27, triangle_fx_Rxy_total_offset+1
002e26 91c0 0aac                 	lds r28, TCB2_CCMPL
002e28 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
002e2a 1bce                      	sub r28, ZL //calculate the difference to the target
002e2b 0bdf                      	sbc r29, ZH
002e2c f408                      	brsh sound_driver_channel2_fx_Rxy_routine_end //if the target has been reached (or passed)
002e2d f068                      	brlo sound_driver_channel2_fx_Rxy_routine_add
                                 
                                 sound_driver_channel2_fx_Rxy_routine_end:
002e2e 9220 290d                 	sts triangle_fx_Rxy_total_offset, zero //disable the effect
002e30 9220 290e                 	sts triangle_fx_Rxy_total_offset+1, zero
002e32 9220 2909                 	sts triangle_fx_Rxy_target, zero
002e34 9220 290a                 	sts triangle_fx_Rxy_target+1, zero
002e36 91b0 2908                 	lds r27, triangle_fx_Rxy_target_note
002e38 93b0 2812                 	sts triangle_note, r27 //replace the note with the final target note
002e3a c00a                      	rjmp sound_driver_instrument_routine_channel3_volume
                                 
                                 sound_driver_channel2_fx_Rxy_routine_add:
002e3b 91c0 290b                 	lds r28, triangle_fx_Rxy_speed
002e3d 91d0 290c                 	lds r29, triangle_fx_Rxy_speed+1
002e3f 0fac                      	add r26, r28 //increase the total offset by the speed
002e40 1fbd                      	adc r27, r29
002e41 93a0 290d                 	sts triangle_fx_Rxy_total_offset, r26 //store the total offset
002e43 93b0 290e                 	sts triangle_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume:
002e45 91e0 2917                 	lds ZL, noise_volume_macro
002e47 91f0 2918                 	lds ZH, noise_volume_macro+1
002e49 9630                      	adiw Z, 0
002e4a f1a1                      	breq sound_driver_instrument_routine_channel3_volume_default //if no volume macro is in use, use default multiplier of F
002e4b 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002e4c 1fff                      	rol ZH
002e4d 91a0 2919                 	lds r26, noise_volume_macro_offset
002e4f 0fea                      	add ZL, r26
002e50 1df2                      	adc ZH, zero
                                 
002e51 91b0 291b                 	lds r27, noise_volume_macro_release
002e53 17ba                      	cp r27, r26
002e54 f429                      	brne sound_driver_instrument_routine_channel3_volume_increment //if the current offset is not equal to the release index, increment the offset
002e55 91a0 291a                 	lds r26, noise_volume_macro_loop
002e57 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002e58 f010                      	brlo sound_driver_instrument_routine_channel3_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002e59 c003                      	rjmp sound_driver_instrument_routine_channel3_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_volume_increment:
002e5a 95a3                      	inc r26 //increment the macro offset
002e5b 93a0 2919                 	sts noise_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_volume_read:
002e5d 91b4                      	lpm r27, Z //load volume data into r27
002e5e 3fbf                      	cpi r27, 0xFF //check for macro end flag
002e5f f469                      	brne sound_driver_instrument_routine_channel3_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_check_release:
002e60 91b0 291b                 	lds r27, noise_volume_macro_release
002e62 3fbf                      	cpi r27, 0xFF
002e63 f429                      	brne sound_driver_instrument_routine_channel3_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_check_loop:
002e64 91b0 291a                 	lds r27, noise_volume_macro_loop //load the loop index
002e66 93b0 2919                 	sts noise_volume_macro_offset, r27 //store the loop index into the offset
002e68 cfdc                      	rjmp sound_driver_instrument_routine_channel3_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_last_index:
002e69 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002e6a 93a0 2919                 	sts noise_volume_macro_offset, r26
002e6c cfd8                      	rjmp sound_driver_instrument_routine_channel3_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume_calculate:
002e6d e0e4                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
002e6e e6f2                      	ldi ZH, HIGH(volumes << 1)
002e6f 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
002e70 0feb                      	add ZL, r27 //add offset to the table
002e71 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel3_volume_load:
002e72 91b0 2813                 	lds r27, noise_param //load main volume
002e74 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002e75 91a0 2941                 	lds r26, noise_fx_7xy_value
002e77 30a0                      	cpi r26, 0x00
002e78 f481                      	brne sound_driver_instrument_routine_channel3_volume_load_7xy
                                 
002e79 0feb                      	add ZL, r27 //offset the volume table by the main volume
002e7a 1df2                      	adc ZH, zero
002e7b 91b4                      	lpm r27, Z
002e7c 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002e7e c023                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_default:
002e7f 91b0 2813                 	lds r27, noise_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
002e81 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002e82 91a0 2941                 	lds r26, noise_fx_7xy_value
002e84 30a0                      	cpi r26, 0x00
002e85 f499                      	brne sound_driver_instrument_routine_channel3_volume_default_7xy
002e86 93b0 2816                 	sts noise_output_volume, r27
002e88 c019                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_load_7xy:
002e89 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002e8a f038                      	brcs sound_driver_instrument_routine_channel3_volume_load_7xy_overflow
002e8b f031                      	breq sound_driver_instrument_routine_channel3_volume_load_7xy_overflow
                                 
002e8c 0feb                      	add ZL, r27 //offset the volume table by the main volume
002e8d 1df2                      	adc ZH, zero
002e8e 91b4                      	lpm r27, Z
002e8f 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002e91 c010                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_load_7xy_overflow:
002e92 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002e93 0feb                      	add ZL, r27 //offset the volume table by the main volume
002e94 1df2                      	adc ZH, zero
002e95 91b4                      	lpm r27, Z
002e96 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002e98 c009                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_default_7xy:
002e99 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002e9a f020                      	brcs sound_driver_instrument_routine_channel3_volume_default_7xy_overflow
002e9b f019                      	breq sound_driver_instrument_routine_channel3_volume_default_7xy_overflow
002e9c 93b0 2816                 	sts noise_output_volume, r27
002e9e c003                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel3_volume_default_7xy_overflow:
002e9f e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002ea0 93b0 2816                 	sts noise_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002ea2 91e0 291c                 	lds ZL, noise_arpeggio_macro
002ea4 91f0 291d                 	lds ZH, noise_arpeggio_macro+1
002ea6 9630                      	adiw Z, 0
002ea7 f1d9                      	breq sound_driver_instrument_routine_channel3_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002ea8 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002ea9 1fff                      	rol ZH
002eaa 91a0 291e                 	lds r26, noise_arpeggio_macro_offset
002eac 0fea                      	add ZL, r26
002ead 1df2                      	adc ZH, zero
                                 
002eae 91b0 2920                 	lds r27, noise_arpeggio_macro_release
002eb0 17ba                      	cp r27, r26
002eb1 f429                      	brne sound_driver_instrument_routine_channel3_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002eb2 91a0 291f                 	lds r26, noise_arpeggio_macro_loop
002eb4 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002eb5 f010                      	brlo sound_driver_instrument_routine_channel3_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002eb6 c003                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_increment:
002eb7 95a3                      	inc r26 //increment the macro offset
002eb8 93a0 291e                 	sts noise_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_arpeggio_read:
002eba 91b4                      	lpm r27, Z //load arpeggio data into r27
002ebb 38b0                      	cpi r27, 0x80 //check for macro end flag
002ebc f009                      	breq sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag
002ebd c041                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_check_mode:
002ebe 50a1                      	subi r26, 1 //keep the offset at the end flag
002ebf 93a0 291e                 	sts noise_arpeggio_macro_offset, r26
002ec1 91b0 2921                 	lds r27, noise_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002ec3 30b1                      	cpi r27, 0x01
002ec4 f048                      	brlo sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_fixed_relative_check_release:
002ec5 91b0 2920                 	lds r27, noise_arpeggio_macro_release
002ec7 3fbf                      	cpi r27, 0xFF
002ec8 f4d1                      	brne sound_driver_instrument_routine_channel3_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_fixed_relative_check_loop:
002ec9 91b0 291f                 	lds r27, noise_arpeggio_macro_loop
002ecb 3fbf                      	cpi r27, 0xFF
002ecc f499                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002ecd c015                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute:
002ece 91b0 2920                 	lds r27, noise_arpeggio_macro_release
002ed0 3fbf                      	cpi r27, 0xFF
002ed1 f421                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_check_loop:
002ed2 91b0 291f                 	lds r27, noise_arpeggio_macro_loop //load the loop index
002ed4 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002ed5 f451                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_no_loop:
002ed6 91c0 2934                 	lds r28, noise_fx_0xy_sequence //check for 0xy effect
002ed8 91d0 2935                 	lds r29, noise_fx_0xy_sequence+1
002eda 9620                      	adiw r29:r28, 0
002edb f469                      	brne sound_driver_instrument_routine_channel3_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002edc 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002edd 93a0 291e                 	sts noise_arpeggio_macro_offset, r26 //store the last valid index into the offset
002edf cfc2                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload:
002ee0 93b0 291e                 	sts noise_arpeggio_macro_offset, r27 //store the loop index into the offset
002ee2 cfbf                      	rjmp sound_driver_instrument_routine_channel3_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_default:
002ee3 91c0 2934                 	lds r28, noise_fx_0xy_sequence //load 0xy effect
002ee5 91d0 2935                 	lds r29, noise_fx_0xy_sequence+1
002ee7 9620                      	adiw r29:r28, 0 //check for 0xy effect
002ee8 f099                      	breq sound_driver_instrument_routine_channel3_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel3_arpeggio_default_0xy:
002ee9 95d6                      	lsr r29
002eea 95c7                      	ror r28
002eeb 95d7                      	ror r29
002eec 95c7                      	ror r28
002eed 95d7                      	ror r29
002eee 95c7                      	ror r28
002eef 95d7                      	ror r29
002ef0 95c7                      	ror r28
002ef1 95d7                      	ror r29
002ef2 95d2                      	swap r29
                                 
002ef3 93c0 2934                 	sts noise_fx_0xy_sequence, r28 //store the rolled sequence
002ef5 93d0 2935                 	sts noise_fx_0xy_sequence+1, r29
002ef7 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002ef8 91a0 2817                 	lds r26, noise_note //load the current note index
002efa 0fac                      	add r26, r28 //add the note offset
002efb c01c                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel3_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002efc 91a0 2817                 	lds r26, noise_note //load the current note index
002efe c019                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process:
002eff 9220 2922                 	sts noise_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002f01 9220 2923                 	sts noise_total_pitch_offset+1, zero
002f03 9220 2929                 	sts noise_total_hi_pitch_offset, zero
002f05 91a0 2921                 	lds r26, noise_arpeggio_macro_mode
002f07 30a1                      	cpi r26, 0x01 //absolute mode
002f08 f010                      	brlo sound_driver_instrument_routine_channel3_arpeggio_process_absolute
002f09 f031                      	breq sound_driver_instrument_routine_channel3_arpeggio_process_fixed
002f0a c007                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_absolute:
002f0b 91a0 2817                 	lds r26, noise_note //load the current note index
002f0d 0fab                      	add r26, r27 //offset the note with the arpeggio data
002f0e 70af                      	andi r26, 0x0F //keep only bits 0-3 in case there was overflow
002f0f c008                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_fixed:
002f10 2fab                      	mov r26, r27 //move the arpeggio data into r26
002f11 c006                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_relative:
002f12 91a0 2817                 	lds r26, noise_note //load the current note index
002f14 0fab                      	add r26, r27 //offset the note with the arpeggio data
002f15 70af                      	andi r26, 0x0F //keep only bits 0-3 in case there was overflow
002f16 93a0 2817                 	sts noise_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_load:
002f18 93a0 2818                 	sts noise_adjusted_note, r26
002f1a c000                      	rjmp sound_driver_instrument_routine_channel3_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch:
002f1b 91e0 2924                 	lds ZL, noise_pitch_macro
002f1d 91f0 2925                 	lds ZH, noise_pitch_macro+1
002f1f 9630                      	adiw Z, 0
002f20 f409                      	brne sound_driver_instrument_routine_channel3_pitch_continue
002f21 c023                      	rjmp sound_driver_instrument_routine_channel3_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel3_pitch_continue:
002f22 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002f23 1fff                      	rol ZH
002f24 91a0 2926                 	lds r26, noise_pitch_macro_offset
002f26 0fea                      	add ZL, r26
002f27 1df2                      	adc ZH, zero
                                 
002f28 91b0 2928                 	lds r27, noise_pitch_macro_release
002f2a 17ba                      	cp r27, r26
002f2b f429                      	brne sound_driver_instrument_routine_channel3_pitch_increment //if the current offset is not equal to the release index, increment the offset
002f2c 91a0 2927                 	lds r26, noise_pitch_macro_loop
002f2e 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002f2f f010                      	brlo sound_driver_instrument_routine_channel3_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002f30 c003                      	rjmp sound_driver_instrument_routine_channel3_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_pitch_increment:
002f31 95a3                      	inc r26 //increment the macro offset
002f32 93a0 2926                 	sts noise_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_pitch_read:
002f34 91b4                      	lpm r27, Z //load pitch data into r27
002f35 38b0                      	cpi r27, 0x80 //check for macro end flag
002f36 f479                      	brne sound_driver_instrument_routine_channel3_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag_check_release:
002f37 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002f38 93a0 2926                 	sts noise_pitch_macro_offset, r26
002f3a 91b0 2928                 	lds r27, noise_pitch_macro_release
002f3c 3fbf                      	cpi r27, 0xFF
002f3d f439                      	brne sound_driver_instrument_routine_channel3_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag_check_loop:
002f3e 91b0 2927                 	lds r27, noise_pitch_macro_loop //load the loop index
002f40 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002f41 f019                      	breq sound_driver_instrument_routine_channel3_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002f42 93b0 2926                 	sts noise_pitch_macro_offset, r27 //store the loop index into the offset
002f44 cfd6                      	rjmp sound_driver_instrument_routine_channel3_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch_default:
002f45 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel3_pitch_calculate:
                                 sound_driver_instrument_routine_channel3_pitch_calculate_offset:
002f46 91a0 2922                 	lds r26, noise_total_pitch_offset
002f48 0fba                      	add r27, r26
002f49 93b0 2922                 	sts noise_total_pitch_offset, r27
002f4b 91a0 2818                 	lds r26, noise_adjusted_note
002f4d 1bab                      	sub r26, r27
                                 	
002f4e 91b0 2937                 	lds r27, noise_fx_1xx_total
002f50 0fab                      	add r26, r27
002f51 91b0 2939                 	lds r27, noise_fx_2xx_total
002f53 1bab                      	sub r26, r27
002f54 91b0 293d                 	lds r27, noise_fx_4xy_offset
002f56 1bab                      	sub r26, r27
002f57 91b0 2945                 	lds r27, noise_fx_Pxx_total
002f59 1bab                      	sub r26, r27
                                 
002f5a 70af                      	andi r26, 0x0F
                                 
002f5b e4e2                      	ldi ZL, LOW(noise_period_table << 1) //load in note table
002f5c e0f1                      	ldi ZH, HIGH(noise_period_table << 1)
002f5d 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002f5e 0fea                      	add ZL, r26 //add offset
002f5f 1df2                      	adc ZH, zero
002f60 91a5                      	lpm r26, Z+ //load bytes
002f61 91b4                      	lpm r27, Z
002f62 93a0 0abc                 	sts TCB3_CCMPL, r26 //load the LOW bits for timer
002f64 93b0 0abd                 	sts TCB3_CCMPH, r27 //load the HIGH bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel3_hi_pitch:
002f66 91e0 292a                 	lds ZL, noise_hi_pitch_macro
002f68 91f0 292b                 	lds ZH, noise_hi_pitch_macro+1
002f6a 9630                      	adiw Z, 0
002f6b f409                      	brne sound_driver_instrument_routine_channel3_hi_pitch_continue
002f6c c03c                      	rjmp sound_driver_instrument_routine_channel3_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel3_hi_pitch_continue:
002f6d 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002f6e 1fff                      	rol ZH
002f6f 91a0 292c                 	lds r26, noise_hi_pitch_macro_offset
002f71 0fea                      	add ZL, r26
002f72 1df2                      	adc ZH, zero
                                 
002f73 91b0 292e                 	lds r27, noise_hi_pitch_macro_release
002f75 17ba                      	cp r27, r26
002f76 f429                      	brne sound_driver_instrument_routine_channel3_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002f77 91a0 292d                 	lds r26, noise_hi_pitch_macro_loop
002f79 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002f7a f010                      	brlo sound_driver_instrument_routine_channel3_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002f7b c003                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_increment:
002f7c 95a3                      	inc r26 //increment the macro offset
002f7d 93a0 292c                 	sts noise_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_hi_pitch_read:
002f7f 91b4                      	lpm r27, Z //load hi pitch data into r27
002f80 38b0                      	cpi r27, 0x80 //check for macro end flag
002f81 f489                      	brne sound_driver_instrument_routine_channel3_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag_check_release:
002f82 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002f83 93a0 292c                 	sts noise_hi_pitch_macro_offset, r26
002f85 91b0 292e                 	lds r27, noise_hi_pitch_macro_release
002f87 3fbf                      	cpi r27, 0xFF
002f88 f439                      	brne sound_driver_instrument_routine_channel3_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag_check_loop:
002f89 91b0 292d                 	lds r27, noise_hi_pitch_macro_loop //load the loop index
002f8b 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002f8c f019                      	breq sound_driver_instrument_routine_channel3_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002f8d 93b0 292c                 	sts noise_hi_pitch_macro_offset, r27 //store the loop index into the offset
002f8f cfd6                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_default:
002f90 91b0 2929                 	lds r27, noise_total_hi_pitch_offset
002f92 c005                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate:
002f93 91a0 2929                 	lds r26, noise_total_hi_pitch_offset //load the total hi pitch offset to change
002f95 0fba                      	add r27, r26
002f96 93b0 2929                 	sts noise_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate_multiply:
002f98 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002f99 937f                      	push r23
002f9a 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002f9b eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002f9c 0367                      	mulsu r22, r23
002f9d 917f                      	pop r23
002f9e 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate_offset:
002f9f 91a0 0abc                 	lds r26, TCB3_CCMPL //load the low bits for timer
002fa1 91b0 0abd                 	lds r27, TCB3_CCMPH //load the high bits for timer
002fa3 0da0                      	add r26, r0 //offset the timer values
002fa4 1db1                      	adc r27, r1
002fa5 93a0 0abc                 	sts TCB3_CCMPL, r26 //store the new low bits for timer
002fa7 93b0 0abd                 	sts TCB3_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty:
002fa9 91e0 292f                 	lds ZL, noise_duty_macro
002fab 91f0 2930                 	lds ZH, noise_duty_macro+1
002fad 9630                      	adiw Z, 0
002fae f169                      	breq sound_driver_channel3_fx_routines //if no duty macro is in use, go to the next routine
002faf 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002fb0 1fff                      	rol ZH
002fb1 91a0 2931                 	lds r26, noise_duty_macro_offset
002fb3 0fea                      	add ZL, r26
002fb4 1df2                      	adc ZH, zero
                                 
002fb5 91b0 2933                 	lds r27, noise_duty_macro_release
002fb7 17ba                      	cp r27, r26
002fb8 f429                      	brne sound_driver_instrument_routine_channel3_duty_increment //if the current offset is not equal to the release index, increment the offset
002fb9 91a0 2932                 	lds r26, noise_duty_macro_loop
002fbb 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002fbc f010                      	brlo sound_driver_instrument_routine_channel3_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002fbd c01e                      	rjmp sound_driver_channel3_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel3_duty_increment:
002fbe 95a3                      	inc r26 //increment the macro offset
002fbf 93a0 2931                 	sts noise_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_duty_read:
002fc1 91b4                      	lpm r27, Z //load pitch data into r27
002fc2 3fbf                      	cpi r27, 0xFF //check for macro end flag
002fc3 f471                      	brne sound_driver_instrument_routine_channel3_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag_check_release:
002fc4 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002fc5 93a0 2931                 	sts noise_duty_macro_offset, r26
002fc7 91b0 2933                 	lds r27, noise_duty_macro_release
002fc9 3fbf                      	cpi r27, 0xFF
002fca f489                      	brne sound_driver_channel3_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag_check_loop:
002fcb 91b0 2932                 	lds r27, noise_duty_macro_loop //load the loop index
002fcd 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002fce f069                      	breq sound_driver_channel3_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
002fcf 93b0 2931                 	sts noise_duty_macro_offset, r27 //store the loop index into the offset
002fd1 cfd7                      	rjmp sound_driver_instrument_routine_channel3_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty_load:
002fd2 95b6                      	lsr r27
002fd3 95b7                      	ror r27 //move mode bit to bit 7
002fd4 91c0 2814                 	lds r28, noise_period
002fd6 77cf                      	andi r28, 0b01111111
002fd7 2bcb                      	or r28, r27 //store the new noise mode
002fd8 93c0 2813                 	sts noise_param, r28
                                 
002fda 776f                      	andi noise_sequence_HIGH, 0b01111111
002fdb 2b6b                      	or noise_sequence_HIGH, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_routines:
                                 sound_driver_channel3_fx_1xx_routine:
002fdc 91e0 2936                 	lds ZL, noise_fx_1xx
002fde 30e0                      	cpi ZL, 0
002fdf f029                      	breq sound_driver_channel3_fx_2xx_routine
                                 
002fe0 91a0 2937                 	lds r26, noise_fx_1xx_total //load the rate to change the pitch by
002fe2 0fae                      	add r26, ZL //increase the total offset by the rate
002fe3 93a0 2937                 	sts noise_fx_1xx_total, r26
                                 
                                 
                                 
                                 sound_driver_channel3_fx_2xx_routine:
002fe5 91e0 2938                 	lds ZL, noise_fx_2xx
002fe7 30e0                      	cpi ZL, 0
002fe8 f029                      	breq sound_driver_channel3_fx_3xx_routine
                                 
002fe9 91a0 2939                 	lds r26, noise_fx_2xx_total //load the rate to change the pitch by
002feb 0fae                      	add r26, ZL //increase the total offset by the rate
002fec 93a0 2939                 	sts noise_fx_2xx_total, r26
                                 
                                 
                                 
                                 sound_driver_channel3_fx_3xx_routine:
                                 
                                 
                                 
                                 sound_driver_channel3_fx_4xy_routine:
002fee 91a0 293a                 	lds r26, noise_fx_4xy_speed
002ff0 15a2                      	cp r26, zero
002ff1 f409                      	brne sound_driver_channel3_fx_4xy_routine_continue
002ff2 c033                      	rjmp sound_driver_channel3_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel3_fx_4xy_routine_continue:
002ff3 91b0 293b                 	lds r27, noise_fx_4xy_depth
002ff5 91c0 293c                 	lds r28, noise_fx_4xy_phase
002ff7 0fca                      	add r28, r26 //increase the phase by the speed
002ff8 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002ff9 f008                      	brlo sound_driver_channel3_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002ffa e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase:
002ffb 93c0 293c                 	sts noise_fx_4xy_phase, r28 //store the new phase
002ffd 31c0                      	cpi r28, 16
002ffe f028                      	brlo sound_driver_channel3_fx_4xy_routine_phase_0
002fff 32c0                      	cpi r28, 32
003000 f028                      	brlo sound_driver_channel3_fx_4xy_routine_phase_1
003001 33c0                      	cpi r28, 48
003002 f030                      	brlo sound_driver_channel3_fx_4xy_routine_phase_2
003003 c007                      	rjmp sound_driver_channel3_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_0:
003004 70cf                      	andi r28, 0x0F //mask for values 0-15
003005 c014                      	rjmp sound_driver_channel3_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_1:
003006 6fc0                      	ori r28, 0xF0
003007 95c0                      	com r28 //invert values 0-15
003008 c011                      	rjmp sound_driver_channel3_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_2:
003009 70cf                      	andi r28, 0x0F //mask for values 0-15
00300a c003                      	rjmp sound_driver_channel3_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_3:
00300b 6fc0                      	ori r28, 0xF0
00300c 95c0                      	com r28 //invert values 0-15
00300d c000                      	rjmp sound_driver_channel3_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel3_fx_4xy_routine_load_add:
00300e 95b2                      	swap r27 //multiply depth by 16
00300f 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
003010 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
003011 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
003012 0fec                      	add ZL, r28 //offset the table by the depth+phase
003013 1df2                      	adc ZH, zero
003014 91c4                      	lpm r28, Z //load the tremelo value into r28
003015 95c2                      	swap r28
003016 70cf                      	andi r28, 0x0F
                                 
003017 93c0 293d                 	sts noise_fx_4xy_offset, r28
003019 c00c                      	rjmp sound_driver_channel3_fx_7xy_routine
                                 
                                 sound_driver_channel3_fx_4xy_routine_load_subtract:
00301a 95b2                      	swap r27 //multiply depth by 16
00301b 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
00301c e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00301d e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00301e 0fec                      	add ZL, r28 //offset the table by the depth+phase
00301f 1df2                      	adc ZH, zero
003020 91c4                      	lpm r28, Z //load the vibrato value into r28
003021 95c2                      	swap r28
003022 70cf                      	andi r28, 0x0F
                                 
003023 95c1                      	neg r28
003024 93c0 293d                 	sts noise_fx_4xy_offset, r28
                                 
                                 
                                 
                                 sound_driver_channel3_fx_7xy_routine:
003026 91a0 293e                 	lds r26, noise_fx_7xy_speed
003028 15a2                      	cp r26, zero
003029 f0e9                      	breq sound_driver_channel3_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
00302a 91b0 293f                 	lds r27, noise_fx_7xy_depth
00302c 91c0 2940                 	lds r28, noise_fx_7xy_phase
00302e 0fca                      	add r28, r26 //increase the phase by the speed
00302f 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
003030 f008                      	brlo sound_driver_channel3_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
003031 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel3_fx_7xy_routine_phase:
003032 93c0 2940                 	sts noise_fx_7xy_phase, r28 //store the new phase
003034 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
003035 ffc4                      	sbrs r28, 4
003036 c001                      	rjmp sound_driver_channel3_fx_7xy_routine_phase_0
003037 c002                      	rjmp sound_driver_channel3_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel3_fx_7xy_routine_phase_0:
003038 70cf                      	andi r28, 0x0F //mask for values 0-15
003039 c003                      	rjmp sound_driver_channel3_fx_7xy_routine_load
                                 
                                 sound_driver_channel3_fx_7xy_routine_phase_1:
00303a 6fc0                      	ori r28, 0xF0
00303b 95c0                      	com r28 //invert values 0-15
00303c c000                      	rjmp sound_driver_channel3_fx_7xy_routine_load
                                 
                                 sound_driver_channel3_fx_7xy_routine_load:
00303d 95b2                      	swap r27 //multiply depth by 16
00303e 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
00303f e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
003040 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
003041 0fec                      	add ZL, r28 //offset the table by the depth+phase
003042 1df2                      	adc ZH, zero
003043 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
003044 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
003045 93c0 2941                 	sts noise_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Axy_routine:
003047 91b0 2942                 	lds r27, noise_fx_Axy
003049 15b2                      	cp r27, zero
00304a f0e9                      	breq sound_driver_channel3_fx_Qxy_routine //0 means that the effect is not in use
                                 	
00304b 91a0 2815                 	lds r26, noise_fractional_volume //load fractional volume representation of the channel
00304d 91c0 2813                 	lds r28, noise_param //load the integer volume representation of the channel
00304f 2fda                      	mov r29, r26 //copy fractional volume into r29
003050 2fec                      	mov r30, r28 //copy the noise_param into r30
003051 95e2                      	swap r30
003052 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
003053 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
003054 17ed                      	cp r30, r29 //compare the fractional and integer volumes
003055 f009                      	breq sound_driver_channel3_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel3_fx_Axy_routine_reload:
003056 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate:
003057 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
003058 c004                      	rjmp sound_driver_channel3_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_addition:
003059 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
00305a f428                      	brcc sound_driver_channel3_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
00305b efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
00305c c003                      	rjmp sound_driver_channel3_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_subtraction:
00305d 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
00305e f008                      	brcs sound_driver_channel3_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
00305f e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_store:
003060 93a0 2815                 	sts noise_fractional_volume, r26 //store the new fractional volume
003062 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
003063 95a2                      	swap r26
003064 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
003065 2bca                      	or r28, r26 //store the new volume back into noise_param
003066 93c0 2813                 	sts noise_param, r28
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Qxy_routine:
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Rxy_routine:
                                 
                                 
                                 
                                 sound_driver_exit:
003068 91ff                      	pop r31
003069 91ef                      	pop r30
00306a 91df                      	pop r29
00306b 91cf                      	pop r28
00306c 940c 1613                 	jmp sequence_1_3 + 3 //+3 is to skip the stack instructions since we already pushed them
                                 
                                 
                                 
                                 //TABLES
00306e 7f05
00306f 010a
003070 0214
003071 0328
003072 0450
003073 051e
003074 0607
003075 070d
003076 0806
003077 090c
003078 0a18
003079 0b30
00307a 0c60
00307b 0d24
00307c 0e08
00307d 0f10                      length: .db $05, $7F, $0A, $01, $14, $02, $28, $03, $50, $04, $1E, $05, $07, $06, $0D, $07, $06, $08, $0C, $09, $18, $0A, $30, $0B, $60, $0C, $24, $0D, $08, $0E, $10, $0F
                                 
                                 //pulse sequences: 12.5%, 25%, 50%, 75%
00307e 0301
00307f fc0f                      sequences: .db 0b00000001, 0b00000011, 0b00001111, 0b11111100
                                 
                                 //list of famitracker fx: http://famitracker.com/wiki/index.php?title=Effect_list
                                 channel0_fx:
003080 187a
003081 187f
003082 189b
003083 18b7
003084 18da                      	.dw sound_driver_channel0_fx_0xy, sound_driver_channel0_fx_1xx, sound_driver_channel0_fx_2xx, sound_driver_channel0_fx_3xx, sound_driver_channel0_fx_4xy
003085 18e5
003086 18f2
003087 18f5
003088 18f8
003089 18fb                      	.dw sound_driver_channel0_fx_7xy, sound_driver_channel0_fx_Axy, sound_driver_channel0_fx_Bxx, sound_driver_channel0_fx_Cxx, sound_driver_channel0_fx_Dxx
00308a 18fe
00308b 1906
00308c 1909
00308d 1916
00308e 1917                      	.dw sound_driver_channel0_fx_Exx, sound_driver_channel0_fx_Fxx, sound_driver_channel0_fx_Gxx, sound_driver_channel0_fx_Hxy, sound_driver_channel0_fx_Ixy
00308f 1918
003090 1919
003091 191a
003092 1932
003093 1974                      	.dw sound_driver_channel0_fx_Hxx, sound_driver_channel0_fx_Ixx, sound_driver_channel0_fx_Pxx, sound_driver_channel0_fx_Qxy, sound_driver_channel0_fx_Rxy
003094 19b5
003095 19c2
003096 19d6
003097 19d7
003098 19d8                      	.dw sound_driver_channel0_fx_Sxx, sound_driver_channel0_fx_Vxx, sound_driver_channel0_fx_Wxx, sound_driver_channel0_fx_Xxx, sound_driver_channel0_fx_Yxx
003099 19d9                      	.dw sound_driver_channel0_fx_Zxx
                                 
                                 channel1_fx:
00309a 1b68
00309b 1b6d
00309c 1b89
00309d 1ba5
00309e 1bc8                      	.dw sound_driver_channel1_fx_0xy, sound_driver_channel1_fx_1xx, sound_driver_channel1_fx_2xx, sound_driver_channel1_fx_3xx, sound_driver_channel1_fx_4xy
00309f 1bd3
0030a0 1be0
0030a1 1be3
0030a2 1be6
0030a3 1be9                      	.dw sound_driver_channel1_fx_7xy, sound_driver_channel1_fx_Axy, sound_driver_channel1_fx_Bxx, sound_driver_channel1_fx_Cxx, sound_driver_channel1_fx_Dxx
0030a4 1bec
0030a5 1bf4
0030a6 1bf7
0030a7 1c04
0030a8 1c05                      	.dw sound_driver_channel1_fx_Exx, sound_driver_channel1_fx_Fxx, sound_driver_channel1_fx_Gxx, sound_driver_channel1_fx_Hxy, sound_driver_channel1_fx_Ixy
0030a9 1c06
0030aa 1c07
0030ab 1c08
0030ac 1c20
0030ad 1c62                      	.dw sound_driver_channel1_fx_Hxx, sound_driver_channel1_fx_Ixx, sound_driver_channel1_fx_Pxx, sound_driver_channel1_fx_Qxy, sound_driver_channel1_fx_Rxy
0030ae 1ca3
0030af 1cb0
0030b0 1cc4
0030b1 1cc5
0030b2 1cc6                      	.dw sound_driver_channel1_fx_Sxx, sound_driver_channel1_fx_Vxx, sound_driver_channel1_fx_Wxx, sound_driver_channel1_fx_Xxx, sound_driver_channel1_fx_Yxx
0030b3 1cc7                      	.dw sound_driver_channel1_fx_Zxx
                                 
                                 channel2_fx:
0030b4 1e49
0030b5 1e4e
0030b6 1e6a
0030b7 1e86
0030b8 1ea9                      	.dw sound_driver_channel2_fx_0xy, sound_driver_channel2_fx_1xx, sound_driver_channel2_fx_2xx, sound_driver_channel2_fx_3xx, sound_driver_channel2_fx_4xy
0030b9 1eb4
0030ba 1eb5
0030bb 1eb6
0030bc 1eb9
0030bd 1ebc                      	.dw sound_driver_channel2_fx_7xy, sound_driver_channel2_fx_Axy, sound_driver_channel2_fx_Bxx, sound_driver_channel2_fx_Cxx, sound_driver_channel2_fx_Dxx
0030be 1ebf
0030bf 1ecc
0030c0 1ecf
0030c1 1edc
0030c2 1edd                      	.dw sound_driver_channel2_fx_Exx, sound_driver_channel2_fx_Fxx, sound_driver_channel2_fx_Gxx, sound_driver_channel2_fx_Hxy, sound_driver_channel2_fx_Ixy
0030c3 1ede
0030c4 1edf
0030c5 1ee0
0030c6 1ef8
0030c7 1f3a                      	.dw sound_driver_channel2_fx_Hxx, sound_driver_channel2_fx_Ixx, sound_driver_channel2_fx_Pxx, sound_driver_channel2_fx_Qxy, sound_driver_channel2_fx_Rxy
0030c8 1f7b
0030c9 1f88
0030ca 1f89
0030cb 1f8a
0030cc 1f8b                      	.dw sound_driver_channel2_fx_Sxx, sound_driver_channel2_fx_Vxx, sound_driver_channel2_fx_Wxx, sound_driver_channel2_fx_Xxx, sound_driver_channel2_fx_Yxx
0030cd 1f8c                      	.dw sound_driver_channel2_fx_Zxx
                                 
                                 channel3_fx:
0030ce 2112
0030cf 2117
0030d0 2120
0030d1 2129
0030d2 212a                      	.dw sound_driver_channel3_fx_0xy, sound_driver_channel3_fx_1xx, sound_driver_channel3_fx_2xx, sound_driver_channel3_fx_3xx, sound_driver_channel3_fx_4xy
0030d3 2137
0030d4 2144
0030d5 2147
0030d6 214a
0030d7 214d                      	.dw sound_driver_channel3_fx_7xy, sound_driver_channel3_fx_Axy, sound_driver_channel3_fx_Bxx, sound_driver_channel3_fx_Cxx, sound_driver_channel3_fx_Dxx
0030d8 2150
0030d9 2157
0030da 215a
0030db 2167
0030dc 2168                      	.dw sound_driver_channel3_fx_Exx, sound_driver_channel3_fx_Fxx, sound_driver_channel3_fx_Gxx, sound_driver_channel3_fx_Hxy, sound_driver_channel3_fx_Ixy
0030dd 2169
0030de 216a
0030df 216b
0030e0 216e
0030e1 216f                      	.dw sound_driver_channel3_fx_Hxx, sound_driver_channel3_fx_Ixx, sound_driver_channel3_fx_Pxx, sound_driver_channel3_fx_Qxy, sound_driver_channel3_fx_Rxy
0030e2 2170
0030e3 217d
0030e4 2188
0030e5 2189
0030e6 218a                      	.dw sound_driver_channel3_fx_Sxx, sound_driver_channel3_fx_Vxx, sound_driver_channel3_fx_Wxx, sound_driver_channel3_fx_Xxx, sound_driver_channel3_fx_Yxx
0030e7 218b                      	.dw sound_driver_channel3_fx_Zxx
                                 
                                 channel4_fx:
0030e8 22d5
0030e9 22d6
0030ea 22d7
0030eb 22d8
0030ec 22d9                      	.dw sound_driver_channel4_fx_0xy, sound_driver_channel4_fx_1xx, sound_driver_channel4_fx_2xx, sound_driver_channel4_fx_3xx, sound_driver_channel4_fx_4xy
0030ed 22da
0030ee 22db
0030ef 22dc
0030f0 22df
0030f1 22e2                      	.dw sound_driver_channel4_fx_7xy, sound_driver_channel4_fx_Axy, sound_driver_channel4_fx_Bxx, sound_driver_channel4_fx_Cxx, sound_driver_channel4_fx_Dxx
0030f2 22e5
0030f3 22e6
0030f4 22e9
0030f5 22f6
0030f6 22f7                      	.dw sound_driver_channel4_fx_Exx, sound_driver_channel4_fx_Fxx, sound_driver_channel4_fx_Gxx, sound_driver_channel4_fx_Hxy, sound_driver_channel4_fx_Ixy
0030f7 22f8
0030f8 22f9
0030f9 22fa
0030fa 22fb
0030fb 22fc                      	.dw sound_driver_channel4_fx_Hxx, sound_driver_channel4_fx_Ixx, sound_driver_channel4_fx_Pxx, sound_driver_channel4_fx_Qxy, sound_driver_channel4_fx_Rxy
0030fc 22fd
0030fd 230a
0030fe 230b
0030ff 230c
003100 230d                      	.dw sound_driver_channel4_fx_Sxx, sound_driver_channel4_fx_Vxx, sound_driver_channel4_fx_Wxx, sound_driver_channel4_fx_Xxx, sound_driver_channel4_fx_Yxx
003101 230e                      	.dw sound_driver_channel4_fx_Zxx
                                 
                                 //famitracker volumes table: http://famitracker.com/wiki/index.php?title=Volume
                                 volumes:
003102 0000
003103 0000
003104 0000
003105 0000
003106 0000
003107 0000
003108 0000
003109 0000                      	.db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
00310a 0100
00310b 0101
00310c 0101
00310d 0101
00310e 0101
00310f 0101
003110 0101
003111 0101                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
003112 0100
003113 0101
003114 0101
003115 0101
003116 0101
003117 0101
003118 0101
003119 0201                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02
00311a 0100
00311b 0101
00311c 0101
00311d 0101
00311e 0101
00311f 0202
003120 0202
003121 0302                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03
003122 0100
003123 0101
003124 0101
003125 0101
003126 0202
003127 0202
003128 0303
003129 0403                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04
00312a 0100
00312b 0101
00312c 0101
00312d 0202
00312e 0302
00312f 0303
003130 0404
003131 0504                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05
003132 0100
003133 0101
003134 0201
003135 0202
003136 0303
003137 0404
003138 0504
003139 0605                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x06
00313a 0100
00313b 0101
00313c 0201
00313d 0302
00313e 0403
00313f 0504
003140 0605
003141 0706                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07
003142 0100
003143 0101
003144 0202
003145 0303
003146 0404
003147 0505
003148 0606
003149 0807                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07, 0x08
00314a 0100
00314b 0101
00314c 0302
00314d 0403
00314e 0504
00314f 0606
003150 0707
003151 0908                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09
003152 0100
003153 0201
003154 0302
003155 0404
003156 0605
003157 0706
003158 0808
003159 0a09                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A
00315a 0100
00315b 0201
00315c 0302
00315d 0504
00315e 0605
00315f 0807
003160 0908
003161 0b0a                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B
003162 0100
003163 0201
003164 0403
003165 0504
003166 0706
003167 0808
003168 0a09
003169 0c0b                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B, 0x0C
00316a 0100
00316b 0201
00316c 0403
00316d 0605
00316e 0706
00316f 0908
003170 0b0a
003171 0d0c                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D
003172 0100
003173 0201
003174 0403
003175 0605
003176 0807
003177 0a09
003178 0c0b
003179 0e0d                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E
00317a 0100
00317b 0302
00317c 0504
00317d 0706
00317e 0908
00317f 0b0a
003180 0d0c


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega4809" register use summary:
x  :   0 y  :   0 z  : 253 r0 : 148 r1 : 160 r2 : 676 r3 :   3 r4 :   4 
r5 :   0 r6 :   0 r7 :   6 r8 :   4 r9 :   9 r10:   6 r11:   4 r12:   9 
r13:   1 r14:   1 r15:   2 r16:   7 r17:   6 r18:   7 r19:   6 r20:   4 
r21:   9 r22: 138 r23: 127 r24:   3 r25:  24 r26: 956 r27:1209 r28: 666 
r29: 350 r30: 383 r31: 331 
Registers used: 31 out of 35 (88.6%)

"ATmega4809" instruction use summary:
.lds  :   0 .sts  :   0 adc   : 132 add   : 183 adiw  : 100 and   :   2 
andi  :  99 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   6 brcs  :  13 break :   0 breq  : 173 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  76 brlt  :   0 brmi  :   0 
brne  : 123 brpl  :   0 brsh  :  37 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :   0 cbr   :   5 
clc   :   0 clh   :   0 cli   :   6 cln   :   0 clr   :   5 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :  16 cp    : 115 cpc   :  15 
cpi   : 175 cpse  :  21 dec   :  40 des   :   0 eor   :   2 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   5 in    :   5 inc   :  46 
jmp   :   8 ld    :   0 ldd   :   0 ldi   : 300 lds   : 675 lpm   : 277 
lsl   :  82 lsr   : 135 mov   : 146 movw  :   0 mul   :  21 muls  :   0 
mulsu :  10 neg   :   1 nop   :   0 or    :  24 ori   :  12 out   :   9 
pop   :  97 push  :  89 rcall :  56 ret   :  34 reti  :   7 rjmp  : 560 
rol   :  59 ror   : 156 sbc   :  30 sbci  :   0 sbi   :   0 sbic  :   0 
sbis  :   0 sbiw  :   0 sbr   :  12 sbrc  :  25 sbrs  :  18 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   :1369 sub   :  53 subi  :  49 swap  :  47 tst   :   0 wdr   :   0 

Instructions used: 54 out of 114 (47.4%)

"ATmega4809" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x006304  15428   9796  25224   49152  51.3%
[.dseg] 0x002800 0x002956      0    342    342    6144   5.6%
[.eseg] 0x000000 0x000000      0      0      0     256   0.0%

Assembly complete, 0 errors, 52 warnings
