
AVRASM ver. 2.2.8  C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm Sat Jan 23 19:57:02 2021

C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
                                 
                                 
                                 ; NES_APU_2a03.asm
                                 ;
                                 ; Created: 11/29/2020 1:44:10 AM
                                 ; Author : Tennyson Cheng
                                 ;
                                 
                                 .list
                                 
                                 .dseg
002800                           pulse1_param: .byte 1 //$4000 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002801                           pulse1_sweep_param: .byte 1 //$4001 EPPP.NSSS = Enable, Period, Negate, Shift
                                 //NOTE: In order to account for multiplier, we use 16 instead of 11 bits for the timer
002802                           pulse1_timerL: .byte 1 //$4002 LLLL.LLLL = Low 8 bits for timer
002803                           pulse1_timerH: .byte 1 //$4002 HHHH.HHHH = High 8 bits for timer
002804                           pulse1_length: .byte 1 //$4003 000l.llll = Length counter load
002805                           pulse1_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002806                           pulse1_output_volume: .byte 1 //this is the final output volume of pulse 1
002807                           pulse1_note: .byte 1 //the current note index in the note table
                                 
002808                           pulse2_param: .byte 1 //$4004 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002809                           pulse2_sweep_param: .byte 1 //$4005 EPPP.NSSS = Enable, Period, Negate, Shift
00280a                           pulse2_timerL: .byte 1 //$4006 LLLL.LLLL = Low 8 bits for timer
00280b                           pulse2_timerH: .byte 1 //$4006 HHHH.HHHH = High 8 bits for timer
00280c                           pulse2_length: .byte 1 //$4007 000l.llll = Length counter load
00280d                           pulse2_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
00280e                           pulse2_output_volume: .byte 1 //this is the final output volume of pulse 2
00280f                           pulse2_note: .byte 1 //the current note index in the note table
                                 
002810                           triangle_timerL: .byte 1 //$400A LLLL.LLLL = Low 8 bits for timer
002811                           triangle_timerH: .byte 1 //$400A HHHH.HHHH = High 8 bits for time
002812                           triangle_note: .byte 1 //the current note index in the note table
                                 
002813                           noise_param: .byte 1 //$400C 00lc.vvvv = Length counter halt/Loop flag, Constant volume flag, Volume
002814                           noise_period: .byte 1 //$400E M000.PPPP = Mode, Period
002815                           noise_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002816                           noise_output_volume: .byte 1 //this is the final output volume of pulse 2
002817                           noise_note: .byte 1 //the current note index in the period table
                                 
002818                           song_frames: .byte 2
00281a                           song_frame_offset: .byte 2
00281c                           song_size: .byte 2
00281e                           song_speed: .byte 1
                                 //song_channel_delay_reload: .byte 1 //bit 0-4 represents channels 0-4. a set bit means that there is a delay that needs to be calculated for that channel.
00281f                           song_fx_Bxx: .byte 1
002820                           song_fx_Cxx: .byte 1
002821                           song_fx_Dxx: .byte 1
                                 
                                 //PULSE 1
002822                           pulse1_pattern: .byte 2
002824                           pulse1_pattern_delay_rows: .byte 1
002825                           pulse1_pattern_delay_frames: .byte 1
002826                           pulse1_pattern_offset: .byte 2
                                 
002828                           pulse1_volume_macro: .byte 2
00282a                           pulse1_volume_macro_offset: .byte 1
00282b                           pulse1_volume_macro_loop: .byte 1
00282c                           pulse1_volume_macro_release: .byte 1
                                 
00282d                           pulse1_arpeggio_macro: .byte 2
00282f                           pulse1_arpeggio_macro_offset: .byte 1
002830                           pulse1_arpeggio_macro_loop: .byte 1
002831                           pulse1_arpeggio_macro_release: .byte 1
002832                           pulse1_arpeggio_macro_mode: .byte 1
                                 
002833                           pulse1_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002835                           pulse1_pitch_macro: .byte 2
002837                           pulse1_pitch_macro_offset: .byte 1
002838                           pulse1_pitch_macro_loop: .byte 1
002839                           pulse1_pitch_macro_release: .byte 1
                                 
00283a                           pulse1_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00283b                           pulse1_hi_pitch_macro: .byte 2
00283d                           pulse1_hi_pitch_macro_offset: .byte 1
00283e                           pulse1_hi_pitch_macro_loop: .byte 1
00283f                           pulse1_hi_pitch_macro_release: .byte 1
                                 
002840                           pulse1_duty_macro: .byte 2
002842                           pulse1_duty_macro_offset: .byte 1
002843                           pulse1_duty_macro_loop: .byte 1
002844                           pulse1_duty_macro_release: .byte 1
                                 
002845                           pulse1_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002847                           pulse1_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002849                           pulse1_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00284b                           pulse1_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
00284d                           pulse1_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
00284f                           pulse1_fx_3xx_start: .byte 2 //the starting note period
002851                           pulse1_fx_3xx_target: .byte 2 //target note period
002853                           pulse1_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
002855                           pulse1_fx_3xx_total_offset: .byte 2
002857                           pulse1_fx_4xy_speed: .byte 1
002858                           pulse1_fx_4xy_depth: .byte 1
002859                           pulse1_fx_4xy_phase: .byte 1
00285a                           pulse1_fx_7xy_speed: .byte 1
00285b                           pulse1_fx_7xy_depth: .byte 1
00285c                           pulse1_fx_7xy_phase: .byte 1
00285d                           pulse1_fx_7xy_value: .byte 1 //value to offset the volume
00285e                           pulse1_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
00285f                           pulse1_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002860                           pulse1_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002861                           pulse1_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
002863                           pulse1_fx_Qxy_target: .byte 2 //target note period
002865                           pulse1_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002867                           pulse1_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002869                           pulse1_fx_Rxy_target: .byte 2 //target note period
00286b                           pulse1_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
00286d                           pulse1_fx_Rxy_total_offset: .byte 2
00286f                           pulse1_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002870                           pulse1_fx_Sxx_post: .byte 1
                                 
                                 //PULSE 2
002871                           pulse2_pattern: .byte 2
002873                           pulse2_pattern_delay_rows: .byte 1
002874                           pulse2_pattern_delay_frames: .byte 1
002875                           pulse2_pattern_offset: .byte 2
                                 
002877                           pulse2_volume_macro: .byte 2
002879                           pulse2_volume_macro_offset: .byte 1
00287a                           pulse2_volume_macro_loop: .byte 1
00287b                           pulse2_volume_macro_release: .byte 1
                                 
00287c                           pulse2_arpeggio_macro: .byte 2
00287e                           pulse2_arpeggio_macro_offset: .byte 1
00287f                           pulse2_arpeggio_macro_loop: .byte 1
002880                           pulse2_arpeggio_macro_release: .byte 1
002881                           pulse2_arpeggio_macro_mode: .byte 1
                                 
002882                           pulse2_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002884                           pulse2_pitch_macro: .byte 2
002886                           pulse2_pitch_macro_offset: .byte 1
002887                           pulse2_pitch_macro_loop: .byte 1
002888                           pulse2_pitch_macro_release: .byte 1
                                 
002889                           pulse2_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00288a                           pulse2_hi_pitch_macro: .byte 2
00288c                           pulse2_hi_pitch_macro_offset: .byte 1
00288d                           pulse2_hi_pitch_macro_loop: .byte 1
00288e                           pulse2_hi_pitch_macro_release: .byte 1
                                 
00288f                           pulse2_duty_macro: .byte 2
002891                           pulse2_duty_macro_offset: .byte 1
002892                           pulse2_duty_macro_loop: .byte 1
002893                           pulse2_duty_macro_release: .byte 1
                                 
002894                           pulse2_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002896                           pulse2_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002898                           pulse2_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00289a                           pulse2_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
00289c                           pulse2_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
00289e                           pulse2_fx_3xx_start: .byte 2 //the starting note period
0028a0                           pulse2_fx_3xx_target: .byte 2 //target note period
0028a2                           pulse2_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028a4                           pulse2_fx_3xx_total_offset: .byte 2
0028a6                           pulse2_fx_4xy_speed: .byte 1
0028a7                           pulse2_fx_4xy_depth: .byte 1
0028a8                           pulse2_fx_4xy_phase: .byte 1
0028a9                           pulse2_fx_7xy_speed: .byte 1
0028aa                           pulse2_fx_7xy_depth: .byte 1
0028ab                           pulse2_fx_7xy_phase: .byte 1
0028ac                           pulse2_fx_7xy_value: .byte 1 //value to offset the volume
0028ad                           pulse2_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
0028ae                           pulse2_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028af                           pulse2_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028b0                           pulse2_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
0028b2                           pulse2_fx_Qxy_target: .byte 2 //target note period
0028b4                           pulse2_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
0028b6                           pulse2_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
0028b8                           pulse2_fx_Rxy_target: .byte 2 //target note period
0028ba                           pulse2_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
0028bc                           pulse2_fx_Rxy_total_offset: .byte 2
0028be                           pulse2_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
0028bf                           pulse2_fx_Sxx_post: .byte 1
                                 
                                 //TRIANGLE
0028c0                           triangle_pattern: .byte 2
0028c2                           triangle_pattern_delay_rows: .byte 1
0028c3                           triangle_pattern_delay_frames: .byte 1
0028c4                           triangle_pattern_offset: .byte 2
                                 
0028c6                           triangle_volume_macro: .byte 2
0028c8                           triangle_volume_macro_offset: .byte 1
0028c9                           triangle_volume_macro_loop: .byte 1
0028ca                           triangle_volume_macro_release: .byte 1
                                 
0028cb                           triangle_arpeggio_macro: .byte 2
0028cd                           triangle_arpeggio_macro_offset: .byte 1
0028ce                           triangle_arpeggio_macro_loop: .byte 1
0028cf                           triangle_arpeggio_macro_release: .byte 1
0028d0                           triangle_arpeggio_macro_mode: .byte 1
                                 
0028d1                           triangle_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
0028d3                           triangle_pitch_macro: .byte 2
0028d5                           triangle_pitch_macro_offset: .byte 1
0028d6                           triangle_pitch_macro_loop: .byte 1
0028d7                           triangle_pitch_macro_release: .byte 1
                                 
0028d8                           triangle_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
0028d9                           triangle_hi_pitch_macro: .byte 2
0028db                           triangle_hi_pitch_macro_offset: .byte 1
0028dc                           triangle_hi_pitch_macro_loop: .byte 1
0028dd                           triangle_hi_pitch_macro_release: .byte 1
                                 
0028de                           triangle_duty_macro: .byte 2
0028e0                           triangle_duty_macro_offset: .byte 1
0028e1                           triangle_duty_macro_loop: .byte 1
0028e2                           triangle_duty_macro_release: .byte 1
                                 
0028e3                           triangle_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
0028e5                           triangle_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
0028e7                           triangle_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
0028e9                           triangle_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
0028eb                           triangle_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
0028ed                           triangle_fx_3xx_start: .byte 2 //the starting note period
0028ef                           triangle_fx_3xx_target: .byte 2 //target note period
0028f1                           triangle_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028f3                           triangle_fx_3xx_total_offset: .byte 2
0028f5                           triangle_fx_4xy_speed: .byte 1
0028f6                           triangle_fx_4xy_depth: .byte 1
0028f7                           triangle_fx_4xy_phase: .byte 1
0028f8                           triangle_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028f9                           triangle_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028fa                           triangle_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
0028fc                           triangle_fx_Qxy_target: .byte 2 //target note period
0028fe                           triangle_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002900                           triangle_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002902                           triangle_fx_Rxy_target: .byte 2 //target note period
002904                           triangle_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
002906                           triangle_fx_Rxy_total_offset: .byte 2
002908                           triangle_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002909                           triangle_fx_Sxx_post: .byte 1
                                 
                                 //NOISE
00290a                           noise_pattern: .byte 2
00290c                           noise_pattern_delay_rows: .byte 1
00290d                           noise_pattern_delay_frames: .byte 1
00290e                           noise_pattern_offset: .byte 2
                                 
002910                           noise_volume_macro: .byte 2
002912                           noise_volume_macro_offset: .byte 1
002913                           noise_volume_macro_loop: .byte 1
002914                           noise_volume_macro_release: .byte 1
                                 
002915                           noise_arpeggio_macro: .byte 2
002917                           noise_arpeggio_macro_offset: .byte 1
002918                           noise_arpeggio_macro_loop: .byte 1
002919                           noise_arpeggio_macro_release: .byte 1
00291a                           noise_arpeggio_macro_mode: .byte 1
                                 
00291b                           noise_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
00291d                           noise_pitch_macro: .byte 2
00291f                           noise_pitch_macro_offset: .byte 1
002920                           noise_pitch_macro_loop: .byte 1
002921                           noise_pitch_macro_release: .byte 1
                                 
002922                           noise_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
002923                           noise_hi_pitch_macro: .byte 2
002925                           noise_hi_pitch_macro_offset: .byte 1
002926                           noise_hi_pitch_macro_loop: .byte 1
002927                           noise_hi_pitch_macro_release: .byte 1
                                 
002928                           noise_duty_macro: .byte 2
00292a                           noise_duty_macro_offset: .byte 1
00292b                           noise_duty_macro_loop: .byte 1
00292c                           noise_duty_macro_release: .byte 1
                                 
00292d                           noise_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
00292f                           noise_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002931                           noise_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
002933                           noise_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
002935                           noise_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
002937                           noise_fx_3xx_start: .byte 2 //the starting note period
002939                           noise_fx_3xx_target: .byte 2 //target note period
00293b                           noise_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
00293d                           noise_fx_3xx_total_offset: .byte 2
00293f                           noise_fx_4xy_speed: .byte 1
002940                           noise_fx_4xy_depth: .byte 1
002941                           noise_fx_4xy_phase: .byte 1
002942                           noise_fx_7xy_speed: .byte 1
002943                           noise_fx_7xy_depth: .byte 1
002944                           noise_fx_7xy_phase: .byte 1
002945                           noise_fx_7xy_value: .byte 1 //value to offset the volume
002946                           noise_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
002947                           noise_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002948                           noise_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002949                           noise_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
00294b                           noise_fx_Qxy_target: .byte 2 //target note period
00294d                           noise_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
00294f                           noise_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002951                           noise_fx_Rxy_target: .byte 2 //target note period
002953                           noise_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
002955                           noise_fx_Rxy_total_offset: .byte 2
002957                           noise_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002958                           noise_fx_Sxx_post: .byte 1
                                 
                                 //DPCM
002959                           dcpm_pattern_delay: .byte 1
                                 
                                 .cseg
                                 
                                 //NOTE: zero is defined in order to use the cp instruction without the need to load 0x00 into a register beforehand
                                 .def zero = r2
                                 .def pulse_channel_flags = r25 //[pulse1.pulse2] RSlc.RSlc = Reload, Start, Length halt/Loop, Constant volume
                                 .def pulse1_sequence = r10
                                 .def pulse1_length_counter = r11
                                 .def pulse1_sweep = r12 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse1_volume_divider = r16 //0000.PPPP = Period divider
                                 .def pulse1_volume_decay = r17 //0000.dddd = Decay
                                 .def pulse2_sequence = r13
                                 .def pulse2_length_counter = r14
                                 .def pulse2_sweep = r15 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse2_volume_divider = r18 //0000.PPPP = Period divider
                                 .def pulse2_volume_decay = r19 //0000.dddd = Decay
                                 .def triangle_sequence = r20
                                 .def noise_sequence_LOW = r21
                                 .def noise_sequence_HIGH = r22
                                 
                                 reset:
000000 940c 0ec3                 	jmp init
                                 
                                 .org TCA0_OVF_vect
00000e 940c 136e                 	jmp sound_driver
                                 
                                 .org TCA0_CMP0_vect
000012 940c 1275                 	jmp sequence_0_2
                                 
                                 .org TCA0_CMP1_vect
000014 940c 1280                 	jmp sequence_1_3
                                 
                                 .org TCA0_CMP2_vect
000016 940c 1275                 	jmp sequence_0_2
                                 
                                 .org TCB0_INT_vect
000018 940c 1297                 	jmp pulse1_sequence_routine
                                 
                                 .org TCB1_INT_vect
00001a 940c 12e4                 	jmp pulse2_sequence_routine
                                 
                                 .org TCB2_INT_vect
000032 940c 1331                 	jmp triangle_sequence_routine
                                 
                                 .org TCB3_INT_vect
000048 940c 133c                 	jmp noise_sequence_routine
                                 
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(33): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(48): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(74): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(77): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(79): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(80): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(81): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(84): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(85): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(88): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(89): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(93): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(95): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(96): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(97): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(101): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(102): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(104): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(106): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(108): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(109): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(110): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(113): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(116): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(119): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(124): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(125): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(127): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(128): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(131): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(138): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(216): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(218): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(219): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(220): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(221): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(223): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(225): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(226): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(227): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(231): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(233): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(234): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(235): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(237): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(240): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(246): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(247): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(249): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(250): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(251): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(258): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(259): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(269): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(270): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
                                 .list
                                 
                                 init:
                                 	//MAIN CLOCK
000ec3 edc8                      	ldi r28, CPU_CCP_IOREG_gc //protected write
000ec4 93c0 0034                 	sts CPU_CCP, r28
000ec6 e0c0                      	ldi r28, 0 << CLKCTRL_PEN_bp //disable prescaler for 20 MHz on main clock
000ec7 93c0 0061                 	sts CLKCTRL_MCLKCTRLB, r28
                                 
                                 	//ZERO
000ec9 2422                      	clr zero
                                 
                                 	//MEMORY
000eca e3c0                      	ldi r28, 0b00110000
000ecb 93c0 2800                 	sts pulse1_param, r28
000ecd e8c0                      	ldi r28, 0b10000000
000ece 93c0 2801                 	sts pulse1_sweep_param, r28
000ed0 efcf                      	ldi r28, 0xFF
000ed1 93c0 2802                 	sts pulse1_timerL, r28
000ed3 93c0 2803                 	sts pulse1_timerH, r28
000ed5 93c0 2804                 	sts pulse1_length, r28
                                 
000ed7 e3c0                      	ldi r28, 0b00110000
000ed8 93c0 2808                 	sts pulse2_param, r28
000eda e8c0                      	ldi r28, 0b10000000
000edb 93c0 2809                 	sts pulse2_sweep_param, r28
000edd efcf                      	ldi r28, 0xFF
000ede 93c0 280a                 	sts pulse2_timerL, r28
000ee0 93c0 280b                 	sts pulse2_timerH, r28
000ee2 93c0 280c                 	sts pulse2_length, r28
                                 
000ee4 efcf                      	ldi r28, 0xFF
000ee5 93c0 2810                 	sts triangle_timerL, r28
000ee7 93c0 2811                 	sts triangle_timerH, r28
                                 
000ee9 e3c0                      	ldi r28, 0b00110000
000eea 93c0 2813                 	sts noise_param, r28
000eec e0cf                      	ldi r28, 0b00001111
000eed 93c0 2814                 	sts noise_period, r28
                                 
000eef e0c2                      	ldi r28, 0x02
000ef0 93c0 281a                 	sts song_frame_offset, r28
000ef2 9220 281b                 	sts song_frame_offset+1, zero
000ef4 efcf                      	ldi r28, 0xFF
000ef5 93c0 281f                 	sts song_fx_Bxx, r28
000ef7 9220 2820                 	sts song_fx_Cxx, zero
000ef9 9220 2821                 	sts song_fx_Dxx, zero
000efb e4ee                      	ldi ZL, LOW(song0_frames << 1)
000efc e0f3                      	ldi ZH, HIGH(song0_frames << 1)
000efd 93e0 2818                 	sts song_frames, ZL
000eff 93f0 2819                 	sts song_frames+1, ZH
000f01 91c5                      	lpm r28, Z+ //load the song size
000f02 91d5                      	lpm r29, Z+
000f03 93c0 281c                 	sts song_size, r28
000f05 93d0 281d                 	sts song_size+1, r29
000f07 9220 281e                 	sts song_speed, zero
                                 
                                 	//CHANNEL 0
000f09 91c5                      	lpm r28, Z+
000f0a 91d5                      	lpm r29, Z+
000f0b 0fcc                      	lsl r28
000f0c 1fdd                      	rol r29
000f0d 93c0 2822                 	sts pulse1_pattern, r28
000f0f 93d0 2823                 	sts pulse1_pattern+1, r29
000f11 9220 2824                 	sts pulse1_pattern_delay_rows, zero
000f13 9220 2825                 	sts pulse1_pattern_delay_frames, zero
000f15 9220 2826                 	sts pulse1_pattern_offset, zero
000f17 9220 2827                 	sts pulse1_pattern_offset+1, zero
                                 
                                 	//CHANNEL 1
000f19 91c5                      	lpm r28, Z+
000f1a 91d5                      	lpm r29, Z+
000f1b 0fcc                      	lsl r28
000f1c 1fdd                      	rol r29
000f1d 93c0 2871                 	sts pulse2_pattern, r28
000f1f 93d0 2872                 	sts pulse2_pattern+1, r29
000f21 9220 2873                 	sts pulse2_pattern_delay_rows, zero
000f23 9220 2874                 	sts pulse2_pattern_delay_frames, zero
000f25 9220 2875                 	sts pulse2_pattern_offset, zero
000f27 9220 2876                 	sts pulse2_pattern_offset+1, zero
                                 
                                 	//CHANNEL 2
000f29 91c5                      	lpm r28, Z+
000f2a 91d5                      	lpm r29, Z+
000f2b 0fcc                      	lsl r28
000f2c 1fdd                      	rol r29
000f2d 93c0 28c0                 	sts triangle_pattern, r28
000f2f 93d0 28c1                 	sts triangle_pattern+1, r29
000f31 9220 28c2                 	sts triangle_pattern_delay_rows, zero
000f33 9220 28c3                 	sts triangle_pattern_delay_frames, zero
000f35 9220 28c4                 	sts triangle_pattern_offset, zero
000f37 9220 28c5                 	sts triangle_pattern_offset+1, zero
                                 
                                 	//CHANNEL 3
000f39 91c5                      	lpm r28, Z+
000f3a 91d5                      	lpm r29, Z+
000f3b 0fcc                      	lsl r28
000f3c 1fdd                      	rol r29
000f3d 93c0 290a                 	sts noise_pattern, r28
000f3f 93d0 290b                 	sts noise_pattern+1, r29
000f41 9220 290c                 	sts noise_pattern_delay_rows, zero
000f43 9220 290d                 	sts noise_pattern_delay_frames, zero
000f45 9220 290e                 	sts noise_pattern_offset, zero
000f47 9220 290f                 	sts noise_pattern_offset+1, zero
                                 
                                 	//CHANNEL 0 instrument macros
000f49 efcf                      	ldi r28, 0xFF
000f4a 9220 282a                 	sts pulse1_volume_macro_offset, zero
000f4c 93c0 282b                 	sts pulse1_volume_macro_loop, r28
000f4e 93c0 282c                 	sts pulse1_volume_macro_release, r28
000f50 9220 282f                 	sts pulse1_arpeggio_macro_offset, zero
000f52 93c0 2830                 	sts pulse1_arpeggio_macro_loop, r28
000f54 93c0 2831                 	sts pulse1_arpeggio_macro_release, r28
000f56 93c0 2832                 	sts pulse1_arpeggio_macro_mode, r28
000f58 9220 2837                 	sts pulse1_pitch_macro_offset, zero
000f5a 93c0 2838                 	sts pulse1_pitch_macro_loop, r28
000f5c 93c0 2839                 	sts pulse1_pitch_macro_release, r28
000f5e 9220 283d                 	sts pulse1_hi_pitch_macro_offset, zero
000f60 93c0 283e                 	sts pulse1_hi_pitch_macro_loop, r28
000f62 93c0 283f                 	sts pulse1_hi_pitch_macro_release, r28
000f64 9220 2842                 	sts pulse1_duty_macro_offset, zero
000f66 93c0 2843                 	sts pulse1_duty_macro_loop, r28
000f68 93c0 2844                 	sts pulse1_duty_macro_release, r28
                                 
000f6a 9220 2828                 	sts pulse1_volume_macro, zero
000f6c 9220 2829                 	sts pulse1_volume_macro+1, zero
000f6e 9220 282d                 	sts pulse1_arpeggio_macro, zero
000f70 9220 282e                 	sts pulse1_arpeggio_macro+1, zero
000f72 9220 2833                 	sts pulse1_total_pitch_offset, zero
000f74 9220 2834                 	sts pulse1_total_pitch_offset+1, zero
000f76 9220 2835                 	sts pulse1_pitch_macro, zero
000f78 9220 2836                 	sts pulse1_pitch_macro+1, zero
000f7a 9220 283a                 	sts pulse1_total_hi_pitch_offset, zero
000f7c 9220 283b                 	sts pulse1_hi_pitch_macro, zero
000f7e 9220 283c                 	sts pulse1_hi_pitch_macro+1, zero
000f80 9220 2840                 	sts pulse1_duty_macro, zero
000f82 9220 2841                 	sts pulse1_duty_macro+1, zero
                                 
                                 	//CHANNEL 0 ENVELOPE
000f84 e00f                      	ldi pulse1_volume_divider, 0x0F
000f85 9110 2800                 	lds pulse1_volume_decay, pulse1_param
000f87 701f                      	andi pulse1_volume_decay, 0x0F //mask for VVVV bits
000f88 9190 2800                 	lds pulse_channel_flags, pulse1_param
000f8a 7390                      	andi pulse_channel_flags, 0b00110000
000f8b 6490                      	sbr pulse_channel_flags, 0b01000000 //set start flag
000f8c 9220 2806                 	sts pulse1_output_volume, zero
000f8e 93c0 2805                 	sts pulse1_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 0 LENGTH
000f90 2ebc                      	mov pulse1_length_counter, r28
                                 
                                 	//CHANNEL 0 SEQUENCE
000f91 e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
000f92 2eac                      	mov pulse1_sequence, r28
                                 
                                 	//CHANNEL 0 SWEEP
000f93 90c0 2801                 	lds pulse1_sweep, pulse1_sweep_param
000f95 94c2                      	swap pulse1_sweep //swap data from high byte and low byte
000f96 6890                      	sbr pulse_channel_flags, 0b10000000 //set reload flag
                                 
                                 	//CHANNEL 0 FX
000f97 efcf                      	ldi r28, 0xFF
000f98 9220 2845                 	sts pulse1_fx_0xy_sequence, zero
000f9a 9220 2846                 	sts pulse1_fx_0xy_sequence+1, zero
000f9c 9220 2847                 	sts pulse1_fx_1xx, zero
000f9e 9220 2848                 	sts pulse1_fx_1xx+1, zero
000fa0 9220 2849                 	sts pulse1_fx_1xx_total, zero
000fa2 9220 284a                 	sts pulse1_fx_1xx_total+1, zero
000fa4 9220 284b                 	sts pulse1_fx_2xx, zero
000fa6 9220 284c                 	sts pulse1_fx_2xx+1, zero
000fa8 9220 284d                 	sts pulse1_fx_2xx_total, zero
000faa 9220 284e                 	sts pulse1_fx_2xx_total+1, zero
000fac 9220 284f                 	sts pulse1_fx_3xx_start, zero
000fae 9220 2850                 	sts pulse1_fx_3xx_start+1, zero
000fb0 9220 2851                 	sts pulse1_fx_3xx_target, zero
000fb2 9220 2852                 	sts pulse1_fx_3xx_target+1, zero
000fb4 9220 2853                 	sts pulse1_fx_3xx_speed, zero
000fb6 9220 2854                 	sts pulse1_fx_3xx_speed+1, zero
000fb8 9220 2855                 	sts pulse1_fx_3xx_total_offset, zero
000fba 9220 2856                 	sts pulse1_fx_3xx_total_offset+1, zero
000fbc 9220 2857                 	sts pulse1_fx_4xy_speed, zero
000fbe 9220 2858                 	sts pulse1_fx_4xy_depth, zero
000fc0 9220 2859                 	sts pulse1_fx_4xy_phase, zero
000fc2 9220 285a                 	sts pulse1_fx_7xy_speed, zero
000fc4 9220 285b                 	sts pulse1_fx_7xy_depth, zero
000fc6 9220 285c                 	sts pulse1_fx_7xy_phase, zero
000fc8 9220 285d                 	sts pulse1_fx_7xy_value, zero
000fca 9220 285e                 	sts pulse1_fx_Axy, zero
000fcc 93c0 285f                 	sts pulse1_fx_Gxx_pre, r28
000fce 93c0 2860                 	sts pulse1_fx_Gxx_post, r28
000fd0 9220 2861                 	sts pulse1_fx_Pxx_total, zero
000fd2 9220 2862                 	sts pulse1_fx_Pxx_total+1, zero
000fd4 9220 2863                 	sts pulse1_fx_Qxy_target, zero
000fd6 9220 2864                 	sts pulse1_fx_Qxy_target+1, zero
000fd8 9220 2865                 	sts pulse1_fx_Qxy_speed, zero
000fda 9220 2866                 	sts pulse1_fx_Qxy_speed+1, zero
000fdc 9220 2867                 	sts pulse1_fx_Qxy_total_offset, zero
000fde 9220 2868                 	sts pulse1_fx_Qxy_total_offset+1, zero
000fe0 9220 2869                 	sts pulse1_fx_Rxy_target, zero
000fe2 9220 286a                 	sts pulse1_fx_Rxy_target+1, zero
000fe4 9220 286b                 	sts pulse1_fx_Rxy_speed, zero
000fe6 9220 286c                 	sts pulse1_fx_Rxy_speed+1, zero
000fe8 9220 286d                 	sts pulse1_fx_Rxy_total_offset, zero
000fea 9220 286e                 	sts pulse1_fx_Rxy_total_offset+1, zero
000fec 93c0 286f                 	sts pulse1_fx_Sxx_pre, r28
000fee 93c0 2870                 	sts pulse1_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 1 instrument macros
000ff0 efcf                      	ldi r28, 0xFF
000ff1 9220 2879                 	sts pulse2_volume_macro_offset, zero
000ff3 93c0 287a                 	sts pulse2_volume_macro_loop, r28
000ff5 93c0 287b                 	sts pulse2_volume_macro_release, r28
000ff7 9220 287e                 	sts pulse2_arpeggio_macro_offset, zero
000ff9 93c0 287f                 	sts pulse2_arpeggio_macro_loop, r28
000ffb 93c0 2880                 	sts pulse2_arpeggio_macro_release, r28
000ffd 93c0 2881                 	sts pulse2_arpeggio_macro_mode, r28
000fff 9220 2886                 	sts pulse2_pitch_macro_offset, zero
001001 93c0 2887                 	sts pulse2_pitch_macro_loop, r28
001003 93c0 2888                 	sts pulse2_pitch_macro_release, r28
001005 9220 288c                 	sts pulse2_hi_pitch_macro_offset, zero
001007 93c0 288d                 	sts pulse2_hi_pitch_macro_loop, r28
001009 93c0 288e                 	sts pulse2_hi_pitch_macro_release, r28
00100b 9220 2891                 	sts pulse2_duty_macro_offset, zero
00100d 93c0 2892                 	sts pulse2_duty_macro_loop, r28
00100f 93c0 2893                 	sts pulse2_duty_macro_release, r28
                                 
001011 9220 2877                 	sts pulse2_volume_macro, zero
001013 9220 2878                 	sts pulse2_volume_macro+1, zero
001015 9220 287c                 	sts pulse2_arpeggio_macro, zero
001017 9220 287d                 	sts pulse2_arpeggio_macro+1, zero
001019 9220 2882                 	sts pulse2_total_pitch_offset, zero
00101b 9220 2883                 	sts pulse2_total_pitch_offset+1, zero
00101d 9220 2884                 	sts pulse2_pitch_macro, zero
00101f 9220 2885                 	sts pulse2_pitch_macro+1, zero
001021 9220 2889                 	sts pulse2_total_hi_pitch_offset, zero
001023 9220 288a                 	sts pulse2_hi_pitch_macro, zero
001025 9220 288b                 	sts pulse2_hi_pitch_macro+1, zero
001027 9220 288f                 	sts pulse2_duty_macro, zero
001029 9220 2890                 	sts pulse2_duty_macro+1, zero
                                 
                                 	//CHANNEL 1 ENVELOPE
00102b e02f                      	ldi pulse2_volume_divider, 0x0F
00102c 9130 2808                 	lds pulse2_volume_decay, pulse2_param
00102e 703f                      	andi pulse2_volume_decay, 0x0F //mask for VVVV bits
00102f 91d0 2808                 	lds r29, pulse2_param
001031 73d0                      	andi r29, 0b00110000
001032 62d0                      	sbr r29, 0b0100000 //set start flag
001033 95d2                      	swap r29
001034 2b9d                      	or pulse_channel_flags, r29
001035 9220 280e                 	sts pulse2_output_volume, zero
001037 93c0 280d                 	sts pulse2_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 1 LENGTH
001039 2eec                      	mov pulse2_length_counter, r28
                                 
                                 	//CHANNEL 1 SEQUENCE
00103a e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
00103b 2edc                      	mov pulse2_sequence, r28
                                 
                                 	//CHANNEL 1 SWEEP
00103c 90f0 2809                 	lds pulse2_sweep, pulse2_sweep_param
00103e 94f2                      	swap pulse2_sweep //swap data from high byte and low byte
00103f 6098                      	sbr pulse_channel_flags, 0b00001000 //set reload flag
                                 
                                 	//CHANNEL 1 FX
001040 efcf                      	ldi r28, 0xFF
001041 9220 2894                 	sts pulse2_fx_0xy_sequence, zero
001043 9220 2895                 	sts pulse2_fx_0xy_sequence+1, zero
001045 9220 2896                 	sts pulse2_fx_1xx, zero
001047 9220 2897                 	sts pulse2_fx_1xx+1, zero
001049 9220 2898                 	sts pulse2_fx_1xx_total, zero
00104b 9220 2899                 	sts pulse2_fx_1xx_total+1, zero
00104d 9220 289a                 	sts pulse2_fx_2xx, zero
00104f 9220 289b                 	sts pulse2_fx_2xx+1, zero
001051 9220 289c                 	sts pulse2_fx_2xx_total, zero
001053 9220 289d                 	sts pulse2_fx_2xx_total+1, zero
001055 9220 289e                 	sts pulse2_fx_3xx_start, zero
001057 9220 289f                 	sts pulse2_fx_3xx_start+1, zero
001059 9220 28a0                 	sts pulse2_fx_3xx_target, zero
00105b 9220 28a1                 	sts pulse2_fx_3xx_target+1, zero
00105d 9220 28a2                 	sts pulse2_fx_3xx_speed, zero
00105f 9220 28a3                 	sts pulse2_fx_3xx_speed+1, zero
001061 9220 28a4                 	sts pulse2_fx_3xx_total_offset, zero
001063 9220 28a5                 	sts pulse2_fx_3xx_total_offset+1, zero
001065 9220 28a6                 	sts pulse2_fx_4xy_speed, zero
001067 9220 28a7                 	sts pulse2_fx_4xy_depth, zero
001069 9220 28a8                 	sts pulse2_fx_4xy_phase, zero
00106b 9220 28a9                 	sts pulse2_fx_7xy_speed, zero
00106d 9220 28aa                 	sts pulse2_fx_7xy_depth, zero
00106f 9220 28ab                 	sts pulse2_fx_7xy_phase, zero
001071 9220 28ac                 	sts pulse2_fx_7xy_value, zero
001073 9220 28ad                 	sts pulse2_fx_Axy, zero
001075 93c0 28ae                 	sts pulse2_fx_Gxx_pre, r28
001077 93c0 28af                 	sts pulse2_fx_Gxx_post, r28
001079 9220 28b0                 	sts pulse2_fx_Pxx_total, zero
00107b 9220 28b1                 	sts pulse2_fx_Pxx_total+1, zero
00107d 9220 28b2                 	sts pulse2_fx_Qxy_target, zero
00107f 9220 28b3                 	sts pulse2_fx_Qxy_target+1, zero
001081 9220 28b4                 	sts pulse2_fx_Qxy_speed, zero
001083 9220 28b5                 	sts pulse2_fx_Qxy_speed+1, zero
001085 9220 28b6                 	sts pulse2_fx_Qxy_total_offset, zero
001087 9220 28b7                 	sts pulse2_fx_Qxy_total_offset+1, zero
001089 9220 28b8                 	sts pulse2_fx_Rxy_target, zero
00108b 9220 28b9                 	sts pulse2_fx_Rxy_target+1, zero
00108d 9220 28ba                 	sts pulse2_fx_Rxy_speed, zero
00108f 9220 28bb                 	sts pulse2_fx_Rxy_speed+1, zero
001091 9220 28bc                 	sts pulse2_fx_Rxy_total_offset, zero
001093 9220 28bd                 	sts pulse2_fx_Rxy_total_offset+1, zero
001095 93c0 28be                 	sts pulse2_fx_Sxx_pre, r28
001097 93c0 28bf                 	sts pulse2_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 2 instrument macros
001099 efcf                      	ldi r28, 0xFF
00109a 9220 28c8                 	sts triangle_volume_macro_offset, zero
00109c 93c0 28c9                 	sts triangle_volume_macro_loop, r28
00109e 93c0 28ca                 	sts triangle_volume_macro_release, r28
0010a0 9220 28cd                 	sts triangle_arpeggio_macro_offset, zero
0010a2 93c0 28ce                 	sts triangle_arpeggio_macro_loop, r28
0010a4 93c0 28cf                 	sts triangle_arpeggio_macro_release, r28
0010a6 93c0 28d0                 	sts triangle_arpeggio_macro_mode, r28
0010a8 9220 28d5                 	sts triangle_pitch_macro_offset, zero
0010aa 93c0 28d6                 	sts triangle_pitch_macro_loop, r28
0010ac 93c0 28d7                 	sts triangle_pitch_macro_release, r28
0010ae 9220 28db                 	sts triangle_hi_pitch_macro_offset, zero
0010b0 93c0 28dc                 	sts triangle_hi_pitch_macro_loop, r28
0010b2 93c0 28dd                 	sts triangle_hi_pitch_macro_release, r28
0010b4 9220 28e0                 	sts triangle_duty_macro_offset, zero
0010b6 93c0 28e1                 	sts triangle_duty_macro_loop, r28
0010b8 93c0 28e2                 	sts triangle_duty_macro_release, r28
                                 
0010ba 9220 28c6                 	sts triangle_volume_macro, zero
0010bc 9220 28c7                 	sts triangle_volume_macro+1, zero
0010be 9220 28cb                 	sts triangle_arpeggio_macro, zero
0010c0 9220 28cc                 	sts triangle_arpeggio_macro+1, zero
0010c2 9220 28d1                 	sts triangle_total_pitch_offset, zero
0010c4 9220 28d2                 	sts triangle_total_pitch_offset+1, zero
0010c6 9220 28d3                 	sts triangle_pitch_macro, zero
0010c8 9220 28d4                 	sts triangle_pitch_macro+1, zero
0010ca 9220 28d8                 	sts triangle_total_hi_pitch_offset, zero
0010cc 9220 28d9                 	sts triangle_hi_pitch_macro, zero
0010ce 9220 28da                 	sts triangle_hi_pitch_macro+1, zero
0010d0 9220 28de                 	sts triangle_duty_macro, zero
0010d2 9220 28df                 	sts triangle_duty_macro+1, zero
                                 
                                 	//CHANNEL 2 SEQUENCE
0010d4 e0c0                      	ldi r28, 0b00000000 //reset sequence to 0
0010d5 2f4c                      	mov triangle_sequence, r28
                                 
                                 	//CHANNEL 2 FX
0010d6 efcf                      	ldi r28, 0xFF
0010d7 9220 28e3                 	sts triangle_fx_0xy_sequence, zero
0010d9 9220 28e4                 	sts triangle_fx_0xy_sequence+1, zero
0010db 9220 28e5                 	sts triangle_fx_1xx, zero
0010dd 9220 28e6                 	sts triangle_fx_1xx+1, zero
0010df 9220 28e7                 	sts triangle_fx_1xx_total, zero
0010e1 9220 28e8                 	sts triangle_fx_1xx_total+1, zero
0010e3 9220 28e9                 	sts triangle_fx_2xx, zero
0010e5 9220 28ea                 	sts triangle_fx_2xx+1, zero
0010e7 9220 28eb                 	sts triangle_fx_2xx_total, zero
0010e9 9220 28ec                 	sts triangle_fx_2xx_total+1, zero
0010eb 9220 28ed                 	sts triangle_fx_3xx_start, zero
0010ed 9220 28ee                 	sts triangle_fx_3xx_start+1, zero
0010ef 9220 28ef                 	sts triangle_fx_3xx_target, zero
0010f1 9220 28f0                 	sts triangle_fx_3xx_target+1, zero
0010f3 9220 28f1                 	sts triangle_fx_3xx_speed, zero
0010f5 9220 28f2                 	sts triangle_fx_3xx_speed+1, zero
0010f7 9220 28f3                 	sts triangle_fx_3xx_total_offset, zero
0010f9 9220 28f4                 	sts triangle_fx_3xx_total_offset+1, zero
0010fb 9220 28f5                 	sts triangle_fx_4xy_speed, zero
0010fd 9220 28f6                 	sts triangle_fx_4xy_depth, zero
0010ff 9220 28f7                 	sts triangle_fx_4xy_phase, zero
001101 93c0 28f8                 	sts triangle_fx_Gxx_pre, r28
001103 93c0 28f9                 	sts triangle_fx_Gxx_post, r28
001105 9220 28fa                 	sts triangle_fx_Pxx_total, zero
001107 9220 28fb                 	sts triangle_fx_Pxx_total+1, zero
001109 9220 28fc                 	sts triangle_fx_Qxy_target, zero
00110b 9220 28fd                 	sts triangle_fx_Qxy_target+1, zero
00110d 9220 28fe                 	sts triangle_fx_Qxy_speed, zero
00110f 9220 28ff                 	sts triangle_fx_Qxy_speed+1, zero
001111 9220 2900                 	sts triangle_fx_Qxy_total_offset, zero
001113 9220 2901                 	sts triangle_fx_Qxy_total_offset+1, zero
001115 9220 2902                 	sts triangle_fx_Rxy_target, zero
001117 9220 2903                 	sts triangle_fx_Rxy_target+1, zero
001119 9220 2904                 	sts triangle_fx_Rxy_speed, zero
00111b 9220 2905                 	sts triangle_fx_Rxy_speed+1, zero
00111d 9220 2906                 	sts triangle_fx_Rxy_total_offset, zero
00111f 9220 2907                 	sts triangle_fx_Rxy_total_offset+1, zero
001121 93c0 2908                 	sts triangle_fx_Sxx_pre, r28
001123 93c0 2909                 	sts triangle_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 3 instrument macros
001125 efcf                      	ldi r28, 0xFF
001126 9220 2912                 	sts noise_volume_macro_offset, zero
001128 93c0 2913                 	sts noise_volume_macro_loop, r28
00112a 93c0 2914                 	sts noise_volume_macro_release, r28
00112c 9220 2917                 	sts noise_arpeggio_macro_offset, zero
00112e 93c0 2918                 	sts noise_arpeggio_macro_loop, r28
001130 93c0 2919                 	sts noise_arpeggio_macro_release, r28
001132 93c0 291a                 	sts noise_arpeggio_macro_mode, r28
001134 9220 291f                 	sts noise_pitch_macro_offset, zero
001136 93c0 2920                 	sts noise_pitch_macro_loop, r28
001138 93c0 2921                 	sts noise_pitch_macro_release, r28
00113a 9220 2925                 	sts noise_hi_pitch_macro_offset, zero
00113c 93c0 2926                 	sts noise_hi_pitch_macro_loop, r28
00113e 93c0 2927                 	sts noise_hi_pitch_macro_release, r28
001140 9220 292a                 	sts noise_duty_macro_offset, zero
001142 93c0 292b                 	sts noise_duty_macro_loop, r28
001144 93c0 292c                 	sts noise_duty_macro_release, r28
                                 
001146 9220 2910                 	sts noise_volume_macro, zero
001148 9220 2911                 	sts noise_volume_macro+1, zero
00114a 9220 2915                 	sts noise_arpeggio_macro, zero
00114c 9220 2916                 	sts noise_arpeggio_macro+1, zero
00114e 9220 291b                 	sts noise_total_pitch_offset, zero
001150 9220 291c                 	sts noise_total_pitch_offset+1, zero
001152 9220 291d                 	sts noise_pitch_macro, zero
001154 9220 291e                 	sts noise_pitch_macro+1, zero
001156 9220 2922                 	sts noise_total_hi_pitch_offset, zero
001158 9220 2923                 	sts noise_hi_pitch_macro, zero
00115a 9220 2924                 	sts noise_hi_pitch_macro+1, zero
00115c 9220 2928                 	sts noise_duty_macro, zero
00115e 9220 2929                 	sts noise_duty_macro+1, zero
                                 
                                 	//CHANNEL 3 VOLUME
001160 9220 2816                 	sts noise_output_volume, zero
001162 93c0 2815                 	sts noise_fractional_volume, r28 //initialize fractional volume to max value
                                 
                                 	//CHANNEL 3 SEQUENCE
001164 e0c1                      	ldi r28, 0b00000001 //noise sequence is reset to 0x0001
001165 2f5c                      	mov noise_sequence_LOW, r28
001166 2d62                      	mov noise_sequence_HIGH, zero
                                 
                                 	//CHANNEL 3 FX
001167 efcf                      	ldi r28, 0xFF
001168 9220 292d                 	sts noise_fx_0xy_sequence, zero
00116a 9220 292e                 	sts noise_fx_0xy_sequence+1, zero
00116c 9220 292f                 	sts noise_fx_1xx, zero
00116e 9220 2930                 	sts noise_fx_1xx+1, zero
001170 9220 2931                 	sts noise_fx_1xx_total, zero
001172 9220 2932                 	sts noise_fx_1xx_total+1, zero
001174 9220 2933                 	sts noise_fx_2xx, zero
001176 9220 2934                 	sts noise_fx_2xx+1, zero
001178 9220 2935                 	sts noise_fx_2xx_total, zero
00117a 9220 2936                 	sts noise_fx_2xx_total+1, zero
00117c 9220 2937                 	sts noise_fx_3xx_start, zero
00117e 9220 2938                 	sts noise_fx_3xx_start+1, zero
001180 9220 2939                 	sts noise_fx_3xx_target, zero
001182 9220 293a                 	sts noise_fx_3xx_target+1, zero
001184 9220 293b                 	sts noise_fx_3xx_speed, zero
001186 9220 293c                 	sts noise_fx_3xx_speed+1, zero
001188 9220 293d                 	sts noise_fx_3xx_total_offset, zero
00118a 9220 293e                 	sts noise_fx_3xx_total_offset+1, zero
00118c 9220 293f                 	sts noise_fx_4xy_speed, zero
00118e 9220 2940                 	sts noise_fx_4xy_depth, zero
001190 9220 2941                 	sts noise_fx_4xy_phase, zero
001192 9220 2942                 	sts noise_fx_7xy_speed, zero
001194 9220 2943                 	sts noise_fx_7xy_depth, zero
001196 9220 2944                 	sts noise_fx_7xy_phase, zero
001198 9220 2945                 	sts noise_fx_7xy_value, zero
00119a 9220 2946                 	sts noise_fx_Axy, zero
00119c 93c0 2947                 	sts noise_fx_Gxx_pre, r28
00119e 93c0 2948                 	sts noise_fx_Gxx_post, r28
0011a0 9220 2949                 	sts noise_fx_Pxx_total, zero
0011a2 9220 294a                 	sts noise_fx_Pxx_total+1, zero
0011a4 9220 294b                 	sts noise_fx_Qxy_target, zero
0011a6 9220 294c                 	sts noise_fx_Qxy_target+1, zero
0011a8 9220 294d                 	sts noise_fx_Qxy_speed, zero
0011aa 9220 294e                 	sts noise_fx_Qxy_speed+1, zero
0011ac 9220 294f                 	sts noise_fx_Qxy_total_offset, zero
0011ae 9220 2950                 	sts noise_fx_Qxy_total_offset+1, zero
0011b0 9220 2951                 	sts noise_fx_Rxy_target, zero
0011b2 9220 2952                 	sts noise_fx_Rxy_target+1, zero
0011b4 9220 2953                 	sts noise_fx_Rxy_speed, zero
0011b6 9220 2954                 	sts noise_fx_Rxy_speed+1, zero
0011b8 9220 2955                 	sts noise_fx_Rxy_total_offset, zero
0011ba 9220 2956                 	sts noise_fx_Rxy_total_offset+1, zero
0011bc 93c0 2957                 	sts noise_fx_Sxx_pre, r28
0011be 93c0 2958                 	sts noise_fx_Sxx_post, r28
                                 
                                 	//PINS
0011c0 efcf                      	ldi r28, 0xFF
0011c1 b9c0                      	out VPORTA_DIR, r28 //set all pins in VPORTA to output
                                 
                                 	//TIMERS
                                 	//Frame Counter
                                 	//NOTE:The frame counter will be defaulted to NTSC mode (60 Hz, 120 Hz, 240 Hz)
                                 	//Each interrupt will be setup to interrupt every 240 Hz clock
                                 	//CMP0 = sequence 0, CMP1 = sequence 1, CMP2 = sequence 2, OVF = sequence 3/sound driver
                                 	//Sequence 3 will clock the sound driver every 60Hz, in which new audio data is read and written to the registers
                                 	//Timer period Calculation: (0.00416666666 * 20000000/64)-1 = 1301.08333125 = 0x0515
                                 	//The ATmega4809 is cofigured to run at 20000000 Hz
                                 	//0.00416666666 seconds is the period for 240 Hz
                                 	//The /64 comes from the prescaler divider used
0011c2 e7c0                      	ldi r28, TCA_SINGLE_CMP0EN_bm | TCA_SINGLE_CMP1EN_bm | TCA_SINGLE_CMP2EN_bm | TCA_SINGLE_WGMODE_NORMAL_gc //interrupt mode
0011c3 93c0 0a01                 	sts TCA0_SINGLE_CTRLB, r28
0011c5 e7c1                      	ldi r28, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP1_bm | TCA_SINGLE_CMP2_bm | TCA_SINGLE_OVF_bm //enable overflow and compare interrupts
0011c6 93c0 0a0a                 	sts TCA0_SINGLE_INTCTRL, r28
0011c8 e1c5                      	ldi r28, 0x15 //set the period for CMP0
0011c9 93c0 0a28                 	sts TCA0_SINGLE_CMP0, r28
0011cb e0c5                      	ldi r28, 0x05
0011cc 93c0 0a29                 	sts TCA0_SINGLE_CMP0 + 1, r28
0011ce e2cb                      	ldi r28, 0x2B //set the period for CMP1
0011cf 93c0 0a2a                 	sts TCA0_SINGLE_CMP1, r28
0011d1 e0ca                      	ldi r28, 0x0A
0011d2 93c0 0a2b                 	sts TCA0_SINGLE_CMP1 + 1, r28
0011d4 e4c1                      	ldi r28, 0x41 //set the period for CMP2
0011d5 93c0 0a2c                 	sts TCA0_SINGLE_CMP2, r28
0011d7 e0cf                      	ldi r28, 0x0F
0011d8 93c0 0a2d                 	sts TCA0_SINGLE_CMP2 + 1, r28
0011da e5c7                      	ldi r28, 0x57 //set the period for OVF
0011db 93c0 0a26                 	sts TCA0_SINGLE_PER, r28
0011dd e1c4                      	ldi r28, 0x14
0011de 93c0 0a27                 	sts TCA0_SINGLE_PER + 1, r28
0011e0 e0cb                      	ldi r28, TCA_SINGLE_CLKSEL_DIV64_gc | TCA_SINGLE_ENABLE_bm //use prescale divider of 64 and enable timer
0011e1 93c0 0a00                 	sts TCA0_SINGLE_CTRLA, r28
                                 
                                 	//NOTE: Channel Timers are clocked (20/2)/(0.8948865) = 11.1746014718 times faster than the NES APU
                                 	//Because of this, we multiply all the NES timer values by 11.1746014718 beforehand
                                 	//Since we rotate the sequence when the timer goes from t-(t-1) to 0, instead of 0 to t like the NES, we add 1 to the NES timers before multiplying
                                 	//The ATmega4809 is configured to run at 20 MHz
                                 	//The /2 comes from the prescaler divider used
                                 	//0.8948865 MHz is the speed of the NTSC NES APU
                                 	//NOTE: This means that any offset to the pitch for the NES timers would be multiplied by 11.1746014718 aswell.
                                 	//Pulse 1
0011e3 e0c0                      	ldi r28, TCB_CNTMODE_INT_gc //interrupt mode
0011e4 93c0 0a81                 	sts TCB0_CTRLB, r28
0011e6 e0c1                      	ldi r28, TCB_CAPT_bm //enable interrupts
0011e7 93c0 0a85                 	sts TCB0_INTCTRL, r28
0011e9 91c0 2802                 	lds r28, pulse1_timerL //load the LOW bits for timer
0011eb 93c0 0a8c                 	sts TCB0_CCMPL, r28
0011ed 91c0 2803                 	lds r28, pulse1_timerH //load the HIGH bits for timer
0011ef 93c0 0a8d                 	sts TCB0_CCMPH, r28
0011f1 e0c3                      	ldi r28, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
0011f2 93c0 0a80                 	sts TCB0_CTRLA, r28
                                 
                                 	//PULSE 2
0011f4 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
0011f5 93b0 0a91                 	sts TCB1_CTRLB, r27
0011f7 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
0011f8 93b0 0a95                 	sts TCB1_INTCTRL, r27
0011fa 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
0011fc 93b0 0a9c                 	sts TCB1_CCMPL, r27
0011fe 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
001200 93b0 0a9d                 	sts TCB1_CCMPH, r27
001202 e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
001203 93b0 0a90                 	sts TCB1_CTRLA, r27
                                 
                                 	//NOTE: The triangle timer is clocked at the same speed as the NES CPU, aka twice the NES APU.
                                 	//Therefore, we won't be using a /2 clock divider like we did with the pulse timers.
                                 	//TRIANGLE
001205 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
001206 93b0 0aa1                 	sts TCB2_CTRLB, r27
001208 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
                                 	//sts TCB2_INTCTRL, r27 //keep interrupts disabled to mute channel since triangle doesn't have volume bits
001209 91b0 2810                 	lds r27, triangle_timerL //load the LOW bits for timer
00120b 93b0 0aac                 	sts TCB2_CCMPL, r27
00120d 91b0 2811                 	lds r27, triangle_timerH //load the HIGH bits for timer
00120f 93b0 0aad                 	sts TCB2_CCMPH, r27
001211 e0b1                      	ldi r27, TCB_CLKSEL_CLKDIV1_gc | TCB_ENABLE_bm //use prescaler divider of 1 and enable timer
001212 93b0 0aa0                 	sts TCB2_CTRLA, r27
001214 9478                      	sei //global interrupt enable
                                 
                                 	//NOISE
001215 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
001216 93b0 0ab1                 	sts TCB3_CTRLB, r27
001218 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001219 93b0 0ab5                 	sts TCB3_INTCTRL, r27
00121b 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
00121d 93b0 0abc                 	sts TCB3_CCMPL, r27
00121f 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
001221 93b0 0abd                 	sts TCB3_CCMPH, r27
001223 e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
001224 93b0 0ab0                 	sts TCB3_CTRLA, r27
                                 
                                 
                                 
                                 //https://wiki.nesdev.com/w/index.php/APU_Mixer
                                 volume_mixer:
001226 91c0 2806                 	lds r28, pulse1_output_volume
001228 91d0 280e                 	lds r29, pulse2_output_volume
                                 
                                 volume_mixer_pulse1:
00122a fea0                      	sbrs pulse1_sequence, 0 //if the sequence output is zero, return
00122b c015                      	rjmp volume_mixer_pulse1_off
                                 
00122c 14b2                      	cp pulse1_length_counter, zero //if length is zero, return
00122d f099                      	breq volume_mixer_pulse1_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
00122e 91e0 0a8c                 	lds r30, TCB0_CCMPL
001230 e5f9                      	ldi r31, 0x059
001231 17ef                      	cp r30, r31
001232 91e0 0a8d                 	lds r30, TCB0_CCMPH
001234 e0f0                      	ldi r31, 0x00
001235 07ef                      	cpc r30, r31
001236 f050                      	brlo volume_mixer_pulse1_off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $5965
001237 91e0 0a8c                 	lds r30, TCB0_CCMPL
001239 e6f6                      	ldi r31, 0x66
00123a 17ef                      	cp r30, r31
00123b 91e0 0a8d                 	lds r30, TCB0_CCMPH
00123d e5f9                      	ldi r31, 0x59
00123e 07ef                      	cpc r30, r31
00123f f408                      	brsh volume_mixer_pulse1_off
001240 c001                      	rjmp volume_mixer_pulse2 //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse1_off:
001241 27cc                      	clr r28
                                 
                                 volume_mixer_pulse2:
001242 fed0                      	sbrs pulse2_sequence, 0 //if the sequence output is zero, return
001243 c015                      	rjmp volume_mixer_pulse2_off
                                 
001244 14e2                      	cp pulse2_length_counter, zero //if length is zero, return
001245 f099                      	breq volume_mixer_pulse2_off
                                 
001246 91e0 0a9c                 	lds r30, TCB1_CCMPL
001248 e5f9                      	ldi r31, 0x059
001249 17ef                      	cp r30, r31
00124a 91e0 0a9d                 	lds r30, TCB1_CCMPH
00124c e0f0                      	ldi r31, 0x00
00124d 07ef                      	cpc r30, r31
00124e f050                      	brlo volume_mixer_pulse2_off
                                 
00124f 91e0 0a9c                 	lds r30, TCB1_CCMPL
001251 e6f6                      	ldi r31, 0x66
001252 17ef                      	cp r30, r31
001253 91e0 0a9d                 	lds r30, TCB1_CCMPH
001255 e5f9                      	ldi r31, 0x59
001256 07ef                      	cpc r30, r31
001257 f408                      	brsh volume_mixer_pulse2_off
001258 c001                      	rjmp volume_mixer_pulse_out //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse2_off:
001259 27dd                      	clr r29
                                 
                                 volume_mixer_pulse_out:
00125a 0fcd                      	add r28, r29
00125b e6e2                      	ldi ZL, LOW(pulse_volume_table << 1)
00125c e0f2                      	ldi ZH, HIGH(pulse_volume_table << 1)
00125d 0fec                      	add ZL, r28
00125e 1df2                      	adc ZH, zero
00125f 91c4                      	lpm r28, Z
                                 
                                 volume_mixer_tnd_triangle:
001260 2fd4                      	mov r29, triangle_sequence
001261 fdd4                      	sbrc r29, 4 //check 5th bit
001262 95d0                      	com r29
001263 70df                      	andi r29, 0x0F
001264 2fed                      	mov r30, r29
001265 0fde                      	add r29, r30 //multiply the triangle volume by 3
001266 0fde                      	add r29, r30
                                 
                                 volume_mixer_tnd_noise:
001267 ff50                      	sbrs noise_sequence_LOW, 0 //check 0th bit, skip if set
001268 c004                      	rjmp volume_mixer_tnd_out
001269 91e0 2816                 	lds r30, noise_output_volume
00126b 0fee                      	lsl r30 //multiply noise volume by 2
00126c 0fde                      	add r29, r30
                                 
                                 volume_mixer_tnd_out:
00126d e8e2                      	ldi ZL, LOW(tnd_volume_table << 1)
00126e e0f2                      	ldi ZH, HIGH(tnd_volume_table << 1)
00126f 0fed                      	add ZL, r29
001270 1df2                      	adc ZH, zero
001271 91d4                      	lpm r29, Z
                                 
                                 volume_mixer_output:
001272 0fcd                      	add r28, r29
001273 b9c1                      	out VPORTA_OUT, r28
001274 cfb1                      	rjmp volume_mixer
                                 
                                 
                                 
                                 //FRAME COUNTER/AUDIO SAMPLE ISR
                                 sequence_0_2:
001275 b7bf                      	in r27, CPU_SREG
001276 93bf                      	push r27
001277 94f8                      	cli
                                 
                                 	//ENVELOPE
001278 d053                      	rcall pulse1_envelope_routine
001279 d09f                      	rcall pulse2_envelope_routine
                                 
00127a e5b0                      	ldi r27, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP2_bm //clear OVF flag
00127b 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
00127d 91bf                      	pop r27
00127e bfbf                      	out CPU_SREG, r27
00127f 9518                      	reti
                                 
                                 sequence_1_3:
001280 b7bf                      	in r27, CPU_SREG
001281 93bf                      	push r27
001282 94f8                      	cli
                                 
                                 	//ENVELOPE
001283 d048                      	rcall pulse1_envelope_routine
001284 d094                      	rcall pulse2_envelope_routine
                                 
                                 	//SWEEP
001285 fcc3                      	sbrc pulse1_sweep, 3 //check if the sweep enable bit is cleared
001286 d01b                      	rcall pulse1_sweep_routine
001287 fcf3                      	sbrc pulse2_sweep, 3
001288 d066                      	rcall pulse2_sweep_routine
                                 
                                 	//LENGTH
                                 	//NOTE: The length routine is relatively simple, so we will not be using clocks to rjmp and ret to a seperate lable
                                 sequence_1_3_pulse1_length:
001289 fd95                      	sbrc pulse_channel_flags, 5 //check if the length counter halt bit is cleared
00128a c002                      	rjmp sequence_1_3_pulse2_length
00128b 10b2                      	cpse pulse1_length_counter, zero //if length counter is already 0, don't decrement
00128c 94ba                      	dec pulse1_length_counter
                                 sequence_1_3_pulse2_length:
00128d fd91                      	sbrc pulse_channel_flags, 1 //check if the length counter halt bit is cleared
00128e c002                      	rjmp sequence_1_3_exit
00128f 10e2                      	cpse pulse2_length_counter, zero //if length counter is already 0, don't decrement
001290 94ea                      	dec pulse2_length_counter
                                 
                                 sequence_1_3_exit:
001291 e2b1                      	ldi r27, TCA_SINGLE_CMP1_bm | TCA_SINGLE_OVF_bm //clear OVF flag
001292 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
001294 91bf                      	pop r27
001295 bfbf                      	out CPU_SREG, r27
001296 9518                      	reti
                                 
                                 //PULSE 1 ROUTINES
                                 pulse1_sequence_routine:
001297 b7bf                      	in r27, CPU_SREG
001298 93bf                      	push r27
001299 94f8                      	cli
                                 
00129a 0caa                      	lsl pulse1_sequence //shifts sequence to the left
00129b 1ca2                      	adc pulse1_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
00129c e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
00129d 93b0 0a86                 	sts TCB0_INTFLAGS, r27
00129f 91bf                      	pop r27
0012a0 bfbf                      	out CPU_SREG, r27
0012a1 9518                      	reti
                                 
                                 pulse1_sweep_routine:
0012a2 2dbc                      	mov r27, pulse1_sweep
0012a3 70b7                      	andi r27, 0x07 //mask for period divider bits
0012a4 f4f9                      	brne pulse1_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse1_sweep_routine_action: //if the divider is == 0, update the pulse timer period
0012a5 93df                      	push r29
0012a6 2ddc                      	mov r29, pulse1_sweep
0012a7 95d2                      	swap r29
0012a8 70d7                      	andi r29, 0x07 //mask for shift bits
0012a9 f411                      	brne pulse1_sweep_routine_action_main //shift != 0
0012aa 91df                      	pop r29
0012ab c019                      	rjmp pulse1_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse1_sweep_routine_action_main:
0012ac 91a0 0a8c                 	lds r26, TCB0_CCMPL
0012ae 91b0 0a8d                 	lds r27, TCB0_CCMPH
                                 pulse1_sweep_routine_action_main_loop:
0012b0 95b6                      	lsr r27
0012b1 95a7                      	ror r26
0012b2 95da                      	dec r29
0012b3 f7e1                      	brne pulse1_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
0012b4 fec7                      	sbrs pulse1_sweep, 7 //check the negate flag
0012b5 c002                      	rjmp pulse1_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
0012b6 95a0                      	com r26 //pulse1 uses one's complement if the negate flag is set
0012b7 95b0                      	com r27
                                 
                                 pulse1_sweep_routine_action_main_add:
0012b8 91d0 0a8c                 	lds r29, TCB0_CCMPL //perform addition to get new timer period
0012ba 0fad                      	add r26, r29
0012bb 91d0 0a8d                 	lds r29, TCB0_CCMPH
0012bd 1fbd                      	adc r27, r29
                                 
0012be 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new LOW bits for timer
0012c0 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new HIGH bits for timer
                                 	
0012c2 91df                      	pop r29
0012c3 c001                      	rjmp pulse1_sweep_routine_check_reload
                                 
                                 pulse1_sweep_routine_decrement_divider:
0012c4 94ca                      	dec pulse1_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse1_sweep_routine_check_reload:
0012c5 ff97                      	sbrs pulse_channel_flags, 7 //if the reload flag is set, reload the sweep divider
0012c6 9508                      	ret
                                 
                                 pulse1_sweep_reload:
0012c7 90c0 2801                 	lds pulse1_sweep, pulse1_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
0012c9 94c2                      	swap pulse1_sweep //bring data from high byte to low byte
0012ca 779f                      	cbr pulse_channel_flags, 0b10000000 //clear reload flag
0012cb 9508                      	ret
                                 
                                 
                                 
                                 pulse1_envelope_routine:
0012cc fd96                      	sbrc pulse_channel_flags, 6 //check if start flag is cleared
0012cd c010                      	rjmp pulse1_envelope_routine_clear_start
                                 
0012ce 3000                      	cpi pulse1_volume_divider, 0x00 //check if the divider is 0
0012cf f011                      	breq PC+3 //if the divider == 0, check loop flag
0012d0 950a                      	dec pulse1_volume_divider //if the divider != 0, decrement and return
0012d1 9508                      	ret
                                 
0012d2 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the divider == 0, reset the divider period
0012d4 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
0012d5 ff95                      	sbrs pulse_channel_flags, 5 //check if the loop flag is set
0012d6 c002                      	rjmp pulse1_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
0012d7 e01f                      	ldi pulse1_volume_decay, 0x0F //if the loop flag is set, reset decay and return
0012d8 9508                      	ret
                                 
                                 pulse1_envelope_routine_decrement_decay:
0012d9 3010                      	cpi pulse1_volume_decay, 0x00 //check if the decay is 0
0012da f409                      	brne PC+2 //if decay != 0, go decrement
0012db 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
0012dc 951a                      	dec pulse1_volume_decay
0012dd 9508                      	ret
                                 
                                 pulse1_envelope_routine_clear_start:
0012de 7b9f                      	cbr pulse_channel_flags, 0b01000000 //if the start flag is set, clear it
0012df 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the start flag is set, reset the divider period
0012e1 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
0012e2 e01f                      	ldi pulse1_volume_decay, 0x0F //if the start flag is set, reset decay
0012e3 9508                      	ret
                                 
                                 //PULSE 2 ROUTINES
                                 pulse2_sequence_routine:
0012e4 b7bf                      	in r27, CPU_SREG
0012e5 93bf                      	push r27
0012e6 94f8                      	cli
                                 
0012e7 0cdd                      	lsl pulse2_sequence //shifts sequence to the left
0012e8 1cd2                      	adc pulse2_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
0012e9 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
0012ea 93b0 0a96                 	sts TCB1_INTFLAGS, r27
0012ec 91bf                      	pop r27
0012ed bfbf                      	out CPU_SREG, r27
0012ee 9518                      	reti
                                 
                                 pulse2_sweep_routine:
0012ef 2dbf                      	mov r27, pulse2_sweep
0012f0 70b7                      	andi r27, 0x07 //mask for period divider bits
0012f1 f4f9                      	brne pulse2_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse2_sweep_routine_action: //if the divider is == 0, update the pulse timer period
0012f2 93df                      	push r29
0012f3 2ddf                      	mov r29, pulse2_sweep
0012f4 95d2                      	swap r29
0012f5 70d7                      	andi r29, 0x07 //mask for shift bits
0012f6 f411                      	brne pulse2_sweep_routine_action_main //shift != 0
0012f7 91df                      	pop r29
0012f8 c019                      	rjmp pulse2_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse2_sweep_routine_action_main:
0012f9 91a0 0a9c                 	lds r26, TCB1_CCMPL
0012fb 91b0 0a9d                 	lds r27, TCB1_CCMPH
                                 pulse2_sweep_routine_action_main_loop:
0012fd 95b6                      	lsr r27
0012fe 95a7                      	ror r26
0012ff 95da                      	dec r29
001300 f7e1                      	brne pulse2_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
001301 fef7                      	sbrs pulse2_sweep, 7 //check the negate flag
001302 c002                      	rjmp pulse2_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
001303 95a0                      	com r26 //pulse2 uses one's complement if the negate flag is set
001304 95b0                      	com r27
                                 
                                 pulse2_sweep_routine_action_main_add:
001305 91d0 0a9c                 	lds r29, TCB1_CCMPL //perform addition to get new timer period
001307 0fad                      	add r26, r29
001308 91d0 0a9d                 	lds r29, TCB1_CCMPH
00130a 1fbd                      	adc r27, r29
                                 
00130b 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new LOW bits for timer
00130d 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new HIGH bits for timer
                                 	
00130f 91df                      	pop r29
001310 c001                      	rjmp pulse2_sweep_routine_check_reload
                                 
                                 pulse2_sweep_routine_decrement_divider:
001311 94fa                      	dec pulse2_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse2_sweep_routine_check_reload:
001312 ff93                      	sbrs pulse_channel_flags, 3 //if the reload flag is set, reload the sweep divider
001313 9508                      	ret
                                 
                                 pulse2_sweep_reload:
001314 90f0 2809                 	lds pulse2_sweep, pulse2_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
001316 94f2                      	swap pulse2_sweep //bring data from high byte to low byte
001317 7f97                      	cbr pulse_channel_flags, 0b00001000 //clear reload flag
001318 9508                      	ret
                                 
                                 
                                 
                                 pulse2_envelope_routine:
001319 fd92                      	sbrc pulse_channel_flags, 2 //check if start flag is cleared
00131a c010                      	rjmp pulse2_envelope_routine_clear_start
                                 
00131b 3020                      	cpi pulse2_volume_divider, 0x00 //check if the divider is 0
00131c f011                      	breq PC+3 //if the divider == 0, check loop flag
00131d 952a                      	dec pulse2_volume_divider //if the divider != 0, decrement and return
00131e 9508                      	ret
                                 
00131f 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the divider == 0, reset the divider period
001321 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
001322 ff91                      	sbrs pulse_channel_flags, 1 //check if the loop flag is set
001323 c002                      	rjmp pulse2_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
001324 e03f                      	ldi pulse2_volume_decay, 0x0F //if the loop flag is set, reset decay and return
001325 9508                      	ret
                                 
                                 pulse2_envelope_routine_decrement_decay:
001326 3030                      	cpi pulse2_volume_decay, 0x00 //check if the decay is 0
001327 f409                      	brne PC+2 //if decay != 0, go decrement
001328 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
001329 953a                      	dec pulse2_volume_decay
00132a 9508                      	ret
                                 
                                 pulse2_envelope_routine_clear_start:
00132b 7f9b                      	cbr pulse_channel_flags, 0b00000100 //if the start flag is set, clear it
00132c 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the start flag is set, reset the divider period
00132e 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
00132f e03f                      	ldi pulse2_volume_decay, 0x0F //if the start flag is set, reset decay
001330 9508                      	ret
                                 
                                 //TRIANGLE ROUTINES
                                 triangle_sequence_routine:
001331 b7bf                      	in r27, CPU_SREG
001332 93bf                      	push r27
001333 94f8                      	cli
                                 
001334 5f4f                      	subi triangle_sequence, -1 //increment sequence by 1
001335 714f                      	andi triangle_sequence, 0b00011111 //mask out bits 5, 6 and 7 NOTE: the sequence only needs bits 0-4.
                                 
001336 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
001337 93b0 0aa6                 	sts TCB2_INTFLAGS, r27
001339 91bf                      	pop r27
00133a bfbf                      	out CPU_SREG, r27
00133b 9518                      	reti
                                 
                                 //NOISE ROUTINES
                                 noise_sequence_routine:
00133c b7bf                      	in r27, CPU_SREG
00133d 93bf                      	push r27
00133e 94f8                      	cli
                                 
00133f 2fa5                      	mov r26, noise_sequence_LOW
001340 fd67                      	sbrc noise_sequence_HIGH, 7 //skip if MODE bit is clear
001341 c00b                      	rjmp noise_sequence_routine_mode_set
                                 
                                 noise_sequence_routine_mode_clear:
001342 95a6                      	lsr r26 //move the 1th bit to the 0th bit place
001343 27a5                      	eor r26, noise_sequence_LOW
001344 fda0                      	sbrc r26, 0 //skip if the EOR of bit 0 and 1 is clear
001345 c003                      	rjmp noise_sequence_routine_mode_clear_EOR_set
                                 
                                 noise_sequence_routine_mode_clear_EOR_clear:
001346 9566                      	lsr noise_sequence_HIGH
001347 9557                      	ror noise_sequence_LOW
001348 c013                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_clear_EOR_set:
001349 9566                      	lsr noise_sequence_HIGH
00134a 9557                      	ror noise_sequence_LOW
00134b 6460                      	ori noise_sequence_HIGH, 0b01000000 //set the 14th bit
00134c c00f                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_set:
00134d 0faa                      	lsl r26
00134e 1faa                      	rol r26
00134f 1faa                      	rol r26 //move the 6th bit to the 0th bit place
001350 27a5                      	eor r26, noise_sequence_LOW
001351 fda0                      	sbrc r26, 0 //skip if the EOR of bit 0 and 1 is clear
001352 c005                      	rjmp noise_sequence_routine_mode_set_EOR_set
                                 
                                 noise_sequence_routine_mode_set_EOR_clear:
001353 776f                      	cbr noise_sequence_HIGH, 0b10000000 //clear the MODE flag
001354 9566                      	lsr noise_sequence_HIGH
001355 9557                      	ror noise_sequence_LOW
001356 6860                      	sbr noise_sequence_HIGH, 0b10000000 //set the MODE flag
001357 c004                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_set_EOR_set:
001358 9566                      	lsr noise_sequence_HIGH
001359 9557                      	ror noise_sequence_LOW
00135a 6860                      	sbr noise_sequence_HIGH, 0b10000000 //set the MODE flag
00135b c000                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_exit:
00135c e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
00135d 93b0 0ab6                 	sts TCB3_INTFLAGS, r27
00135f 91bf                      	pop r27
001360 bfbf                      	out CPU_SREG, r27
001361 9518                      	reti
                                 
                                 //CONVERTERS
                                 //converts and loads 5 bit length to corresponding 8 bit length value into r29
                                 length_converter:
001362 e9e0                      	ldi ZL, LOW(length << 1)
001363 e5fb                      	ldi ZH, HIGH(length << 1)
001364 0fed                      	add ZL, r29
001365 1df2                      	adc ZH, zero
001366 91d4                      	lpm r29, Z
001367 9508                      	ret
                                 
                                 //loads pulse sequence into r29
                                 duty_cycle_sequences:
001368 ebe0                      	ldi ZL, LOW(sequences << 1)
001369 e5fb                      	ldi ZH, HIGH(sequences << 1)
00136a 0fed                      	add ZL, r29
00136b 1df2                      	adc ZH, zero
00136c 91d4                      	lpm r29, Z
00136d 9508                      	ret
                                 
                                 
                                 
                                 //SOUND DRIVER
                                 sound_driver:
00136e b7bf                      	in r27, CPU_SREG
00136f 93bf                      	push r27
001370 94f8                      	cli
001371 93cf                      	push r28
001372 93df                      	push r29
001373 93ef                      	push r30
001374 93ff                      	push r31
                                 
                                 	//SOUND DRIVER
001375 91a0 281f                 	lds r26, song_fx_Bxx
001377 3faf                      	cpi r26, 0xFF //0xFF means that the flag is disabled
001378 f4a9                      	brne sound_driver_fx_Bxx_routine
001379 91a0 2820                 	lds r26, song_fx_Cxx
00137b 11a2                      	cpse r26, zero
00137c c08b                      	rjmp sound_driver_fx_Cxx_routine
00137d 91a0 2821                 	lds r26, song_fx_Dxx
00137f 11a2                      	cpse r26, zero
001380 c096                      	rjmp sound_driver_fx_Dxx_routine
                                 
001381 91a0 281a                 	lds r26, song_frame_offset
001383 91b0 281b                 	lds r27, song_frame_offset+1
001385 91c0 281c                 	lds r28, song_size
001387 91d0 281d                 	lds r29, song_size+1
001389 17ac                      	cp r26, r28
00138a 07bd                      	cpc r27, r29
00138b f408                      	brsh sound_driver_fx_song_loop
00138c c101                      	rjmp sound_driver_channel0
                                 
                                 
                                 sound_driver_fx_song_loop:
00138d e0a0                      	ldi r26, 0x00
                                 sound_driver_fx_Bxx_routine:
00138e 91e0 2818                 	lds ZL, song_frames
001390 91f0 2819                 	lds ZH, song_frames+1
001392 27cc                      	clr r28 //initialize r29:r28 to 0
001393 27dd                      	clr r29
001394 95a3                      	inc r26 //increment xx parameter by 1
                                 sound_driver_fx_Bxx_routine_loop:
001395 95aa                      	dec r26
001396 f011                      	breq sound_driver_fx_Bxx_routine_loop_exit //once r26 == 0, r29:r28 will hold Bxx*(5*2).
001397 962a                      	adiw r29:r28, 10 //increment the offset by 10 because 5 channels, and each address takes 2 bytes (5*2 = 10)
001398 cffc                      	rjmp sound_driver_fx_Bxx_routine_loop
                                 
                                 sound_driver_fx_Bxx_routine_loop_exit:
001399 9622                      	adiw r29:r28, 2 //add 2 to skip the first 2 bytes (first 2 bytes is the song size)
00139a 93c0 281a                 	sts song_frame_offset, r28
00139c 93d0 281b                 	sts song_frame_offset+1, r29
00139e 0fec                      	add ZL, r28
00139f 1ffd                      	adc ZH, r29
                                 
0013a0 91a5                      	lpm r26, Z+ //load the address of the frame(pattern)
0013a1 91b5                      	lpm r27, Z+
0013a2 0faa                      	lsl r26
0013a3 1fbb                      	rol r27
0013a4 93a0 2822                 	sts pulse1_pattern, r26
0013a6 93b0 2823                 	sts pulse1_pattern+1, r27
0013a8 91a5                      	lpm r26, Z+
0013a9 91b5                      	lpm r27, Z+
0013aa 0faa                      	lsl r26
0013ab 1fbb                      	rol r27
0013ac 93a0 2871                 	sts pulse2_pattern, r26
0013ae 93b0 2872                 	sts pulse2_pattern+1, r27
0013b0 91a5                      	lpm r26, Z+
0013b1 91b5                      	lpm r27, Z+
0013b2 0faa                      	lsl r26
0013b3 1fbb                      	rol r27
0013b4 93a0 28c0                 	sts triangle_pattern, r26
0013b6 93b0 28c1                 	sts triangle_pattern+1, r27
0013b8 91a5                      	lpm r26, Z+
0013b9 91b5                      	lpm r27, Z+
0013ba 0faa                      	lsl r26
0013bb 1fbb                      	rol r27
0013bc 93a0 290a                 	sts noise_pattern, r26
0013be 93b0 290b                 	sts noise_pattern+1, r27
                                 
0013c0 9220 2826                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
0013c2 9220 2827                 	sts pulse1_pattern_offset+1, zero
0013c4 9220 2824                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
0013c6 9220 2825                 	sts pulse1_pattern_delay_frames, zero
0013c8 9220 2875                 	sts pulse2_pattern_offset, zero
0013ca 9220 2876                 	sts pulse2_pattern_offset+1, zero
0013cc 9220 2873                 	sts pulse2_pattern_delay_rows, zero
0013ce 9220 2874                 	sts pulse2_pattern_delay_frames, zero
0013d0 9220 28c4                 	sts triangle_pattern_offset, zero
0013d2 9220 28c5                 	sts triangle_pattern_offset+1, zero
0013d4 9220 28c2                 	sts triangle_pattern_delay_rows, zero
0013d6 9220 28c3                 	sts triangle_pattern_delay_frames, zero
0013d8 9220 290e                 	sts noise_pattern_offset, zero
0013da 9220 290f                 	sts noise_pattern_offset+1, zero
0013dc 9220 290c                 	sts noise_pattern_delay_rows, zero
0013de 9220 290d                 	sts noise_pattern_delay_frames, zero
                                 
0013e0 efaf                      	ldi r26, 0xFF
0013e1 93a0 285f                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
0013e3 93a0 2860                 	sts pulse1_fx_Gxx_post, r26
0013e5 93a0 286f                 	sts pulse1_fx_Sxx_pre, r26
0013e7 93a0 2870                 	sts pulse1_fx_Sxx_post, r26
0013e9 93a0 28ae                 	sts pulse2_fx_Gxx_pre, r26
0013eb 93a0 28af                 	sts pulse2_fx_Gxx_post, r26
0013ed 93a0 28be                 	sts pulse2_fx_Sxx_pre, r26
0013ef 93a0 28bf                 	sts pulse2_fx_Sxx_post, r26
0013f1 93a0 28f8                 	sts triangle_fx_Gxx_pre, r26
0013f3 93a0 28f9                 	sts triangle_fx_Gxx_post, r26
0013f5 93a0 2908                 	sts triangle_fx_Sxx_pre, r26
0013f7 93a0 2909                 	sts triangle_fx_Sxx_post, r26
0013f9 93a0 2947                 	sts noise_fx_Gxx_pre, r26
0013fb 93a0 2948                 	sts noise_fx_Gxx_post, r26
0013fd 93a0 2957                 	sts noise_fx_Sxx_pre, r26
0013ff 93a0 2958                 	sts noise_fx_Sxx_post, r26
                                 
001401 93a0 281f                 	sts song_fx_Bxx, r26 //reset all song effects
001403 9220 2820                 	sts song_fx_Cxx, zero
001405 9220 2821                 	sts song_fx_Dxx, zero
001407 c086                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_fx_Cxx_routine:
001408 91ff                      	pop r31
001409 91ef                      	pop r30
00140a 91df                      	pop r29
00140b 91cf                      	pop r28
00140c 91bf                      	pop r27
00140d bfbf                      	out CPU_SREG, r27
00140e 94f8                      	cli //disable global interrupts
                                 		
00140f efaf                      	ldi r26, 0xFF
001410 93a0 281f                 	sts song_fx_Bxx, r26 //reset all song effects
001412 9220 2820                 	sts song_fx_Cxx, zero
001414 9220 2821                 	sts song_fx_Dxx, zero
001416 9518                      	reti
                                 
                                 sound_driver_fx_Dxx_routine:
001417 91e0 2818                 	lds ZL, song_frames
001419 91f0 2819                 	lds ZH, song_frames+1
00141b 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
00141d 91b0 281b                 	lds r27, song_frame_offset+1
00141f 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
001420 93a0 281a                 	sts song_frame_offset, r26
001422 93b0 281b                 	sts song_frame_offset+1, r27
001424 0fea                      	add ZL, r26
001425 1ffb                      	adc ZH, r27
                                 
001426 91a5                      	lpm r26, Z+ //load the address of the next pattern
001427 91b5                      	lpm r27, Z+
001428 0faa                      	lsl r26
001429 1fbb                      	rol r27
00142a 93a0 2822                 	sts pulse1_pattern, r26
00142c 93b0 2823                 	sts pulse1_pattern+1, r27
00142e 91a5                      	lpm r26, Z+
00142f 91b5                      	lpm r27, Z+
001430 0faa                      	lsl r26
001431 1fbb                      	rol r27
001432 93a0 2871                 	sts pulse2_pattern, r26
001434 93b0 2872                 	sts pulse2_pattern+1, r27
001436 91a5                      	lpm r26, Z+
001437 91b5                      	lpm r27, Z+
001438 0faa                      	lsl r26
001439 1fbb                      	rol r27
00143a 93a0 28c0                 	sts triangle_pattern, r26
00143c 93b0 28c1                 	sts triangle_pattern+1, r27
00143e 91a5                      	lpm r26, Z+
00143f 91b5                      	lpm r27, Z+
001440 0faa                      	lsl r26
001441 1fbb                      	rol r27
001442 93a0 290a                 	sts noise_pattern, r26
001444 93b0 290b                 	sts noise_pattern+1, r27
                                 
001446 9220 2826                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001448 9220 2827                 	sts pulse1_pattern_offset+1, zero
00144a 9220 2824                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
00144c 9220 2825                 	sts pulse1_pattern_delay_frames, zero
00144e 9220 2875                 	sts pulse2_pattern_offset, zero
001450 9220 2876                 	sts pulse2_pattern_offset+1, zero
001452 9220 2873                 	sts pulse2_pattern_delay_rows, zero
001454 9220 2874                 	sts pulse2_pattern_delay_frames, zero
001456 9220 28c4                 	sts triangle_pattern_offset, zero
001458 9220 28c5                 	sts triangle_pattern_offset+1, zero
00145a 9220 28c2                 	sts triangle_pattern_delay_rows, zero
00145c 9220 28c3                 	sts triangle_pattern_delay_frames, zero
00145e 9220 290e                 	sts noise_pattern_offset, zero
001460 9220 290f                 	sts noise_pattern_offset+1, zero
001462 9220 290c                 	sts noise_pattern_delay_rows, zero
001464 9220 290d                 	sts noise_pattern_delay_frames, zero
                                 
001466 efaf                      	ldi r26, 0xFF
001467 93a0 285f                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
001469 93a0 2860                 	sts pulse1_fx_Gxx_post, r26
00146b 93a0 286f                 	sts pulse1_fx_Sxx_pre, r26
00146d 93a0 2870                 	sts pulse1_fx_Sxx_post, r26
00146f 93a0 28ae                 	sts pulse2_fx_Gxx_pre, r26
001471 93a0 28af                 	sts pulse2_fx_Gxx_post, r26
001473 93a0 28be                 	sts pulse2_fx_Sxx_pre, r26
001475 93a0 28bf                 	sts pulse2_fx_Sxx_post, r26
001477 93a0 28f8                 	sts triangle_fx_Gxx_pre, r26
001479 93a0 28f9                 	sts triangle_fx_Gxx_post, r26
00147b 93a0 2908                 	sts triangle_fx_Sxx_pre, r26
00147d 93a0 2909                 	sts triangle_fx_Sxx_post, r26
00147f 93a0 2947                 	sts noise_fx_Gxx_pre, r26
001481 93a0 2948                 	sts noise_fx_Gxx_post, r26
001483 93a0 2957                 	sts noise_fx_Sxx_pre, r26
001485 93a0 2958                 	sts noise_fx_Sxx_post, r26
                                 
001487 93a0 281f                 	sts song_fx_Bxx, r26 //reset all song effects
001489 9220 2820                 	sts song_fx_Cxx, zero
00148b 9220 2821                 	sts song_fx_Dxx, zero
00148d c000                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0:
00148e 91a0 2824                 	lds r26, pulse1_pattern_delay_rows
001490 91b0 2825                 	lds r27, pulse1_pattern_delay_frames
001492 9610                      	adiw r27:r26, 0
001493 f009                      	breq sound_driver_channel0_main //if the pattern delay is 0, proceed with sound driver procedures
001494 c2e4                      	rjmp sound_driver_channel0_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel0_main:
001495 91e0 2822                 	lds ZL, pulse1_pattern //current pattern for pulse 1
001497 91f0 2823                 	lds ZH, pulse1_pattern+1
001499 91a0 2826                 	lds r26, pulse1_pattern_offset //current offset in the pattern for pulse 1
00149b 91b0 2827                 	lds r27, pulse1_pattern_offset+1
00149d 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
00149e 1ffb                      	adc ZH, r27
00149f 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel0_check_if_note: //check if data is a note (0x00 - 0x56)
0014a0 35b7                      	cpi r27, 0x57
0014a1 f408                      	brsh sound_driver_channel0_check_if_volume
0014a2 c180                      	rjmp sound_driver_channel0_note
                                 sound_driver_channel0_check_if_volume: //check if data is volume (0x57-0x66)
0014a3 36b7                      	cpi r27, 0x67
0014a4 f408                      	brsh sound_driver_channel0_check_if_delay
0014a5 c1ba                      	rjmp sound_driver_channel0_volume
                                 sound_driver_channel0_check_if_delay: //check if data is a delay (0x67 - 0xE2)
0014a6 3eb3                      	cpi r27, 0xE3
0014a7 f408                      	brsh sound_driver_channel0_check_if_instrument
0014a8 c1c1                      	rjmp sound_driver_channel0_delay
                                 sound_driver_channel0_check_if_instrument: //check for instrument flag (0xE3)
0014a9 f409                      	brne sound_driver_channel0_check_if_release
0014aa c1c4                      	rjmp sound_driver_channel0_instrument_change 
                                 sound_driver_channel0_check_if_release: //check for note release flag (0xE4)
0014ab 3eb4                      	cpi r27, 0xE4
0014ac f409                      	brne sound_driver_channel0_check_if_end
0014ad c26d                      	rjmp sound_driver_channel0_release
                                 sound_driver_channel0_check_if_end:
0014ae 3fbf                      	cpi r27, 0xFF
0014af f409                      	brne sound_driver_channel0_check_if_fx
0014b0 c28f                      	rjmp sound_driver_channel0_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel0_check_if_fx: //fx flags (0xE5 - 0xFE)
0014b1 9631                      	adiw Z, 1 //point Z to the byte next to the flag
0014b2 91a4                      	lpm r26, Z //load the fx data into r26
0014b3 d2bb                      	rcall sound_driver_channel0_increment_offset_twice
                                 
0014b4 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
0014b5 ebe4                      	ldi ZL, LOW(channel0_fx << 1) //load in note table
0014b6 e5fb                      	ldi ZH, HIGH(channel0_fx << 1)
0014b7 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
0014b8 0feb                      	add ZL, r27 //add offset
0014b9 1df2                      	adc ZH, zero
0014ba 91c5                      	lpm r28, Z+ //load address bytes
0014bb 91d4                      	lpm r29, Z
0014bc 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
0014bd 2ffd                      	mov ZH, r29
0014be 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel0_fx_0xy:
0014bf 93a0 2845                 	sts pulse1_fx_0xy_sequence, r26
0014c1 9220 2846                 	sts pulse1_fx_0xy_sequence+1, zero
0014c3 cfd1                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel0_fx_1xx:
0014c4 9220 284b                 	sts pulse1_fx_2xx, zero //turn off any 2xx pitch slide down
0014c6 9220 284c                 	sts pulse1_fx_2xx+1, zero
0014c8 9220 2845                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
0014ca 9220 2846                 	sts pulse1_fx_0xy_sequence+1, zero
0014cc 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0014cd 937f                      	push r23
0014ce 2f6a                      	mov r22, r26 //store the rate into r22
0014cf eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0014d0 9f67                      	mul r22, r23
0014d1 917f                      	pop r23
0014d2 916f                      	pop r22
                                 
0014d3 9416                      	lsr r1 //shift out the fractional bits
0014d4 9407                      	ror r0
0014d5 9416                      	lsr r1
0014d6 9407                      	ror r0
0014d7 9416                      	lsr r1
0014d8 9407                      	ror r0
0014d9 9416                      	lsr r1
0014da 9407                      	ror r0
0014db 9200 2847                 	sts pulse1_fx_1xx, r0
0014dd 9210 2848                 	sts pulse1_fx_1xx+1, r1
0014df cfb5                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel0_fx_2xx:
0014e0 9220 2847                 	sts pulse1_fx_1xx, zero //turn off any 1xx pitch slide down
0014e2 9220 2848                 	sts pulse1_fx_1xx+1, zero
0014e4 9220 2845                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
0014e6 9220 2846                 	sts pulse1_fx_0xy_sequence+1, zero
0014e8 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0014e9 937f                      	push r23
0014ea 2f6a                      	mov r22, r26 //store the rate into r22
0014eb eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0014ec 9f67                      	mul r22, r23
0014ed 917f                      	pop r23
0014ee 916f                      	pop r22
                                 
0014ef 9416                      	lsr r1 //shift out the fractional bits
0014f0 9407                      	ror r0
0014f1 9416                      	lsr r1
0014f2 9407                      	ror r0
0014f3 9416                      	lsr r1
0014f4 9407                      	ror r0
0014f5 9416                      	lsr r1
0014f6 9407                      	ror r0
0014f7 9200 284b                 	sts pulse1_fx_2xx, r0
0014f9 9210 284c                 	sts pulse1_fx_2xx+1, r1
0014fb cf99                      	rjmp sound_driver_channel0_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel0_fx_3xx:
0014fc 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0014fd 937f                      	push r23
0014fe 2f6a                      	mov r22, r26 //store the rate into r22
0014ff eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001500 9f67                      	mul r22, r23
001501 917f                      	pop r23
001502 916f                      	pop r22
                                 
001503 9416                      	lsr r1 //shift out the fractional bits
001504 9407                      	ror r0
001505 9416                      	lsr r1
001506 9407                      	ror r0
001507 9416                      	lsr r1
001508 9407                      	ror r0
001509 9416                      	lsr r1
00150a 9407                      	ror r0
00150b 9200 2853                 	sts pulse1_fx_3xx_speed, r0
00150d 9210 2854                 	sts pulse1_fx_3xx_speed+1, r1
                                 
00150f 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001510 c001                      	rjmp sound_driver_channel0_fx_3xx_enabled
001511 cf83                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_3xx_enabled:
001512 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001514 91b0 0a8d                 	lds r27, TCB0_CCMPH
001516 93a0 284f                 	sts pulse1_fx_3xx_start, r26
001518 93b0 2850                 	sts pulse1_fx_3xx_start+1, r27
                                 
00151a 9220 2855                 	sts pulse1_fx_3xx_total_offset, zero
00151c 9220 2856                 	sts pulse1_fx_3xx_total_offset+1, zero
00151e cf76                      	rjmp sound_driver_channel0_main
                                 
                                 //VIBRATO
                                 sound_driver_channel0_fx_4xy:
00151f 2fba                      	mov r27, r26
001520 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001521 95a2                      	swap r26
001522 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001523 93a0 2857                 	sts pulse1_fx_4xy_speed, r26
001525 93b0 2858                 	sts pulse1_fx_4xy_depth, r27
001527 9220 2859                 	sts pulse1_fx_4xy_phase, zero //reset the phase to 0
001529 cf6b                      	rjmp sound_driver_channel0_main
                                 
                                 //TREMELO
                                 sound_driver_channel0_fx_7xy:
00152a 2fba                      	mov r27, r26
00152b 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
00152c 95a2                      	swap r26
00152d 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
00152e 93a0 285a                 	sts pulse1_fx_7xy_speed, r26
001530 93b0 285b                 	sts pulse1_fx_7xy_depth, r27
001532 9220 285c                 	sts pulse1_fx_7xy_phase, zero //reset the phase to 0
001534 9220 285d                 	sts pulse1_fx_7xy_value, zero //reset the tremelo value
001536 cf5e                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel0_fx_Axy:
001537 93a0 285e                 	sts pulse1_fx_Axy, r26
001539 cf5b                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel0_fx_Bxx:
00153a 93a0 281f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
00153c cf58                      	rjmp sound_driver_channel0_main
                                 
                                 //HALT
                                 sound_driver_channel0_fx_Cxx:
00153d 93b0 2820                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
00153f cf55                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel0_fx_Dxx:
001540 93b0 2821                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001542 cf52                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME
                                 sound_driver_channel0_fx_Exx:
001543 91b0 2800                 	lds r27, pulse1_param
001545 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
001546 2bba                      	or r27, r26 //move new VVVV bits into pulse1_param
001547 93b0 2800                 	sts pulse1_param, r27
001549 6096                      	sbr pulse_channel_flags, 6
00154a cf4a                      	rjmp sound_driver_channel0_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel0_fx_Fxx:
00154b 93a0 281e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
00154d cf47                      	rjmp sound_driver_channel0_main
                                 
                                 //DELAY
                                 sound_driver_channel0_fx_Gxx:
00154e 15a2                      	cp r26, zero
00154f f051                      	breq sound_driver_channel0_fx_Gxx_invalid
001550 91b0 281e                 	lds r27, song_speed
001552 17ab                      	cp r26, r27
001553 f430                      	brsh sound_driver_channel0_fx_Gxx_invalid
001554 93a0 285f                 	sts pulse1_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001556 e0b1                      	ldi r27, 0x01
001557 93b0 2824                 	sts pulse1_pattern_delay_rows, r27
001559 c222                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Gxx_invalid:
00155a cf3a                      	rjmp sound_driver_channel0_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel0_fx_Hxy: //hardware sweep up
00155b cf39                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixy: //hardware sweep down
00155c cf38                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Hxx: //FDS modulation depth
00155d cf37                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixx: //FDS modulation speed
00155e cf36                      	rjmp sound_driver_channel0_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel0_fx_Pxx:
00155f 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001560 937f                      	push r23
001561 2f6a                      	mov r22, r26
001562 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001563 0367                      	mulsu r22, r23
001564 917f                      	pop r23
001565 916f                      	pop r22
001566 9416                      	lsr r1 //shift out the fractional bits
001567 9407                      	ror r0
001568 9416                      	lsr r1
001569 9407                      	ror r0
00156a 9416                      	lsr r1
00156b 9407                      	ror r0
00156c 9416                      	lsr r1
00156d 9407                      	ror r0
00156e fe13                      	sbrs r1, 3 //check if result was a negative number
00156f c002                      	rjmp sound_driver_channel0_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel0_fx_Pxx_negative:
001570 efb0                      	ldi r27, 0xF0
001571 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel0_fx_Pxx_store:
001572 9200 2861                 	sts pulse1_fx_Pxx_total, r0
001574 9210 2862                 	sts pulse1_fx_Pxx_total+1, r1
001576 cf1e                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel0_fx_Qxy:
                                 sound_driver_channel0_fx_Qxy_check_arpeggio_macro:
001577 91e0 282d                 	lds ZL, pulse1_arpeggio_macro
001579 91f0 282e                 	lds ZH, pulse1_arpeggio_macro+1
00157b 9630                      	adiw Z, 0
00157c f009                      	breq sound_driver_channel0_fx_Qxy_check_pitch_macro
00157d cf17                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_pitch_macro:
00157e 91e0 2835                 	lds ZL, pulse1_pitch_macro
001580 91f0 2836                 	lds ZH, pulse1_pitch_macro+1
001582 9630                      	adiw Z, 0
001583 f009                      	breq sound_driver_channel0_fx_Qxy_check_hi_pitch_macro
001584 cf10                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_hi_pitch_macro:
001585 91e0 283b                 	lds ZL, pulse1_hi_pitch_macro
001587 91f0 283c                 	lds ZH, pulse1_hi_pitch_macro+1
001589 9630                      	adiw Z, 0
00158a f009                      	breq sound_driver_channel0_fx_Qxy_process
00158b cf09                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_process:
00158c 2fba                      	mov r27, r26 //copy fx parameters into r27
00158d 70bf                      	andi r27, 0x0F //mask note index offset
00158e 91c0 2807                 	lds r28, pulse1_note //load current note index
001590 0fbc                      	add r27, r28
001591 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001592 f008                      	brlo sound_driver_channel0_fx_Qxy_process_continue
001593 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel0_fx_Qxy_process_continue:
001594 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001595 e0f0                      	ldi ZH, HIGH(note_table << 1)
001596 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001597 0feb                      	add ZL, r27 //add offset
001598 1df2                      	adc ZH, zero
001599 91c5                      	lpm r28, Z+ //load bytes
00159a 91d4                      	lpm r29, Z
00159b 93c0 2863                 	sts pulse1_fx_Qxy_target, r28 //load the LOW bits for the target period
00159d 93d0 2864                 	sts pulse1_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
00159f 95a2                      	swap r26
0015a0 70af                      	andi r26, 0x0F //mask effect speed
0015a1 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0015a2 95a3                      	inc r26 //increment the speed by 1
                                 
0015a3 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0015a4 937f                      	push r23
0015a5 2f6a                      	mov r22, r26 //store the speed data into r27
0015a6 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0015a7 9f67                      	mul r22, r23
0015a8 917f                      	pop r23
0015a9 916f                      	pop r22
                                 
0015aa 9416                      	lsr r1 //shift out the fractional bits
0015ab 9407                      	ror r0
0015ac 9416                      	lsr r1
0015ad 9407                      	ror r0
0015ae 9416                      	lsr r1
0015af 9407                      	ror r0
0015b0 9416                      	lsr r1
0015b1 9407                      	ror r0
                                 
0015b2 9200 2865                 	sts pulse1_fx_Qxy_speed, r0 //store the effect speed
0015b4 9210 2866                 	sts pulse1_fx_Qxy_speed+1, r1
0015b6 9220 2867                 	sts pulse1_fx_Qxy_total_offset, zero
0015b8 9220 2868                 	sts pulse1_fx_Qxy_total_offset+1, zero
0015ba ceda                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel0_fx_Rxy:
                                 sound_driver_channel0_fx_Rxy_check_arpeggio_macro:
0015bb 91e0 282d                 	lds ZL, pulse1_arpeggio_macro
0015bd 91f0 282e                 	lds ZH, pulse1_arpeggio_macro+1
0015bf 9630                      	adiw Z, 0
0015c0 f009                      	breq sound_driver_channel0_fx_Rxy_check_pitch_macro
0015c1 ced3                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_pitch_macro:
0015c2 91e0 2835                 	lds ZL, pulse1_pitch_macro
0015c4 91f0 2836                 	lds ZH, pulse1_pitch_macro+1
0015c6 9630                      	adiw Z, 0
0015c7 f009                      	breq sound_driver_channel0_fx_Rxy_check_hi_pitch_macro
0015c8 cecc                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_hi_pitch_macro:
0015c9 91e0 283b                 	lds ZL, pulse1_hi_pitch_macro
0015cb 91f0 283c                 	lds ZH, pulse1_hi_pitch_macro+1
0015cd 9630                      	adiw Z, 0
0015ce f009                      	breq sound_driver_channel0_fx_Rxy_process
0015cf cec5                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_process:
0015d0 2fba                      	mov r27, r26 //copy fx parameters into r27
0015d1 70bf                      	andi r27, 0x0F //mask note index offset
0015d2 91c0 2807                 	lds r28, pulse1_note //load current note index
0015d4 1bcb                      	sub r28, r27
0015d5 f408                      	brcc sound_driver_channel0_fx_Rxy_process_continue
0015d6 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel0_fx_Rxy_process_continue:
0015d7 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0015d8 e0f0                      	ldi ZH, HIGH(note_table << 1)
0015d9 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
0015da 0fec                      	add ZL, r28 //add offset
0015db 1df2                      	adc ZH, zero
0015dc 91c5                      	lpm r28, Z+ //load bytes
0015dd 91d4                      	lpm r29, Z
0015de 93c0 2869                 	sts pulse1_fx_Rxy_target, r28 //load the LOW bits for the target period
0015e0 93d0 286a                 	sts pulse1_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
0015e2 95a2                      	swap r26
0015e3 70af                      	andi r26, 0x0F //mask effect speed
0015e4 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0015e5 95a3                      	inc r26 //increment the speed by 1
                                 
0015e6 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0015e7 937f                      	push r23
0015e8 2f6a                      	mov r22, r26 //store the speed data into r27
0015e9 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0015ea 9f67                      	mul r22, r23
0015eb 917f                      	pop r23
0015ec 916f                      	pop r22
                                 
0015ed 9416                      	lsr r1 //shift out the fractional bits
0015ee 9407                      	ror r0
0015ef 9416                      	lsr r1
0015f0 9407                      	ror r0
0015f1 9416                      	lsr r1
0015f2 9407                      	ror r0
0015f3 9416                      	lsr r1
0015f4 9407                      	ror r0
                                 
0015f5 9200 286b                 	sts pulse1_fx_Rxy_speed, r0 //store the effect speed
0015f7 9210 286c                 	sts pulse1_fx_Rxy_speed+1, r1
0015f9 9220 286d                 	sts pulse1_fx_Rxy_total_offset, zero
0015fb 9220 286e                 	sts pulse1_fx_Rxy_total_offset+1, zero
0015fd ce97                      	rjmp sound_driver_channel0_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel0_fx_Sxx:
0015fe 15a2                      	cp r26, zero
0015ff f051                      	breq sound_driver_channel0_fx_Sxx_invalid
001600 91b0 281e                 	lds r27, song_speed
001602 17ab                      	cp r26, r27
001603 f430                      	brsh sound_driver_channel0_fx_Sxx_invalid
001604 93a0 286f                 	sts pulse1_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001606 e0b1                      	ldi r27, 0x01
001607 93b0 2824                 	sts pulse1_pattern_delay_rows, r27
001609 c172                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Sxx_invalid:
00160a ce8a                      	rjmp sound_driver_channel0_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel0_fx_Vxx:
00160b ebe0                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
00160c e5fb                      	ldi ZH, HIGH(sequences << 1)
00160d 0fea                      	add ZL, r26 //offset the pointer
00160e 1df2                      	adc ZH, zero
                                 
00160f 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
001610 95a7                      	ror r26
001611 95a7                      	ror r26
001612 91b0 2800                 	lds r27, pulse1_param //load r27 with pulse1_param (register $4000)
001614 2fcb                      	mov r28, r27 //store a copy of pulse1_param into r28
001615 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
001616 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
001617 c001                      	rjmp sound_driver_channel0_fx_Vxx_store
001618 ce7c                      	rjmp sound_driver_channel0_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel0_fx_Vxx_store:
001619 90a4                      	lpm pulse1_sequence, Z //store the sequence
                                 
00161a 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
00161b 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
00161c 93c0 2800                 	sts pulse1_param, r28
00161e ce76                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_Wxx: //DPCM sample speed
00161f ce75                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Xxx: //DPCM sample retrigger
001620 ce74                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Yxx: //DPCM sample offset
001621 ce73                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Zxx: //DPCM sample delta counter
001622 ce72                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 sound_driver_channel0_note:
001623 93b0 2807                 	sts pulse1_note, r27 //store the note index
001625 e0a3                      	ldi r26, 0x03
001626 e0b2                      	ldi r27, 0x02
001627 93b0 282a                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
001629 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26
00162b 93b0 2837                 	sts pulse1_pitch_macro_offset, r27
00162d 93b0 283d                 	sts pulse1_hi_pitch_macro_offset, r27
00162f 93b0 2842                 	sts pulse1_duty_macro_offset, r27
001631 9220 2833                 	sts pulse1_total_pitch_offset, zero //reset the pitch and hi pitch offset
001633 9220 2834                 	sts pulse1_total_pitch_offset+1, zero
001635 9220 283a                 	sts pulse1_total_hi_pitch_offset, zero
001637 9220 2849                 	sts pulse1_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001639 9220 284a                 	sts pulse1_fx_1xx_total+1, zero
00163b 9220 284d                 	sts pulse1_fx_2xx_total, zero
00163d 9220 284e                 	sts pulse1_fx_2xx_total+1, zero
00163f 9220 2855                 	sts pulse1_fx_3xx_total_offset, zero //reset 3xx offset
001641 9220 2856                 	sts pulse1_fx_3xx_total_offset+1, zero
001643 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001645 91b0 0a8d                 	lds r27, TCB0_CCMPH
001647 93a0 284f                 	sts pulse1_fx_3xx_start, r26
001649 93b0 2850                 	sts pulse1_fx_3xx_start+1, r27
00164b 9220 2801                 	sts pulse1_sweep_param, zero //reset any sweep effect
00164d 6097                      	sbr pulse_channel_flags, 7 //set reload flag
00164e 9220 2863                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001650 9220 2864                 	sts pulse1_fx_Qxy_target+1, zero
001652 9220 2867                 	sts pulse1_fx_Qxy_total_offset, zero
001654 9220 2868                 	sts pulse1_fx_Qxy_total_offset+1, zero
001656 9220 2869                 	sts pulse1_fx_Rxy_target, zero
001658 9220 286a                 	sts pulse1_fx_Rxy_target+1, zero
00165a 9220 286d                 	sts pulse1_fx_Rxy_total_offset, zero
00165c 9220 286e                 	sts pulse1_fx_Rxy_total_offset+1, zero
00165e d106                      	rcall sound_driver_channel0_increment_offset
00165f ce35                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_volume:
001660 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001661 91a0 2800                 	lds r26, pulse1_param
001663 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001664 2bab                      	or r26, r27 //move new VVVV bits into pulse1_param
001665 93a0 2800                 	sts pulse1_param, r26
001667 6096                      	sbr pulse_channel_flags, 6
001668 d0fc                      	rcall sound_driver_channel0_increment_offset
001669 ce2b                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_delay:
00166a 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
00166b 93b0 2824                 	sts pulse1_pattern_delay_rows, r27
00166d d0f7                      	rcall sound_driver_channel0_increment_offset
00166e c10d                      	rjmp sound_driver_channel1
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change:
00166f 9220 2828                 	sts pulse1_volume_macro, zero //reset all macro addresses
001671 9220 2829                 	sts pulse1_volume_macro+1, zero
001673 9220 282d                 	sts pulse1_arpeggio_macro, zero
001675 9220 282e                 	sts pulse1_arpeggio_macro+1, zero
001677 9220 2835                 	sts pulse1_pitch_macro, zero
001679 9220 2836                 	sts pulse1_pitch_macro+1, zero
00167b 9220 283b                 	sts pulse1_hi_pitch_macro, zero
00167d 9220 283c                 	sts pulse1_hi_pitch_macro+1, zero
00167f 9220 2840                 	sts pulse1_duty_macro, zero
001681 9220 2841                 	sts pulse1_duty_macro+1, zero
001683 9220 2833                 	sts pulse1_total_pitch_offset, zero //reset the pitch offset
001685 9220 2834                 	sts pulse1_total_pitch_offset+1, zero
001687 9220 283a                 	sts pulse1_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001689 9631                      	adiw Z, 1 //point to the byte next to the flag
00168a 91b4                      	lpm r27, Z //store the instrument offset into r27
00168b e2ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
00168c e0fd                      	ldi ZH, HIGH(instruments)
00168d 0feb                      	add ZL, r27 //point Z to offsetted instrument
00168e 1df2                      	adc ZH, zero
00168f 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001690 1fff                      	rol ZH
001691 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001692 91b4                      	lpm r27, Z
                                 
001693 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001694 1fbb                      	rol r27
001695 2fea                      	mov ZL, r26
001696 2ffb                      	mov ZH, r27
001697 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001698 9632                      	adiw Z, 2 //point Z to the address of the macro
001699 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel0_instrument_change_macro_loop:
00169a 95aa                      	dec r26
00169b f019                      	breq sound_driver_channel0_instrument_change_exit
00169c 95b6                      	lsr r27
00169d f078                      	brcs sound_driver_channel0_instrument_change_load_macro
00169e cffb                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_exit:
00169f e0a3                      	ldi r26, 0x03
0016a0 e0b2                      	ldi r27, 0x02
0016a1 93b0 282a                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
0016a3 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26
0016a5 93b0 2837                 	sts pulse1_pitch_macro_offset, r27
0016a7 93b0 283d                 	sts pulse1_hi_pitch_macro_offset, r27
0016a9 93b0 2842                 	sts pulse1_duty_macro_offset, r27
0016ab d0c3                      	rcall sound_driver_channel0_increment_offset_twice
0016ac cde8                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_load_macro:
0016ad 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
0016ae 91d5                      	lpm r29, Z+
                                 
0016af 30a5                      	cpi r26, 5
0016b0 f039                      	breq sound_driver_channel0_instrument_change_load_macro_volume
0016b1 30a4                      	cpi r26, 4
0016b2 f079                      	breq sound_driver_channel0_instrument_change_load_macro_arpeggio
0016b3 30a3                      	cpi r26, 3
0016b4 f0d9                      	breq sound_driver_channel0_instrument_change_load_macro_pitch
0016b5 30a2                      	cpi r26, 2
0016b6 f159                      	breq sound_driver_channel0_instrument_change_load_macro_hi_pitch
0016b7 c03c                      	rjmp sound_driver_channel0_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel0_instrument_change_load_macro_volume:
0016b8 93c0 2828                 	sts pulse1_volume_macro, r28
0016ba 93d0 2829                 	sts pulse1_volume_macro+1, r29
0016bc d041                      	rcall sound_driver_channel0_instrument_change_read_header
0016bd 93c0 282c                 	sts pulse1_volume_macro_release, r28
0016bf 93d0 282b                 	sts pulse1_volume_macro_loop, r29
0016c1 cfd8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 	
                                 sound_driver_channel0_instrument_change_load_macro_arpeggio:
0016c2 93c0 282d                 	sts pulse1_arpeggio_macro, r28
0016c4 93d0 282e                 	sts pulse1_arpeggio_macro+1, r29
0016c6 9220 2863                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0016c8 9220 2864                 	sts pulse1_fx_Qxy_target+1, zero
0016ca 9220 2869                 	sts pulse1_fx_Rxy_target, zero
0016cc 9220 286a                 	sts pulse1_fx_Rxy_target+1, zero
0016ce d03a                      	rcall sound_driver_channel0_instrument_change_read_header_arpeggio
0016cf cfca                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_pitch:
0016d0 93c0 2835                 	sts pulse1_pitch_macro, r28
0016d2 93d0 2836                 	sts pulse1_pitch_macro+1, r29
0016d4 9220 2863                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0016d6 9220 2864                 	sts pulse1_fx_Qxy_target+1, zero
0016d8 9220 2869                 	sts pulse1_fx_Rxy_target, zero
0016da 9220 286a                 	sts pulse1_fx_Rxy_target+1, zero
0016dc d021                      	rcall sound_driver_channel0_instrument_change_read_header
0016dd 93c0 2839                 	sts pulse1_pitch_macro_release, r28
0016df 93d0 2838                 	sts pulse1_pitch_macro_loop, r29
0016e1 cfb8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_hi_pitch:
0016e2 93c0 283b                 	sts pulse1_hi_pitch_macro, r28
0016e4 93d0 283c                 	sts pulse1_hi_pitch_macro+1, r29
0016e6 9220 2863                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0016e8 9220 2864                 	sts pulse1_fx_Qxy_target+1, zero
0016ea 9220 2869                 	sts pulse1_fx_Rxy_target, zero
0016ec 9220 286a                 	sts pulse1_fx_Rxy_target+1, zero
0016ee d00f                      	rcall sound_driver_channel0_instrument_change_read_header
0016ef 93c0 283f                 	sts pulse1_hi_pitch_macro_release, r28
0016f1 93d0 283e                 	sts pulse1_hi_pitch_macro_loop, r29
0016f3 cfa6                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_duty:
0016f4 93c0 2840                 	sts pulse1_duty_macro, r28
0016f6 93d0 2841                 	sts pulse1_duty_macro+1, r29
0016f8 d005                      	rcall sound_driver_channel0_instrument_change_read_header
0016f9 93c0 2844                 	sts pulse1_duty_macro_release, r28
0016fb 93d0 2843                 	sts pulse1_duty_macro_loop, r29
0016fd cf9c                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_read_header:
0016fe 93ef                      	push ZL
0016ff 93ff                      	push ZH
001700 2fec                      	mov ZL, r28
001701 2ffd                      	mov ZH, r29
001702 0fee                      	lsl ZL
001703 1fff                      	rol ZH
001704 91c5                      	lpm r28, Z+
001705 91d4                      	lpm r29, Z
001706 91ff                      	pop ZH
001707 91ef                      	pop ZL
001708 9508                      	ret
                                 
                                 sound_driver_channel0_instrument_change_read_header_arpeggio:
001709 93ef                      	push ZL
00170a 93ff                      	push ZH
00170b 2fec                      	mov ZL, r28
00170c 2ffd                      	mov ZH, r29
00170d 0fee                      	lsl ZL
00170e 1fff                      	rol ZH
00170f 91c5                      	lpm r28, Z+
001710 91d5                      	lpm r29, Z+
001711 93c0 2831                 	sts pulse1_arpeggio_macro_release, r28
001713 93d0 2830                 	sts pulse1_arpeggio_macro_loop, r29
001715 91c4                      	lpm r28, Z
001716 93c0 2832                 	sts pulse1_arpeggio_macro_mode, r28
001718 91ff                      	pop ZH
001719 91ef                      	pop ZL
00171a 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel0_release:
                                 sound_driver_channel0_release_volume:
00171b 91b0 282c                 	lds r27, pulse1_volume_macro_release
00171d 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
00171e f019                      	breq sound_driver_channel0_release_arpeggio //if the macro has no release flag, check the next macro
00171f 95b3                      	inc r27
001720 93b0 282a                 	sts pulse1_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel0_release_arpeggio:
001722 91b0 2831                 	lds r27, pulse1_arpeggio_macro_release
001724 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001725 f019                      	breq sound_driver_channel0_release_pitch
001726 95b3                      	inc r27
001727 93b0 282f                 	sts pulse1_arpeggio_macro_offset, r27
                                 sound_driver_channel0_release_pitch:
001729 91b0 2839                 	lds r27, pulse1_pitch_macro_release
00172b 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
00172c f019                      	breq sound_driver_channel0_release_hi_pitch
00172d 95b3                      	inc r27
00172e 93b0 2837                 	sts pulse1_pitch_macro_offset, r27
                                 sound_driver_channel0_release_hi_pitch:
001730 91b0 283f                 	lds r27, pulse1_hi_pitch_macro_release
001732 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001733 f019                      	breq sound_driver_channel0_release_duty
001734 95b3                      	inc r27
001735 93b0 283d                 	sts pulse1_hi_pitch_macro_offset, r27
                                 sound_driver_channel0_release_duty:
001737 91b0 2844                 	lds r27, pulse1_duty_macro_release
001739 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
00173a f019                      	breq sound_driver_channel0_release_exit
00173b 95b3                      	inc r27
00173c 93b0 2842                 	sts pulse1_duty_macro_offset, r27
                                 sound_driver_channel0_release_exit:
00173e d026                      	rcall sound_driver_channel0_increment_offset
00173f cd55                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_next_pattern:
001740 91e0 2818                 	lds ZL, song_frames
001742 91f0 2819                 	lds ZH, song_frames+1
001744 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001746 91b0 281b                 	lds r27, song_frame_offset+1
001748 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
001749 93a0 281a                 	sts song_frame_offset, r26
00174b 93b0 281b                 	sts song_frame_offset+1, r27
                                 
00174d 91c0 281c                 	lds r28, song_size
00174f 91d0 281d                 	lds r29, song_size+1
001751 17ac                      	cp r26, r28
001752 07bd                      	cpc r27, r29
001753 f010                      	brlo sound_driver_channel0_next_pattern_exists
001754 940c 2dc2                 	jmp sound_driver_exit
                                 
                                 sound_driver_channel0_next_pattern_exists:
001756 0fea                      	add ZL, r26
001757 1ffb                      	adc ZH, r27
                                 
001758 91a5                      	lpm r26, Z+ //load the address of the next pattern
001759 91b4                      	lpm r27, Z
00175a 0faa                      	lsl r26
00175b 1fbb                      	rol r27
00175c 93a0 2822                 	sts pulse1_pattern, r26
00175e 93b0 2823                 	sts pulse1_pattern+1, r27
                                 
001760 9220 2826                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001762 9220 2827                 	sts pulse1_pattern_offset+1, zero
001764 cd30                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_increment_offset:
001765 91e0 2826                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
001767 91f0 2827                 	lds ZH, pulse1_pattern_offset+1
001769 9631                      	adiw Z, 1
00176a 93e0 2826                 	sts pulse1_pattern_offset, ZL
00176c 93f0 2827                 	sts pulse1_pattern_offset+1, ZH
00176e 9508                      	ret
                                 
                                 sound_driver_channel0_increment_offset_twice: //used for data that takes up 2 bytes worth of space
00176f 91e0 2826                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
001771 91f0 2827                 	lds ZH, pulse1_pattern_offset+1
001773 9632                      	adiw Z, 2 //increment the pointer twice
001774 93e0 2826                 	sts pulse1_pattern_offset, ZL
001776 93f0 2827                 	sts pulse1_pattern_offset+1, ZH
001778 9508                      	ret
                                 
                                 sound_driver_channel0_decrement_frame_delay:
001779 95ba                      	dec r27
00177a 93b0 2825                 	sts pulse1_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel1:
00177c 91a0 2873                 	lds r26, pulse2_pattern_delay_rows
00177e 91b0 2874                 	lds r27, pulse2_pattern_delay_frames
001780 9610                      	adiw r27:r26, 0
001781 f009                      	breq sound_driver_channel1_main //if the pattern delay is 0, proceed with sound driver procedures
001782 c2d7                      	rjmp sound_driver_channel1_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel1_main:
001783 91e0 2871                 	lds ZL, pulse2_pattern //current pattern for pulse 2
001785 91f0 2872                 	lds ZH, pulse2_pattern+1
001787 91a0 2875                 	lds r26, pulse2_pattern_offset //current offset in the pattern for pulse 2
001789 91b0 2876                 	lds r27, pulse2_pattern_offset+1
00178b 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
00178c 1ffb                      	adc ZH, r27
00178d 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel1_check_if_note: //check if data is a note (0x00 - 0x56)
00178e 35b7                      	cpi r27, 0x57
00178f f408                      	brsh sound_driver_channel1_check_if_volume
001790 c180                      	rjmp sound_driver_channel1_note
                                 sound_driver_channel1_check_if_volume: //check if data is volume (0x57-0x66)
001791 36b7                      	cpi r27, 0x67
001792 f408                      	brsh sound_driver_channel1_check_if_delay
001793 c1ba                      	rjmp sound_driver_channel1_volume
                                 sound_driver_channel1_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001794 3eb3                      	cpi r27, 0xE3
001795 f408                      	brsh sound_driver_channel1_check_if_instrument
001796 c1c1                      	rjmp sound_driver_channel1_delay
                                 sound_driver_channel1_check_if_instrument: //check for instrument flag (0xE3)
001797 f409                      	brne sound_driver_channel1_check_if_release
001798 c1c4                      	rjmp sound_driver_channel1_instrument_change 
                                 sound_driver_channel1_check_if_release: //check for note release flag (0xE4)
001799 3eb4                      	cpi r27, 0xE4
00179a f409                      	brne sound_driver_channel1_check_if_end
00179b c26d                      	rjmp sound_driver_channel1_release
                                 sound_driver_channel1_check_if_end:
00179c 3fbf                      	cpi r27, 0xFF
00179d f409                      	brne sound_driver_channel1_check_if_fx
00179e c28f                      	rjmp sound_driver_channel1_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel1_check_if_fx: //fx flags (0xE5 - 0xFE)
00179f 9631                      	adiw Z, 1 //point Z to the byte next to the flag
0017a0 91a4                      	lpm r26, Z //load the fx data into r26
0017a1 d2ae                      	rcall sound_driver_channel1_increment_offset_twice
                                 
0017a2 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
0017a3 eee8                      	ldi ZL, LOW(channel1_fx << 1) //load in note table
0017a4 e5fb                      	ldi ZH, HIGH(channel1_fx << 1)
0017a5 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
0017a6 0feb                      	add ZL, r27 //add offset
0017a7 1df2                      	adc ZH, zero
0017a8 91c5                      	lpm r28, Z+ //load address bytes
0017a9 91d4                      	lpm r29, Z
0017aa 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
0017ab 2ffd                      	mov ZH, r29
0017ac 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel1_fx_0xy:
0017ad 93a0 2894                 	sts pulse2_fx_0xy_sequence, r26
0017af 9220 2895                 	sts pulse2_fx_0xy_sequence+1, zero
0017b1 cfd1                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel1_fx_1xx:
0017b2 9220 289a                 	sts pulse2_fx_2xx, zero //turn off any 2xx pitch slide down
0017b4 9220 289b                 	sts pulse2_fx_2xx+1, zero
0017b6 9220 2894                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
0017b8 9220 2895                 	sts pulse2_fx_0xy_sequence+1, zero
0017ba 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0017bb 937f                      	push r23
0017bc 2f6a                      	mov r22, r26 //store the rate into r22
0017bd eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0017be 9f67                      	mul r22, r23
0017bf 917f                      	pop r23
0017c0 916f                      	pop r22
                                 
0017c1 9416                      	lsr r1 //shift out the fractional bits
0017c2 9407                      	ror r0
0017c3 9416                      	lsr r1
0017c4 9407                      	ror r0
0017c5 9416                      	lsr r1
0017c6 9407                      	ror r0
0017c7 9416                      	lsr r1
0017c8 9407                      	ror r0
0017c9 9200 2896                 	sts pulse2_fx_1xx, r0
0017cb 9210 2897                 	sts pulse2_fx_1xx+1, r1
0017cd cfb5                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel1_fx_2xx:
0017ce 9220 2896                 	sts pulse2_fx_1xx, zero //turn off any 1xx pitch slide down
0017d0 9220 2897                 	sts pulse2_fx_1xx+1, zero
0017d2 9220 2894                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
0017d4 9220 2895                 	sts pulse2_fx_0xy_sequence+1, zero
0017d6 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0017d7 937f                      	push r23
0017d8 2f6a                      	mov r22, r26 //store the rate into r22
0017d9 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0017da 9f67                      	mul r22, r23
0017db 917f                      	pop r23
0017dc 916f                      	pop r22
                                 
0017dd 9416                      	lsr r1 //shift out the fractional bits
0017de 9407                      	ror r0
0017df 9416                      	lsr r1
0017e0 9407                      	ror r0
0017e1 9416                      	lsr r1
0017e2 9407                      	ror r0
0017e3 9416                      	lsr r1
0017e4 9407                      	ror r0
0017e5 9200 289a                 	sts pulse2_fx_2xx, r0
0017e7 9210 289b                 	sts pulse2_fx_2xx+1, r1
0017e9 cf99                      	rjmp sound_driver_channel1_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel1_fx_3xx:
0017ea 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0017eb 937f                      	push r23
0017ec 2f6a                      	mov r22, r26 //store the rate into r22
0017ed eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0017ee 9f67                      	mul r22, r23
0017ef 917f                      	pop r23
0017f0 916f                      	pop r22
                                 
0017f1 9416                      	lsr r1 //shift out the fractional bits
0017f2 9407                      	ror r0
0017f3 9416                      	lsr r1
0017f4 9407                      	ror r0
0017f5 9416                      	lsr r1
0017f6 9407                      	ror r0
0017f7 9416                      	lsr r1
0017f8 9407                      	ror r0
0017f9 9200 28a2                 	sts pulse2_fx_3xx_speed, r0
0017fb 9210 28a3                 	sts pulse2_fx_3xx_speed+1, r1
                                 
0017fd 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
0017fe c001                      	rjmp sound_driver_channel1_fx_3xx_enabled
0017ff cf83                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_3xx_enabled:
001800 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001802 91b0 0a9d                 	lds r27, TCB1_CCMPH
001804 93a0 289e                 	sts pulse2_fx_3xx_start, r26
001806 93b0 289f                 	sts pulse2_fx_3xx_start+1, r27
                                 
001808 9220 28a4                 	sts pulse2_fx_3xx_total_offset, zero
00180a 9220 28a5                 	sts pulse2_fx_3xx_total_offset+1, zero
00180c cf76                      	rjmp sound_driver_channel1_main
                                 
                                 //VIBRATO
                                 sound_driver_channel1_fx_4xy:
00180d 2fba                      	mov r27, r26
00180e 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
00180f 95a2                      	swap r26
001810 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001811 93a0 28a6                 	sts pulse2_fx_4xy_speed, r26
001813 93b0 28a7                 	sts pulse2_fx_4xy_depth, r27
001815 9220 28a8                 	sts pulse2_fx_4xy_phase, zero //reset the phase to 0
001817 cf6b                      	rjmp sound_driver_channel1_main
                                 
                                 //TREMELO
                                 sound_driver_channel1_fx_7xy:
001818 2fba                      	mov r27, r26
001819 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
00181a 95a2                      	swap r26
00181b 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
00181c 93a0 28a9                 	sts pulse2_fx_7xy_speed, r26
00181e 93b0 28aa                 	sts pulse2_fx_7xy_depth, r27
001820 9220 28ab                 	sts pulse2_fx_7xy_phase, zero //reset the phase to 0
001822 9220 28ac                 	sts pulse2_fx_7xy_value, zero //reset the tremelo value
001824 cf5e                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel1_fx_Axy:
001825 93a0 28ad                 	sts pulse2_fx_Axy, r26
001827 cf5b                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel1_fx_Bxx:
001828 93a0 281f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
00182a cf58                      	rjmp sound_driver_channel1_main
                                 
                                 //HALT
                                 sound_driver_channel1_fx_Cxx:
00182b 93b0 2820                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
00182d cf55                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel1_fx_Dxx:
00182e 93b0 2821                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001830 cf52                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME
                                 sound_driver_channel1_fx_Exx:
001831 91b0 2808                 	lds r27, pulse2_param
001833 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
001834 2bba                      	or r27, r26 //move new VVVV bits into pulse2_param
001835 93b0 2808                 	sts pulse2_param, r27
001837 6092                      	sbr pulse_channel_flags, 2
001838 cf4a                      	rjmp sound_driver_channel1_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel1_fx_Fxx:
001839 93a0 281e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
00183b cf47                      	rjmp sound_driver_channel1_main
                                 
                                 //DELAY
                                 sound_driver_channel1_fx_Gxx:
00183c 15a2                      	cp r26, zero
00183d f051                      	breq sound_driver_channel1_fx_Gxx_invalid
00183e 91b0 281e                 	lds r27, song_speed
001840 17ab                      	cp r26, r27
001841 f430                      	brsh sound_driver_channel1_fx_Gxx_invalid
001842 93a0 28ae                 	sts pulse2_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001844 e0b1                      	ldi r27, 0x01
001845 93b0 2873                 	sts pulse2_pattern_delay_rows, r27
001847 c215                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Gxx_invalid:
001848 cf3a                      	rjmp sound_driver_channel1_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel1_fx_Hxy: //hardware sweep up
001849 cf39                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixy: //hardware sweep down
00184a cf38                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Hxx: //FDS modulation depth
00184b cf37                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixx: //FDS modulation speed
00184c cf36                      	rjmp sound_driver_channel1_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel1_fx_Pxx:
00184d 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00184e 937f                      	push r23
00184f 2f6a                      	mov r22, r26
001850 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001851 0367                      	mulsu r22, r23
001852 917f                      	pop r23
001853 916f                      	pop r22
001854 9416                      	lsr r1 //shift out the fractional bits
001855 9407                      	ror r0
001856 9416                      	lsr r1
001857 9407                      	ror r0
001858 9416                      	lsr r1
001859 9407                      	ror r0
00185a 9416                      	lsr r1
00185b 9407                      	ror r0
00185c fe13                      	sbrs r1, 3 //check if result was a negative number
00185d c002                      	rjmp sound_driver_channel1_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel1_fx_Pxx_negative:
00185e efb0                      	ldi r27, 0xF0
00185f 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel1_fx_Pxx_store:
001860 9200 28b0                 	sts pulse2_fx_Pxx_total, r0
001862 9210 28b1                 	sts pulse2_fx_Pxx_total+1, r1
001864 cf1e                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel1_fx_Qxy:
                                 sound_driver_channel1_fx_Qxy_check_arpeggio_macro:
001865 91e0 287c                 	lds ZL, pulse2_arpeggio_macro
001867 91f0 287d                 	lds ZH, pulse2_arpeggio_macro+1
001869 9630                      	adiw Z, 0
00186a f009                      	breq sound_driver_channel1_fx_Qxy_check_pitch_macro
00186b cf17                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_pitch_macro:
00186c 91e0 2884                 	lds ZL, pulse2_pitch_macro
00186e 91f0 2885                 	lds ZH, pulse2_pitch_macro+1
001870 9630                      	adiw Z, 0
001871 f009                      	breq sound_driver_channel1_fx_Qxy_check_hi_pitch_macro
001872 cf10                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_hi_pitch_macro:
001873 91e0 288a                 	lds ZL, pulse2_hi_pitch_macro
001875 91f0 288b                 	lds ZH, pulse2_hi_pitch_macro+1
001877 9630                      	adiw Z, 0
001878 f009                      	breq sound_driver_channel1_fx_Qxy_process
001879 cf09                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_process:
00187a 2fba                      	mov r27, r26 //copy fx parameters into r27
00187b 70bf                      	andi r27, 0x0F //mask note index offset
00187c 91c0 280f                 	lds r28, pulse2_note //load current note index
00187e 0fbc                      	add r27, r28
00187f 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001880 f008                      	brlo sound_driver_channel1_fx_Qxy_process_continue
001881 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel1_fx_Qxy_process_continue:
001882 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001883 e0f0                      	ldi ZH, HIGH(note_table << 1)
001884 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001885 0feb                      	add ZL, r27 //add offset
001886 1df2                      	adc ZH, zero
001887 91c5                      	lpm r28, Z+ //load bytes
001888 91d4                      	lpm r29, Z
001889 93c0 28b2                 	sts pulse2_fx_Qxy_target, r28 //load the LOW bits for the target period
00188b 93d0 28b3                 	sts pulse2_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
00188d 95a2                      	swap r26
00188e 70af                      	andi r26, 0x0F //mask effect speed
00188f 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001890 95a3                      	inc r26 //increment the speed by 1
                                 
001891 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001892 937f                      	push r23
001893 2f6a                      	mov r22, r26 //store the speed data into r27
001894 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001895 9f67                      	mul r22, r23
001896 917f                      	pop r23
001897 916f                      	pop r22
                                 
001898 9416                      	lsr r1 //shift out the fractional bits
001899 9407                      	ror r0
00189a 9416                      	lsr r1
00189b 9407                      	ror r0
00189c 9416                      	lsr r1
00189d 9407                      	ror r0
00189e 9416                      	lsr r1
00189f 9407                      	ror r0
                                 
0018a0 9200 28b4                 	sts pulse2_fx_Qxy_speed, r0 //store the effect speed
0018a2 9210 28b5                 	sts pulse2_fx_Qxy_speed+1, r1
0018a4 9220 28b6                 	sts pulse2_fx_Qxy_total_offset, zero
0018a6 9220 28b7                 	sts pulse2_fx_Qxy_total_offset+1, zero
0018a8 ceda                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel1_fx_Rxy:
                                 sound_driver_channel1_fx_Rxy_check_arpeggio_macro:
0018a9 91e0 287c                 	lds ZL, pulse2_arpeggio_macro
0018ab 91f0 287d                 	lds ZH, pulse2_arpeggio_macro+1
0018ad 9630                      	adiw Z, 0
0018ae f009                      	breq sound_driver_channel1_fx_Rxy_check_pitch_macro
0018af ced3                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_pitch_macro:
0018b0 91e0 2884                 	lds ZL, pulse2_pitch_macro
0018b2 91f0 2885                 	lds ZH, pulse2_pitch_macro+1
0018b4 9630                      	adiw Z, 0
0018b5 f009                      	breq sound_driver_channel1_fx_Rxy_check_hi_pitch_macro
0018b6 cecc                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_hi_pitch_macro:
0018b7 91e0 288a                 	lds ZL, pulse2_hi_pitch_macro
0018b9 91f0 288b                 	lds ZH, pulse2_hi_pitch_macro+1
0018bb 9630                      	adiw Z, 0
0018bc f009                      	breq sound_driver_channel1_fx_Rxy_process
0018bd cec5                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_process:
0018be 2fba                      	mov r27, r26 //copy fx parameters into r27
0018bf 70bf                      	andi r27, 0x0F //mask note index offset
0018c0 91c0 280f                 	lds r28, pulse2_note //load current note index
0018c2 1bcb                      	sub r28, r27
0018c3 f408                      	brcc sound_driver_channel1_fx_Rxy_process_continue
0018c4 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel1_fx_Rxy_process_continue:
0018c5 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0018c6 e0f0                      	ldi ZH, HIGH(note_table << 1)
0018c7 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
0018c8 0fec                      	add ZL, r28 //add offset
0018c9 1df2                      	adc ZH, zero
0018ca 91c5                      	lpm r28, Z+ //load bytes
0018cb 91d4                      	lpm r29, Z
0018cc 93c0 28b8                 	sts pulse2_fx_Rxy_target, r28 //load the LOW bits for the target period
0018ce 93d0 28b9                 	sts pulse2_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
0018d0 95a2                      	swap r26
0018d1 70af                      	andi r26, 0x0F //mask effect speed
0018d2 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0018d3 95a3                      	inc r26 //increment the speed by 1
                                 
0018d4 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0018d5 937f                      	push r23
0018d6 2f6a                      	mov r22, r26 //store the speed data into r27
0018d7 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0018d8 9f67                      	mul r22, r23
0018d9 917f                      	pop r23
0018da 916f                      	pop r22
                                 
0018db 9416                      	lsr r1 //shift out the fractional bits
0018dc 9407                      	ror r0
0018dd 9416                      	lsr r1
0018de 9407                      	ror r0
0018df 9416                      	lsr r1
0018e0 9407                      	ror r0
0018e1 9416                      	lsr r1
0018e2 9407                      	ror r0
                                 
0018e3 9200 28ba                 	sts pulse2_fx_Rxy_speed, r0 //store the effect speed
0018e5 9210 28bb                 	sts pulse2_fx_Rxy_speed+1, r1
0018e7 9220 28bc                 	sts pulse2_fx_Rxy_total_offset, zero
0018e9 9220 28bd                 	sts pulse2_fx_Rxy_total_offset+1, zero
0018eb ce97                      	rjmp sound_driver_channel1_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel1_fx_Sxx:
0018ec 15a2                      	cp r26, zero
0018ed f051                      	breq sound_driver_channel1_fx_Sxx_invalid
0018ee 91b0 281e                 	lds r27, song_speed
0018f0 17ab                      	cp r26, r27
0018f1 f430                      	brsh sound_driver_channel1_fx_Sxx_invalid
0018f2 93a0 28be                 	sts pulse2_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
0018f4 e0b1                      	ldi r27, 0x01
0018f5 93b0 2873                 	sts pulse2_pattern_delay_rows, r27
0018f7 c165                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Sxx_invalid:
0018f8 ce8a                      	rjmp sound_driver_channel1_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel1_fx_Vxx:
0018f9 ebe0                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
0018fa e5fb                      	ldi ZH, HIGH(sequences << 1)
0018fb 0fea                      	add ZL, r26 //offset the pointer
0018fc 1df2                      	adc ZH, zero
                                 
0018fd 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
0018fe 95a7                      	ror r26
0018ff 95a7                      	ror r26
001900 91b0 2808                 	lds r27, pulse2_param //load r27 with pulse2_param (register $4000)
001902 2fcb                      	mov r28, r27 //store a copy of pulse2_param into r28
001903 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
001904 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
001905 c001                      	rjmp sound_driver_channel1_fx_Vxx_store
001906 ce7c                      	rjmp sound_driver_channel1_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel1_fx_Vxx_store:
001907 90d4                      	lpm pulse2_sequence, Z //store the sequence
                                 
001908 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
001909 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
00190a 93c0 2808                 	sts pulse2_param, r28
00190c ce76                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_Wxx: //DPCM sample speed
00190d ce75                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Xxx: //DPCM sample retrigger
00190e ce74                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Yxx: //DPCM sample offset
00190f ce73                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Zxx: //DPCM sample delta counter
001910 ce72                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 sound_driver_channel1_note:
001911 93b0 280f                 	sts pulse2_note, r27 //store the note index
001913 e0a3                      	ldi r26, 0x03
001914 e0b2                      	ldi r27, 0x02
001915 93b0 2879                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
001917 93a0 287e                 	sts pulse2_arpeggio_macro_offset, r26
001919 93b0 2886                 	sts pulse2_pitch_macro_offset, r27
00191b 93b0 288c                 	sts pulse2_hi_pitch_macro_offset, r27
00191d 93b0 2891                 	sts pulse2_duty_macro_offset, r27
00191f 9220 2882                 	sts pulse2_total_pitch_offset, zero //reset the pitch and hi pitch offset
001921 9220 2883                 	sts pulse2_total_pitch_offset+1, zero
001923 9220 2889                 	sts pulse2_total_hi_pitch_offset, zero
001925 9220 2898                 	sts pulse2_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001927 9220 2899                 	sts pulse2_fx_1xx_total+1, zero
001929 9220 289c                 	sts pulse2_fx_2xx_total, zero
00192b 9220 289d                 	sts pulse2_fx_2xx_total+1, zero
00192d 9220 28a4                 	sts pulse2_fx_3xx_total_offset, zero //reset 3xx offset
00192f 9220 28a5                 	sts pulse2_fx_3xx_total_offset+1, zero
001931 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001933 91b0 0a9d                 	lds r27, TCB1_CCMPH
001935 93a0 289e                 	sts pulse2_fx_3xx_start, r26
001937 93b0 289f                 	sts pulse2_fx_3xx_start+1, r27
001939 9220 2809                 	sts pulse2_sweep_param, zero //reset any sweep effect
00193b 6093                      	sbr pulse_channel_flags, 3 //set reload flag
00193c 9220 28b2                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00193e 9220 28b3                 	sts pulse2_fx_Qxy_target+1, zero
001940 9220 28b6                 	sts pulse2_fx_Qxy_total_offset, zero
001942 9220 28b7                 	sts pulse2_fx_Qxy_total_offset+1, zero
001944 9220 28b8                 	sts pulse2_fx_Rxy_target, zero
001946 9220 28b9                 	sts pulse2_fx_Rxy_target+1, zero
001948 9220 28bc                 	sts pulse2_fx_Rxy_total_offset, zero
00194a 9220 28bd                 	sts pulse2_fx_Rxy_total_offset+1, zero
00194c d0f9                      	rcall sound_driver_channel1_increment_offset
00194d ce35                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_volume:
00194e 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
00194f 91a0 2808                 	lds r26, pulse2_param
001951 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001952 2bab                      	or r26, r27 //move new VVVV bits into pulse2_param
001953 93a0 2808                 	sts pulse2_param, r26
001955 6092                      	sbr pulse_channel_flags, 2
001956 d0ef                      	rcall sound_driver_channel1_increment_offset
001957 ce2b                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_delay:
001958 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001959 93b0 2873                 	sts pulse2_pattern_delay_rows, r27
00195b d0ea                      	rcall sound_driver_channel1_increment_offset
00195c c100                      	rjmp sound_driver_channel2
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change:
00195d 9220 2877                 	sts pulse2_volume_macro, zero //reset all macro addresses
00195f 9220 2878                 	sts pulse2_volume_macro+1, zero
001961 9220 287c                 	sts pulse2_arpeggio_macro, zero
001963 9220 287d                 	sts pulse2_arpeggio_macro+1, zero
001965 9220 2884                 	sts pulse2_pitch_macro, zero
001967 9220 2885                 	sts pulse2_pitch_macro+1, zero
001969 9220 288a                 	sts pulse2_hi_pitch_macro, zero
00196b 9220 288b                 	sts pulse2_hi_pitch_macro+1, zero
00196d 9220 288f                 	sts pulse2_duty_macro, zero
00196f 9220 2890                 	sts pulse2_duty_macro+1, zero
001971 9220 2882                 	sts pulse2_total_pitch_offset, zero //reset the pitch offset
001973 9220 2883                 	sts pulse2_total_pitch_offset+1, zero
001975 9220 2889                 	sts pulse2_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001977 9631                      	adiw Z, 1 //point to the byte next to the flag
001978 91b4                      	lpm r27, Z //store the instrument offset into r27
001979 e2ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
00197a e0fd                      	ldi ZH, HIGH(instruments)
00197b 0feb                      	add ZL, r27 //point Z to offsetted instrument
00197c 1df2                      	adc ZH, zero
00197d 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
00197e 1fff                      	rol ZH
00197f 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001980 91b4                      	lpm r27, Z
                                 
001981 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001982 1fbb                      	rol r27
001983 2fea                      	mov ZL, r26
001984 2ffb                      	mov ZH, r27
001985 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001986 9632                      	adiw Z, 2 //point Z to the address of the macro
001987 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel1_instrument_change_macro_loop:
001988 95aa                      	dec r26
001989 f019                      	breq sound_driver_channel1_instrument_change_exit
00198a 95b6                      	lsr r27
00198b f078                      	brcs sound_driver_channel1_instrument_change_load_macro
00198c cffb                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_exit:
00198d e0a3                      	ldi r26, 0x03
00198e e0b2                      	ldi r27, 0x02
00198f 93b0 2879                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
001991 93a0 287e                 	sts pulse2_arpeggio_macro_offset, r26
001993 93b0 2886                 	sts pulse2_pitch_macro_offset, r27
001995 93b0 288c                 	sts pulse2_hi_pitch_macro_offset, r27
001997 93b0 2891                 	sts pulse2_duty_macro_offset, r27
001999 d0b6                      	rcall sound_driver_channel1_increment_offset_twice
00199a cde8                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_load_macro:
00199b 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
00199c 91d5                      	lpm r29, Z+
                                 
00199d 30a5                      	cpi r26, 5
00199e f039                      	breq sound_driver_channel1_instrument_change_load_macro_volume
00199f 30a4                      	cpi r26, 4
0019a0 f079                      	breq sound_driver_channel1_instrument_change_load_macro_arpeggio
0019a1 30a3                      	cpi r26, 3
0019a2 f0d9                      	breq sound_driver_channel1_instrument_change_load_macro_pitch
0019a3 30a2                      	cpi r26, 2
0019a4 f159                      	breq sound_driver_channel1_instrument_change_load_macro_hi_pitch
0019a5 c03c                      	rjmp sound_driver_channel1_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel1_instrument_change_load_macro_volume:
0019a6 93c0 2877                 	sts pulse2_volume_macro, r28
0019a8 93d0 2878                 	sts pulse2_volume_macro+1, r29
0019aa d041                      	rcall sound_driver_channel1_instrument_change_read_header
0019ab 93c0 287b                 	sts pulse2_volume_macro_release, r28
0019ad 93d0 287a                 	sts pulse2_volume_macro_loop, r29
0019af cfd8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 	
                                 sound_driver_channel1_instrument_change_load_macro_arpeggio:
0019b0 93c0 287c                 	sts pulse2_arpeggio_macro, r28
0019b2 93d0 287d                 	sts pulse2_arpeggio_macro+1, r29
0019b4 9220 28b2                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0019b6 9220 28b3                 	sts pulse2_fx_Qxy_target+1, zero
0019b8 9220 28b8                 	sts pulse2_fx_Rxy_target, zero
0019ba 9220 28b9                 	sts pulse2_fx_Rxy_target+1, zero
0019bc d03a                      	rcall sound_driver_channel1_instrument_change_read_header_arpeggio
0019bd cfca                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_pitch:
0019be 93c0 2884                 	sts pulse2_pitch_macro, r28
0019c0 93d0 2885                 	sts pulse2_pitch_macro+1, r29
0019c2 9220 28b2                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0019c4 9220 28b3                 	sts pulse2_fx_Qxy_target+1, zero
0019c6 9220 28b8                 	sts pulse2_fx_Rxy_target, zero
0019c8 9220 28b9                 	sts pulse2_fx_Rxy_target+1, zero
0019ca d021                      	rcall sound_driver_channel1_instrument_change_read_header
0019cb 93c0 2888                 	sts pulse2_pitch_macro_release, r28
0019cd 93d0 2887                 	sts pulse2_pitch_macro_loop, r29
0019cf cfb8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_hi_pitch:
0019d0 93c0 288a                 	sts pulse2_hi_pitch_macro, r28
0019d2 93d0 288b                 	sts pulse2_hi_pitch_macro+1, r29
0019d4 9220 28b2                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0019d6 9220 28b3                 	sts pulse2_fx_Qxy_target+1, zero
0019d8 9220 28b8                 	sts pulse2_fx_Rxy_target, zero
0019da 9220 28b9                 	sts pulse2_fx_Rxy_target+1, zero
0019dc d00f                      	rcall sound_driver_channel1_instrument_change_read_header
0019dd 93c0 288e                 	sts pulse2_hi_pitch_macro_release, r28
0019df 93d0 288d                 	sts pulse2_hi_pitch_macro_loop, r29
0019e1 cfa6                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_duty:
0019e2 93c0 288f                 	sts pulse2_duty_macro, r28
0019e4 93d0 2890                 	sts pulse2_duty_macro+1, r29
0019e6 d005                      	rcall sound_driver_channel1_instrument_change_read_header
0019e7 93c0 2893                 	sts pulse2_duty_macro_release, r28
0019e9 93d0 2892                 	sts pulse2_duty_macro_loop, r29
0019eb cf9c                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_read_header:
0019ec 93ef                      	push ZL
0019ed 93ff                      	push ZH
0019ee 2fec                      	mov ZL, r28
0019ef 2ffd                      	mov ZH, r29
0019f0 0fee                      	lsl ZL
0019f1 1fff                      	rol ZH
0019f2 91c5                      	lpm r28, Z+
0019f3 91d4                      	lpm r29, Z
0019f4 91ff                      	pop ZH
0019f5 91ef                      	pop ZL
0019f6 9508                      	ret
                                 
                                 sound_driver_channel1_instrument_change_read_header_arpeggio:
0019f7 93ef                      	push ZL
0019f8 93ff                      	push ZH
0019f9 2fec                      	mov ZL, r28
0019fa 2ffd                      	mov ZH, r29
0019fb 0fee                      	lsl ZL
0019fc 1fff                      	rol ZH
0019fd 91c5                      	lpm r28, Z+
0019fe 91d5                      	lpm r29, Z+
0019ff 93c0 2880                 	sts pulse2_arpeggio_macro_release, r28
001a01 93d0 287f                 	sts pulse2_arpeggio_macro_loop, r29
001a03 91c4                      	lpm r28, Z
001a04 93c0 2881                 	sts pulse2_arpeggio_macro_mode, r28
001a06 91ff                      	pop ZH
001a07 91ef                      	pop ZL
001a08 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel1_release:
                                 sound_driver_channel1_release_volume:
001a09 91b0 287b                 	lds r27, pulse2_volume_macro_release
001a0b 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001a0c f019                      	breq sound_driver_channel1_release_arpeggio //if the macro has no release flag, check the next macro
001a0d 95b3                      	inc r27
001a0e 93b0 2879                 	sts pulse2_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel1_release_arpeggio:
001a10 91b0 2880                 	lds r27, pulse2_arpeggio_macro_release
001a12 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001a13 f019                      	breq sound_driver_channel1_release_pitch
001a14 95b3                      	inc r27
001a15 93b0 287e                 	sts pulse2_arpeggio_macro_offset, r27
                                 sound_driver_channel1_release_pitch:
001a17 91b0 2888                 	lds r27, pulse2_pitch_macro_release
001a19 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001a1a f019                      	breq sound_driver_channel1_release_hi_pitch
001a1b 95b3                      	inc r27
001a1c 93b0 2886                 	sts pulse2_pitch_macro_offset, r27
                                 sound_driver_channel1_release_hi_pitch:
001a1e 91b0 288e                 	lds r27, pulse2_hi_pitch_macro_release
001a20 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001a21 f019                      	breq sound_driver_channel1_release_duty
001a22 95b3                      	inc r27
001a23 93b0 288c                 	sts pulse2_hi_pitch_macro_offset, r27
                                 sound_driver_channel1_release_duty:
001a25 91b0 2893                 	lds r27, pulse2_duty_macro_release
001a27 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001a28 f019                      	breq sound_driver_channel1_release_exit
001a29 95b3                      	inc r27
001a2a 93b0 2891                 	sts pulse2_duty_macro_offset, r27
                                 sound_driver_channel1_release_exit:
001a2c d019                      	rcall sound_driver_channel1_increment_offset
001a2d cd55                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_next_pattern:
001a2e 91e0 2818                 	lds ZL, song_frames
001a30 91f0 2819                 	lds ZH, song_frames+1
001a32 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001a34 91b0 281b                 	lds r27, song_frame_offset+1
001a36 9612                      	adiw r27:r26, 2 //offset for channel 1
001a37 0fea                      	add ZL, r26
001a38 1ffb                      	adc ZH, r27
                                 
001a39 91a5                      	lpm r26, Z+ //load the address of the next pattern
001a3a 91b4                      	lpm r27, Z
001a3b 0faa                      	lsl r26
001a3c 1fbb                      	rol r27
001a3d 93a0 2871                 	sts pulse2_pattern, r26
001a3f 93b0 2872                 	sts pulse2_pattern+1, r27
                                 
001a41 9220 2875                 	sts pulse2_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001a43 9220 2876                 	sts pulse2_pattern_offset+1, zero
001a45 cd3d                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_increment_offset:
001a46 91e0 2875                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001a48 91f0 2876                 	lds ZH, pulse2_pattern_offset+1
001a4a 9631                      	adiw Z, 1
001a4b 93e0 2875                 	sts pulse2_pattern_offset, ZL
001a4d 93f0 2876                 	sts pulse2_pattern_offset+1, ZH
001a4f 9508                      	ret
                                 
                                 sound_driver_channel1_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001a50 91e0 2875                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001a52 91f0 2876                 	lds ZH, pulse2_pattern_offset+1
001a54 9632                      	adiw Z, 2 //increment the pointer twice
001a55 93e0 2875                 	sts pulse2_pattern_offset, ZL
001a57 93f0 2876                 	sts pulse2_pattern_offset+1, ZH
001a59 9508                      	ret
                                 
                                 sound_driver_channel1_decrement_frame_delay:
001a5a 95ba                      	dec r27
001a5b 93b0 2874                 	sts pulse2_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel2:
001a5d 91a0 28c2                 	lds r26, triangle_pattern_delay_rows
001a5f 91b0 28c3                 	lds r27, triangle_pattern_delay_frames
001a61 9610                      	adiw r27:r26, 0
001a62 f009                      	breq sound_driver_channel2_main //if the pattern delay is 0, proceed with sound driver procedures
001a63 c2bf                      	rjmp sound_driver_channel2_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel2_main:
001a64 91e0 28c0                 	lds ZL, triangle_pattern //current pattern for triangle
001a66 91f0 28c1                 	lds ZH, triangle_pattern+1
001a68 91a0 28c4                 	lds r26, triangle_pattern_offset //current offset in the pattern for triangle
001a6a 91b0 28c5                 	lds r27, triangle_pattern_offset+1
001a6c 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001a6d 1ffb                      	adc ZH, r27
001a6e 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel2_check_if_note: //check if data is a note (0x00 - 0x56)
001a6f 35b7                      	cpi r27, 0x57
001a70 f408                      	brsh sound_driver_channel2_check_if_volume
001a71 c164                      	rjmp sound_driver_channel2_note
                                 sound_driver_channel2_check_if_volume: //check if data is volume (0x57-0x66)
001a72 36b7                      	cpi r27, 0x67
001a73 f408                      	brsh sound_driver_channel2_check_if_delay
001a74 c19e                      	rjmp sound_driver_channel2_volume
                                 sound_driver_channel2_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001a75 3eb3                      	cpi r27, 0xE3
001a76 f408                      	brsh sound_driver_channel2_check_if_instrument
001a77 c1a9                      	rjmp sound_driver_channel2_delay
                                 sound_driver_channel2_check_if_instrument: //check for instrument flag (0xE3)
001a78 f409                      	brne sound_driver_channel2_check_if_release
001a79 c1ac                      	rjmp sound_driver_channel2_instrument_change 
                                 sound_driver_channel2_check_if_release: //check for note release flag (0xE4)
001a7a 3eb4                      	cpi r27, 0xE4
001a7b f409                      	brne sound_driver_channel2_check_if_end
001a7c c255                      	rjmp sound_driver_channel2_release
                                 sound_driver_channel2_check_if_end:
001a7d 3fbf                      	cpi r27, 0xFF
001a7e f409                      	brne sound_driver_channel2_check_if_fx
001a7f c277                      	rjmp sound_driver_channel2_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel2_check_if_fx: //fx flags (0xE5 - 0xFE)
001a80 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001a81 91a4                      	lpm r26, Z //load the fx data into r26
001a82 d296                      	rcall sound_driver_channel2_increment_offset_twice
                                 
001a83 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001a84 e1ec                      	ldi ZL, LOW(channel2_fx << 1) //load in note table
001a85 e5fc                      	ldi ZH, HIGH(channel2_fx << 1)
001a86 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001a87 0feb                      	add ZL, r27 //add offset
001a88 1df2                      	adc ZH, zero
001a89 91c5                      	lpm r28, Z+ //load address bytes
001a8a 91d4                      	lpm r29, Z
001a8b 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001a8c 2ffd                      	mov ZH, r29
001a8d 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel2_fx_0xy:
001a8e 93a0 28e3                 	sts triangle_fx_0xy_sequence, r26
001a90 9220 28e4                 	sts triangle_fx_0xy_sequence+1, zero
001a92 cfd1                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel2_fx_1xx:
001a93 9220 28e9                 	sts triangle_fx_2xx, zero //turn off any 2xx pitch slide down
001a95 9220 28ea                 	sts triangle_fx_2xx+1, zero
001a97 9220 28e3                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001a99 9220 28e4                 	sts triangle_fx_0xy_sequence+1, zero
001a9b 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001a9c 937f                      	push r23
001a9d 2f6a                      	mov r22, r26 //store the rate into r22
001a9e eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001a9f 9f67                      	mul r22, r23
001aa0 917f                      	pop r23
001aa1 916f                      	pop r22
                                 
001aa2 9416                      	lsr r1 //shift out the fractional bits
001aa3 9407                      	ror r0
001aa4 9416                      	lsr r1
001aa5 9407                      	ror r0
001aa6 9416                      	lsr r1
001aa7 9407                      	ror r0
001aa8 9416                      	lsr r1
001aa9 9407                      	ror r0
001aaa 9200 28e5                 	sts triangle_fx_1xx, r0
001aac 9210 28e6                 	sts triangle_fx_1xx+1, r1
001aae cfb5                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel2_fx_2xx:
001aaf 9220 28e5                 	sts triangle_fx_1xx, zero //turn off any 1xx pitch slide down
001ab1 9220 28e6                 	sts triangle_fx_1xx+1, zero
001ab3 9220 28e3                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001ab5 9220 28e4                 	sts triangle_fx_0xy_sequence+1, zero
001ab7 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001ab8 937f                      	push r23
001ab9 2f6a                      	mov r22, r26 //store the rate into r22
001aba eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001abb 9f67                      	mul r22, r23
001abc 917f                      	pop r23
001abd 916f                      	pop r22
                                 
001abe 9416                      	lsr r1 //shift out the fractional bits
001abf 9407                      	ror r0
001ac0 9416                      	lsr r1
001ac1 9407                      	ror r0
001ac2 9416                      	lsr r1
001ac3 9407                      	ror r0
001ac4 9416                      	lsr r1
001ac5 9407                      	ror r0
001ac6 9200 28e9                 	sts triangle_fx_2xx, r0
001ac8 9210 28ea                 	sts triangle_fx_2xx+1, r1
001aca cf99                      	rjmp sound_driver_channel2_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel2_fx_3xx:
001acb 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001acc 937f                      	push r23
001acd 2f6a                      	mov r22, r26 //store the rate into r22
001ace eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001acf 9f67                      	mul r22, r23
001ad0 917f                      	pop r23
001ad1 916f                      	pop r22
                                 
001ad2 9416                      	lsr r1 //shift out the fractional bits
001ad3 9407                      	ror r0
001ad4 9416                      	lsr r1
001ad5 9407                      	ror r0
001ad6 9416                      	lsr r1
001ad7 9407                      	ror r0
001ad8 9416                      	lsr r1
001ad9 9407                      	ror r0
001ada 9200 28f1                 	sts triangle_fx_3xx_speed, r0
001adc 9210 28f2                 	sts triangle_fx_3xx_speed+1, r1
                                 
001ade 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001adf c001                      	rjmp sound_driver_channel2_fx_3xx_enabled
001ae0 cf83                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_3xx_enabled:
001ae1 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001ae3 91b0 0aad                 	lds r27, TCB2_CCMPH
001ae5 93a0 28ed                 	sts triangle_fx_3xx_start, r26
001ae7 93b0 28ee                 	sts triangle_fx_3xx_start+1, r27
                                 
001ae9 9220 28f3                 	sts triangle_fx_3xx_total_offset, zero
001aeb 9220 28f4                 	sts triangle_fx_3xx_total_offset+1, zero
001aed cf76                      	rjmp sound_driver_channel2_main
                                 
                                 //VIBRATO
                                 sound_driver_channel2_fx_4xy:
001aee 2fba                      	mov r27, r26
001aef 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001af0 95a2                      	swap r26
001af1 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001af2 93a0 28f5                 	sts triangle_fx_4xy_speed, r26
001af4 93b0 28f6                 	sts triangle_fx_4xy_depth, r27
001af6 9220 28f7                 	sts triangle_fx_4xy_phase, zero //reset the phase to 0
001af8 cf6b                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_7xy: //tremelo
001af9 cf6a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Axy: //volume slide
001afa cf69                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel2_fx_Bxx:
001afb 93a0 281f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001afd cf66                      	rjmp sound_driver_channel2_main
                                 
                                 //HALT
                                 sound_driver_channel2_fx_Cxx:
001afe 93b0 2820                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001b00 cf63                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel2_fx_Dxx:
001b01 93b0 2821                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001b03 cf60                      	rjmp sound_driver_channel2_main
                                 
                                 //VOLUME
                                 sound_driver_channel2_fx_Exx:
001b04 15a2                      	cp r26, zero
001b05 f021                      	breq sound_driver_channel2_fx_Exx_disable
                                 sound_driver_channel2_fx_Exx_enable:
001b06 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001b07 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001b09 cf5a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Exx_disable:
001b0a 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
001b0c 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
001b0e 9220 0aad                 	sts TCB2_CCMPH, zero
001b10 cf53                      	rjmp sound_driver_channel2_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel2_fx_Fxx:
001b11 93a0 281e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001b13 cf50                      	rjmp sound_driver_channel2_main
                                 
                                 //DELAY
                                 sound_driver_channel2_fx_Gxx:
001b14 15a2                      	cp r26, zero
001b15 f051                      	breq sound_driver_channel2_fx_Gxx_invalid
001b16 91b0 281e                 	lds r27, song_speed
001b18 17ab                      	cp r26, r27
001b19 f430                      	brsh sound_driver_channel2_fx_Gxx_invalid
001b1a 93a0 28f8                 	sts triangle_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001b1c e0b1                      	ldi r27, 0x01
001b1d 93b0 28c2                 	sts triangle_pattern_delay_rows, r27
001b1f c206                      	rjmp sound_driver_channel3
                                 sound_driver_channel2_fx_Gxx_invalid:
001b20 cf43                      	rjmp sound_driver_channel2_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Hxy: //hardware sweep up
001b21 cf42                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixy: //hardware sweep down
001b22 cf41                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Hxx: //FDS modulation depth
001b23 cf40                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixx: //FDS modulation speed
001b24 cf3f                      	rjmp sound_driver_channel2_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel2_fx_Pxx:
001b25 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001b26 937f                      	push r23
001b27 2f6a                      	mov r22, r26
001b28 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001b29 0367                      	mulsu r22, r23
001b2a 917f                      	pop r23
001b2b 916f                      	pop r22
001b2c 9416                      	lsr r1 //shift out the fractional bits
001b2d 9407                      	ror r0
001b2e 9416                      	lsr r1
001b2f 9407                      	ror r0
001b30 9416                      	lsr r1
001b31 9407                      	ror r0
001b32 9416                      	lsr r1
001b33 9407                      	ror r0
001b34 fe13                      	sbrs r1, 3 //check if result was a negative number
001b35 c002                      	rjmp sound_driver_channel2_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel2_fx_Pxx_negative:
001b36 efb0                      	ldi r27, 0xF0
001b37 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel2_fx_Pxx_store:
001b38 9200 28fa                 	sts triangle_fx_Pxx_total, r0
001b3a 9210 28fb                 	sts triangle_fx_Pxx_total+1, r1
001b3c cf27                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel2_fx_Qxy:
                                 sound_driver_channel2_fx_Qxy_check_arpeggio_macro:
001b3d 91e0 28cb                 	lds ZL, triangle_arpeggio_macro
001b3f 91f0 28cc                 	lds ZH, triangle_arpeggio_macro+1
001b41 9630                      	adiw Z, 0
001b42 f009                      	breq sound_driver_channel2_fx_Qxy_check_pitch_macro
001b43 cf20                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_pitch_macro:
001b44 91e0 28d3                 	lds ZL, triangle_pitch_macro
001b46 91f0 28d4                 	lds ZH, triangle_pitch_macro+1
001b48 9630                      	adiw Z, 0
001b49 f009                      	breq sound_driver_channel2_fx_Qxy_check_hi_pitch_macro
001b4a cf19                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_hi_pitch_macro:
001b4b 91e0 28d9                 	lds ZL, triangle_hi_pitch_macro
001b4d 91f0 28da                 	lds ZH, triangle_hi_pitch_macro+1
001b4f 9630                      	adiw Z, 0
001b50 f009                      	breq sound_driver_channel2_fx_Qxy_process
001b51 cf12                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_process:
001b52 2fba                      	mov r27, r26 //copy fx parameters into r27
001b53 70bf                      	andi r27, 0x0F //mask note index offset
001b54 91c0 2812                 	lds r28, triangle_note //load current note index
001b56 0fbc                      	add r27, r28
001b57 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001b58 f008                      	brlo sound_driver_channel2_fx_Qxy_process_continue
001b59 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel2_fx_Qxy_process_continue:
001b5a e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001b5b e0f0                      	ldi ZH, HIGH(note_table << 1)
001b5c 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001b5d 0feb                      	add ZL, r27 //add offset
001b5e 1df2                      	adc ZH, zero
001b5f 91c5                      	lpm r28, Z+ //load bytes
001b60 91d4                      	lpm r29, Z
001b61 93c0 28fc                 	sts triangle_fx_Qxy_target, r28 //load the LOW bits for the target period
001b63 93d0 28fd                 	sts triangle_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
001b65 95a2                      	swap r26
001b66 70af                      	andi r26, 0x0F //mask effect speed
001b67 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001b68 95a3                      	inc r26 //increment the speed by 1
                                 
001b69 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001b6a 937f                      	push r23
001b6b 2f6a                      	mov r22, r26 //store the speed data into r27
001b6c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001b6d 9f67                      	mul r22, r23
001b6e 917f                      	pop r23
001b6f 916f                      	pop r22
                                 
001b70 9416                      	lsr r1 //shift out the fractional bits
001b71 9407                      	ror r0
001b72 9416                      	lsr r1
001b73 9407                      	ror r0
001b74 9416                      	lsr r1
001b75 9407                      	ror r0
001b76 9416                      	lsr r1
001b77 9407                      	ror r0
                                 
001b78 9200 28fe                 	sts triangle_fx_Qxy_speed, r0 //store the effect speed
001b7a 9210 28ff                 	sts triangle_fx_Qxy_speed+1, r1
001b7c 9220 2900                 	sts triangle_fx_Qxy_total_offset, zero
001b7e 9220 2901                 	sts triangle_fx_Qxy_total_offset+1, zero
001b80 cee3                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel2_fx_Rxy:
                                 sound_driver_channel2_fx_Rxy_check_arpeggio_macro:
001b81 91e0 28cb                 	lds ZL, triangle_arpeggio_macro
001b83 91f0 28cc                 	lds ZH, triangle_arpeggio_macro+1
001b85 9630                      	adiw Z, 0
001b86 f009                      	breq sound_driver_channel2_fx_Rxy_check_pitch_macro
001b87 cedc                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_pitch_macro:
001b88 91e0 28d3                 	lds ZL, triangle_pitch_macro
001b8a 91f0 28d4                 	lds ZH, triangle_pitch_macro+1
001b8c 9630                      	adiw Z, 0
001b8d f009                      	breq sound_driver_channel2_fx_Rxy_check_hi_pitch_macro
001b8e ced5                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_hi_pitch_macro:
001b8f 91e0 28d9                 	lds ZL, triangle_hi_pitch_macro
001b91 91f0 28da                 	lds ZH, triangle_hi_pitch_macro+1
001b93 9630                      	adiw Z, 0
001b94 f009                      	breq sound_driver_channel2_fx_Rxy_process
001b95 cece                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_process:
001b96 2fba                      	mov r27, r26 //copy fx parameters into r27
001b97 70bf                      	andi r27, 0x0F //mask note index offset
001b98 91c0 2812                 	lds r28, triangle_note //load current note index
001b9a 1bcb                      	sub r28, r27
001b9b f408                      	brcc sound_driver_channel2_fx_Rxy_process_continue
001b9c e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel2_fx_Rxy_process_continue:
001b9d e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001b9e e0f0                      	ldi ZH, HIGH(note_table << 1)
001b9f 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001ba0 0fec                      	add ZL, r28 //add offset
001ba1 1df2                      	adc ZH, zero
001ba2 91c5                      	lpm r28, Z+ //load bytes
001ba3 91d4                      	lpm r29, Z
001ba4 93c0 2902                 	sts triangle_fx_Rxy_target, r28 //load the LOW bits for the target period
001ba6 93d0 2903                 	sts triangle_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
001ba8 95a2                      	swap r26
001ba9 70af                      	andi r26, 0x0F //mask effect speed
001baa 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001bab 95a3                      	inc r26 //increment the speed by 1
                                 
001bac 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001bad 937f                      	push r23
001bae 2f6a                      	mov r22, r26 //store the speed data into r27
001baf eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001bb0 9f67                      	mul r22, r23
001bb1 917f                      	pop r23
001bb2 916f                      	pop r22
                                 
001bb3 9416                      	lsr r1 //shift out the fractional bits
001bb4 9407                      	ror r0
001bb5 9416                      	lsr r1
001bb6 9407                      	ror r0
001bb7 9416                      	lsr r1
001bb8 9407                      	ror r0
001bb9 9416                      	lsr r1
001bba 9407                      	ror r0
                                 
001bbb 9200 2904                 	sts triangle_fx_Rxy_speed, r0 //store the effect speed
001bbd 9210 2905                 	sts triangle_fx_Rxy_speed+1, r1
001bbf 9220 2906                 	sts triangle_fx_Rxy_total_offset, zero
001bc1 9220 2907                 	sts triangle_fx_Rxy_total_offset+1, zero
001bc3 cea0                      	rjmp sound_driver_channel2_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel2_fx_Sxx:
001bc4 15a2                      	cp r26, zero
001bc5 f051                      	breq sound_driver_channel2_fx_Sxx_invalid
001bc6 91b0 281e                 	lds r27, song_speed
001bc8 17ab                      	cp r26, r27
001bc9 f430                      	brsh sound_driver_channel2_fx_Sxx_invalid
001bca 93a0 2908                 	sts triangle_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001bcc e0b1                      	ldi r27, 0x01
001bcd 93b0 28c2                 	sts triangle_pattern_delay_rows, r27
001bcf c156                      	rjmp sound_driver_channel3
                                 sound_driver_channel2_fx_Sxx_invalid:
001bd0 ce93                      	rjmp sound_driver_channel2_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Vxx: //duty
001bd1 ce92                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Wxx: //DPCM sample speed
001bd2 ce91                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Xxx: //DPCM sample retrigger
001bd3 ce90                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Yxx: //DPCM sample offset
001bd4 ce8f                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Zxx: //DPCM sample delta counter
001bd5 ce8e                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 sound_driver_channel2_note:
001bd6 93b0 2812                 	sts triangle_note, r27 //store the note index
001bd8 e0a3                      	ldi r26, 0x03
001bd9 e0b2                      	ldi r27, 0x02
001bda 93b0 28c8                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
001bdc 93a0 28cd                 	sts triangle_arpeggio_macro_offset, r26
001bde 93b0 28d5                 	sts triangle_pitch_macro_offset, r27
001be0 93b0 28db                 	sts triangle_hi_pitch_macro_offset, r27
001be2 93b0 28e0                 	sts triangle_duty_macro_offset, r27
001be4 9220 28d1                 	sts triangle_total_pitch_offset, zero //reset the pitch and hi pitch offset
001be6 9220 28d2                 	sts triangle_total_pitch_offset+1, zero
001be8 9220 28d8                 	sts triangle_total_hi_pitch_offset, zero
001bea 9220 28e7                 	sts triangle_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001bec 9220 28e8                 	sts triangle_fx_1xx_total+1, zero
001bee 9220 28eb                 	sts triangle_fx_2xx_total, zero
001bf0 9220 28ec                 	sts triangle_fx_2xx_total+1, zero
001bf2 9220 28f3                 	sts triangle_fx_3xx_total_offset, zero //reset 3xx offset
001bf4 9220 28f4                 	sts triangle_fx_3xx_total_offset+1, zero
001bf6 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001bf8 91b0 0aad                 	lds r27, TCB2_CCMPH
001bfa 93a0 28ed                 	sts triangle_fx_3xx_start, r26
001bfc 93b0 28ee                 	sts triangle_fx_3xx_start+1, r27
001bfe 9220 28fc                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001c00 9220 28fd                 	sts triangle_fx_Qxy_target+1, zero
001c02 9220 2900                 	sts triangle_fx_Qxy_total_offset, zero
001c04 9220 2901                 	sts triangle_fx_Qxy_total_offset+1, zero
001c06 9220 2902                 	sts triangle_fx_Rxy_target, zero
001c08 9220 2903                 	sts triangle_fx_Rxy_target+1, zero
001c0a 9220 2906                 	sts triangle_fx_Rxy_total_offset, zero
001c0c 9220 2907                 	sts triangle_fx_Rxy_total_offset+1, zero
001c0e e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001c0f 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001c11 d0fd                      	rcall sound_driver_channel2_increment_offset
001c12 ce51                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_volume:
001c13 d0fb                      	rcall sound_driver_channel2_increment_offset
001c14 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001c15 f021                      	breq sound_driver_channel2_volume_disable
                                 sound_driver_channel2_volume_enable:
001c16 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001c17 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001c19 ce4a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_volume_disable:
001c1a 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
001c1c 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
001c1e 9220 0aad                 	sts TCB2_CCMPH, zero
001c20 ce43                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_delay:
001c21 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001c22 93b0 28c2                 	sts triangle_pattern_delay_rows, r27
001c24 d0ea                      	rcall sound_driver_channel2_increment_offset
001c25 c100                      	rjmp sound_driver_channel3
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change:
001c26 9220 28c6                 	sts triangle_volume_macro, zero //reset all macro addresses
001c28 9220 28c7                 	sts triangle_volume_macro+1, zero
001c2a 9220 28cb                 	sts triangle_arpeggio_macro, zero
001c2c 9220 28cc                 	sts triangle_arpeggio_macro+1, zero
001c2e 9220 28d3                 	sts triangle_pitch_macro, zero
001c30 9220 28d4                 	sts triangle_pitch_macro+1, zero
001c32 9220 28d9                 	sts triangle_hi_pitch_macro, zero
001c34 9220 28da                 	sts triangle_hi_pitch_macro+1, zero
001c36 9220 28de                 	sts triangle_duty_macro, zero
001c38 9220 28df                 	sts triangle_duty_macro+1, zero
001c3a 9220 28d1                 	sts triangle_total_pitch_offset, zero //reset the pitch offset
001c3c 9220 28d2                 	sts triangle_total_pitch_offset+1, zero
001c3e 9220 28d8                 	sts triangle_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001c40 9631                      	adiw Z, 1 //point to the byte next to the flag
001c41 91b4                      	lpm r27, Z //store the instrument offset into r27
001c42 e2ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
001c43 e0fd                      	ldi ZH, HIGH(instruments)
001c44 0feb                      	add ZL, r27 //point Z to offsetted instrument
001c45 1df2                      	adc ZH, zero
001c46 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001c47 1fff                      	rol ZH
001c48 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001c49 91b4                      	lpm r27, Z
                                 
001c4a 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001c4b 1fbb                      	rol r27
001c4c 2fea                      	mov ZL, r26
001c4d 2ffb                      	mov ZH, r27
001c4e 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001c4f 9632                      	adiw Z, 2 //point Z to the address of the macro
001c50 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel2_instrument_change_macro_loop:
001c51 95aa                      	dec r26
001c52 f019                      	breq sound_driver_channel2_instrument_change_exit
001c53 95b6                      	lsr r27
001c54 f078                      	brcs sound_driver_channel2_instrument_change_load_macro
001c55 cffb                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_exit:
001c56 e0a3                      	ldi r26, 0x03
001c57 e0b2                      	ldi r27, 0x02
001c58 93b0 28c8                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
001c5a 93a0 28cd                 	sts triangle_arpeggio_macro_offset, r26
001c5c 93b0 28d5                 	sts triangle_pitch_macro_offset, r27
001c5e 93b0 28db                 	sts triangle_hi_pitch_macro_offset, r27
001c60 93b0 28e0                 	sts triangle_duty_macro_offset, r27
001c62 d0b6                      	rcall sound_driver_channel2_increment_offset_twice
001c63 ce00                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_load_macro:
001c64 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001c65 91d5                      	lpm r29, Z+
                                 
001c66 30a5                      	cpi r26, 5
001c67 f039                      	breq sound_driver_channel2_instrument_change_load_macro_volume
001c68 30a4                      	cpi r26, 4
001c69 f079                      	breq sound_driver_channel2_instrument_change_load_macro_arpeggio
001c6a 30a3                      	cpi r26, 3
001c6b f0d9                      	breq sound_driver_channel2_instrument_change_load_macro_pitch
001c6c 30a2                      	cpi r26, 2
001c6d f159                      	breq sound_driver_channel2_instrument_change_load_macro_hi_pitch
001c6e c03c                      	rjmp sound_driver_channel2_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel2_instrument_change_load_macro_volume:
001c6f 93c0 28c6                 	sts triangle_volume_macro, r28
001c71 93d0 28c7                 	sts triangle_volume_macro+1, r29
001c73 d041                      	rcall sound_driver_channel2_instrument_change_read_header
001c74 93c0 28ca                 	sts triangle_volume_macro_release, r28
001c76 93d0 28c9                 	sts triangle_volume_macro_loop, r29
001c78 cfd8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 	
                                 sound_driver_channel2_instrument_change_load_macro_arpeggio:
001c79 93c0 28cb                 	sts triangle_arpeggio_macro, r28
001c7b 93d0 28cc                 	sts triangle_arpeggio_macro+1, r29
001c7d 9220 28fc                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001c7f 9220 28fd                 	sts triangle_fx_Qxy_target+1, zero
001c81 9220 2902                 	sts triangle_fx_Rxy_target, zero
001c83 9220 2903                 	sts triangle_fx_Rxy_target+1, zero
001c85 d03a                      	rcall sound_driver_channel2_instrument_change_read_header_arpeggio
001c86 cfca                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_pitch:
001c87 93c0 28d3                 	sts triangle_pitch_macro, r28
001c89 93d0 28d4                 	sts triangle_pitch_macro+1, r29
001c8b 9220 28fc                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001c8d 9220 28fd                 	sts triangle_fx_Qxy_target+1, zero
001c8f 9220 2902                 	sts triangle_fx_Rxy_target, zero
001c91 9220 2903                 	sts triangle_fx_Rxy_target+1, zero
001c93 d021                      	rcall sound_driver_channel2_instrument_change_read_header
001c94 93c0 28d7                 	sts triangle_pitch_macro_release, r28
001c96 93d0 28d6                 	sts triangle_pitch_macro_loop, r29
001c98 cfb8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_hi_pitch:
001c99 93c0 28d9                 	sts triangle_hi_pitch_macro, r28
001c9b 93d0 28da                 	sts triangle_hi_pitch_macro+1, r29
001c9d 9220 28fc                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001c9f 9220 28fd                 	sts triangle_fx_Qxy_target+1, zero
001ca1 9220 2902                 	sts triangle_fx_Rxy_target, zero
001ca3 9220 2903                 	sts triangle_fx_Rxy_target+1, zero
001ca5 d00f                      	rcall sound_driver_channel2_instrument_change_read_header
001ca6 93c0 28dd                 	sts triangle_hi_pitch_macro_release, r28
001ca8 93d0 28dc                 	sts triangle_hi_pitch_macro_loop, r29
001caa cfa6                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_duty:
001cab 93c0 28de                 	sts triangle_duty_macro, r28
001cad 93d0 28df                 	sts triangle_duty_macro+1, r29
001caf d005                      	rcall sound_driver_channel2_instrument_change_read_header
001cb0 93c0 28e2                 	sts triangle_duty_macro_release, r28
001cb2 93d0 28e1                 	sts triangle_duty_macro_loop, r29
001cb4 cf9c                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_read_header:
001cb5 93ef                      	push ZL
001cb6 93ff                      	push ZH
001cb7 2fec                      	mov ZL, r28
001cb8 2ffd                      	mov ZH, r29
001cb9 0fee                      	lsl ZL
001cba 1fff                      	rol ZH
001cbb 91c5                      	lpm r28, Z+
001cbc 91d4                      	lpm r29, Z
001cbd 91ff                      	pop ZH
001cbe 91ef                      	pop ZL
001cbf 9508                      	ret
                                 
                                 sound_driver_channel2_instrument_change_read_header_arpeggio:
001cc0 93ef                      	push ZL
001cc1 93ff                      	push ZH
001cc2 2fec                      	mov ZL, r28
001cc3 2ffd                      	mov ZH, r29
001cc4 0fee                      	lsl ZL
001cc5 1fff                      	rol ZH
001cc6 91c5                      	lpm r28, Z+
001cc7 91d5                      	lpm r29, Z+
001cc8 93c0 28cf                 	sts triangle_arpeggio_macro_release, r28
001cca 93d0 28ce                 	sts triangle_arpeggio_macro_loop, r29
001ccc 91c4                      	lpm r28, Z
001ccd 93c0 28d0                 	sts triangle_arpeggio_macro_mode, r28
001ccf 91ff                      	pop ZH
001cd0 91ef                      	pop ZL
001cd1 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel2_release:
                                 sound_driver_channel2_release_volume:
001cd2 91b0 28ca                 	lds r27, triangle_volume_macro_release
001cd4 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001cd5 f019                      	breq sound_driver_channel2_release_arpeggio //if the macro has no release flag, check the next macro
001cd6 95b3                      	inc r27
001cd7 93b0 28c8                 	sts triangle_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel2_release_arpeggio:
001cd9 91b0 28cf                 	lds r27, triangle_arpeggio_macro_release
001cdb 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001cdc f019                      	breq sound_driver_channel2_release_pitch
001cdd 95b3                      	inc r27
001cde 93b0 28cd                 	sts triangle_arpeggio_macro_offset, r27
                                 sound_driver_channel2_release_pitch:
001ce0 91b0 28d7                 	lds r27, triangle_pitch_macro_release
001ce2 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001ce3 f019                      	breq sound_driver_channel2_release_hi_pitch
001ce4 95b3                      	inc r27
001ce5 93b0 28d5                 	sts triangle_pitch_macro_offset, r27
                                 sound_driver_channel2_release_hi_pitch:
001ce7 91b0 28dd                 	lds r27, triangle_hi_pitch_macro_release
001ce9 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001cea f019                      	breq sound_driver_channel2_release_duty
001ceb 95b3                      	inc r27
001cec 93b0 28db                 	sts triangle_hi_pitch_macro_offset, r27
                                 sound_driver_channel2_release_duty:
001cee 91b0 28e2                 	lds r27, triangle_duty_macro_release
001cf0 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001cf1 f019                      	breq sound_driver_channel2_release_exit
001cf2 95b3                      	inc r27
001cf3 93b0 28e0                 	sts triangle_duty_macro_offset, r27
                                 sound_driver_channel2_release_exit:
001cf5 d019                      	rcall sound_driver_channel2_increment_offset
001cf6 cd6d                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_next_pattern:
001cf7 91e0 2818                 	lds ZL, song_frames
001cf9 91f0 2819                 	lds ZH, song_frames+1
001cfb 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001cfd 91b0 281b                 	lds r27, song_frame_offset+1
001cff 9614                      	adiw r27:r26, 4 //offset for channel 2
001d00 0fea                      	add ZL, r26
001d01 1ffb                      	adc ZH, r27
                                 
001d02 91a5                      	lpm r26, Z+ //load the address of the next pattern
001d03 91b4                      	lpm r27, Z
001d04 0faa                      	lsl r26
001d05 1fbb                      	rol r27
001d06 93a0 28c0                 	sts triangle_pattern, r26
001d08 93b0 28c1                 	sts triangle_pattern+1, r27
                                 
001d0a 9220 28c4                 	sts triangle_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001d0c 9220 28c5                 	sts triangle_pattern_offset+1, zero
001d0e cd55                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_increment_offset:
001d0f 91e0 28c4                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
001d11 91f0 28c5                 	lds ZH, triangle_pattern_offset+1
001d13 9631                      	adiw Z, 1
001d14 93e0 28c4                 	sts triangle_pattern_offset, ZL
001d16 93f0 28c5                 	sts triangle_pattern_offset+1, ZH
001d18 9508                      	ret
                                 
                                 sound_driver_channel2_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001d19 91e0 28c4                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
001d1b 91f0 28c5                 	lds ZH, triangle_pattern_offset+1
001d1d 9632                      	adiw Z, 2 //increment the pointer twice
001d1e 93e0 28c4                 	sts triangle_pattern_offset, ZL
001d20 93f0 28c5                 	sts triangle_pattern_offset+1, ZH
001d22 9508                      	ret
                                 
                                 sound_driver_channel2_decrement_frame_delay:
001d23 95ba                      	dec r27
001d24 93b0 28c3                 	sts triangle_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel3:
001d26 91a0 290c                 	lds r26, noise_pattern_delay_rows
001d28 91b0 290d                 	lds r27, noise_pattern_delay_frames
001d2a 9610                      	adiw r27:r26, 0
001d2b f009                      	breq sound_driver_channel3_main //if the pattern delay is 0, proceed with sound driver procedures
001d2c c2cd                      	rjmp sound_driver_channel3_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel3_main:
001d2d 91e0 290a                 	lds ZL, noise_pattern //current pattern for noise
001d2f 91f0 290b                 	lds ZH, noise_pattern+1
001d31 91a0 290e                 	lds r26, noise_pattern_offset //current offset in the pattern for noise
001d33 91b0 290f                 	lds r27, noise_pattern_offset+1
001d35 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001d36 1ffb                      	adc ZH, r27
001d37 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel3_check_if_note: //check if data is a note (0x00 - 0x56)
001d38 35b7                      	cpi r27, 0x57
001d39 f408                      	brsh sound_driver_channel3_check_if_volume
001d3a c176                      	rjmp sound_driver_channel3_note
                                 sound_driver_channel3_check_if_volume: //check if data is volume (0x57-0x66)
001d3b 36b7                      	cpi r27, 0x67
001d3c f408                      	brsh sound_driver_channel3_check_if_delay
001d3d c1ad                      	rjmp sound_driver_channel3_volume
                                 sound_driver_channel3_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001d3e 3eb3                      	cpi r27, 0xE3
001d3f f408                      	brsh sound_driver_channel3_check_if_instrument
001d40 c1b3                      	rjmp sound_driver_channel3_delay
                                 sound_driver_channel3_check_if_instrument: //check for instrument flag (0xE3)
001d41 f409                      	brne sound_driver_channel3_check_if_release
001d42 c1b6                      	rjmp sound_driver_channel3_instrument_change 
                                 sound_driver_channel3_check_if_release: //check for note release flag (0xE4)
001d43 3eb4                      	cpi r27, 0xE4
001d44 f409                      	brne sound_driver_channel3_check_if_end
001d45 c25f                      	rjmp sound_driver_channel3_release
                                 sound_driver_channel3_check_if_end:
001d46 3fbf                      	cpi r27, 0xFF
001d47 f409                      	brne sound_driver_channel3_check_if_fx
001d48 c281                      	rjmp sound_driver_channel3_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel3_check_if_fx: //fx flags (0xE5 - 0xFE)
001d49 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001d4a 91a4                      	lpm r26, Z //load the fx data into r26
001d4b d2a4                      	rcall sound_driver_channel3_increment_offset_twice
                                 
001d4c 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001d4d e5e0                      	ldi ZL, LOW(channel3_fx << 1) //load in note table
001d4e e5fc                      	ldi ZH, HIGH(channel3_fx << 1)
001d4f 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001d50 0feb                      	add ZL, r27 //add offset
001d51 1df2                      	adc ZH, zero
001d52 91c5                      	lpm r28, Z+ //load address bytes
001d53 91d4                      	lpm r29, Z
001d54 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001d55 2ffd                      	mov ZH, r29
001d56 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel3_fx_0xy:
001d57 93a0 292d                 	sts noise_fx_0xy_sequence, r26
001d59 9220 292e                 	sts noise_fx_0xy_sequence+1, zero
001d5b cfd1                      	rjmp sound_driver_channel3_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel3_fx_1xx:
001d5c 9220 2933                 	sts noise_fx_2xx, zero //turn off any 2xx pitch slide down
001d5e 9220 2934                 	sts noise_fx_2xx+1, zero
001d60 9220 292d                 	sts noise_fx_0xy_sequence, zero //disable any 0xy effect
001d62 9220 292e                 	sts noise_fx_0xy_sequence+1, zero
001d64 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001d65 937f                      	push r23
001d66 2f6a                      	mov r22, r26 //store the rate into r22
001d67 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001d68 9f67                      	mul r22, r23
001d69 917f                      	pop r23
001d6a 916f                      	pop r22
                                 
001d6b 9416                      	lsr r1 //shift out the fractional bits
001d6c 9407                      	ror r0
001d6d 9416                      	lsr r1
001d6e 9407                      	ror r0
001d6f 9416                      	lsr r1
001d70 9407                      	ror r0
001d71 9416                      	lsr r1
001d72 9407                      	ror r0
001d73 9200 292f                 	sts noise_fx_1xx, r0
001d75 9210 2930                 	sts noise_fx_1xx+1, r1
001d77 cfb5                      	rjmp sound_driver_channel3_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel3_fx_2xx:
001d78 9220 292f                 	sts noise_fx_1xx, zero //turn off any 1xx pitch slide down
001d7a 9220 2930                 	sts noise_fx_1xx+1, zero
001d7c 9220 292d                 	sts noise_fx_0xy_sequence, zero //disable any 0xy effect
001d7e 9220 292e                 	sts noise_fx_0xy_sequence+1, zero
001d80 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001d81 937f                      	push r23
001d82 2f6a                      	mov r22, r26 //store the rate into r22
001d83 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001d84 9f67                      	mul r22, r23
001d85 917f                      	pop r23
001d86 916f                      	pop r22
                                 
001d87 9416                      	lsr r1 //shift out the fractional bits
001d88 9407                      	ror r0
001d89 9416                      	lsr r1
001d8a 9407                      	ror r0
001d8b 9416                      	lsr r1
001d8c 9407                      	ror r0
001d8d 9416                      	lsr r1
001d8e 9407                      	ror r0
001d8f 9200 2933                 	sts noise_fx_2xx, r0
001d91 9210 2934                 	sts noise_fx_2xx+1, r1
001d93 cf99                      	rjmp sound_driver_channel3_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel3_fx_3xx:
001d94 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001d95 937f                      	push r23
001d96 2f6a                      	mov r22, r26 //store the rate into r22
001d97 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001d98 9f67                      	mul r22, r23
001d99 917f                      	pop r23
001d9a 916f                      	pop r22
                                 
001d9b 9416                      	lsr r1 //shift out the fractional bits
001d9c 9407                      	ror r0
001d9d 9416                      	lsr r1
001d9e 9407                      	ror r0
001d9f 9416                      	lsr r1
001da0 9407                      	ror r0
001da1 9416                      	lsr r1
001da2 9407                      	ror r0
001da3 9200 293b                 	sts noise_fx_3xx_speed, r0
001da5 9210 293c                 	sts noise_fx_3xx_speed+1, r1
                                 
001da7 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001da8 c001                      	rjmp sound_driver_channel3_fx_3xx_enabled
001da9 cf83                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_3xx_enabled:
001daa 91a0 0abc                 	lds r26, TCB3_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001dac 91b0 0abd                 	lds r27, TCB3_CCMPH
001dae 93a0 2937                 	sts noise_fx_3xx_start, r26
001db0 93b0 2938                 	sts noise_fx_3xx_start+1, r27
                                 
001db2 9220 293d                 	sts noise_fx_3xx_total_offset, zero
001db4 9220 293e                 	sts noise_fx_3xx_total_offset+1, zero
001db6 cf76                      	rjmp sound_driver_channel3_main
                                 
                                 //VIBRATO
                                 sound_driver_channel3_fx_4xy:
001db7 2fba                      	mov r27, r26
001db8 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001db9 95a2                      	swap r26
001dba 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001dbb 93a0 293f                 	sts noise_fx_4xy_speed, r26
001dbd 93b0 2940                 	sts noise_fx_4xy_depth, r27
001dbf 9220 2941                 	sts noise_fx_4xy_phase, zero //reset the phase to 0
001dc1 cf6b                      	rjmp sound_driver_channel3_main
                                 
                                 //TREMELO
                                 sound_driver_channel3_fx_7xy:
001dc2 2fba                      	mov r27, r26
001dc3 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001dc4 95a2                      	swap r26
001dc5 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001dc6 93a0 2942                 	sts noise_fx_7xy_speed, r26
001dc8 93b0 2943                 	sts noise_fx_7xy_depth, r27
001dca 9220 2944                 	sts noise_fx_7xy_phase, zero //reset the phase to 0
001dcc 9220 2945                 	sts noise_fx_7xy_value, zero //reset the tremelo value
001dce cf5e                      	rjmp sound_driver_channel3_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel3_fx_Axy:
001dcf 93a0 2946                 	sts noise_fx_Axy, r26
001dd1 cf5b                      	rjmp sound_driver_channel3_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel3_fx_Bxx:
001dd2 93a0 281f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001dd4 cf58                      	rjmp sound_driver_channel3_main
                                 
                                 //HALT
                                 sound_driver_channel3_fx_Cxx:
001dd5 93b0 2820                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001dd7 cf55                      	rjmp sound_driver_channel3_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel3_fx_Dxx:
001dd8 93b0 2821                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001dda cf52                      	rjmp sound_driver_channel3_main
                                 
                                 //VOLUME
                                 sound_driver_channel3_fx_Exx:
001ddb 91b0 2813                 	lds r27, noise_param
001ddd 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
001dde 2bba                      	or r27, r26 //move new VVVV bits into noise_param
001ddf 93b0 2813                 	sts noise_param, r27
001de1 cf4b                      	rjmp sound_driver_channel3_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel3_fx_Fxx:
001de2 93a0 281e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001de4 cf48                      	rjmp sound_driver_channel3_main
                                 
                                 //DELAY
                                 sound_driver_channel3_fx_Gxx:
001de5 15a2                      	cp r26, zero
001de6 f051                      	breq sound_driver_channel3_fx_Gxx_invalid
001de7 91b0 281e                 	lds r27, song_speed
001de9 17ab                      	cp r26, r27
001dea f430                      	brsh sound_driver_channel3_fx_Gxx_invalid
001deb 93a0 2947                 	sts noise_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001ded e0b1                      	ldi r27, 0x01
001dee 93b0 290c                 	sts noise_pattern_delay_rows, r27
001df0 c20c                      	rjmp sound_driver_channel4
                                 sound_driver_channel3_fx_Gxx_invalid:
001df1 cf3b                      	rjmp sound_driver_channel3_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel3_fx_Hxy: //hardware sweep up
001df2 cf3a                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Ixy: //hardware sweep down
001df3 cf39                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Hxx: //FDS modulation depth
001df4 cf38                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Ixx: //FDS modulation speed
001df5 cf37                      	rjmp sound_driver_channel3_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel3_fx_Pxx:
001df6 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001df7 937f                      	push r23
001df8 2f6a                      	mov r22, r26
001df9 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001dfa 0367                      	mulsu r22, r23
001dfb 917f                      	pop r23
001dfc 916f                      	pop r22
001dfd 9416                      	lsr r1 //shift out the fractional bits
001dfe 9407                      	ror r0
001dff 9416                      	lsr r1
001e00 9407                      	ror r0
001e01 9416                      	lsr r1
001e02 9407                      	ror r0
001e03 9416                      	lsr r1
001e04 9407                      	ror r0
001e05 fe13                      	sbrs r1, 3 //check if result was a negative number
001e06 c002                      	rjmp sound_driver_channel3_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel3_fx_Pxx_negative:
001e07 efb0                      	ldi r27, 0xF0
001e08 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel3_fx_Pxx_store:
001e09 9200 2949                 	sts noise_fx_Pxx_total, r0
001e0b 9210 294a                 	sts noise_fx_Pxx_total+1, r1
001e0d cf1f                      	rjmp sound_driver_channel3_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel3_fx_Qxy:
                                 sound_driver_channel3_fx_Qxy_check_arpeggio_macro:
001e0e 91e0 2915                 	lds ZL, noise_arpeggio_macro
001e10 91f0 2916                 	lds ZH, noise_arpeggio_macro+1
001e12 9630                      	adiw Z, 0
001e13 f009                      	breq sound_driver_channel3_fx_Qxy_check_pitch_macro
001e14 cf18                      	rjmp sound_driver_channel3_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Qxy_check_pitch_macro:
001e15 91e0 291d                 	lds ZL, noise_pitch_macro
001e17 91f0 291e                 	lds ZH, noise_pitch_macro+1
001e19 9630                      	adiw Z, 0
001e1a f009                      	breq sound_driver_channel3_fx_Qxy_check_hi_pitch_macro
001e1b cf11                      	rjmp sound_driver_channel3_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Qxy_check_hi_pitch_macro:
001e1c 91e0 2923                 	lds ZL, noise_hi_pitch_macro
001e1e 91f0 2924                 	lds ZH, noise_hi_pitch_macro+1
001e20 9630                      	adiw Z, 0
001e21 f009                      	breq sound_driver_channel3_fx_Qxy_process
001e22 cf0a                      	rjmp sound_driver_channel3_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Qxy_process:
001e23 2fba                      	mov r27, r26 //copy fx parameters into r27
001e24 70bf                      	andi r27, 0x0F //mask note index offset
001e25 91c0 2817                 	lds r28, noise_note //load current note index
001e27 0fbc                      	add r27, r28
001e28 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001e29 f008                      	brlo sound_driver_channel3_fx_Qxy_process_continue
001e2a e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel3_fx_Qxy_process_continue:
001e2b e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001e2c e0f0                      	ldi ZH, HIGH(note_table << 1)
001e2d 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001e2e 0feb                      	add ZL, r27 //add offset
001e2f 1df2                      	adc ZH, zero
001e30 91c5                      	lpm r28, Z+ //load bytes
001e31 91d4                      	lpm r29, Z
001e32 93c0 294b                 	sts noise_fx_Qxy_target, r28 //load the LOW bits for the target period
001e34 93d0 294c                 	sts noise_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
001e36 95a2                      	swap r26
001e37 70af                      	andi r26, 0x0F //mask effect speed
001e38 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001e39 95a3                      	inc r26 //increment the speed by 1
                                 
001e3a 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001e3b 937f                      	push r23
001e3c 2f6a                      	mov r22, r26 //store the speed data into r27
001e3d eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001e3e 9f67                      	mul r22, r23
001e3f 917f                      	pop r23
001e40 916f                      	pop r22
                                 
001e41 9416                      	lsr r1 //shift out the fractional bits
001e42 9407                      	ror r0
001e43 9416                      	lsr r1
001e44 9407                      	ror r0
001e45 9416                      	lsr r1
001e46 9407                      	ror r0
001e47 9416                      	lsr r1
001e48 9407                      	ror r0
                                 
001e49 9200 294d                 	sts noise_fx_Qxy_speed, r0 //store the effect speed
001e4b 9210 294e                 	sts noise_fx_Qxy_speed+1, r1
001e4d 9220 294f                 	sts noise_fx_Qxy_total_offset, zero
001e4f 9220 2950                 	sts noise_fx_Qxy_total_offset+1, zero
001e51 cedb                      	rjmp sound_driver_channel3_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel3_fx_Rxy:
                                 sound_driver_channel3_fx_Rxy_check_arpeggio_macro:
001e52 91e0 2915                 	lds ZL, noise_arpeggio_macro
001e54 91f0 2916                 	lds ZH, noise_arpeggio_macro+1
001e56 9630                      	adiw Z, 0
001e57 f009                      	breq sound_driver_channel3_fx_Rxy_check_pitch_macro
001e58 ced4                      	rjmp sound_driver_channel3_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Rxy_check_pitch_macro:
001e59 91e0 291d                 	lds ZL, noise_pitch_macro
001e5b 91f0 291e                 	lds ZH, noise_pitch_macro+1
001e5d 9630                      	adiw Z, 0
001e5e f009                      	breq sound_driver_channel3_fx_Rxy_check_hi_pitch_macro
001e5f cecd                      	rjmp sound_driver_channel3_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Rxy_check_hi_pitch_macro:
001e60 91e0 2923                 	lds ZL, noise_hi_pitch_macro
001e62 91f0 2924                 	lds ZH, noise_hi_pitch_macro+1
001e64 9630                      	adiw Z, 0
001e65 f009                      	breq sound_driver_channel3_fx_Rxy_process
001e66 cec6                      	rjmp sound_driver_channel3_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Rxy_process:
001e67 2fba                      	mov r27, r26 //copy fx parameters into r27
001e68 70bf                      	andi r27, 0x0F //mask note index offset
001e69 91c0 2817                 	lds r28, noise_note //load current note index
001e6b 1bcb                      	sub r28, r27
001e6c f408                      	brcc sound_driver_channel3_fx_Rxy_process_continue
001e6d e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel3_fx_Rxy_process_continue:
001e6e e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001e6f e0f0                      	ldi ZH, HIGH(note_table << 1)
001e70 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001e71 0fec                      	add ZL, r28 //add offset
001e72 1df2                      	adc ZH, zero
001e73 91c5                      	lpm r28, Z+ //load bytes
001e74 91d4                      	lpm r29, Z
001e75 93c0 2951                 	sts noise_fx_Rxy_target, r28 //load the LOW bits for the target period
001e77 93d0 2952                 	sts noise_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
001e79 95a2                      	swap r26
001e7a 70af                      	andi r26, 0x0F //mask effect speed
001e7b 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001e7c 95a3                      	inc r26 //increment the speed by 1
                                 
001e7d 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001e7e 937f                      	push r23
001e7f 2f6a                      	mov r22, r26 //store the speed data into r27
001e80 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001e81 9f67                      	mul r22, r23
001e82 917f                      	pop r23
001e83 916f                      	pop r22
                                 
001e84 9416                      	lsr r1 //shift out the fractional bits
001e85 9407                      	ror r0
001e86 9416                      	lsr r1
001e87 9407                      	ror r0
001e88 9416                      	lsr r1
001e89 9407                      	ror r0
001e8a 9416                      	lsr r1
001e8b 9407                      	ror r0
                                 
001e8c 9200 2953                 	sts noise_fx_Rxy_speed, r0 //store the effect speed
001e8e 9210 2954                 	sts noise_fx_Rxy_speed+1, r1
001e90 9220 2955                 	sts noise_fx_Rxy_total_offset, zero
001e92 9220 2956                 	sts noise_fx_Rxy_total_offset+1, zero
001e94 ce98                      	rjmp sound_driver_channel3_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel3_fx_Sxx:
001e95 15a2                      	cp r26, zero
001e96 f051                      	breq sound_driver_channel3_fx_Sxx_invalid
001e97 91b0 281e                 	lds r27, song_speed
001e99 17ab                      	cp r26, r27
001e9a f430                      	brsh sound_driver_channel3_fx_Sxx_invalid
001e9b 93a0 2957                 	sts noise_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001e9d e0b1                      	ldi r27, 0x01
001e9e 93b0 290c                 	sts noise_pattern_delay_rows, r27
001ea0 c15c                      	rjmp sound_driver_channel4
                                 sound_driver_channel3_fx_Sxx_invalid:
001ea1 ce8b                      	rjmp sound_driver_channel3_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel3_fx_Vxx:
001ea2 95a6                      	lsr r26
001ea3 95a7                      	ror r26 //move mode bit to bit 7
001ea4 91b0 2814                 	lds r27, noise_period
001ea6 77bf                      	andi r27, 0b01111111
001ea7 2bba                      	or r27, r26 //store the new noise mode
001ea8 93b0 2813                 	sts noise_param, r27
                                 
001eaa 776f                      	andi noise_sequence_HIGH, 0b01111111
001eab 2b6a                      	or noise_sequence_HIGH, r26
001eac ce80                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_Wxx: //DPCM sample speed
001ead ce7f                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Xxx: //DPCM sample retrigger
001eae ce7e                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Yxx: //DPCM sample offset
001eaf ce7d                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Zxx: //DPCM sample delta counter
001eb0 ce7c                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 sound_driver_channel3_note:
001eb1 93b0 2817                 	sts noise_note, r27 //store the note index
001eb3 e0a3                      	ldi r26, 0x03
001eb4 e0b2                      	ldi r27, 0x02
001eb5 93b0 2912                 	sts noise_volume_macro_offset, r27 //reset all macro offsets
001eb7 93a0 2917                 	sts noise_arpeggio_macro_offset, r26
001eb9 93b0 291f                 	sts noise_pitch_macro_offset, r27
001ebb 93b0 2925                 	sts noise_hi_pitch_macro_offset, r27
001ebd 93b0 292a                 	sts noise_duty_macro_offset, r27
001ebf 9220 291b                 	sts noise_total_pitch_offset, zero //reset the pitch and hi pitch offset
001ec1 9220 291c                 	sts noise_total_pitch_offset+1, zero
001ec3 9220 2922                 	sts noise_total_hi_pitch_offset, zero
001ec5 9220 2931                 	sts noise_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001ec7 9220 2932                 	sts noise_fx_1xx_total+1, zero
001ec9 9220 2935                 	sts noise_fx_2xx_total, zero
001ecb 9220 2936                 	sts noise_fx_2xx_total+1, zero
001ecd 9220 293d                 	sts noise_fx_3xx_total_offset, zero //reset 3xx offset
001ecf 9220 293e                 	sts noise_fx_3xx_total_offset+1, zero
001ed1 91a0 0abc                 	lds r26, TCB3_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001ed3 91b0 0abd                 	lds r27, TCB3_CCMPH
001ed5 93a0 2937                 	sts noise_fx_3xx_start, r26
001ed7 93b0 2938                 	sts noise_fx_3xx_start+1, r27
001ed9 9220 294b                 	sts noise_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001edb 9220 294c                 	sts noise_fx_Qxy_target+1, zero
001edd 9220 294f                 	sts noise_fx_Qxy_total_offset, zero
001edf 9220 2950                 	sts noise_fx_Qxy_total_offset+1, zero
001ee1 9220 2951                 	sts noise_fx_Rxy_target, zero
001ee3 9220 2952                 	sts noise_fx_Rxy_target+1, zero
001ee5 9220 2955                 	sts noise_fx_Rxy_total_offset, zero
001ee7 9220 2956                 	sts noise_fx_Rxy_total_offset+1, zero
001ee9 d0fc                      	rcall sound_driver_channel3_increment_offset
001eea ce42                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_volume:
001eeb 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001eec 91a0 2813                 	lds r26, noise_param
001eee 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001eef 2bab                      	or r26, r27 //move new VVVV bits into noise_param
001ef0 93a0 2813                 	sts noise_param, r26
001ef2 d0f3                      	rcall sound_driver_channel3_increment_offset
001ef3 ce39                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_delay:
001ef4 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001ef5 93b0 290c                 	sts noise_pattern_delay_rows, r27
001ef7 d0ee                      	rcall sound_driver_channel3_increment_offset
001ef8 c104                      	rjmp sound_driver_channel4
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change:
001ef9 9220 2910                 	sts noise_volume_macro, zero //reset all macro addresses
001efb 9220 2911                 	sts noise_volume_macro+1, zero
001efd 9220 2915                 	sts noise_arpeggio_macro, zero
001eff 9220 2916                 	sts noise_arpeggio_macro+1, zero
001f01 9220 291d                 	sts noise_pitch_macro, zero
001f03 9220 291e                 	sts noise_pitch_macro+1, zero
001f05 9220 2923                 	sts noise_hi_pitch_macro, zero
001f07 9220 2924                 	sts noise_hi_pitch_macro+1, zero
001f09 9220 2928                 	sts noise_duty_macro, zero
001f0b 9220 2929                 	sts noise_duty_macro+1, zero
001f0d 9220 291b                 	sts noise_total_pitch_offset, zero //reset the pitch offset
001f0f 9220 291c                 	sts noise_total_pitch_offset+1, zero
001f11 9220 2922                 	sts noise_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001f13 9631                      	adiw Z, 1 //point to the byte next to the flag
001f14 91b4                      	lpm r27, Z //store the instrument offset into r27
001f15 e2ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
001f16 e0fd                      	ldi ZH, HIGH(instruments)
001f17 0feb                      	add ZL, r27 //point Z to offsetted instrument
001f18 1df2                      	adc ZH, zero
001f19 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001f1a 1fff                      	rol ZH
001f1b 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001f1c 91b4                      	lpm r27, Z
                                 
001f1d 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001f1e 1fbb                      	rol r27
001f1f 2fea                      	mov ZL, r26
001f20 2ffb                      	mov ZH, r27
001f21 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001f22 9632                      	adiw Z, 2 //point Z to the address of the macro
001f23 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel3_instrument_change_macro_loop:
001f24 95aa                      	dec r26
001f25 f019                      	breq sound_driver_channel3_instrument_change_exit
001f26 95b6                      	lsr r27
001f27 f078                      	brcs sound_driver_channel3_instrument_change_load_macro
001f28 cffb                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_exit:
001f29 e0a3                      	ldi r26, 0x03
001f2a e0b2                      	ldi r27, 0x02
001f2b 93b0 2912                 	sts noise_volume_macro_offset, r27 //reset all macro offsets
001f2d 93a0 2917                 	sts noise_arpeggio_macro_offset, r26
001f2f 93b0 291f                 	sts noise_pitch_macro_offset, r27
001f31 93b0 2925                 	sts noise_hi_pitch_macro_offset, r27
001f33 93b0 292a                 	sts noise_duty_macro_offset, r27
001f35 d0ba                      	rcall sound_driver_channel3_increment_offset_twice
001f36 cdf6                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_load_macro:
001f37 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001f38 91d5                      	lpm r29, Z+
                                 
001f39 30a5                      	cpi r26, 5
001f3a f039                      	breq sound_driver_channel3_instrument_change_load_macro_volume
001f3b 30a4                      	cpi r26, 4
001f3c f079                      	breq sound_driver_channel3_instrument_change_load_macro_arpeggio
001f3d 30a3                      	cpi r26, 3
001f3e f0d9                      	breq sound_driver_channel3_instrument_change_load_macro_pitch
001f3f 30a2                      	cpi r26, 2
001f40 f159                      	breq sound_driver_channel3_instrument_change_load_macro_hi_pitch
001f41 c03c                      	rjmp sound_driver_channel3_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel3_instrument_change_load_macro_volume:
001f42 93c0 2910                 	sts noise_volume_macro, r28
001f44 93d0 2911                 	sts noise_volume_macro+1, r29
001f46 d041                      	rcall sound_driver_channel3_instrument_change_read_header
001f47 93c0 2914                 	sts noise_volume_macro_release, r28
001f49 93d0 2913                 	sts noise_volume_macro_loop, r29
001f4b cfd8                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 	
                                 sound_driver_channel3_instrument_change_load_macro_arpeggio:
001f4c 93c0 2915                 	sts noise_arpeggio_macro, r28
001f4e 93d0 2916                 	sts noise_arpeggio_macro+1, r29
001f50 9220 294b                 	sts noise_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001f52 9220 294c                 	sts noise_fx_Qxy_target+1, zero
001f54 9220 2951                 	sts noise_fx_Rxy_target, zero
001f56 9220 2952                 	sts noise_fx_Rxy_target+1, zero
001f58 d03a                      	rcall sound_driver_channel3_instrument_change_read_header_arpeggio
001f59 cfca                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_pitch:
001f5a 93c0 291d                 	sts noise_pitch_macro, r28
001f5c 93d0 291e                 	sts noise_pitch_macro+1, r29
001f5e 9220 294b                 	sts noise_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001f60 9220 294c                 	sts noise_fx_Qxy_target+1, zero
001f62 9220 2951                 	sts noise_fx_Rxy_target, zero
001f64 9220 2952                 	sts noise_fx_Rxy_target+1, zero
001f66 d021                      	rcall sound_driver_channel3_instrument_change_read_header
001f67 93c0 2921                 	sts noise_pitch_macro_release, r28
001f69 93d0 2920                 	sts noise_pitch_macro_loop, r29
001f6b cfb8                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_hi_pitch:
001f6c 93c0 2923                 	sts noise_hi_pitch_macro, r28
001f6e 93d0 2924                 	sts noise_hi_pitch_macro+1, r29
001f70 9220 294b                 	sts noise_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001f72 9220 294c                 	sts noise_fx_Qxy_target+1, zero
001f74 9220 2951                 	sts noise_fx_Rxy_target, zero
001f76 9220 2952                 	sts noise_fx_Rxy_target+1, zero
001f78 d00f                      	rcall sound_driver_channel3_instrument_change_read_header
001f79 93c0 2927                 	sts noise_hi_pitch_macro_release, r28
001f7b 93d0 2926                 	sts noise_hi_pitch_macro_loop, r29
001f7d cfa6                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_duty:
001f7e 93c0 2928                 	sts noise_duty_macro, r28
001f80 93d0 2929                 	sts noise_duty_macro+1, r29
001f82 d005                      	rcall sound_driver_channel3_instrument_change_read_header
001f83 93c0 292c                 	sts noise_duty_macro_release, r28
001f85 93d0 292b                 	sts noise_duty_macro_loop, r29
001f87 cf9c                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_read_header:
001f88 93ef                      	push ZL
001f89 93ff                      	push ZH
001f8a 2fec                      	mov ZL, r28
001f8b 2ffd                      	mov ZH, r29
001f8c 0fee                      	lsl ZL
001f8d 1fff                      	rol ZH
001f8e 91c5                      	lpm r28, Z+
001f8f 91d4                      	lpm r29, Z
001f90 91ff                      	pop ZH
001f91 91ef                      	pop ZL
001f92 9508                      	ret
                                 
                                 sound_driver_channel3_instrument_change_read_header_arpeggio:
001f93 93ef                      	push ZL
001f94 93ff                      	push ZH
001f95 2fec                      	mov ZL, r28
001f96 2ffd                      	mov ZH, r29
001f97 0fee                      	lsl ZL
001f98 1fff                      	rol ZH
001f99 91c5                      	lpm r28, Z+
001f9a 91d5                      	lpm r29, Z+
001f9b 93c0 2919                 	sts noise_arpeggio_macro_release, r28
001f9d 93d0 2918                 	sts noise_arpeggio_macro_loop, r29
001f9f 91c4                      	lpm r28, Z
001fa0 93c0 291a                 	sts noise_arpeggio_macro_mode, r28
001fa2 91ff                      	pop ZH
001fa3 91ef                      	pop ZL
001fa4 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel3_release:
                                 sound_driver_channel3_release_volume:
001fa5 91b0 2914                 	lds r27, noise_volume_macro_release
001fa7 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001fa8 f019                      	breq sound_driver_channel3_release_arpeggio //if the macro has no release flag, check the next macro
001fa9 95b3                      	inc r27
001faa 93b0 2912                 	sts noise_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel3_release_arpeggio:
001fac 91b0 2919                 	lds r27, noise_arpeggio_macro_release
001fae 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001faf f019                      	breq sound_driver_channel3_release_pitch
001fb0 95b3                      	inc r27
001fb1 93b0 2917                 	sts noise_arpeggio_macro_offset, r27
                                 sound_driver_channel3_release_pitch:
001fb3 91b0 2921                 	lds r27, noise_pitch_macro_release
001fb5 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001fb6 f019                      	breq sound_driver_channel3_release_hi_pitch
001fb7 95b3                      	inc r27
001fb8 93b0 291f                 	sts noise_pitch_macro_offset, r27
                                 sound_driver_channel3_release_hi_pitch:
001fba 91b0 2927                 	lds r27, noise_hi_pitch_macro_release
001fbc 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001fbd f019                      	breq sound_driver_channel3_release_duty
001fbe 95b3                      	inc r27
001fbf 93b0 2925                 	sts noise_hi_pitch_macro_offset, r27
                                 sound_driver_channel3_release_duty:
001fc1 91b0 292c                 	lds r27, noise_duty_macro_release
001fc3 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001fc4 f019                      	breq sound_driver_channel3_release_exit
001fc5 95b3                      	inc r27
001fc6 93b0 292a                 	sts noise_duty_macro_offset, r27
                                 sound_driver_channel3_release_exit:
001fc8 d01d                      	rcall sound_driver_channel3_increment_offset
001fc9 cd63                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_next_pattern:
001fca 91e0 2818                 	lds ZL, song_frames
001fcc 91f0 2819                 	lds ZH, song_frames+1
001fce 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001fd0 91b0 281b                 	lds r27, song_frame_offset+1
001fd2 93a0 281a                 	sts song_frame_offset, r26
001fd4 93b0 281b                 	sts song_frame_offset+1, r27
001fd6 9616                      	adiw r27:r26, 6 //offset for channel 3
001fd7 0fea                      	add ZL, r26
001fd8 1ffb                      	adc ZH, r27
                                 
001fd9 91a5                      	lpm r26, Z+ //load the address of the next pattern
001fda 91b4                      	lpm r27, Z
001fdb 0faa                      	lsl r26
001fdc 1fbb                      	rol r27
001fdd 93a0 290a                 	sts noise_pattern, r26
001fdf 93b0 290b                 	sts noise_pattern+1, r27
                                 
001fe1 9220 290e                 	sts noise_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001fe3 9220 290f                 	sts noise_pattern_offset+1, zero
001fe5 cd47                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_increment_offset:
001fe6 91e0 290e                 	lds ZL, noise_pattern_offset //current offset in the pattern for noise
001fe8 91f0 290f                 	lds ZH, noise_pattern_offset+1
001fea 9631                      	adiw Z, 1
001feb 93e0 290e                 	sts noise_pattern_offset, ZL
001fed 93f0 290f                 	sts noise_pattern_offset+1, ZH
001fef 9508                      	ret
                                 
                                 sound_driver_channel3_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001ff0 91e0 290e                 	lds ZL, noise_pattern_offset //current offset in the pattern for noise
001ff2 91f0 290f                 	lds ZH, noise_pattern_offset+1
001ff4 9632                      	adiw Z, 2 //increment the pointer twice
001ff5 93e0 290e                 	sts noise_pattern_offset, ZL
001ff7 93f0 290f                 	sts noise_pattern_offset+1, ZH
001ff9 9508                      	ret
                                 
                                 sound_driver_channel3_decrement_frame_delay:
001ffa 95ba                      	dec r27
001ffb 93b0 290d                 	sts noise_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel4:
                                 
                                 sound_driver_calculate_delays:
001ffd 91f0 281e                 	lds r31, song_speed
001fff 2fef                      	mov r30, r31
002000 50e1                      	subi r30, 1
                                 sound_driver_calculate_delays_pulse1:
002001 91a0 2825                 	lds r26, pulse1_pattern_delay_frames
002003 11a2                      	cpse r26, zero
002004 c042                      	rjmp sound_driver_calculate_delays_pulse2
002005 c000                      	rjmp sound_driver_calculate_delays_pulse1_main
                                 
                                 sound_driver_calculate_delays_pulse1_main:
002006 2faf                      	mov r26, r31 //move the speed to r26
002007 91b0 2824                 	lds r27, pulse1_pattern_delay_rows //decrement the delay rows
002009 15b2                      	cp r27, zero
00200a f409                      	brne PC+2
00200b c03b                      	rjmp sound_driver_calculate_delays_pulse2
00200c 95ba                      	dec r27
00200d 93b0 2824                 	sts pulse1_pattern_delay_rows, r27
00200f 11b2                      	cpse r27, zero
002010 c034                      	rjmp sound_driver_calculate_delays_pulse1_store
002011 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx:
002012 efbf                      	ldi r27, 0xFF
002013 91c0 286f                 	lds r28, pulse1_fx_Sxx_pre
002015 91d0 2870                 	lds r29, pulse1_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse1_Sxx_check_pre:
002017 17cb                      	cp r28, r27
002018 f009                      	breq sound_driver_calculate_delays_pulse1_Sxx_check_post
002019 c00d                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_pre
                                 sound_driver_calculate_delays_pulse1_Sxx_check_post:
00201a 17db                      	cp r29, r27
00201b f009                      	breq sound_driver_calculate_delays_pulse1_Gxx
00201c c015                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx:
00201d 91c0 285f                 	lds r28, pulse1_fx_Gxx_pre
00201f 91d0 2860                 	lds r29, pulse1_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse1_Gxx_check_pre:
002021 17cb                      	cp r28, r27
002022 f009                      	breq sound_driver_calculate_delays_pulse1_Gxx_check_post
002023 c012                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_pre
                                 sound_driver_calculate_delays_pulse1_Gxx_check_post:
002024 17db                      	cp r29, r27
002025 f0f9                      	breq sound_driver_calculate_delays_pulse1_store
002026 c01a                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_pre:
002027 93b0 286f                 	sts pulse1_fx_Sxx_pre, r27
002029 1bec                      	sub r30, r28 //(song speed)-1-Sxx
00202a 93e0 2870                 	sts pulse1_fx_Sxx_post, r30
00202c 95ca                      	dec r28
00202d 93c0 2825                 	sts pulse1_pattern_delay_frames, r28
00202f 2fef                      	mov r30, r31
002030 50e1                      	subi r30, 1
002031 c015                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_post:
002032 93b0 2870                 	sts pulse1_fx_Sxx_post, r27
002034 2fad                      	mov r26, r29
002035 c00f                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx_pre:
002036 93b0 285f                 	sts pulse1_fx_Gxx_pre, r27
002038 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002039 93e0 2860                 	sts pulse1_fx_Gxx_post, r30
00203b 95ca                      	dec r28
00203c 93c0 2825                 	sts pulse1_pattern_delay_frames, r28
00203e 2fef                      	mov r30, r31
00203f 50e1                      	subi r30, 1
002040 c006                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse1_Gxx_post:
002041 93b0 2860                 	sts pulse1_fx_Gxx_post, r27
002043 2fad                      	mov r26, r29
002044 c000                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_store:
002045 93a0 2825                 	sts pulse1_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_pulse2:
002047 91a0 2874                 	lds r26, pulse2_pattern_delay_frames
002049 11a2                      	cpse r26, zero
00204a c042                      	rjmp sound_driver_calculate_delays_triangle
00204b c000                      	rjmp sound_driver_calculate_delays_pulse2_main
                                 
                                 sound_driver_calculate_delays_pulse2_main:
00204c 2faf                      	mov r26, r31 //move the speed to r26
00204d 91b0 2873                 	lds r27, pulse2_pattern_delay_rows //decrement the delay rows
00204f 15b2                      	cp r27, zero
002050 f409                      	brne PC+2
002051 c03b                      	rjmp sound_driver_calculate_delays_triangle
002052 95ba                      	dec r27
002053 93b0 2873                 	sts pulse2_pattern_delay_rows, r27
002055 11b2                      	cpse r27, zero
002056 c034                      	rjmp sound_driver_calculate_delays_pulse2_store
002057 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx:
002058 efbf                      	ldi r27, 0xFF
002059 91c0 28be                 	lds r28, pulse2_fx_Sxx_pre
00205b 91d0 28bf                 	lds r29, pulse2_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse2_Sxx_check_pre:
00205d 17cb                      	cp r28, r27
00205e f009                      	breq sound_driver_calculate_delays_pulse2_Sxx_check_post
00205f c00d                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_pre
                                 sound_driver_calculate_delays_pulse2_Sxx_check_post:
002060 17db                      	cp r29, r27
002061 f009                      	breq sound_driver_calculate_delays_pulse2_Gxx
002062 c015                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx:
002063 91c0 28ae                 	lds r28, pulse2_fx_Gxx_pre
002065 91d0 28af                 	lds r29, pulse2_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse2_Gxx_check_pre:
002067 17cb                      	cp r28, r27
002068 f009                      	breq sound_driver_calculate_delays_pulse2_Gxx_check_post
002069 c012                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_pre
                                 sound_driver_calculate_delays_pulse2_Gxx_check_post:
00206a 17db                      	cp r29, r27
00206b f0f9                      	breq sound_driver_calculate_delays_pulse2_store
00206c c01a                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_pre:
00206d 93b0 28be                 	sts pulse2_fx_Sxx_pre, r27
00206f 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002070 93e0 28bf                 	sts pulse2_fx_Sxx_post, r30
002072 95ca                      	dec r28
002073 93c0 2874                 	sts pulse2_pattern_delay_frames, r28
002075 2fef                      	mov r30, r31
002076 50e1                      	subi r30, 1
002077 cfcf                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_post:
002078 93b0 28bf                 	sts pulse2_fx_Sxx_post, r27
00207a 2fad                      	mov r26, r29
00207b c00f                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx_pre:
00207c 93b0 28ae                 	sts pulse2_fx_Gxx_pre, r27
00207e 1bec                      	sub r30, r28 //(song speed)-1-Sxx
00207f 93e0 28af                 	sts pulse2_fx_Gxx_post, r30
002081 95ca                      	dec r28
002082 93c0 2874                 	sts pulse2_pattern_delay_frames, r28
002084 2fef                      	mov r30, r31
002085 50e1                      	subi r30, 1
002086 cfc0                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse2_Gxx_post:
002087 93b0 28af                 	sts pulse2_fx_Gxx_post, r27
002089 2fad                      	mov r26, r29
00208a c000                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_store:
00208b 93a0 2874                 	sts pulse2_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_triangle:
00208d 91a0 28c3                 	lds r26, triangle_pattern_delay_frames
00208f 11a2                      	cpse r26, zero
002090 c042                      	rjmp sound_driver_calculate_delays_noise
002091 c000                      	rjmp sound_driver_calculate_delays_triangle_main
                                 
                                 sound_driver_calculate_delays_triangle_main:
002092 2faf                      	mov r26, r31 //move the speed to r26
002093 91b0 28c2                 	lds r27, triangle_pattern_delay_rows //decrement the delay rows
002095 15b2                      	cp r27, zero
002096 f409                      	brne PC+2
002097 c03b                      	rjmp sound_driver_calculate_delays_noise
002098 95ba                      	dec r27
002099 93b0 28c2                 	sts triangle_pattern_delay_rows, r27
00209b 11b2                      	cpse r27, zero
00209c c034                      	rjmp sound_driver_calculate_delays_triangle_store
00209d 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_triangle_Sxx:
00209e efbf                      	ldi r27, 0xFF
00209f 91c0 2908                 	lds r28, triangle_fx_Sxx_pre
0020a1 91d0 2909                 	lds r29, triangle_fx_Sxx_post
                                 sound_driver_calculate_delays_triangle_Sxx_check_pre:
0020a3 17cb                      	cp r28, r27
0020a4 f009                      	breq sound_driver_calculate_delays_triangle_Sxx_check_post
0020a5 c00d                      	rjmp sound_driver_calculate_delays_triangle_Sxx_pre
                                 sound_driver_calculate_delays_triangle_Sxx_check_post:
0020a6 17db                      	cp r29, r27
0020a7 f009                      	breq sound_driver_calculate_delays_triangle_Gxx
0020a8 c015                      	rjmp sound_driver_calculate_delays_triangle_Sxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Gxx:
0020a9 91c0 28f8                 	lds r28, triangle_fx_Gxx_pre
0020ab 91d0 28f9                 	lds r29, triangle_fx_Gxx_post
                                 sound_driver_calculate_delays_triangle_Gxx_check_pre:
0020ad 17cb                      	cp r28, r27
0020ae f009                      	breq sound_driver_calculate_delays_triangle_Gxx_check_post
0020af c012                      	rjmp sound_driver_calculate_delays_triangle_Gxx_pre
                                 sound_driver_calculate_delays_triangle_Gxx_check_post:
0020b0 17db                      	cp r29, r27
0020b1 f0f9                      	breq sound_driver_calculate_delays_triangle_store
0020b2 c01a                      	rjmp sound_driver_calculate_delays_triangle_Gxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_pre:
0020b3 93b0 2908                 	sts triangle_fx_Sxx_pre, r27
0020b5 1bec                      	sub r30, r28 //(song speed)-1-Sxx
0020b6 93e0 2909                 	sts triangle_fx_Sxx_post, r30
0020b8 95ca                      	dec r28
0020b9 93c0 28c3                 	sts triangle_pattern_delay_frames, r28
0020bb 2fef                      	mov r30, r31
0020bc 50e1                      	subi r30, 1
0020bd c015                      	rjmp sound_driver_calculate_delays_noise
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_post:
0020be 93b0 2909                 	sts triangle_fx_Sxx_post, r27
0020c0 2fad                      	mov r26, r29
0020c1 c00f                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_Gxx_pre:
0020c2 93b0 28f8                 	sts triangle_fx_Gxx_pre, r27
0020c4 1bec                      	sub r30, r28 //(song speed)-1-Sxx
0020c5 93e0 28f9                 	sts triangle_fx_Gxx_post, r30
0020c7 95ca                      	dec r28
0020c8 93c0 28c3                 	sts triangle_pattern_delay_frames, r28
0020ca 2fef                      	mov r30, r31
0020cb 50e1                      	subi r30, 1
0020cc c006                      	rjmp sound_driver_calculate_delays_noise
                                 	
                                 sound_driver_calculate_delays_triangle_Gxx_post:
0020cd 93b0 28f9                 	sts triangle_fx_Gxx_post, r27
0020cf 2fad                      	mov r26, r29
0020d0 c000                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_store:
0020d1 93a0 28c3                 	sts triangle_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_noise:
0020d3 91a0 290d                 	lds r26, noise_pattern_delay_frames
0020d5 11a2                      	cpse r26, zero
0020d6 c042                      	rjmp sound_driver_calculate_delays_dpcm
0020d7 c000                      	rjmp sound_driver_calculate_delays_noise_main
                                 
                                 sound_driver_calculate_delays_noise_main:
0020d8 2faf                      	mov r26, r31 //move the speed to r26
0020d9 91b0 290c                 	lds r27, noise_pattern_delay_rows //decrement the delay rows
0020db 15b2                      	cp r27, zero
0020dc f409                      	brne PC+2
0020dd c03b                      	rjmp sound_driver_calculate_delays_dpcm
0020de 95ba                      	dec r27
0020df 93b0 290c                 	sts noise_pattern_delay_rows, r27
0020e1 11b2                      	cpse r27, zero
0020e2 c034                      	rjmp sound_driver_calculate_delays_noise_store
0020e3 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_noise_Sxx:
0020e4 efbf                      	ldi r27, 0xFF
0020e5 91c0 2957                 	lds r28, noise_fx_Sxx_pre
0020e7 91d0 2958                 	lds r29, noise_fx_Sxx_post
                                 sound_driver_calculate_delays_noise_Sxx_check_pre:
0020e9 17cb                      	cp r28, r27
0020ea f009                      	breq sound_driver_calculate_delays_noise_Sxx_check_post
0020eb c00d                      	rjmp sound_driver_calculate_delays_noise_Sxx_pre
                                 sound_driver_calculate_delays_noise_Sxx_check_post:
0020ec 17db                      	cp r29, r27
0020ed f009                      	breq sound_driver_calculate_delays_noise_Gxx
0020ee c015                      	rjmp sound_driver_calculate_delays_noise_Sxx_post
                                 
                                 sound_driver_calculate_delays_noise_Gxx:
0020ef 91c0 2947                 	lds r28, noise_fx_Gxx_pre
0020f1 91d0 2948                 	lds r29, noise_fx_Gxx_post
                                 sound_driver_calculate_delays_noise_Gxx_check_pre:
0020f3 17cb                      	cp r28, r27
0020f4 f009                      	breq sound_driver_calculate_delays_noise_Gxx_check_post
0020f5 c012                      	rjmp sound_driver_calculate_delays_noise_Gxx_pre
                                 sound_driver_calculate_delays_noise_Gxx_check_post:
0020f6 17db                      	cp r29, r27
0020f7 f0f9                      	breq sound_driver_calculate_delays_noise_store
0020f8 c01a                      	rjmp sound_driver_calculate_delays_noise_Gxx_post
                                 
                                 sound_driver_calculate_delays_noise_Sxx_pre:
0020f9 93b0 2957                 	sts noise_fx_Sxx_pre, r27
0020fb 1bec                      	sub r30, r28 //(song speed)-1-Sxx
0020fc 93e0 2958                 	sts noise_fx_Sxx_post, r30
0020fe 95ca                      	dec r28
0020ff 93c0 290d                 	sts noise_pattern_delay_frames, r28
002101 2fef                      	mov r30, r31
002102 50e1                      	subi r30, 1
002103 c015                      	rjmp sound_driver_calculate_delays_dpcm
                                 
                                 sound_driver_calculate_delays_noise_Sxx_post:
002104 93b0 2958                 	sts noise_fx_Sxx_post, r27
002106 2fad                      	mov r26, r29
002107 c00f                      	rjmp sound_driver_calculate_delays_noise_store
                                 
                                 sound_driver_calculate_delays_noise_Gxx_pre:
002108 93b0 2947                 	sts noise_fx_Gxx_pre, r27
00210a 1bec                      	sub r30, r28 //(song speed)-1-Sxx
00210b 93e0 2948                 	sts noise_fx_Gxx_post, r30
00210d 95ca                      	dec r28
00210e 93c0 290d                 	sts noise_pattern_delay_frames, r28
002110 2fef                      	mov r30, r31
002111 50e1                      	subi r30, 1
002112 c006                      	rjmp sound_driver_calculate_delays_dpcm
                                 	
                                 sound_driver_calculate_delays_noise_Gxx_post:
002113 93b0 2948                 	sts noise_fx_Gxx_post, r27
002115 2fad                      	mov r26, r29
002116 c000                      	rjmp sound_driver_calculate_delays_noise_store
                                 
                                 sound_driver_calculate_delays_noise_store:
002117 93a0 290d                 	sts noise_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_dpcm:
                                 
                                 sound_driver_instrument_fx_routine:
                                 sound_driver_instrument_routine_channel0_volume:
002119 91e0 2828                 	lds ZL, pulse1_volume_macro
00211b 91f0 2829                 	lds ZH, pulse1_volume_macro+1
00211d 9630                      	adiw Z, 0
00211e f1a1                      	breq sound_driver_instrument_routine_channel0_volume_default //if no volume macro is in use, use default multiplier of F
00211f 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002120 1fff                      	rol ZH
002121 91a0 282a                 	lds r26, pulse1_volume_macro_offset
002123 0fea                      	add ZL, r26
002124 1df2                      	adc ZH, zero
                                 
002125 91b0 282c                 	lds r27, pulse1_volume_macro_release
002127 17ba                      	cp r27, r26
002128 f429                      	brne sound_driver_instrument_routine_channel0_volume_increment //if the current offset is not equal to the release index, increment the offset
002129 91a0 282b                 	lds r26, pulse1_volume_macro_loop
00212b 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00212c f010                      	brlo sound_driver_instrument_routine_channel0_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00212d c003                      	rjmp sound_driver_instrument_routine_channel0_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_volume_increment:
00212e 95a3                      	inc r26 //increment the macro offset
00212f 93a0 282a                 	sts pulse1_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_volume_read:
002131 91b4                      	lpm r27, Z //load volume data into r27
002132 3fbf                      	cpi r27, 0xFF //check for macro end flag
002133 f469                      	brne sound_driver_instrument_routine_channel0_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_release:
002134 91b0 282c                 	lds r27, pulse1_volume_macro_release
002136 3fbf                      	cpi r27, 0xFF
002137 f429                      	brne sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_loop:
002138 91b0 282b                 	lds r27, pulse1_volume_macro_loop //load the loop index
00213a 93b0 282a                 	sts pulse1_volume_macro_offset, r27 //store the loop index into the offset
00213c cfdc                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index:
00213d 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
00213e 93a0 282a                 	sts pulse1_volume_macro_offset, r26
002140 cfd8                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_calculate:
002141 e8e4                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
002142 e5fc                      	ldi ZH, HIGH(volumes << 1)
002143 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
002144 0feb                      	add ZL, r27 //add offset to the table
002145 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel0_volume_load:
002146 91b0 2800                 	lds r27, pulse1_param //load main volume
002148 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002149 91a0 285d                 	lds r26, pulse1_fx_7xy_value
00214b 30a0                      	cpi r26, 0x00
00214c f481                      	brne sound_driver_instrument_routine_channel0_volume_load_7xy
                                 
00214d 0feb                      	add ZL, r27 //offset the volume table by the main volume
00214e 1df2                      	adc ZH, zero
00214f 91b4                      	lpm r27, Z
002150 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
002152 c023                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default:
002153 91b0 2800                 	lds r27, pulse1_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
002155 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002156 91a0 285d                 	lds r26, pulse1_fx_7xy_value
002158 30a0                      	cpi r26, 0x00
002159 f499                      	brne sound_driver_instrument_routine_channel0_volume_default_7xy
00215a 93b0 2806                 	sts pulse1_output_volume, r27
00215c c019                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy:
00215d 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
00215e f038                      	brcs sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
00215f f031                      	breq sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
                                 
002160 0feb                      	add ZL, r27 //offset the volume table by the main volume
002161 1df2                      	adc ZH, zero
002162 91b4                      	lpm r27, Z
002163 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
002165 c010                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy_overflow:
002166 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002167 0feb                      	add ZL, r27 //offset the volume table by the main volume
002168 1df2                      	adc ZH, zero
002169 91b4                      	lpm r27, Z
00216a 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
00216c c009                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default_7xy:
00216d 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
00216e f020                      	brcs sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
00216f f019                      	breq sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
002170 93b0 2806                 	sts pulse1_output_volume, r27
002172 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel0_volume_default_7xy_overflow:
002173 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002174 93b0 2806                 	sts pulse1_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002176 91e0 282d                 	lds ZL, pulse1_arpeggio_macro
002178 91f0 282e                 	lds ZH, pulse1_arpeggio_macro+1
00217a 9630                      	adiw Z, 0
00217b f1d9                      	breq sound_driver_instrument_routine_channel0_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
00217c 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
00217d 1fff                      	rol ZH
00217e 91a0 282f                 	lds r26, pulse1_arpeggio_macro_offset
002180 0fea                      	add ZL, r26
002181 1df2                      	adc ZH, zero
                                 
002182 91b0 2831                 	lds r27, pulse1_arpeggio_macro_release
002184 17ba                      	cp r27, r26
002185 f429                      	brne sound_driver_instrument_routine_channel0_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002186 91a0 2830                 	lds r26, pulse1_arpeggio_macro_loop
002188 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002189 f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
00218a c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_increment:
00218b 95a3                      	inc r26 //increment the macro offset
00218c 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_read:
00218e 91b4                      	lpm r27, Z //load arpeggio data into r27
00218f 38b0                      	cpi r27, 0x80 //check for macro end flag
002190 f009                      	breq sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag
002191 c041                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_check_mode:
002192 50a1                      	subi r26, 1 //keep the offset at the end flag
002193 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26
002195 91b0 2832                 	lds r27, pulse1_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002197 30b1                      	cpi r27, 0x01
002198 f048                      	brlo sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_release:
002199 91b0 2831                 	lds r27, pulse1_arpeggio_macro_release
00219b 3fbf                      	cpi r27, 0xFF
00219c f4d1                      	brne sound_driver_instrument_routine_channel0_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_loop:
00219d 91b0 2830                 	lds r27, pulse1_arpeggio_macro_loop
00219f 3fbf                      	cpi r27, 0xFF
0021a0 f499                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
0021a1 c015                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute:
0021a2 91b0 2831                 	lds r27, pulse1_arpeggio_macro_release
0021a4 3fbf                      	cpi r27, 0xFF
0021a5 f421                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_check_loop:
0021a6 91b0 2830                 	lds r27, pulse1_arpeggio_macro_loop //load the loop index
0021a8 3fbf                      	cpi r27, 0xFF //check if loop flag exists
0021a9 f451                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop:
0021aa 91c0 2845                 	lds r28, pulse1_fx_0xy_sequence //check for 0xy effect
0021ac 91d0 2846                 	lds r29, pulse1_fx_0xy_sequence+1
0021ae 9620                      	adiw r29:r28, 0
0021af f469                      	brne sound_driver_instrument_routine_channel0_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
0021b0 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
0021b1 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26 //store the last valid index into the offset
0021b3 cfc2                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload:
0021b4 93b0 282f                 	sts pulse1_arpeggio_macro_offset, r27 //store the loop index into the offset
0021b6 cfbf                      	rjmp sound_driver_instrument_routine_channel0_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_default:
0021b7 91c0 2845                 	lds r28, pulse1_fx_0xy_sequence //load 0xy effect
0021b9 91d0 2846                 	lds r29, pulse1_fx_0xy_sequence+1
0021bb 9620                      	adiw r29:r28, 0 //check for 0xy effect
0021bc f099                      	breq sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel0_arpeggio_default_xy:
0021bd 95d6                      	lsr r29
0021be 95c7                      	ror r28
0021bf 95d7                      	ror r29
0021c0 95c7                      	ror r28
0021c1 95d7                      	ror r29
0021c2 95c7                      	ror r28
0021c3 95d7                      	ror r29
0021c4 95c7                      	ror r28
0021c5 95d7                      	ror r29
0021c6 95d2                      	swap r29
                                 
0021c7 93c0 2845                 	sts pulse1_fx_0xy_sequence, r28 //store the rolled sequence
0021c9 93d0 2846                 	sts pulse1_fx_0xy_sequence+1, r29
0021cb 70cf                      	andi r28, 0x0F //mask out the 4 LSB
0021cc 91a0 2807                 	lds r26, pulse1_note //load the current note index
0021ce 0fac                      	add r26, r28 //add the note offset
0021cf c02e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
0021d0 91a0 2807                 	lds r26, pulse1_note //load the current note index
0021d2 c02b                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process:
0021d3 9220 2833                 	sts pulse1_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
0021d5 9220 2834                 	sts pulse1_total_pitch_offset+1, zero
0021d7 9220 283a                 	sts pulse1_total_hi_pitch_offset, zero
0021d9 91a0 2832                 	lds r26, pulse1_arpeggio_macro_mode
0021db 30a1                      	cpi r26, 0x01 //absolute mode
0021dc f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_absolute
0021dd f069                      	breq sound_driver_instrument_routine_channel0_arpeggio_process_fixed
0021de c00e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute:
0021df 91a0 2807                 	lds r26, pulse1_note //load the current note index
0021e1 0fab                      	add r26, r27 //offset the note with the arpeggio data
0021e2 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0021e3 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_add:
0021e4 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0021e5 f0c0                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
0021e6 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0021e7 c016                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract:
0021e8 fda7                      	sbrc r26, 7 //check if result is negative
0021e9 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0021ea c013                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_fixed:
0021eb 2fab                      	mov r26, r27 //move the arpeggio data into r26
0021ec c011                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative:
0021ed 91a0 2807                 	lds r26, pulse1_note //load the current note index
0021ef 0fab                      	add r26, r27 //offset the note with the arpeggio data
0021f0 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0021f1 c008                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_add:
0021f2 93a0 2807                 	sts pulse1_note, r26 //NOTE: relative mode modifies the original note index
0021f4 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0021f5 f040                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
0021f6 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0021f7 93a0 2807                 	sts pulse1_note, r26
0021f9 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract:
0021fa fda7                      	sbrc r26, 7 //check if result is negative
0021fb e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0021fc 93a0 2807                 	sts pulse1_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_load:
0021fe e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0021ff e0f0                      	ldi ZH, HIGH(note_table << 1)
002200 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002201 0fea                      	add ZL, r26 //add offset
002202 1df2                      	adc ZH, zero
002203 91a5                      	lpm r26, Z+ //load bytes
002204 91b4                      	lpm r27, Z
002205 93a0 0a8c                 	sts TCB0_CCMPL, r26 //load the LOW bits for timer
002207 93b0 0a8d                 	sts TCB0_CCMPH, r27 //load the HIGH bits for timer
002209 93a0 2851                 	sts pulse1_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
00220b 93b0 2852                 	sts pulse1_fx_3xx_target+1, r27
00220d c000                      	rjmp sound_driver_instrument_routine_channel0_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch:
00220e 91e0 2835                 	lds ZL, pulse1_pitch_macro
002210 91f0 2836                 	lds ZH, pulse1_pitch_macro+1
002212 9630                      	adiw Z, 0
002213 f409                      	brne sound_driver_instrument_routine_channel0_pitch_continue
002214 c023                      	rjmp sound_driver_instrument_routine_channel0_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel0_pitch_continue:
002215 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002216 1fff                      	rol ZH
002217 91a0 2837                 	lds r26, pulse1_pitch_macro_offset
002219 0fea                      	add ZL, r26
00221a 1df2                      	adc ZH, zero
                                 
00221b 91b0 2839                 	lds r27, pulse1_pitch_macro_release
00221d 17ba                      	cp r27, r26
00221e f429                      	brne sound_driver_instrument_routine_channel0_pitch_increment //if the current offset is not equal to the release index, increment the offset
00221f 91a0 2838                 	lds r26, pulse1_pitch_macro_loop
002221 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002222 f010                      	brlo sound_driver_instrument_routine_channel0_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002223 c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_pitch_increment:
002224 95a3                      	inc r26 //increment the macro offset
002225 93a0 2837                 	sts pulse1_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_pitch_read:
002227 91b4                      	lpm r27, Z //load pitch data into r27
002228 38b0                      	cpi r27, 0x80 //check for macro end flag
002229 f479                      	brne sound_driver_instrument_routine_channel0_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_release:
00222a 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00222b 93a0 2837                 	sts pulse1_pitch_macro_offset, r26
00222d 91b0 2839                 	lds r27, pulse1_pitch_macro_release
00222f 3fbf                      	cpi r27, 0xFF
002230 f439                      	brne sound_driver_instrument_routine_channel0_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_loop:
002231 91b0 2838                 	lds r27, pulse1_pitch_macro_loop //load the loop index
002233 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002234 f019                      	breq sound_driver_instrument_routine_channel0_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002235 93b0 2837                 	sts pulse1_pitch_macro_offset, r27 //store the loop index into the offset
002237 cfd6                      	rjmp sound_driver_instrument_routine_channel0_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_default:
002238 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel0_pitch_calculate:
002239 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00223a 937f                      	push r23
00223b 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
00223c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00223d 0367                      	mulsu r22, r23
00223e 917f                      	pop r23
00223f 916f                      	pop r22
                                 
002240 9416                      	lsr r1 //shift out the fractional bits
002241 9407                      	ror r0
002242 9416                      	lsr r1
002243 9407                      	ror r0
002244 9416                      	lsr r1
002245 9407                      	ror r0
002246 9416                      	lsr r1
002247 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_check_negative:
002248 fe13                      	sbrs r1, 3 //check if result was a negative number
002249 c007                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_negative:
00224a efc0                      	ldi r28, 0xF0
00224b 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_check_divisible_8:
00224c 70b7                      	andi r27, 0b00000111
00224d f019                      	breq sound_driver_instrument_routine_channel0_pitch_calculate_offset
                                 
00224e e0b1                      	ldi r27, 0x01
00224f 0e0b                      	add r0, r27
002250 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_offset:
002251 91a0 2833                 	lds r26, pulse1_total_pitch_offset
002253 91b0 2834                 	lds r27, pulse1_total_pitch_offset+1
002255 0e0a                      	add r0, r26
002256 1e1b                      	adc r1, r27
002257 9200 2833                 	sts pulse1_total_pitch_offset, r0
002259 9210 2834                 	sts pulse1_total_pitch_offset+1, r1
00225b 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
00225d 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
00225f 0da0                      	add r26, r0 //offset the timer values
002260 1db1                      	adc r27, r1
                                 	
002261 91c0 2849                 	lds r28, pulse1_fx_1xx_total
002263 91d0 284a                 	lds r29, pulse1_fx_1xx_total+1
002265 1bac                      	sub r26, r28
002266 0bbd                      	sbc r27, r29
002267 91c0 284d                 	lds r28, pulse1_fx_2xx_total
002269 91d0 284e                 	lds r29, pulse1_fx_2xx_total+1
00226b 0fac                      	add r26, r28
00226c 1fbd                      	adc r27, r29
00226d 91c0 2861                 	lds r28, pulse1_fx_Pxx_total
00226f 91d0 2862                 	lds r29, pulse1_fx_Pxx_total+1
002271 0fac                      	add r26, r28
002272 1fbd                      	adc r27, r29
002273 91c0 2867                 	lds r28, pulse1_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
002275 91d0 2868                 	lds r29, pulse1_fx_Qxy_total_offset+1
002277 1bac                      	sub r26, r28
002278 0bbd                      	sbc r27, r29
002279 91c0 286d                 	lds r28, pulse1_fx_Rxy_total_offset
00227b 91d0 286e                 	lds r29, pulse1_fx_Rxy_total_offset+1
00227d 0fac                      	add r26, r28
00227e 1fbd                      	adc r27, r29
                                 
00227f 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
002281 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel0_hi_pitch:
002283 91e0 283b                 	lds ZL, pulse1_hi_pitch_macro
002285 91f0 283c                 	lds ZH, pulse1_hi_pitch_macro+1
002287 9630                      	adiw Z, 0
002288 f409                      	brne sound_driver_instrument_routine_channel0_hi_pitch_continue
002289 c03c                      	rjmp sound_driver_instrument_routine_channel0_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel0_hi_pitch_continue:
00228a 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00228b 1fff                      	rol ZH
00228c 91a0 283d                 	lds r26, pulse1_hi_pitch_macro_offset
00228e 0fea                      	add ZL, r26
00228f 1df2                      	adc ZH, zero
                                 
002290 91b0 283f                 	lds r27, pulse1_hi_pitch_macro_release
002292 17ba                      	cp r27, r26
002293 f429                      	brne sound_driver_instrument_routine_channel0_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002294 91a0 283e                 	lds r26, pulse1_hi_pitch_macro_loop
002296 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002297 f010                      	brlo sound_driver_instrument_routine_channel0_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002298 c003                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_increment:
002299 95a3                      	inc r26 //increment the macro offset
00229a 93a0 283d                 	sts pulse1_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_hi_pitch_read:
00229c 91b4                      	lpm r27, Z //load hi pitch data into r27
00229d 38b0                      	cpi r27, 0x80 //check for macro end flag
00229e f489                      	brne sound_driver_instrument_routine_channel0_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_release:
00229f 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0022a0 93a0 283d                 	sts pulse1_hi_pitch_macro_offset, r26
0022a2 91b0 283f                 	lds r27, pulse1_hi_pitch_macro_release
0022a4 3fbf                      	cpi r27, 0xFF
0022a5 f439                      	brne sound_driver_instrument_routine_channel0_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_loop:
0022a6 91b0 283e                 	lds r27, pulse1_hi_pitch_macro_loop //load the loop index
0022a8 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0022a9 f019                      	breq sound_driver_instrument_routine_channel0_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
0022aa 93b0 283d                 	sts pulse1_hi_pitch_macro_offset, r27 //store the loop index into the offset
0022ac cfd6                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_default:
0022ad 91b0 283a                 	lds r27, pulse1_total_hi_pitch_offset
0022af c005                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate:
0022b0 91a0 283a                 	lds r26, pulse1_total_hi_pitch_offset //load the total hi pitch offset to change
0022b2 0fba                      	add r27, r26
0022b3 93b0 283a                 	sts pulse1_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply:
0022b5 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0022b6 937f                      	push r23
0022b7 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
0022b8 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0022b9 0367                      	mulsu r22, r23
0022ba 917f                      	pop r23
0022bb 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_offset:
0022bc 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
0022be 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
0022c0 0da0                      	add r26, r0 //offset the timer values
0022c1 1db1                      	adc r27, r1
0022c2 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
0022c4 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel0_duty:
0022c6 91e0 2840                 	lds ZL, pulse1_duty_macro
0022c8 91f0 2841                 	lds ZH, pulse1_duty_macro+1
0022ca 9630                      	adiw Z, 0
0022cb f1b1                      	breq sound_driver_channel0_fx_routines //if no duty macro is in use, go to the next routine
0022cc 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0022cd 1fff                      	rol ZH
0022ce 91a0 2842                 	lds r26, pulse1_duty_macro_offset
0022d0 0fea                      	add ZL, r26
0022d1 1df2                      	adc ZH, zero
                                 
0022d2 91b0 2844                 	lds r27, pulse1_duty_macro_release
0022d4 17ba                      	cp r27, r26
0022d5 f429                      	brne sound_driver_instrument_routine_channel0_duty_increment //if the current offset is not equal to the release index, increment the offset
0022d6 91a0 2843                 	lds r26, pulse1_duty_macro_loop
0022d8 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0022d9 f010                      	brlo sound_driver_instrument_routine_channel0_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0022da c027                      	rjmp sound_driver_channel0_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel0_duty_increment:
0022db 95a3                      	inc r26 //increment the macro offset
0022dc 93a0 2842                 	sts pulse1_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_duty_read:
0022de 91b4                      	lpm r27, Z //load pitch data into r27
0022df 3fbf                      	cpi r27, 0xFF //check for macro end flag
0022e0 f471                      	brne sound_driver_instrument_routine_channel0_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_release:
0022e1 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0022e2 93a0 2842                 	sts pulse1_duty_macro_offset, r26
0022e4 91b0 2844                 	lds r27, pulse1_duty_macro_release
0022e6 3fbf                      	cpi r27, 0xFF
0022e7 f4d1                      	brne sound_driver_channel0_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_loop:
0022e8 91b0 2843                 	lds r27, pulse1_duty_macro_loop //load the loop index
0022ea 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0022eb f0b1                      	breq sound_driver_channel0_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
0022ec 93b0 2842                 	sts pulse1_duty_macro_offset, r27 //store the loop index into the offset
0022ee cfd7                      	rjmp sound_driver_instrument_routine_channel0_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_load:
0022ef ebe0                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
0022f0 e5fb                      	ldi ZH, HIGH(sequences << 1)
0022f1 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
0022f2 1df2                      	adc ZH, zero
                                 
0022f3 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
0022f4 95b7                      	ror r27
0022f5 95b7                      	ror r27
0022f6 91a0 2800                 	lds r26, pulse1_param //load r26 with pulse1_param (register $4000)
0022f8 2fca                      	mov r28, r26 //store a copy of pulse1_param into r28
0022f9 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
0022fa 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
0022fb c001                      	rjmp sound_driver_instrument_routine_channel0_duty_load_store
0022fc c005                      	rjmp sound_driver_channel0_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel0_duty_load_store:
0022fd 90a4                      	lpm pulse1_sequence, Z //store the sequence
                                 
0022fe 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
0022ff 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
002300 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_routines:
                                 sound_driver_channel0_fx_1xx_routine:
002302 91e0 2847                 	lds ZL, pulse1_fx_1xx
002304 91f0 2848                 	lds ZH, pulse1_fx_1xx+1
002306 9630                      	adiw Z, 0
002307 f051                      	breq sound_driver_channel0_fx_2xx_routine
                                 
002308 91a0 2849                 	lds r26, pulse1_fx_1xx_total //load the rate to change the pitch by
00230a 91b0 284a                 	lds r27, pulse1_fx_1xx_total+1
00230c 0fae                      	add r26, ZL //increase the total offset by the rate
00230d 1fbf                      	adc r27, ZH
00230e 93a0 2849                 	sts pulse1_fx_1xx_total, r26
002310 93b0 284a                 	sts pulse1_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_2xx_routine:
002312 91e0 284b                 	lds ZL, pulse1_fx_2xx
002314 91f0 284c                 	lds ZH, pulse1_fx_2xx+1
002316 9630                      	adiw Z, 0
002317 f051                      	breq sound_driver_channel0_fx_3xx_routine
                                 
002318 91a0 284d                 	lds r26, pulse1_fx_2xx_total //load the rate to change the pitch by
00231a 91b0 284e                 	lds r27, pulse1_fx_2xx_total+1
00231c 0fae                      	add r26, ZL //increase the total offset by the rate
00231d 1fbf                      	adc r27, ZH
00231e 93a0 284d                 	sts pulse1_fx_2xx_total, r26
002320 93b0 284e                 	sts pulse1_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_3xx_routine:
002322 91e0 2853                 	lds ZL, pulse1_fx_3xx_speed
002324 91f0 2854                 	lds ZH, pulse1_fx_3xx_speed+1
002326 9630                      	adiw Z, 0
002327 f409                      	brne sound_driver_channel0_fx_3xx_routine_check_start
002328 c048                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_check_start:
002329 91a0 284f                 	lds r26, pulse1_fx_3xx_start
00232b 91b0 2850                 	lds r27, pulse1_fx_3xx_start+1
00232d 9610                      	adiw r26:r27, 0
00232e f409                      	brne sound_driver_channel0_fx_3xx_routine_main
00232f c041                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_main:
002330 91c0 2851                 	lds r28, pulse1_fx_3xx_target
002332 91d0 2852                 	lds r29, pulse1_fx_3xx_target+1
                                 
002334 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
002335 07bd                      	cpc r27, r29
002336 f011                      	breq sound_driver_channel0_fx_3xx_routine_disable
002337 f030                      	brlo sound_driver_channel0_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002338 c01f                      	rjmp sound_driver_channel0_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel0_fx_3xx_routine_disable:
002339 9220 284f                 	sts pulse1_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
00233b 9220 2850                 	sts pulse1_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
00233d c033                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_subtract:
00233e 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
00233f 0bdb                      	sbc r29, r27
002340 91a0 2855                 	lds r26, pulse1_fx_3xx_total_offset
002342 91b0 2856                 	lds r27, pulse1_fx_3xx_total_offset+1
                                 
002344 0fae                      	add r26, ZL //add the speed to the total offset
002345 1fbf                      	adc r27, ZH
002346 1bca                      	sub r28, r26 //invert the total difference with the total offset
002347 0bdb                      	sbc r29, r27
002348 f380                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002349 93a0 2855                 	sts pulse1_fx_3xx_total_offset, r26 //store the new total offset
00234b 93b0 2856                 	sts pulse1_fx_3xx_total_offset+1, r27
                                 
00234d 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the current timer period
00234f 91b0 0a8d                 	lds r27, TCB0_CCMPH
002351 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002352 0bbd                      	sbc r27, r29
002353 93a0 0a8c                 	sts TCB0_CCMPL, r26
002355 93b0 0a8d                 	sts TCB0_CCMPH, r27
002357 c019                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_add:
002358 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002359 0bbd                      	sbc r27, r29
00235a 91c0 2855                 	lds r28, pulse1_fx_3xx_total_offset
00235c 91d0 2856                 	lds r29, pulse1_fx_3xx_total_offset+1
                                 
00235e 0fce                      	add r28, ZL //add the speed to the total offset
00235f 1fdf                      	adc r29, ZH
002360 1bac                      	sub r26, r28 //invert the total difference with the total offset
002361 0bbd                      	sbc r27, r29
002362 f2b0                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002363 93c0 2855                 	sts pulse1_fx_3xx_total_offset, r28 //store the new total offset
002365 93d0 2856                 	sts pulse1_fx_3xx_total_offset+1, r29
                                 
002367 91c0 0a8c                 	lds r28, TCB0_CCMPL //load the current timer period
002369 91d0 0a8d                 	lds r29, TCB0_CCMPH
00236b 0fca                      	add r28, r26 //offset the current timer period with the total offset
00236c 1fdb                      	adc r29, r27
00236d 93c0 0a8c                 	sts TCB0_CCMPL, r28
00236f 93d0 0a8d                 	sts TCB0_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel0_fx_4xy_routine:
002371 91a0 2857                 	lds r26, pulse1_fx_4xy_speed
002373 15a2                      	cp r26, zero
002374 f409                      	brne sound_driver_channel0_fx_4xy_routine_continue
002375 c05c                      	rjmp sound_driver_channel0_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel0_fx_4xy_routine_continue:
002376 91b0 2858                 	lds r27, pulse1_fx_4xy_depth
002378 91c0 2859                 	lds r28, pulse1_fx_4xy_phase
00237a 0fca                      	add r28, r26 //increase the phase by the speed
00237b 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
00237c f008                      	brlo sound_driver_channel0_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
00237d e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase:
00237e 93c0 2859                 	sts pulse1_fx_4xy_phase, r28 //store the new phase
002380 31c0                      	cpi r28, 16
002381 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_0
002382 32c0                      	cpi r28, 32
002383 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_1
002384 33c0                      	cpi r28, 48
002385 f030                      	brlo sound_driver_channel0_fx_4xy_routine_phase_2
002386 c007                      	rjmp sound_driver_channel0_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_0:
002387 70cf                      	andi r28, 0x0F //mask for values 0-15
002388 c029                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_1:
002389 6fc0                      	ori r28, 0xF0
00238a 95c0                      	com r28 //invert values 0-15
00238b c026                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_2:
00238c 70cf                      	andi r28, 0x0F //mask for values 0-15
00238d c003                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_3:
00238e 6fc0                      	ori r28, 0xF0
00238f 95c0                      	com r28 //invert values 0-15
002390 c000                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_add:
002391 95b2                      	swap r27 //multiply depth by 16
002392 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002393 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002394 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002395 0fec                      	add ZL, r28 //offset the table by the depth+phase
002396 1df2                      	adc ZH, zero
002397 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002398 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002399 937f                      	push r23
00239a 2f6c                      	mov r22, r28 //store the vibrato value into r22
00239b eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00239c 9f67                      	mul r22, r23
00239d 917f                      	pop r23
00239e 916f                      	pop r22
                                 
00239f 9416                      	lsr r1 //shift out the fractional bits
0023a0 9407                      	ror r0
0023a1 9416                      	lsr r1
0023a2 9407                      	ror r0
0023a3 9416                      	lsr r1
0023a4 9407                      	ror r0
0023a5 9416                      	lsr r1
0023a6 9407                      	ror r0
                                 	
0023a7 91a0 0a8c                 	lds r26, TCB0_CCMPL
0023a9 91b0 0a8d                 	lds r27, TCB0_CCMPH
0023ab 0da0                      	add r26, r0
0023ac 1db1                      	adc r27, r1
0023ad 93a0 0a8c                 	sts TCB0_CCMPL, r26
0023af 93b0 0a8d                 	sts TCB0_CCMPH, r27
0023b1 c020                      	rjmp sound_driver_channel0_fx_7xy_routine
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_subtract:
0023b2 95b2                      	swap r27 //multiply depth by 16
0023b3 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
0023b4 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0023b5 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0023b6 0fec                      	add ZL, r28 //offset the table by the depth+phase
0023b7 1df2                      	adc ZH, zero
0023b8 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
0023b9 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0023ba 937f                      	push r23
0023bb 2f6c                      	mov r22, r28 //store the vibrato value into r22
0023bc eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0023bd 9f67                      	mul r22, r23
0023be 917f                      	pop r23
0023bf 916f                      	pop r22
                                 
0023c0 9416                      	lsr r1 //shift out the fractional bits
0023c1 9407                      	ror r0
0023c2 9416                      	lsr r1
0023c3 9407                      	ror r0
0023c4 9416                      	lsr r1
0023c5 9407                      	ror r0
0023c6 9416                      	lsr r1
0023c7 9407                      	ror r0
                                 
0023c8 91a0 0a8c                 	lds r26, TCB0_CCMPL
0023ca 91b0 0a8d                 	lds r27, TCB0_CCMPH
0023cc 19a0                      	sub r26, r0
0023cd 09b1                      	sbc r27, r1
0023ce 93a0 0a8c                 	sts TCB0_CCMPL, r26
0023d0 93b0 0a8d                 	sts TCB0_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_7xy_routine:
0023d2 91a0 285a                 	lds r26, pulse1_fx_7xy_speed
0023d4 15a2                      	cp r26, zero
0023d5 f0e9                      	breq sound_driver_channel0_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
0023d6 91b0 285b                 	lds r27, pulse1_fx_7xy_depth
0023d8 91c0 285c                 	lds r28, pulse1_fx_7xy_phase
0023da 0fca                      	add r28, r26 //increase the phase by the speed
0023db 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
0023dc f008                      	brlo sound_driver_channel0_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
0023dd e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase:
0023de 93c0 285c                 	sts pulse1_fx_7xy_phase, r28 //store the new phase
0023e0 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
0023e1 ffc4                      	sbrs r28, 4
0023e2 c001                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_0
0023e3 c002                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel0_fx_7xy_routine_phase_0:
0023e4 70cf                      	andi r28, 0x0F //mask for values 0-15
0023e5 c003                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase_1:
0023e6 6fc0                      	ori r28, 0xF0
0023e7 95c0                      	com r28 //invert values 0-15
0023e8 c000                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_load:
0023e9 95b2                      	swap r27 //multiply depth by 16
0023ea 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0023eb e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0023ec e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0023ed 0fec                      	add ZL, r28 //offset the table by the depth+phase
0023ee 1df2                      	adc ZH, zero
0023ef 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
0023f0 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
0023f1 93c0 285d                 	sts pulse1_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Axy_routine:
0023f3 91b0 285e                 	lds r27, pulse1_fx_Axy
0023f5 15b2                      	cp r27, zero
0023f6 f0e9                      	breq sound_driver_channel0_fx_Qxy_routine //0 means that the effect is not in use
                                 	
0023f7 91a0 2805                 	lds r26, pulse1_fractional_volume //load fractional volume representation of the channel
0023f9 91c0 2800                 	lds r28, pulse1_param //load the integer volume representation of the channel
0023fb 2fda                      	mov r29, r26 //copy fractional volume into r29
0023fc 2fec                      	mov r30, r28 //copy the pulse1_param into r30
0023fd 95e2                      	swap r30
0023fe 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
0023ff 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
002400 17ed                      	cp r30, r29 //compare the fractional and integer volumes
002401 f009                      	breq sound_driver_channel0_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel0_fx_Axy_routine_reload:
002402 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate:
002403 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
002404 c004                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_addition:
002405 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002406 f428                      	brcc sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002407 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
002408 c003                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_subtraction:
002409 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
00240a f008                      	brcs sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
00240b e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_store:
00240c 93a0 2805                 	sts pulse1_fractional_volume, r26 //store the new fractional volume
00240e 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
00240f 95a2                      	swap r26
002410 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
002411 2bca                      	or r28, r26 //store the new volume back into pulse1_param
002412 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel0_fx_Qxy_routine:
002414 91e0 2863                 	lds ZL, pulse1_fx_Qxy_target
002416 91f0 2864                 	lds ZH, pulse1_fx_Qxy_target+1
002418 9630                      	adiw Z, 0
002419 f139                      	breq sound_driver_channel0_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
00241a 91a0 2867                 	lds r26, pulse1_fx_Qxy_total_offset
00241c 91b0 2868                 	lds r27, pulse1_fx_Qxy_total_offset+1
00241e 91c0 0a8c                 	lds r28, TCB0_CCMPL
002420 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
002422 1bec                      	sub ZL, r28 //calculate the difference to the target
002423 0bfd                      	sbc ZH, r29
002424 f408                      	brsh sound_driver_channel0_fx_Qxy_routine_end //if the target has been reached (or passed)
002425 f088                      	brlo sound_driver_channel0_fx_Qxy_routine_add
                                 
                                 sound_driver_channel0_fx_Qxy_routine_end:
002426 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
002427 0bbf                      	sbc r27, ZH
                                 
002428 91c0 2861                 	lds r28, pulse1_fx_Pxx_total
00242a 91d0 2862                 	lds r29, pulse1_fx_Pxx_total+1
                                 
00242c 0fac                      	add r26, r28
00242d 1fbd                      	adc r27, r29
                                 
00242e 93a0 2867                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
002430 93b0 2868                 	sts pulse1_fx_Qxy_total_offset+1, r27
002432 9220 2863                 	sts pulse1_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
002434 9220 2864                 	sts pulse1_fx_Qxy_target+1, zero
002436 c00a                      	rjmp sound_driver_channel0_fx_Rxy_routine
                                 
                                 sound_driver_channel0_fx_Qxy_routine_add:
002437 91c0 2865                 	lds r28, pulse1_fx_Qxy_speed
002439 91d0 2866                 	lds r29, pulse1_fx_Qxy_speed+1
00243b 0fac                      	add r26, r28 //increase the total offset by the speed
00243c 1fbd                      	adc r27, r29
00243d 93a0 2867                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
00243f 93b0 2868                 	sts pulse1_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Rxy_routine:
002441 91e0 2869                 	lds ZL, pulse1_fx_Rxy_target
002443 91f0 286a                 	lds ZH, pulse1_fx_Rxy_target+1
002445 9630                      	adiw Z, 0
002446 f139                      	breq sound_driver_instrument_routine_channel1_volume //if the effect is not enabled, skip the routine
                                 
002447 91a0 286d                 	lds r26, pulse1_fx_Rxy_total_offset
002449 91b0 286e                 	lds r27, pulse1_fx_Rxy_total_offset+1
00244b 91c0 0a8c                 	lds r28, TCB0_CCMPL
00244d 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
00244f 1bce                      	sub r28, ZL //calculate the difference to the target
002450 0bdf                      	sbc r29, ZH
002451 f408                      	brsh sound_driver_channel0_fx_Rxy_routine_end //if the target has been reached (or passed)
002452 f088                      	brlo sound_driver_channel0_fx_Rxy_routine_add
                                 
                                 sound_driver_channel0_fx_Rxy_routine_end:
002453 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
002454 0bbd                      	sbc r27, r29
                                 
002455 91c0 2861                 	lds r28, pulse1_fx_Pxx_total
002457 91d0 2862                 	lds r29, pulse1_fx_Pxx_total+1
                                 
002459 0fac                      	add r26, r28
00245a 1fbd                      	adc r27, r29
                                 
00245b 93a0 286d                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
00245d 93b0 286e                 	sts pulse1_fx_Rxy_total_offset+1, r27
00245f 9220 2869                 	sts pulse1_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
002461 9220 286a                 	sts pulse1_fx_Rxy_target+1, zero
002463 c00a                      	rjmp sound_driver_instrument_routine_channel1_volume
                                 
                                 sound_driver_channel0_fx_Rxy_routine_add:
002464 91c0 286b                 	lds r28, pulse1_fx_Rxy_speed
002466 91d0 286c                 	lds r29, pulse1_fx_Rxy_speed+1
002468 0fac                      	add r26, r28 //increase the total offset by the speed
002469 1fbd                      	adc r27, r29
00246a 93a0 286d                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
00246c 93b0 286e                 	sts pulse1_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume:
00246e 91e0 2877                 	lds ZL, pulse2_volume_macro
002470 91f0 2878                 	lds ZH, pulse2_volume_macro+1
002472 9630                      	adiw Z, 0
002473 f1a1                      	breq sound_driver_instrument_routine_channel1_volume_default //if no volume macro is in use, use default multiplier of F
002474 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002475 1fff                      	rol ZH
002476 91a0 2879                 	lds r26, pulse2_volume_macro_offset
002478 0fea                      	add ZL, r26
002479 1df2                      	adc ZH, zero
                                 
00247a 91b0 287b                 	lds r27, pulse2_volume_macro_release
00247c 17ba                      	cp r27, r26
00247d f429                      	brne sound_driver_instrument_routine_channel1_volume_increment //if the current offset is not equal to the release index, increment the offset
00247e 91a0 287a                 	lds r26, pulse2_volume_macro_loop
002480 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002481 f010                      	brlo sound_driver_instrument_routine_channel1_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002482 c003                      	rjmp sound_driver_instrument_routine_channel1_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_volume_increment:
002483 95a3                      	inc r26 //increment the macro offset
002484 93a0 2879                 	sts pulse2_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_volume_read:
002486 91b4                      	lpm r27, Z //load volume data into r27
002487 3fbf                      	cpi r27, 0xFF //check for macro end flag
002488 f469                      	brne sound_driver_instrument_routine_channel1_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_release:
002489 91b0 287b                 	lds r27, pulse2_volume_macro_release
00248b 3fbf                      	cpi r27, 0xFF
00248c f429                      	brne sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_loop:
00248d 91b0 287a                 	lds r27, pulse2_volume_macro_loop //load the loop index
00248f 93b0 2879                 	sts pulse2_volume_macro_offset, r27 //store the loop index into the offset
002491 cfdc                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index:
002492 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002493 93a0 2879                 	sts pulse2_volume_macro_offset, r26
002495 cfd8                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_calculate:
002496 e8e4                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
002497 e5fc                      	ldi ZH, HIGH(volumes << 1)
002498 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
002499 0feb                      	add ZL, r27 //add offset to the table
00249a 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel1_volume_load:
00249b 91b0 2808                 	lds r27, pulse2_param //load main volume
00249d 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
00249e 91a0 28ac                 	lds r26, pulse2_fx_7xy_value
0024a0 30a0                      	cpi r26, 0x00
0024a1 f481                      	brne sound_driver_instrument_routine_channel1_volume_load_7xy
                                 
0024a2 0feb                      	add ZL, r27 //offset the volume table by the main volume
0024a3 1df2                      	adc ZH, zero
0024a4 91b4                      	lpm r27, Z
0024a5 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
0024a7 c023                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default:
0024a8 91b0 2808                 	lds r27, pulse2_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
0024aa 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
0024ab 91a0 28ac                 	lds r26, pulse2_fx_7xy_value
0024ad 30a0                      	cpi r26, 0x00
0024ae f499                      	brne sound_driver_instrument_routine_channel1_volume_default_7xy
0024af 93b0 280e                 	sts pulse2_output_volume, r27
0024b1 c019                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy:
0024b2 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
0024b3 f038                      	brcs sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
0024b4 f031                      	breq sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
                                 
0024b5 0feb                      	add ZL, r27 //offset the volume table by the main volume
0024b6 1df2                      	adc ZH, zero
0024b7 91b4                      	lpm r27, Z
0024b8 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
0024ba c010                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy_overflow:
0024bb e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
0024bc 0feb                      	add ZL, r27 //offset the volume table by the main volume
0024bd 1df2                      	adc ZH, zero
0024be 91b4                      	lpm r27, Z
0024bf 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
0024c1 c009                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default_7xy:
0024c2 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
0024c3 f020                      	brcs sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
0024c4 f019                      	breq sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
0024c5 93b0 280e                 	sts pulse2_output_volume, r27
0024c7 c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel1_volume_default_7xy_overflow:
0024c8 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
0024c9 93b0 280e                 	sts pulse2_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
0024cb 91e0 287c                 	lds ZL, pulse2_arpeggio_macro
0024cd 91f0 287d                 	lds ZH, pulse2_arpeggio_macro+1
0024cf 9630                      	adiw Z, 0
0024d0 f1d9                      	breq sound_driver_instrument_routine_channel1_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
0024d1 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0024d2 1fff                      	rol ZH
0024d3 91a0 287e                 	lds r26, pulse2_arpeggio_macro_offset
0024d5 0fea                      	add ZL, r26
0024d6 1df2                      	adc ZH, zero
                                 
0024d7 91b0 2880                 	lds r27, pulse2_arpeggio_macro_release
0024d9 17ba                      	cp r27, r26
0024da f429                      	brne sound_driver_instrument_routine_channel1_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
0024db 91a0 287f                 	lds r26, pulse2_arpeggio_macro_loop
0024dd 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0024de f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
0024df c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_increment:
0024e0 95a3                      	inc r26 //increment the macro offset
0024e1 93a0 287e                 	sts pulse2_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_read:
0024e3 91b4                      	lpm r27, Z //load arpeggio data into r27
0024e4 38b0                      	cpi r27, 0x80 //check for macro end flag
0024e5 f009                      	breq sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag
0024e6 c041                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_check_mode:
0024e7 50a1                      	subi r26, 1 //keep the offset at the end flag
0024e8 93a0 287e                 	sts pulse2_arpeggio_macro_offset, r26
0024ea 91b0 2881                 	lds r27, pulse2_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
0024ec 30b1                      	cpi r27, 0x01
0024ed f048                      	brlo sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_release:
0024ee 91b0 2880                 	lds r27, pulse2_arpeggio_macro_release
0024f0 3fbf                      	cpi r27, 0xFF
0024f1 f4d1                      	brne sound_driver_instrument_routine_channel1_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_loop:
0024f2 91b0 287f                 	lds r27, pulse2_arpeggio_macro_loop
0024f4 3fbf                      	cpi r27, 0xFF
0024f5 f499                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
0024f6 c015                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute:
0024f7 91b0 2880                 	lds r27, pulse2_arpeggio_macro_release
0024f9 3fbf                      	cpi r27, 0xFF
0024fa f421                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_check_loop:
0024fb 91b0 287f                 	lds r27, pulse2_arpeggio_macro_loop //load the loop index
0024fd 3fbf                      	cpi r27, 0xFF //check if loop flag exists
0024fe f451                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop:
0024ff 91c0 2894                 	lds r28, pulse2_fx_0xy_sequence //check for 0xy effect
002501 91d0 2895                 	lds r29, pulse2_fx_0xy_sequence+1
002503 9620                      	adiw r29:r28, 0
002504 f469                      	brne sound_driver_instrument_routine_channel1_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002505 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002506 93a0 287e                 	sts pulse2_arpeggio_macro_offset, r26 //store the last valid index into the offset
002508 cfc2                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload:
002509 93b0 287e                 	sts pulse2_arpeggio_macro_offset, r27 //store the loop index into the offset
00250b cfbf                      	rjmp sound_driver_instrument_routine_channel1_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_default:
00250c 91c0 2894                 	lds r28, pulse2_fx_0xy_sequence //load 0xy effect
00250e 91d0 2895                 	lds r29, pulse2_fx_0xy_sequence+1
002510 9620                      	adiw r29:r28, 0 //check for 0xy effect
002511 f099                      	breq sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel1_arpeggio_default_xy:
002512 95d6                      	lsr r29
002513 95c7                      	ror r28
002514 95d7                      	ror r29
002515 95c7                      	ror r28
002516 95d7                      	ror r29
002517 95c7                      	ror r28
002518 95d7                      	ror r29
002519 95c7                      	ror r28
00251a 95d7                      	ror r29
00251b 95d2                      	swap r29
                                 
00251c 93c0 2894                 	sts pulse2_fx_0xy_sequence, r28 //store the rolled sequence
00251e 93d0 2895                 	sts pulse2_fx_0xy_sequence+1, r29
002520 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002521 91a0 280f                 	lds r26, pulse2_note //load the current note index
002523 0fac                      	add r26, r28 //add the note offset
002524 c02e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002525 91a0 280f                 	lds r26, pulse2_note //load the current note index
002527 c02b                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process:
002528 9220 2882                 	sts pulse2_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
00252a 9220 2883                 	sts pulse2_total_pitch_offset+1, zero
00252c 9220 2889                 	sts pulse2_total_hi_pitch_offset, zero
00252e 91a0 2881                 	lds r26, pulse2_arpeggio_macro_mode
002530 30a1                      	cpi r26, 0x01 //absolute mode
002531 f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_absolute
002532 f069                      	breq sound_driver_instrument_routine_channel1_arpeggio_process_fixed
002533 c00e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute:
002534 91a0 280f                 	lds r26, pulse2_note //load the current note index
002536 0fab                      	add r26, r27 //offset the note with the arpeggio data
002537 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002538 c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_add:
002539 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
00253a f0c0                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
00253b e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
00253c c016                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract:
00253d fda7                      	sbrc r26, 7 //check if result is negative
00253e e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
00253f c013                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_fixed:
002540 2fab                      	mov r26, r27 //move the arpeggio data into r26
002541 c011                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative:
002542 91a0 280f                 	lds r26, pulse2_note //load the current note index
002544 0fab                      	add r26, r27 //offset the note with the arpeggio data
002545 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002546 c008                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_add:
002547 93a0 280f                 	sts pulse2_note, r26 //NOTE: relative mode modifies the original note index
002549 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
00254a f040                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
00254b e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
00254c 93a0 280f                 	sts pulse2_note, r26
00254e c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract:
00254f fda7                      	sbrc r26, 7 //check if result is negative
002550 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002551 93a0 280f                 	sts pulse2_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_load:
002553 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
002554 e0f0                      	ldi ZH, HIGH(note_table << 1)
002555 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002556 0fea                      	add ZL, r26 //add offset
002557 1df2                      	adc ZH, zero
002558 91a5                      	lpm r26, Z+ //load bytes
002559 91b4                      	lpm r27, Z
00255a 93a0 0a9c                 	sts TCB1_CCMPL, r26 //load the LOW bits for timer
00255c 93b0 0a9d                 	sts TCB1_CCMPH, r27 //load the HIGH bits for timer
00255e 93a0 28a0                 	sts pulse2_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002560 93b0 28a1                 	sts pulse2_fx_3xx_target+1, r27
002562 c000                      	rjmp sound_driver_instrument_routine_channel1_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch:
002563 91e0 2884                 	lds ZL, pulse2_pitch_macro
002565 91f0 2885                 	lds ZH, pulse2_pitch_macro+1
002567 9630                      	adiw Z, 0
002568 f409                      	brne sound_driver_instrument_routine_channel1_pitch_continue
002569 c023                      	rjmp sound_driver_instrument_routine_channel1_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel1_pitch_continue:
00256a 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00256b 1fff                      	rol ZH
00256c 91a0 2886                 	lds r26, pulse2_pitch_macro_offset
00256e 0fea                      	add ZL, r26
00256f 1df2                      	adc ZH, zero
                                 
002570 91b0 2888                 	lds r27, pulse2_pitch_macro_release
002572 17ba                      	cp r27, r26
002573 f429                      	brne sound_driver_instrument_routine_channel1_pitch_increment //if the current offset is not equal to the release index, increment the offset
002574 91a0 2887                 	lds r26, pulse2_pitch_macro_loop
002576 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002577 f010                      	brlo sound_driver_instrument_routine_channel1_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002578 c003                      	rjmp sound_driver_instrument_routine_channel1_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_pitch_increment:
002579 95a3                      	inc r26 //increment the macro offset
00257a 93a0 2886                 	sts pulse2_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_pitch_read:
00257c 91b4                      	lpm r27, Z //load pitch data into r27
00257d 38b0                      	cpi r27, 0x80 //check for macro end flag
00257e f479                      	brne sound_driver_instrument_routine_channel1_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_release:
00257f 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002580 93a0 2886                 	sts pulse2_pitch_macro_offset, r26
002582 91b0 2888                 	lds r27, pulse2_pitch_macro_release
002584 3fbf                      	cpi r27, 0xFF
002585 f439                      	brne sound_driver_instrument_routine_channel1_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_loop:
002586 91b0 2887                 	lds r27, pulse2_pitch_macro_loop //load the loop index
002588 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002589 f019                      	breq sound_driver_instrument_routine_channel1_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
00258a 93b0 2886                 	sts pulse2_pitch_macro_offset, r27 //store the loop index into the offset
00258c cfd6                      	rjmp sound_driver_instrument_routine_channel1_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_default:
00258d e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel1_pitch_calculate:
00258e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00258f 937f                      	push r23
002590 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
002591 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002592 0367                      	mulsu r22, r23
002593 917f                      	pop r23
002594 916f                      	pop r22
                                 
002595 9416                      	lsr r1 //shift out the fractional bits
002596 9407                      	ror r0
002597 9416                      	lsr r1
002598 9407                      	ror r0
002599 9416                      	lsr r1
00259a 9407                      	ror r0
00259b 9416                      	lsr r1
00259c 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_check_negative:
00259d fe13                      	sbrs r1, 3 //check if result was a negative number
00259e c007                      	rjmp sound_driver_instrument_routine_channel1_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_negative:
00259f efc0                      	ldi r28, 0xF0
0025a0 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_check_divisible_8:
0025a1 70b7                      	andi r27, 0b00000111
0025a2 f019                      	breq sound_driver_instrument_routine_channel1_pitch_calculate_offset
                                 
0025a3 e0b1                      	ldi r27, 0x01
0025a4 0e0b                      	add r0, r27
0025a5 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_offset:
0025a6 91a0 2882                 	lds r26, pulse2_total_pitch_offset
0025a8 91b0 2883                 	lds r27, pulse2_total_pitch_offset+1
0025aa 0e0a                      	add r0, r26
0025ab 1e1b                      	adc r1, r27
0025ac 9200 2882                 	sts pulse2_total_pitch_offset, r0
0025ae 9210 2883                 	sts pulse2_total_pitch_offset+1, r1
0025b0 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
0025b2 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
0025b4 0da0                      	add r26, r0 //offset the timer values
0025b5 1db1                      	adc r27, r1
                                 	
0025b6 91c0 2898                 	lds r28, pulse2_fx_1xx_total
0025b8 91d0 2899                 	lds r29, pulse2_fx_1xx_total+1
0025ba 1bac                      	sub r26, r28
0025bb 0bbd                      	sbc r27, r29
0025bc 91c0 289c                 	lds r28, pulse2_fx_2xx_total
0025be 91d0 289d                 	lds r29, pulse2_fx_2xx_total+1
0025c0 0fac                      	add r26, r28
0025c1 1fbd                      	adc r27, r29
0025c2 91c0 28b0                 	lds r28, pulse2_fx_Pxx_total
0025c4 91d0 28b1                 	lds r29, pulse2_fx_Pxx_total+1
0025c6 0fac                      	add r26, r28
0025c7 1fbd                      	adc r27, r29
0025c8 91c0 28b6                 	lds r28, pulse2_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
0025ca 91d0 28b7                 	lds r29, pulse2_fx_Qxy_total_offset+1
0025cc 1bac                      	sub r26, r28
0025cd 0bbd                      	sbc r27, r29
0025ce 91c0 28bc                 	lds r28, pulse2_fx_Rxy_total_offset
0025d0 91d0 28bd                 	lds r29, pulse2_fx_Rxy_total_offset+1
0025d2 0fac                      	add r26, r28
0025d3 1fbd                      	adc r27, r29
                                 
0025d4 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
0025d6 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel1_hi_pitch:
0025d8 91e0 288a                 	lds ZL, pulse2_hi_pitch_macro
0025da 91f0 288b                 	lds ZH, pulse2_hi_pitch_macro+1
0025dc 9630                      	adiw Z, 0
0025dd f409                      	brne sound_driver_instrument_routine_channel1_hi_pitch_continue
0025de c03c                      	rjmp sound_driver_instrument_routine_channel1_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel1_hi_pitch_continue:
0025df 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0025e0 1fff                      	rol ZH
0025e1 91a0 288c                 	lds r26, pulse2_hi_pitch_macro_offset
0025e3 0fea                      	add ZL, r26
0025e4 1df2                      	adc ZH, zero
                                 
0025e5 91b0 288e                 	lds r27, pulse2_hi_pitch_macro_release
0025e7 17ba                      	cp r27, r26
0025e8 f429                      	brne sound_driver_instrument_routine_channel1_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
0025e9 91a0 288d                 	lds r26, pulse2_hi_pitch_macro_loop
0025eb 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0025ec f010                      	brlo sound_driver_instrument_routine_channel1_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0025ed c003                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_increment:
0025ee 95a3                      	inc r26 //increment the macro offset
0025ef 93a0 288c                 	sts pulse2_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_hi_pitch_read:
0025f1 91b4                      	lpm r27, Z //load hi pitch data into r27
0025f2 38b0                      	cpi r27, 0x80 //check for macro end flag
0025f3 f489                      	brne sound_driver_instrument_routine_channel1_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_release:
0025f4 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0025f5 93a0 288c                 	sts pulse2_hi_pitch_macro_offset, r26
0025f7 91b0 288e                 	lds r27, pulse2_hi_pitch_macro_release
0025f9 3fbf                      	cpi r27, 0xFF
0025fa f439                      	brne sound_driver_instrument_routine_channel1_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_loop:
0025fb 91b0 288d                 	lds r27, pulse2_hi_pitch_macro_loop //load the loop index
0025fd 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0025fe f019                      	breq sound_driver_instrument_routine_channel1_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
0025ff 93b0 288c                 	sts pulse2_hi_pitch_macro_offset, r27 //store the loop index into the offset
002601 cfd6                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_default:
002602 91b0 2889                 	lds r27, pulse2_total_hi_pitch_offset
002604 c005                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate:
002605 91a0 2889                 	lds r26, pulse2_total_hi_pitch_offset //load the total hi pitch offset to change
002607 0fba                      	add r27, r26
002608 93b0 2889                 	sts pulse2_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply:
00260a 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00260b 937f                      	push r23
00260c 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
00260d eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00260e 0367                      	mulsu r22, r23
00260f 917f                      	pop r23
002610 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_offset:
002611 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
002613 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
002615 0da0                      	add r26, r0 //offset the timer values
002616 1db1                      	adc r27, r1
002617 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
002619 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel1_duty:
00261b 91e0 288f                 	lds ZL, pulse2_duty_macro
00261d 91f0 2890                 	lds ZH, pulse2_duty_macro+1
00261f 9630                      	adiw Z, 0
002620 f1b1                      	breq sound_driver_channel1_fx_routines //if no duty macro is in use, go to the next routine
002621 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002622 1fff                      	rol ZH
002623 91a0 2891                 	lds r26, pulse2_duty_macro_offset
002625 0fea                      	add ZL, r26
002626 1df2                      	adc ZH, zero
                                 
002627 91b0 2893                 	lds r27, pulse2_duty_macro_release
002629 17ba                      	cp r27, r26
00262a f429                      	brne sound_driver_instrument_routine_channel1_duty_increment //if the current offset is not equal to the release index, increment the offset
00262b 91a0 2892                 	lds r26, pulse2_duty_macro_loop
00262d 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00262e f010                      	brlo sound_driver_instrument_routine_channel1_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00262f c027                      	rjmp sound_driver_channel1_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel1_duty_increment:
002630 95a3                      	inc r26 //increment the macro offset
002631 93a0 2891                 	sts pulse2_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_duty_read:
002633 91b4                      	lpm r27, Z //load pitch data into r27
002634 3fbf                      	cpi r27, 0xFF //check for macro end flag
002635 f471                      	brne sound_driver_instrument_routine_channel1_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_release:
002636 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002637 93a0 2891                 	sts pulse2_duty_macro_offset, r26
002639 91b0 2893                 	lds r27, pulse2_duty_macro_release
00263b 3fbf                      	cpi r27, 0xFF
00263c f4d1                      	brne sound_driver_channel1_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_loop:
00263d 91b0 2892                 	lds r27, pulse2_duty_macro_loop //load the loop index
00263f 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002640 f0b1                      	breq sound_driver_channel1_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
002641 93b0 2891                 	sts pulse2_duty_macro_offset, r27 //store the loop index into the offset
002643 cfd7                      	rjmp sound_driver_instrument_routine_channel1_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_load:
002644 ebe0                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
002645 e5fb                      	ldi ZH, HIGH(sequences << 1)
002646 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
002647 1df2                      	adc ZH, zero
                                 
002648 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
002649 95b7                      	ror r27
00264a 95b7                      	ror r27
00264b 91a0 2808                 	lds r26, pulse2_param //load r26 with pulse2_param (register $4000)
00264d 2fca                      	mov r28, r26 //store a copy of pulse2_param into r28
00264e 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
00264f 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
002650 c001                      	rjmp sound_driver_instrument_routine_channel1_duty_load_store
002651 c005                      	rjmp sound_driver_channel1_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel1_duty_load_store:
002652 90d4                      	lpm pulse2_sequence, Z //store the sequence
                                 
002653 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
002654 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
002655 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_routines:
                                 sound_driver_channel1_fx_1xx_routine:
002657 91e0 2896                 	lds ZL, pulse2_fx_1xx
002659 91f0 2897                 	lds ZH, pulse2_fx_1xx+1
00265b 9630                      	adiw Z, 0
00265c f051                      	breq sound_driver_channel1_fx_2xx_routine
                                 
00265d 91a0 2898                 	lds r26, pulse2_fx_1xx_total //load the rate to change the pitch by
00265f 91b0 2899                 	lds r27, pulse2_fx_1xx_total+1
002661 0fae                      	add r26, ZL //increase the total offset by the rate
002662 1fbf                      	adc r27, ZH
002663 93a0 2898                 	sts pulse2_fx_1xx_total, r26
002665 93b0 2899                 	sts pulse2_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_2xx_routine:
002667 91e0 289a                 	lds ZL, pulse2_fx_2xx
002669 91f0 289b                 	lds ZH, pulse2_fx_2xx+1
00266b 9630                      	adiw Z, 0
00266c f051                      	breq sound_driver_channel1_fx_3xx_routine
                                 
00266d 91a0 289c                 	lds r26, pulse2_fx_2xx_total //load the rate to change the pitch by
00266f 91b0 289d                 	lds r27, pulse2_fx_2xx_total+1
002671 0fae                      	add r26, ZL //increase the total offset by the rate
002672 1fbf                      	adc r27, ZH
002673 93a0 289c                 	sts pulse2_fx_2xx_total, r26
002675 93b0 289d                 	sts pulse2_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_3xx_routine:
002677 91e0 28a2                 	lds ZL, pulse2_fx_3xx_speed
002679 91f0 28a3                 	lds ZH, pulse2_fx_3xx_speed+1
00267b 9630                      	adiw Z, 0
00267c f409                      	brne sound_driver_channel1_fx_3xx_routine_check_start
00267d c048                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_check_start:
00267e 91a0 289e                 	lds r26, pulse2_fx_3xx_start
002680 91b0 289f                 	lds r27, pulse2_fx_3xx_start+1
002682 9610                      	adiw r26:r27, 0
002683 f409                      	brne sound_driver_channel1_fx_3xx_routine_main
002684 c041                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_main:
002685 91c0 28a0                 	lds r28, pulse2_fx_3xx_target
002687 91d0 28a1                 	lds r29, pulse2_fx_3xx_target+1
                                 
002689 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
00268a 07bd                      	cpc r27, r29
00268b f011                      	breq sound_driver_channel1_fx_3xx_routine_disable
00268c f030                      	brlo sound_driver_channel1_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
00268d c01f                      	rjmp sound_driver_channel1_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel1_fx_3xx_routine_disable:
00268e 9220 289e                 	sts pulse2_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002690 9220 289f                 	sts pulse2_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002692 c033                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_subtract:
002693 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002694 0bdb                      	sbc r29, r27
002695 91a0 28a4                 	lds r26, pulse2_fx_3xx_total_offset
002697 91b0 28a5                 	lds r27, pulse2_fx_3xx_total_offset+1
                                 
002699 0fae                      	add r26, ZL //add the speed to the total offset
00269a 1fbf                      	adc r27, ZH
00269b 1bca                      	sub r28, r26 //invert the total difference with the total offset
00269c 0bdb                      	sbc r29, r27
00269d f380                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
00269e 93a0 28a4                 	sts pulse2_fx_3xx_total_offset, r26 //store the new total offset
0026a0 93b0 28a5                 	sts pulse2_fx_3xx_total_offset+1, r27
                                 
0026a2 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the current timer period
0026a4 91b0 0a9d                 	lds r27, TCB1_CCMPH
0026a6 1bac                      	sub r26, r28 //offset the current timer period with the total offset
0026a7 0bbd                      	sbc r27, r29
0026a8 93a0 0a9c                 	sts TCB1_CCMPL, r26
0026aa 93b0 0a9d                 	sts TCB1_CCMPH, r27
0026ac c019                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_add:
0026ad 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
0026ae 0bbd                      	sbc r27, r29
0026af 91c0 28a4                 	lds r28, pulse2_fx_3xx_total_offset
0026b1 91d0 28a5                 	lds r29, pulse2_fx_3xx_total_offset+1
                                 
0026b3 0fce                      	add r28, ZL //add the speed to the total offset
0026b4 1fdf                      	adc r29, ZH
0026b5 1bac                      	sub r26, r28 //invert the total difference with the total offset
0026b6 0bbd                      	sbc r27, r29
0026b7 f2b0                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0026b8 93c0 28a4                 	sts pulse2_fx_3xx_total_offset, r28 //store the new total offset
0026ba 93d0 28a5                 	sts pulse2_fx_3xx_total_offset+1, r29
                                 
0026bc 91c0 0a9c                 	lds r28, TCB1_CCMPL //load the current timer period
0026be 91d0 0a9d                 	lds r29, TCB1_CCMPH
0026c0 0fca                      	add r28, r26 //offset the current timer period with the total offset
0026c1 1fdb                      	adc r29, r27
0026c2 93c0 0a9c                 	sts TCB1_CCMPL, r28
0026c4 93d0 0a9d                 	sts TCB1_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel1_fx_4xy_routine:
0026c6 91a0 28a6                 	lds r26, pulse2_fx_4xy_speed
0026c8 15a2                      	cp r26, zero
0026c9 f409                      	brne sound_driver_channel1_fx_4xy_routine_continue
0026ca c05c                      	rjmp sound_driver_channel1_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel1_fx_4xy_routine_continue:
0026cb 91b0 28a7                 	lds r27, pulse2_fx_4xy_depth
0026cd 91c0 28a8                 	lds r28, pulse2_fx_4xy_phase
0026cf 0fca                      	add r28, r26 //increase the phase by the speed
0026d0 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
0026d1 f008                      	brlo sound_driver_channel1_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
0026d2 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase:
0026d3 93c0 28a8                 	sts pulse2_fx_4xy_phase, r28 //store the new phase
0026d5 31c0                      	cpi r28, 16
0026d6 f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_0
0026d7 32c0                      	cpi r28, 32
0026d8 f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_1
0026d9 33c0                      	cpi r28, 48
0026da f030                      	brlo sound_driver_channel1_fx_4xy_routine_phase_2
0026db c007                      	rjmp sound_driver_channel1_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_0:
0026dc 70cf                      	andi r28, 0x0F //mask for values 0-15
0026dd c029                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_1:
0026de 6fc0                      	ori r28, 0xF0
0026df 95c0                      	com r28 //invert values 0-15
0026e0 c026                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_2:
0026e1 70cf                      	andi r28, 0x0F //mask for values 0-15
0026e2 c003                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_3:
0026e3 6fc0                      	ori r28, 0xF0
0026e4 95c0                      	com r28 //invert values 0-15
0026e5 c000                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_add:
0026e6 95b2                      	swap r27 //multiply depth by 16
0026e7 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0026e8 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0026e9 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0026ea 0fec                      	add ZL, r28 //offset the table by the depth+phase
0026eb 1df2                      	adc ZH, zero
0026ec 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
0026ed 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0026ee 937f                      	push r23
0026ef 2f6c                      	mov r22, r28 //store the vibrato value into r22
0026f0 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0026f1 9f67                      	mul r22, r23
0026f2 917f                      	pop r23
0026f3 916f                      	pop r22
                                 
0026f4 9416                      	lsr r1 //shift out the fractional bits
0026f5 9407                      	ror r0
0026f6 9416                      	lsr r1
0026f7 9407                      	ror r0
0026f8 9416                      	lsr r1
0026f9 9407                      	ror r0
0026fa 9416                      	lsr r1
0026fb 9407                      	ror r0
                                 	
0026fc 91a0 0a9c                 	lds r26, TCB1_CCMPL
0026fe 91b0 0a9d                 	lds r27, TCB1_CCMPH
002700 0da0                      	add r26, r0
002701 1db1                      	adc r27, r1
002702 93a0 0a9c                 	sts TCB1_CCMPL, r26
002704 93b0 0a9d                 	sts TCB1_CCMPH, r27
002706 c020                      	rjmp sound_driver_channel1_fx_7xy_routine
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_subtract:
002707 95b2                      	swap r27 //multiply depth by 16
002708 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002709 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00270a e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00270b 0fec                      	add ZL, r28 //offset the table by the depth+phase
00270c 1df2                      	adc ZH, zero
00270d 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
00270e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00270f 937f                      	push r23
002710 2f6c                      	mov r22, r28 //store the vibrato value into r22
002711 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002712 9f67                      	mul r22, r23
002713 917f                      	pop r23
002714 916f                      	pop r22
                                 
002715 9416                      	lsr r1 //shift out the fractional bits
002716 9407                      	ror r0
002717 9416                      	lsr r1
002718 9407                      	ror r0
002719 9416                      	lsr r1
00271a 9407                      	ror r0
00271b 9416                      	lsr r1
00271c 9407                      	ror r0
                                 
00271d 91a0 0a9c                 	lds r26, TCB1_CCMPL
00271f 91b0 0a9d                 	lds r27, TCB1_CCMPH
002721 19a0                      	sub r26, r0
002722 09b1                      	sbc r27, r1
002723 93a0 0a9c                 	sts TCB1_CCMPL, r26
002725 93b0 0a9d                 	sts TCB1_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_7xy_routine:
002727 91a0 28a9                 	lds r26, pulse2_fx_7xy_speed
002729 15a2                      	cp r26, zero
00272a f0e9                      	breq sound_driver_channel1_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
00272b 91b0 28aa                 	lds r27, pulse2_fx_7xy_depth
00272d 91c0 28ab                 	lds r28, pulse2_fx_7xy_phase
00272f 0fca                      	add r28, r26 //increase the phase by the speed
002730 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002731 f008                      	brlo sound_driver_channel1_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
002732 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase:
002733 93c0 28ab                 	sts pulse2_fx_7xy_phase, r28 //store the new phase
002735 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
002736 ffc4                      	sbrs r28, 4
002737 c001                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_0
002738 c002                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel1_fx_7xy_routine_phase_0:
002739 70cf                      	andi r28, 0x0F //mask for values 0-15
00273a c003                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase_1:
00273b 6fc0                      	ori r28, 0xF0
00273c 95c0                      	com r28 //invert values 0-15
00273d c000                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_load:
00273e 95b2                      	swap r27 //multiply depth by 16
00273f 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002740 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002741 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002742 0fec                      	add ZL, r28 //offset the table by the depth+phase
002743 1df2                      	adc ZH, zero
002744 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002745 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
002746 93c0 28ac                 	sts pulse2_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Axy_routine:
002748 91b0 28ad                 	lds r27, pulse2_fx_Axy
00274a 15b2                      	cp r27, zero
00274b f0e9                      	breq sound_driver_channel1_fx_Qxy_routine //0 means that the effect is not in use
                                 	
00274c 91a0 280d                 	lds r26, pulse2_fractional_volume //load fractional volume representation of the channel
00274e 91c0 2808                 	lds r28, pulse2_param //load the integer volume representation of the channel
002750 2fda                      	mov r29, r26 //copy fractional volume into r29
002751 2fec                      	mov r30, r28 //copy the pulse2_param into r30
002752 95e2                      	swap r30
002753 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
002754 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
002755 17ed                      	cp r30, r29 //compare the fractional and integer volumes
002756 f009                      	breq sound_driver_channel1_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel1_fx_Axy_routine_reload:
002757 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate:
002758 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
002759 c004                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_addition:
00275a 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
00275b f428                      	brcc sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
00275c efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
00275d c003                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_subtraction:
00275e 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
00275f f008                      	brcs sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002760 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_store:
002761 93a0 280d                 	sts pulse2_fractional_volume, r26 //store the new fractional volume
002763 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
002764 95a2                      	swap r26
002765 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
002766 2bca                      	or r28, r26 //store the new volume back into pulse2_param
002767 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel1_fx_Qxy_routine:
002769 91e0 28b2                 	lds ZL, pulse2_fx_Qxy_target
00276b 91f0 28b3                 	lds ZH, pulse2_fx_Qxy_target+1
00276d 9630                      	adiw Z, 0
00276e f139                      	breq sound_driver_channel1_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
00276f 91a0 28b6                 	lds r26, pulse2_fx_Qxy_total_offset
002771 91b0 28b7                 	lds r27, pulse2_fx_Qxy_total_offset+1
002773 91c0 0a9c                 	lds r28, TCB1_CCMPL
002775 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
002777 1bec                      	sub ZL, r28 //calculate the difference to the target
002778 0bfd                      	sbc ZH, r29
002779 f408                      	brsh sound_driver_channel1_fx_Qxy_routine_end //if the target has been reached (or passed)
00277a f088                      	brlo sound_driver_channel1_fx_Qxy_routine_add
                                 
                                 sound_driver_channel1_fx_Qxy_routine_end:
00277b 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
00277c 0bbf                      	sbc r27, ZH
                                 
00277d 91c0 28b0                 	lds r28, pulse2_fx_Pxx_total
00277f 91d0 28b1                 	lds r29, pulse2_fx_Pxx_total+1
                                 
002781 0fac                      	add r26, r28
002782 1fbd                      	adc r27, r29
                                 
002783 93a0 28b6                 	sts pulse2_fx_Qxy_total_offset, r26 //store the total offset
002785 93b0 28b7                 	sts pulse2_fx_Qxy_total_offset+1, r27
002787 9220 28b2                 	sts pulse2_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
002789 9220 28b3                 	sts pulse2_fx_Qxy_target+1, zero
00278b c00a                      	rjmp sound_driver_channel1_fx_Rxy_routine
                                 
                                 sound_driver_channel1_fx_Qxy_routine_add:
00278c 91c0 28b4                 	lds r28, pulse2_fx_Qxy_speed
00278e 91d0 28b5                 	lds r29, pulse2_fx_Qxy_speed+1
002790 0fac                      	add r26, r28 //increase the total offset by the speed
002791 1fbd                      	adc r27, r29
002792 93a0 28b6                 	sts pulse2_fx_Qxy_total_offset, r26 //store the total offset
002794 93b0 28b7                 	sts pulse2_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Rxy_routine:
002796 91e0 28b8                 	lds ZL, pulse2_fx_Rxy_target
002798 91f0 28b9                 	lds ZH, pulse2_fx_Rxy_target+1
00279a 9630                      	adiw Z, 0
00279b f139                      	breq sound_driver_instrument_routine_channel2_volume //if the effect is not enabled, skip the routine
                                 
00279c 91a0 28bc                 	lds r26, pulse2_fx_Rxy_total_offset
00279e 91b0 28bd                 	lds r27, pulse2_fx_Rxy_total_offset+1
0027a0 91c0 0a9c                 	lds r28, TCB1_CCMPL
0027a2 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
0027a4 1bce                      	sub r28, ZL //calculate the difference to the target
0027a5 0bdf                      	sbc r29, ZH
0027a6 f408                      	brsh sound_driver_channel1_fx_Rxy_routine_end //if the target has been reached (or passed)
0027a7 f088                      	brlo sound_driver_channel1_fx_Rxy_routine_add
                                 
                                 sound_driver_channel1_fx_Rxy_routine_end:
0027a8 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
0027a9 0bbd                      	sbc r27, r29
                                 
0027aa 91c0 28b0                 	lds r28, pulse2_fx_Pxx_total
0027ac 91d0 28b1                 	lds r29, pulse2_fx_Pxx_total+1
                                 
0027ae 0fac                      	add r26, r28
0027af 1fbd                      	adc r27, r29
                                 
0027b0 93a0 28bc                 	sts pulse2_fx_Rxy_total_offset, r26 //store the total offset
0027b2 93b0 28bd                 	sts pulse2_fx_Rxy_total_offset+1, r27
0027b4 9220 28b8                 	sts pulse2_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
0027b6 9220 28b9                 	sts pulse2_fx_Rxy_target+1, zero
0027b8 c00a                      	rjmp sound_driver_instrument_routine_channel2_volume
                                 
                                 sound_driver_channel1_fx_Rxy_routine_add:
0027b9 91c0 28ba                 	lds r28, pulse2_fx_Rxy_speed
0027bb 91d0 28bb                 	lds r29, pulse2_fx_Rxy_speed+1
0027bd 0fac                      	add r26, r28 //increase the total offset by the speed
0027be 1fbd                      	adc r27, r29
0027bf 93a0 28bc                 	sts pulse2_fx_Rxy_total_offset, r26 //store the total offset
0027c1 93b0 28bd                 	sts pulse2_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume:
0027c3 91e0 28c6                 	lds ZL, triangle_volume_macro
0027c5 91f0 28c7                 	lds ZH, triangle_volume_macro+1
0027c7 9630                      	adiw Z, 0
0027c8 f199                      	breq sound_driver_instrument_routine_channel2_volume_default //if no volume macro is in use, do nothing
0027c9 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0027ca 1fff                      	rol ZH
0027cb 91a0 28c8                 	lds r26, triangle_volume_macro_offset
0027cd 0fea                      	add ZL, r26
0027ce 1df2                      	adc ZH, zero
                                 
0027cf 91b0 28ca                 	lds r27, triangle_volume_macro_release
0027d1 17ba                      	cp r27, r26
0027d2 f429                      	brne sound_driver_instrument_routine_channel2_volume_increment //if the current offset is not equal to the release index, increment the offset
0027d3 91a0 28c9                 	lds r26, triangle_volume_macro_loop
0027d5 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0027d6 f010                      	brlo sound_driver_instrument_routine_channel2_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0027d7 c003                      	rjmp sound_driver_instrument_routine_channel2_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_volume_increment:
0027d8 95a3                      	inc r26 //increment the macro offset
0027d9 93a0 28c8                 	sts triangle_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_volume_read:
0027db 91b4                      	lpm r27, Z //load volume data into r27
0027dc 3fbf                      	cpi r27, 0xFF //check for macro end flag
0027dd f469                      	brne sound_driver_instrument_routine_channel2_volume_process //if the data was not the macro end flag
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_release:
0027de 91b0 28ca                 	lds r27, triangle_volume_macro_release
0027e0 3fbf                      	cpi r27, 0xFF
0027e1 f429                      	brne sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_loop:
0027e2 91b0 28c9                 	lds r27, triangle_volume_macro_loop //load the loop index
0027e4 93b0 28c8                 	sts triangle_volume_macro_offset, r27 //store the loop index into the offset
0027e6 cfdc                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index:
0027e7 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
0027e8 93a0 28c8                 	sts triangle_volume_macro_offset, r26
0027ea cfd8                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_process:
0027eb 15b2                      	cp r27, zero
0027ec f041                      	breq sound_driver_instrument_routine_channel2_volume_process_disable
                                 sound_driver_instrument_routine_channel2_volume_process_enable:
0027ed 91b0 0aa5                 	lds r27, TCB2_INTCTRL
0027ef 30b1                      	cpi r27, TCB_CAPT_bm
0027f0 f459                      	brne sound_driver_instrument_routine_channel2_volume_default //if the channel has already been muted, don't enable it again
0027f1 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
0027f2 93b0 0aa5                 	sts TCB2_INTCTRL, r27
0027f4 c007                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 sound_driver_instrument_routine_channel2_volume_process_disable:
0027f5 9220 0aa5                 	sts TCB2_INTCTRL, zero
0027f7 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
0027f9 9220 0aad                 	sts TCB2_CCMPH, zero
0027fb c000                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_volume_default:
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
0027fc 91e0 28cb                 	lds ZL, triangle_arpeggio_macro
0027fe 91f0 28cc                 	lds ZH, triangle_arpeggio_macro+1
002800 9630                      	adiw Z, 0
002801 f1d9                      	breq sound_driver_instrument_routine_channel2_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002802 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002803 1fff                      	rol ZH
002804 91a0 28cd                 	lds r26, triangle_arpeggio_macro_offset
002806 0fea                      	add ZL, r26
002807 1df2                      	adc ZH, zero
                                 
002808 91b0 28cf                 	lds r27, triangle_arpeggio_macro_release
00280a 17ba                      	cp r27, r26
00280b f429                      	brne sound_driver_instrument_routine_channel2_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
00280c 91a0 28ce                 	lds r26, triangle_arpeggio_macro_loop
00280e 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00280f f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002810 c003                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_increment:
002811 95a3                      	inc r26 //increment the macro offset
002812 93a0 28cd                 	sts triangle_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_read:
002814 91b4                      	lpm r27, Z //load arpeggio data into r27
002815 38b0                      	cpi r27, 0x80 //check for macro end flag
002816 f009                      	breq sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag
002817 c041                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_check_mode:
002818 50a1                      	subi r26, 1 //keep the offset at the end flag
002819 93a0 28cd                 	sts triangle_arpeggio_macro_offset, r26
00281b 91b0 28d0                 	lds r27, triangle_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
00281d 30b1                      	cpi r27, 0x01
00281e f048                      	brlo sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_release:
00281f 91b0 28cf                 	lds r27, triangle_arpeggio_macro_release
002821 3fbf                      	cpi r27, 0xFF
002822 f4d1                      	brne sound_driver_instrument_routine_channel2_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_loop:
002823 91b0 28ce                 	lds r27, triangle_arpeggio_macro_loop
002825 3fbf                      	cpi r27, 0xFF
002826 f499                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002827 c015                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute:
002828 91b0 28cf                 	lds r27, triangle_arpeggio_macro_release
00282a 3fbf                      	cpi r27, 0xFF
00282b f421                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_check_loop:
00282c 91b0 28ce                 	lds r27, triangle_arpeggio_macro_loop //load the loop index
00282e 3fbf                      	cpi r27, 0xFF //check if loop flag exists
00282f f451                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop:
002830 91c0 28e3                 	lds r28, triangle_fx_0xy_sequence //check for 0xy effect
002832 91d0 28e4                 	lds r29, triangle_fx_0xy_sequence+1
002834 9620                      	adiw r29:r28, 0
002835 f469                      	brne sound_driver_instrument_routine_channel2_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002836 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002837 93a0 28cd                 	sts triangle_arpeggio_macro_offset, r26 //store the last valid index into the offset
002839 cfc2                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload:
00283a 93b0 28cd                 	sts triangle_arpeggio_macro_offset, r27 //store the loop index into the offset
00283c cfbf                      	rjmp sound_driver_instrument_routine_channel2_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_default:
00283d 91c0 28e3                 	lds r28, triangle_fx_0xy_sequence //load 0xy effect
00283f 91d0 28e4                 	lds r29, triangle_fx_0xy_sequence+1
002841 9620                      	adiw r29:r28, 0 //check for 0xy effect
002842 f099                      	breq sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel2_arpeggio_default_xy:
002843 95d6                      	lsr r29
002844 95c7                      	ror r28
002845 95d7                      	ror r29
002846 95c7                      	ror r28
002847 95d7                      	ror r29
002848 95c7                      	ror r28
002849 95d7                      	ror r29
00284a 95c7                      	ror r28
00284b 95d7                      	ror r29
00284c 95d2                      	swap r29
                                 
00284d 93c0 28e3                 	sts triangle_fx_0xy_sequence, r28 //store the rolled sequence
00284f 93d0 28e4                 	sts triangle_fx_0xy_sequence+1, r29
002851 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002852 91a0 2812                 	lds r26, triangle_note //load the current note index
002854 0fac                      	add r26, r28 //add the note offset
002855 c02e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002856 91a0 2812                 	lds r26, triangle_note //load the current note index
002858 c02b                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process:
002859 9220 28d1                 	sts triangle_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
00285b 9220 28d2                 	sts triangle_total_pitch_offset+1, zero
00285d 9220 28d8                 	sts triangle_total_hi_pitch_offset, zero
00285f 91a0 28d0                 	lds r26, triangle_arpeggio_macro_mode
002861 30a1                      	cpi r26, 0x01 //absolute mode
002862 f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_absolute
002863 f069                      	breq sound_driver_instrument_routine_channel2_arpeggio_process_fixed
002864 c00e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute:
002865 91a0 2812                 	lds r26, triangle_note //load the current note index
002867 0fab                      	add r26, r27 //offset the note with the arpeggio data
002868 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002869 c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_add:
00286a 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
00286b f0c0                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
00286c e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
00286d c016                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract:
00286e fda7                      	sbrc r26, 7 //check if result is negative
00286f e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002870 c013                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_fixed:
002871 2fab                      	mov r26, r27 //move the arpeggio data into r26
002872 c011                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative:
002873 91a0 2812                 	lds r26, triangle_note //load the current note index
002875 0fab                      	add r26, r27 //offset the note with the arpeggio data
002876 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002877 c008                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_add:
002878 93a0 2812                 	sts triangle_note, r26 //NOTE: relative mode modifies the original note index
00287a 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
00287b f040                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
00287c e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
00287d 93a0 2812                 	sts triangle_note, r26
00287f c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract:
002880 fda7                      	sbrc r26, 7 //check if result is negative
002881 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002882 93a0 2812                 	sts triangle_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_load:
002884 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
002885 e0f0                      	ldi ZH, HIGH(note_table << 1)
002886 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002887 0fea                      	add ZL, r26 //add offset
002888 1df2                      	adc ZH, zero
002889 91a5                      	lpm r26, Z+ //load bytes
00288a 91b4                      	lpm r27, Z
00288b 93a0 0aac                 	sts TCB2_CCMPL, r26 //load the LOW bits for timer
00288d 93b0 0aad                 	sts TCB2_CCMPH, r27 //load the HIGH bits for timer
00288f 93a0 28ef                 	sts triangle_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002891 93b0 28f0                 	sts triangle_fx_3xx_target+1, r27
002893 c000                      	rjmp sound_driver_instrument_routine_channel2_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch:
002894 91e0 28d3                 	lds ZL, triangle_pitch_macro
002896 91f0 28d4                 	lds ZH, triangle_pitch_macro+1
002898 9630                      	adiw Z, 0
002899 f409                      	brne sound_driver_instrument_routine_channel2_pitch_continue
00289a c023                      	rjmp sound_driver_instrument_routine_channel2_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel2_pitch_continue:
00289b 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00289c 1fff                      	rol ZH
00289d 91a0 28d5                 	lds r26, triangle_pitch_macro_offset
00289f 0fea                      	add ZL, r26
0028a0 1df2                      	adc ZH, zero
                                 
0028a1 91b0 28d7                 	lds r27, triangle_pitch_macro_release
0028a3 17ba                      	cp r27, r26
0028a4 f429                      	brne sound_driver_instrument_routine_channel2_pitch_increment //if the current offset is not equal to the release index, increment the offset
0028a5 91a0 28d6                 	lds r26, triangle_pitch_macro_loop
0028a7 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0028a8 f010                      	brlo sound_driver_instrument_routine_channel2_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0028a9 c003                      	rjmp sound_driver_instrument_routine_channel2_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_pitch_increment:
0028aa 95a3                      	inc r26 //increment the macro offset
0028ab 93a0 28d5                 	sts triangle_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_pitch_read:
0028ad 91b4                      	lpm r27, Z //load pitch data into r27
0028ae 38b0                      	cpi r27, 0x80 //check for macro end flag
0028af f479                      	brne sound_driver_instrument_routine_channel2_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_release:
0028b0 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0028b1 93a0 28d5                 	sts triangle_pitch_macro_offset, r26
0028b3 91b0 28d7                 	lds r27, triangle_pitch_macro_release
0028b5 3fbf                      	cpi r27, 0xFF
0028b6 f439                      	brne sound_driver_instrument_routine_channel2_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_loop:
0028b7 91b0 28d6                 	lds r27, triangle_pitch_macro_loop //load the loop index
0028b9 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0028ba f019                      	breq sound_driver_instrument_routine_channel2_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
0028bb 93b0 28d5                 	sts triangle_pitch_macro_offset, r27 //store the loop index into the offset
0028bd cfd6                      	rjmp sound_driver_instrument_routine_channel2_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_default:
0028be e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel2_pitch_calculate:
0028bf 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0028c0 937f                      	push r23
0028c1 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
0028c2 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0028c3 0367                      	mulsu r22, r23
0028c4 917f                      	pop r23
0028c5 916f                      	pop r22
                                 
0028c6 9416                      	lsr r1 //shift out the fractional bits
0028c7 9407                      	ror r0
0028c8 9416                      	lsr r1
0028c9 9407                      	ror r0
0028ca 9416                      	lsr r1
0028cb 9407                      	ror r0
0028cc 9416                      	lsr r1
0028cd 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_check_negative:
0028ce fe13                      	sbrs r1, 3 //check if result was a negative number
0028cf c007                      	rjmp sound_driver_instrument_routine_channel2_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_negative:
0028d0 efc0                      	ldi r28, 0xF0
0028d1 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_check_divisible_8:
0028d2 70b7                      	andi r27, 0b00000111
0028d3 f019                      	breq sound_driver_instrument_routine_channel2_pitch_calculate_offset
                                 
0028d4 e0b1                      	ldi r27, 0x01
0028d5 0e0b                      	add r0, r27
0028d6 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_offset:
0028d7 91a0 28d1                 	lds r26, triangle_total_pitch_offset
0028d9 91b0 28d2                 	lds r27, triangle_total_pitch_offset+1
0028db 0e0a                      	add r0, r26
0028dc 1e1b                      	adc r1, r27
0028dd 9200 28d1                 	sts triangle_total_pitch_offset, r0
0028df 9210 28d2                 	sts triangle_total_pitch_offset+1, r1
0028e1 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
0028e3 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
0028e5 0da0                      	add r26, r0 //offset the timer values
0028e6 1db1                      	adc r27, r1
                                 	
0028e7 91c0 28e7                 	lds r28, triangle_fx_1xx_total
0028e9 91d0 28e8                 	lds r29, triangle_fx_1xx_total+1
0028eb 1bac                      	sub r26, r28
0028ec 0bbd                      	sbc r27, r29
0028ed 91c0 28eb                 	lds r28, triangle_fx_2xx_total
0028ef 91d0 28ec                 	lds r29, triangle_fx_2xx_total+1
0028f1 0fac                      	add r26, r28
0028f2 1fbd                      	adc r27, r29
0028f3 91c0 28fa                 	lds r28, triangle_fx_Pxx_total
0028f5 91d0 28fb                 	lds r29, triangle_fx_Pxx_total+1
0028f7 0fac                      	add r26, r28
0028f8 1fbd                      	adc r27, r29
0028f9 91c0 2900                 	lds r28, triangle_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
0028fb 91d0 2901                 	lds r29, triangle_fx_Qxy_total_offset+1
0028fd 1bac                      	sub r26, r28
0028fe 0bbd                      	sbc r27, r29
0028ff 91c0 2906                 	lds r28, triangle_fx_Rxy_total_offset
002901 91d0 2907                 	lds r29, triangle_fx_Rxy_total_offset+1
002903 0fac                      	add r26, r28
002904 1fbd                      	adc r27, r29
                                 
002905 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
002907 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel2_hi_pitch:
002909 91e0 28d9                 	lds ZL, triangle_hi_pitch_macro
00290b 91f0 28da                 	lds ZH, triangle_hi_pitch_macro+1
00290d 9630                      	adiw Z, 0
00290e f409                      	brne sound_driver_instrument_routine_channel2_hi_pitch_continue
00290f c03c                      	rjmp sound_driver_instrument_routine_channel2_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel2_hi_pitch_continue:
002910 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002911 1fff                      	rol ZH
002912 91a0 28db                 	lds r26, triangle_hi_pitch_macro_offset
002914 0fea                      	add ZL, r26
002915 1df2                      	adc ZH, zero
                                 
002916 91b0 28dd                 	lds r27, triangle_hi_pitch_macro_release
002918 17ba                      	cp r27, r26
002919 f429                      	brne sound_driver_instrument_routine_channel2_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
00291a 91a0 28dc                 	lds r26, triangle_hi_pitch_macro_loop
00291c 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00291d f010                      	brlo sound_driver_instrument_routine_channel2_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00291e c003                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_increment:
00291f 95a3                      	inc r26 //increment the macro offset
002920 93a0 28db                 	sts triangle_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_hi_pitch_read:
002922 91b4                      	lpm r27, Z //load hi pitch data into r27
002923 38b0                      	cpi r27, 0x80 //check for macro end flag
002924 f489                      	brne sound_driver_instrument_routine_channel2_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_release:
002925 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002926 93a0 28db                 	sts triangle_hi_pitch_macro_offset, r26
002928 91b0 28dd                 	lds r27, triangle_hi_pitch_macro_release
00292a 3fbf                      	cpi r27, 0xFF
00292b f439                      	brne sound_driver_instrument_routine_channel2_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_loop:
00292c 91b0 28dc                 	lds r27, triangle_hi_pitch_macro_loop //load the loop index
00292e 3fbf                      	cpi r27, 0xFF //check if there is a loop index
00292f f019                      	breq sound_driver_instrument_routine_channel2_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002930 93b0 28db                 	sts triangle_hi_pitch_macro_offset, r27 //store the loop index into the offset
002932 cfd6                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_default:
002933 91b0 28d8                 	lds r27, triangle_total_hi_pitch_offset
002935 c005                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate:
002936 91a0 28d8                 	lds r26, triangle_total_hi_pitch_offset //load the total hi pitch offset to change
002938 0fba                      	add r27, r26
002939 93b0 28d8                 	sts triangle_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply:
00293b 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00293c 937f                      	push r23
00293d 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
00293e eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00293f 0367                      	mulsu r22, r23
002940 917f                      	pop r23
002941 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_offset:
002942 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
002944 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
002946 0da0                      	add r26, r0 //offset the timer values
002947 1db1                      	adc r27, r1
002948 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
00294a 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: The triangle channel does not have a duty cycle
                                 sound_driver_instrument_routine_channel2_duty:
                                 
                                 
                                 
                                 sound_driver_channel2_fx_routines:
                                 sound_driver_channel2_fx_1xx_routine:
00294c 91e0 28e5                 	lds ZL, triangle_fx_1xx
00294e 91f0 28e6                 	lds ZH, triangle_fx_1xx+1
002950 9630                      	adiw Z, 0
002951 f051                      	breq sound_driver_channel2_fx_2xx_routine
                                 
002952 91a0 28e7                 	lds r26, triangle_fx_1xx_total //load the rate to change the pitch by
002954 91b0 28e8                 	lds r27, triangle_fx_1xx_total+1
002956 0fae                      	add r26, ZL //increase the total offset by the rate
002957 1fbf                      	adc r27, ZH
002958 93a0 28e7                 	sts triangle_fx_1xx_total, r26
00295a 93b0 28e8                 	sts triangle_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_2xx_routine:
00295c 91e0 28e9                 	lds ZL, triangle_fx_2xx
00295e 91f0 28ea                 	lds ZH, triangle_fx_2xx+1
002960 9630                      	adiw Z, 0
002961 f051                      	breq sound_driver_channel2_fx_3xx_routine
                                 
002962 91a0 28eb                 	lds r26, triangle_fx_2xx_total //load the rate to change the pitch by
002964 91b0 28ec                 	lds r27, triangle_fx_2xx_total+1
002966 0fae                      	add r26, ZL //increase the total offset by the rate
002967 1fbf                      	adc r27, ZH
002968 93a0 28eb                 	sts triangle_fx_2xx_total, r26
00296a 93b0 28ec                 	sts triangle_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_3xx_routine:
00296c 91e0 28f1                 	lds ZL, triangle_fx_3xx_speed
00296e 91f0 28f2                 	lds ZH, triangle_fx_3xx_speed+1
002970 9630                      	adiw Z, 0
002971 f409                      	brne sound_driver_channel2_fx_3xx_routine_check_start
002972 c048                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_check_start:
002973 91a0 28ed                 	lds r26, triangle_fx_3xx_start
002975 91b0 28ee                 	lds r27, triangle_fx_3xx_start+1
002977 9610                      	adiw r26:r27, 0
002978 f409                      	brne sound_driver_channel2_fx_3xx_routine_main
002979 c041                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_main:
00297a 91c0 28ef                 	lds r28, triangle_fx_3xx_target
00297c 91d0 28f0                 	lds r29, triangle_fx_3xx_target+1
                                 
00297e 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
00297f 07bd                      	cpc r27, r29
002980 f011                      	breq sound_driver_channel2_fx_3xx_routine_disable
002981 f030                      	brlo sound_driver_channel2_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002982 c01f                      	rjmp sound_driver_channel2_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel2_fx_3xx_routine_disable:
002983 9220 28ed                 	sts triangle_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002985 9220 28ee                 	sts triangle_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002987 c033                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_subtract:
002988 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002989 0bdb                      	sbc r29, r27
00298a 91a0 28f3                 	lds r26, triangle_fx_3xx_total_offset
00298c 91b0 28f4                 	lds r27, triangle_fx_3xx_total_offset+1
                                 
00298e 0fae                      	add r26, ZL //add the speed to the total offset
00298f 1fbf                      	adc r27, ZH
002990 1bca                      	sub r28, r26 //invert the total difference with the total offset
002991 0bdb                      	sbc r29, r27
002992 f380                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002993 93a0 28f3                 	sts triangle_fx_3xx_total_offset, r26 //store the new total offset
002995 93b0 28f4                 	sts triangle_fx_3xx_total_offset+1, r27
                                 
002997 91a0 0aac                 	lds r26, TCB2_CCMPL //load the current timer period
002999 91b0 0aad                 	lds r27, TCB2_CCMPH
00299b 1bac                      	sub r26, r28 //offset the current timer period with the total offset
00299c 0bbd                      	sbc r27, r29
00299d 93a0 0aac                 	sts TCB2_CCMPL, r26
00299f 93b0 0aad                 	sts TCB2_CCMPH, r27
0029a1 c019                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_add:
0029a2 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
0029a3 0bbd                      	sbc r27, r29
0029a4 91c0 28f3                 	lds r28, triangle_fx_3xx_total_offset
0029a6 91d0 28f4                 	lds r29, triangle_fx_3xx_total_offset+1
                                 
0029a8 0fce                      	add r28, ZL //add the speed to the total offset
0029a9 1fdf                      	adc r29, ZH
0029aa 1bac                      	sub r26, r28 //invert the total difference with the total offset
0029ab 0bbd                      	sbc r27, r29
0029ac f2b0                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0029ad 93c0 28f3                 	sts triangle_fx_3xx_total_offset, r28 //store the new total offset
0029af 93d0 28f4                 	sts triangle_fx_3xx_total_offset+1, r29
                                 
0029b1 91c0 0aac                 	lds r28, TCB2_CCMPL //load the current timer period
0029b3 91d0 0aad                 	lds r29, TCB2_CCMPH
0029b5 0fca                      	add r28, r26 //offset the current timer period with the total offset
0029b6 1fdb                      	adc r29, r27
0029b7 93c0 0aac                 	sts TCB2_CCMPL, r28
0029b9 93d0 0aad                 	sts TCB2_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel2_fx_4xy_routine:
0029bb 91a0 28f5                 	lds r26, triangle_fx_4xy_speed
0029bd 15a2                      	cp r26, zero
0029be f409                      	brne sound_driver_channel2_fx_4xy_routine_continue
0029bf c05c                      	rjmp sound_driver_channel2_fx_Qxy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel2_fx_4xy_routine_continue:
0029c0 91b0 28f6                 	lds r27, triangle_fx_4xy_depth
0029c2 91c0 28f7                 	lds r28, triangle_fx_4xy_phase
0029c4 0fca                      	add r28, r26 //increase the phase by the speed
0029c5 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
0029c6 f008                      	brlo sound_driver_channel2_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
0029c7 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase:
0029c8 93c0 28f7                 	sts triangle_fx_4xy_phase, r28 //store the new phase
0029ca 31c0                      	cpi r28, 16
0029cb f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_0
0029cc 32c0                      	cpi r28, 32
0029cd f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_1
0029ce 33c0                      	cpi r28, 48
0029cf f030                      	brlo sound_driver_channel2_fx_4xy_routine_phase_2
0029d0 c007                      	rjmp sound_driver_channel2_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_0:
0029d1 70cf                      	andi r28, 0x0F //mask for values 0-15
0029d2 c029                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_1:
0029d3 6fc0                      	ori r28, 0xF0
0029d4 95c0                      	com r28 //invert values 0-15
0029d5 c026                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_2:
0029d6 70cf                      	andi r28, 0x0F //mask for values 0-15
0029d7 c003                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_3:
0029d8 6fc0                      	ori r28, 0xF0
0029d9 95c0                      	com r28 //invert values 0-15
0029da c000                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_add:
0029db 95b2                      	swap r27 //multiply depth by 16
0029dc 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0029dd e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0029de e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0029df 0fec                      	add ZL, r28 //offset the table by the depth+phase
0029e0 1df2                      	adc ZH, zero
0029e1 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
0029e2 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0029e3 937f                      	push r23
0029e4 2f6c                      	mov r22, r28 //store the vibrato value into r22
0029e5 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0029e6 9f67                      	mul r22, r23
0029e7 917f                      	pop r23
0029e8 916f                      	pop r22
                                 
0029e9 9416                      	lsr r1 //shift out the fractional bits
0029ea 9407                      	ror r0
0029eb 9416                      	lsr r1
0029ec 9407                      	ror r0
0029ed 9416                      	lsr r1
0029ee 9407                      	ror r0
0029ef 9416                      	lsr r1
0029f0 9407                      	ror r0
                                 	
0029f1 91a0 0aac                 	lds r26, TCB2_CCMPL
0029f3 91b0 0aad                 	lds r27, TCB2_CCMPH
0029f5 0da0                      	add r26, r0
0029f6 1db1                      	adc r27, r1
0029f7 93a0 0aac                 	sts TCB2_CCMPL, r26
0029f9 93b0 0aad                 	sts TCB2_CCMPH, r27
0029fb c020                      	rjmp sound_driver_channel2_fx_Qxy_routine
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_subtract:
0029fc 95b2                      	swap r27 //multiply depth by 16
0029fd 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
0029fe e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0029ff e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002a00 0fec                      	add ZL, r28 //offset the table by the depth+phase
002a01 1df2                      	adc ZH, zero
002a02 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002a03 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002a04 937f                      	push r23
002a05 2f6c                      	mov r22, r28 //store the vibrato value into r22
002a06 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002a07 9f67                      	mul r22, r23
002a08 917f                      	pop r23
002a09 916f                      	pop r22
                                 
002a0a 9416                      	lsr r1 //shift out the fractional bits
002a0b 9407                      	ror r0
002a0c 9416                      	lsr r1
002a0d 9407                      	ror r0
002a0e 9416                      	lsr r1
002a0f 9407                      	ror r0
002a10 9416                      	lsr r1
002a11 9407                      	ror r0
                                 
002a12 91a0 0aac                 	lds r26, TCB2_CCMPL
002a14 91b0 0aad                 	lds r27, TCB2_CCMPH
002a16 19a0                      	sub r26, r0
002a17 09b1                      	sbc r27, r1
002a18 93a0 0aac                 	sts TCB2_CCMPL, r26
002a1a 93b0 0aad                 	sts TCB2_CCMPH, r27
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel2_fx_Qxy_routine:
002a1c 91e0 28fc                 	lds ZL, triangle_fx_Qxy_target
002a1e 91f0 28fd                 	lds ZH, triangle_fx_Qxy_target+1
002a20 9630                      	adiw Z, 0
002a21 f139                      	breq sound_driver_channel2_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002a22 91a0 2900                 	lds r26, triangle_fx_Qxy_total_offset
002a24 91b0 2901                 	lds r27, triangle_fx_Qxy_total_offset+1
002a26 91c0 0aac                 	lds r28, TCB2_CCMPL
002a28 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
002a2a 1bec                      	sub ZL, r28 //calculate the difference to the target
002a2b 0bfd                      	sbc ZH, r29
002a2c f408                      	brsh sound_driver_channel2_fx_Qxy_routine_end //if the target has been reached (or passed)
002a2d f088                      	brlo sound_driver_channel2_fx_Qxy_routine_add
                                 
                                 sound_driver_channel2_fx_Qxy_routine_end:
002a2e 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
002a2f 0bbf                      	sbc r27, ZH
                                 
002a30 91c0 28fa                 	lds r28, triangle_fx_Pxx_total
002a32 91d0 28fb                 	lds r29, triangle_fx_Pxx_total+1
                                 
002a34 0fac                      	add r26, r28
002a35 1fbd                      	adc r27, r29
                                 
002a36 93a0 2900                 	sts triangle_fx_Qxy_total_offset, r26 //store the total offset
002a38 93b0 2901                 	sts triangle_fx_Qxy_total_offset+1, r27
002a3a 9220 28fc                 	sts triangle_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
002a3c 9220 28fd                 	sts triangle_fx_Qxy_target+1, zero
002a3e c00a                      	rjmp sound_driver_channel2_fx_Rxy_routine
                                 
                                 sound_driver_channel2_fx_Qxy_routine_add:
002a3f 91c0 28fe                 	lds r28, triangle_fx_Qxy_speed
002a41 91d0 28ff                 	lds r29, triangle_fx_Qxy_speed+1
002a43 0fac                      	add r26, r28 //increase the total offset by the speed
002a44 1fbd                      	adc r27, r29
002a45 93a0 2900                 	sts triangle_fx_Qxy_total_offset, r26 //store the total offset
002a47 93b0 2901                 	sts triangle_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_Rxy_routine:
002a49 91e0 2902                 	lds ZL, triangle_fx_Rxy_target
002a4b 91f0 2903                 	lds ZH, triangle_fx_Rxy_target+1
002a4d 9630                      	adiw Z, 0
002a4e f139                      	breq sound_driver_instrument_routine_channel3_volume //if the effect is not enabled, skip the routine
                                 
002a4f 91a0 2906                 	lds r26, triangle_fx_Rxy_total_offset
002a51 91b0 2907                 	lds r27, triangle_fx_Rxy_total_offset+1
002a53 91c0 0aac                 	lds r28, TCB2_CCMPL
002a55 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
002a57 1bce                      	sub r28, ZL //calculate the difference to the target
002a58 0bdf                      	sbc r29, ZH
002a59 f408                      	brsh sound_driver_channel2_fx_Rxy_routine_end //if the target has been reached (or passed)
002a5a f088                      	brlo sound_driver_channel2_fx_Rxy_routine_add
                                 
                                 sound_driver_channel2_fx_Rxy_routine_end:
002a5b 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
002a5c 0bbd                      	sbc r27, r29
                                 
002a5d 91c0 28fa                 	lds r28, triangle_fx_Pxx_total
002a5f 91d0 28fb                 	lds r29, triangle_fx_Pxx_total+1
                                 
002a61 0fac                      	add r26, r28
002a62 1fbd                      	adc r27, r29
                                 
002a63 93a0 2906                 	sts triangle_fx_Rxy_total_offset, r26 //store the total offset
002a65 93b0 2907                 	sts triangle_fx_Rxy_total_offset+1, r27
002a67 9220 2902                 	sts triangle_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
002a69 9220 2903                 	sts triangle_fx_Rxy_target+1, zero
002a6b c00a                      	rjmp sound_driver_instrument_routine_channel3_volume
                                 
                                 sound_driver_channel2_fx_Rxy_routine_add:
002a6c 91c0 2904                 	lds r28, triangle_fx_Rxy_speed
002a6e 91d0 2905                 	lds r29, triangle_fx_Rxy_speed+1
002a70 0fac                      	add r26, r28 //increase the total offset by the speed
002a71 1fbd                      	adc r27, r29
002a72 93a0 2906                 	sts triangle_fx_Rxy_total_offset, r26 //store the total offset
002a74 93b0 2907                 	sts triangle_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume:
002a76 91e0 2910                 	lds ZL, noise_volume_macro
002a78 91f0 2911                 	lds ZH, noise_volume_macro+1
002a7a 9630                      	adiw Z, 0
002a7b f1a1                      	breq sound_driver_instrument_routine_channel3_volume_default //if no volume macro is in use, use default multiplier of F
002a7c 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002a7d 1fff                      	rol ZH
002a7e 91a0 2912                 	lds r26, noise_volume_macro_offset
002a80 0fea                      	add ZL, r26
002a81 1df2                      	adc ZH, zero
                                 
002a82 91b0 2914                 	lds r27, noise_volume_macro_release
002a84 17ba                      	cp r27, r26
002a85 f429                      	brne sound_driver_instrument_routine_channel3_volume_increment //if the current offset is not equal to the release index, increment the offset
002a86 91a0 2913                 	lds r26, noise_volume_macro_loop
002a88 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002a89 f010                      	brlo sound_driver_instrument_routine_channel3_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002a8a c003                      	rjmp sound_driver_instrument_routine_channel3_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_volume_increment:
002a8b 95a3                      	inc r26 //increment the macro offset
002a8c 93a0 2912                 	sts noise_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_volume_read:
002a8e 91b4                      	lpm r27, Z //load volume data into r27
002a8f 3fbf                      	cpi r27, 0xFF //check for macro end flag
002a90 f469                      	brne sound_driver_instrument_routine_channel3_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_check_release:
002a91 91b0 2914                 	lds r27, noise_volume_macro_release
002a93 3fbf                      	cpi r27, 0xFF
002a94 f429                      	brne sound_driver_instrument_routine_channel3_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_check_loop:
002a95 91b0 2913                 	lds r27, noise_volume_macro_loop //load the loop index
002a97 93b0 2912                 	sts noise_volume_macro_offset, r27 //store the loop index into the offset
002a99 cfdc                      	rjmp sound_driver_instrument_routine_channel3_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_last_index:
002a9a 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002a9b 93a0 2912                 	sts noise_volume_macro_offset, r26
002a9d cfd8                      	rjmp sound_driver_instrument_routine_channel3_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume_calculate:
002a9e e8e4                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
002a9f e5fc                      	ldi ZH, HIGH(volumes << 1)
002aa0 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
002aa1 0feb                      	add ZL, r27 //add offset to the table
002aa2 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel3_volume_load:
002aa3 91b0 2813                 	lds r27, noise_param //load main volume
002aa5 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002aa6 91a0 2945                 	lds r26, noise_fx_7xy_value
002aa8 30a0                      	cpi r26, 0x00
002aa9 f481                      	brne sound_driver_instrument_routine_channel3_volume_load_7xy
                                 
002aaa 0feb                      	add ZL, r27 //offset the volume table by the main volume
002aab 1df2                      	adc ZH, zero
002aac 91b4                      	lpm r27, Z
002aad 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002aaf c023                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_default:
002ab0 91b0 2813                 	lds r27, noise_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
002ab2 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002ab3 91a0 2945                 	lds r26, noise_fx_7xy_value
002ab5 30a0                      	cpi r26, 0x00
002ab6 f499                      	brne sound_driver_instrument_routine_channel3_volume_default_7xy
002ab7 93b0 2816                 	sts noise_output_volume, r27
002ab9 c019                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_load_7xy:
002aba 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002abb f038                      	brcs sound_driver_instrument_routine_channel3_volume_load_7xy_overflow
002abc f031                      	breq sound_driver_instrument_routine_channel3_volume_load_7xy_overflow
                                 
002abd 0feb                      	add ZL, r27 //offset the volume table by the main volume
002abe 1df2                      	adc ZH, zero
002abf 91b4                      	lpm r27, Z
002ac0 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002ac2 c010                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_load_7xy_overflow:
002ac3 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002ac4 0feb                      	add ZL, r27 //offset the volume table by the main volume
002ac5 1df2                      	adc ZH, zero
002ac6 91b4                      	lpm r27, Z
002ac7 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002ac9 c009                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_default_7xy:
002aca 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002acb f020                      	brcs sound_driver_instrument_routine_channel3_volume_default_7xy_overflow
002acc f019                      	breq sound_driver_instrument_routine_channel3_volume_default_7xy_overflow
002acd 93b0 2816                 	sts noise_output_volume, r27
002acf c003                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel3_volume_default_7xy_overflow:
002ad0 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002ad1 93b0 2816                 	sts noise_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002ad3 91e0 2915                 	lds ZL, noise_arpeggio_macro
002ad5 91f0 2916                 	lds ZH, noise_arpeggio_macro+1
002ad7 9630                      	adiw Z, 0
002ad8 f1d9                      	breq sound_driver_instrument_routine_channel3_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002ad9 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002ada 1fff                      	rol ZH
002adb 91a0 2917                 	lds r26, noise_arpeggio_macro_offset
002add 0fea                      	add ZL, r26
002ade 1df2                      	adc ZH, zero
                                 
002adf 91b0 2919                 	lds r27, noise_arpeggio_macro_release
002ae1 17ba                      	cp r27, r26
002ae2 f429                      	brne sound_driver_instrument_routine_channel3_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002ae3 91a0 2918                 	lds r26, noise_arpeggio_macro_loop
002ae5 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002ae6 f010                      	brlo sound_driver_instrument_routine_channel3_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002ae7 c003                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_increment:
002ae8 95a3                      	inc r26 //increment the macro offset
002ae9 93a0 2917                 	sts noise_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_arpeggio_read:
002aeb 91b4                      	lpm r27, Z //load arpeggio data into r27
002aec 38b0                      	cpi r27, 0x80 //check for macro end flag
002aed f009                      	breq sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag
002aee c041                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_check_mode:
002aef 50a1                      	subi r26, 1 //keep the offset at the end flag
002af0 93a0 2917                 	sts noise_arpeggio_macro_offset, r26
002af2 91b0 291a                 	lds r27, noise_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002af4 30b1                      	cpi r27, 0x01
002af5 f048                      	brlo sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_fixed_relative_check_release:
002af6 91b0 2919                 	lds r27, noise_arpeggio_macro_release
002af8 3fbf                      	cpi r27, 0xFF
002af9 f4d1                      	brne sound_driver_instrument_routine_channel3_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_fixed_relative_check_loop:
002afa 91b0 2918                 	lds r27, noise_arpeggio_macro_loop
002afc 3fbf                      	cpi r27, 0xFF
002afd f499                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002afe c015                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute:
002aff 91b0 2919                 	lds r27, noise_arpeggio_macro_release
002b01 3fbf                      	cpi r27, 0xFF
002b02 f421                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_check_loop:
002b03 91b0 2918                 	lds r27, noise_arpeggio_macro_loop //load the loop index
002b05 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002b06 f451                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_no_loop:
002b07 91c0 292d                 	lds r28, noise_fx_0xy_sequence //check for 0xy effect
002b09 91d0 292e                 	lds r29, noise_fx_0xy_sequence+1
002b0b 9620                      	adiw r29:r28, 0
002b0c f469                      	brne sound_driver_instrument_routine_channel3_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002b0d 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002b0e 93a0 2917                 	sts noise_arpeggio_macro_offset, r26 //store the last valid index into the offset
002b10 cfc2                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload:
002b11 93b0 2917                 	sts noise_arpeggio_macro_offset, r27 //store the loop index into the offset
002b13 cfbf                      	rjmp sound_driver_instrument_routine_channel3_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_default:
002b14 91c0 292d                 	lds r28, noise_fx_0xy_sequence //load 0xy effect
002b16 91d0 292e                 	lds r29, noise_fx_0xy_sequence+1
002b18 9620                      	adiw r29:r28, 0 //check for 0xy effect
002b19 f099                      	breq sound_driver_instrument_routine_channel3_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel3_arpeggio_default_xy:
002b1a 95d6                      	lsr r29
002b1b 95c7                      	ror r28
002b1c 95d7                      	ror r29
002b1d 95c7                      	ror r28
002b1e 95d7                      	ror r29
002b1f 95c7                      	ror r28
002b20 95d7                      	ror r29
002b21 95c7                      	ror r28
002b22 95d7                      	ror r29
002b23 95d2                      	swap r29
                                 
002b24 93c0 292d                 	sts noise_fx_0xy_sequence, r28 //store the rolled sequence
002b26 93d0 292e                 	sts noise_fx_0xy_sequence+1, r29
002b28 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002b29 91a0 2817                 	lds r26, noise_note //load the current note index
002b2b 0fac                      	add r26, r28 //add the note offset
002b2c c02e                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel3_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002b2d 91a0 2817                 	lds r26, noise_note //load the current note index
002b2f c02b                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process:
002b30 9220 291b                 	sts noise_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002b32 9220 291c                 	sts noise_total_pitch_offset+1, zero
002b34 9220 2922                 	sts noise_total_hi_pitch_offset, zero
002b36 91a0 291a                 	lds r26, noise_arpeggio_macro_mode
002b38 30a1                      	cpi r26, 0x01 //absolute mode
002b39 f010                      	brlo sound_driver_instrument_routine_channel3_arpeggio_process_absolute
002b3a f069                      	breq sound_driver_instrument_routine_channel3_arpeggio_process_fixed
002b3b c00e                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_absolute:
002b3c 91a0 2817                 	lds r26, noise_note //load the current note index
002b3e 0fab                      	add r26, r27 //offset the note with the arpeggio data
002b3f fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002b40 c004                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_absolute_add:
002b41 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002b42 f0c0                      	brlo sound_driver_instrument_routine_channel3_arpeggio_process_load //if the result is valid, go load the new note
002b43 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002b44 c016                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_absolute_subtract:
002b45 fda7                      	sbrc r26, 7 //check if result is negative
002b46 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002b47 c013                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_fixed:
002b48 2fab                      	mov r26, r27 //move the arpeggio data into r26
002b49 c011                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_relative:
002b4a 91a0 2817                 	lds r26, noise_note //load the current note index
002b4c 0fab                      	add r26, r27 //offset the note with the arpeggio data
002b4d fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002b4e c008                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_relative_add:
002b4f 93a0 2817                 	sts noise_note, r26 //NOTE: relative mode modifies the original note index
002b51 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002b52 f040                      	brlo sound_driver_instrument_routine_channel3_arpeggio_process_load //if the result is valid, go load the new note
002b53 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002b54 93a0 2817                 	sts noise_note, r26
002b56 c004                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_relative_subtract:
002b57 fda7                      	sbrc r26, 7 //check if result is negative
002b58 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002b59 93a0 2817                 	sts noise_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_load:
002b5b e4e2                      	ldi ZL, LOW(noise_period_table << 1) //load in note table
002b5c e0f1                      	ldi ZH, HIGH(noise_period_table << 1)
002b5d 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002b5e 0fea                      	add ZL, r26 //add offset
002b5f 1df2                      	adc ZH, zero
002b60 91a5                      	lpm r26, Z+ //load bytes
002b61 91b4                      	lpm r27, Z
002b62 93a0 0abc                 	sts TCB3_CCMPL, r26 //load the LOW bits for timer
002b64 93b0 0abd                 	sts TCB3_CCMPH, r27 //load the HIGH bits for timer
002b66 93a0 2939                 	sts noise_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002b68 93b0 293a                 	sts noise_fx_3xx_target+1, r27
002b6a c000                      	rjmp sound_driver_instrument_routine_channel3_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch:
002b6b 91e0 291d                 	lds ZL, noise_pitch_macro
002b6d 91f0 291e                 	lds ZH, noise_pitch_macro+1
002b6f 9630                      	adiw Z, 0
002b70 f409                      	brne sound_driver_instrument_routine_channel3_pitch_continue
002b71 c023                      	rjmp sound_driver_instrument_routine_channel3_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel3_pitch_continue:
002b72 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002b73 1fff                      	rol ZH
002b74 91a0 291f                 	lds r26, noise_pitch_macro_offset
002b76 0fea                      	add ZL, r26
002b77 1df2                      	adc ZH, zero
                                 
002b78 91b0 2921                 	lds r27, noise_pitch_macro_release
002b7a 17ba                      	cp r27, r26
002b7b f429                      	brne sound_driver_instrument_routine_channel3_pitch_increment //if the current offset is not equal to the release index, increment the offset
002b7c 91a0 2920                 	lds r26, noise_pitch_macro_loop
002b7e 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002b7f f010                      	brlo sound_driver_instrument_routine_channel3_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002b80 c003                      	rjmp sound_driver_instrument_routine_channel3_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_pitch_increment:
002b81 95a3                      	inc r26 //increment the macro offset
002b82 93a0 291f                 	sts noise_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_pitch_read:
002b84 91b4                      	lpm r27, Z //load pitch data into r27
002b85 38b0                      	cpi r27, 0x80 //check for macro end flag
002b86 f479                      	brne sound_driver_instrument_routine_channel3_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag_check_release:
002b87 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002b88 93a0 291f                 	sts noise_pitch_macro_offset, r26
002b8a 91b0 2921                 	lds r27, noise_pitch_macro_release
002b8c 3fbf                      	cpi r27, 0xFF
002b8d f439                      	brne sound_driver_instrument_routine_channel3_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag_check_loop:
002b8e 91b0 2920                 	lds r27, noise_pitch_macro_loop //load the loop index
002b90 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002b91 f019                      	breq sound_driver_instrument_routine_channel3_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002b92 93b0 291f                 	sts noise_pitch_macro_offset, r27 //store the loop index into the offset
002b94 cfd6                      	rjmp sound_driver_instrument_routine_channel3_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch_default:
002b95 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel3_pitch_calculate:
002b96 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002b97 937f                      	push r23
002b98 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
002b99 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002b9a 0367                      	mulsu r22, r23
002b9b 917f                      	pop r23
002b9c 916f                      	pop r22
                                 
002b9d 9416                      	lsr r1 //shift out the fractional bits
002b9e 9407                      	ror r0
002b9f 9416                      	lsr r1
002ba0 9407                      	ror r0
002ba1 9416                      	lsr r1
002ba2 9407                      	ror r0
002ba3 9416                      	lsr r1
002ba4 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel3_pitch_calculate_check_negative:
002ba5 fe13                      	sbrs r1, 3 //check if result was a negative number
002ba6 c007                      	rjmp sound_driver_instrument_routine_channel3_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel3_pitch_calculate_negative:
002ba7 efc0                      	ldi r28, 0xF0
002ba8 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel3_pitch_calculate_check_divisible_8:
002ba9 70b7                      	andi r27, 0b00000111
002baa f019                      	breq sound_driver_instrument_routine_channel3_pitch_calculate_offset
                                 
002bab e0b1                      	ldi r27, 0x01
002bac 0e0b                      	add r0, r27
002bad 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel3_pitch_calculate_offset:
002bae 91a0 291b                 	lds r26, noise_total_pitch_offset
002bb0 91b0 291c                 	lds r27, noise_total_pitch_offset+1
002bb2 0e0a                      	add r0, r26
002bb3 1e1b                      	adc r1, r27
002bb4 9200 291b                 	sts noise_total_pitch_offset, r0
002bb6 9210 291c                 	sts noise_total_pitch_offset+1, r1
002bb8 91a0 0abc                 	lds r26, TCB3_CCMPL //load the low bits for timer
002bba 91b0 0abd                 	lds r27, TCB3_CCMPH //load the high bits for timer
002bbc 0da0                      	add r26, r0 //offset the timer values
002bbd 1db1                      	adc r27, r1
                                 	
002bbe 91c0 2931                 	lds r28, noise_fx_1xx_total
002bc0 91d0 2932                 	lds r29, noise_fx_1xx_total+1
002bc2 1bac                      	sub r26, r28
002bc3 0bbd                      	sbc r27, r29
002bc4 91c0 2935                 	lds r28, noise_fx_2xx_total
002bc6 91d0 2936                 	lds r29, noise_fx_2xx_total+1
002bc8 0fac                      	add r26, r28
002bc9 1fbd                      	adc r27, r29
002bca 91c0 2949                 	lds r28, noise_fx_Pxx_total
002bcc 91d0 294a                 	lds r29, noise_fx_Pxx_total+1
002bce 0fac                      	add r26, r28
002bcf 1fbd                      	adc r27, r29
002bd0 91c0 294f                 	lds r28, noise_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
002bd2 91d0 2950                 	lds r29, noise_fx_Qxy_total_offset+1
002bd4 1bac                      	sub r26, r28
002bd5 0bbd                      	sbc r27, r29
002bd6 91c0 2955                 	lds r28, noise_fx_Rxy_total_offset
002bd8 91d0 2956                 	lds r29, noise_fx_Rxy_total_offset+1
002bda 0fac                      	add r26, r28
002bdb 1fbd                      	adc r27, r29
                                 
002bdc 93a0 0abc                 	sts TCB3_CCMPL, r26 //store the new low bits for timer
002bde 93b0 0abd                 	sts TCB3_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel3_hi_pitch:
002be0 91e0 2923                 	lds ZL, noise_hi_pitch_macro
002be2 91f0 2924                 	lds ZH, noise_hi_pitch_macro+1
002be4 9630                      	adiw Z, 0
002be5 f409                      	brne sound_driver_instrument_routine_channel3_hi_pitch_continue
002be6 c03c                      	rjmp sound_driver_instrument_routine_channel3_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel3_hi_pitch_continue:
002be7 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002be8 1fff                      	rol ZH
002be9 91a0 2925                 	lds r26, noise_hi_pitch_macro_offset
002beb 0fea                      	add ZL, r26
002bec 1df2                      	adc ZH, zero
                                 
002bed 91b0 2927                 	lds r27, noise_hi_pitch_macro_release
002bef 17ba                      	cp r27, r26
002bf0 f429                      	brne sound_driver_instrument_routine_channel3_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002bf1 91a0 2926                 	lds r26, noise_hi_pitch_macro_loop
002bf3 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002bf4 f010                      	brlo sound_driver_instrument_routine_channel3_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002bf5 c003                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_increment:
002bf6 95a3                      	inc r26 //increment the macro offset
002bf7 93a0 2925                 	sts noise_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_hi_pitch_read:
002bf9 91b4                      	lpm r27, Z //load hi pitch data into r27
002bfa 38b0                      	cpi r27, 0x80 //check for macro end flag
002bfb f489                      	brne sound_driver_instrument_routine_channel3_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag_check_release:
002bfc 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002bfd 93a0 2925                 	sts noise_hi_pitch_macro_offset, r26
002bff 91b0 2927                 	lds r27, noise_hi_pitch_macro_release
002c01 3fbf                      	cpi r27, 0xFF
002c02 f439                      	brne sound_driver_instrument_routine_channel3_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag_check_loop:
002c03 91b0 2926                 	lds r27, noise_hi_pitch_macro_loop //load the loop index
002c05 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002c06 f019                      	breq sound_driver_instrument_routine_channel3_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002c07 93b0 2925                 	sts noise_hi_pitch_macro_offset, r27 //store the loop index into the offset
002c09 cfd6                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_default:
002c0a 91b0 2922                 	lds r27, noise_total_hi_pitch_offset
002c0c c005                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate:
002c0d 91a0 2922                 	lds r26, noise_total_hi_pitch_offset //load the total hi pitch offset to change
002c0f 0fba                      	add r27, r26
002c10 93b0 2922                 	sts noise_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate_multiply:
002c12 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002c13 937f                      	push r23
002c14 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002c15 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002c16 0367                      	mulsu r22, r23
002c17 917f                      	pop r23
002c18 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate_offset:
002c19 91a0 0abc                 	lds r26, TCB3_CCMPL //load the low bits for timer
002c1b 91b0 0abd                 	lds r27, TCB3_CCMPH //load the high bits for timer
002c1d 0da0                      	add r26, r0 //offset the timer values
002c1e 1db1                      	adc r27, r1
002c1f 93a0 0abc                 	sts TCB3_CCMPL, r26 //store the new low bits for timer
002c21 93b0 0abd                 	sts TCB3_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty:
002c23 91e0 2928                 	lds ZL, noise_duty_macro
002c25 91f0 2929                 	lds ZH, noise_duty_macro+1
002c27 9630                      	adiw Z, 0
002c28 f169                      	breq sound_driver_channel3_fx_routines //if no duty macro is in use, go to the next routine
002c29 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002c2a 1fff                      	rol ZH
002c2b 91a0 292a                 	lds r26, noise_duty_macro_offset
002c2d 0fea                      	add ZL, r26
002c2e 1df2                      	adc ZH, zero
                                 
002c2f 91b0 292c                 	lds r27, noise_duty_macro_release
002c31 17ba                      	cp r27, r26
002c32 f429                      	brne sound_driver_instrument_routine_channel3_duty_increment //if the current offset is not equal to the release index, increment the offset
002c33 91a0 292b                 	lds r26, noise_duty_macro_loop
002c35 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002c36 f010                      	brlo sound_driver_instrument_routine_channel3_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002c37 c01e                      	rjmp sound_driver_channel3_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel3_duty_increment:
002c38 95a3                      	inc r26 //increment the macro offset
002c39 93a0 292a                 	sts noise_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_duty_read:
002c3b 91b4                      	lpm r27, Z //load pitch data into r27
002c3c 3fbf                      	cpi r27, 0xFF //check for macro end flag
002c3d f471                      	brne sound_driver_instrument_routine_channel3_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag_check_release:
002c3e 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002c3f 93a0 292a                 	sts noise_duty_macro_offset, r26
002c41 91b0 292c                 	lds r27, noise_duty_macro_release
002c43 3fbf                      	cpi r27, 0xFF
002c44 f489                      	brne sound_driver_channel3_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag_check_loop:
002c45 91b0 292b                 	lds r27, noise_duty_macro_loop //load the loop index
002c47 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002c48 f069                      	breq sound_driver_channel3_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
002c49 93b0 292a                 	sts noise_duty_macro_offset, r27 //store the loop index into the offset
002c4b cfd7                      	rjmp sound_driver_instrument_routine_channel3_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty_load:
002c4c 95b6                      	lsr r27
002c4d 95b7                      	ror r27 //move mode bit to bit 7
002c4e 91c0 2814                 	lds r28, noise_period
002c50 77cf                      	andi r28, 0b01111111
002c51 2bcb                      	or r28, r27 //store the new noise mode
002c52 93c0 2813                 	sts noise_param, r28
                                 
002c54 776f                      	andi noise_sequence_HIGH, 0b01111111
002c55 2b6b                      	or noise_sequence_HIGH, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_routines:
                                 sound_driver_channel3_fx_1xx_routine:
002c56 91e0 292f                 	lds ZL, noise_fx_1xx
002c58 91f0 2930                 	lds ZH, noise_fx_1xx+1
002c5a 9630                      	adiw Z, 0
002c5b f051                      	breq sound_driver_channel3_fx_2xx_routine
                                 
002c5c 91a0 2931                 	lds r26, noise_fx_1xx_total //load the rate to change the pitch by
002c5e 91b0 2932                 	lds r27, noise_fx_1xx_total+1
002c60 0fae                      	add r26, ZL //increase the total offset by the rate
002c61 1fbf                      	adc r27, ZH
002c62 93a0 2931                 	sts noise_fx_1xx_total, r26
002c64 93b0 2932                 	sts noise_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_2xx_routine:
002c66 91e0 2933                 	lds ZL, noise_fx_2xx
002c68 91f0 2934                 	lds ZH, noise_fx_2xx+1
002c6a 9630                      	adiw Z, 0
002c6b f051                      	breq sound_driver_channel3_fx_3xx_routine
                                 
002c6c 91a0 2935                 	lds r26, noise_fx_2xx_total //load the rate to change the pitch by
002c6e 91b0 2936                 	lds r27, noise_fx_2xx_total+1
002c70 0fae                      	add r26, ZL //increase the total offset by the rate
002c71 1fbf                      	adc r27, ZH
002c72 93a0 2935                 	sts noise_fx_2xx_total, r26
002c74 93b0 2936                 	sts noise_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_3xx_routine:
002c76 91e0 293b                 	lds ZL, noise_fx_3xx_speed
002c78 91f0 293c                 	lds ZH, noise_fx_3xx_speed+1
002c7a 9630                      	adiw Z, 0
002c7b f409                      	brne sound_driver_channel3_fx_3xx_routine_check_start
002c7c c048                      	rjmp sound_driver_channel3_fx_4xy_routine
                                 
                                 sound_driver_channel3_fx_3xx_routine_check_start:
002c7d 91a0 2937                 	lds r26, noise_fx_3xx_start
002c7f 91b0 2938                 	lds r27, noise_fx_3xx_start+1
002c81 9610                      	adiw r26:r27, 0
002c82 f409                      	brne sound_driver_channel3_fx_3xx_routine_main
002c83 c041                      	rjmp sound_driver_channel3_fx_4xy_routine
                                 
                                 sound_driver_channel3_fx_3xx_routine_main:
002c84 91c0 2939                 	lds r28, noise_fx_3xx_target
002c86 91d0 293a                 	lds r29, noise_fx_3xx_target+1
                                 
002c88 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
002c89 07bd                      	cpc r27, r29
002c8a f011                      	breq sound_driver_channel3_fx_3xx_routine_disable
002c8b f030                      	brlo sound_driver_channel3_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002c8c c01f                      	rjmp sound_driver_channel3_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel3_fx_3xx_routine_disable:
002c8d 9220 2937                 	sts noise_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002c8f 9220 2938                 	sts noise_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002c91 c033                      	rjmp sound_driver_channel3_fx_4xy_routine
                                 
                                 sound_driver_channel3_fx_3xx_routine_subtract:
002c92 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002c93 0bdb                      	sbc r29, r27
002c94 91a0 293d                 	lds r26, noise_fx_3xx_total_offset
002c96 91b0 293e                 	lds r27, noise_fx_3xx_total_offset+1
                                 
002c98 0fae                      	add r26, ZL //add the speed to the total offset
002c99 1fbf                      	adc r27, ZH
002c9a 1bca                      	sub r28, r26 //invert the total difference with the total offset
002c9b 0bdb                      	sbc r29, r27
002c9c f380                      	brlo sound_driver_channel3_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002c9d 93a0 293d                 	sts noise_fx_3xx_total_offset, r26 //store the new total offset
002c9f 93b0 293e                 	sts noise_fx_3xx_total_offset+1, r27
                                 
002ca1 91a0 0abc                 	lds r26, TCB3_CCMPL //load the current timer period
002ca3 91b0 0abd                 	lds r27, TCB3_CCMPH
002ca5 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002ca6 0bbd                      	sbc r27, r29
002ca7 93a0 0abc                 	sts TCB3_CCMPL, r26
002ca9 93b0 0abd                 	sts TCB3_CCMPH, r27
002cab c019                      	rjmp sound_driver_channel3_fx_4xy_routine
                                 
                                 sound_driver_channel3_fx_3xx_routine_add:
002cac 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002cad 0bbd                      	sbc r27, r29
002cae 91c0 293d                 	lds r28, noise_fx_3xx_total_offset
002cb0 91d0 293e                 	lds r29, noise_fx_3xx_total_offset+1
                                 
002cb2 0fce                      	add r28, ZL //add the speed to the total offset
002cb3 1fdf                      	adc r29, ZH
002cb4 1bac                      	sub r26, r28 //invert the total difference with the total offset
002cb5 0bbd                      	sbc r27, r29
002cb6 f2b0                      	brlo sound_driver_channel3_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002cb7 93c0 293d                 	sts noise_fx_3xx_total_offset, r28 //store the new total offset
002cb9 93d0 293e                 	sts noise_fx_3xx_total_offset+1, r29
                                 
002cbb 91c0 0abc                 	lds r28, TCB3_CCMPL //load the current timer period
002cbd 91d0 0abd                 	lds r29, TCB3_CCMPH
002cbf 0fca                      	add r28, r26 //offset the current timer period with the total offset
002cc0 1fdb                      	adc r29, r27
002cc1 93c0 0abc                 	sts TCB3_CCMPL, r28
002cc3 93d0 0abd                 	sts TCB3_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel3_fx_4xy_routine:
002cc5 91a0 293f                 	lds r26, noise_fx_4xy_speed
002cc7 15a2                      	cp r26, zero
002cc8 f409                      	brne sound_driver_channel3_fx_4xy_routine_continue
002cc9 c05c                      	rjmp sound_driver_channel3_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel3_fx_4xy_routine_continue:
002cca 91b0 2940                 	lds r27, noise_fx_4xy_depth
002ccc 91c0 2941                 	lds r28, noise_fx_4xy_phase
002cce 0fca                      	add r28, r26 //increase the phase by the speed
002ccf 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002cd0 f008                      	brlo sound_driver_channel3_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002cd1 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase:
002cd2 93c0 2941                 	sts noise_fx_4xy_phase, r28 //store the new phase
002cd4 31c0                      	cpi r28, 16
002cd5 f028                      	brlo sound_driver_channel3_fx_4xy_routine_phase_0
002cd6 32c0                      	cpi r28, 32
002cd7 f028                      	brlo sound_driver_channel3_fx_4xy_routine_phase_1
002cd8 33c0                      	cpi r28, 48
002cd9 f030                      	brlo sound_driver_channel3_fx_4xy_routine_phase_2
002cda c007                      	rjmp sound_driver_channel3_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_0:
002cdb 70cf                      	andi r28, 0x0F //mask for values 0-15
002cdc c029                      	rjmp sound_driver_channel3_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_1:
002cdd 6fc0                      	ori r28, 0xF0
002cde 95c0                      	com r28 //invert values 0-15
002cdf c026                      	rjmp sound_driver_channel3_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_2:
002ce0 70cf                      	andi r28, 0x0F //mask for values 0-15
002ce1 c003                      	rjmp sound_driver_channel3_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_3:
002ce2 6fc0                      	ori r28, 0xF0
002ce3 95c0                      	com r28 //invert values 0-15
002ce4 c000                      	rjmp sound_driver_channel3_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel3_fx_4xy_routine_load_add:
002ce5 95b2                      	swap r27 //multiply depth by 16
002ce6 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002ce7 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002ce8 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002ce9 0fec                      	add ZL, r28 //offset the table by the depth+phase
002cea 1df2                      	adc ZH, zero
002ceb 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002cec 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002ced 937f                      	push r23
002cee 2f6c                      	mov r22, r28 //store the vibrato value into r22
002cef eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002cf0 9f67                      	mul r22, r23
002cf1 917f                      	pop r23
002cf2 916f                      	pop r22
                                 
002cf3 9416                      	lsr r1 //shift out the fractional bits
002cf4 9407                      	ror r0
002cf5 9416                      	lsr r1
002cf6 9407                      	ror r0
002cf7 9416                      	lsr r1
002cf8 9407                      	ror r0
002cf9 9416                      	lsr r1
002cfa 9407                      	ror r0
                                 	
002cfb 91a0 0abc                 	lds r26, TCB3_CCMPL
002cfd 91b0 0abd                 	lds r27, TCB3_CCMPH
002cff 0da0                      	add r26, r0
002d00 1db1                      	adc r27, r1
002d01 93a0 0abc                 	sts TCB3_CCMPL, r26
002d03 93b0 0abd                 	sts TCB3_CCMPH, r27
002d05 c020                      	rjmp sound_driver_channel3_fx_7xy_routine
                                 
                                 sound_driver_channel3_fx_4xy_routine_load_subtract:
002d06 95b2                      	swap r27 //multiply depth by 16
002d07 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002d08 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002d09 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002d0a 0fec                      	add ZL, r28 //offset the table by the depth+phase
002d0b 1df2                      	adc ZH, zero
002d0c 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002d0d 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002d0e 937f                      	push r23
002d0f 2f6c                      	mov r22, r28 //store the vibrato value into r22
002d10 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002d11 9f67                      	mul r22, r23
002d12 917f                      	pop r23
002d13 916f                      	pop r22
                                 
002d14 9416                      	lsr r1 //shift out the fractional bits
002d15 9407                      	ror r0
002d16 9416                      	lsr r1
002d17 9407                      	ror r0
002d18 9416                      	lsr r1
002d19 9407                      	ror r0
002d1a 9416                      	lsr r1
002d1b 9407                      	ror r0
                                 
002d1c 91a0 0abc                 	lds r26, TCB3_CCMPL
002d1e 91b0 0abd                 	lds r27, TCB3_CCMPH
002d20 19a0                      	sub r26, r0
002d21 09b1                      	sbc r27, r1
002d22 93a0 0abc                 	sts TCB3_CCMPL, r26
002d24 93b0 0abd                 	sts TCB3_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_7xy_routine:
002d26 91a0 2942                 	lds r26, noise_fx_7xy_speed
002d28 15a2                      	cp r26, zero
002d29 f0e9                      	breq sound_driver_channel3_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
002d2a 91b0 2943                 	lds r27, noise_fx_7xy_depth
002d2c 91c0 2944                 	lds r28, noise_fx_7xy_phase
002d2e 0fca                      	add r28, r26 //increase the phase by the speed
002d2f 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002d30 f008                      	brlo sound_driver_channel3_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
002d31 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel3_fx_7xy_routine_phase:
002d32 93c0 2944                 	sts noise_fx_7xy_phase, r28 //store the new phase
002d34 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
002d35 ffc4                      	sbrs r28, 4
002d36 c001                      	rjmp sound_driver_channel3_fx_7xy_routine_phase_0
002d37 c002                      	rjmp sound_driver_channel3_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel3_fx_7xy_routine_phase_0:
002d38 70cf                      	andi r28, 0x0F //mask for values 0-15
002d39 c003                      	rjmp sound_driver_channel3_fx_7xy_routine_load
                                 
                                 sound_driver_channel3_fx_7xy_routine_phase_1:
002d3a 6fc0                      	ori r28, 0xF0
002d3b 95c0                      	com r28 //invert values 0-15
002d3c c000                      	rjmp sound_driver_channel3_fx_7xy_routine_load
                                 
                                 sound_driver_channel3_fx_7xy_routine_load:
002d3d 95b2                      	swap r27 //multiply depth by 16
002d3e 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002d3f e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002d40 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002d41 0fec                      	add ZL, r28 //offset the table by the depth+phase
002d42 1df2                      	adc ZH, zero
002d43 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002d44 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
002d45 93c0 2945                 	sts noise_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Axy_routine:
002d47 91b0 2946                 	lds r27, noise_fx_Axy
002d49 15b2                      	cp r27, zero
002d4a f0e9                      	breq sound_driver_channel3_fx_Qxy_routine //0 means that the effect is not in use
                                 	
002d4b 91a0 2815                 	lds r26, noise_fractional_volume //load fractional volume representation of the channel
002d4d 91c0 2813                 	lds r28, noise_param //load the integer volume representation of the channel
002d4f 2fda                      	mov r29, r26 //copy fractional volume into r29
002d50 2fec                      	mov r30, r28 //copy the noise_param into r30
002d51 95e2                      	swap r30
002d52 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
002d53 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
002d54 17ed                      	cp r30, r29 //compare the fractional and integer volumes
002d55 f009                      	breq sound_driver_channel3_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel3_fx_Axy_routine_reload:
002d56 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate:
002d57 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
002d58 c004                      	rjmp sound_driver_channel3_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_addition:
002d59 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002d5a f428                      	brcc sound_driver_channel3_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002d5b efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
002d5c c003                      	rjmp sound_driver_channel3_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_subtraction:
002d5d 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002d5e f008                      	brcs sound_driver_channel3_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002d5f e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_store:
002d60 93a0 2815                 	sts noise_fractional_volume, r26 //store the new fractional volume
002d62 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
002d63 95a2                      	swap r26
002d64 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
002d65 2bca                      	or r28, r26 //store the new volume back into noise_param
002d66 93c0 2813                 	sts noise_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel3_fx_Qxy_routine:
002d68 91e0 294b                 	lds ZL, noise_fx_Qxy_target
002d6a 91f0 294c                 	lds ZH, noise_fx_Qxy_target+1
002d6c 9630                      	adiw Z, 0
002d6d f139                      	breq sound_driver_channel3_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002d6e 91a0 294f                 	lds r26, noise_fx_Qxy_total_offset
002d70 91b0 2950                 	lds r27, noise_fx_Qxy_total_offset+1
002d72 91c0 0abc                 	lds r28, TCB3_CCMPL
002d74 91d0 0abd                 	lds r29, TCB3_CCMPH
                                 
002d76 1bec                      	sub ZL, r28 //calculate the difference to the target
002d77 0bfd                      	sbc ZH, r29
002d78 f408                      	brsh sound_driver_channel3_fx_Qxy_routine_end //if the target has been reached (or passed)
002d79 f088                      	brlo sound_driver_channel3_fx_Qxy_routine_add
                                 
                                 sound_driver_channel3_fx_Qxy_routine_end:
002d7a 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
002d7b 0bbf                      	sbc r27, ZH
                                 
002d7c 91c0 2949                 	lds r28, noise_fx_Pxx_total
002d7e 91d0 294a                 	lds r29, noise_fx_Pxx_total+1
                                 
002d80 0fac                      	add r26, r28
002d81 1fbd                      	adc r27, r29
                                 
002d82 93a0 294f                 	sts noise_fx_Qxy_total_offset, r26 //store the total offset
002d84 93b0 2950                 	sts noise_fx_Qxy_total_offset+1, r27
002d86 9220 294b                 	sts noise_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
002d88 9220 294c                 	sts noise_fx_Qxy_target+1, zero
002d8a c00a                      	rjmp sound_driver_channel3_fx_Rxy_routine
                                 
                                 sound_driver_channel3_fx_Qxy_routine_add:
002d8b 91c0 294d                 	lds r28, noise_fx_Qxy_speed
002d8d 91d0 294e                 	lds r29, noise_fx_Qxy_speed+1
002d8f 0fac                      	add r26, r28 //increase the total offset by the speed
002d90 1fbd                      	adc r27, r29
002d91 93a0 294f                 	sts noise_fx_Qxy_total_offset, r26 //store the total offset
002d93 93b0 2950                 	sts noise_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Rxy_routine:
002d95 91e0 2951                 	lds ZL, noise_fx_Rxy_target
002d97 91f0 2952                 	lds ZH, noise_fx_Rxy_target+1
002d99 9630                      	adiw Z, 0
002d9a f139                      	breq sound_driver_instrument_routine_channel4_volume //if the effect is not enabled, skip the routine
                                 
002d9b 91a0 2955                 	lds r26, noise_fx_Rxy_total_offset
002d9d 91b0 2956                 	lds r27, noise_fx_Rxy_total_offset+1
002d9f 91c0 0abc                 	lds r28, TCB3_CCMPL
002da1 91d0 0abd                 	lds r29, TCB3_CCMPH
                                 
002da3 1bce                      	sub r28, ZL //calculate the difference to the target
002da4 0bdf                      	sbc r29, ZH
002da5 f408                      	brsh sound_driver_channel3_fx_Rxy_routine_end //if the target has been reached (or passed)
002da6 f088                      	brlo sound_driver_channel3_fx_Rxy_routine_add
                                 
                                 sound_driver_channel3_fx_Rxy_routine_end:
002da7 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
002da8 0bbd                      	sbc r27, r29
                                 
002da9 91c0 2949                 	lds r28, noise_fx_Pxx_total
002dab 91d0 294a                 	lds r29, noise_fx_Pxx_total+1
                                 
002dad 0fac                      	add r26, r28
002dae 1fbd                      	adc r27, r29
                                 
002daf 93a0 2955                 	sts noise_fx_Rxy_total_offset, r26 //store the total offset
002db1 93b0 2956                 	sts noise_fx_Rxy_total_offset+1, r27
002db3 9220 2951                 	sts noise_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
002db5 9220 2952                 	sts noise_fx_Rxy_target+1, zero
002db7 c00a                      	rjmp sound_driver_instrument_routine_channel4_volume
                                 
                                 sound_driver_channel3_fx_Rxy_routine_add:
002db8 91c0 2953                 	lds r28, noise_fx_Rxy_speed
002dba 91d0 2954                 	lds r29, noise_fx_Rxy_speed+1
002dbc 0fac                      	add r26, r28 //increase the total offset by the speed
002dbd 1fbd                      	adc r27, r29
002dbe 93a0 2955                 	sts noise_fx_Rxy_total_offset, r26 //store the total offset
002dc0 93b0 2956                 	sts noise_fx_Rxy_total_offset+1, r27
                                 
                                 sound_driver_instrument_routine_channel4_volume:
                                 
                                 sound_driver_exit:
002dc2 91ff                      	pop r31
002dc3 91ef                      	pop r30
002dc4 91df                      	pop r29
002dc5 91cf                      	pop r28
002dc6 940c 1283                 	jmp sequence_1_3 + 3 //+3 is to skip the stack instructions since we already pushed them
                                 
                                 
                                 
                                 //TABLES
002dc8 7f05
002dc9 010a
002dca 0214
002dcb 0328
002dcc 0450
002dcd 051e
002dce 0607
002dcf 070d
002dd0 0806
002dd1 090c
002dd2 0a18
002dd3 0b30
002dd4 0c60
002dd5 0d24
002dd6 0e08
002dd7 0f10                      length: .db $05, $7F, $0A, $01, $14, $02, $28, $03, $50, $04, $1E, $05, $07, $06, $0D, $07, $06, $08, $0C, $09, $18, $0A, $30, $0B, $60, $0C, $24, $0D, $08, $0E, $10, $0F
                                 
                                 //pulse sequences: 12.5%, 25%, 50%, 75%
002dd8 0301
002dd9 fc0f                      sequences: .db 0b00000001, 0b00000011, 0b00001111, 0b11111100
                                 
                                 //list of famitracker fx: http://famitracker.com/wiki/index.php?title=Effect_list
                                 channel0_fx:
002dda 14bf
002ddb 14c4
002ddc 14e0
002ddd 14fc
002dde 151f                      	.dw sound_driver_channel0_fx_0xy, sound_driver_channel0_fx_1xx, sound_driver_channel0_fx_2xx, sound_driver_channel0_fx_3xx, sound_driver_channel0_fx_4xy
002ddf 152a
002de0 1537
002de1 153a
002de2 153d
002de3 1540                      	.dw sound_driver_channel0_fx_7xy, sound_driver_channel0_fx_Axy, sound_driver_channel0_fx_Bxx, sound_driver_channel0_fx_Cxx, sound_driver_channel0_fx_Dxx
002de4 1543
002de5 154b
002de6 154e
002de7 155b
002de8 155c                      	.dw sound_driver_channel0_fx_Exx, sound_driver_channel0_fx_Fxx, sound_driver_channel0_fx_Gxx, sound_driver_channel0_fx_Hxy, sound_driver_channel0_fx_Ixy
002de9 155d
002dea 155e
002deb 155f
002dec 1577
002ded 15bb                      	.dw sound_driver_channel0_fx_Hxx, sound_driver_channel0_fx_Ixx, sound_driver_channel0_fx_Pxx, sound_driver_channel0_fx_Qxy, sound_driver_channel0_fx_Rxy
002dee 15fe
002def 160b
002df0 161f
002df1 1620
002df2 1621                      	.dw sound_driver_channel0_fx_Sxx, sound_driver_channel0_fx_Vxx, sound_driver_channel0_fx_Wxx, sound_driver_channel0_fx_Xxx, sound_driver_channel0_fx_Yxx
002df3 1622                      	.dw sound_driver_channel0_fx_Zxx
                                 
                                 channel1_fx:
002df4 17ad
002df5 17b2
002df6 17ce
002df7 17ea
002df8 180d                      	.dw sound_driver_channel1_fx_0xy, sound_driver_channel1_fx_1xx, sound_driver_channel1_fx_2xx, sound_driver_channel1_fx_3xx, sound_driver_channel1_fx_4xy
002df9 1818
002dfa 1825
002dfb 1828
002dfc 182b
002dfd 182e                      	.dw sound_driver_channel1_fx_7xy, sound_driver_channel1_fx_Axy, sound_driver_channel1_fx_Bxx, sound_driver_channel1_fx_Cxx, sound_driver_channel1_fx_Dxx
002dfe 1831
002dff 1839
002e00 183c
002e01 1849
002e02 184a                      	.dw sound_driver_channel1_fx_Exx, sound_driver_channel1_fx_Fxx, sound_driver_channel1_fx_Gxx, sound_driver_channel1_fx_Hxy, sound_driver_channel1_fx_Ixy
002e03 184b
002e04 184c
002e05 184d
002e06 1865
002e07 18a9                      	.dw sound_driver_channel1_fx_Hxx, sound_driver_channel1_fx_Ixx, sound_driver_channel1_fx_Pxx, sound_driver_channel1_fx_Qxy, sound_driver_channel1_fx_Rxy
002e08 18ec
002e09 18f9
002e0a 190d
002e0b 190e
002e0c 190f                      	.dw sound_driver_channel1_fx_Sxx, sound_driver_channel1_fx_Vxx, sound_driver_channel1_fx_Wxx, sound_driver_channel1_fx_Xxx, sound_driver_channel1_fx_Yxx
002e0d 1910                      	.dw sound_driver_channel1_fx_Zxx
                                 
                                 channel2_fx:
002e0e 1a8e
002e0f 1a93
002e10 1aaf
002e11 1acb
002e12 1aee                      	.dw sound_driver_channel2_fx_0xy, sound_driver_channel2_fx_1xx, sound_driver_channel2_fx_2xx, sound_driver_channel2_fx_3xx, sound_driver_channel2_fx_4xy
002e13 1af9
002e14 1afa
002e15 1afb
002e16 1afe
002e17 1b01                      	.dw sound_driver_channel2_fx_7xy, sound_driver_channel2_fx_Axy, sound_driver_channel2_fx_Bxx, sound_driver_channel2_fx_Cxx, sound_driver_channel2_fx_Dxx
002e18 1b04
002e19 1b11
002e1a 1b14
002e1b 1b21
002e1c 1b22                      	.dw sound_driver_channel2_fx_Exx, sound_driver_channel2_fx_Fxx, sound_driver_channel2_fx_Gxx, sound_driver_channel2_fx_Hxy, sound_driver_channel2_fx_Ixy
002e1d 1b23
002e1e 1b24
002e1f 1b25
002e20 1b3d
002e21 1b81                      	.dw sound_driver_channel2_fx_Hxx, sound_driver_channel2_fx_Ixx, sound_driver_channel2_fx_Pxx, sound_driver_channel2_fx_Qxy, sound_driver_channel2_fx_Rxy
002e22 1bc4
002e23 1bd1
002e24 1bd2
002e25 1bd3
002e26 1bd4                      	.dw sound_driver_channel2_fx_Sxx, sound_driver_channel2_fx_Vxx, sound_driver_channel2_fx_Wxx, sound_driver_channel2_fx_Xxx, sound_driver_channel2_fx_Yxx
002e27 1bd5                      	.dw sound_driver_channel2_fx_Zxx
                                 
                                 channel3_fx:
002e28 1d57
002e29 1d5c
002e2a 1d78
002e2b 1d94
002e2c 1db7                      	.dw sound_driver_channel3_fx_0xy, sound_driver_channel3_fx_1xx, sound_driver_channel3_fx_2xx, sound_driver_channel3_fx_3xx, sound_driver_channel3_fx_4xy
002e2d 1dc2
002e2e 1dcf
002e2f 1dd2
002e30 1dd5
002e31 1dd8                      	.dw sound_driver_channel3_fx_7xy, sound_driver_channel3_fx_Axy, sound_driver_channel3_fx_Bxx, sound_driver_channel3_fx_Cxx, sound_driver_channel3_fx_Dxx
002e32 1ddb
002e33 1de2
002e34 1de5
002e35 1df2
002e36 1df3                      	.dw sound_driver_channel3_fx_Exx, sound_driver_channel3_fx_Fxx, sound_driver_channel3_fx_Gxx, sound_driver_channel3_fx_Hxy, sound_driver_channel3_fx_Ixy
002e37 1df4
002e38 1df5
002e39 1df6
002e3a 1e0e
002e3b 1e52                      	.dw sound_driver_channel3_fx_Hxx, sound_driver_channel3_fx_Ixx, sound_driver_channel3_fx_Pxx, sound_driver_channel3_fx_Qxy, sound_driver_channel3_fx_Rxy
002e3c 1e95
002e3d 1ea2
002e3e 1ead
002e3f 1eae
002e40 1eaf                      	.dw sound_driver_channel3_fx_Sxx, sound_driver_channel3_fx_Vxx, sound_driver_channel3_fx_Wxx, sound_driver_channel3_fx_Xxx, sound_driver_channel3_fx_Yxx
002e41 1eb0                      	.dw sound_driver_channel3_fx_Zxx
                                 
                                 //famitracker volumes table: http://famitracker.com/wiki/index.php?title=Volume
                                 volumes:
002e42 0000
002e43 0000
002e44 0000
002e45 0000
002e46 0000
002e47 0000
002e48 0000
002e49 0000                      	.db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
002e4a 0100
002e4b 0101
002e4c 0101
002e4d 0101
002e4e 0101
002e4f 0101
002e50 0101
002e51 0101                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
002e52 0100
002e53 0101
002e54 0101
002e55 0101
002e56 0101
002e57 0101
002e58 0101
002e59 0201                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02
002e5a 0100
002e5b 0101
002e5c 0101
002e5d 0101
002e5e 0101
002e5f 0202
002e60 0202
002e61 0302                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03
002e62 0100
002e63 0101
002e64 0101
002e65 0101
002e66 0202
002e67 0202
002e68 0303
002e69 0403                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04
002e6a 0100
002e6b 0101
002e6c 0101
002e6d 0202
002e6e 0302
002e6f 0303
002e70 0404
002e71 0504                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05
002e72 0100
002e73 0101
002e74 0201
002e75 0202
002e76 0303
002e77 0404
002e78 0504
002e79 0605                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x06
002e7a 0100
002e7b 0101
002e7c 0201
002e7d 0302
002e7e 0403
002e7f 0504
002e80 0605
002e81 0706                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07
002e82 0100
002e83 0101
002e84 0202
002e85 0303
002e86 0404
002e87 0505
002e88 0606
002e89 0807                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07, 0x08
002e8a 0100
002e8b 0101
002e8c 0302
002e8d 0403
002e8e 0504
002e8f 0606
002e90 0707
002e91 0908                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09
002e92 0100
002e93 0201
002e94 0302
002e95 0404
002e96 0605
002e97 0706
002e98 0808
002e99 0a09                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A
002e9a 0100
002e9b 0201
002e9c 0302
002e9d 0504
002e9e 0605
002e9f 0807
002ea0 0908
002ea1 0b0a                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B
002ea2 0100
002ea3 0201
002ea4 0403
002ea5 0504
002ea6 0706
002ea7 0808
002ea8 0a09
002ea9 0c0b                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B, 0x0C
002eaa 0100
002eab 0201
002eac 0403
002ead 0605
002eae 0706
002eaf 0908
002eb0 0b0a
002eb1 0d0c                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D
002eb2 0100
002eb3 0201
002eb4 0403
002eb5 0605
002eb6 0807
002eb7 0a09
002eb8 0c0b
002eb9 0e0d                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E
002eba 0100
002ebb 0302
002ebc 0504
002ebd 0706
002ebe 0908
002ebf 0b0a
002ec0 0d0c


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega4809" register use summary:
x  :   0 y  :   0 z  : 248 r0 : 196 r1 : 212 r2 : 701 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   6 r11:   4 r12:   9 
r13:   6 r14:   4 r15:   9 r16:   7 r17:   6 r18:   7 r19:   6 r20:   4 
r21:   9 r22: 174 r23: 160 r24:   0 r25:  24 r26: 979 r27:1193 r28: 703 
r29: 376 r30: 378 r31: 337 
Registers used: 25 out of 35 (71.4%)

"ATmega4809" instruction use summary:
.lds  :   0 .sts  :   0 adc   : 152 add   : 199 adiw  : 106 and   :   0 
andi  :  99 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   7 brcs  :  13 break :   0 breq  : 173 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  81 brlt  :   0 brmi  :   0 
brne  : 121 brpl  :   0 brsh  :  31 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :   0 cbr   :   5 
clc   :   0 clh   :   0 cli   :   8 cln   :   0 clr   :   5 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :  16 cp    : 101 cpc   :  10 
cpi   : 168 cpse  :  20 dec   :  35 des   :   0 eor   :   2 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   4 in    :   7 inc   :  48 
jmp   :  11 ld    :   0 ldd   :   0 ldi   : 294 lds   : 727 lpm   : 260 
lsl   :  79 lsr   : 171 mov   : 139 movw  :   0 mul   :  28 muls  :   0 
mulsu :  12 neg   :   0 nop   :   0 or    :  26 ori   :  12 out   :   9 
pop   : 115 push  : 109 rcall :  50 ret   :  32 reti  :   7 rjmp  : 518 
rol   :  53 ror   : 192 sbc   :  48 sbci  :   0 sbi   :   0 sbic  :   0 
sbis  :   0 sbiw  :   0 sbr   :  12 sbrc  :  29 sbrs  :  20 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   :1397 sub   :  66 subi  :  45 swap  :  46 tst   :   0 wdr   :   0 

Instructions used: 52 out of 114 (45.6%)

"ATmega4809" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x005d84  15918   7910  23828   49152  48.5%
[.dseg] 0x002800 0x00295a      0    346    346    6144   5.6%
[.eseg] 0x000000 0x000000      0      0      0     256   0.0%

Assembly complete, 0 errors, 55 warnings
