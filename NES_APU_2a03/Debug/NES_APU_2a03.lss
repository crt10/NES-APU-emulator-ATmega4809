
AVRASM ver. 2.2.8  C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm Sat Jan 23 20:30:35 2021

C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
                                 
                                 
                                 ; NES_APU_2a03.asm
                                 ;
                                 ; Created: 11/29/2020 1:44:10 AM
                                 ; Author : Tennyson Cheng
                                 ;
                                 
                                 .list
                                 
                                 .dseg
002800                           pulse1_param: .byte 1 //$4000 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002801                           pulse1_sweep_param: .byte 1 //$4001 EPPP.NSSS = Enable, Period, Negate, Shift
                                 //NOTE: In order to account for multiplier, we use 16 instead of 11 bits for the timer
002802                           pulse1_timerL: .byte 1 //$4002 LLLL.LLLL = Low 8 bits for timer
002803                           pulse1_timerH: .byte 1 //$4002 HHHH.HHHH = High 8 bits for timer
002804                           pulse1_length: .byte 1 //$4003 000l.llll = Length counter load
002805                           pulse1_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002806                           pulse1_output_volume: .byte 1 //this is the final output volume of pulse 1
002807                           pulse1_note: .byte 1 //the current note index in the note table
                                 
002808                           pulse2_param: .byte 1 //$4004 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002809                           pulse2_sweep_param: .byte 1 //$4005 EPPP.NSSS = Enable, Period, Negate, Shift
00280a                           pulse2_timerL: .byte 1 //$4006 LLLL.LLLL = Low 8 bits for timer
00280b                           pulse2_timerH: .byte 1 //$4006 HHHH.HHHH = High 8 bits for timer
00280c                           pulse2_length: .byte 1 //$4007 000l.llll = Length counter load
00280d                           pulse2_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
00280e                           pulse2_output_volume: .byte 1 //this is the final output volume of pulse 2
00280f                           pulse2_note: .byte 1 //the current note index in the note table
                                 
002810                           triangle_timerL: .byte 1 //$400A LLLL.LLLL = Low 8 bits for timer
002811                           triangle_timerH: .byte 1 //$400A HHHH.HHHH = High 8 bits for time
002812                           triangle_note: .byte 1 //the current note index in the note table
                                 
002813                           noise_param: .byte 1 //$400C 00lc.vvvv = Length counter halt/Loop flag, Constant volume flag, Volume
002814                           noise_period: .byte 1 //$400E M000.PPPP = Mode, Period
002815                           noise_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002816                           noise_output_volume: .byte 1 //this is the final output volume of pulse 2
002817                           noise_note: .byte 1 //the current note index in the period table
                                 
002818                           song_frames: .byte 2
00281a                           song_frame_offset: .byte 2
00281c                           song_size: .byte 2
00281e                           song_speed: .byte 1
                                 //song_channel_delay_reload: .byte 1 //bit 0-4 represents channels 0-4. a set bit means that there is a delay that needs to be calculated for that channel.
00281f                           song_fx_Bxx: .byte 1
002820                           song_fx_Cxx: .byte 1
002821                           song_fx_Dxx: .byte 1
                                 
                                 //PULSE 1
002822                           pulse1_pattern: .byte 2
002824                           pulse1_pattern_delay_rows: .byte 1
002825                           pulse1_pattern_delay_frames: .byte 1
002826                           pulse1_pattern_offset: .byte 2
                                 
002828                           pulse1_volume_macro: .byte 2
00282a                           pulse1_volume_macro_offset: .byte 1
00282b                           pulse1_volume_macro_loop: .byte 1
00282c                           pulse1_volume_macro_release: .byte 1
                                 
00282d                           pulse1_arpeggio_macro: .byte 2
00282f                           pulse1_arpeggio_macro_offset: .byte 1
002830                           pulse1_arpeggio_macro_loop: .byte 1
002831                           pulse1_arpeggio_macro_release: .byte 1
002832                           pulse1_arpeggio_macro_mode: .byte 1
                                 
002833                           pulse1_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002835                           pulse1_pitch_macro: .byte 2
002837                           pulse1_pitch_macro_offset: .byte 1
002838                           pulse1_pitch_macro_loop: .byte 1
002839                           pulse1_pitch_macro_release: .byte 1
                                 
00283a                           pulse1_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00283b                           pulse1_hi_pitch_macro: .byte 2
00283d                           pulse1_hi_pitch_macro_offset: .byte 1
00283e                           pulse1_hi_pitch_macro_loop: .byte 1
00283f                           pulse1_hi_pitch_macro_release: .byte 1
                                 
002840                           pulse1_duty_macro: .byte 2
002842                           pulse1_duty_macro_offset: .byte 1
002843                           pulse1_duty_macro_loop: .byte 1
002844                           pulse1_duty_macro_release: .byte 1
                                 
002845                           pulse1_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002847                           pulse1_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002849                           pulse1_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00284b                           pulse1_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
00284d                           pulse1_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
00284f                           pulse1_fx_3xx_start: .byte 2 //the starting note period
002851                           pulse1_fx_3xx_target: .byte 2 //target note period
002853                           pulse1_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
002855                           pulse1_fx_3xx_total_offset: .byte 2
002857                           pulse1_fx_4xy_speed: .byte 1
002858                           pulse1_fx_4xy_depth: .byte 1
002859                           pulse1_fx_4xy_phase: .byte 1
00285a                           pulse1_fx_7xy_speed: .byte 1
00285b                           pulse1_fx_7xy_depth: .byte 1
00285c                           pulse1_fx_7xy_phase: .byte 1
00285d                           pulse1_fx_7xy_value: .byte 1 //value to offset the volume
00285e                           pulse1_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
00285f                           pulse1_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002860                           pulse1_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002861                           pulse1_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
002863                           pulse1_fx_Qxy_target_note: .byte 1 //target note index
002864                           pulse1_fx_Qxy_target: .byte 2 //target note period
002866                           pulse1_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002868                           pulse1_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
00286a                           pulse1_fx_Rxy_target_note: .byte 1 //target note index
00286b                           pulse1_fx_Rxy_target: .byte 2 //target note period
00286d                           pulse1_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
00286f                           pulse1_fx_Rxy_total_offset: .byte 2
002871                           pulse1_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002872                           pulse1_fx_Sxx_post: .byte 1
                                 
                                 //PULSE 2
002873                           pulse2_pattern: .byte 2
002875                           pulse2_pattern_delay_rows: .byte 1
002876                           pulse2_pattern_delay_frames: .byte 1
002877                           pulse2_pattern_offset: .byte 2
                                 
002879                           pulse2_volume_macro: .byte 2
00287b                           pulse2_volume_macro_offset: .byte 1
00287c                           pulse2_volume_macro_loop: .byte 1
00287d                           pulse2_volume_macro_release: .byte 1
                                 
00287e                           pulse2_arpeggio_macro: .byte 2
002880                           pulse2_arpeggio_macro_offset: .byte 1
002881                           pulse2_arpeggio_macro_loop: .byte 1
002882                           pulse2_arpeggio_macro_release: .byte 1
002883                           pulse2_arpeggio_macro_mode: .byte 1
                                 
002884                           pulse2_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002886                           pulse2_pitch_macro: .byte 2
002888                           pulse2_pitch_macro_offset: .byte 1
002889                           pulse2_pitch_macro_loop: .byte 1
00288a                           pulse2_pitch_macro_release: .byte 1
                                 
00288b                           pulse2_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00288c                           pulse2_hi_pitch_macro: .byte 2
00288e                           pulse2_hi_pitch_macro_offset: .byte 1
00288f                           pulse2_hi_pitch_macro_loop: .byte 1
002890                           pulse2_hi_pitch_macro_release: .byte 1
                                 
002891                           pulse2_duty_macro: .byte 2
002893                           pulse2_duty_macro_offset: .byte 1
002894                           pulse2_duty_macro_loop: .byte 1
002895                           pulse2_duty_macro_release: .byte 1
                                 
002896                           pulse2_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002898                           pulse2_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
00289a                           pulse2_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00289c                           pulse2_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
00289e                           pulse2_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
0028a0                           pulse2_fx_3xx_start: .byte 2 //the starting note period
0028a2                           pulse2_fx_3xx_target: .byte 2 //target note period
0028a4                           pulse2_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028a6                           pulse2_fx_3xx_total_offset: .byte 2
0028a8                           pulse2_fx_4xy_speed: .byte 1
0028a9                           pulse2_fx_4xy_depth: .byte 1
0028aa                           pulse2_fx_4xy_phase: .byte 1
0028ab                           pulse2_fx_7xy_speed: .byte 1
0028ac                           pulse2_fx_7xy_depth: .byte 1
0028ad                           pulse2_fx_7xy_phase: .byte 1
0028ae                           pulse2_fx_7xy_value: .byte 1 //value to offset the volume
0028af                           pulse2_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
0028b0                           pulse2_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028b1                           pulse2_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028b2                           pulse2_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
0028b4                           pulse2_fx_Qxy_target_note: .byte 1 //target note index
0028b5                           pulse2_fx_Qxy_target: .byte 2 //target note period
0028b7                           pulse2_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
0028b9                           pulse2_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
0028bb                           pulse2_fx_Rxy_target_note: .byte 1 //target note index
0028bc                           pulse2_fx_Rxy_target: .byte 2 //target note period
0028be                           pulse2_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
0028c0                           pulse2_fx_Rxy_total_offset: .byte 2
0028c2                           pulse2_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
0028c3                           pulse2_fx_Sxx_post: .byte 1
                                 
                                 //TRIANGLE
0028c4                           triangle_pattern: .byte 2
0028c6                           triangle_pattern_delay_rows: .byte 1
0028c7                           triangle_pattern_delay_frames: .byte 1
0028c8                           triangle_pattern_offset: .byte 2
                                 
0028ca                           triangle_volume_macro: .byte 2
0028cc                           triangle_volume_macro_offset: .byte 1
0028cd                           triangle_volume_macro_loop: .byte 1
0028ce                           triangle_volume_macro_release: .byte 1
                                 
0028cf                           triangle_arpeggio_macro: .byte 2
0028d1                           triangle_arpeggio_macro_offset: .byte 1
0028d2                           triangle_arpeggio_macro_loop: .byte 1
0028d3                           triangle_arpeggio_macro_release: .byte 1
0028d4                           triangle_arpeggio_macro_mode: .byte 1
                                 
0028d5                           triangle_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
0028d7                           triangle_pitch_macro: .byte 2
0028d9                           triangle_pitch_macro_offset: .byte 1
0028da                           triangle_pitch_macro_loop: .byte 1
0028db                           triangle_pitch_macro_release: .byte 1
                                 
0028dc                           triangle_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
0028dd                           triangle_hi_pitch_macro: .byte 2
0028df                           triangle_hi_pitch_macro_offset: .byte 1
0028e0                           triangle_hi_pitch_macro_loop: .byte 1
0028e1                           triangle_hi_pitch_macro_release: .byte 1
                                 
0028e2                           triangle_duty_macro: .byte 2
0028e4                           triangle_duty_macro_offset: .byte 1
0028e5                           triangle_duty_macro_loop: .byte 1
0028e6                           triangle_duty_macro_release: .byte 1
                                 
0028e7                           triangle_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
0028e9                           triangle_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
0028eb                           triangle_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
0028ed                           triangle_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
0028ef                           triangle_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
0028f1                           triangle_fx_3xx_start: .byte 2 //the starting note period
0028f3                           triangle_fx_3xx_target: .byte 2 //target note period
0028f5                           triangle_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028f7                           triangle_fx_3xx_total_offset: .byte 2
0028f9                           triangle_fx_4xy_speed: .byte 1
0028fa                           triangle_fx_4xy_depth: .byte 1
0028fb                           triangle_fx_4xy_phase: .byte 1
0028fc                           triangle_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028fd                           triangle_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028fe                           triangle_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
002900                           triangle_fx_Qxy_target_note: .byte 1 //target note index
002901                           triangle_fx_Qxy_target: .byte 2 //target note period
002903                           triangle_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002905                           triangle_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002907                           triangle_fx_Rxy_target_note: .byte 1 //target note index
002908                           triangle_fx_Rxy_target: .byte 2 //target note period
00290a                           triangle_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
00290c                           triangle_fx_Rxy_total_offset: .byte 2
00290e                           triangle_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
00290f                           triangle_fx_Sxx_post: .byte 1
                                 
                                 //NOISE
002910                           noise_pattern: .byte 2
002912                           noise_pattern_delay_rows: .byte 1
002913                           noise_pattern_delay_frames: .byte 1
002914                           noise_pattern_offset: .byte 2
                                 
002916                           noise_volume_macro: .byte 2
002918                           noise_volume_macro_offset: .byte 1
002919                           noise_volume_macro_loop: .byte 1
00291a                           noise_volume_macro_release: .byte 1
                                 
00291b                           noise_arpeggio_macro: .byte 2
00291d                           noise_arpeggio_macro_offset: .byte 1
00291e                           noise_arpeggio_macro_loop: .byte 1
00291f                           noise_arpeggio_macro_release: .byte 1
002920                           noise_arpeggio_macro_mode: .byte 1
                                 
002921                           noise_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002923                           noise_pitch_macro: .byte 2
002925                           noise_pitch_macro_offset: .byte 1
002926                           noise_pitch_macro_loop: .byte 1
002927                           noise_pitch_macro_release: .byte 1
                                 
002928                           noise_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
002929                           noise_hi_pitch_macro: .byte 2
00292b                           noise_hi_pitch_macro_offset: .byte 1
00292c                           noise_hi_pitch_macro_loop: .byte 1
00292d                           noise_hi_pitch_macro_release: .byte 1
                                 
00292e                           noise_duty_macro: .byte 2
002930                           noise_duty_macro_offset: .byte 1
002931                           noise_duty_macro_loop: .byte 1
002932                           noise_duty_macro_release: .byte 1
                                 
002933                           noise_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002935                           noise_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002937                           noise_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
002939                           noise_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
00293b                           noise_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
00293d                           noise_fx_3xx_start: .byte 2 //the starting note period
00293f                           noise_fx_3xx_target: .byte 2 //target note period
002941                           noise_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
002943                           noise_fx_3xx_total_offset: .byte 2
002945                           noise_fx_4xy_speed: .byte 1
002946                           noise_fx_4xy_depth: .byte 1
002947                           noise_fx_4xy_phase: .byte 1
002948                           noise_fx_7xy_speed: .byte 1
002949                           noise_fx_7xy_depth: .byte 1
00294a                           noise_fx_7xy_phase: .byte 1
00294b                           noise_fx_7xy_value: .byte 1 //value to offset the volume
00294c                           noise_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
00294d                           noise_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
00294e                           noise_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
00294f                           noise_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
002951                           noise_fx_Qxy_target_note: .byte 1 //target note index
002952                           noise_fx_Qxy_target: .byte 2 //target note period
002954                           noise_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002956                           noise_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002958                           noise_fx_Rxy_target_note: .byte 1 //target note index
002959                           noise_fx_Rxy_target: .byte 2 //target note period
00295b                           noise_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
00295d                           noise_fx_Rxy_total_offset: .byte 2
00295f                           noise_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002960                           noise_fx_Sxx_post: .byte 1
                                 
                                 //DPCM
002961                           dcpm_pattern_delay: .byte 1
                                 
                                 .cseg
                                 
                                 //NOTE: zero is defined in order to use the cp instruction without the need to load 0x00 into a register beforehand
                                 .def zero = r2
                                 .def pulse_channel_flags = r25 //[pulse1.pulse2] RSlc.RSlc = Reload, Start, Length halt/Loop, Constant volume
                                 .def pulse1_sequence = r10
                                 .def pulse1_length_counter = r11
                                 .def pulse1_sweep = r12 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse1_volume_divider = r16 //0000.PPPP = Period divider
                                 .def pulse1_volume_decay = r17 //0000.dddd = Decay
                                 .def pulse2_sequence = r13
                                 .def pulse2_length_counter = r14
                                 .def pulse2_sweep = r15 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse2_volume_divider = r18 //0000.PPPP = Period divider
                                 .def pulse2_volume_decay = r19 //0000.dddd = Decay
                                 .def triangle_sequence = r20
                                 .def noise_sequence_LOW = r21
                                 .def noise_sequence_HIGH = r22
                                 
                                 reset:
000000 940c 0ec3                 	jmp init
                                 
                                 .org TCA0_OVF_vect
00000e 940c 137e                 	jmp sound_driver
                                 
                                 .org TCA0_CMP0_vect
000012 940c 1285                 	jmp sequence_0_2
                                 
                                 .org TCA0_CMP1_vect
000014 940c 1290                 	jmp sequence_1_3
                                 
                                 .org TCA0_CMP2_vect
000016 940c 1285                 	jmp sequence_0_2
                                 
                                 .org TCB0_INT_vect
000018 940c 12a7                 	jmp pulse1_sequence_routine
                                 
                                 .org TCB1_INT_vect
00001a 940c 12f4                 	jmp pulse2_sequence_routine
                                 
                                 .org TCB2_INT_vect
000032 940c 1341                 	jmp triangle_sequence_routine
                                 
                                 .org TCB3_INT_vect
000048 940c 134c                 	jmp noise_sequence_routine
                                 
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(33): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(48): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(74): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(77): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(79): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(80): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(81): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(84): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(85): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(88): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(89): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(93): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(95): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(96): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(97): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(101): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(102): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(104): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(106): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(108): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(109): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(110): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(113): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(116): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(119): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(124): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(125): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(127): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(128): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(131): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(138): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(216): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(218): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(219): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(220): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(221): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(223): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(225): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(226): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(227): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(231): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(233): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(234): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(235): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(237): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(240): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(246): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(247): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(249): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(250): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(251): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(258): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(259): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(269): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(270): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
                                 .list
                                 
                                 init:
                                 	//MAIN CLOCK
000ec3 edc8                      	ldi r28, CPU_CCP_IOREG_gc //protected write
000ec4 93c0 0034                 	sts CPU_CCP, r28
000ec6 e0c0                      	ldi r28, 0 << CLKCTRL_PEN_bp //disable prescaler for 20 MHz on main clock
000ec7 93c0 0061                 	sts CLKCTRL_MCLKCTRLB, r28
                                 
                                 	//ZERO
000ec9 2422                      	clr zero
                                 
                                 	//MEMORY
000eca e3c0                      	ldi r28, 0b00110000
000ecb 93c0 2800                 	sts pulse1_param, r28
000ecd e8c0                      	ldi r28, 0b10000000
000ece 93c0 2801                 	sts pulse1_sweep_param, r28
000ed0 efcf                      	ldi r28, 0xFF
000ed1 93c0 2802                 	sts pulse1_timerL, r28
000ed3 93c0 2803                 	sts pulse1_timerH, r28
000ed5 93c0 2804                 	sts pulse1_length, r28
                                 
000ed7 e3c0                      	ldi r28, 0b00110000
000ed8 93c0 2808                 	sts pulse2_param, r28
000eda e8c0                      	ldi r28, 0b10000000
000edb 93c0 2809                 	sts pulse2_sweep_param, r28
000edd efcf                      	ldi r28, 0xFF
000ede 93c0 280a                 	sts pulse2_timerL, r28
000ee0 93c0 280b                 	sts pulse2_timerH, r28
000ee2 93c0 280c                 	sts pulse2_length, r28
                                 
000ee4 efcf                      	ldi r28, 0xFF
000ee5 93c0 2810                 	sts triangle_timerL, r28
000ee7 93c0 2811                 	sts triangle_timerH, r28
                                 
000ee9 e3c0                      	ldi r28, 0b00110000
000eea 93c0 2813                 	sts noise_param, r28
000eec e0cf                      	ldi r28, 0b00001111
000eed 93c0 2814                 	sts noise_period, r28
                                 
000eef e0c2                      	ldi r28, 0x02
000ef0 93c0 281a                 	sts song_frame_offset, r28
000ef2 9220 281b                 	sts song_frame_offset+1, zero
000ef4 efcf                      	ldi r28, 0xFF
000ef5 93c0 281f                 	sts song_fx_Bxx, r28
000ef7 9220 2820                 	sts song_fx_Cxx, zero
000ef9 9220 2821                 	sts song_fx_Dxx, zero
000efb e4ee                      	ldi ZL, LOW(song0_frames << 1)
000efc e0f3                      	ldi ZH, HIGH(song0_frames << 1)
000efd 93e0 2818                 	sts song_frames, ZL
000eff 93f0 2819                 	sts song_frames+1, ZH
000f01 91c5                      	lpm r28, Z+ //load the song size
000f02 91d5                      	lpm r29, Z+
000f03 93c0 281c                 	sts song_size, r28
000f05 93d0 281d                 	sts song_size+1, r29
000f07 9220 281e                 	sts song_speed, zero
                                 
                                 	//CHANNEL 0
000f09 91c5                      	lpm r28, Z+
000f0a 91d5                      	lpm r29, Z+
000f0b 0fcc                      	lsl r28
000f0c 1fdd                      	rol r29
000f0d 93c0 2822                 	sts pulse1_pattern, r28
000f0f 93d0 2823                 	sts pulse1_pattern+1, r29
000f11 9220 2824                 	sts pulse1_pattern_delay_rows, zero
000f13 9220 2825                 	sts pulse1_pattern_delay_frames, zero
000f15 9220 2826                 	sts pulse1_pattern_offset, zero
000f17 9220 2827                 	sts pulse1_pattern_offset+1, zero
                                 
                                 	//CHANNEL 1
000f19 91c5                      	lpm r28, Z+
000f1a 91d5                      	lpm r29, Z+
000f1b 0fcc                      	lsl r28
000f1c 1fdd                      	rol r29
000f1d 93c0 2873                 	sts pulse2_pattern, r28
000f1f 93d0 2874                 	sts pulse2_pattern+1, r29
000f21 9220 2875                 	sts pulse2_pattern_delay_rows, zero
000f23 9220 2876                 	sts pulse2_pattern_delay_frames, zero
000f25 9220 2877                 	sts pulse2_pattern_offset, zero
000f27 9220 2878                 	sts pulse2_pattern_offset+1, zero
                                 
                                 	//CHANNEL 2
000f29 91c5                      	lpm r28, Z+
000f2a 91d5                      	lpm r29, Z+
000f2b 0fcc                      	lsl r28
000f2c 1fdd                      	rol r29
000f2d 93c0 28c4                 	sts triangle_pattern, r28
000f2f 93d0 28c5                 	sts triangle_pattern+1, r29
000f31 9220 28c6                 	sts triangle_pattern_delay_rows, zero
000f33 9220 28c7                 	sts triangle_pattern_delay_frames, zero
000f35 9220 28c8                 	sts triangle_pattern_offset, zero
000f37 9220 28c9                 	sts triangle_pattern_offset+1, zero
                                 
                                 	//CHANNEL 3
000f39 91c5                      	lpm r28, Z+
000f3a 91d5                      	lpm r29, Z+
000f3b 0fcc                      	lsl r28
000f3c 1fdd                      	rol r29
000f3d 93c0 2910                 	sts noise_pattern, r28
000f3f 93d0 2911                 	sts noise_pattern+1, r29
000f41 9220 2912                 	sts noise_pattern_delay_rows, zero
000f43 9220 2913                 	sts noise_pattern_delay_frames, zero
000f45 9220 2914                 	sts noise_pattern_offset, zero
000f47 9220 2915                 	sts noise_pattern_offset+1, zero
                                 
                                 	//CHANNEL 0 instrument macros
000f49 efcf                      	ldi r28, 0xFF
000f4a 9220 282a                 	sts pulse1_volume_macro_offset, zero
000f4c 93c0 282b                 	sts pulse1_volume_macro_loop, r28
000f4e 93c0 282c                 	sts pulse1_volume_macro_release, r28
000f50 9220 282f                 	sts pulse1_arpeggio_macro_offset, zero
000f52 93c0 2830                 	sts pulse1_arpeggio_macro_loop, r28
000f54 93c0 2831                 	sts pulse1_arpeggio_macro_release, r28
000f56 93c0 2832                 	sts pulse1_arpeggio_macro_mode, r28
000f58 9220 2837                 	sts pulse1_pitch_macro_offset, zero
000f5a 93c0 2838                 	sts pulse1_pitch_macro_loop, r28
000f5c 93c0 2839                 	sts pulse1_pitch_macro_release, r28
000f5e 9220 283d                 	sts pulse1_hi_pitch_macro_offset, zero
000f60 93c0 283e                 	sts pulse1_hi_pitch_macro_loop, r28
000f62 93c0 283f                 	sts pulse1_hi_pitch_macro_release, r28
000f64 9220 2842                 	sts pulse1_duty_macro_offset, zero
000f66 93c0 2843                 	sts pulse1_duty_macro_loop, r28
000f68 93c0 2844                 	sts pulse1_duty_macro_release, r28
                                 
000f6a 9220 2828                 	sts pulse1_volume_macro, zero
000f6c 9220 2829                 	sts pulse1_volume_macro+1, zero
000f6e 9220 282d                 	sts pulse1_arpeggio_macro, zero
000f70 9220 282e                 	sts pulse1_arpeggio_macro+1, zero
000f72 9220 2833                 	sts pulse1_total_pitch_offset, zero
000f74 9220 2834                 	sts pulse1_total_pitch_offset+1, zero
000f76 9220 2835                 	sts pulse1_pitch_macro, zero
000f78 9220 2836                 	sts pulse1_pitch_macro+1, zero
000f7a 9220 283a                 	sts pulse1_total_hi_pitch_offset, zero
000f7c 9220 283b                 	sts pulse1_hi_pitch_macro, zero
000f7e 9220 283c                 	sts pulse1_hi_pitch_macro+1, zero
000f80 9220 2840                 	sts pulse1_duty_macro, zero
000f82 9220 2841                 	sts pulse1_duty_macro+1, zero
                                 
                                 	//CHANNEL 0 ENVELOPE
000f84 e00f                      	ldi pulse1_volume_divider, 0x0F
000f85 9110 2800                 	lds pulse1_volume_decay, pulse1_param
000f87 701f                      	andi pulse1_volume_decay, 0x0F //mask for VVVV bits
000f88 9190 2800                 	lds pulse_channel_flags, pulse1_param
000f8a 7390                      	andi pulse_channel_flags, 0b00110000
000f8b 6490                      	sbr pulse_channel_flags, 0b01000000 //set start flag
000f8c 9220 2806                 	sts pulse1_output_volume, zero
000f8e 93c0 2805                 	sts pulse1_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 0 LENGTH
000f90 2ebc                      	mov pulse1_length_counter, r28
                                 
                                 	//CHANNEL 0 SEQUENCE
000f91 e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
000f92 2eac                      	mov pulse1_sequence, r28
                                 
                                 	//CHANNEL 0 SWEEP
000f93 90c0 2801                 	lds pulse1_sweep, pulse1_sweep_param
000f95 94c2                      	swap pulse1_sweep //swap data from high byte and low byte
000f96 6890                      	sbr pulse_channel_flags, 0b10000000 //set reload flag
                                 
                                 	//CHANNEL 0 FX
000f97 efcf                      	ldi r28, 0xFF
000f98 9220 2845                 	sts pulse1_fx_0xy_sequence, zero
000f9a 9220 2846                 	sts pulse1_fx_0xy_sequence+1, zero
000f9c 9220 2847                 	sts pulse1_fx_1xx, zero
000f9e 9220 2848                 	sts pulse1_fx_1xx+1, zero
000fa0 9220 2849                 	sts pulse1_fx_1xx_total, zero
000fa2 9220 284a                 	sts pulse1_fx_1xx_total+1, zero
000fa4 9220 284b                 	sts pulse1_fx_2xx, zero
000fa6 9220 284c                 	sts pulse1_fx_2xx+1, zero
000fa8 9220 284d                 	sts pulse1_fx_2xx_total, zero
000faa 9220 284e                 	sts pulse1_fx_2xx_total+1, zero
000fac 9220 284f                 	sts pulse1_fx_3xx_start, zero
000fae 9220 2850                 	sts pulse1_fx_3xx_start+1, zero
000fb0 9220 2851                 	sts pulse1_fx_3xx_target, zero
000fb2 9220 2852                 	sts pulse1_fx_3xx_target+1, zero
000fb4 9220 2853                 	sts pulse1_fx_3xx_speed, zero
000fb6 9220 2854                 	sts pulse1_fx_3xx_speed+1, zero
000fb8 9220 2855                 	sts pulse1_fx_3xx_total_offset, zero
000fba 9220 2856                 	sts pulse1_fx_3xx_total_offset+1, zero
000fbc 9220 2857                 	sts pulse1_fx_4xy_speed, zero
000fbe 9220 2858                 	sts pulse1_fx_4xy_depth, zero
000fc0 9220 2859                 	sts pulse1_fx_4xy_phase, zero
000fc2 9220 285a                 	sts pulse1_fx_7xy_speed, zero
000fc4 9220 285b                 	sts pulse1_fx_7xy_depth, zero
000fc6 9220 285c                 	sts pulse1_fx_7xy_phase, zero
000fc8 9220 285d                 	sts pulse1_fx_7xy_value, zero
000fca 9220 285e                 	sts pulse1_fx_Axy, zero
000fcc 93c0 285f                 	sts pulse1_fx_Gxx_pre, r28
000fce 93c0 2860                 	sts pulse1_fx_Gxx_post, r28
000fd0 9220 2861                 	sts pulse1_fx_Pxx_total, zero
000fd2 9220 2862                 	sts pulse1_fx_Pxx_total+1, zero
000fd4 9220 2863                 	sts pulse1_fx_Qxy_target_note, zero
000fd6 9220 2864                 	sts pulse1_fx_Qxy_target, zero
000fd8 9220 2865                 	sts pulse1_fx_Qxy_target+1, zero
000fda 9220 2866                 	sts pulse1_fx_Qxy_speed, zero
000fdc 9220 2867                 	sts pulse1_fx_Qxy_speed+1, zero
000fde 9220 2868                 	sts pulse1_fx_Qxy_total_offset, zero
000fe0 9220 2869                 	sts pulse1_fx_Qxy_total_offset+1, zero
000fe2 9220 286a                 	sts pulse1_fx_Rxy_target_note, zero
000fe4 9220 286b                 	sts pulse1_fx_Rxy_target, zero
000fe6 9220 286c                 	sts pulse1_fx_Rxy_target+1, zero
000fe8 9220 286d                 	sts pulse1_fx_Rxy_speed, zero
000fea 9220 286e                 	sts pulse1_fx_Rxy_speed+1, zero
000fec 9220 286f                 	sts pulse1_fx_Rxy_total_offset, zero
000fee 9220 2870                 	sts pulse1_fx_Rxy_total_offset+1, zero
000ff0 93c0 2871                 	sts pulse1_fx_Sxx_pre, r28
000ff2 93c0 2872                 	sts pulse1_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 1 instrument macros
000ff4 efcf                      	ldi r28, 0xFF
000ff5 9220 287b                 	sts pulse2_volume_macro_offset, zero
000ff7 93c0 287c                 	sts pulse2_volume_macro_loop, r28
000ff9 93c0 287d                 	sts pulse2_volume_macro_release, r28
000ffb 9220 2880                 	sts pulse2_arpeggio_macro_offset, zero
000ffd 93c0 2881                 	sts pulse2_arpeggio_macro_loop, r28
000fff 93c0 2882                 	sts pulse2_arpeggio_macro_release, r28
001001 93c0 2883                 	sts pulse2_arpeggio_macro_mode, r28
001003 9220 2888                 	sts pulse2_pitch_macro_offset, zero
001005 93c0 2889                 	sts pulse2_pitch_macro_loop, r28
001007 93c0 288a                 	sts pulse2_pitch_macro_release, r28
001009 9220 288e                 	sts pulse2_hi_pitch_macro_offset, zero
00100b 93c0 288f                 	sts pulse2_hi_pitch_macro_loop, r28
00100d 93c0 2890                 	sts pulse2_hi_pitch_macro_release, r28
00100f 9220 2893                 	sts pulse2_duty_macro_offset, zero
001011 93c0 2894                 	sts pulse2_duty_macro_loop, r28
001013 93c0 2895                 	sts pulse2_duty_macro_release, r28
                                 
001015 9220 2879                 	sts pulse2_volume_macro, zero
001017 9220 287a                 	sts pulse2_volume_macro+1, zero
001019 9220 287e                 	sts pulse2_arpeggio_macro, zero
00101b 9220 287f                 	sts pulse2_arpeggio_macro+1, zero
00101d 9220 2884                 	sts pulse2_total_pitch_offset, zero
00101f 9220 2885                 	sts pulse2_total_pitch_offset+1, zero
001021 9220 2886                 	sts pulse2_pitch_macro, zero
001023 9220 2887                 	sts pulse2_pitch_macro+1, zero
001025 9220 288b                 	sts pulse2_total_hi_pitch_offset, zero
001027 9220 288c                 	sts pulse2_hi_pitch_macro, zero
001029 9220 288d                 	sts pulse2_hi_pitch_macro+1, zero
00102b 9220 2891                 	sts pulse2_duty_macro, zero
00102d 9220 2892                 	sts pulse2_duty_macro+1, zero
                                 
                                 	//CHANNEL 1 ENVELOPE
00102f e02f                      	ldi pulse2_volume_divider, 0x0F
001030 9130 2808                 	lds pulse2_volume_decay, pulse2_param
001032 703f                      	andi pulse2_volume_decay, 0x0F //mask for VVVV bits
001033 91d0 2808                 	lds r29, pulse2_param
001035 73d0                      	andi r29, 0b00110000
001036 62d0                      	sbr r29, 0b0100000 //set start flag
001037 95d2                      	swap r29
001038 2b9d                      	or pulse_channel_flags, r29
001039 9220 280e                 	sts pulse2_output_volume, zero
00103b 93c0 280d                 	sts pulse2_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 1 LENGTH
00103d 2eec                      	mov pulse2_length_counter, r28
                                 
                                 	//CHANNEL 1 SEQUENCE
00103e e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
00103f 2edc                      	mov pulse2_sequence, r28
                                 
                                 	//CHANNEL 1 SWEEP
001040 90f0 2809                 	lds pulse2_sweep, pulse2_sweep_param
001042 94f2                      	swap pulse2_sweep //swap data from high byte and low byte
001043 6098                      	sbr pulse_channel_flags, 0b00001000 //set reload flag
                                 
                                 	//CHANNEL 1 FX
001044 efcf                      	ldi r28, 0xFF
001045 9220 2896                 	sts pulse2_fx_0xy_sequence, zero
001047 9220 2897                 	sts pulse2_fx_0xy_sequence+1, zero
001049 9220 2898                 	sts pulse2_fx_1xx, zero
00104b 9220 2899                 	sts pulse2_fx_1xx+1, zero
00104d 9220 289a                 	sts pulse2_fx_1xx_total, zero
00104f 9220 289b                 	sts pulse2_fx_1xx_total+1, zero
001051 9220 289c                 	sts pulse2_fx_2xx, zero
001053 9220 289d                 	sts pulse2_fx_2xx+1, zero
001055 9220 289e                 	sts pulse2_fx_2xx_total, zero
001057 9220 289f                 	sts pulse2_fx_2xx_total+1, zero
001059 9220 28a0                 	sts pulse2_fx_3xx_start, zero
00105b 9220 28a1                 	sts pulse2_fx_3xx_start+1, zero
00105d 9220 28a2                 	sts pulse2_fx_3xx_target, zero
00105f 9220 28a3                 	sts pulse2_fx_3xx_target+1, zero
001061 9220 28a4                 	sts pulse2_fx_3xx_speed, zero
001063 9220 28a5                 	sts pulse2_fx_3xx_speed+1, zero
001065 9220 28a6                 	sts pulse2_fx_3xx_total_offset, zero
001067 9220 28a7                 	sts pulse2_fx_3xx_total_offset+1, zero
001069 9220 28a8                 	sts pulse2_fx_4xy_speed, zero
00106b 9220 28a9                 	sts pulse2_fx_4xy_depth, zero
00106d 9220 28aa                 	sts pulse2_fx_4xy_phase, zero
00106f 9220 28ab                 	sts pulse2_fx_7xy_speed, zero
001071 9220 28ac                 	sts pulse2_fx_7xy_depth, zero
001073 9220 28ad                 	sts pulse2_fx_7xy_phase, zero
001075 9220 28ae                 	sts pulse2_fx_7xy_value, zero
001077 9220 28af                 	sts pulse2_fx_Axy, zero
001079 93c0 28b0                 	sts pulse2_fx_Gxx_pre, r28
00107b 93c0 28b1                 	sts pulse2_fx_Gxx_post, r28
00107d 9220 28b2                 	sts pulse2_fx_Pxx_total, zero
00107f 9220 28b3                 	sts pulse2_fx_Pxx_total+1, zero
001081 9220 28b4                 	sts pulse2_fx_Qxy_target_note, zero
001083 9220 28b5                 	sts pulse2_fx_Qxy_target, zero
001085 9220 28b6                 	sts pulse2_fx_Qxy_target+1, zero
001087 9220 28b7                 	sts pulse2_fx_Qxy_speed, zero
001089 9220 28b8                 	sts pulse2_fx_Qxy_speed+1, zero
00108b 9220 28b9                 	sts pulse2_fx_Qxy_total_offset, zero
00108d 9220 28ba                 	sts pulse2_fx_Qxy_total_offset+1, zero
00108f 9220 28bb                 	sts pulse2_fx_Rxy_target_note, zero
001091 9220 28bc                 	sts pulse2_fx_Rxy_target, zero
001093 9220 28bd                 	sts pulse2_fx_Rxy_target+1, zero
001095 9220 28be                 	sts pulse2_fx_Rxy_speed, zero
001097 9220 28bf                 	sts pulse2_fx_Rxy_speed+1, zero
001099 9220 28c0                 	sts pulse2_fx_Rxy_total_offset, zero
00109b 9220 28c1                 	sts pulse2_fx_Rxy_total_offset+1, zero
00109d 93c0 28c2                 	sts pulse2_fx_Sxx_pre, r28
00109f 93c0 28c3                 	sts pulse2_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 2 instrument macros
0010a1 efcf                      	ldi r28, 0xFF
0010a2 9220 28cc                 	sts triangle_volume_macro_offset, zero
0010a4 93c0 28cd                 	sts triangle_volume_macro_loop, r28
0010a6 93c0 28ce                 	sts triangle_volume_macro_release, r28
0010a8 9220 28d1                 	sts triangle_arpeggio_macro_offset, zero
0010aa 93c0 28d2                 	sts triangle_arpeggio_macro_loop, r28
0010ac 93c0 28d3                 	sts triangle_arpeggio_macro_release, r28
0010ae 93c0 28d4                 	sts triangle_arpeggio_macro_mode, r28
0010b0 9220 28d9                 	sts triangle_pitch_macro_offset, zero
0010b2 93c0 28da                 	sts triangle_pitch_macro_loop, r28
0010b4 93c0 28db                 	sts triangle_pitch_macro_release, r28
0010b6 9220 28df                 	sts triangle_hi_pitch_macro_offset, zero
0010b8 93c0 28e0                 	sts triangle_hi_pitch_macro_loop, r28
0010ba 93c0 28e1                 	sts triangle_hi_pitch_macro_release, r28
0010bc 9220 28e4                 	sts triangle_duty_macro_offset, zero
0010be 93c0 28e5                 	sts triangle_duty_macro_loop, r28
0010c0 93c0 28e6                 	sts triangle_duty_macro_release, r28
                                 
0010c2 9220 28ca                 	sts triangle_volume_macro, zero
0010c4 9220 28cb                 	sts triangle_volume_macro+1, zero
0010c6 9220 28cf                 	sts triangle_arpeggio_macro, zero
0010c8 9220 28d0                 	sts triangle_arpeggio_macro+1, zero
0010ca 9220 28d5                 	sts triangle_total_pitch_offset, zero
0010cc 9220 28d6                 	sts triangle_total_pitch_offset+1, zero
0010ce 9220 28d7                 	sts triangle_pitch_macro, zero
0010d0 9220 28d8                 	sts triangle_pitch_macro+1, zero
0010d2 9220 28dc                 	sts triangle_total_hi_pitch_offset, zero
0010d4 9220 28dd                 	sts triangle_hi_pitch_macro, zero
0010d6 9220 28de                 	sts triangle_hi_pitch_macro+1, zero
0010d8 9220 28e2                 	sts triangle_duty_macro, zero
0010da 9220 28e3                 	sts triangle_duty_macro+1, zero
                                 
                                 	//CHANNEL 2 SEQUENCE
0010dc e0c0                      	ldi r28, 0b00000000 //reset sequence to 0
0010dd 2f4c                      	mov triangle_sequence, r28
                                 
                                 	//CHANNEL 2 FX
0010de efcf                      	ldi r28, 0xFF
0010df 9220 28e7                 	sts triangle_fx_0xy_sequence, zero
0010e1 9220 28e8                 	sts triangle_fx_0xy_sequence+1, zero
0010e3 9220 28e9                 	sts triangle_fx_1xx, zero
0010e5 9220 28ea                 	sts triangle_fx_1xx+1, zero
0010e7 9220 28eb                 	sts triangle_fx_1xx_total, zero
0010e9 9220 28ec                 	sts triangle_fx_1xx_total+1, zero
0010eb 9220 28ed                 	sts triangle_fx_2xx, zero
0010ed 9220 28ee                 	sts triangle_fx_2xx+1, zero
0010ef 9220 28ef                 	sts triangle_fx_2xx_total, zero
0010f1 9220 28f0                 	sts triangle_fx_2xx_total+1, zero
0010f3 9220 28f1                 	sts triangle_fx_3xx_start, zero
0010f5 9220 28f2                 	sts triangle_fx_3xx_start+1, zero
0010f7 9220 28f3                 	sts triangle_fx_3xx_target, zero
0010f9 9220 28f4                 	sts triangle_fx_3xx_target+1, zero
0010fb 9220 28f5                 	sts triangle_fx_3xx_speed, zero
0010fd 9220 28f6                 	sts triangle_fx_3xx_speed+1, zero
0010ff 9220 28f7                 	sts triangle_fx_3xx_total_offset, zero
001101 9220 28f8                 	sts triangle_fx_3xx_total_offset+1, zero
001103 9220 28f9                 	sts triangle_fx_4xy_speed, zero
001105 9220 28fa                 	sts triangle_fx_4xy_depth, zero
001107 9220 28fb                 	sts triangle_fx_4xy_phase, zero
001109 93c0 28fc                 	sts triangle_fx_Gxx_pre, r28
00110b 93c0 28fd                 	sts triangle_fx_Gxx_post, r28
00110d 9220 28fe                 	sts triangle_fx_Pxx_total, zero
00110f 9220 28ff                 	sts triangle_fx_Pxx_total+1, zero
001111 9220 2900                 	sts triangle_fx_Qxy_target_note, zero
001113 9220 2901                 	sts triangle_fx_Qxy_target, zero
001115 9220 2902                 	sts triangle_fx_Qxy_target+1, zero
001117 9220 2903                 	sts triangle_fx_Qxy_speed, zero
001119 9220 2904                 	sts triangle_fx_Qxy_speed+1, zero
00111b 9220 2905                 	sts triangle_fx_Qxy_total_offset, zero
00111d 9220 2906                 	sts triangle_fx_Qxy_total_offset+1, zero
00111f 9220 2907                 	sts triangle_fx_Rxy_target_note, zero
001121 9220 2908                 	sts triangle_fx_Rxy_target, zero
001123 9220 2909                 	sts triangle_fx_Rxy_target+1, zero
001125 9220 290a                 	sts triangle_fx_Rxy_speed, zero
001127 9220 290b                 	sts triangle_fx_Rxy_speed+1, zero
001129 9220 290c                 	sts triangle_fx_Rxy_total_offset, zero
00112b 9220 290d                 	sts triangle_fx_Rxy_total_offset+1, zero
00112d 93c0 290e                 	sts triangle_fx_Sxx_pre, r28
00112f 93c0 290f                 	sts triangle_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 3 instrument macros
001131 efcf                      	ldi r28, 0xFF
001132 9220 2918                 	sts noise_volume_macro_offset, zero
001134 93c0 2919                 	sts noise_volume_macro_loop, r28
001136 93c0 291a                 	sts noise_volume_macro_release, r28
001138 9220 291d                 	sts noise_arpeggio_macro_offset, zero
00113a 93c0 291e                 	sts noise_arpeggio_macro_loop, r28
00113c 93c0 291f                 	sts noise_arpeggio_macro_release, r28
00113e 93c0 2920                 	sts noise_arpeggio_macro_mode, r28
001140 9220 2925                 	sts noise_pitch_macro_offset, zero
001142 93c0 2926                 	sts noise_pitch_macro_loop, r28
001144 93c0 2927                 	sts noise_pitch_macro_release, r28
001146 9220 292b                 	sts noise_hi_pitch_macro_offset, zero
001148 93c0 292c                 	sts noise_hi_pitch_macro_loop, r28
00114a 93c0 292d                 	sts noise_hi_pitch_macro_release, r28
00114c 9220 2930                 	sts noise_duty_macro_offset, zero
00114e 93c0 2931                 	sts noise_duty_macro_loop, r28
001150 93c0 2932                 	sts noise_duty_macro_release, r28
                                 
001152 9220 2916                 	sts noise_volume_macro, zero
001154 9220 2917                 	sts noise_volume_macro+1, zero
001156 9220 291b                 	sts noise_arpeggio_macro, zero
001158 9220 291c                 	sts noise_arpeggio_macro+1, zero
00115a 9220 2921                 	sts noise_total_pitch_offset, zero
00115c 9220 2922                 	sts noise_total_pitch_offset+1, zero
00115e 9220 2923                 	sts noise_pitch_macro, zero
001160 9220 2924                 	sts noise_pitch_macro+1, zero
001162 9220 2928                 	sts noise_total_hi_pitch_offset, zero
001164 9220 2929                 	sts noise_hi_pitch_macro, zero
001166 9220 292a                 	sts noise_hi_pitch_macro+1, zero
001168 9220 292e                 	sts noise_duty_macro, zero
00116a 9220 292f                 	sts noise_duty_macro+1, zero
                                 
                                 	//CHANNEL 3 VOLUME
00116c 9220 2816                 	sts noise_output_volume, zero
00116e 93c0 2815                 	sts noise_fractional_volume, r28 //initialize fractional volume to max value
                                 
                                 	//CHANNEL 3 SEQUENCE
001170 e0c1                      	ldi r28, 0b00000001 //noise sequence is reset to 0x0001
001171 2f5c                      	mov noise_sequence_LOW, r28
001172 2d62                      	mov noise_sequence_HIGH, zero
                                 
                                 	//CHANNEL 3 FX
001173 efcf                      	ldi r28, 0xFF
001174 9220 2933                 	sts noise_fx_0xy_sequence, zero
001176 9220 2934                 	sts noise_fx_0xy_sequence+1, zero
001178 9220 2935                 	sts noise_fx_1xx, zero
00117a 9220 2936                 	sts noise_fx_1xx+1, zero
00117c 9220 2937                 	sts noise_fx_1xx_total, zero
00117e 9220 2938                 	sts noise_fx_1xx_total+1, zero
001180 9220 2939                 	sts noise_fx_2xx, zero
001182 9220 293a                 	sts noise_fx_2xx+1, zero
001184 9220 293b                 	sts noise_fx_2xx_total, zero
001186 9220 293c                 	sts noise_fx_2xx_total+1, zero
001188 9220 293d                 	sts noise_fx_3xx_start, zero
00118a 9220 293e                 	sts noise_fx_3xx_start+1, zero
00118c 9220 293f                 	sts noise_fx_3xx_target, zero
00118e 9220 2940                 	sts noise_fx_3xx_target+1, zero
001190 9220 2941                 	sts noise_fx_3xx_speed, zero
001192 9220 2942                 	sts noise_fx_3xx_speed+1, zero
001194 9220 2943                 	sts noise_fx_3xx_total_offset, zero
001196 9220 2944                 	sts noise_fx_3xx_total_offset+1, zero
001198 9220 2945                 	sts noise_fx_4xy_speed, zero
00119a 9220 2946                 	sts noise_fx_4xy_depth, zero
00119c 9220 2947                 	sts noise_fx_4xy_phase, zero
00119e 9220 2948                 	sts noise_fx_7xy_speed, zero
0011a0 9220 2949                 	sts noise_fx_7xy_depth, zero
0011a2 9220 294a                 	sts noise_fx_7xy_phase, zero
0011a4 9220 294b                 	sts noise_fx_7xy_value, zero
0011a6 9220 294c                 	sts noise_fx_Axy, zero
0011a8 93c0 294d                 	sts noise_fx_Gxx_pre, r28
0011aa 93c0 294e                 	sts noise_fx_Gxx_post, r28
0011ac 9220 294f                 	sts noise_fx_Pxx_total, zero
0011ae 9220 2950                 	sts noise_fx_Pxx_total+1, zero
0011b0 9220 2951                 	sts noise_fx_Qxy_target_note, zero
0011b2 9220 2952                 	sts noise_fx_Qxy_target, zero
0011b4 9220 2953                 	sts noise_fx_Qxy_target+1, zero
0011b6 9220 2954                 	sts noise_fx_Qxy_speed, zero
0011b8 9220 2955                 	sts noise_fx_Qxy_speed+1, zero
0011ba 9220 2956                 	sts noise_fx_Qxy_total_offset, zero
0011bc 9220 2957                 	sts noise_fx_Qxy_total_offset+1, zero
0011be 9220 2958                 	sts noise_fx_Rxy_target_note, zero
0011c0 9220 2959                 	sts noise_fx_Rxy_target, zero
0011c2 9220 295a                 	sts noise_fx_Rxy_target+1, zero
0011c4 9220 295b                 	sts noise_fx_Rxy_speed, zero
0011c6 9220 295c                 	sts noise_fx_Rxy_speed+1, zero
0011c8 9220 295d                 	sts noise_fx_Rxy_total_offset, zero
0011ca 9220 295e                 	sts noise_fx_Rxy_total_offset+1, zero
0011cc 93c0 295f                 	sts noise_fx_Sxx_pre, r28
0011ce 93c0 2960                 	sts noise_fx_Sxx_post, r28
                                 
                                 	//PINS
0011d0 efcf                      	ldi r28, 0xFF
0011d1 b9c0                      	out VPORTA_DIR, r28 //set all pins in VPORTA to output
                                 
                                 	//TIMERS
                                 	//Frame Counter
                                 	//NOTE:The frame counter will be defaulted to NTSC mode (60 Hz, 120 Hz, 240 Hz)
                                 	//Each interrupt will be setup to interrupt every 240 Hz clock
                                 	//CMP0 = sequence 0, CMP1 = sequence 1, CMP2 = sequence 2, OVF = sequence 3/sound driver
                                 	//Sequence 3 will clock the sound driver every 60Hz, in which new audio data is read and written to the registers
                                 	//Timer period Calculation: (0.00416666666 * 20000000/64)-1 = 1301.08333125 = 0x0515
                                 	//The ATmega4809 is cofigured to run at 20000000 Hz
                                 	//0.00416666666 seconds is the period for 240 Hz
                                 	//The /64 comes from the prescaler divider used
0011d2 e7c0                      	ldi r28, TCA_SINGLE_CMP0EN_bm | TCA_SINGLE_CMP1EN_bm | TCA_SINGLE_CMP2EN_bm | TCA_SINGLE_WGMODE_NORMAL_gc //interrupt mode
0011d3 93c0 0a01                 	sts TCA0_SINGLE_CTRLB, r28
0011d5 e7c1                      	ldi r28, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP1_bm | TCA_SINGLE_CMP2_bm | TCA_SINGLE_OVF_bm //enable overflow and compare interrupts
0011d6 93c0 0a0a                 	sts TCA0_SINGLE_INTCTRL, r28
0011d8 e1c5                      	ldi r28, 0x15 //set the period for CMP0
0011d9 93c0 0a28                 	sts TCA0_SINGLE_CMP0, r28
0011db e0c5                      	ldi r28, 0x05
0011dc 93c0 0a29                 	sts TCA0_SINGLE_CMP0 + 1, r28
0011de e2cb                      	ldi r28, 0x2B //set the period for CMP1
0011df 93c0 0a2a                 	sts TCA0_SINGLE_CMP1, r28
0011e1 e0ca                      	ldi r28, 0x0A
0011e2 93c0 0a2b                 	sts TCA0_SINGLE_CMP1 + 1, r28
0011e4 e4c1                      	ldi r28, 0x41 //set the period for CMP2
0011e5 93c0 0a2c                 	sts TCA0_SINGLE_CMP2, r28
0011e7 e0cf                      	ldi r28, 0x0F
0011e8 93c0 0a2d                 	sts TCA0_SINGLE_CMP2 + 1, r28
0011ea e5c7                      	ldi r28, 0x57 //set the period for OVF
0011eb 93c0 0a26                 	sts TCA0_SINGLE_PER, r28
0011ed e1c4                      	ldi r28, 0x14
0011ee 93c0 0a27                 	sts TCA0_SINGLE_PER + 1, r28
0011f0 e0cb                      	ldi r28, TCA_SINGLE_CLKSEL_DIV64_gc | TCA_SINGLE_ENABLE_bm //use prescale divider of 64 and enable timer
0011f1 93c0 0a00                 	sts TCA0_SINGLE_CTRLA, r28
                                 
                                 	//NOTE: Channel Timers are clocked (20/2)/(0.8948865) = 11.1746014718 times faster than the NES APU
                                 	//Because of this, we multiply all the NES timer values by 11.1746014718 beforehand
                                 	//Since we rotate the sequence when the timer goes from t-(t-1) to 0, instead of 0 to t like the NES, we add 1 to the NES timers before multiplying
                                 	//The ATmega4809 is configured to run at 20 MHz
                                 	//The /2 comes from the prescaler divider used
                                 	//0.8948865 MHz is the speed of the NTSC NES APU
                                 	//NOTE: This means that any offset to the pitch for the NES timers would be multiplied by 11.1746014718 aswell.
                                 	//Pulse 1
0011f3 e0c0                      	ldi r28, TCB_CNTMODE_INT_gc //interrupt mode
0011f4 93c0 0a81                 	sts TCB0_CTRLB, r28
0011f6 e0c1                      	ldi r28, TCB_CAPT_bm //enable interrupts
0011f7 93c0 0a85                 	sts TCB0_INTCTRL, r28
0011f9 91c0 2802                 	lds r28, pulse1_timerL //load the LOW bits for timer
0011fb 93c0 0a8c                 	sts TCB0_CCMPL, r28
0011fd 91c0 2803                 	lds r28, pulse1_timerH //load the HIGH bits for timer
0011ff 93c0 0a8d                 	sts TCB0_CCMPH, r28
001201 e0c3                      	ldi r28, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
001202 93c0 0a80                 	sts TCB0_CTRLA, r28
                                 
                                 	//PULSE 2
001204 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
001205 93b0 0a91                 	sts TCB1_CTRLB, r27
001207 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001208 93b0 0a95                 	sts TCB1_INTCTRL, r27
00120a 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
00120c 93b0 0a9c                 	sts TCB1_CCMPL, r27
00120e 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
001210 93b0 0a9d                 	sts TCB1_CCMPH, r27
001212 e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
001213 93b0 0a90                 	sts TCB1_CTRLA, r27
                                 
                                 	//NOTE: The triangle timer is clocked at the same speed as the NES CPU, aka twice the NES APU.
                                 	//Therefore, we won't be using a /2 clock divider like we did with the pulse timers.
                                 	//TRIANGLE
001215 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
001216 93b0 0aa1                 	sts TCB2_CTRLB, r27
001218 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
                                 	//sts TCB2_INTCTRL, r27 //keep interrupts disabled to mute channel since triangle doesn't have volume bits
001219 91b0 2810                 	lds r27, triangle_timerL //load the LOW bits for timer
00121b 93b0 0aac                 	sts TCB2_CCMPL, r27
00121d 91b0 2811                 	lds r27, triangle_timerH //load the HIGH bits for timer
00121f 93b0 0aad                 	sts TCB2_CCMPH, r27
001221 e0b1                      	ldi r27, TCB_CLKSEL_CLKDIV1_gc | TCB_ENABLE_bm //use prescaler divider of 1 and enable timer
001222 93b0 0aa0                 	sts TCB2_CTRLA, r27
001224 9478                      	sei //global interrupt enable
                                 
                                 	//NOISE
001225 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
001226 93b0 0ab1                 	sts TCB3_CTRLB, r27
001228 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001229 93b0 0ab5                 	sts TCB3_INTCTRL, r27
00122b 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
00122d 93b0 0abc                 	sts TCB3_CCMPL, r27
00122f 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
001231 93b0 0abd                 	sts TCB3_CCMPH, r27
001233 e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
001234 93b0 0ab0                 	sts TCB3_CTRLA, r27
                                 
                                 
                                 
                                 //https://wiki.nesdev.com/w/index.php/APU_Mixer
                                 volume_mixer:
001236 91c0 2806                 	lds r28, pulse1_output_volume
001238 91d0 280e                 	lds r29, pulse2_output_volume
                                 
                                 volume_mixer_pulse1:
00123a fea0                      	sbrs pulse1_sequence, 0 //if the sequence output is zero, return
00123b c015                      	rjmp volume_mixer_pulse1_off
                                 
00123c 14b2                      	cp pulse1_length_counter, zero //if length is zero, return
00123d f099                      	breq volume_mixer_pulse1_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
00123e 91e0 0a8c                 	lds r30, TCB0_CCMPL
001240 e5f9                      	ldi r31, 0x059
001241 17ef                      	cp r30, r31
001242 91e0 0a8d                 	lds r30, TCB0_CCMPH
001244 e0f0                      	ldi r31, 0x00
001245 07ef                      	cpc r30, r31
001246 f050                      	brlo volume_mixer_pulse1_off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $5965
001247 91e0 0a8c                 	lds r30, TCB0_CCMPL
001249 e6f6                      	ldi r31, 0x66
00124a 17ef                      	cp r30, r31
00124b 91e0 0a8d                 	lds r30, TCB0_CCMPH
00124d e5f9                      	ldi r31, 0x59
00124e 07ef                      	cpc r30, r31
00124f f408                      	brsh volume_mixer_pulse1_off
001250 c001                      	rjmp volume_mixer_pulse2 //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse1_off:
001251 27cc                      	clr r28
                                 
                                 volume_mixer_pulse2:
001252 fed0                      	sbrs pulse2_sequence, 0 //if the sequence output is zero, return
001253 c015                      	rjmp volume_mixer_pulse2_off
                                 
001254 14e2                      	cp pulse2_length_counter, zero //if length is zero, return
001255 f099                      	breq volume_mixer_pulse2_off
                                 
001256 91e0 0a9c                 	lds r30, TCB1_CCMPL
001258 e5f9                      	ldi r31, 0x059
001259 17ef                      	cp r30, r31
00125a 91e0 0a9d                 	lds r30, TCB1_CCMPH
00125c e0f0                      	ldi r31, 0x00
00125d 07ef                      	cpc r30, r31
00125e f050                      	brlo volume_mixer_pulse2_off
                                 
00125f 91e0 0a9c                 	lds r30, TCB1_CCMPL
001261 e6f6                      	ldi r31, 0x66
001262 17ef                      	cp r30, r31
001263 91e0 0a9d                 	lds r30, TCB1_CCMPH
001265 e5f9                      	ldi r31, 0x59
001266 07ef                      	cpc r30, r31
001267 f408                      	brsh volume_mixer_pulse2_off
001268 c001                      	rjmp volume_mixer_pulse_out //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse2_off:
001269 27dd                      	clr r29
                                 
                                 volume_mixer_pulse_out:
00126a 0fcd                      	add r28, r29
00126b e6e2                      	ldi ZL, LOW(pulse_volume_table << 1)
00126c e0f2                      	ldi ZH, HIGH(pulse_volume_table << 1)
00126d 0fec                      	add ZL, r28
00126e 1df2                      	adc ZH, zero
00126f 91c4                      	lpm r28, Z
                                 
                                 volume_mixer_tnd_triangle:
001270 2fd4                      	mov r29, triangle_sequence
001271 fdd4                      	sbrc r29, 4 //check 5th bit
001272 95d0                      	com r29
001273 70df                      	andi r29, 0x0F
001274 2fed                      	mov r30, r29
001275 0fde                      	add r29, r30 //multiply the triangle volume by 3
001276 0fde                      	add r29, r30
                                 
                                 volume_mixer_tnd_noise:
001277 ff50                      	sbrs noise_sequence_LOW, 0 //check 0th bit, skip if set
001278 c004                      	rjmp volume_mixer_tnd_out
001279 91e0 2816                 	lds r30, noise_output_volume
00127b 0fee                      	lsl r30 //multiply noise volume by 2
00127c 0fde                      	add r29, r30
                                 
                                 volume_mixer_tnd_out:
00127d e8e2                      	ldi ZL, LOW(tnd_volume_table << 1)
00127e e0f2                      	ldi ZH, HIGH(tnd_volume_table << 1)
00127f 0fed                      	add ZL, r29
001280 1df2                      	adc ZH, zero
001281 91d4                      	lpm r29, Z
                                 
                                 volume_mixer_output:
001282 0fcd                      	add r28, r29
001283 b9c1                      	out VPORTA_OUT, r28
001284 cfb1                      	rjmp volume_mixer
                                 
                                 
                                 
                                 //FRAME COUNTER/AUDIO SAMPLE ISR
                                 sequence_0_2:
001285 b7bf                      	in r27, CPU_SREG
001286 93bf                      	push r27
001287 94f8                      	cli
                                 
                                 	//ENVELOPE
001288 d053                      	rcall pulse1_envelope_routine
001289 d09f                      	rcall pulse2_envelope_routine
                                 
00128a e5b0                      	ldi r27, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP2_bm //clear OVF flag
00128b 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
00128d 91bf                      	pop r27
00128e bfbf                      	out CPU_SREG, r27
00128f 9518                      	reti
                                 
                                 sequence_1_3:
001290 b7bf                      	in r27, CPU_SREG
001291 93bf                      	push r27
001292 94f8                      	cli
                                 
                                 	//ENVELOPE
001293 d048                      	rcall pulse1_envelope_routine
001294 d094                      	rcall pulse2_envelope_routine
                                 
                                 	//SWEEP
001295 fcc3                      	sbrc pulse1_sweep, 3 //check if the sweep enable bit is cleared
001296 d01b                      	rcall pulse1_sweep_routine
001297 fcf3                      	sbrc pulse2_sweep, 3
001298 d066                      	rcall pulse2_sweep_routine
                                 
                                 	//LENGTH
                                 	//NOTE: The length routine is relatively simple, so we will not be using clocks to rjmp and ret to a seperate lable
                                 sequence_1_3_pulse1_length:
001299 fd95                      	sbrc pulse_channel_flags, 5 //check if the length counter halt bit is cleared
00129a c002                      	rjmp sequence_1_3_pulse2_length
00129b 10b2                      	cpse pulse1_length_counter, zero //if length counter is already 0, don't decrement
00129c 94ba                      	dec pulse1_length_counter
                                 sequence_1_3_pulse2_length:
00129d fd91                      	sbrc pulse_channel_flags, 1 //check if the length counter halt bit is cleared
00129e c002                      	rjmp sequence_1_3_exit
00129f 10e2                      	cpse pulse2_length_counter, zero //if length counter is already 0, don't decrement
0012a0 94ea                      	dec pulse2_length_counter
                                 
                                 sequence_1_3_exit:
0012a1 e2b1                      	ldi r27, TCA_SINGLE_CMP1_bm | TCA_SINGLE_OVF_bm //clear OVF flag
0012a2 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
0012a4 91bf                      	pop r27
0012a5 bfbf                      	out CPU_SREG, r27
0012a6 9518                      	reti
                                 
                                 //PULSE 1 ROUTINES
                                 pulse1_sequence_routine:
0012a7 b7bf                      	in r27, CPU_SREG
0012a8 93bf                      	push r27
0012a9 94f8                      	cli
                                 
0012aa 0caa                      	lsl pulse1_sequence //shifts sequence to the left
0012ab 1ca2                      	adc pulse1_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
0012ac e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
0012ad 93b0 0a86                 	sts TCB0_INTFLAGS, r27
0012af 91bf                      	pop r27
0012b0 bfbf                      	out CPU_SREG, r27
0012b1 9518                      	reti
                                 
                                 pulse1_sweep_routine:
0012b2 2dbc                      	mov r27, pulse1_sweep
0012b3 70b7                      	andi r27, 0x07 //mask for period divider bits
0012b4 f4f9                      	brne pulse1_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse1_sweep_routine_action: //if the divider is == 0, update the pulse timer period
0012b5 93df                      	push r29
0012b6 2ddc                      	mov r29, pulse1_sweep
0012b7 95d2                      	swap r29
0012b8 70d7                      	andi r29, 0x07 //mask for shift bits
0012b9 f411                      	brne pulse1_sweep_routine_action_main //shift != 0
0012ba 91df                      	pop r29
0012bb c019                      	rjmp pulse1_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse1_sweep_routine_action_main:
0012bc 91a0 0a8c                 	lds r26, TCB0_CCMPL
0012be 91b0 0a8d                 	lds r27, TCB0_CCMPH
                                 pulse1_sweep_routine_action_main_loop:
0012c0 95b6                      	lsr r27
0012c1 95a7                      	ror r26
0012c2 95da                      	dec r29
0012c3 f7e1                      	brne pulse1_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
0012c4 fec7                      	sbrs pulse1_sweep, 7 //check the negate flag
0012c5 c002                      	rjmp pulse1_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
0012c6 95a0                      	com r26 //pulse1 uses one's complement if the negate flag is set
0012c7 95b0                      	com r27
                                 
                                 pulse1_sweep_routine_action_main_add:
0012c8 91d0 0a8c                 	lds r29, TCB0_CCMPL //perform addition to get new timer period
0012ca 0fad                      	add r26, r29
0012cb 91d0 0a8d                 	lds r29, TCB0_CCMPH
0012cd 1fbd                      	adc r27, r29
                                 
0012ce 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new LOW bits for timer
0012d0 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new HIGH bits for timer
                                 	
0012d2 91df                      	pop r29
0012d3 c001                      	rjmp pulse1_sweep_routine_check_reload
                                 
                                 pulse1_sweep_routine_decrement_divider:
0012d4 94ca                      	dec pulse1_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse1_sweep_routine_check_reload:
0012d5 ff97                      	sbrs pulse_channel_flags, 7 //if the reload flag is set, reload the sweep divider
0012d6 9508                      	ret
                                 
                                 pulse1_sweep_reload:
0012d7 90c0 2801                 	lds pulse1_sweep, pulse1_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
0012d9 94c2                      	swap pulse1_sweep //bring data from high byte to low byte
0012da 779f                      	cbr pulse_channel_flags, 0b10000000 //clear reload flag
0012db 9508                      	ret
                                 
                                 
                                 
                                 pulse1_envelope_routine:
0012dc fd96                      	sbrc pulse_channel_flags, 6 //check if start flag is cleared
0012dd c010                      	rjmp pulse1_envelope_routine_clear_start
                                 
0012de 3000                      	cpi pulse1_volume_divider, 0x00 //check if the divider is 0
0012df f011                      	breq PC+3 //if the divider == 0, check loop flag
0012e0 950a                      	dec pulse1_volume_divider //if the divider != 0, decrement and return
0012e1 9508                      	ret
                                 
0012e2 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the divider == 0, reset the divider period
0012e4 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
0012e5 ff95                      	sbrs pulse_channel_flags, 5 //check if the loop flag is set
0012e6 c002                      	rjmp pulse1_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
0012e7 e01f                      	ldi pulse1_volume_decay, 0x0F //if the loop flag is set, reset decay and return
0012e8 9508                      	ret
                                 
                                 pulse1_envelope_routine_decrement_decay:
0012e9 3010                      	cpi pulse1_volume_decay, 0x00 //check if the decay is 0
0012ea f409                      	brne PC+2 //if decay != 0, go decrement
0012eb 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
0012ec 951a                      	dec pulse1_volume_decay
0012ed 9508                      	ret
                                 
                                 pulse1_envelope_routine_clear_start:
0012ee 7b9f                      	cbr pulse_channel_flags, 0b01000000 //if the start flag is set, clear it
0012ef 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the start flag is set, reset the divider period
0012f1 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
0012f2 e01f                      	ldi pulse1_volume_decay, 0x0F //if the start flag is set, reset decay
0012f3 9508                      	ret
                                 
                                 //PULSE 2 ROUTINES
                                 pulse2_sequence_routine:
0012f4 b7bf                      	in r27, CPU_SREG
0012f5 93bf                      	push r27
0012f6 94f8                      	cli
                                 
0012f7 0cdd                      	lsl pulse2_sequence //shifts sequence to the left
0012f8 1cd2                      	adc pulse2_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
0012f9 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
0012fa 93b0 0a96                 	sts TCB1_INTFLAGS, r27
0012fc 91bf                      	pop r27
0012fd bfbf                      	out CPU_SREG, r27
0012fe 9518                      	reti
                                 
                                 pulse2_sweep_routine:
0012ff 2dbf                      	mov r27, pulse2_sweep
001300 70b7                      	andi r27, 0x07 //mask for period divider bits
001301 f4f9                      	brne pulse2_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse2_sweep_routine_action: //if the divider is == 0, update the pulse timer period
001302 93df                      	push r29
001303 2ddf                      	mov r29, pulse2_sweep
001304 95d2                      	swap r29
001305 70d7                      	andi r29, 0x07 //mask for shift bits
001306 f411                      	brne pulse2_sweep_routine_action_main //shift != 0
001307 91df                      	pop r29
001308 c019                      	rjmp pulse2_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse2_sweep_routine_action_main:
001309 91a0 0a9c                 	lds r26, TCB1_CCMPL
00130b 91b0 0a9d                 	lds r27, TCB1_CCMPH
                                 pulse2_sweep_routine_action_main_loop:
00130d 95b6                      	lsr r27
00130e 95a7                      	ror r26
00130f 95da                      	dec r29
001310 f7e1                      	brne pulse2_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
001311 fef7                      	sbrs pulse2_sweep, 7 //check the negate flag
001312 c002                      	rjmp pulse2_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
001313 95a0                      	com r26 //pulse2 uses one's complement if the negate flag is set
001314 95b0                      	com r27
                                 
                                 pulse2_sweep_routine_action_main_add:
001315 91d0 0a9c                 	lds r29, TCB1_CCMPL //perform addition to get new timer period
001317 0fad                      	add r26, r29
001318 91d0 0a9d                 	lds r29, TCB1_CCMPH
00131a 1fbd                      	adc r27, r29
                                 
00131b 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new LOW bits for timer
00131d 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new HIGH bits for timer
                                 	
00131f 91df                      	pop r29
001320 c001                      	rjmp pulse2_sweep_routine_check_reload
                                 
                                 pulse2_sweep_routine_decrement_divider:
001321 94fa                      	dec pulse2_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse2_sweep_routine_check_reload:
001322 ff93                      	sbrs pulse_channel_flags, 3 //if the reload flag is set, reload the sweep divider
001323 9508                      	ret
                                 
                                 pulse2_sweep_reload:
001324 90f0 2809                 	lds pulse2_sweep, pulse2_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
001326 94f2                      	swap pulse2_sweep //bring data from high byte to low byte
001327 7f97                      	cbr pulse_channel_flags, 0b00001000 //clear reload flag
001328 9508                      	ret
                                 
                                 
                                 
                                 pulse2_envelope_routine:
001329 fd92                      	sbrc pulse_channel_flags, 2 //check if start flag is cleared
00132a c010                      	rjmp pulse2_envelope_routine_clear_start
                                 
00132b 3020                      	cpi pulse2_volume_divider, 0x00 //check if the divider is 0
00132c f011                      	breq PC+3 //if the divider == 0, check loop flag
00132d 952a                      	dec pulse2_volume_divider //if the divider != 0, decrement and return
00132e 9508                      	ret
                                 
00132f 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the divider == 0, reset the divider period
001331 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
001332 ff91                      	sbrs pulse_channel_flags, 1 //check if the loop flag is set
001333 c002                      	rjmp pulse2_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
001334 e03f                      	ldi pulse2_volume_decay, 0x0F //if the loop flag is set, reset decay and return
001335 9508                      	ret
                                 
                                 pulse2_envelope_routine_decrement_decay:
001336 3030                      	cpi pulse2_volume_decay, 0x00 //check if the decay is 0
001337 f409                      	brne PC+2 //if decay != 0, go decrement
001338 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
001339 953a                      	dec pulse2_volume_decay
00133a 9508                      	ret
                                 
                                 pulse2_envelope_routine_clear_start:
00133b 7f9b                      	cbr pulse_channel_flags, 0b00000100 //if the start flag is set, clear it
00133c 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the start flag is set, reset the divider period
00133e 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
00133f e03f                      	ldi pulse2_volume_decay, 0x0F //if the start flag is set, reset decay
001340 9508                      	ret
                                 
                                 //TRIANGLE ROUTINES
                                 triangle_sequence_routine:
001341 b7bf                      	in r27, CPU_SREG
001342 93bf                      	push r27
001343 94f8                      	cli
                                 
001344 5f4f                      	subi triangle_sequence, -1 //increment sequence by 1
001345 714f                      	andi triangle_sequence, 0b00011111 //mask out bits 5, 6 and 7 NOTE: the sequence only needs bits 0-4.
                                 
001346 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
001347 93b0 0aa6                 	sts TCB2_INTFLAGS, r27
001349 91bf                      	pop r27
00134a bfbf                      	out CPU_SREG, r27
00134b 9518                      	reti
                                 
                                 //NOISE ROUTINES
                                 noise_sequence_routine:
00134c b7bf                      	in r27, CPU_SREG
00134d 93bf                      	push r27
00134e 94f8                      	cli
                                 
00134f 2fa5                      	mov r26, noise_sequence_LOW
001350 fd67                      	sbrc noise_sequence_HIGH, 7 //skip if MODE bit is clear
001351 c00b                      	rjmp noise_sequence_routine_mode_set
                                 
                                 noise_sequence_routine_mode_clear:
001352 95a6                      	lsr r26 //move the 1th bit to the 0th bit place
001353 27a5                      	eor r26, noise_sequence_LOW
001354 fda0                      	sbrc r26, 0 //skip if the EOR of bit 0 and 1 is clear
001355 c003                      	rjmp noise_sequence_routine_mode_clear_EOR_set
                                 
                                 noise_sequence_routine_mode_clear_EOR_clear:
001356 9566                      	lsr noise_sequence_HIGH
001357 9557                      	ror noise_sequence_LOW
001358 c013                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_clear_EOR_set:
001359 9566                      	lsr noise_sequence_HIGH
00135a 9557                      	ror noise_sequence_LOW
00135b 6460                      	ori noise_sequence_HIGH, 0b01000000 //set the 14th bit
00135c c00f                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_set:
00135d 0faa                      	lsl r26
00135e 1faa                      	rol r26
00135f 1faa                      	rol r26 //move the 6th bit to the 0th bit place
001360 27a5                      	eor r26, noise_sequence_LOW
001361 fda0                      	sbrc r26, 0 //skip if the EOR of bit 0 and 1 is clear
001362 c005                      	rjmp noise_sequence_routine_mode_set_EOR_set
                                 
                                 noise_sequence_routine_mode_set_EOR_clear:
001363 776f                      	cbr noise_sequence_HIGH, 0b10000000 //clear the MODE flag
001364 9566                      	lsr noise_sequence_HIGH
001365 9557                      	ror noise_sequence_LOW
001366 6860                      	sbr noise_sequence_HIGH, 0b10000000 //set the MODE flag
001367 c004                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_set_EOR_set:
001368 9566                      	lsr noise_sequence_HIGH
001369 9557                      	ror noise_sequence_LOW
00136a 6860                      	sbr noise_sequence_HIGH, 0b10000000 //set the MODE flag
00136b c000                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_exit:
00136c e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
00136d 93b0 0ab6                 	sts TCB3_INTFLAGS, r27
00136f 91bf                      	pop r27
001370 bfbf                      	out CPU_SREG, r27
001371 9518                      	reti
                                 
                                 //CONVERTERS
                                 //converts and loads 5 bit length to corresponding 8 bit length value into r29
                                 length_converter:
001372 e9e0                      	ldi ZL, LOW(length << 1)
001373 e5fb                      	ldi ZH, HIGH(length << 1)
001374 0fed                      	add ZL, r29
001375 1df2                      	adc ZH, zero
001376 91d4                      	lpm r29, Z
001377 9508                      	ret
                                 
                                 //loads pulse sequence into r29
                                 duty_cycle_sequences:
001378 ebe0                      	ldi ZL, LOW(sequences << 1)
001379 e5fb                      	ldi ZH, HIGH(sequences << 1)
00137a 0fed                      	add ZL, r29
00137b 1df2                      	adc ZH, zero
00137c 91d4                      	lpm r29, Z
00137d 9508                      	ret
                                 
                                 
                                 
                                 //SOUND DRIVER
                                 sound_driver:
00137e b7bf                      	in r27, CPU_SREG
00137f 93bf                      	push r27
001380 94f8                      	cli
001381 93cf                      	push r28
001382 93df                      	push r29
001383 93ef                      	push r30
001384 93ff                      	push r31
                                 
                                 	//SOUND DRIVER
001385 91a0 281f                 	lds r26, song_fx_Bxx
001387 3faf                      	cpi r26, 0xFF //0xFF means that the flag is disabled
001388 f4a9                      	brne sound_driver_fx_Bxx_routine
001389 91a0 2820                 	lds r26, song_fx_Cxx
00138b 11a2                      	cpse r26, zero
00138c c08b                      	rjmp sound_driver_fx_Cxx_routine
00138d 91a0 2821                 	lds r26, song_fx_Dxx
00138f 11a2                      	cpse r26, zero
001390 c096                      	rjmp sound_driver_fx_Dxx_routine
                                 
001391 91a0 281a                 	lds r26, song_frame_offset
001393 91b0 281b                 	lds r27, song_frame_offset+1
001395 91c0 281c                 	lds r28, song_size
001397 91d0 281d                 	lds r29, song_size+1
001399 17ac                      	cp r26, r28
00139a 07bd                      	cpc r27, r29
00139b f408                      	brsh sound_driver_fx_song_loop
00139c c101                      	rjmp sound_driver_channel0
                                 
                                 
                                 sound_driver_fx_song_loop:
00139d e0a0                      	ldi r26, 0x00
                                 sound_driver_fx_Bxx_routine:
00139e 91e0 2818                 	lds ZL, song_frames
0013a0 91f0 2819                 	lds ZH, song_frames+1
0013a2 27cc                      	clr r28 //initialize r29:r28 to 0
0013a3 27dd                      	clr r29
0013a4 95a3                      	inc r26 //increment xx parameter by 1
                                 sound_driver_fx_Bxx_routine_loop:
0013a5 95aa                      	dec r26
0013a6 f011                      	breq sound_driver_fx_Bxx_routine_loop_exit //once r26 == 0, r29:r28 will hold Bxx*(5*2).
0013a7 962a                      	adiw r29:r28, 10 //increment the offset by 10 because 5 channels, and each address takes 2 bytes (5*2 = 10)
0013a8 cffc                      	rjmp sound_driver_fx_Bxx_routine_loop
                                 
                                 sound_driver_fx_Bxx_routine_loop_exit:
0013a9 9622                      	adiw r29:r28, 2 //add 2 to skip the first 2 bytes (first 2 bytes is the song size)
0013aa 93c0 281a                 	sts song_frame_offset, r28
0013ac 93d0 281b                 	sts song_frame_offset+1, r29
0013ae 0fec                      	add ZL, r28
0013af 1ffd                      	adc ZH, r29
                                 
0013b0 91a5                      	lpm r26, Z+ //load the address of the frame(pattern)
0013b1 91b5                      	lpm r27, Z+
0013b2 0faa                      	lsl r26
0013b3 1fbb                      	rol r27
0013b4 93a0 2822                 	sts pulse1_pattern, r26
0013b6 93b0 2823                 	sts pulse1_pattern+1, r27
0013b8 91a5                      	lpm r26, Z+
0013b9 91b5                      	lpm r27, Z+
0013ba 0faa                      	lsl r26
0013bb 1fbb                      	rol r27
0013bc 93a0 2873                 	sts pulse2_pattern, r26
0013be 93b0 2874                 	sts pulse2_pattern+1, r27
0013c0 91a5                      	lpm r26, Z+
0013c1 91b5                      	lpm r27, Z+
0013c2 0faa                      	lsl r26
0013c3 1fbb                      	rol r27
0013c4 93a0 28c4                 	sts triangle_pattern, r26
0013c6 93b0 28c5                 	sts triangle_pattern+1, r27
0013c8 91a5                      	lpm r26, Z+
0013c9 91b5                      	lpm r27, Z+
0013ca 0faa                      	lsl r26
0013cb 1fbb                      	rol r27
0013cc 93a0 2910                 	sts noise_pattern, r26
0013ce 93b0 2911                 	sts noise_pattern+1, r27
                                 
0013d0 9220 2826                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
0013d2 9220 2827                 	sts pulse1_pattern_offset+1, zero
0013d4 9220 2824                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
0013d6 9220 2825                 	sts pulse1_pattern_delay_frames, zero
0013d8 9220 2877                 	sts pulse2_pattern_offset, zero
0013da 9220 2878                 	sts pulse2_pattern_offset+1, zero
0013dc 9220 2875                 	sts pulse2_pattern_delay_rows, zero
0013de 9220 2876                 	sts pulse2_pattern_delay_frames, zero
0013e0 9220 28c8                 	sts triangle_pattern_offset, zero
0013e2 9220 28c9                 	sts triangle_pattern_offset+1, zero
0013e4 9220 28c6                 	sts triangle_pattern_delay_rows, zero
0013e6 9220 28c7                 	sts triangle_pattern_delay_frames, zero
0013e8 9220 2914                 	sts noise_pattern_offset, zero
0013ea 9220 2915                 	sts noise_pattern_offset+1, zero
0013ec 9220 2912                 	sts noise_pattern_delay_rows, zero
0013ee 9220 2913                 	sts noise_pattern_delay_frames, zero
                                 
0013f0 efaf                      	ldi r26, 0xFF
0013f1 93a0 285f                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
0013f3 93a0 2860                 	sts pulse1_fx_Gxx_post, r26
0013f5 93a0 2871                 	sts pulse1_fx_Sxx_pre, r26
0013f7 93a0 2872                 	sts pulse1_fx_Sxx_post, r26
0013f9 93a0 28b0                 	sts pulse2_fx_Gxx_pre, r26
0013fb 93a0 28b1                 	sts pulse2_fx_Gxx_post, r26
0013fd 93a0 28c2                 	sts pulse2_fx_Sxx_pre, r26
0013ff 93a0 28c3                 	sts pulse2_fx_Sxx_post, r26
001401 93a0 28fc                 	sts triangle_fx_Gxx_pre, r26
001403 93a0 28fd                 	sts triangle_fx_Gxx_post, r26
001405 93a0 290e                 	sts triangle_fx_Sxx_pre, r26
001407 93a0 290f                 	sts triangle_fx_Sxx_post, r26
001409 93a0 294d                 	sts noise_fx_Gxx_pre, r26
00140b 93a0 294e                 	sts noise_fx_Gxx_post, r26
00140d 93a0 295f                 	sts noise_fx_Sxx_pre, r26
00140f 93a0 2960                 	sts noise_fx_Sxx_post, r26
                                 
001411 93a0 281f                 	sts song_fx_Bxx, r26 //reset all song effects
001413 9220 2820                 	sts song_fx_Cxx, zero
001415 9220 2821                 	sts song_fx_Dxx, zero
001417 c086                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_fx_Cxx_routine:
001418 91ff                      	pop r31
001419 91ef                      	pop r30
00141a 91df                      	pop r29
00141b 91cf                      	pop r28
00141c 91bf                      	pop r27
00141d bfbf                      	out CPU_SREG, r27
00141e 94f8                      	cli //disable global interrupts
                                 		
00141f efaf                      	ldi r26, 0xFF
001420 93a0 281f                 	sts song_fx_Bxx, r26 //reset all song effects
001422 9220 2820                 	sts song_fx_Cxx, zero
001424 9220 2821                 	sts song_fx_Dxx, zero
001426 9518                      	reti
                                 
                                 sound_driver_fx_Dxx_routine:
001427 91e0 2818                 	lds ZL, song_frames
001429 91f0 2819                 	lds ZH, song_frames+1
00142b 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
00142d 91b0 281b                 	lds r27, song_frame_offset+1
00142f 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
001430 93a0 281a                 	sts song_frame_offset, r26
001432 93b0 281b                 	sts song_frame_offset+1, r27
001434 0fea                      	add ZL, r26
001435 1ffb                      	adc ZH, r27
                                 
001436 91a5                      	lpm r26, Z+ //load the address of the next pattern
001437 91b5                      	lpm r27, Z+
001438 0faa                      	lsl r26
001439 1fbb                      	rol r27
00143a 93a0 2822                 	sts pulse1_pattern, r26
00143c 93b0 2823                 	sts pulse1_pattern+1, r27
00143e 91a5                      	lpm r26, Z+
00143f 91b5                      	lpm r27, Z+
001440 0faa                      	lsl r26
001441 1fbb                      	rol r27
001442 93a0 2873                 	sts pulse2_pattern, r26
001444 93b0 2874                 	sts pulse2_pattern+1, r27
001446 91a5                      	lpm r26, Z+
001447 91b5                      	lpm r27, Z+
001448 0faa                      	lsl r26
001449 1fbb                      	rol r27
00144a 93a0 28c4                 	sts triangle_pattern, r26
00144c 93b0 28c5                 	sts triangle_pattern+1, r27
00144e 91a5                      	lpm r26, Z+
00144f 91b5                      	lpm r27, Z+
001450 0faa                      	lsl r26
001451 1fbb                      	rol r27
001452 93a0 2910                 	sts noise_pattern, r26
001454 93b0 2911                 	sts noise_pattern+1, r27
                                 
001456 9220 2826                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001458 9220 2827                 	sts pulse1_pattern_offset+1, zero
00145a 9220 2824                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
00145c 9220 2825                 	sts pulse1_pattern_delay_frames, zero
00145e 9220 2877                 	sts pulse2_pattern_offset, zero
001460 9220 2878                 	sts pulse2_pattern_offset+1, zero
001462 9220 2875                 	sts pulse2_pattern_delay_rows, zero
001464 9220 2876                 	sts pulse2_pattern_delay_frames, zero
001466 9220 28c8                 	sts triangle_pattern_offset, zero
001468 9220 28c9                 	sts triangle_pattern_offset+1, zero
00146a 9220 28c6                 	sts triangle_pattern_delay_rows, zero
00146c 9220 28c7                 	sts triangle_pattern_delay_frames, zero
00146e 9220 2914                 	sts noise_pattern_offset, zero
001470 9220 2915                 	sts noise_pattern_offset+1, zero
001472 9220 2912                 	sts noise_pattern_delay_rows, zero
001474 9220 2913                 	sts noise_pattern_delay_frames, zero
                                 
001476 efaf                      	ldi r26, 0xFF
001477 93a0 285f                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
001479 93a0 2860                 	sts pulse1_fx_Gxx_post, r26
00147b 93a0 2871                 	sts pulse1_fx_Sxx_pre, r26
00147d 93a0 2872                 	sts pulse1_fx_Sxx_post, r26
00147f 93a0 28b0                 	sts pulse2_fx_Gxx_pre, r26
001481 93a0 28b1                 	sts pulse2_fx_Gxx_post, r26
001483 93a0 28c2                 	sts pulse2_fx_Sxx_pre, r26
001485 93a0 28c3                 	sts pulse2_fx_Sxx_post, r26
001487 93a0 28fc                 	sts triangle_fx_Gxx_pre, r26
001489 93a0 28fd                 	sts triangle_fx_Gxx_post, r26
00148b 93a0 290e                 	sts triangle_fx_Sxx_pre, r26
00148d 93a0 290f                 	sts triangle_fx_Sxx_post, r26
00148f 93a0 294d                 	sts noise_fx_Gxx_pre, r26
001491 93a0 294e                 	sts noise_fx_Gxx_post, r26
001493 93a0 295f                 	sts noise_fx_Sxx_pre, r26
001495 93a0 2960                 	sts noise_fx_Sxx_post, r26
                                 
001497 93a0 281f                 	sts song_fx_Bxx, r26 //reset all song effects
001499 9220 2820                 	sts song_fx_Cxx, zero
00149b 9220 2821                 	sts song_fx_Dxx, zero
00149d c000                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0:
00149e 91a0 2824                 	lds r26, pulse1_pattern_delay_rows
0014a0 91b0 2825                 	lds r27, pulse1_pattern_delay_frames
0014a2 9610                      	adiw r27:r26, 0
0014a3 f009                      	breq sound_driver_channel0_main //if the pattern delay is 0, proceed with sound driver procedures
0014a4 c2e8                      	rjmp sound_driver_channel0_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel0_main:
0014a5 91e0 2822                 	lds ZL, pulse1_pattern //current pattern for pulse 1
0014a7 91f0 2823                 	lds ZH, pulse1_pattern+1
0014a9 91a0 2826                 	lds r26, pulse1_pattern_offset //current offset in the pattern for pulse 1
0014ab 91b0 2827                 	lds r27, pulse1_pattern_offset+1
0014ad 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
0014ae 1ffb                      	adc ZH, r27
0014af 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel0_check_if_note: //check if data is a note (0x00 - 0x56)
0014b0 35b7                      	cpi r27, 0x57
0014b1 f408                      	brsh sound_driver_channel0_check_if_volume
0014b2 c184                      	rjmp sound_driver_channel0_note
                                 sound_driver_channel0_check_if_volume: //check if data is volume (0x57-0x66)
0014b3 36b7                      	cpi r27, 0x67
0014b4 f408                      	brsh sound_driver_channel0_check_if_delay
0014b5 c1be                      	rjmp sound_driver_channel0_volume
                                 sound_driver_channel0_check_if_delay: //check if data is a delay (0x67 - 0xE2)
0014b6 3eb3                      	cpi r27, 0xE3
0014b7 f408                      	brsh sound_driver_channel0_check_if_instrument
0014b8 c1c5                      	rjmp sound_driver_channel0_delay
                                 sound_driver_channel0_check_if_instrument: //check for instrument flag (0xE3)
0014b9 f409                      	brne sound_driver_channel0_check_if_release
0014ba c1c8                      	rjmp sound_driver_channel0_instrument_change 
                                 sound_driver_channel0_check_if_release: //check for note release flag (0xE4)
0014bb 3eb4                      	cpi r27, 0xE4
0014bc f409                      	brne sound_driver_channel0_check_if_end
0014bd c271                      	rjmp sound_driver_channel0_release
                                 sound_driver_channel0_check_if_end:
0014be 3fbf                      	cpi r27, 0xFF
0014bf f409                      	brne sound_driver_channel0_check_if_fx
0014c0 c293                      	rjmp sound_driver_channel0_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel0_check_if_fx: //fx flags (0xE5 - 0xFE)
0014c1 9631                      	adiw Z, 1 //point Z to the byte next to the flag
0014c2 91a4                      	lpm r26, Z //load the fx data into r26
0014c3 d2bf                      	rcall sound_driver_channel0_increment_offset_twice
                                 
0014c4 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
0014c5 ebe4                      	ldi ZL, LOW(channel0_fx << 1) //load in note table
0014c6 e5fb                      	ldi ZH, HIGH(channel0_fx << 1)
0014c7 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
0014c8 0feb                      	add ZL, r27 //add offset
0014c9 1df2                      	adc ZH, zero
0014ca 91c5                      	lpm r28, Z+ //load address bytes
0014cb 91d4                      	lpm r29, Z
0014cc 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
0014cd 2ffd                      	mov ZH, r29
0014ce 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel0_fx_0xy:
0014cf 93a0 2845                 	sts pulse1_fx_0xy_sequence, r26
0014d1 9220 2846                 	sts pulse1_fx_0xy_sequence+1, zero
0014d3 cfd1                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel0_fx_1xx:
0014d4 9220 284b                 	sts pulse1_fx_2xx, zero //turn off any 2xx pitch slide down
0014d6 9220 284c                 	sts pulse1_fx_2xx+1, zero
0014d8 9220 2845                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
0014da 9220 2846                 	sts pulse1_fx_0xy_sequence+1, zero
0014dc 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0014dd 937f                      	push r23
0014de 2f6a                      	mov r22, r26 //store the rate into r22
0014df eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0014e0 9f67                      	mul r22, r23
0014e1 917f                      	pop r23
0014e2 916f                      	pop r22
                                 
0014e3 9416                      	lsr r1 //shift out the fractional bits
0014e4 9407                      	ror r0
0014e5 9416                      	lsr r1
0014e6 9407                      	ror r0
0014e7 9416                      	lsr r1
0014e8 9407                      	ror r0
0014e9 9416                      	lsr r1
0014ea 9407                      	ror r0
0014eb 9200 2847                 	sts pulse1_fx_1xx, r0
0014ed 9210 2848                 	sts pulse1_fx_1xx+1, r1
0014ef cfb5                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel0_fx_2xx:
0014f0 9220 2847                 	sts pulse1_fx_1xx, zero //turn off any 1xx pitch slide down
0014f2 9220 2848                 	sts pulse1_fx_1xx+1, zero
0014f4 9220 2845                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
0014f6 9220 2846                 	sts pulse1_fx_0xy_sequence+1, zero
0014f8 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0014f9 937f                      	push r23
0014fa 2f6a                      	mov r22, r26 //store the rate into r22
0014fb eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0014fc 9f67                      	mul r22, r23
0014fd 917f                      	pop r23
0014fe 916f                      	pop r22
                                 
0014ff 9416                      	lsr r1 //shift out the fractional bits
001500 9407                      	ror r0
001501 9416                      	lsr r1
001502 9407                      	ror r0
001503 9416                      	lsr r1
001504 9407                      	ror r0
001505 9416                      	lsr r1
001506 9407                      	ror r0
001507 9200 284b                 	sts pulse1_fx_2xx, r0
001509 9210 284c                 	sts pulse1_fx_2xx+1, r1
00150b cf99                      	rjmp sound_driver_channel0_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel0_fx_3xx:
00150c 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00150d 937f                      	push r23
00150e 2f6a                      	mov r22, r26 //store the rate into r22
00150f eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001510 9f67                      	mul r22, r23
001511 917f                      	pop r23
001512 916f                      	pop r22
                                 
001513 9416                      	lsr r1 //shift out the fractional bits
001514 9407                      	ror r0
001515 9416                      	lsr r1
001516 9407                      	ror r0
001517 9416                      	lsr r1
001518 9407                      	ror r0
001519 9416                      	lsr r1
00151a 9407                      	ror r0
00151b 9200 2853                 	sts pulse1_fx_3xx_speed, r0
00151d 9210 2854                 	sts pulse1_fx_3xx_speed+1, r1
                                 
00151f 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001520 c001                      	rjmp sound_driver_channel0_fx_3xx_enabled
001521 cf83                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_3xx_enabled:
001522 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001524 91b0 0a8d                 	lds r27, TCB0_CCMPH
001526 93a0 284f                 	sts pulse1_fx_3xx_start, r26
001528 93b0 2850                 	sts pulse1_fx_3xx_start+1, r27
                                 
00152a 9220 2855                 	sts pulse1_fx_3xx_total_offset, zero
00152c 9220 2856                 	sts pulse1_fx_3xx_total_offset+1, zero
00152e cf76                      	rjmp sound_driver_channel0_main
                                 
                                 //VIBRATO
                                 sound_driver_channel0_fx_4xy:
00152f 2fba                      	mov r27, r26
001530 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001531 95a2                      	swap r26
001532 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001533 93a0 2857                 	sts pulse1_fx_4xy_speed, r26
001535 93b0 2858                 	sts pulse1_fx_4xy_depth, r27
001537 9220 2859                 	sts pulse1_fx_4xy_phase, zero //reset the phase to 0
001539 cf6b                      	rjmp sound_driver_channel0_main
                                 
                                 //TREMELO
                                 sound_driver_channel0_fx_7xy:
00153a 2fba                      	mov r27, r26
00153b 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
00153c 95a2                      	swap r26
00153d 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
00153e 93a0 285a                 	sts pulse1_fx_7xy_speed, r26
001540 93b0 285b                 	sts pulse1_fx_7xy_depth, r27
001542 9220 285c                 	sts pulse1_fx_7xy_phase, zero //reset the phase to 0
001544 9220 285d                 	sts pulse1_fx_7xy_value, zero //reset the tremelo value
001546 cf5e                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel0_fx_Axy:
001547 93a0 285e                 	sts pulse1_fx_Axy, r26
001549 cf5b                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel0_fx_Bxx:
00154a 93a0 281f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
00154c cf58                      	rjmp sound_driver_channel0_main
                                 
                                 //HALT
                                 sound_driver_channel0_fx_Cxx:
00154d 93b0 2820                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
00154f cf55                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel0_fx_Dxx:
001550 93b0 2821                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001552 cf52                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME
                                 sound_driver_channel0_fx_Exx:
001553 91b0 2800                 	lds r27, pulse1_param
001555 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
001556 2bba                      	or r27, r26 //move new VVVV bits into pulse1_param
001557 93b0 2800                 	sts pulse1_param, r27
001559 6096                      	sbr pulse_channel_flags, 6
00155a cf4a                      	rjmp sound_driver_channel0_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel0_fx_Fxx:
00155b 93a0 281e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
00155d cf47                      	rjmp sound_driver_channel0_main
                                 
                                 //DELAY
                                 sound_driver_channel0_fx_Gxx:
00155e 15a2                      	cp r26, zero
00155f f051                      	breq sound_driver_channel0_fx_Gxx_invalid
001560 91b0 281e                 	lds r27, song_speed
001562 17ab                      	cp r26, r27
001563 f430                      	brsh sound_driver_channel0_fx_Gxx_invalid
001564 93a0 285f                 	sts pulse1_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001566 e0b1                      	ldi r27, 0x01
001567 93b0 2824                 	sts pulse1_pattern_delay_rows, r27
001569 c226                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Gxx_invalid:
00156a cf3a                      	rjmp sound_driver_channel0_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel0_fx_Hxy: //hardware sweep up
00156b cf39                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixy: //hardware sweep down
00156c cf38                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Hxx: //FDS modulation depth
00156d cf37                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixx: //FDS modulation speed
00156e cf36                      	rjmp sound_driver_channel0_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel0_fx_Pxx:
00156f 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001570 937f                      	push r23
001571 2f6a                      	mov r22, r26
001572 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001573 0367                      	mulsu r22, r23
001574 917f                      	pop r23
001575 916f                      	pop r22
001576 9416                      	lsr r1 //shift out the fractional bits
001577 9407                      	ror r0
001578 9416                      	lsr r1
001579 9407                      	ror r0
00157a 9416                      	lsr r1
00157b 9407                      	ror r0
00157c 9416                      	lsr r1
00157d 9407                      	ror r0
00157e fe13                      	sbrs r1, 3 //check if result was a negative number
00157f c002                      	rjmp sound_driver_channel0_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel0_fx_Pxx_negative:
001580 efb0                      	ldi r27, 0xF0
001581 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel0_fx_Pxx_store:
001582 9200 2861                 	sts pulse1_fx_Pxx_total, r0
001584 9210 2862                 	sts pulse1_fx_Pxx_total+1, r1
001586 cf1e                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel0_fx_Qxy:
                                 sound_driver_channel0_fx_Qxy_check_arpeggio_macro:
001587 91e0 282d                 	lds ZL, pulse1_arpeggio_macro
001589 91f0 282e                 	lds ZH, pulse1_arpeggio_macro+1
00158b 9630                      	adiw Z, 0
00158c f009                      	breq sound_driver_channel0_fx_Qxy_check_pitch_macro
00158d cf17                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_pitch_macro:
00158e 91e0 2835                 	lds ZL, pulse1_pitch_macro
001590 91f0 2836                 	lds ZH, pulse1_pitch_macro+1
001592 9630                      	adiw Z, 0
001593 f009                      	breq sound_driver_channel0_fx_Qxy_check_hi_pitch_macro
001594 cf10                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_hi_pitch_macro:
001595 91e0 283b                 	lds ZL, pulse1_hi_pitch_macro
001597 91f0 283c                 	lds ZH, pulse1_hi_pitch_macro+1
001599 9630                      	adiw Z, 0
00159a f009                      	breq sound_driver_channel0_fx_Qxy_process
00159b cf09                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_process:
00159c 2fba                      	mov r27, r26 //copy fx parameters into r27
00159d 70bf                      	andi r27, 0x0F //mask note index offset
00159e 91c0 2807                 	lds r28, pulse1_note //load current note index
0015a0 0fbc                      	add r27, r28
0015a1 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
0015a2 f008                      	brlo sound_driver_channel0_fx_Qxy_process_continue
0015a3 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel0_fx_Qxy_process_continue:
0015a4 93b0 2863                 	sts pulse1_fx_Qxy_target_note, r27
0015a6 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0015a7 e0f0                      	ldi ZH, HIGH(note_table << 1)
0015a8 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
0015a9 0feb                      	add ZL, r27 //add offset
0015aa 1df2                      	adc ZH, zero
0015ab 91c5                      	lpm r28, Z+ //load bytes
0015ac 91d4                      	lpm r29, Z
0015ad 93c0 2864                 	sts pulse1_fx_Qxy_target, r28 //load the LOW bits for the target period
0015af 93d0 2865                 	sts pulse1_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
0015b1 95a2                      	swap r26
0015b2 70af                      	andi r26, 0x0F //mask effect speed
0015b3 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0015b4 95a3                      	inc r26 //increment the speed by 1
                                 
0015b5 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0015b6 937f                      	push r23
0015b7 2f6a                      	mov r22, r26 //store the speed data into r27
0015b8 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0015b9 9f67                      	mul r22, r23
0015ba 917f                      	pop r23
0015bb 916f                      	pop r22
                                 
0015bc 9416                      	lsr r1 //shift out the fractional bits
0015bd 9407                      	ror r0
0015be 9416                      	lsr r1
0015bf 9407                      	ror r0
0015c0 9416                      	lsr r1
0015c1 9407                      	ror r0
0015c2 9416                      	lsr r1
0015c3 9407                      	ror r0
                                 
0015c4 9200 2866                 	sts pulse1_fx_Qxy_speed, r0 //store the effect speed
0015c6 9210 2867                 	sts pulse1_fx_Qxy_speed+1, r1
0015c8 9220 2868                 	sts pulse1_fx_Qxy_total_offset, zero
0015ca 9220 2869                 	sts pulse1_fx_Qxy_total_offset+1, zero
0015cc ced8                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel0_fx_Rxy:
                                 sound_driver_channel0_fx_Rxy_check_arpeggio_macro:
0015cd 91e0 282d                 	lds ZL, pulse1_arpeggio_macro
0015cf 91f0 282e                 	lds ZH, pulse1_arpeggio_macro+1
0015d1 9630                      	adiw Z, 0
0015d2 f009                      	breq sound_driver_channel0_fx_Rxy_check_pitch_macro
0015d3 ced1                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_pitch_macro:
0015d4 91e0 2835                 	lds ZL, pulse1_pitch_macro
0015d6 91f0 2836                 	lds ZH, pulse1_pitch_macro+1
0015d8 9630                      	adiw Z, 0
0015d9 f009                      	breq sound_driver_channel0_fx_Rxy_check_hi_pitch_macro
0015da ceca                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_hi_pitch_macro:
0015db 91e0 283b                 	lds ZL, pulse1_hi_pitch_macro
0015dd 91f0 283c                 	lds ZH, pulse1_hi_pitch_macro+1
0015df 9630                      	adiw Z, 0
0015e0 f009                      	breq sound_driver_channel0_fx_Rxy_process
0015e1 cec3                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_process:
0015e2 2fba                      	mov r27, r26 //copy fx parameters into r27
0015e3 70bf                      	andi r27, 0x0F //mask note index offset
0015e4 91c0 2807                 	lds r28, pulse1_note //load current note index
0015e6 1bcb                      	sub r28, r27
0015e7 f408                      	brcc sound_driver_channel0_fx_Rxy_process_continue
0015e8 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel0_fx_Rxy_process_continue:
0015e9 93c0 286a                 	sts pulse1_fx_Rxy_target_note, r28
0015eb e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0015ec e0f0                      	ldi ZH, HIGH(note_table << 1)
0015ed 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
0015ee 0fec                      	add ZL, r28 //add offset
0015ef 1df2                      	adc ZH, zero
0015f0 91c5                      	lpm r28, Z+ //load bytes
0015f1 91d4                      	lpm r29, Z
0015f2 93c0 286b                 	sts pulse1_fx_Rxy_target, r28 //load the LOW bits for the target period
0015f4 93d0 286c                 	sts pulse1_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
0015f6 95a2                      	swap r26
0015f7 70af                      	andi r26, 0x0F //mask effect speed
0015f8 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0015f9 95a3                      	inc r26 //increment the speed by 1
                                 
0015fa 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0015fb 937f                      	push r23
0015fc 2f6a                      	mov r22, r26 //store the speed data into r27
0015fd eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0015fe 9f67                      	mul r22, r23
0015ff 917f                      	pop r23
001600 916f                      	pop r22
                                 
001601 9416                      	lsr r1 //shift out the fractional bits
001602 9407                      	ror r0
001603 9416                      	lsr r1
001604 9407                      	ror r0
001605 9416                      	lsr r1
001606 9407                      	ror r0
001607 9416                      	lsr r1
001608 9407                      	ror r0
                                 
001609 9200 286d                 	sts pulse1_fx_Rxy_speed, r0 //store the effect speed
00160b 9210 286e                 	sts pulse1_fx_Rxy_speed+1, r1
00160d 9220 286f                 	sts pulse1_fx_Rxy_total_offset, zero
00160f 9220 2870                 	sts pulse1_fx_Rxy_total_offset+1, zero
001611 ce93                      	rjmp sound_driver_channel0_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel0_fx_Sxx:
001612 15a2                      	cp r26, zero
001613 f051                      	breq sound_driver_channel0_fx_Sxx_invalid
001614 91b0 281e                 	lds r27, song_speed
001616 17ab                      	cp r26, r27
001617 f430                      	brsh sound_driver_channel0_fx_Sxx_invalid
001618 93a0 2871                 	sts pulse1_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
00161a e0b1                      	ldi r27, 0x01
00161b 93b0 2824                 	sts pulse1_pattern_delay_rows, r27
00161d c172                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Sxx_invalid:
00161e ce86                      	rjmp sound_driver_channel0_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel0_fx_Vxx:
00161f ebe0                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
001620 e5fb                      	ldi ZH, HIGH(sequences << 1)
001621 0fea                      	add ZL, r26 //offset the pointer
001622 1df2                      	adc ZH, zero
                                 
001623 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
001624 95a7                      	ror r26
001625 95a7                      	ror r26
001626 91b0 2800                 	lds r27, pulse1_param //load r27 with pulse1_param (register $4000)
001628 2fcb                      	mov r28, r27 //store a copy of pulse1_param into r28
001629 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
00162a 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
00162b c001                      	rjmp sound_driver_channel0_fx_Vxx_store
00162c ce78                      	rjmp sound_driver_channel0_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel0_fx_Vxx_store:
00162d 90a4                      	lpm pulse1_sequence, Z //store the sequence
                                 
00162e 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
00162f 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
001630 93c0 2800                 	sts pulse1_param, r28
001632 ce72                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_Wxx: //DPCM sample speed
001633 ce71                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Xxx: //DPCM sample retrigger
001634 ce70                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Yxx: //DPCM sample offset
001635 ce6f                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Zxx: //DPCM sample delta counter
001636 ce6e                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 sound_driver_channel0_note:
001637 93b0 2807                 	sts pulse1_note, r27 //store the note index
001639 e0a3                      	ldi r26, 0x03
00163a e0b2                      	ldi r27, 0x02
00163b 93b0 282a                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
00163d 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26
00163f 93b0 2837                 	sts pulse1_pitch_macro_offset, r27
001641 93b0 283d                 	sts pulse1_hi_pitch_macro_offset, r27
001643 93b0 2842                 	sts pulse1_duty_macro_offset, r27
001645 9220 2833                 	sts pulse1_total_pitch_offset, zero //reset the pitch and hi pitch offset
001647 9220 2834                 	sts pulse1_total_pitch_offset+1, zero
001649 9220 283a                 	sts pulse1_total_hi_pitch_offset, zero
00164b 9220 2849                 	sts pulse1_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
00164d 9220 284a                 	sts pulse1_fx_1xx_total+1, zero
00164f 9220 284d                 	sts pulse1_fx_2xx_total, zero
001651 9220 284e                 	sts pulse1_fx_2xx_total+1, zero
001653 9220 2855                 	sts pulse1_fx_3xx_total_offset, zero //reset 3xx offset
001655 9220 2856                 	sts pulse1_fx_3xx_total_offset+1, zero
001657 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001659 91b0 0a8d                 	lds r27, TCB0_CCMPH
00165b 93a0 284f                 	sts pulse1_fx_3xx_start, r26
00165d 93b0 2850                 	sts pulse1_fx_3xx_start+1, r27
00165f 9220 2801                 	sts pulse1_sweep_param, zero //reset any sweep effect
001661 6097                      	sbr pulse_channel_flags, 7 //set reload flag
001662 9220 2864                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001664 9220 2865                 	sts pulse1_fx_Qxy_target+1, zero
001666 9220 2868                 	sts pulse1_fx_Qxy_total_offset, zero
001668 9220 2869                 	sts pulse1_fx_Qxy_total_offset+1, zero
00166a 9220 286b                 	sts pulse1_fx_Rxy_target, zero
00166c 9220 286c                 	sts pulse1_fx_Rxy_target+1, zero
00166e 9220 286f                 	sts pulse1_fx_Rxy_total_offset, zero
001670 9220 2870                 	sts pulse1_fx_Rxy_total_offset+1, zero
001672 d106                      	rcall sound_driver_channel0_increment_offset
001673 ce31                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_volume:
001674 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001675 91a0 2800                 	lds r26, pulse1_param
001677 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001678 2bab                      	or r26, r27 //move new VVVV bits into pulse1_param
001679 93a0 2800                 	sts pulse1_param, r26
00167b 6096                      	sbr pulse_channel_flags, 6
00167c d0fc                      	rcall sound_driver_channel0_increment_offset
00167d ce27                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_delay:
00167e 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
00167f 93b0 2824                 	sts pulse1_pattern_delay_rows, r27
001681 d0f7                      	rcall sound_driver_channel0_increment_offset
001682 c10d                      	rjmp sound_driver_channel1
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change:
001683 9220 2828                 	sts pulse1_volume_macro, zero //reset all macro addresses
001685 9220 2829                 	sts pulse1_volume_macro+1, zero
001687 9220 282d                 	sts pulse1_arpeggio_macro, zero
001689 9220 282e                 	sts pulse1_arpeggio_macro+1, zero
00168b 9220 2835                 	sts pulse1_pitch_macro, zero
00168d 9220 2836                 	sts pulse1_pitch_macro+1, zero
00168f 9220 283b                 	sts pulse1_hi_pitch_macro, zero
001691 9220 283c                 	sts pulse1_hi_pitch_macro+1, zero
001693 9220 2840                 	sts pulse1_duty_macro, zero
001695 9220 2841                 	sts pulse1_duty_macro+1, zero
001697 9220 2833                 	sts pulse1_total_pitch_offset, zero //reset the pitch offset
001699 9220 2834                 	sts pulse1_total_pitch_offset+1, zero
00169b 9220 283a                 	sts pulse1_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
00169d 9631                      	adiw Z, 1 //point to the byte next to the flag
00169e 91b4                      	lpm r27, Z //store the instrument offset into r27
00169f e2ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
0016a0 e0fd                      	ldi ZH, HIGH(instruments)
0016a1 0feb                      	add ZL, r27 //point Z to offsetted instrument
0016a2 1df2                      	adc ZH, zero
0016a3 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
0016a4 1fff                      	rol ZH
0016a5 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
0016a6 91b4                      	lpm r27, Z
                                 
0016a7 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
0016a8 1fbb                      	rol r27
0016a9 2fea                      	mov ZL, r26
0016aa 2ffb                      	mov ZH, r27
0016ab 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
0016ac 9632                      	adiw Z, 2 //point Z to the address of the macro
0016ad e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel0_instrument_change_macro_loop:
0016ae 95aa                      	dec r26
0016af f019                      	breq sound_driver_channel0_instrument_change_exit
0016b0 95b6                      	lsr r27
0016b1 f078                      	brcs sound_driver_channel0_instrument_change_load_macro
0016b2 cffb                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_exit:
0016b3 e0a3                      	ldi r26, 0x03
0016b4 e0b2                      	ldi r27, 0x02
0016b5 93b0 282a                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
0016b7 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26
0016b9 93b0 2837                 	sts pulse1_pitch_macro_offset, r27
0016bb 93b0 283d                 	sts pulse1_hi_pitch_macro_offset, r27
0016bd 93b0 2842                 	sts pulse1_duty_macro_offset, r27
0016bf d0c3                      	rcall sound_driver_channel0_increment_offset_twice
0016c0 cde4                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_load_macro:
0016c1 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
0016c2 91d5                      	lpm r29, Z+
                                 
0016c3 30a5                      	cpi r26, 5
0016c4 f039                      	breq sound_driver_channel0_instrument_change_load_macro_volume
0016c5 30a4                      	cpi r26, 4
0016c6 f079                      	breq sound_driver_channel0_instrument_change_load_macro_arpeggio
0016c7 30a3                      	cpi r26, 3
0016c8 f0d9                      	breq sound_driver_channel0_instrument_change_load_macro_pitch
0016c9 30a2                      	cpi r26, 2
0016ca f159                      	breq sound_driver_channel0_instrument_change_load_macro_hi_pitch
0016cb c03c                      	rjmp sound_driver_channel0_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel0_instrument_change_load_macro_volume:
0016cc 93c0 2828                 	sts pulse1_volume_macro, r28
0016ce 93d0 2829                 	sts pulse1_volume_macro+1, r29
0016d0 d041                      	rcall sound_driver_channel0_instrument_change_read_header
0016d1 93c0 282c                 	sts pulse1_volume_macro_release, r28
0016d3 93d0 282b                 	sts pulse1_volume_macro_loop, r29
0016d5 cfd8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 	
                                 sound_driver_channel0_instrument_change_load_macro_arpeggio:
0016d6 93c0 282d                 	sts pulse1_arpeggio_macro, r28
0016d8 93d0 282e                 	sts pulse1_arpeggio_macro+1, r29
0016da 9220 2864                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0016dc 9220 2865                 	sts pulse1_fx_Qxy_target+1, zero
0016de 9220 286b                 	sts pulse1_fx_Rxy_target, zero
0016e0 9220 286c                 	sts pulse1_fx_Rxy_target+1, zero
0016e2 d03a                      	rcall sound_driver_channel0_instrument_change_read_header_arpeggio
0016e3 cfca                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_pitch:
0016e4 93c0 2835                 	sts pulse1_pitch_macro, r28
0016e6 93d0 2836                 	sts pulse1_pitch_macro+1, r29
0016e8 9220 2864                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0016ea 9220 2865                 	sts pulse1_fx_Qxy_target+1, zero
0016ec 9220 286b                 	sts pulse1_fx_Rxy_target, zero
0016ee 9220 286c                 	sts pulse1_fx_Rxy_target+1, zero
0016f0 d021                      	rcall sound_driver_channel0_instrument_change_read_header
0016f1 93c0 2839                 	sts pulse1_pitch_macro_release, r28
0016f3 93d0 2838                 	sts pulse1_pitch_macro_loop, r29
0016f5 cfb8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_hi_pitch:
0016f6 93c0 283b                 	sts pulse1_hi_pitch_macro, r28
0016f8 93d0 283c                 	sts pulse1_hi_pitch_macro+1, r29
0016fa 9220 2864                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0016fc 9220 2865                 	sts pulse1_fx_Qxy_target+1, zero
0016fe 9220 286b                 	sts pulse1_fx_Rxy_target, zero
001700 9220 286c                 	sts pulse1_fx_Rxy_target+1, zero
001702 d00f                      	rcall sound_driver_channel0_instrument_change_read_header
001703 93c0 283f                 	sts pulse1_hi_pitch_macro_release, r28
001705 93d0 283e                 	sts pulse1_hi_pitch_macro_loop, r29
001707 cfa6                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_duty:
001708 93c0 2840                 	sts pulse1_duty_macro, r28
00170a 93d0 2841                 	sts pulse1_duty_macro+1, r29
00170c d005                      	rcall sound_driver_channel0_instrument_change_read_header
00170d 93c0 2844                 	sts pulse1_duty_macro_release, r28
00170f 93d0 2843                 	sts pulse1_duty_macro_loop, r29
001711 cf9c                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_read_header:
001712 93ef                      	push ZL
001713 93ff                      	push ZH
001714 2fec                      	mov ZL, r28
001715 2ffd                      	mov ZH, r29
001716 0fee                      	lsl ZL
001717 1fff                      	rol ZH
001718 91c5                      	lpm r28, Z+
001719 91d4                      	lpm r29, Z
00171a 91ff                      	pop ZH
00171b 91ef                      	pop ZL
00171c 9508                      	ret
                                 
                                 sound_driver_channel0_instrument_change_read_header_arpeggio:
00171d 93ef                      	push ZL
00171e 93ff                      	push ZH
00171f 2fec                      	mov ZL, r28
001720 2ffd                      	mov ZH, r29
001721 0fee                      	lsl ZL
001722 1fff                      	rol ZH
001723 91c5                      	lpm r28, Z+
001724 91d5                      	lpm r29, Z+
001725 93c0 2831                 	sts pulse1_arpeggio_macro_release, r28
001727 93d0 2830                 	sts pulse1_arpeggio_macro_loop, r29
001729 91c4                      	lpm r28, Z
00172a 93c0 2832                 	sts pulse1_arpeggio_macro_mode, r28
00172c 91ff                      	pop ZH
00172d 91ef                      	pop ZL
00172e 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel0_release:
                                 sound_driver_channel0_release_volume:
00172f 91b0 282c                 	lds r27, pulse1_volume_macro_release
001731 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001732 f019                      	breq sound_driver_channel0_release_arpeggio //if the macro has no release flag, check the next macro
001733 95b3                      	inc r27
001734 93b0 282a                 	sts pulse1_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel0_release_arpeggio:
001736 91b0 2831                 	lds r27, pulse1_arpeggio_macro_release
001738 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001739 f019                      	breq sound_driver_channel0_release_pitch
00173a 95b3                      	inc r27
00173b 93b0 282f                 	sts pulse1_arpeggio_macro_offset, r27
                                 sound_driver_channel0_release_pitch:
00173d 91b0 2839                 	lds r27, pulse1_pitch_macro_release
00173f 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001740 f019                      	breq sound_driver_channel0_release_hi_pitch
001741 95b3                      	inc r27
001742 93b0 2837                 	sts pulse1_pitch_macro_offset, r27
                                 sound_driver_channel0_release_hi_pitch:
001744 91b0 283f                 	lds r27, pulse1_hi_pitch_macro_release
001746 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001747 f019                      	breq sound_driver_channel0_release_duty
001748 95b3                      	inc r27
001749 93b0 283d                 	sts pulse1_hi_pitch_macro_offset, r27
                                 sound_driver_channel0_release_duty:
00174b 91b0 2844                 	lds r27, pulse1_duty_macro_release
00174d 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
00174e f019                      	breq sound_driver_channel0_release_exit
00174f 95b3                      	inc r27
001750 93b0 2842                 	sts pulse1_duty_macro_offset, r27
                                 sound_driver_channel0_release_exit:
001752 d026                      	rcall sound_driver_channel0_increment_offset
001753 cd51                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_next_pattern:
001754 91e0 2818                 	lds ZL, song_frames
001756 91f0 2819                 	lds ZH, song_frames+1
001758 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
00175a 91b0 281b                 	lds r27, song_frame_offset+1
00175c 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
00175d 93a0 281a                 	sts song_frame_offset, r26
00175f 93b0 281b                 	sts song_frame_offset+1, r27
                                 
001761 91c0 281c                 	lds r28, song_size
001763 91d0 281d                 	lds r29, song_size+1
001765 17ac                      	cp r26, r28
001766 07bd                      	cpc r27, r29
001767 f010                      	brlo sound_driver_channel0_next_pattern_exists
001768 940c 2dc2                 	jmp sound_driver_exit
                                 
                                 sound_driver_channel0_next_pattern_exists:
00176a 0fea                      	add ZL, r26
00176b 1ffb                      	adc ZH, r27
                                 
00176c 91a5                      	lpm r26, Z+ //load the address of the next pattern
00176d 91b4                      	lpm r27, Z
00176e 0faa                      	lsl r26
00176f 1fbb                      	rol r27
001770 93a0 2822                 	sts pulse1_pattern, r26
001772 93b0 2823                 	sts pulse1_pattern+1, r27
                                 
001774 9220 2826                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001776 9220 2827                 	sts pulse1_pattern_offset+1, zero
001778 cd2c                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_increment_offset:
001779 91e0 2826                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
00177b 91f0 2827                 	lds ZH, pulse1_pattern_offset+1
00177d 9631                      	adiw Z, 1
00177e 93e0 2826                 	sts pulse1_pattern_offset, ZL
001780 93f0 2827                 	sts pulse1_pattern_offset+1, ZH
001782 9508                      	ret
                                 
                                 sound_driver_channel0_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001783 91e0 2826                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
001785 91f0 2827                 	lds ZH, pulse1_pattern_offset+1
001787 9632                      	adiw Z, 2 //increment the pointer twice
001788 93e0 2826                 	sts pulse1_pattern_offset, ZL
00178a 93f0 2827                 	sts pulse1_pattern_offset+1, ZH
00178c 9508                      	ret
                                 
                                 sound_driver_channel0_decrement_frame_delay:
00178d 95ba                      	dec r27
00178e 93b0 2825                 	sts pulse1_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel1:
001790 91a0 2875                 	lds r26, pulse2_pattern_delay_rows
001792 91b0 2876                 	lds r27, pulse2_pattern_delay_frames
001794 9610                      	adiw r27:r26, 0
001795 f009                      	breq sound_driver_channel1_main //if the pattern delay is 0, proceed with sound driver procedures
001796 c2db                      	rjmp sound_driver_channel1_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel1_main:
001797 91e0 2873                 	lds ZL, pulse2_pattern //current pattern for pulse 2
001799 91f0 2874                 	lds ZH, pulse2_pattern+1
00179b 91a0 2877                 	lds r26, pulse2_pattern_offset //current offset in the pattern for pulse 2
00179d 91b0 2878                 	lds r27, pulse2_pattern_offset+1
00179f 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
0017a0 1ffb                      	adc ZH, r27
0017a1 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel1_check_if_note: //check if data is a note (0x00 - 0x56)
0017a2 35b7                      	cpi r27, 0x57
0017a3 f408                      	brsh sound_driver_channel1_check_if_volume
0017a4 c184                      	rjmp sound_driver_channel1_note
                                 sound_driver_channel1_check_if_volume: //check if data is volume (0x57-0x66)
0017a5 36b7                      	cpi r27, 0x67
0017a6 f408                      	brsh sound_driver_channel1_check_if_delay
0017a7 c1be                      	rjmp sound_driver_channel1_volume
                                 sound_driver_channel1_check_if_delay: //check if data is a delay (0x67 - 0xE2)
0017a8 3eb3                      	cpi r27, 0xE3
0017a9 f408                      	brsh sound_driver_channel1_check_if_instrument
0017aa c1c5                      	rjmp sound_driver_channel1_delay
                                 sound_driver_channel1_check_if_instrument: //check for instrument flag (0xE3)
0017ab f409                      	brne sound_driver_channel1_check_if_release
0017ac c1c8                      	rjmp sound_driver_channel1_instrument_change 
                                 sound_driver_channel1_check_if_release: //check for note release flag (0xE4)
0017ad 3eb4                      	cpi r27, 0xE4
0017ae f409                      	brne sound_driver_channel1_check_if_end
0017af c271                      	rjmp sound_driver_channel1_release
                                 sound_driver_channel1_check_if_end:
0017b0 3fbf                      	cpi r27, 0xFF
0017b1 f409                      	brne sound_driver_channel1_check_if_fx
0017b2 c293                      	rjmp sound_driver_channel1_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel1_check_if_fx: //fx flags (0xE5 - 0xFE)
0017b3 9631                      	adiw Z, 1 //point Z to the byte next to the flag
0017b4 91a4                      	lpm r26, Z //load the fx data into r26
0017b5 d2b2                      	rcall sound_driver_channel1_increment_offset_twice
                                 
0017b6 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
0017b7 eee8                      	ldi ZL, LOW(channel1_fx << 1) //load in note table
0017b8 e5fb                      	ldi ZH, HIGH(channel1_fx << 1)
0017b9 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
0017ba 0feb                      	add ZL, r27 //add offset
0017bb 1df2                      	adc ZH, zero
0017bc 91c5                      	lpm r28, Z+ //load address bytes
0017bd 91d4                      	lpm r29, Z
0017be 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
0017bf 2ffd                      	mov ZH, r29
0017c0 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel1_fx_0xy:
0017c1 93a0 2896                 	sts pulse2_fx_0xy_sequence, r26
0017c3 9220 2897                 	sts pulse2_fx_0xy_sequence+1, zero
0017c5 cfd1                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel1_fx_1xx:
0017c6 9220 289c                 	sts pulse2_fx_2xx, zero //turn off any 2xx pitch slide down
0017c8 9220 289d                 	sts pulse2_fx_2xx+1, zero
0017ca 9220 2896                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
0017cc 9220 2897                 	sts pulse2_fx_0xy_sequence+1, zero
0017ce 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0017cf 937f                      	push r23
0017d0 2f6a                      	mov r22, r26 //store the rate into r22
0017d1 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0017d2 9f67                      	mul r22, r23
0017d3 917f                      	pop r23
0017d4 916f                      	pop r22
                                 
0017d5 9416                      	lsr r1 //shift out the fractional bits
0017d6 9407                      	ror r0
0017d7 9416                      	lsr r1
0017d8 9407                      	ror r0
0017d9 9416                      	lsr r1
0017da 9407                      	ror r0
0017db 9416                      	lsr r1
0017dc 9407                      	ror r0
0017dd 9200 2898                 	sts pulse2_fx_1xx, r0
0017df 9210 2899                 	sts pulse2_fx_1xx+1, r1
0017e1 cfb5                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel1_fx_2xx:
0017e2 9220 2898                 	sts pulse2_fx_1xx, zero //turn off any 1xx pitch slide down
0017e4 9220 2899                 	sts pulse2_fx_1xx+1, zero
0017e6 9220 2896                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
0017e8 9220 2897                 	sts pulse2_fx_0xy_sequence+1, zero
0017ea 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0017eb 937f                      	push r23
0017ec 2f6a                      	mov r22, r26 //store the rate into r22
0017ed eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0017ee 9f67                      	mul r22, r23
0017ef 917f                      	pop r23
0017f0 916f                      	pop r22
                                 
0017f1 9416                      	lsr r1 //shift out the fractional bits
0017f2 9407                      	ror r0
0017f3 9416                      	lsr r1
0017f4 9407                      	ror r0
0017f5 9416                      	lsr r1
0017f6 9407                      	ror r0
0017f7 9416                      	lsr r1
0017f8 9407                      	ror r0
0017f9 9200 289c                 	sts pulse2_fx_2xx, r0
0017fb 9210 289d                 	sts pulse2_fx_2xx+1, r1
0017fd cf99                      	rjmp sound_driver_channel1_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel1_fx_3xx:
0017fe 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0017ff 937f                      	push r23
001800 2f6a                      	mov r22, r26 //store the rate into r22
001801 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001802 9f67                      	mul r22, r23
001803 917f                      	pop r23
001804 916f                      	pop r22
                                 
001805 9416                      	lsr r1 //shift out the fractional bits
001806 9407                      	ror r0
001807 9416                      	lsr r1
001808 9407                      	ror r0
001809 9416                      	lsr r1
00180a 9407                      	ror r0
00180b 9416                      	lsr r1
00180c 9407                      	ror r0
00180d 9200 28a4                 	sts pulse2_fx_3xx_speed, r0
00180f 9210 28a5                 	sts pulse2_fx_3xx_speed+1, r1
                                 
001811 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001812 c001                      	rjmp sound_driver_channel1_fx_3xx_enabled
001813 cf83                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_3xx_enabled:
001814 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001816 91b0 0a9d                 	lds r27, TCB1_CCMPH
001818 93a0 28a0                 	sts pulse2_fx_3xx_start, r26
00181a 93b0 28a1                 	sts pulse2_fx_3xx_start+1, r27
                                 
00181c 9220 28a6                 	sts pulse2_fx_3xx_total_offset, zero
00181e 9220 28a7                 	sts pulse2_fx_3xx_total_offset+1, zero
001820 cf76                      	rjmp sound_driver_channel1_main
                                 
                                 //VIBRATO
                                 sound_driver_channel1_fx_4xy:
001821 2fba                      	mov r27, r26
001822 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001823 95a2                      	swap r26
001824 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001825 93a0 28a8                 	sts pulse2_fx_4xy_speed, r26
001827 93b0 28a9                 	sts pulse2_fx_4xy_depth, r27
001829 9220 28aa                 	sts pulse2_fx_4xy_phase, zero //reset the phase to 0
00182b cf6b                      	rjmp sound_driver_channel1_main
                                 
                                 //TREMELO
                                 sound_driver_channel1_fx_7xy:
00182c 2fba                      	mov r27, r26
00182d 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
00182e 95a2                      	swap r26
00182f 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001830 93a0 28ab                 	sts pulse2_fx_7xy_speed, r26
001832 93b0 28ac                 	sts pulse2_fx_7xy_depth, r27
001834 9220 28ad                 	sts pulse2_fx_7xy_phase, zero //reset the phase to 0
001836 9220 28ae                 	sts pulse2_fx_7xy_value, zero //reset the tremelo value
001838 cf5e                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel1_fx_Axy:
001839 93a0 28af                 	sts pulse2_fx_Axy, r26
00183b cf5b                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel1_fx_Bxx:
00183c 93a0 281f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
00183e cf58                      	rjmp sound_driver_channel1_main
                                 
                                 //HALT
                                 sound_driver_channel1_fx_Cxx:
00183f 93b0 2820                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001841 cf55                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel1_fx_Dxx:
001842 93b0 2821                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001844 cf52                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME
                                 sound_driver_channel1_fx_Exx:
001845 91b0 2808                 	lds r27, pulse2_param
001847 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
001848 2bba                      	or r27, r26 //move new VVVV bits into pulse2_param
001849 93b0 2808                 	sts pulse2_param, r27
00184b 6092                      	sbr pulse_channel_flags, 2
00184c cf4a                      	rjmp sound_driver_channel1_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel1_fx_Fxx:
00184d 93a0 281e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
00184f cf47                      	rjmp sound_driver_channel1_main
                                 
                                 //DELAY
                                 sound_driver_channel1_fx_Gxx:
001850 15a2                      	cp r26, zero
001851 f051                      	breq sound_driver_channel1_fx_Gxx_invalid
001852 91b0 281e                 	lds r27, song_speed
001854 17ab                      	cp r26, r27
001855 f430                      	brsh sound_driver_channel1_fx_Gxx_invalid
001856 93a0 28b0                 	sts pulse2_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001858 e0b1                      	ldi r27, 0x01
001859 93b0 2875                 	sts pulse2_pattern_delay_rows, r27
00185b c219                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Gxx_invalid:
00185c cf3a                      	rjmp sound_driver_channel1_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel1_fx_Hxy: //hardware sweep up
00185d cf39                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixy: //hardware sweep down
00185e cf38                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Hxx: //FDS modulation depth
00185f cf37                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixx: //FDS modulation speed
001860 cf36                      	rjmp sound_driver_channel1_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel1_fx_Pxx:
001861 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001862 937f                      	push r23
001863 2f6a                      	mov r22, r26
001864 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001865 0367                      	mulsu r22, r23
001866 917f                      	pop r23
001867 916f                      	pop r22
001868 9416                      	lsr r1 //shift out the fractional bits
001869 9407                      	ror r0
00186a 9416                      	lsr r1
00186b 9407                      	ror r0
00186c 9416                      	lsr r1
00186d 9407                      	ror r0
00186e 9416                      	lsr r1
00186f 9407                      	ror r0
001870 fe13                      	sbrs r1, 3 //check if result was a negative number
001871 c002                      	rjmp sound_driver_channel1_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel1_fx_Pxx_negative:
001872 efb0                      	ldi r27, 0xF0
001873 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel1_fx_Pxx_store:
001874 9200 28b2                 	sts pulse2_fx_Pxx_total, r0
001876 9210 28b3                 	sts pulse2_fx_Pxx_total+1, r1
001878 cf1e                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel1_fx_Qxy:
                                 sound_driver_channel1_fx_Qxy_check_arpeggio_macro:
001879 91e0 287e                 	lds ZL, pulse2_arpeggio_macro
00187b 91f0 287f                 	lds ZH, pulse2_arpeggio_macro+1
00187d 9630                      	adiw Z, 0
00187e f009                      	breq sound_driver_channel1_fx_Qxy_check_pitch_macro
00187f cf17                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_pitch_macro:
001880 91e0 2886                 	lds ZL, pulse2_pitch_macro
001882 91f0 2887                 	lds ZH, pulse2_pitch_macro+1
001884 9630                      	adiw Z, 0
001885 f009                      	breq sound_driver_channel1_fx_Qxy_check_hi_pitch_macro
001886 cf10                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_hi_pitch_macro:
001887 91e0 288c                 	lds ZL, pulse2_hi_pitch_macro
001889 91f0 288d                 	lds ZH, pulse2_hi_pitch_macro+1
00188b 9630                      	adiw Z, 0
00188c f009                      	breq sound_driver_channel1_fx_Qxy_process
00188d cf09                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_process:
00188e 2fba                      	mov r27, r26 //copy fx parameters into r27
00188f 70bf                      	andi r27, 0x0F //mask note index offset
001890 91c0 280f                 	lds r28, pulse2_note //load current note index
001892 0fbc                      	add r27, r28
001893 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001894 f008                      	brlo sound_driver_channel1_fx_Qxy_process_continue
001895 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel1_fx_Qxy_process_continue:
001896 93b0 28b4                 	sts pulse2_fx_Qxy_target_note, r27
001898 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001899 e0f0                      	ldi ZH, HIGH(note_table << 1)
00189a 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
00189b 0feb                      	add ZL, r27 //add offset
00189c 1df2                      	adc ZH, zero
00189d 91c5                      	lpm r28, Z+ //load bytes
00189e 91d4                      	lpm r29, Z
00189f 93c0 28b5                 	sts pulse2_fx_Qxy_target, r28 //load the LOW bits for the target period
0018a1 93d0 28b6                 	sts pulse2_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
0018a3 95a2                      	swap r26
0018a4 70af                      	andi r26, 0x0F //mask effect speed
0018a5 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0018a6 95a3                      	inc r26 //increment the speed by 1
                                 
0018a7 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0018a8 937f                      	push r23
0018a9 2f6a                      	mov r22, r26 //store the speed data into r27
0018aa eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0018ab 9f67                      	mul r22, r23
0018ac 917f                      	pop r23
0018ad 916f                      	pop r22
                                 
0018ae 9416                      	lsr r1 //shift out the fractional bits
0018af 9407                      	ror r0
0018b0 9416                      	lsr r1
0018b1 9407                      	ror r0
0018b2 9416                      	lsr r1
0018b3 9407                      	ror r0
0018b4 9416                      	lsr r1
0018b5 9407                      	ror r0
                                 
0018b6 9200 28b7                 	sts pulse2_fx_Qxy_speed, r0 //store the effect speed
0018b8 9210 28b8                 	sts pulse2_fx_Qxy_speed+1, r1
0018ba 9220 28b9                 	sts pulse2_fx_Qxy_total_offset, zero
0018bc 9220 28ba                 	sts pulse2_fx_Qxy_total_offset+1, zero
0018be ced8                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel1_fx_Rxy:
                                 sound_driver_channel1_fx_Rxy_check_arpeggio_macro:
0018bf 91e0 287e                 	lds ZL, pulse2_arpeggio_macro
0018c1 91f0 287f                 	lds ZH, pulse2_arpeggio_macro+1
0018c3 9630                      	adiw Z, 0
0018c4 f009                      	breq sound_driver_channel1_fx_Rxy_check_pitch_macro
0018c5 ced1                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_pitch_macro:
0018c6 91e0 2886                 	lds ZL, pulse2_pitch_macro
0018c8 91f0 2887                 	lds ZH, pulse2_pitch_macro+1
0018ca 9630                      	adiw Z, 0
0018cb f009                      	breq sound_driver_channel1_fx_Rxy_check_hi_pitch_macro
0018cc ceca                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_hi_pitch_macro:
0018cd 91e0 288c                 	lds ZL, pulse2_hi_pitch_macro
0018cf 91f0 288d                 	lds ZH, pulse2_hi_pitch_macro+1
0018d1 9630                      	adiw Z, 0
0018d2 f009                      	breq sound_driver_channel1_fx_Rxy_process
0018d3 cec3                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_process:
0018d4 2fba                      	mov r27, r26 //copy fx parameters into r27
0018d5 70bf                      	andi r27, 0x0F //mask note index offset
0018d6 91c0 280f                 	lds r28, pulse2_note //load current note index
0018d8 1bcb                      	sub r28, r27
0018d9 f408                      	brcc sound_driver_channel1_fx_Rxy_process_continue
0018da e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel1_fx_Rxy_process_continue:
0018db 93c0 28bb                 	sts pulse2_fx_Rxy_target_note, r28
0018dd e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0018de e0f0                      	ldi ZH, HIGH(note_table << 1)
0018df 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
0018e0 0fec                      	add ZL, r28 //add offset
0018e1 1df2                      	adc ZH, zero
0018e2 91c5                      	lpm r28, Z+ //load bytes
0018e3 91d4                      	lpm r29, Z
0018e4 93c0 28bc                 	sts pulse2_fx_Rxy_target, r28 //load the LOW bits for the target period
0018e6 93d0 28bd                 	sts pulse2_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
0018e8 95a2                      	swap r26
0018e9 70af                      	andi r26, 0x0F //mask effect speed
0018ea 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0018eb 95a3                      	inc r26 //increment the speed by 1
                                 
0018ec 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0018ed 937f                      	push r23
0018ee 2f6a                      	mov r22, r26 //store the speed data into r27
0018ef eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0018f0 9f67                      	mul r22, r23
0018f1 917f                      	pop r23
0018f2 916f                      	pop r22
                                 
0018f3 9416                      	lsr r1 //shift out the fractional bits
0018f4 9407                      	ror r0
0018f5 9416                      	lsr r1
0018f6 9407                      	ror r0
0018f7 9416                      	lsr r1
0018f8 9407                      	ror r0
0018f9 9416                      	lsr r1
0018fa 9407                      	ror r0
                                 
0018fb 9200 28be                 	sts pulse2_fx_Rxy_speed, r0 //store the effect speed
0018fd 9210 28bf                 	sts pulse2_fx_Rxy_speed+1, r1
0018ff 9220 28c0                 	sts pulse2_fx_Rxy_total_offset, zero
001901 9220 28c1                 	sts pulse2_fx_Rxy_total_offset+1, zero
001903 ce93                      	rjmp sound_driver_channel1_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel1_fx_Sxx:
001904 15a2                      	cp r26, zero
001905 f051                      	breq sound_driver_channel1_fx_Sxx_invalid
001906 91b0 281e                 	lds r27, song_speed
001908 17ab                      	cp r26, r27
001909 f430                      	brsh sound_driver_channel1_fx_Sxx_invalid
00190a 93a0 28c2                 	sts pulse2_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
00190c e0b1                      	ldi r27, 0x01
00190d 93b0 2875                 	sts pulse2_pattern_delay_rows, r27
00190f c165                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Sxx_invalid:
001910 ce86                      	rjmp sound_driver_channel1_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel1_fx_Vxx:
001911 ebe0                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
001912 e5fb                      	ldi ZH, HIGH(sequences << 1)
001913 0fea                      	add ZL, r26 //offset the pointer
001914 1df2                      	adc ZH, zero
                                 
001915 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
001916 95a7                      	ror r26
001917 95a7                      	ror r26
001918 91b0 2808                 	lds r27, pulse2_param //load r27 with pulse2_param (register $4000)
00191a 2fcb                      	mov r28, r27 //store a copy of pulse2_param into r28
00191b 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
00191c 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
00191d c001                      	rjmp sound_driver_channel1_fx_Vxx_store
00191e ce78                      	rjmp sound_driver_channel1_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel1_fx_Vxx_store:
00191f 90d4                      	lpm pulse2_sequence, Z //store the sequence
                                 
001920 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
001921 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
001922 93c0 2808                 	sts pulse2_param, r28
001924 ce72                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_Wxx: //DPCM sample speed
001925 ce71                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Xxx: //DPCM sample retrigger
001926 ce70                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Yxx: //DPCM sample offset
001927 ce6f                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Zxx: //DPCM sample delta counter
001928 ce6e                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 sound_driver_channel1_note:
001929 93b0 280f                 	sts pulse2_note, r27 //store the note index
00192b e0a3                      	ldi r26, 0x03
00192c e0b2                      	ldi r27, 0x02
00192d 93b0 287b                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
00192f 93a0 2880                 	sts pulse2_arpeggio_macro_offset, r26
001931 93b0 2888                 	sts pulse2_pitch_macro_offset, r27
001933 93b0 288e                 	sts pulse2_hi_pitch_macro_offset, r27
001935 93b0 2893                 	sts pulse2_duty_macro_offset, r27
001937 9220 2884                 	sts pulse2_total_pitch_offset, zero //reset the pitch and hi pitch offset
001939 9220 2885                 	sts pulse2_total_pitch_offset+1, zero
00193b 9220 288b                 	sts pulse2_total_hi_pitch_offset, zero
00193d 9220 289a                 	sts pulse2_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
00193f 9220 289b                 	sts pulse2_fx_1xx_total+1, zero
001941 9220 289e                 	sts pulse2_fx_2xx_total, zero
001943 9220 289f                 	sts pulse2_fx_2xx_total+1, zero
001945 9220 28a6                 	sts pulse2_fx_3xx_total_offset, zero //reset 3xx offset
001947 9220 28a7                 	sts pulse2_fx_3xx_total_offset+1, zero
001949 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
00194b 91b0 0a9d                 	lds r27, TCB1_CCMPH
00194d 93a0 28a0                 	sts pulse2_fx_3xx_start, r26
00194f 93b0 28a1                 	sts pulse2_fx_3xx_start+1, r27
001951 9220 2809                 	sts pulse2_sweep_param, zero //reset any sweep effect
001953 6093                      	sbr pulse_channel_flags, 3 //set reload flag
001954 9220 28b5                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001956 9220 28b6                 	sts pulse2_fx_Qxy_target+1, zero
001958 9220 28b9                 	sts pulse2_fx_Qxy_total_offset, zero
00195a 9220 28ba                 	sts pulse2_fx_Qxy_total_offset+1, zero
00195c 9220 28bc                 	sts pulse2_fx_Rxy_target, zero
00195e 9220 28bd                 	sts pulse2_fx_Rxy_target+1, zero
001960 9220 28c0                 	sts pulse2_fx_Rxy_total_offset, zero
001962 9220 28c1                 	sts pulse2_fx_Rxy_total_offset+1, zero
001964 d0f9                      	rcall sound_driver_channel1_increment_offset
001965 ce31                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_volume:
001966 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001967 91a0 2808                 	lds r26, pulse2_param
001969 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
00196a 2bab                      	or r26, r27 //move new VVVV bits into pulse2_param
00196b 93a0 2808                 	sts pulse2_param, r26
00196d 6092                      	sbr pulse_channel_flags, 2
00196e d0ef                      	rcall sound_driver_channel1_increment_offset
00196f ce27                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_delay:
001970 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001971 93b0 2875                 	sts pulse2_pattern_delay_rows, r27
001973 d0ea                      	rcall sound_driver_channel1_increment_offset
001974 c100                      	rjmp sound_driver_channel2
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change:
001975 9220 2879                 	sts pulse2_volume_macro, zero //reset all macro addresses
001977 9220 287a                 	sts pulse2_volume_macro+1, zero
001979 9220 287e                 	sts pulse2_arpeggio_macro, zero
00197b 9220 287f                 	sts pulse2_arpeggio_macro+1, zero
00197d 9220 2886                 	sts pulse2_pitch_macro, zero
00197f 9220 2887                 	sts pulse2_pitch_macro+1, zero
001981 9220 288c                 	sts pulse2_hi_pitch_macro, zero
001983 9220 288d                 	sts pulse2_hi_pitch_macro+1, zero
001985 9220 2891                 	sts pulse2_duty_macro, zero
001987 9220 2892                 	sts pulse2_duty_macro+1, zero
001989 9220 2884                 	sts pulse2_total_pitch_offset, zero //reset the pitch offset
00198b 9220 2885                 	sts pulse2_total_pitch_offset+1, zero
00198d 9220 288b                 	sts pulse2_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
00198f 9631                      	adiw Z, 1 //point to the byte next to the flag
001990 91b4                      	lpm r27, Z //store the instrument offset into r27
001991 e2ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
001992 e0fd                      	ldi ZH, HIGH(instruments)
001993 0feb                      	add ZL, r27 //point Z to offsetted instrument
001994 1df2                      	adc ZH, zero
001995 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001996 1fff                      	rol ZH
001997 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001998 91b4                      	lpm r27, Z
                                 
001999 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
00199a 1fbb                      	rol r27
00199b 2fea                      	mov ZL, r26
00199c 2ffb                      	mov ZH, r27
00199d 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
00199e 9632                      	adiw Z, 2 //point Z to the address of the macro
00199f e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel1_instrument_change_macro_loop:
0019a0 95aa                      	dec r26
0019a1 f019                      	breq sound_driver_channel1_instrument_change_exit
0019a2 95b6                      	lsr r27
0019a3 f078                      	brcs sound_driver_channel1_instrument_change_load_macro
0019a4 cffb                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_exit:
0019a5 e0a3                      	ldi r26, 0x03
0019a6 e0b2                      	ldi r27, 0x02
0019a7 93b0 287b                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
0019a9 93a0 2880                 	sts pulse2_arpeggio_macro_offset, r26
0019ab 93b0 2888                 	sts pulse2_pitch_macro_offset, r27
0019ad 93b0 288e                 	sts pulse2_hi_pitch_macro_offset, r27
0019af 93b0 2893                 	sts pulse2_duty_macro_offset, r27
0019b1 d0b6                      	rcall sound_driver_channel1_increment_offset_twice
0019b2 cde4                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_load_macro:
0019b3 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
0019b4 91d5                      	lpm r29, Z+
                                 
0019b5 30a5                      	cpi r26, 5
0019b6 f039                      	breq sound_driver_channel1_instrument_change_load_macro_volume
0019b7 30a4                      	cpi r26, 4
0019b8 f079                      	breq sound_driver_channel1_instrument_change_load_macro_arpeggio
0019b9 30a3                      	cpi r26, 3
0019ba f0d9                      	breq sound_driver_channel1_instrument_change_load_macro_pitch
0019bb 30a2                      	cpi r26, 2
0019bc f159                      	breq sound_driver_channel1_instrument_change_load_macro_hi_pitch
0019bd c03c                      	rjmp sound_driver_channel1_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel1_instrument_change_load_macro_volume:
0019be 93c0 2879                 	sts pulse2_volume_macro, r28
0019c0 93d0 287a                 	sts pulse2_volume_macro+1, r29
0019c2 d041                      	rcall sound_driver_channel1_instrument_change_read_header
0019c3 93c0 287d                 	sts pulse2_volume_macro_release, r28
0019c5 93d0 287c                 	sts pulse2_volume_macro_loop, r29
0019c7 cfd8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 	
                                 sound_driver_channel1_instrument_change_load_macro_arpeggio:
0019c8 93c0 287e                 	sts pulse2_arpeggio_macro, r28
0019ca 93d0 287f                 	sts pulse2_arpeggio_macro+1, r29
0019cc 9220 28b5                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0019ce 9220 28b6                 	sts pulse2_fx_Qxy_target+1, zero
0019d0 9220 28bc                 	sts pulse2_fx_Rxy_target, zero
0019d2 9220 28bd                 	sts pulse2_fx_Rxy_target+1, zero
0019d4 d03a                      	rcall sound_driver_channel1_instrument_change_read_header_arpeggio
0019d5 cfca                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_pitch:
0019d6 93c0 2886                 	sts pulse2_pitch_macro, r28
0019d8 93d0 2887                 	sts pulse2_pitch_macro+1, r29
0019da 9220 28b5                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0019dc 9220 28b6                 	sts pulse2_fx_Qxy_target+1, zero
0019de 9220 28bc                 	sts pulse2_fx_Rxy_target, zero
0019e0 9220 28bd                 	sts pulse2_fx_Rxy_target+1, zero
0019e2 d021                      	rcall sound_driver_channel1_instrument_change_read_header
0019e3 93c0 288a                 	sts pulse2_pitch_macro_release, r28
0019e5 93d0 2889                 	sts pulse2_pitch_macro_loop, r29
0019e7 cfb8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_hi_pitch:
0019e8 93c0 288c                 	sts pulse2_hi_pitch_macro, r28
0019ea 93d0 288d                 	sts pulse2_hi_pitch_macro+1, r29
0019ec 9220 28b5                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0019ee 9220 28b6                 	sts pulse2_fx_Qxy_target+1, zero
0019f0 9220 28bc                 	sts pulse2_fx_Rxy_target, zero
0019f2 9220 28bd                 	sts pulse2_fx_Rxy_target+1, zero
0019f4 d00f                      	rcall sound_driver_channel1_instrument_change_read_header
0019f5 93c0 2890                 	sts pulse2_hi_pitch_macro_release, r28
0019f7 93d0 288f                 	sts pulse2_hi_pitch_macro_loop, r29
0019f9 cfa6                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_duty:
0019fa 93c0 2891                 	sts pulse2_duty_macro, r28
0019fc 93d0 2892                 	sts pulse2_duty_macro+1, r29
0019fe d005                      	rcall sound_driver_channel1_instrument_change_read_header
0019ff 93c0 2895                 	sts pulse2_duty_macro_release, r28
001a01 93d0 2894                 	sts pulse2_duty_macro_loop, r29
001a03 cf9c                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_read_header:
001a04 93ef                      	push ZL
001a05 93ff                      	push ZH
001a06 2fec                      	mov ZL, r28
001a07 2ffd                      	mov ZH, r29
001a08 0fee                      	lsl ZL
001a09 1fff                      	rol ZH
001a0a 91c5                      	lpm r28, Z+
001a0b 91d4                      	lpm r29, Z
001a0c 91ff                      	pop ZH
001a0d 91ef                      	pop ZL
001a0e 9508                      	ret
                                 
                                 sound_driver_channel1_instrument_change_read_header_arpeggio:
001a0f 93ef                      	push ZL
001a10 93ff                      	push ZH
001a11 2fec                      	mov ZL, r28
001a12 2ffd                      	mov ZH, r29
001a13 0fee                      	lsl ZL
001a14 1fff                      	rol ZH
001a15 91c5                      	lpm r28, Z+
001a16 91d5                      	lpm r29, Z+
001a17 93c0 2882                 	sts pulse2_arpeggio_macro_release, r28
001a19 93d0 2881                 	sts pulse2_arpeggio_macro_loop, r29
001a1b 91c4                      	lpm r28, Z
001a1c 93c0 2883                 	sts pulse2_arpeggio_macro_mode, r28
001a1e 91ff                      	pop ZH
001a1f 91ef                      	pop ZL
001a20 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel1_release:
                                 sound_driver_channel1_release_volume:
001a21 91b0 287d                 	lds r27, pulse2_volume_macro_release
001a23 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001a24 f019                      	breq sound_driver_channel1_release_arpeggio //if the macro has no release flag, check the next macro
001a25 95b3                      	inc r27
001a26 93b0 287b                 	sts pulse2_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel1_release_arpeggio:
001a28 91b0 2882                 	lds r27, pulse2_arpeggio_macro_release
001a2a 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001a2b f019                      	breq sound_driver_channel1_release_pitch
001a2c 95b3                      	inc r27
001a2d 93b0 2880                 	sts pulse2_arpeggio_macro_offset, r27
                                 sound_driver_channel1_release_pitch:
001a2f 91b0 288a                 	lds r27, pulse2_pitch_macro_release
001a31 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001a32 f019                      	breq sound_driver_channel1_release_hi_pitch
001a33 95b3                      	inc r27
001a34 93b0 2888                 	sts pulse2_pitch_macro_offset, r27
                                 sound_driver_channel1_release_hi_pitch:
001a36 91b0 2890                 	lds r27, pulse2_hi_pitch_macro_release
001a38 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001a39 f019                      	breq sound_driver_channel1_release_duty
001a3a 95b3                      	inc r27
001a3b 93b0 288e                 	sts pulse2_hi_pitch_macro_offset, r27
                                 sound_driver_channel1_release_duty:
001a3d 91b0 2895                 	lds r27, pulse2_duty_macro_release
001a3f 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001a40 f019                      	breq sound_driver_channel1_release_exit
001a41 95b3                      	inc r27
001a42 93b0 2893                 	sts pulse2_duty_macro_offset, r27
                                 sound_driver_channel1_release_exit:
001a44 d019                      	rcall sound_driver_channel1_increment_offset
001a45 cd51                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_next_pattern:
001a46 91e0 2818                 	lds ZL, song_frames
001a48 91f0 2819                 	lds ZH, song_frames+1
001a4a 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001a4c 91b0 281b                 	lds r27, song_frame_offset+1
001a4e 9612                      	adiw r27:r26, 2 //offset for channel 1
001a4f 0fea                      	add ZL, r26
001a50 1ffb                      	adc ZH, r27
                                 
001a51 91a5                      	lpm r26, Z+ //load the address of the next pattern
001a52 91b4                      	lpm r27, Z
001a53 0faa                      	lsl r26
001a54 1fbb                      	rol r27
001a55 93a0 2873                 	sts pulse2_pattern, r26
001a57 93b0 2874                 	sts pulse2_pattern+1, r27
                                 
001a59 9220 2877                 	sts pulse2_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001a5b 9220 2878                 	sts pulse2_pattern_offset+1, zero
001a5d cd39                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_increment_offset:
001a5e 91e0 2877                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001a60 91f0 2878                 	lds ZH, pulse2_pattern_offset+1
001a62 9631                      	adiw Z, 1
001a63 93e0 2877                 	sts pulse2_pattern_offset, ZL
001a65 93f0 2878                 	sts pulse2_pattern_offset+1, ZH
001a67 9508                      	ret
                                 
                                 sound_driver_channel1_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001a68 91e0 2877                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001a6a 91f0 2878                 	lds ZH, pulse2_pattern_offset+1
001a6c 9632                      	adiw Z, 2 //increment the pointer twice
001a6d 93e0 2877                 	sts pulse2_pattern_offset, ZL
001a6f 93f0 2878                 	sts pulse2_pattern_offset+1, ZH
001a71 9508                      	ret
                                 
                                 sound_driver_channel1_decrement_frame_delay:
001a72 95ba                      	dec r27
001a73 93b0 2876                 	sts pulse2_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel2:
001a75 91a0 28c6                 	lds r26, triangle_pattern_delay_rows
001a77 91b0 28c7                 	lds r27, triangle_pattern_delay_frames
001a79 9610                      	adiw r27:r26, 0
001a7a f009                      	breq sound_driver_channel2_main //if the pattern delay is 0, proceed with sound driver procedures
001a7b c2c3                      	rjmp sound_driver_channel2_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel2_main:
001a7c 91e0 28c4                 	lds ZL, triangle_pattern //current pattern for triangle
001a7e 91f0 28c5                 	lds ZH, triangle_pattern+1
001a80 91a0 28c8                 	lds r26, triangle_pattern_offset //current offset in the pattern for triangle
001a82 91b0 28c9                 	lds r27, triangle_pattern_offset+1
001a84 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001a85 1ffb                      	adc ZH, r27
001a86 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel2_check_if_note: //check if data is a note (0x00 - 0x56)
001a87 35b7                      	cpi r27, 0x57
001a88 f408                      	brsh sound_driver_channel2_check_if_volume
001a89 c168                      	rjmp sound_driver_channel2_note
                                 sound_driver_channel2_check_if_volume: //check if data is volume (0x57-0x66)
001a8a 36b7                      	cpi r27, 0x67
001a8b f408                      	brsh sound_driver_channel2_check_if_delay
001a8c c1a2                      	rjmp sound_driver_channel2_volume
                                 sound_driver_channel2_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001a8d 3eb3                      	cpi r27, 0xE3
001a8e f408                      	brsh sound_driver_channel2_check_if_instrument
001a8f c1ad                      	rjmp sound_driver_channel2_delay
                                 sound_driver_channel2_check_if_instrument: //check for instrument flag (0xE3)
001a90 f409                      	brne sound_driver_channel2_check_if_release
001a91 c1b0                      	rjmp sound_driver_channel2_instrument_change 
                                 sound_driver_channel2_check_if_release: //check for note release flag (0xE4)
001a92 3eb4                      	cpi r27, 0xE4
001a93 f409                      	brne sound_driver_channel2_check_if_end
001a94 c259                      	rjmp sound_driver_channel2_release
                                 sound_driver_channel2_check_if_end:
001a95 3fbf                      	cpi r27, 0xFF
001a96 f409                      	brne sound_driver_channel2_check_if_fx
001a97 c27b                      	rjmp sound_driver_channel2_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel2_check_if_fx: //fx flags (0xE5 - 0xFE)
001a98 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001a99 91a4                      	lpm r26, Z //load the fx data into r26
001a9a d29a                      	rcall sound_driver_channel2_increment_offset_twice
                                 
001a9b 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001a9c e1ec                      	ldi ZL, LOW(channel2_fx << 1) //load in note table
001a9d e5fc                      	ldi ZH, HIGH(channel2_fx << 1)
001a9e 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001a9f 0feb                      	add ZL, r27 //add offset
001aa0 1df2                      	adc ZH, zero
001aa1 91c5                      	lpm r28, Z+ //load address bytes
001aa2 91d4                      	lpm r29, Z
001aa3 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001aa4 2ffd                      	mov ZH, r29
001aa5 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel2_fx_0xy:
001aa6 93a0 28e7                 	sts triangle_fx_0xy_sequence, r26
001aa8 9220 28e8                 	sts triangle_fx_0xy_sequence+1, zero
001aaa cfd1                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel2_fx_1xx:
001aab 9220 28ed                 	sts triangle_fx_2xx, zero //turn off any 2xx pitch slide down
001aad 9220 28ee                 	sts triangle_fx_2xx+1, zero
001aaf 9220 28e7                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001ab1 9220 28e8                 	sts triangle_fx_0xy_sequence+1, zero
001ab3 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001ab4 937f                      	push r23
001ab5 2f6a                      	mov r22, r26 //store the rate into r22
001ab6 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001ab7 9f67                      	mul r22, r23
001ab8 917f                      	pop r23
001ab9 916f                      	pop r22
                                 
001aba 9416                      	lsr r1 //shift out the fractional bits
001abb 9407                      	ror r0
001abc 9416                      	lsr r1
001abd 9407                      	ror r0
001abe 9416                      	lsr r1
001abf 9407                      	ror r0
001ac0 9416                      	lsr r1
001ac1 9407                      	ror r0
001ac2 9200 28e9                 	sts triangle_fx_1xx, r0
001ac4 9210 28ea                 	sts triangle_fx_1xx+1, r1
001ac6 cfb5                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel2_fx_2xx:
001ac7 9220 28e9                 	sts triangle_fx_1xx, zero //turn off any 1xx pitch slide down
001ac9 9220 28ea                 	sts triangle_fx_1xx+1, zero
001acb 9220 28e7                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001acd 9220 28e8                 	sts triangle_fx_0xy_sequence+1, zero
001acf 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001ad0 937f                      	push r23
001ad1 2f6a                      	mov r22, r26 //store the rate into r22
001ad2 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001ad3 9f67                      	mul r22, r23
001ad4 917f                      	pop r23
001ad5 916f                      	pop r22
                                 
001ad6 9416                      	lsr r1 //shift out the fractional bits
001ad7 9407                      	ror r0
001ad8 9416                      	lsr r1
001ad9 9407                      	ror r0
001ada 9416                      	lsr r1
001adb 9407                      	ror r0
001adc 9416                      	lsr r1
001add 9407                      	ror r0
001ade 9200 28ed                 	sts triangle_fx_2xx, r0
001ae0 9210 28ee                 	sts triangle_fx_2xx+1, r1
001ae2 cf99                      	rjmp sound_driver_channel2_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel2_fx_3xx:
001ae3 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001ae4 937f                      	push r23
001ae5 2f6a                      	mov r22, r26 //store the rate into r22
001ae6 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001ae7 9f67                      	mul r22, r23
001ae8 917f                      	pop r23
001ae9 916f                      	pop r22
                                 
001aea 9416                      	lsr r1 //shift out the fractional bits
001aeb 9407                      	ror r0
001aec 9416                      	lsr r1
001aed 9407                      	ror r0
001aee 9416                      	lsr r1
001aef 9407                      	ror r0
001af0 9416                      	lsr r1
001af1 9407                      	ror r0
001af2 9200 28f5                 	sts triangle_fx_3xx_speed, r0
001af4 9210 28f6                 	sts triangle_fx_3xx_speed+1, r1
                                 
001af6 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001af7 c001                      	rjmp sound_driver_channel2_fx_3xx_enabled
001af8 cf83                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_3xx_enabled:
001af9 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001afb 91b0 0aad                 	lds r27, TCB2_CCMPH
001afd 93a0 28f1                 	sts triangle_fx_3xx_start, r26
001aff 93b0 28f2                 	sts triangle_fx_3xx_start+1, r27
                                 
001b01 9220 28f7                 	sts triangle_fx_3xx_total_offset, zero
001b03 9220 28f8                 	sts triangle_fx_3xx_total_offset+1, zero
001b05 cf76                      	rjmp sound_driver_channel2_main
                                 
                                 //VIBRATO
                                 sound_driver_channel2_fx_4xy:
001b06 2fba                      	mov r27, r26
001b07 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001b08 95a2                      	swap r26
001b09 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001b0a 93a0 28f9                 	sts triangle_fx_4xy_speed, r26
001b0c 93b0 28fa                 	sts triangle_fx_4xy_depth, r27
001b0e 9220 28fb                 	sts triangle_fx_4xy_phase, zero //reset the phase to 0
001b10 cf6b                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_7xy: //tremelo
001b11 cf6a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Axy: //volume slide
001b12 cf69                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel2_fx_Bxx:
001b13 93a0 281f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001b15 cf66                      	rjmp sound_driver_channel2_main
                                 
                                 //HALT
                                 sound_driver_channel2_fx_Cxx:
001b16 93b0 2820                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001b18 cf63                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel2_fx_Dxx:
001b19 93b0 2821                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001b1b cf60                      	rjmp sound_driver_channel2_main
                                 
                                 //VOLUME
                                 sound_driver_channel2_fx_Exx:
001b1c 15a2                      	cp r26, zero
001b1d f021                      	breq sound_driver_channel2_fx_Exx_disable
                                 sound_driver_channel2_fx_Exx_enable:
001b1e e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001b1f 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001b21 cf5a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Exx_disable:
001b22 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
001b24 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
001b26 9220 0aad                 	sts TCB2_CCMPH, zero
001b28 cf53                      	rjmp sound_driver_channel2_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel2_fx_Fxx:
001b29 93a0 281e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001b2b cf50                      	rjmp sound_driver_channel2_main
                                 
                                 //DELAY
                                 sound_driver_channel2_fx_Gxx:
001b2c 15a2                      	cp r26, zero
001b2d f051                      	breq sound_driver_channel2_fx_Gxx_invalid
001b2e 91b0 281e                 	lds r27, song_speed
001b30 17ab                      	cp r26, r27
001b31 f430                      	brsh sound_driver_channel2_fx_Gxx_invalid
001b32 93a0 28fc                 	sts triangle_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001b34 e0b1                      	ldi r27, 0x01
001b35 93b0 28c6                 	sts triangle_pattern_delay_rows, r27
001b37 c20a                      	rjmp sound_driver_channel3
                                 sound_driver_channel2_fx_Gxx_invalid:
001b38 cf43                      	rjmp sound_driver_channel2_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Hxy: //hardware sweep up
001b39 cf42                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixy: //hardware sweep down
001b3a cf41                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Hxx: //FDS modulation depth
001b3b cf40                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixx: //FDS modulation speed
001b3c cf3f                      	rjmp sound_driver_channel2_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel2_fx_Pxx:
001b3d 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001b3e 937f                      	push r23
001b3f 2f6a                      	mov r22, r26
001b40 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001b41 0367                      	mulsu r22, r23
001b42 917f                      	pop r23
001b43 916f                      	pop r22
001b44 9416                      	lsr r1 //shift out the fractional bits
001b45 9407                      	ror r0
001b46 9416                      	lsr r1
001b47 9407                      	ror r0
001b48 9416                      	lsr r1
001b49 9407                      	ror r0
001b4a 9416                      	lsr r1
001b4b 9407                      	ror r0
001b4c fe13                      	sbrs r1, 3 //check if result was a negative number
001b4d c002                      	rjmp sound_driver_channel2_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel2_fx_Pxx_negative:
001b4e efb0                      	ldi r27, 0xF0
001b4f 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel2_fx_Pxx_store:
001b50 9200 28fe                 	sts triangle_fx_Pxx_total, r0
001b52 9210 28ff                 	sts triangle_fx_Pxx_total+1, r1
001b54 cf27                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel2_fx_Qxy:
                                 sound_driver_channel2_fx_Qxy_check_arpeggio_macro:
001b55 91e0 28cf                 	lds ZL, triangle_arpeggio_macro
001b57 91f0 28d0                 	lds ZH, triangle_arpeggio_macro+1
001b59 9630                      	adiw Z, 0
001b5a f009                      	breq sound_driver_channel2_fx_Qxy_check_pitch_macro
001b5b cf20                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_pitch_macro:
001b5c 91e0 28d7                 	lds ZL, triangle_pitch_macro
001b5e 91f0 28d8                 	lds ZH, triangle_pitch_macro+1
001b60 9630                      	adiw Z, 0
001b61 f009                      	breq sound_driver_channel2_fx_Qxy_check_hi_pitch_macro
001b62 cf19                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_hi_pitch_macro:
001b63 91e0 28dd                 	lds ZL, triangle_hi_pitch_macro
001b65 91f0 28de                 	lds ZH, triangle_hi_pitch_macro+1
001b67 9630                      	adiw Z, 0
001b68 f009                      	breq sound_driver_channel2_fx_Qxy_process
001b69 cf12                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_process:
001b6a 2fba                      	mov r27, r26 //copy fx parameters into r27
001b6b 70bf                      	andi r27, 0x0F //mask note index offset
001b6c 91c0 2812                 	lds r28, triangle_note //load current note index
001b6e 0fbc                      	add r27, r28
001b6f 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001b70 f008                      	brlo sound_driver_channel2_fx_Qxy_process_continue
001b71 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel2_fx_Qxy_process_continue:
001b72 93b0 2900                 	sts triangle_fx_Qxy_target_note, r27
001b74 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001b75 e0f0                      	ldi ZH, HIGH(note_table << 1)
001b76 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001b77 0feb                      	add ZL, r27 //add offset
001b78 1df2                      	adc ZH, zero
001b79 91c5                      	lpm r28, Z+ //load bytes
001b7a 91d4                      	lpm r29, Z
001b7b 93c0 2901                 	sts triangle_fx_Qxy_target, r28 //load the LOW bits for the target period
001b7d 93d0 2902                 	sts triangle_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
001b7f 95a2                      	swap r26
001b80 70af                      	andi r26, 0x0F //mask effect speed
001b81 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001b82 95a3                      	inc r26 //increment the speed by 1
                                 
001b83 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001b84 937f                      	push r23
001b85 2f6a                      	mov r22, r26 //store the speed data into r27
001b86 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001b87 9f67                      	mul r22, r23
001b88 917f                      	pop r23
001b89 916f                      	pop r22
                                 
001b8a 9416                      	lsr r1 //shift out the fractional bits
001b8b 9407                      	ror r0
001b8c 9416                      	lsr r1
001b8d 9407                      	ror r0
001b8e 9416                      	lsr r1
001b8f 9407                      	ror r0
001b90 9416                      	lsr r1
001b91 9407                      	ror r0
                                 
001b92 9200 2903                 	sts triangle_fx_Qxy_speed, r0 //store the effect speed
001b94 9210 2904                 	sts triangle_fx_Qxy_speed+1, r1
001b96 9220 2905                 	sts triangle_fx_Qxy_total_offset, zero
001b98 9220 2906                 	sts triangle_fx_Qxy_total_offset+1, zero
001b9a cee1                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel2_fx_Rxy:
                                 sound_driver_channel2_fx_Rxy_check_arpeggio_macro:
001b9b 91e0 28cf                 	lds ZL, triangle_arpeggio_macro
001b9d 91f0 28d0                 	lds ZH, triangle_arpeggio_macro+1
001b9f 9630                      	adiw Z, 0
001ba0 f009                      	breq sound_driver_channel2_fx_Rxy_check_pitch_macro
001ba1 ceda                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_pitch_macro:
001ba2 91e0 28d7                 	lds ZL, triangle_pitch_macro
001ba4 91f0 28d8                 	lds ZH, triangle_pitch_macro+1
001ba6 9630                      	adiw Z, 0
001ba7 f009                      	breq sound_driver_channel2_fx_Rxy_check_hi_pitch_macro
001ba8 ced3                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_hi_pitch_macro:
001ba9 91e0 28dd                 	lds ZL, triangle_hi_pitch_macro
001bab 91f0 28de                 	lds ZH, triangle_hi_pitch_macro+1
001bad 9630                      	adiw Z, 0
001bae f009                      	breq sound_driver_channel2_fx_Rxy_process
001baf cecc                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_process:
001bb0 2fba                      	mov r27, r26 //copy fx parameters into r27
001bb1 70bf                      	andi r27, 0x0F //mask note index offset
001bb2 91c0 2812                 	lds r28, triangle_note //load current note index
001bb4 1bcb                      	sub r28, r27
001bb5 f408                      	brcc sound_driver_channel2_fx_Rxy_process_continue
001bb6 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel2_fx_Rxy_process_continue:
001bb7 93c0 2907                 	sts triangle_fx_Rxy_target_note, r28
001bb9 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001bba e0f0                      	ldi ZH, HIGH(note_table << 1)
001bbb 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001bbc 0fec                      	add ZL, r28 //add offset
001bbd 1df2                      	adc ZH, zero
001bbe 91c5                      	lpm r28, Z+ //load bytes
001bbf 91d4                      	lpm r29, Z
001bc0 93c0 2908                 	sts triangle_fx_Rxy_target, r28 //load the LOW bits for the target period
001bc2 93d0 2909                 	sts triangle_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
001bc4 95a2                      	swap r26
001bc5 70af                      	andi r26, 0x0F //mask effect speed
001bc6 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001bc7 95a3                      	inc r26 //increment the speed by 1
                                 
001bc8 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001bc9 937f                      	push r23
001bca 2f6a                      	mov r22, r26 //store the speed data into r27
001bcb eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001bcc 9f67                      	mul r22, r23
001bcd 917f                      	pop r23
001bce 916f                      	pop r22
                                 
001bcf 9416                      	lsr r1 //shift out the fractional bits
001bd0 9407                      	ror r0
001bd1 9416                      	lsr r1
001bd2 9407                      	ror r0
001bd3 9416                      	lsr r1
001bd4 9407                      	ror r0
001bd5 9416                      	lsr r1
001bd6 9407                      	ror r0
                                 
001bd7 9200 290a                 	sts triangle_fx_Rxy_speed, r0 //store the effect speed
001bd9 9210 290b                 	sts triangle_fx_Rxy_speed+1, r1
001bdb 9220 290c                 	sts triangle_fx_Rxy_total_offset, zero
001bdd 9220 290d                 	sts triangle_fx_Rxy_total_offset+1, zero
001bdf ce9c                      	rjmp sound_driver_channel2_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel2_fx_Sxx:
001be0 15a2                      	cp r26, zero
001be1 f051                      	breq sound_driver_channel2_fx_Sxx_invalid
001be2 91b0 281e                 	lds r27, song_speed
001be4 17ab                      	cp r26, r27
001be5 f430                      	brsh sound_driver_channel2_fx_Sxx_invalid
001be6 93a0 290e                 	sts triangle_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001be8 e0b1                      	ldi r27, 0x01
001be9 93b0 28c6                 	sts triangle_pattern_delay_rows, r27
001beb c156                      	rjmp sound_driver_channel3
                                 sound_driver_channel2_fx_Sxx_invalid:
001bec ce8f                      	rjmp sound_driver_channel2_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Vxx: //duty
001bed ce8e                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Wxx: //DPCM sample speed
001bee ce8d                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Xxx: //DPCM sample retrigger
001bef ce8c                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Yxx: //DPCM sample offset
001bf0 ce8b                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Zxx: //DPCM sample delta counter
001bf1 ce8a                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 sound_driver_channel2_note:
001bf2 93b0 2812                 	sts triangle_note, r27 //store the note index
001bf4 e0a3                      	ldi r26, 0x03
001bf5 e0b2                      	ldi r27, 0x02
001bf6 93b0 28cc                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
001bf8 93a0 28d1                 	sts triangle_arpeggio_macro_offset, r26
001bfa 93b0 28d9                 	sts triangle_pitch_macro_offset, r27
001bfc 93b0 28df                 	sts triangle_hi_pitch_macro_offset, r27
001bfe 93b0 28e4                 	sts triangle_duty_macro_offset, r27
001c00 9220 28d5                 	sts triangle_total_pitch_offset, zero //reset the pitch and hi pitch offset
001c02 9220 28d6                 	sts triangle_total_pitch_offset+1, zero
001c04 9220 28dc                 	sts triangle_total_hi_pitch_offset, zero
001c06 9220 28eb                 	sts triangle_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001c08 9220 28ec                 	sts triangle_fx_1xx_total+1, zero
001c0a 9220 28ef                 	sts triangle_fx_2xx_total, zero
001c0c 9220 28f0                 	sts triangle_fx_2xx_total+1, zero
001c0e 9220 28f7                 	sts triangle_fx_3xx_total_offset, zero //reset 3xx offset
001c10 9220 28f8                 	sts triangle_fx_3xx_total_offset+1, zero
001c12 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001c14 91b0 0aad                 	lds r27, TCB2_CCMPH
001c16 93a0 28f1                 	sts triangle_fx_3xx_start, r26
001c18 93b0 28f2                 	sts triangle_fx_3xx_start+1, r27
001c1a 9220 2901                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001c1c 9220 2902                 	sts triangle_fx_Qxy_target+1, zero
001c1e 9220 2905                 	sts triangle_fx_Qxy_total_offset, zero
001c20 9220 2906                 	sts triangle_fx_Qxy_total_offset+1, zero
001c22 9220 2908                 	sts triangle_fx_Rxy_target, zero
001c24 9220 2909                 	sts triangle_fx_Rxy_target+1, zero
001c26 9220 290c                 	sts triangle_fx_Rxy_total_offset, zero
001c28 9220 290d                 	sts triangle_fx_Rxy_total_offset+1, zero
001c2a e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001c2b 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001c2d d0fd                      	rcall sound_driver_channel2_increment_offset
001c2e ce4d                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_volume:
001c2f d0fb                      	rcall sound_driver_channel2_increment_offset
001c30 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001c31 f021                      	breq sound_driver_channel2_volume_disable
                                 sound_driver_channel2_volume_enable:
001c32 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001c33 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001c35 ce46                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_volume_disable:
001c36 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
001c38 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
001c3a 9220 0aad                 	sts TCB2_CCMPH, zero
001c3c ce3f                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_delay:
001c3d 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001c3e 93b0 28c6                 	sts triangle_pattern_delay_rows, r27
001c40 d0ea                      	rcall sound_driver_channel2_increment_offset
001c41 c100                      	rjmp sound_driver_channel3
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change:
001c42 9220 28ca                 	sts triangle_volume_macro, zero //reset all macro addresses
001c44 9220 28cb                 	sts triangle_volume_macro+1, zero
001c46 9220 28cf                 	sts triangle_arpeggio_macro, zero
001c48 9220 28d0                 	sts triangle_arpeggio_macro+1, zero
001c4a 9220 28d7                 	sts triangle_pitch_macro, zero
001c4c 9220 28d8                 	sts triangle_pitch_macro+1, zero
001c4e 9220 28dd                 	sts triangle_hi_pitch_macro, zero
001c50 9220 28de                 	sts triangle_hi_pitch_macro+1, zero
001c52 9220 28e2                 	sts triangle_duty_macro, zero
001c54 9220 28e3                 	sts triangle_duty_macro+1, zero
001c56 9220 28d5                 	sts triangle_total_pitch_offset, zero //reset the pitch offset
001c58 9220 28d6                 	sts triangle_total_pitch_offset+1, zero
001c5a 9220 28dc                 	sts triangle_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001c5c 9631                      	adiw Z, 1 //point to the byte next to the flag
001c5d 91b4                      	lpm r27, Z //store the instrument offset into r27
001c5e e2ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
001c5f e0fd                      	ldi ZH, HIGH(instruments)
001c60 0feb                      	add ZL, r27 //point Z to offsetted instrument
001c61 1df2                      	adc ZH, zero
001c62 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001c63 1fff                      	rol ZH
001c64 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001c65 91b4                      	lpm r27, Z
                                 
001c66 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001c67 1fbb                      	rol r27
001c68 2fea                      	mov ZL, r26
001c69 2ffb                      	mov ZH, r27
001c6a 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001c6b 9632                      	adiw Z, 2 //point Z to the address of the macro
001c6c e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel2_instrument_change_macro_loop:
001c6d 95aa                      	dec r26
001c6e f019                      	breq sound_driver_channel2_instrument_change_exit
001c6f 95b6                      	lsr r27
001c70 f078                      	brcs sound_driver_channel2_instrument_change_load_macro
001c71 cffb                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_exit:
001c72 e0a3                      	ldi r26, 0x03
001c73 e0b2                      	ldi r27, 0x02
001c74 93b0 28cc                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
001c76 93a0 28d1                 	sts triangle_arpeggio_macro_offset, r26
001c78 93b0 28d9                 	sts triangle_pitch_macro_offset, r27
001c7a 93b0 28df                 	sts triangle_hi_pitch_macro_offset, r27
001c7c 93b0 28e4                 	sts triangle_duty_macro_offset, r27
001c7e d0b6                      	rcall sound_driver_channel2_increment_offset_twice
001c7f cdfc                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_load_macro:
001c80 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001c81 91d5                      	lpm r29, Z+
                                 
001c82 30a5                      	cpi r26, 5
001c83 f039                      	breq sound_driver_channel2_instrument_change_load_macro_volume
001c84 30a4                      	cpi r26, 4
001c85 f079                      	breq sound_driver_channel2_instrument_change_load_macro_arpeggio
001c86 30a3                      	cpi r26, 3
001c87 f0d9                      	breq sound_driver_channel2_instrument_change_load_macro_pitch
001c88 30a2                      	cpi r26, 2
001c89 f159                      	breq sound_driver_channel2_instrument_change_load_macro_hi_pitch
001c8a c03c                      	rjmp sound_driver_channel2_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel2_instrument_change_load_macro_volume:
001c8b 93c0 28ca                 	sts triangle_volume_macro, r28
001c8d 93d0 28cb                 	sts triangle_volume_macro+1, r29
001c8f d041                      	rcall sound_driver_channel2_instrument_change_read_header
001c90 93c0 28ce                 	sts triangle_volume_macro_release, r28
001c92 93d0 28cd                 	sts triangle_volume_macro_loop, r29
001c94 cfd8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 	
                                 sound_driver_channel2_instrument_change_load_macro_arpeggio:
001c95 93c0 28cf                 	sts triangle_arpeggio_macro, r28
001c97 93d0 28d0                 	sts triangle_arpeggio_macro+1, r29
001c99 9220 2901                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001c9b 9220 2902                 	sts triangle_fx_Qxy_target+1, zero
001c9d 9220 2908                 	sts triangle_fx_Rxy_target, zero
001c9f 9220 2909                 	sts triangle_fx_Rxy_target+1, zero
001ca1 d03a                      	rcall sound_driver_channel2_instrument_change_read_header_arpeggio
001ca2 cfca                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_pitch:
001ca3 93c0 28d7                 	sts triangle_pitch_macro, r28
001ca5 93d0 28d8                 	sts triangle_pitch_macro+1, r29
001ca7 9220 2901                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001ca9 9220 2902                 	sts triangle_fx_Qxy_target+1, zero
001cab 9220 2908                 	sts triangle_fx_Rxy_target, zero
001cad 9220 2909                 	sts triangle_fx_Rxy_target+1, zero
001caf d021                      	rcall sound_driver_channel2_instrument_change_read_header
001cb0 93c0 28db                 	sts triangle_pitch_macro_release, r28
001cb2 93d0 28da                 	sts triangle_pitch_macro_loop, r29
001cb4 cfb8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_hi_pitch:
001cb5 93c0 28dd                 	sts triangle_hi_pitch_macro, r28
001cb7 93d0 28de                 	sts triangle_hi_pitch_macro+1, r29
001cb9 9220 2901                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001cbb 9220 2902                 	sts triangle_fx_Qxy_target+1, zero
001cbd 9220 2908                 	sts triangle_fx_Rxy_target, zero
001cbf 9220 2909                 	sts triangle_fx_Rxy_target+1, zero
001cc1 d00f                      	rcall sound_driver_channel2_instrument_change_read_header
001cc2 93c0 28e1                 	sts triangle_hi_pitch_macro_release, r28
001cc4 93d0 28e0                 	sts triangle_hi_pitch_macro_loop, r29
001cc6 cfa6                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_duty:
001cc7 93c0 28e2                 	sts triangle_duty_macro, r28
001cc9 93d0 28e3                 	sts triangle_duty_macro+1, r29
001ccb d005                      	rcall sound_driver_channel2_instrument_change_read_header
001ccc 93c0 28e6                 	sts triangle_duty_macro_release, r28
001cce 93d0 28e5                 	sts triangle_duty_macro_loop, r29
001cd0 cf9c                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_read_header:
001cd1 93ef                      	push ZL
001cd2 93ff                      	push ZH
001cd3 2fec                      	mov ZL, r28
001cd4 2ffd                      	mov ZH, r29
001cd5 0fee                      	lsl ZL
001cd6 1fff                      	rol ZH
001cd7 91c5                      	lpm r28, Z+
001cd8 91d4                      	lpm r29, Z
001cd9 91ff                      	pop ZH
001cda 91ef                      	pop ZL
001cdb 9508                      	ret
                                 
                                 sound_driver_channel2_instrument_change_read_header_arpeggio:
001cdc 93ef                      	push ZL
001cdd 93ff                      	push ZH
001cde 2fec                      	mov ZL, r28
001cdf 2ffd                      	mov ZH, r29
001ce0 0fee                      	lsl ZL
001ce1 1fff                      	rol ZH
001ce2 91c5                      	lpm r28, Z+
001ce3 91d5                      	lpm r29, Z+
001ce4 93c0 28d3                 	sts triangle_arpeggio_macro_release, r28
001ce6 93d0 28d2                 	sts triangle_arpeggio_macro_loop, r29
001ce8 91c4                      	lpm r28, Z
001ce9 93c0 28d4                 	sts triangle_arpeggio_macro_mode, r28
001ceb 91ff                      	pop ZH
001cec 91ef                      	pop ZL
001ced 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel2_release:
                                 sound_driver_channel2_release_volume:
001cee 91b0 28ce                 	lds r27, triangle_volume_macro_release
001cf0 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001cf1 f019                      	breq sound_driver_channel2_release_arpeggio //if the macro has no release flag, check the next macro
001cf2 95b3                      	inc r27
001cf3 93b0 28cc                 	sts triangle_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel2_release_arpeggio:
001cf5 91b0 28d3                 	lds r27, triangle_arpeggio_macro_release
001cf7 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001cf8 f019                      	breq sound_driver_channel2_release_pitch
001cf9 95b3                      	inc r27
001cfa 93b0 28d1                 	sts triangle_arpeggio_macro_offset, r27
                                 sound_driver_channel2_release_pitch:
001cfc 91b0 28db                 	lds r27, triangle_pitch_macro_release
001cfe 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001cff f019                      	breq sound_driver_channel2_release_hi_pitch
001d00 95b3                      	inc r27
001d01 93b0 28d9                 	sts triangle_pitch_macro_offset, r27
                                 sound_driver_channel2_release_hi_pitch:
001d03 91b0 28e1                 	lds r27, triangle_hi_pitch_macro_release
001d05 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001d06 f019                      	breq sound_driver_channel2_release_duty
001d07 95b3                      	inc r27
001d08 93b0 28df                 	sts triangle_hi_pitch_macro_offset, r27
                                 sound_driver_channel2_release_duty:
001d0a 91b0 28e6                 	lds r27, triangle_duty_macro_release
001d0c 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001d0d f019                      	breq sound_driver_channel2_release_exit
001d0e 95b3                      	inc r27
001d0f 93b0 28e4                 	sts triangle_duty_macro_offset, r27
                                 sound_driver_channel2_release_exit:
001d11 d019                      	rcall sound_driver_channel2_increment_offset
001d12 cd69                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_next_pattern:
001d13 91e0 2818                 	lds ZL, song_frames
001d15 91f0 2819                 	lds ZH, song_frames+1
001d17 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001d19 91b0 281b                 	lds r27, song_frame_offset+1
001d1b 9614                      	adiw r27:r26, 4 //offset for channel 2
001d1c 0fea                      	add ZL, r26
001d1d 1ffb                      	adc ZH, r27
                                 
001d1e 91a5                      	lpm r26, Z+ //load the address of the next pattern
001d1f 91b4                      	lpm r27, Z
001d20 0faa                      	lsl r26
001d21 1fbb                      	rol r27
001d22 93a0 28c4                 	sts triangle_pattern, r26
001d24 93b0 28c5                 	sts triangle_pattern+1, r27
                                 
001d26 9220 28c8                 	sts triangle_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001d28 9220 28c9                 	sts triangle_pattern_offset+1, zero
001d2a cd51                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_increment_offset:
001d2b 91e0 28c8                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
001d2d 91f0 28c9                 	lds ZH, triangle_pattern_offset+1
001d2f 9631                      	adiw Z, 1
001d30 93e0 28c8                 	sts triangle_pattern_offset, ZL
001d32 93f0 28c9                 	sts triangle_pattern_offset+1, ZH
001d34 9508                      	ret
                                 
                                 sound_driver_channel2_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001d35 91e0 28c8                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
001d37 91f0 28c9                 	lds ZH, triangle_pattern_offset+1
001d39 9632                      	adiw Z, 2 //increment the pointer twice
001d3a 93e0 28c8                 	sts triangle_pattern_offset, ZL
001d3c 93f0 28c9                 	sts triangle_pattern_offset+1, ZH
001d3e 9508                      	ret
                                 
                                 sound_driver_channel2_decrement_frame_delay:
001d3f 95ba                      	dec r27
001d40 93b0 28c7                 	sts triangle_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel3:
001d42 91a0 2912                 	lds r26, noise_pattern_delay_rows
001d44 91b0 2913                 	lds r27, noise_pattern_delay_frames
001d46 9610                      	adiw r27:r26, 0
001d47 f009                      	breq sound_driver_channel3_main //if the pattern delay is 0, proceed with sound driver procedures
001d48 c2d1                      	rjmp sound_driver_channel3_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel3_main:
001d49 91e0 2910                 	lds ZL, noise_pattern //current pattern for noise
001d4b 91f0 2911                 	lds ZH, noise_pattern+1
001d4d 91a0 2914                 	lds r26, noise_pattern_offset //current offset in the pattern for noise
001d4f 91b0 2915                 	lds r27, noise_pattern_offset+1
001d51 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001d52 1ffb                      	adc ZH, r27
001d53 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel3_check_if_note: //check if data is a note (0x00 - 0x56)
001d54 35b7                      	cpi r27, 0x57
001d55 f408                      	brsh sound_driver_channel3_check_if_volume
001d56 c17a                      	rjmp sound_driver_channel3_note
                                 sound_driver_channel3_check_if_volume: //check if data is volume (0x57-0x66)
001d57 36b7                      	cpi r27, 0x67
001d58 f408                      	brsh sound_driver_channel3_check_if_delay
001d59 c1b1                      	rjmp sound_driver_channel3_volume
                                 sound_driver_channel3_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001d5a 3eb3                      	cpi r27, 0xE3
001d5b f408                      	brsh sound_driver_channel3_check_if_instrument
001d5c c1b7                      	rjmp sound_driver_channel3_delay
                                 sound_driver_channel3_check_if_instrument: //check for instrument flag (0xE3)
001d5d f409                      	brne sound_driver_channel3_check_if_release
001d5e c1ba                      	rjmp sound_driver_channel3_instrument_change 
                                 sound_driver_channel3_check_if_release: //check for note release flag (0xE4)
001d5f 3eb4                      	cpi r27, 0xE4
001d60 f409                      	brne sound_driver_channel3_check_if_end
001d61 c263                      	rjmp sound_driver_channel3_release
                                 sound_driver_channel3_check_if_end:
001d62 3fbf                      	cpi r27, 0xFF
001d63 f409                      	brne sound_driver_channel3_check_if_fx
001d64 c285                      	rjmp sound_driver_channel3_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel3_check_if_fx: //fx flags (0xE5 - 0xFE)
001d65 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001d66 91a4                      	lpm r26, Z //load the fx data into r26
001d67 d2a8                      	rcall sound_driver_channel3_increment_offset_twice
                                 
001d68 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001d69 e5e0                      	ldi ZL, LOW(channel3_fx << 1) //load in note table
001d6a e5fc                      	ldi ZH, HIGH(channel3_fx << 1)
001d6b 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001d6c 0feb                      	add ZL, r27 //add offset
001d6d 1df2                      	adc ZH, zero
001d6e 91c5                      	lpm r28, Z+ //load address bytes
001d6f 91d4                      	lpm r29, Z
001d70 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001d71 2ffd                      	mov ZH, r29
001d72 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel3_fx_0xy:
001d73 93a0 2933                 	sts noise_fx_0xy_sequence, r26
001d75 9220 2934                 	sts noise_fx_0xy_sequence+1, zero
001d77 cfd1                      	rjmp sound_driver_channel3_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel3_fx_1xx:
001d78 9220 2939                 	sts noise_fx_2xx, zero //turn off any 2xx pitch slide down
001d7a 9220 293a                 	sts noise_fx_2xx+1, zero
001d7c 9220 2933                 	sts noise_fx_0xy_sequence, zero //disable any 0xy effect
001d7e 9220 2934                 	sts noise_fx_0xy_sequence+1, zero
001d80 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001d81 937f                      	push r23
001d82 2f6a                      	mov r22, r26 //store the rate into r22
001d83 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001d84 9f67                      	mul r22, r23
001d85 917f                      	pop r23
001d86 916f                      	pop r22
                                 
001d87 9416                      	lsr r1 //shift out the fractional bits
001d88 9407                      	ror r0
001d89 9416                      	lsr r1
001d8a 9407                      	ror r0
001d8b 9416                      	lsr r1
001d8c 9407                      	ror r0
001d8d 9416                      	lsr r1
001d8e 9407                      	ror r0
001d8f 9200 2935                 	sts noise_fx_1xx, r0
001d91 9210 2936                 	sts noise_fx_1xx+1, r1
001d93 cfb5                      	rjmp sound_driver_channel3_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel3_fx_2xx:
001d94 9220 2935                 	sts noise_fx_1xx, zero //turn off any 1xx pitch slide down
001d96 9220 2936                 	sts noise_fx_1xx+1, zero
001d98 9220 2933                 	sts noise_fx_0xy_sequence, zero //disable any 0xy effect
001d9a 9220 2934                 	sts noise_fx_0xy_sequence+1, zero
001d9c 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001d9d 937f                      	push r23
001d9e 2f6a                      	mov r22, r26 //store the rate into r22
001d9f eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001da0 9f67                      	mul r22, r23
001da1 917f                      	pop r23
001da2 916f                      	pop r22
                                 
001da3 9416                      	lsr r1 //shift out the fractional bits
001da4 9407                      	ror r0
001da5 9416                      	lsr r1
001da6 9407                      	ror r0
001da7 9416                      	lsr r1
001da8 9407                      	ror r0
001da9 9416                      	lsr r1
001daa 9407                      	ror r0
001dab 9200 2939                 	sts noise_fx_2xx, r0
001dad 9210 293a                 	sts noise_fx_2xx+1, r1
001daf cf99                      	rjmp sound_driver_channel3_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel3_fx_3xx:
001db0 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001db1 937f                      	push r23
001db2 2f6a                      	mov r22, r26 //store the rate into r22
001db3 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001db4 9f67                      	mul r22, r23
001db5 917f                      	pop r23
001db6 916f                      	pop r22
                                 
001db7 9416                      	lsr r1 //shift out the fractional bits
001db8 9407                      	ror r0
001db9 9416                      	lsr r1
001dba 9407                      	ror r0
001dbb 9416                      	lsr r1
001dbc 9407                      	ror r0
001dbd 9416                      	lsr r1
001dbe 9407                      	ror r0
001dbf 9200 2941                 	sts noise_fx_3xx_speed, r0
001dc1 9210 2942                 	sts noise_fx_3xx_speed+1, r1
                                 
001dc3 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001dc4 c001                      	rjmp sound_driver_channel3_fx_3xx_enabled
001dc5 cf83                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_3xx_enabled:
001dc6 91a0 0abc                 	lds r26, TCB3_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001dc8 91b0 0abd                 	lds r27, TCB3_CCMPH
001dca 93a0 293d                 	sts noise_fx_3xx_start, r26
001dcc 93b0 293e                 	sts noise_fx_3xx_start+1, r27
                                 
001dce 9220 2943                 	sts noise_fx_3xx_total_offset, zero
001dd0 9220 2944                 	sts noise_fx_3xx_total_offset+1, zero
001dd2 cf76                      	rjmp sound_driver_channel3_main
                                 
                                 //VIBRATO
                                 sound_driver_channel3_fx_4xy:
001dd3 2fba                      	mov r27, r26
001dd4 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001dd5 95a2                      	swap r26
001dd6 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001dd7 93a0 2945                 	sts noise_fx_4xy_speed, r26
001dd9 93b0 2946                 	sts noise_fx_4xy_depth, r27
001ddb 9220 2947                 	sts noise_fx_4xy_phase, zero //reset the phase to 0
001ddd cf6b                      	rjmp sound_driver_channel3_main
                                 
                                 //TREMELO
                                 sound_driver_channel3_fx_7xy:
001dde 2fba                      	mov r27, r26
001ddf 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001de0 95a2                      	swap r26
001de1 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001de2 93a0 2948                 	sts noise_fx_7xy_speed, r26
001de4 93b0 2949                 	sts noise_fx_7xy_depth, r27
001de6 9220 294a                 	sts noise_fx_7xy_phase, zero //reset the phase to 0
001de8 9220 294b                 	sts noise_fx_7xy_value, zero //reset the tremelo value
001dea cf5e                      	rjmp sound_driver_channel3_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel3_fx_Axy:
001deb 93a0 294c                 	sts noise_fx_Axy, r26
001ded cf5b                      	rjmp sound_driver_channel3_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel3_fx_Bxx:
001dee 93a0 281f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001df0 cf58                      	rjmp sound_driver_channel3_main
                                 
                                 //HALT
                                 sound_driver_channel3_fx_Cxx:
001df1 93b0 2820                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001df3 cf55                      	rjmp sound_driver_channel3_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel3_fx_Dxx:
001df4 93b0 2821                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001df6 cf52                      	rjmp sound_driver_channel3_main
                                 
                                 //VOLUME
                                 sound_driver_channel3_fx_Exx:
001df7 91b0 2813                 	lds r27, noise_param
001df9 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
001dfa 2bba                      	or r27, r26 //move new VVVV bits into noise_param
001dfb 93b0 2813                 	sts noise_param, r27
001dfd cf4b                      	rjmp sound_driver_channel3_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel3_fx_Fxx:
001dfe 93a0 281e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001e00 cf48                      	rjmp sound_driver_channel3_main
                                 
                                 //DELAY
                                 sound_driver_channel3_fx_Gxx:
001e01 15a2                      	cp r26, zero
001e02 f051                      	breq sound_driver_channel3_fx_Gxx_invalid
001e03 91b0 281e                 	lds r27, song_speed
001e05 17ab                      	cp r26, r27
001e06 f430                      	brsh sound_driver_channel3_fx_Gxx_invalid
001e07 93a0 294d                 	sts noise_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001e09 e0b1                      	ldi r27, 0x01
001e0a 93b0 2912                 	sts noise_pattern_delay_rows, r27
001e0c c210                      	rjmp sound_driver_channel4
                                 sound_driver_channel3_fx_Gxx_invalid:
001e0d cf3b                      	rjmp sound_driver_channel3_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel3_fx_Hxy: //hardware sweep up
001e0e cf3a                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Ixy: //hardware sweep down
001e0f cf39                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Hxx: //FDS modulation depth
001e10 cf38                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Ixx: //FDS modulation speed
001e11 cf37                      	rjmp sound_driver_channel3_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel3_fx_Pxx:
001e12 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001e13 937f                      	push r23
001e14 2f6a                      	mov r22, r26
001e15 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001e16 0367                      	mulsu r22, r23
001e17 917f                      	pop r23
001e18 916f                      	pop r22
001e19 9416                      	lsr r1 //shift out the fractional bits
001e1a 9407                      	ror r0
001e1b 9416                      	lsr r1
001e1c 9407                      	ror r0
001e1d 9416                      	lsr r1
001e1e 9407                      	ror r0
001e1f 9416                      	lsr r1
001e20 9407                      	ror r0
001e21 fe13                      	sbrs r1, 3 //check if result was a negative number
001e22 c002                      	rjmp sound_driver_channel3_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel3_fx_Pxx_negative:
001e23 efb0                      	ldi r27, 0xF0
001e24 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel3_fx_Pxx_store:
001e25 9200 294f                 	sts noise_fx_Pxx_total, r0
001e27 9210 2950                 	sts noise_fx_Pxx_total+1, r1
001e29 cf1f                      	rjmp sound_driver_channel3_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel3_fx_Qxy:
                                 sound_driver_channel3_fx_Qxy_check_arpeggio_macro:
001e2a 91e0 291b                 	lds ZL, noise_arpeggio_macro
001e2c 91f0 291c                 	lds ZH, noise_arpeggio_macro+1
001e2e 9630                      	adiw Z, 0
001e2f f009                      	breq sound_driver_channel3_fx_Qxy_check_pitch_macro
001e30 cf18                      	rjmp sound_driver_channel3_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Qxy_check_pitch_macro:
001e31 91e0 2923                 	lds ZL, noise_pitch_macro
001e33 91f0 2924                 	lds ZH, noise_pitch_macro+1
001e35 9630                      	adiw Z, 0
001e36 f009                      	breq sound_driver_channel3_fx_Qxy_check_hi_pitch_macro
001e37 cf11                      	rjmp sound_driver_channel3_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Qxy_check_hi_pitch_macro:
001e38 91e0 2929                 	lds ZL, noise_hi_pitch_macro
001e3a 91f0 292a                 	lds ZH, noise_hi_pitch_macro+1
001e3c 9630                      	adiw Z, 0
001e3d f009                      	breq sound_driver_channel3_fx_Qxy_process
001e3e cf0a                      	rjmp sound_driver_channel3_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Qxy_process:
001e3f 2fba                      	mov r27, r26 //copy fx parameters into r27
001e40 70bf                      	andi r27, 0x0F //mask note index offset
001e41 91c0 2817                 	lds r28, noise_note //load current note index
001e43 0fbc                      	add r27, r28
001e44 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001e45 f008                      	brlo sound_driver_channel3_fx_Qxy_process_continue
001e46 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel3_fx_Qxy_process_continue:
001e47 93b0 2951                 	sts noise_fx_Qxy_target_note, r27
001e49 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001e4a e0f0                      	ldi ZH, HIGH(note_table << 1)
001e4b 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001e4c 0feb                      	add ZL, r27 //add offset
001e4d 1df2                      	adc ZH, zero
001e4e 91c5                      	lpm r28, Z+ //load bytes
001e4f 91d4                      	lpm r29, Z
001e50 93c0 2952                 	sts noise_fx_Qxy_target, r28 //load the LOW bits for the target period
001e52 93d0 2953                 	sts noise_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
001e54 95a2                      	swap r26
001e55 70af                      	andi r26, 0x0F //mask effect speed
001e56 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001e57 95a3                      	inc r26 //increment the speed by 1
                                 
001e58 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001e59 937f                      	push r23
001e5a 2f6a                      	mov r22, r26 //store the speed data into r27
001e5b eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001e5c 9f67                      	mul r22, r23
001e5d 917f                      	pop r23
001e5e 916f                      	pop r22
                                 
001e5f 9416                      	lsr r1 //shift out the fractional bits
001e60 9407                      	ror r0
001e61 9416                      	lsr r1
001e62 9407                      	ror r0
001e63 9416                      	lsr r1
001e64 9407                      	ror r0
001e65 9416                      	lsr r1
001e66 9407                      	ror r0
                                 
001e67 9200 2954                 	sts noise_fx_Qxy_speed, r0 //store the effect speed
001e69 9210 2955                 	sts noise_fx_Qxy_speed+1, r1
001e6b 9220 2956                 	sts noise_fx_Qxy_total_offset, zero
001e6d 9220 2957                 	sts noise_fx_Qxy_total_offset+1, zero
001e6f ced9                      	rjmp sound_driver_channel3_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel3_fx_Rxy:
                                 sound_driver_channel3_fx_Rxy_check_arpeggio_macro:
001e70 91e0 291b                 	lds ZL, noise_arpeggio_macro
001e72 91f0 291c                 	lds ZH, noise_arpeggio_macro+1
001e74 9630                      	adiw Z, 0
001e75 f009                      	breq sound_driver_channel3_fx_Rxy_check_pitch_macro
001e76 ced2                      	rjmp sound_driver_channel3_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Rxy_check_pitch_macro:
001e77 91e0 2923                 	lds ZL, noise_pitch_macro
001e79 91f0 2924                 	lds ZH, noise_pitch_macro+1
001e7b 9630                      	adiw Z, 0
001e7c f009                      	breq sound_driver_channel3_fx_Rxy_check_hi_pitch_macro
001e7d cecb                      	rjmp sound_driver_channel3_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Rxy_check_hi_pitch_macro:
001e7e 91e0 2929                 	lds ZL, noise_hi_pitch_macro
001e80 91f0 292a                 	lds ZH, noise_hi_pitch_macro+1
001e82 9630                      	adiw Z, 0
001e83 f009                      	breq sound_driver_channel3_fx_Rxy_process
001e84 cec4                      	rjmp sound_driver_channel3_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Rxy_process:
001e85 2fba                      	mov r27, r26 //copy fx parameters into r27
001e86 70bf                      	andi r27, 0x0F //mask note index offset
001e87 91c0 2817                 	lds r28, noise_note //load current note index
001e89 1bcb                      	sub r28, r27
001e8a f408                      	brcc sound_driver_channel3_fx_Rxy_process_continue
001e8b e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel3_fx_Rxy_process_continue:
001e8c 93c0 2958                 	sts noise_fx_Rxy_target_note, r28
001e8e e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001e8f e0f0                      	ldi ZH, HIGH(note_table << 1)
001e90 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001e91 0fec                      	add ZL, r28 //add offset
001e92 1df2                      	adc ZH, zero
001e93 91c5                      	lpm r28, Z+ //load bytes
001e94 91d4                      	lpm r29, Z
001e95 93c0 2959                 	sts noise_fx_Rxy_target, r28 //load the LOW bits for the target period
001e97 93d0 295a                 	sts noise_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
001e99 95a2                      	swap r26
001e9a 70af                      	andi r26, 0x0F //mask effect speed
001e9b 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001e9c 95a3                      	inc r26 //increment the speed by 1
                                 
001e9d 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001e9e 937f                      	push r23
001e9f 2f6a                      	mov r22, r26 //store the speed data into r27
001ea0 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001ea1 9f67                      	mul r22, r23
001ea2 917f                      	pop r23
001ea3 916f                      	pop r22
                                 
001ea4 9416                      	lsr r1 //shift out the fractional bits
001ea5 9407                      	ror r0
001ea6 9416                      	lsr r1
001ea7 9407                      	ror r0
001ea8 9416                      	lsr r1
001ea9 9407                      	ror r0
001eaa 9416                      	lsr r1
001eab 9407                      	ror r0
                                 
001eac 9200 295b                 	sts noise_fx_Rxy_speed, r0 //store the effect speed
001eae 9210 295c                 	sts noise_fx_Rxy_speed+1, r1
001eb0 9220 295d                 	sts noise_fx_Rxy_total_offset, zero
001eb2 9220 295e                 	sts noise_fx_Rxy_total_offset+1, zero
001eb4 ce94                      	rjmp sound_driver_channel3_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel3_fx_Sxx:
001eb5 15a2                      	cp r26, zero
001eb6 f051                      	breq sound_driver_channel3_fx_Sxx_invalid
001eb7 91b0 281e                 	lds r27, song_speed
001eb9 17ab                      	cp r26, r27
001eba f430                      	brsh sound_driver_channel3_fx_Sxx_invalid
001ebb 93a0 295f                 	sts noise_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001ebd e0b1                      	ldi r27, 0x01
001ebe 93b0 2912                 	sts noise_pattern_delay_rows, r27
001ec0 c15c                      	rjmp sound_driver_channel4
                                 sound_driver_channel3_fx_Sxx_invalid:
001ec1 ce87                      	rjmp sound_driver_channel3_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel3_fx_Vxx:
001ec2 95a6                      	lsr r26
001ec3 95a7                      	ror r26 //move mode bit to bit 7
001ec4 91b0 2814                 	lds r27, noise_period
001ec6 77bf                      	andi r27, 0b01111111
001ec7 2bba                      	or r27, r26 //store the new noise mode
001ec8 93b0 2813                 	sts noise_param, r27
                                 
001eca 776f                      	andi noise_sequence_HIGH, 0b01111111
001ecb 2b6a                      	or noise_sequence_HIGH, r26
001ecc ce7c                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_Wxx: //DPCM sample speed
001ecd ce7b                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Xxx: //DPCM sample retrigger
001ece ce7a                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Yxx: //DPCM sample offset
001ecf ce79                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Zxx: //DPCM sample delta counter
001ed0 ce78                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 sound_driver_channel3_note:
001ed1 93b0 2817                 	sts noise_note, r27 //store the note index
001ed3 e0a3                      	ldi r26, 0x03
001ed4 e0b2                      	ldi r27, 0x02
001ed5 93b0 2918                 	sts noise_volume_macro_offset, r27 //reset all macro offsets
001ed7 93a0 291d                 	sts noise_arpeggio_macro_offset, r26
001ed9 93b0 2925                 	sts noise_pitch_macro_offset, r27
001edb 93b0 292b                 	sts noise_hi_pitch_macro_offset, r27
001edd 93b0 2930                 	sts noise_duty_macro_offset, r27
001edf 9220 2921                 	sts noise_total_pitch_offset, zero //reset the pitch and hi pitch offset
001ee1 9220 2922                 	sts noise_total_pitch_offset+1, zero
001ee3 9220 2928                 	sts noise_total_hi_pitch_offset, zero
001ee5 9220 2937                 	sts noise_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001ee7 9220 2938                 	sts noise_fx_1xx_total+1, zero
001ee9 9220 293b                 	sts noise_fx_2xx_total, zero
001eeb 9220 293c                 	sts noise_fx_2xx_total+1, zero
001eed 9220 2943                 	sts noise_fx_3xx_total_offset, zero //reset 3xx offset
001eef 9220 2944                 	sts noise_fx_3xx_total_offset+1, zero
001ef1 91a0 0abc                 	lds r26, TCB3_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001ef3 91b0 0abd                 	lds r27, TCB3_CCMPH
001ef5 93a0 293d                 	sts noise_fx_3xx_start, r26
001ef7 93b0 293e                 	sts noise_fx_3xx_start+1, r27
001ef9 9220 2952                 	sts noise_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001efb 9220 2953                 	sts noise_fx_Qxy_target+1, zero
001efd 9220 2956                 	sts noise_fx_Qxy_total_offset, zero
001eff 9220 2957                 	sts noise_fx_Qxy_total_offset+1, zero
001f01 9220 2959                 	sts noise_fx_Rxy_target, zero
001f03 9220 295a                 	sts noise_fx_Rxy_target+1, zero
001f05 9220 295d                 	sts noise_fx_Rxy_total_offset, zero
001f07 9220 295e                 	sts noise_fx_Rxy_total_offset+1, zero
001f09 d0fc                      	rcall sound_driver_channel3_increment_offset
001f0a ce3e                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_volume:
001f0b 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001f0c 91a0 2813                 	lds r26, noise_param
001f0e 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001f0f 2bab                      	or r26, r27 //move new VVVV bits into noise_param
001f10 93a0 2813                 	sts noise_param, r26
001f12 d0f3                      	rcall sound_driver_channel3_increment_offset
001f13 ce35                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_delay:
001f14 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001f15 93b0 2912                 	sts noise_pattern_delay_rows, r27
001f17 d0ee                      	rcall sound_driver_channel3_increment_offset
001f18 c104                      	rjmp sound_driver_channel4
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change:
001f19 9220 2916                 	sts noise_volume_macro, zero //reset all macro addresses
001f1b 9220 2917                 	sts noise_volume_macro+1, zero
001f1d 9220 291b                 	sts noise_arpeggio_macro, zero
001f1f 9220 291c                 	sts noise_arpeggio_macro+1, zero
001f21 9220 2923                 	sts noise_pitch_macro, zero
001f23 9220 2924                 	sts noise_pitch_macro+1, zero
001f25 9220 2929                 	sts noise_hi_pitch_macro, zero
001f27 9220 292a                 	sts noise_hi_pitch_macro+1, zero
001f29 9220 292e                 	sts noise_duty_macro, zero
001f2b 9220 292f                 	sts noise_duty_macro+1, zero
001f2d 9220 2921                 	sts noise_total_pitch_offset, zero //reset the pitch offset
001f2f 9220 2922                 	sts noise_total_pitch_offset+1, zero
001f31 9220 2928                 	sts noise_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001f33 9631                      	adiw Z, 1 //point to the byte next to the flag
001f34 91b4                      	lpm r27, Z //store the instrument offset into r27
001f35 e2ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
001f36 e0fd                      	ldi ZH, HIGH(instruments)
001f37 0feb                      	add ZL, r27 //point Z to offsetted instrument
001f38 1df2                      	adc ZH, zero
001f39 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001f3a 1fff                      	rol ZH
001f3b 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001f3c 91b4                      	lpm r27, Z
                                 
001f3d 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001f3e 1fbb                      	rol r27
001f3f 2fea                      	mov ZL, r26
001f40 2ffb                      	mov ZH, r27
001f41 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001f42 9632                      	adiw Z, 2 //point Z to the address of the macro
001f43 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel3_instrument_change_macro_loop:
001f44 95aa                      	dec r26
001f45 f019                      	breq sound_driver_channel3_instrument_change_exit
001f46 95b6                      	lsr r27
001f47 f078                      	brcs sound_driver_channel3_instrument_change_load_macro
001f48 cffb                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_exit:
001f49 e0a3                      	ldi r26, 0x03
001f4a e0b2                      	ldi r27, 0x02
001f4b 93b0 2918                 	sts noise_volume_macro_offset, r27 //reset all macro offsets
001f4d 93a0 291d                 	sts noise_arpeggio_macro_offset, r26
001f4f 93b0 2925                 	sts noise_pitch_macro_offset, r27
001f51 93b0 292b                 	sts noise_hi_pitch_macro_offset, r27
001f53 93b0 2930                 	sts noise_duty_macro_offset, r27
001f55 d0ba                      	rcall sound_driver_channel3_increment_offset_twice
001f56 cdf2                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_load_macro:
001f57 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001f58 91d5                      	lpm r29, Z+
                                 
001f59 30a5                      	cpi r26, 5
001f5a f039                      	breq sound_driver_channel3_instrument_change_load_macro_volume
001f5b 30a4                      	cpi r26, 4
001f5c f079                      	breq sound_driver_channel3_instrument_change_load_macro_arpeggio
001f5d 30a3                      	cpi r26, 3
001f5e f0d9                      	breq sound_driver_channel3_instrument_change_load_macro_pitch
001f5f 30a2                      	cpi r26, 2
001f60 f159                      	breq sound_driver_channel3_instrument_change_load_macro_hi_pitch
001f61 c03c                      	rjmp sound_driver_channel3_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel3_instrument_change_load_macro_volume:
001f62 93c0 2916                 	sts noise_volume_macro, r28
001f64 93d0 2917                 	sts noise_volume_macro+1, r29
001f66 d041                      	rcall sound_driver_channel3_instrument_change_read_header
001f67 93c0 291a                 	sts noise_volume_macro_release, r28
001f69 93d0 2919                 	sts noise_volume_macro_loop, r29
001f6b cfd8                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 	
                                 sound_driver_channel3_instrument_change_load_macro_arpeggio:
001f6c 93c0 291b                 	sts noise_arpeggio_macro, r28
001f6e 93d0 291c                 	sts noise_arpeggio_macro+1, r29
001f70 9220 2952                 	sts noise_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001f72 9220 2953                 	sts noise_fx_Qxy_target+1, zero
001f74 9220 2959                 	sts noise_fx_Rxy_target, zero
001f76 9220 295a                 	sts noise_fx_Rxy_target+1, zero
001f78 d03a                      	rcall sound_driver_channel3_instrument_change_read_header_arpeggio
001f79 cfca                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_pitch:
001f7a 93c0 2923                 	sts noise_pitch_macro, r28
001f7c 93d0 2924                 	sts noise_pitch_macro+1, r29
001f7e 9220 2952                 	sts noise_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001f80 9220 2953                 	sts noise_fx_Qxy_target+1, zero
001f82 9220 2959                 	sts noise_fx_Rxy_target, zero
001f84 9220 295a                 	sts noise_fx_Rxy_target+1, zero
001f86 d021                      	rcall sound_driver_channel3_instrument_change_read_header
001f87 93c0 2927                 	sts noise_pitch_macro_release, r28
001f89 93d0 2926                 	sts noise_pitch_macro_loop, r29
001f8b cfb8                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_hi_pitch:
001f8c 93c0 2929                 	sts noise_hi_pitch_macro, r28
001f8e 93d0 292a                 	sts noise_hi_pitch_macro+1, r29
001f90 9220 2952                 	sts noise_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001f92 9220 2953                 	sts noise_fx_Qxy_target+1, zero
001f94 9220 2959                 	sts noise_fx_Rxy_target, zero
001f96 9220 295a                 	sts noise_fx_Rxy_target+1, zero
001f98 d00f                      	rcall sound_driver_channel3_instrument_change_read_header
001f99 93c0 292d                 	sts noise_hi_pitch_macro_release, r28
001f9b 93d0 292c                 	sts noise_hi_pitch_macro_loop, r29
001f9d cfa6                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_duty:
001f9e 93c0 292e                 	sts noise_duty_macro, r28
001fa0 93d0 292f                 	sts noise_duty_macro+1, r29
001fa2 d005                      	rcall sound_driver_channel3_instrument_change_read_header
001fa3 93c0 2932                 	sts noise_duty_macro_release, r28
001fa5 93d0 2931                 	sts noise_duty_macro_loop, r29
001fa7 cf9c                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_read_header:
001fa8 93ef                      	push ZL
001fa9 93ff                      	push ZH
001faa 2fec                      	mov ZL, r28
001fab 2ffd                      	mov ZH, r29
001fac 0fee                      	lsl ZL
001fad 1fff                      	rol ZH
001fae 91c5                      	lpm r28, Z+
001faf 91d4                      	lpm r29, Z
001fb0 91ff                      	pop ZH
001fb1 91ef                      	pop ZL
001fb2 9508                      	ret
                                 
                                 sound_driver_channel3_instrument_change_read_header_arpeggio:
001fb3 93ef                      	push ZL
001fb4 93ff                      	push ZH
001fb5 2fec                      	mov ZL, r28
001fb6 2ffd                      	mov ZH, r29
001fb7 0fee                      	lsl ZL
001fb8 1fff                      	rol ZH
001fb9 91c5                      	lpm r28, Z+
001fba 91d5                      	lpm r29, Z+
001fbb 93c0 291f                 	sts noise_arpeggio_macro_release, r28
001fbd 93d0 291e                 	sts noise_arpeggio_macro_loop, r29
001fbf 91c4                      	lpm r28, Z
001fc0 93c0 2920                 	sts noise_arpeggio_macro_mode, r28
001fc2 91ff                      	pop ZH
001fc3 91ef                      	pop ZL
001fc4 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel3_release:
                                 sound_driver_channel3_release_volume:
001fc5 91b0 291a                 	lds r27, noise_volume_macro_release
001fc7 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001fc8 f019                      	breq sound_driver_channel3_release_arpeggio //if the macro has no release flag, check the next macro
001fc9 95b3                      	inc r27
001fca 93b0 2918                 	sts noise_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel3_release_arpeggio:
001fcc 91b0 291f                 	lds r27, noise_arpeggio_macro_release
001fce 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001fcf f019                      	breq sound_driver_channel3_release_pitch
001fd0 95b3                      	inc r27
001fd1 93b0 291d                 	sts noise_arpeggio_macro_offset, r27
                                 sound_driver_channel3_release_pitch:
001fd3 91b0 2927                 	lds r27, noise_pitch_macro_release
001fd5 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001fd6 f019                      	breq sound_driver_channel3_release_hi_pitch
001fd7 95b3                      	inc r27
001fd8 93b0 2925                 	sts noise_pitch_macro_offset, r27
                                 sound_driver_channel3_release_hi_pitch:
001fda 91b0 292d                 	lds r27, noise_hi_pitch_macro_release
001fdc 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001fdd f019                      	breq sound_driver_channel3_release_duty
001fde 95b3                      	inc r27
001fdf 93b0 292b                 	sts noise_hi_pitch_macro_offset, r27
                                 sound_driver_channel3_release_duty:
001fe1 91b0 2932                 	lds r27, noise_duty_macro_release
001fe3 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001fe4 f019                      	breq sound_driver_channel3_release_exit
001fe5 95b3                      	inc r27
001fe6 93b0 2930                 	sts noise_duty_macro_offset, r27
                                 sound_driver_channel3_release_exit:
001fe8 d01d                      	rcall sound_driver_channel3_increment_offset
001fe9 cd5f                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_next_pattern:
001fea 91e0 2818                 	lds ZL, song_frames
001fec 91f0 2819                 	lds ZH, song_frames+1
001fee 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001ff0 91b0 281b                 	lds r27, song_frame_offset+1
001ff2 93a0 281a                 	sts song_frame_offset, r26
001ff4 93b0 281b                 	sts song_frame_offset+1, r27
001ff6 9616                      	adiw r27:r26, 6 //offset for channel 3
001ff7 0fea                      	add ZL, r26
001ff8 1ffb                      	adc ZH, r27
                                 
001ff9 91a5                      	lpm r26, Z+ //load the address of the next pattern
001ffa 91b4                      	lpm r27, Z
001ffb 0faa                      	lsl r26
001ffc 1fbb                      	rol r27
001ffd 93a0 2910                 	sts noise_pattern, r26
001fff 93b0 2911                 	sts noise_pattern+1, r27
                                 
002001 9220 2914                 	sts noise_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
002003 9220 2915                 	sts noise_pattern_offset+1, zero
002005 cd43                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_increment_offset:
002006 91e0 2914                 	lds ZL, noise_pattern_offset //current offset in the pattern for noise
002008 91f0 2915                 	lds ZH, noise_pattern_offset+1
00200a 9631                      	adiw Z, 1
00200b 93e0 2914                 	sts noise_pattern_offset, ZL
00200d 93f0 2915                 	sts noise_pattern_offset+1, ZH
00200f 9508                      	ret
                                 
                                 sound_driver_channel3_increment_offset_twice: //used for data that takes up 2 bytes worth of space
002010 91e0 2914                 	lds ZL, noise_pattern_offset //current offset in the pattern for noise
002012 91f0 2915                 	lds ZH, noise_pattern_offset+1
002014 9632                      	adiw Z, 2 //increment the pointer twice
002015 93e0 2914                 	sts noise_pattern_offset, ZL
002017 93f0 2915                 	sts noise_pattern_offset+1, ZH
002019 9508                      	ret
                                 
                                 sound_driver_channel3_decrement_frame_delay:
00201a 95ba                      	dec r27
00201b 93b0 2913                 	sts noise_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel4:
                                 
                                 sound_driver_calculate_delays:
00201d 91f0 281e                 	lds r31, song_speed
00201f 2fef                      	mov r30, r31
002020 50e1                      	subi r30, 1
                                 sound_driver_calculate_delays_pulse1:
002021 91a0 2825                 	lds r26, pulse1_pattern_delay_frames
002023 11a2                      	cpse r26, zero
002024 c042                      	rjmp sound_driver_calculate_delays_pulse2
002025 c000                      	rjmp sound_driver_calculate_delays_pulse1_main
                                 
                                 sound_driver_calculate_delays_pulse1_main:
002026 2faf                      	mov r26, r31 //move the speed to r26
002027 91b0 2824                 	lds r27, pulse1_pattern_delay_rows //decrement the delay rows
002029 15b2                      	cp r27, zero
00202a f409                      	brne PC+2
00202b c03b                      	rjmp sound_driver_calculate_delays_pulse2
00202c 95ba                      	dec r27
00202d 93b0 2824                 	sts pulse1_pattern_delay_rows, r27
00202f 11b2                      	cpse r27, zero
002030 c034                      	rjmp sound_driver_calculate_delays_pulse1_store
002031 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx:
002032 efbf                      	ldi r27, 0xFF
002033 91c0 2871                 	lds r28, pulse1_fx_Sxx_pre
002035 91d0 2872                 	lds r29, pulse1_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse1_Sxx_check_pre:
002037 17cb                      	cp r28, r27
002038 f009                      	breq sound_driver_calculate_delays_pulse1_Sxx_check_post
002039 c00d                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_pre
                                 sound_driver_calculate_delays_pulse1_Sxx_check_post:
00203a 17db                      	cp r29, r27
00203b f009                      	breq sound_driver_calculate_delays_pulse1_Gxx
00203c c015                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx:
00203d 91c0 285f                 	lds r28, pulse1_fx_Gxx_pre
00203f 91d0 2860                 	lds r29, pulse1_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse1_Gxx_check_pre:
002041 17cb                      	cp r28, r27
002042 f009                      	breq sound_driver_calculate_delays_pulse1_Gxx_check_post
002043 c012                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_pre
                                 sound_driver_calculate_delays_pulse1_Gxx_check_post:
002044 17db                      	cp r29, r27
002045 f0f9                      	breq sound_driver_calculate_delays_pulse1_store
002046 c01a                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_pre:
002047 93b0 2871                 	sts pulse1_fx_Sxx_pre, r27
002049 1bec                      	sub r30, r28 //(song speed)-1-Sxx
00204a 93e0 2872                 	sts pulse1_fx_Sxx_post, r30
00204c 95ca                      	dec r28
00204d 93c0 2825                 	sts pulse1_pattern_delay_frames, r28
00204f 2fef                      	mov r30, r31
002050 50e1                      	subi r30, 1
002051 c015                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_post:
002052 93b0 2872                 	sts pulse1_fx_Sxx_post, r27
002054 2fad                      	mov r26, r29
002055 c00f                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx_pre:
002056 93b0 285f                 	sts pulse1_fx_Gxx_pre, r27
002058 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002059 93e0 2860                 	sts pulse1_fx_Gxx_post, r30
00205b 95ca                      	dec r28
00205c 93c0 2825                 	sts pulse1_pattern_delay_frames, r28
00205e 2fef                      	mov r30, r31
00205f 50e1                      	subi r30, 1
002060 c006                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse1_Gxx_post:
002061 93b0 2860                 	sts pulse1_fx_Gxx_post, r27
002063 2fad                      	mov r26, r29
002064 c000                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_store:
002065 93a0 2825                 	sts pulse1_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_pulse2:
002067 91a0 2876                 	lds r26, pulse2_pattern_delay_frames
002069 11a2                      	cpse r26, zero
00206a c042                      	rjmp sound_driver_calculate_delays_triangle
00206b c000                      	rjmp sound_driver_calculate_delays_pulse2_main
                                 
                                 sound_driver_calculate_delays_pulse2_main:
00206c 2faf                      	mov r26, r31 //move the speed to r26
00206d 91b0 2875                 	lds r27, pulse2_pattern_delay_rows //decrement the delay rows
00206f 15b2                      	cp r27, zero
002070 f409                      	brne PC+2
002071 c03b                      	rjmp sound_driver_calculate_delays_triangle
002072 95ba                      	dec r27
002073 93b0 2875                 	sts pulse2_pattern_delay_rows, r27
002075 11b2                      	cpse r27, zero
002076 c034                      	rjmp sound_driver_calculate_delays_pulse2_store
002077 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx:
002078 efbf                      	ldi r27, 0xFF
002079 91c0 28c2                 	lds r28, pulse2_fx_Sxx_pre
00207b 91d0 28c3                 	lds r29, pulse2_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse2_Sxx_check_pre:
00207d 17cb                      	cp r28, r27
00207e f009                      	breq sound_driver_calculate_delays_pulse2_Sxx_check_post
00207f c00d                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_pre
                                 sound_driver_calculate_delays_pulse2_Sxx_check_post:
002080 17db                      	cp r29, r27
002081 f009                      	breq sound_driver_calculate_delays_pulse2_Gxx
002082 c015                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx:
002083 91c0 28b0                 	lds r28, pulse2_fx_Gxx_pre
002085 91d0 28b1                 	lds r29, pulse2_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse2_Gxx_check_pre:
002087 17cb                      	cp r28, r27
002088 f009                      	breq sound_driver_calculate_delays_pulse2_Gxx_check_post
002089 c012                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_pre
                                 sound_driver_calculate_delays_pulse2_Gxx_check_post:
00208a 17db                      	cp r29, r27
00208b f0f9                      	breq sound_driver_calculate_delays_pulse2_store
00208c c01a                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_pre:
00208d 93b0 28c2                 	sts pulse2_fx_Sxx_pre, r27
00208f 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002090 93e0 28c3                 	sts pulse2_fx_Sxx_post, r30
002092 95ca                      	dec r28
002093 93c0 2876                 	sts pulse2_pattern_delay_frames, r28
002095 2fef                      	mov r30, r31
002096 50e1                      	subi r30, 1
002097 cfcf                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_post:
002098 93b0 28c3                 	sts pulse2_fx_Sxx_post, r27
00209a 2fad                      	mov r26, r29
00209b c00f                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx_pre:
00209c 93b0 28b0                 	sts pulse2_fx_Gxx_pre, r27
00209e 1bec                      	sub r30, r28 //(song speed)-1-Sxx
00209f 93e0 28b1                 	sts pulse2_fx_Gxx_post, r30
0020a1 95ca                      	dec r28
0020a2 93c0 2876                 	sts pulse2_pattern_delay_frames, r28
0020a4 2fef                      	mov r30, r31
0020a5 50e1                      	subi r30, 1
0020a6 cfc0                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse2_Gxx_post:
0020a7 93b0 28b1                 	sts pulse2_fx_Gxx_post, r27
0020a9 2fad                      	mov r26, r29
0020aa c000                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_store:
0020ab 93a0 2876                 	sts pulse2_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_triangle:
0020ad 91a0 28c7                 	lds r26, triangle_pattern_delay_frames
0020af 11a2                      	cpse r26, zero
0020b0 c042                      	rjmp sound_driver_calculate_delays_noise
0020b1 c000                      	rjmp sound_driver_calculate_delays_triangle_main
                                 
                                 sound_driver_calculate_delays_triangle_main:
0020b2 2faf                      	mov r26, r31 //move the speed to r26
0020b3 91b0 28c6                 	lds r27, triangle_pattern_delay_rows //decrement the delay rows
0020b5 15b2                      	cp r27, zero
0020b6 f409                      	brne PC+2
0020b7 c03b                      	rjmp sound_driver_calculate_delays_noise
0020b8 95ba                      	dec r27
0020b9 93b0 28c6                 	sts triangle_pattern_delay_rows, r27
0020bb 11b2                      	cpse r27, zero
0020bc c034                      	rjmp sound_driver_calculate_delays_triangle_store
0020bd 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_triangle_Sxx:
0020be efbf                      	ldi r27, 0xFF
0020bf 91c0 290e                 	lds r28, triangle_fx_Sxx_pre
0020c1 91d0 290f                 	lds r29, triangle_fx_Sxx_post
                                 sound_driver_calculate_delays_triangle_Sxx_check_pre:
0020c3 17cb                      	cp r28, r27
0020c4 f009                      	breq sound_driver_calculate_delays_triangle_Sxx_check_post
0020c5 c00d                      	rjmp sound_driver_calculate_delays_triangle_Sxx_pre
                                 sound_driver_calculate_delays_triangle_Sxx_check_post:
0020c6 17db                      	cp r29, r27
0020c7 f009                      	breq sound_driver_calculate_delays_triangle_Gxx
0020c8 c015                      	rjmp sound_driver_calculate_delays_triangle_Sxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Gxx:
0020c9 91c0 28fc                 	lds r28, triangle_fx_Gxx_pre
0020cb 91d0 28fd                 	lds r29, triangle_fx_Gxx_post
                                 sound_driver_calculate_delays_triangle_Gxx_check_pre:
0020cd 17cb                      	cp r28, r27
0020ce f009                      	breq sound_driver_calculate_delays_triangle_Gxx_check_post
0020cf c012                      	rjmp sound_driver_calculate_delays_triangle_Gxx_pre
                                 sound_driver_calculate_delays_triangle_Gxx_check_post:
0020d0 17db                      	cp r29, r27
0020d1 f0f9                      	breq sound_driver_calculate_delays_triangle_store
0020d2 c01a                      	rjmp sound_driver_calculate_delays_triangle_Gxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_pre:
0020d3 93b0 290e                 	sts triangle_fx_Sxx_pre, r27
0020d5 1bec                      	sub r30, r28 //(song speed)-1-Sxx
0020d6 93e0 290f                 	sts triangle_fx_Sxx_post, r30
0020d8 95ca                      	dec r28
0020d9 93c0 28c7                 	sts triangle_pattern_delay_frames, r28
0020db 2fef                      	mov r30, r31
0020dc 50e1                      	subi r30, 1
0020dd c015                      	rjmp sound_driver_calculate_delays_noise
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_post:
0020de 93b0 290f                 	sts triangle_fx_Sxx_post, r27
0020e0 2fad                      	mov r26, r29
0020e1 c00f                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_Gxx_pre:
0020e2 93b0 28fc                 	sts triangle_fx_Gxx_pre, r27
0020e4 1bec                      	sub r30, r28 //(song speed)-1-Sxx
0020e5 93e0 28fd                 	sts triangle_fx_Gxx_post, r30
0020e7 95ca                      	dec r28
0020e8 93c0 28c7                 	sts triangle_pattern_delay_frames, r28
0020ea 2fef                      	mov r30, r31
0020eb 50e1                      	subi r30, 1
0020ec c006                      	rjmp sound_driver_calculate_delays_noise
                                 	
                                 sound_driver_calculate_delays_triangle_Gxx_post:
0020ed 93b0 28fd                 	sts triangle_fx_Gxx_post, r27
0020ef 2fad                      	mov r26, r29
0020f0 c000                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_store:
0020f1 93a0 28c7                 	sts triangle_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_noise:
0020f3 91a0 2913                 	lds r26, noise_pattern_delay_frames
0020f5 11a2                      	cpse r26, zero
0020f6 c042                      	rjmp sound_driver_calculate_delays_dpcm
0020f7 c000                      	rjmp sound_driver_calculate_delays_noise_main
                                 
                                 sound_driver_calculate_delays_noise_main:
0020f8 2faf                      	mov r26, r31 //move the speed to r26
0020f9 91b0 2912                 	lds r27, noise_pattern_delay_rows //decrement the delay rows
0020fb 15b2                      	cp r27, zero
0020fc f409                      	brne PC+2
0020fd c03b                      	rjmp sound_driver_calculate_delays_dpcm
0020fe 95ba                      	dec r27
0020ff 93b0 2912                 	sts noise_pattern_delay_rows, r27
002101 11b2                      	cpse r27, zero
002102 c034                      	rjmp sound_driver_calculate_delays_noise_store
002103 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_noise_Sxx:
002104 efbf                      	ldi r27, 0xFF
002105 91c0 295f                 	lds r28, noise_fx_Sxx_pre
002107 91d0 2960                 	lds r29, noise_fx_Sxx_post
                                 sound_driver_calculate_delays_noise_Sxx_check_pre:
002109 17cb                      	cp r28, r27
00210a f009                      	breq sound_driver_calculate_delays_noise_Sxx_check_post
00210b c00d                      	rjmp sound_driver_calculate_delays_noise_Sxx_pre
                                 sound_driver_calculate_delays_noise_Sxx_check_post:
00210c 17db                      	cp r29, r27
00210d f009                      	breq sound_driver_calculate_delays_noise_Gxx
00210e c015                      	rjmp sound_driver_calculate_delays_noise_Sxx_post
                                 
                                 sound_driver_calculate_delays_noise_Gxx:
00210f 91c0 294d                 	lds r28, noise_fx_Gxx_pre
002111 91d0 294e                 	lds r29, noise_fx_Gxx_post
                                 sound_driver_calculate_delays_noise_Gxx_check_pre:
002113 17cb                      	cp r28, r27
002114 f009                      	breq sound_driver_calculate_delays_noise_Gxx_check_post
002115 c012                      	rjmp sound_driver_calculate_delays_noise_Gxx_pre
                                 sound_driver_calculate_delays_noise_Gxx_check_post:
002116 17db                      	cp r29, r27
002117 f0f9                      	breq sound_driver_calculate_delays_noise_store
002118 c01a                      	rjmp sound_driver_calculate_delays_noise_Gxx_post
                                 
                                 sound_driver_calculate_delays_noise_Sxx_pre:
002119 93b0 295f                 	sts noise_fx_Sxx_pre, r27
00211b 1bec                      	sub r30, r28 //(song speed)-1-Sxx
00211c 93e0 2960                 	sts noise_fx_Sxx_post, r30
00211e 95ca                      	dec r28
00211f 93c0 2913                 	sts noise_pattern_delay_frames, r28
002121 2fef                      	mov r30, r31
002122 50e1                      	subi r30, 1
002123 c015                      	rjmp sound_driver_calculate_delays_dpcm
                                 
                                 sound_driver_calculate_delays_noise_Sxx_post:
002124 93b0 2960                 	sts noise_fx_Sxx_post, r27
002126 2fad                      	mov r26, r29
002127 c00f                      	rjmp sound_driver_calculate_delays_noise_store
                                 
                                 sound_driver_calculate_delays_noise_Gxx_pre:
002128 93b0 294d                 	sts noise_fx_Gxx_pre, r27
00212a 1bec                      	sub r30, r28 //(song speed)-1-Sxx
00212b 93e0 294e                 	sts noise_fx_Gxx_post, r30
00212d 95ca                      	dec r28
00212e 93c0 2913                 	sts noise_pattern_delay_frames, r28
002130 2fef                      	mov r30, r31
002131 50e1                      	subi r30, 1
002132 c006                      	rjmp sound_driver_calculate_delays_dpcm
                                 	
                                 sound_driver_calculate_delays_noise_Gxx_post:
002133 93b0 294e                 	sts noise_fx_Gxx_post, r27
002135 2fad                      	mov r26, r29
002136 c000                      	rjmp sound_driver_calculate_delays_noise_store
                                 
                                 sound_driver_calculate_delays_noise_store:
002137 93a0 2913                 	sts noise_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_dpcm:
                                 
                                 sound_driver_instrument_fx_routine:
                                 sound_driver_instrument_routine_channel0_volume:
002139 91e0 2828                 	lds ZL, pulse1_volume_macro
00213b 91f0 2829                 	lds ZH, pulse1_volume_macro+1
00213d 9630                      	adiw Z, 0
00213e f1a1                      	breq sound_driver_instrument_routine_channel0_volume_default //if no volume macro is in use, use default multiplier of F
00213f 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002140 1fff                      	rol ZH
002141 91a0 282a                 	lds r26, pulse1_volume_macro_offset
002143 0fea                      	add ZL, r26
002144 1df2                      	adc ZH, zero
                                 
002145 91b0 282c                 	lds r27, pulse1_volume_macro_release
002147 17ba                      	cp r27, r26
002148 f429                      	brne sound_driver_instrument_routine_channel0_volume_increment //if the current offset is not equal to the release index, increment the offset
002149 91a0 282b                 	lds r26, pulse1_volume_macro_loop
00214b 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00214c f010                      	brlo sound_driver_instrument_routine_channel0_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00214d c003                      	rjmp sound_driver_instrument_routine_channel0_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_volume_increment:
00214e 95a3                      	inc r26 //increment the macro offset
00214f 93a0 282a                 	sts pulse1_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_volume_read:
002151 91b4                      	lpm r27, Z //load volume data into r27
002152 3fbf                      	cpi r27, 0xFF //check for macro end flag
002153 f469                      	brne sound_driver_instrument_routine_channel0_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_release:
002154 91b0 282c                 	lds r27, pulse1_volume_macro_release
002156 3fbf                      	cpi r27, 0xFF
002157 f429                      	brne sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_loop:
002158 91b0 282b                 	lds r27, pulse1_volume_macro_loop //load the loop index
00215a 93b0 282a                 	sts pulse1_volume_macro_offset, r27 //store the loop index into the offset
00215c cfdc                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index:
00215d 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
00215e 93a0 282a                 	sts pulse1_volume_macro_offset, r26
002160 cfd8                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_calculate:
002161 e8e4                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
002162 e5fc                      	ldi ZH, HIGH(volumes << 1)
002163 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
002164 0feb                      	add ZL, r27 //add offset to the table
002165 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel0_volume_load:
002166 91b0 2800                 	lds r27, pulse1_param //load main volume
002168 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002169 91a0 285d                 	lds r26, pulse1_fx_7xy_value
00216b 30a0                      	cpi r26, 0x00
00216c f481                      	brne sound_driver_instrument_routine_channel0_volume_load_7xy
                                 
00216d 0feb                      	add ZL, r27 //offset the volume table by the main volume
00216e 1df2                      	adc ZH, zero
00216f 91b4                      	lpm r27, Z
002170 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
002172 c023                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default:
002173 91b0 2800                 	lds r27, pulse1_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
002175 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002176 91a0 285d                 	lds r26, pulse1_fx_7xy_value
002178 30a0                      	cpi r26, 0x00
002179 f499                      	brne sound_driver_instrument_routine_channel0_volume_default_7xy
00217a 93b0 2806                 	sts pulse1_output_volume, r27
00217c c019                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy:
00217d 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
00217e f038                      	brcs sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
00217f f031                      	breq sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
                                 
002180 0feb                      	add ZL, r27 //offset the volume table by the main volume
002181 1df2                      	adc ZH, zero
002182 91b4                      	lpm r27, Z
002183 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
002185 c010                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy_overflow:
002186 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002187 0feb                      	add ZL, r27 //offset the volume table by the main volume
002188 1df2                      	adc ZH, zero
002189 91b4                      	lpm r27, Z
00218a 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
00218c c009                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default_7xy:
00218d 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
00218e f020                      	brcs sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
00218f f019                      	breq sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
002190 93b0 2806                 	sts pulse1_output_volume, r27
002192 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel0_volume_default_7xy_overflow:
002193 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002194 93b0 2806                 	sts pulse1_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002196 91e0 282d                 	lds ZL, pulse1_arpeggio_macro
002198 91f0 282e                 	lds ZH, pulse1_arpeggio_macro+1
00219a 9630                      	adiw Z, 0
00219b f1d9                      	breq sound_driver_instrument_routine_channel0_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
00219c 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
00219d 1fff                      	rol ZH
00219e 91a0 282f                 	lds r26, pulse1_arpeggio_macro_offset
0021a0 0fea                      	add ZL, r26
0021a1 1df2                      	adc ZH, zero
                                 
0021a2 91b0 2831                 	lds r27, pulse1_arpeggio_macro_release
0021a4 17ba                      	cp r27, r26
0021a5 f429                      	brne sound_driver_instrument_routine_channel0_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
0021a6 91a0 2830                 	lds r26, pulse1_arpeggio_macro_loop
0021a8 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0021a9 f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
0021aa c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_increment:
0021ab 95a3                      	inc r26 //increment the macro offset
0021ac 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_read:
0021ae 91b4                      	lpm r27, Z //load arpeggio data into r27
0021af 38b0                      	cpi r27, 0x80 //check for macro end flag
0021b0 f009                      	breq sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag
0021b1 c041                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_check_mode:
0021b2 50a1                      	subi r26, 1 //keep the offset at the end flag
0021b3 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26
0021b5 91b0 2832                 	lds r27, pulse1_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
0021b7 30b1                      	cpi r27, 0x01
0021b8 f048                      	brlo sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_release:
0021b9 91b0 2831                 	lds r27, pulse1_arpeggio_macro_release
0021bb 3fbf                      	cpi r27, 0xFF
0021bc f4d1                      	brne sound_driver_instrument_routine_channel0_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_loop:
0021bd 91b0 2830                 	lds r27, pulse1_arpeggio_macro_loop
0021bf 3fbf                      	cpi r27, 0xFF
0021c0 f499                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
0021c1 c015                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute:
0021c2 91b0 2831                 	lds r27, pulse1_arpeggio_macro_release
0021c4 3fbf                      	cpi r27, 0xFF
0021c5 f421                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_check_loop:
0021c6 91b0 2830                 	lds r27, pulse1_arpeggio_macro_loop //load the loop index
0021c8 3fbf                      	cpi r27, 0xFF //check if loop flag exists
0021c9 f451                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop:
0021ca 91c0 2845                 	lds r28, pulse1_fx_0xy_sequence //check for 0xy effect
0021cc 91d0 2846                 	lds r29, pulse1_fx_0xy_sequence+1
0021ce 9620                      	adiw r29:r28, 0
0021cf f469                      	brne sound_driver_instrument_routine_channel0_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
0021d0 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
0021d1 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26 //store the last valid index into the offset
0021d3 cfc2                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload:
0021d4 93b0 282f                 	sts pulse1_arpeggio_macro_offset, r27 //store the loop index into the offset
0021d6 cfbf                      	rjmp sound_driver_instrument_routine_channel0_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_default:
0021d7 91c0 2845                 	lds r28, pulse1_fx_0xy_sequence //load 0xy effect
0021d9 91d0 2846                 	lds r29, pulse1_fx_0xy_sequence+1
0021db 9620                      	adiw r29:r28, 0 //check for 0xy effect
0021dc f099                      	breq sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel0_arpeggio_default_xy:
0021dd 95d6                      	lsr r29
0021de 95c7                      	ror r28
0021df 95d7                      	ror r29
0021e0 95c7                      	ror r28
0021e1 95d7                      	ror r29
0021e2 95c7                      	ror r28
0021e3 95d7                      	ror r29
0021e4 95c7                      	ror r28
0021e5 95d7                      	ror r29
0021e6 95d2                      	swap r29
                                 
0021e7 93c0 2845                 	sts pulse1_fx_0xy_sequence, r28 //store the rolled sequence
0021e9 93d0 2846                 	sts pulse1_fx_0xy_sequence+1, r29
0021eb 70cf                      	andi r28, 0x0F //mask out the 4 LSB
0021ec 91a0 2807                 	lds r26, pulse1_note //load the current note index
0021ee 0fac                      	add r26, r28 //add the note offset
0021ef c02e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
0021f0 91a0 2807                 	lds r26, pulse1_note //load the current note index
0021f2 c02b                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process:
0021f3 9220 2833                 	sts pulse1_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
0021f5 9220 2834                 	sts pulse1_total_pitch_offset+1, zero
0021f7 9220 283a                 	sts pulse1_total_hi_pitch_offset, zero
0021f9 91a0 2832                 	lds r26, pulse1_arpeggio_macro_mode
0021fb 30a1                      	cpi r26, 0x01 //absolute mode
0021fc f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_absolute
0021fd f069                      	breq sound_driver_instrument_routine_channel0_arpeggio_process_fixed
0021fe c00e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute:
0021ff 91a0 2807                 	lds r26, pulse1_note //load the current note index
002201 0fab                      	add r26, r27 //offset the note with the arpeggio data
002202 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002203 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_add:
002204 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002205 f0c0                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
002206 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002207 c016                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract:
002208 fda7                      	sbrc r26, 7 //check if result is negative
002209 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
00220a c013                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_fixed:
00220b 2fab                      	mov r26, r27 //move the arpeggio data into r26
00220c c011                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative:
00220d 91a0 2807                 	lds r26, pulse1_note //load the current note index
00220f 0fab                      	add r26, r27 //offset the note with the arpeggio data
002210 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002211 c008                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_add:
002212 93a0 2807                 	sts pulse1_note, r26 //NOTE: relative mode modifies the original note index
002214 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002215 f040                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
002216 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002217 93a0 2807                 	sts pulse1_note, r26
002219 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract:
00221a fda7                      	sbrc r26, 7 //check if result is negative
00221b e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
00221c 93a0 2807                 	sts pulse1_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_load:
00221e e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
00221f e0f0                      	ldi ZH, HIGH(note_table << 1)
002220 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002221 0fea                      	add ZL, r26 //add offset
002222 1df2                      	adc ZH, zero
002223 91a5                      	lpm r26, Z+ //load bytes
002224 91b4                      	lpm r27, Z
002225 93a0 0a8c                 	sts TCB0_CCMPL, r26 //load the LOW bits for timer
002227 93b0 0a8d                 	sts TCB0_CCMPH, r27 //load the HIGH bits for timer
002229 93a0 2851                 	sts pulse1_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
00222b 93b0 2852                 	sts pulse1_fx_3xx_target+1, r27
00222d c000                      	rjmp sound_driver_instrument_routine_channel0_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch:
00222e 91e0 2835                 	lds ZL, pulse1_pitch_macro
002230 91f0 2836                 	lds ZH, pulse1_pitch_macro+1
002232 9630                      	adiw Z, 0
002233 f409                      	brne sound_driver_instrument_routine_channel0_pitch_continue
002234 c023                      	rjmp sound_driver_instrument_routine_channel0_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel0_pitch_continue:
002235 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002236 1fff                      	rol ZH
002237 91a0 2837                 	lds r26, pulse1_pitch_macro_offset
002239 0fea                      	add ZL, r26
00223a 1df2                      	adc ZH, zero
                                 
00223b 91b0 2839                 	lds r27, pulse1_pitch_macro_release
00223d 17ba                      	cp r27, r26
00223e f429                      	brne sound_driver_instrument_routine_channel0_pitch_increment //if the current offset is not equal to the release index, increment the offset
00223f 91a0 2838                 	lds r26, pulse1_pitch_macro_loop
002241 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002242 f010                      	brlo sound_driver_instrument_routine_channel0_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002243 c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_pitch_increment:
002244 95a3                      	inc r26 //increment the macro offset
002245 93a0 2837                 	sts pulse1_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_pitch_read:
002247 91b4                      	lpm r27, Z //load pitch data into r27
002248 38b0                      	cpi r27, 0x80 //check for macro end flag
002249 f479                      	brne sound_driver_instrument_routine_channel0_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_release:
00224a 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00224b 93a0 2837                 	sts pulse1_pitch_macro_offset, r26
00224d 91b0 2839                 	lds r27, pulse1_pitch_macro_release
00224f 3fbf                      	cpi r27, 0xFF
002250 f439                      	brne sound_driver_instrument_routine_channel0_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_loop:
002251 91b0 2838                 	lds r27, pulse1_pitch_macro_loop //load the loop index
002253 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002254 f019                      	breq sound_driver_instrument_routine_channel0_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002255 93b0 2837                 	sts pulse1_pitch_macro_offset, r27 //store the loop index into the offset
002257 cfd6                      	rjmp sound_driver_instrument_routine_channel0_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_default:
002258 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel0_pitch_calculate:
002259 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00225a 937f                      	push r23
00225b 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
00225c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00225d 0367                      	mulsu r22, r23
00225e 917f                      	pop r23
00225f 916f                      	pop r22
                                 
002260 9416                      	lsr r1 //shift out the fractional bits
002261 9407                      	ror r0
002262 9416                      	lsr r1
002263 9407                      	ror r0
002264 9416                      	lsr r1
002265 9407                      	ror r0
002266 9416                      	lsr r1
002267 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_check_negative:
002268 fe13                      	sbrs r1, 3 //check if result was a negative number
002269 c007                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_negative:
00226a efc0                      	ldi r28, 0xF0
00226b 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_check_divisible_8:
00226c 70b7                      	andi r27, 0b00000111
00226d f019                      	breq sound_driver_instrument_routine_channel0_pitch_calculate_offset
                                 
00226e e0b1                      	ldi r27, 0x01
00226f 0e0b                      	add r0, r27
002270 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_offset:
002271 91a0 2833                 	lds r26, pulse1_total_pitch_offset
002273 91b0 2834                 	lds r27, pulse1_total_pitch_offset+1
002275 0e0a                      	add r0, r26
002276 1e1b                      	adc r1, r27
002277 9200 2833                 	sts pulse1_total_pitch_offset, r0
002279 9210 2834                 	sts pulse1_total_pitch_offset+1, r1
00227b 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
00227d 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
00227f 0da0                      	add r26, r0 //offset the timer values
002280 1db1                      	adc r27, r1
                                 	
002281 91c0 2849                 	lds r28, pulse1_fx_1xx_total
002283 91d0 284a                 	lds r29, pulse1_fx_1xx_total+1
002285 1bac                      	sub r26, r28
002286 0bbd                      	sbc r27, r29
002287 91c0 284d                 	lds r28, pulse1_fx_2xx_total
002289 91d0 284e                 	lds r29, pulse1_fx_2xx_total+1
00228b 0fac                      	add r26, r28
00228c 1fbd                      	adc r27, r29
00228d 91c0 2861                 	lds r28, pulse1_fx_Pxx_total
00228f 91d0 2862                 	lds r29, pulse1_fx_Pxx_total+1
002291 0fac                      	add r26, r28
002292 1fbd                      	adc r27, r29
002293 91c0 2868                 	lds r28, pulse1_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
002295 91d0 2869                 	lds r29, pulse1_fx_Qxy_total_offset+1
002297 1bac                      	sub r26, r28
002298 0bbd                      	sbc r27, r29
002299 91c0 286f                 	lds r28, pulse1_fx_Rxy_total_offset
00229b 91d0 2870                 	lds r29, pulse1_fx_Rxy_total_offset+1
00229d 0fac                      	add r26, r28
00229e 1fbd                      	adc r27, r29
                                 
00229f 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
0022a1 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel0_hi_pitch:
0022a3 91e0 283b                 	lds ZL, pulse1_hi_pitch_macro
0022a5 91f0 283c                 	lds ZH, pulse1_hi_pitch_macro+1
0022a7 9630                      	adiw Z, 0
0022a8 f409                      	brne sound_driver_instrument_routine_channel0_hi_pitch_continue
0022a9 c03c                      	rjmp sound_driver_instrument_routine_channel0_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel0_hi_pitch_continue:
0022aa 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0022ab 1fff                      	rol ZH
0022ac 91a0 283d                 	lds r26, pulse1_hi_pitch_macro_offset
0022ae 0fea                      	add ZL, r26
0022af 1df2                      	adc ZH, zero
                                 
0022b0 91b0 283f                 	lds r27, pulse1_hi_pitch_macro_release
0022b2 17ba                      	cp r27, r26
0022b3 f429                      	brne sound_driver_instrument_routine_channel0_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
0022b4 91a0 283e                 	lds r26, pulse1_hi_pitch_macro_loop
0022b6 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0022b7 f010                      	brlo sound_driver_instrument_routine_channel0_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0022b8 c003                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_increment:
0022b9 95a3                      	inc r26 //increment the macro offset
0022ba 93a0 283d                 	sts pulse1_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_hi_pitch_read:
0022bc 91b4                      	lpm r27, Z //load hi pitch data into r27
0022bd 38b0                      	cpi r27, 0x80 //check for macro end flag
0022be f489                      	brne sound_driver_instrument_routine_channel0_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_release:
0022bf 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0022c0 93a0 283d                 	sts pulse1_hi_pitch_macro_offset, r26
0022c2 91b0 283f                 	lds r27, pulse1_hi_pitch_macro_release
0022c4 3fbf                      	cpi r27, 0xFF
0022c5 f439                      	brne sound_driver_instrument_routine_channel0_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_loop:
0022c6 91b0 283e                 	lds r27, pulse1_hi_pitch_macro_loop //load the loop index
0022c8 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0022c9 f019                      	breq sound_driver_instrument_routine_channel0_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
0022ca 93b0 283d                 	sts pulse1_hi_pitch_macro_offset, r27 //store the loop index into the offset
0022cc cfd6                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_default:
0022cd 91b0 283a                 	lds r27, pulse1_total_hi_pitch_offset
0022cf c005                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate:
0022d0 91a0 283a                 	lds r26, pulse1_total_hi_pitch_offset //load the total hi pitch offset to change
0022d2 0fba                      	add r27, r26
0022d3 93b0 283a                 	sts pulse1_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply:
0022d5 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0022d6 937f                      	push r23
0022d7 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
0022d8 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0022d9 0367                      	mulsu r22, r23
0022da 917f                      	pop r23
0022db 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_offset:
0022dc 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
0022de 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
0022e0 0da0                      	add r26, r0 //offset the timer values
0022e1 1db1                      	adc r27, r1
0022e2 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
0022e4 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel0_duty:
0022e6 91e0 2840                 	lds ZL, pulse1_duty_macro
0022e8 91f0 2841                 	lds ZH, pulse1_duty_macro+1
0022ea 9630                      	adiw Z, 0
0022eb f1b1                      	breq sound_driver_channel0_fx_routines //if no duty macro is in use, go to the next routine
0022ec 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0022ed 1fff                      	rol ZH
0022ee 91a0 2842                 	lds r26, pulse1_duty_macro_offset
0022f0 0fea                      	add ZL, r26
0022f1 1df2                      	adc ZH, zero
                                 
0022f2 91b0 2844                 	lds r27, pulse1_duty_macro_release
0022f4 17ba                      	cp r27, r26
0022f5 f429                      	brne sound_driver_instrument_routine_channel0_duty_increment //if the current offset is not equal to the release index, increment the offset
0022f6 91a0 2843                 	lds r26, pulse1_duty_macro_loop
0022f8 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0022f9 f010                      	brlo sound_driver_instrument_routine_channel0_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0022fa c027                      	rjmp sound_driver_channel0_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel0_duty_increment:
0022fb 95a3                      	inc r26 //increment the macro offset
0022fc 93a0 2842                 	sts pulse1_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_duty_read:
0022fe 91b4                      	lpm r27, Z //load pitch data into r27
0022ff 3fbf                      	cpi r27, 0xFF //check for macro end flag
002300 f471                      	brne sound_driver_instrument_routine_channel0_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_release:
002301 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002302 93a0 2842                 	sts pulse1_duty_macro_offset, r26
002304 91b0 2844                 	lds r27, pulse1_duty_macro_release
002306 3fbf                      	cpi r27, 0xFF
002307 f4d1                      	brne sound_driver_channel0_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_loop:
002308 91b0 2843                 	lds r27, pulse1_duty_macro_loop //load the loop index
00230a 3fbf                      	cpi r27, 0xFF //check if there is a loop index
00230b f0b1                      	breq sound_driver_channel0_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
00230c 93b0 2842                 	sts pulse1_duty_macro_offset, r27 //store the loop index into the offset
00230e cfd7                      	rjmp sound_driver_instrument_routine_channel0_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_load:
00230f ebe0                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
002310 e5fb                      	ldi ZH, HIGH(sequences << 1)
002311 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
002312 1df2                      	adc ZH, zero
                                 
002313 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
002314 95b7                      	ror r27
002315 95b7                      	ror r27
002316 91a0 2800                 	lds r26, pulse1_param //load r26 with pulse1_param (register $4000)
002318 2fca                      	mov r28, r26 //store a copy of pulse1_param into r28
002319 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
00231a 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
00231b c001                      	rjmp sound_driver_instrument_routine_channel0_duty_load_store
00231c c005                      	rjmp sound_driver_channel0_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel0_duty_load_store:
00231d 90a4                      	lpm pulse1_sequence, Z //store the sequence
                                 
00231e 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
00231f 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
002320 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_routines:
                                 sound_driver_channel0_fx_1xx_routine:
002322 91e0 2847                 	lds ZL, pulse1_fx_1xx
002324 91f0 2848                 	lds ZH, pulse1_fx_1xx+1
002326 9630                      	adiw Z, 0
002327 f051                      	breq sound_driver_channel0_fx_2xx_routine
                                 
002328 91a0 2849                 	lds r26, pulse1_fx_1xx_total //load the rate to change the pitch by
00232a 91b0 284a                 	lds r27, pulse1_fx_1xx_total+1
00232c 0fae                      	add r26, ZL //increase the total offset by the rate
00232d 1fbf                      	adc r27, ZH
00232e 93a0 2849                 	sts pulse1_fx_1xx_total, r26
002330 93b0 284a                 	sts pulse1_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_2xx_routine:
002332 91e0 284b                 	lds ZL, pulse1_fx_2xx
002334 91f0 284c                 	lds ZH, pulse1_fx_2xx+1
002336 9630                      	adiw Z, 0
002337 f051                      	breq sound_driver_channel0_fx_3xx_routine
                                 
002338 91a0 284d                 	lds r26, pulse1_fx_2xx_total //load the rate to change the pitch by
00233a 91b0 284e                 	lds r27, pulse1_fx_2xx_total+1
00233c 0fae                      	add r26, ZL //increase the total offset by the rate
00233d 1fbf                      	adc r27, ZH
00233e 93a0 284d                 	sts pulse1_fx_2xx_total, r26
002340 93b0 284e                 	sts pulse1_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_3xx_routine:
002342 91e0 2853                 	lds ZL, pulse1_fx_3xx_speed
002344 91f0 2854                 	lds ZH, pulse1_fx_3xx_speed+1
002346 9630                      	adiw Z, 0
002347 f409                      	brne sound_driver_channel0_fx_3xx_routine_check_start
002348 c048                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_check_start:
002349 91a0 284f                 	lds r26, pulse1_fx_3xx_start
00234b 91b0 2850                 	lds r27, pulse1_fx_3xx_start+1
00234d 9610                      	adiw r26:r27, 0
00234e f409                      	brne sound_driver_channel0_fx_3xx_routine_main
00234f c041                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_main:
002350 91c0 2851                 	lds r28, pulse1_fx_3xx_target
002352 91d0 2852                 	lds r29, pulse1_fx_3xx_target+1
                                 
002354 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
002355 07bd                      	cpc r27, r29
002356 f011                      	breq sound_driver_channel0_fx_3xx_routine_disable
002357 f030                      	brlo sound_driver_channel0_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002358 c01f                      	rjmp sound_driver_channel0_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel0_fx_3xx_routine_disable:
002359 9220 284f                 	sts pulse1_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
00235b 9220 2850                 	sts pulse1_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
00235d c033                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_subtract:
00235e 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
00235f 0bdb                      	sbc r29, r27
002360 91a0 2855                 	lds r26, pulse1_fx_3xx_total_offset
002362 91b0 2856                 	lds r27, pulse1_fx_3xx_total_offset+1
                                 
002364 0fae                      	add r26, ZL //add the speed to the total offset
002365 1fbf                      	adc r27, ZH
002366 1bca                      	sub r28, r26 //invert the total difference with the total offset
002367 0bdb                      	sbc r29, r27
002368 f380                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002369 93a0 2855                 	sts pulse1_fx_3xx_total_offset, r26 //store the new total offset
00236b 93b0 2856                 	sts pulse1_fx_3xx_total_offset+1, r27
                                 
00236d 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the current timer period
00236f 91b0 0a8d                 	lds r27, TCB0_CCMPH
002371 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002372 0bbd                      	sbc r27, r29
002373 93a0 0a8c                 	sts TCB0_CCMPL, r26
002375 93b0 0a8d                 	sts TCB0_CCMPH, r27
002377 c019                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_add:
002378 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002379 0bbd                      	sbc r27, r29
00237a 91c0 2855                 	lds r28, pulse1_fx_3xx_total_offset
00237c 91d0 2856                 	lds r29, pulse1_fx_3xx_total_offset+1
                                 
00237e 0fce                      	add r28, ZL //add the speed to the total offset
00237f 1fdf                      	adc r29, ZH
002380 1bac                      	sub r26, r28 //invert the total difference with the total offset
002381 0bbd                      	sbc r27, r29
002382 f2b0                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002383 93c0 2855                 	sts pulse1_fx_3xx_total_offset, r28 //store the new total offset
002385 93d0 2856                 	sts pulse1_fx_3xx_total_offset+1, r29
                                 
002387 91c0 0a8c                 	lds r28, TCB0_CCMPL //load the current timer period
002389 91d0 0a8d                 	lds r29, TCB0_CCMPH
00238b 0fca                      	add r28, r26 //offset the current timer period with the total offset
00238c 1fdb                      	adc r29, r27
00238d 93c0 0a8c                 	sts TCB0_CCMPL, r28
00238f 93d0 0a8d                 	sts TCB0_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel0_fx_4xy_routine:
002391 91a0 2857                 	lds r26, pulse1_fx_4xy_speed
002393 15a2                      	cp r26, zero
002394 f409                      	brne sound_driver_channel0_fx_4xy_routine_continue
002395 c05c                      	rjmp sound_driver_channel0_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel0_fx_4xy_routine_continue:
002396 91b0 2858                 	lds r27, pulse1_fx_4xy_depth
002398 91c0 2859                 	lds r28, pulse1_fx_4xy_phase
00239a 0fca                      	add r28, r26 //increase the phase by the speed
00239b 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
00239c f008                      	brlo sound_driver_channel0_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
00239d e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase:
00239e 93c0 2859                 	sts pulse1_fx_4xy_phase, r28 //store the new phase
0023a0 31c0                      	cpi r28, 16
0023a1 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_0
0023a2 32c0                      	cpi r28, 32
0023a3 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_1
0023a4 33c0                      	cpi r28, 48
0023a5 f030                      	brlo sound_driver_channel0_fx_4xy_routine_phase_2
0023a6 c007                      	rjmp sound_driver_channel0_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_0:
0023a7 70cf                      	andi r28, 0x0F //mask for values 0-15
0023a8 c029                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_1:
0023a9 6fc0                      	ori r28, 0xF0
0023aa 95c0                      	com r28 //invert values 0-15
0023ab c026                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_2:
0023ac 70cf                      	andi r28, 0x0F //mask for values 0-15
0023ad c003                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_3:
0023ae 6fc0                      	ori r28, 0xF0
0023af 95c0                      	com r28 //invert values 0-15
0023b0 c000                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_add:
0023b1 95b2                      	swap r27 //multiply depth by 16
0023b2 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0023b3 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0023b4 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0023b5 0fec                      	add ZL, r28 //offset the table by the depth+phase
0023b6 1df2                      	adc ZH, zero
0023b7 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
0023b8 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0023b9 937f                      	push r23
0023ba 2f6c                      	mov r22, r28 //store the vibrato value into r22
0023bb eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0023bc 9f67                      	mul r22, r23
0023bd 917f                      	pop r23
0023be 916f                      	pop r22
                                 
0023bf 9416                      	lsr r1 //shift out the fractional bits
0023c0 9407                      	ror r0
0023c1 9416                      	lsr r1
0023c2 9407                      	ror r0
0023c3 9416                      	lsr r1
0023c4 9407                      	ror r0
0023c5 9416                      	lsr r1
0023c6 9407                      	ror r0
                                 	
0023c7 91a0 0a8c                 	lds r26, TCB0_CCMPL
0023c9 91b0 0a8d                 	lds r27, TCB0_CCMPH
0023cb 0da0                      	add r26, r0
0023cc 1db1                      	adc r27, r1
0023cd 93a0 0a8c                 	sts TCB0_CCMPL, r26
0023cf 93b0 0a8d                 	sts TCB0_CCMPH, r27
0023d1 c020                      	rjmp sound_driver_channel0_fx_7xy_routine
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_subtract:
0023d2 95b2                      	swap r27 //multiply depth by 16
0023d3 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
0023d4 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0023d5 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0023d6 0fec                      	add ZL, r28 //offset the table by the depth+phase
0023d7 1df2                      	adc ZH, zero
0023d8 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
0023d9 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0023da 937f                      	push r23
0023db 2f6c                      	mov r22, r28 //store the vibrato value into r22
0023dc eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0023dd 9f67                      	mul r22, r23
0023de 917f                      	pop r23
0023df 916f                      	pop r22
                                 
0023e0 9416                      	lsr r1 //shift out the fractional bits
0023e1 9407                      	ror r0
0023e2 9416                      	lsr r1
0023e3 9407                      	ror r0
0023e4 9416                      	lsr r1
0023e5 9407                      	ror r0
0023e6 9416                      	lsr r1
0023e7 9407                      	ror r0
                                 
0023e8 91a0 0a8c                 	lds r26, TCB0_CCMPL
0023ea 91b0 0a8d                 	lds r27, TCB0_CCMPH
0023ec 19a0                      	sub r26, r0
0023ed 09b1                      	sbc r27, r1
0023ee 93a0 0a8c                 	sts TCB0_CCMPL, r26
0023f0 93b0 0a8d                 	sts TCB0_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_7xy_routine:
0023f2 91a0 285a                 	lds r26, pulse1_fx_7xy_speed
0023f4 15a2                      	cp r26, zero
0023f5 f0e9                      	breq sound_driver_channel0_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
0023f6 91b0 285b                 	lds r27, pulse1_fx_7xy_depth
0023f8 91c0 285c                 	lds r28, pulse1_fx_7xy_phase
0023fa 0fca                      	add r28, r26 //increase the phase by the speed
0023fb 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
0023fc f008                      	brlo sound_driver_channel0_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
0023fd e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase:
0023fe 93c0 285c                 	sts pulse1_fx_7xy_phase, r28 //store the new phase
002400 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
002401 ffc4                      	sbrs r28, 4
002402 c001                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_0
002403 c002                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel0_fx_7xy_routine_phase_0:
002404 70cf                      	andi r28, 0x0F //mask for values 0-15
002405 c003                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase_1:
002406 6fc0                      	ori r28, 0xF0
002407 95c0                      	com r28 //invert values 0-15
002408 c000                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_load:
002409 95b2                      	swap r27 //multiply depth by 16
00240a 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
00240b e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00240c e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00240d 0fec                      	add ZL, r28 //offset the table by the depth+phase
00240e 1df2                      	adc ZH, zero
00240f 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002410 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
002411 93c0 285d                 	sts pulse1_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Axy_routine:
002413 91b0 285e                 	lds r27, pulse1_fx_Axy
002415 15b2                      	cp r27, zero
002416 f0e9                      	breq sound_driver_channel0_fx_Qxy_routine //0 means that the effect is not in use
                                 	
002417 91a0 2805                 	lds r26, pulse1_fractional_volume //load fractional volume representation of the channel
002419 91c0 2800                 	lds r28, pulse1_param //load the integer volume representation of the channel
00241b 2fda                      	mov r29, r26 //copy fractional volume into r29
00241c 2fec                      	mov r30, r28 //copy the pulse1_param into r30
00241d 95e2                      	swap r30
00241e 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
00241f 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
002420 17ed                      	cp r30, r29 //compare the fractional and integer volumes
002421 f009                      	breq sound_driver_channel0_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel0_fx_Axy_routine_reload:
002422 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate:
002423 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
002424 c004                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_addition:
002425 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002426 f428                      	brcc sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002427 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
002428 c003                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_subtraction:
002429 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
00242a f008                      	brcs sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
00242b e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_store:
00242c 93a0 2805                 	sts pulse1_fractional_volume, r26 //store the new fractional volume
00242e 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
00242f 95a2                      	swap r26
002430 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
002431 2bca                      	or r28, r26 //store the new volume back into pulse1_param
002432 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel0_fx_Qxy_routine:
002434 91e0 2864                 	lds ZL, pulse1_fx_Qxy_target
002436 91f0 2865                 	lds ZH, pulse1_fx_Qxy_target+1
002438 9630                      	adiw Z, 0
002439 f119                      	breq sound_driver_channel0_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
00243a 91a0 2868                 	lds r26, pulse1_fx_Qxy_total_offset
00243c 91b0 2869                 	lds r27, pulse1_fx_Qxy_total_offset+1
00243e 91c0 0a8c                 	lds r28, TCB0_CCMPL
002440 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
002442 1bec                      	sub ZL, r28 //calculate the difference to the target
002443 0bfd                      	sbc ZH, r29
002444 f408                      	brsh sound_driver_channel0_fx_Qxy_routine_end //if the target has been reached (or passed)
002445 f068                      	brlo sound_driver_channel0_fx_Qxy_routine_add
                                 
                                 sound_driver_channel0_fx_Qxy_routine_end:
002446 9220 2868                 	sts pulse1_fx_Qxy_total_offset, zero //turn off the effect
002448 9220 2869                 	sts pulse1_fx_Qxy_total_offset+1, zero
00244a 9220 2864                 	sts pulse1_fx_Qxy_target, zero
00244c 9220 2865                 	sts pulse1_fx_Qxy_target+1, zero
00244e 91b0 2863                 	lds r27, pulse1_fx_Qxy_target_note
002450 93b0 2807                 	sts pulse1_note, r27 //replace the note with the final target note
002452 c00a                      	rjmp sound_driver_channel0_fx_Rxy_routine
                                 
                                 sound_driver_channel0_fx_Qxy_routine_add:
002453 91c0 2866                 	lds r28, pulse1_fx_Qxy_speed
002455 91d0 2867                 	lds r29, pulse1_fx_Qxy_speed+1
002457 0fac                      	add r26, r28 //increase the total offset by the speed
002458 1fbd                      	adc r27, r29
002459 93a0 2868                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
00245b 93b0 2869                 	sts pulse1_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Rxy_routine:
00245d 91e0 286b                 	lds ZL, pulse1_fx_Rxy_target
00245f 91f0 286c                 	lds ZH, pulse1_fx_Rxy_target+1
002461 9630                      	adiw Z, 0
002462 f119                      	breq sound_driver_instrument_routine_channel1_volume //if the effect is not enabled, skip the routine
                                 
002463 91a0 286f                 	lds r26, pulse1_fx_Rxy_total_offset
002465 91b0 2870                 	lds r27, pulse1_fx_Rxy_total_offset+1
002467 91c0 0a8c                 	lds r28, TCB0_CCMPL
002469 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
00246b 1bce                      	sub r28, ZL //calculate the difference to the target
00246c 0bdf                      	sbc r29, ZH
00246d f408                      	brsh sound_driver_channel0_fx_Rxy_routine_end //if the target has been reached (or passed)
00246e f068                      	brlo sound_driver_channel0_fx_Rxy_routine_add
                                 
                                 sound_driver_channel0_fx_Rxy_routine_end:
00246f 9220 286f                 	sts pulse1_fx_Rxy_total_offset, zero //disable the effect
002471 9220 2870                 	sts pulse1_fx_Rxy_total_offset+1, zero
002473 9220 286b                 	sts pulse1_fx_Rxy_target, zero
002475 9220 286c                 	sts pulse1_fx_Rxy_target+1, zero
002477 91b0 286a                 	lds r27, pulse1_fx_Rxy_target_note
002479 93b0 2807                 	sts pulse1_note, r27 //replace the note with the final target note
00247b c00a                      	rjmp sound_driver_instrument_routine_channel1_volume
                                 
                                 sound_driver_channel0_fx_Rxy_routine_add:
00247c 91c0 286d                 	lds r28, pulse1_fx_Rxy_speed
00247e 91d0 286e                 	lds r29, pulse1_fx_Rxy_speed+1
002480 0fac                      	add r26, r28 //increase the total offset by the speed
002481 1fbd                      	adc r27, r29
002482 93a0 286f                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
002484 93b0 2870                 	sts pulse1_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume:
002486 91e0 2879                 	lds ZL, pulse2_volume_macro
002488 91f0 287a                 	lds ZH, pulse2_volume_macro+1
00248a 9630                      	adiw Z, 0
00248b f1a1                      	breq sound_driver_instrument_routine_channel1_volume_default //if no volume macro is in use, use default multiplier of F
00248c 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
00248d 1fff                      	rol ZH
00248e 91a0 287b                 	lds r26, pulse2_volume_macro_offset
002490 0fea                      	add ZL, r26
002491 1df2                      	adc ZH, zero
                                 
002492 91b0 287d                 	lds r27, pulse2_volume_macro_release
002494 17ba                      	cp r27, r26
002495 f429                      	brne sound_driver_instrument_routine_channel1_volume_increment //if the current offset is not equal to the release index, increment the offset
002496 91a0 287c                 	lds r26, pulse2_volume_macro_loop
002498 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002499 f010                      	brlo sound_driver_instrument_routine_channel1_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00249a c003                      	rjmp sound_driver_instrument_routine_channel1_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_volume_increment:
00249b 95a3                      	inc r26 //increment the macro offset
00249c 93a0 287b                 	sts pulse2_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_volume_read:
00249e 91b4                      	lpm r27, Z //load volume data into r27
00249f 3fbf                      	cpi r27, 0xFF //check for macro end flag
0024a0 f469                      	brne sound_driver_instrument_routine_channel1_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_release:
0024a1 91b0 287d                 	lds r27, pulse2_volume_macro_release
0024a3 3fbf                      	cpi r27, 0xFF
0024a4 f429                      	brne sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_loop:
0024a5 91b0 287c                 	lds r27, pulse2_volume_macro_loop //load the loop index
0024a7 93b0 287b                 	sts pulse2_volume_macro_offset, r27 //store the loop index into the offset
0024a9 cfdc                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index:
0024aa 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
0024ab 93a0 287b                 	sts pulse2_volume_macro_offset, r26
0024ad cfd8                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_calculate:
0024ae e8e4                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
0024af e5fc                      	ldi ZH, HIGH(volumes << 1)
0024b0 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
0024b1 0feb                      	add ZL, r27 //add offset to the table
0024b2 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel1_volume_load:
0024b3 91b0 2808                 	lds r27, pulse2_param //load main volume
0024b5 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
0024b6 91a0 28ae                 	lds r26, pulse2_fx_7xy_value
0024b8 30a0                      	cpi r26, 0x00
0024b9 f481                      	brne sound_driver_instrument_routine_channel1_volume_load_7xy
                                 
0024ba 0feb                      	add ZL, r27 //offset the volume table by the main volume
0024bb 1df2                      	adc ZH, zero
0024bc 91b4                      	lpm r27, Z
0024bd 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
0024bf c023                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default:
0024c0 91b0 2808                 	lds r27, pulse2_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
0024c2 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
0024c3 91a0 28ae                 	lds r26, pulse2_fx_7xy_value
0024c5 30a0                      	cpi r26, 0x00
0024c6 f499                      	brne sound_driver_instrument_routine_channel1_volume_default_7xy
0024c7 93b0 280e                 	sts pulse2_output_volume, r27
0024c9 c019                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy:
0024ca 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
0024cb f038                      	brcs sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
0024cc f031                      	breq sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
                                 
0024cd 0feb                      	add ZL, r27 //offset the volume table by the main volume
0024ce 1df2                      	adc ZH, zero
0024cf 91b4                      	lpm r27, Z
0024d0 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
0024d2 c010                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy_overflow:
0024d3 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
0024d4 0feb                      	add ZL, r27 //offset the volume table by the main volume
0024d5 1df2                      	adc ZH, zero
0024d6 91b4                      	lpm r27, Z
0024d7 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
0024d9 c009                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default_7xy:
0024da 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
0024db f020                      	brcs sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
0024dc f019                      	breq sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
0024dd 93b0 280e                 	sts pulse2_output_volume, r27
0024df c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel1_volume_default_7xy_overflow:
0024e0 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
0024e1 93b0 280e                 	sts pulse2_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
0024e3 91e0 287e                 	lds ZL, pulse2_arpeggio_macro
0024e5 91f0 287f                 	lds ZH, pulse2_arpeggio_macro+1
0024e7 9630                      	adiw Z, 0
0024e8 f1d9                      	breq sound_driver_instrument_routine_channel1_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
0024e9 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0024ea 1fff                      	rol ZH
0024eb 91a0 2880                 	lds r26, pulse2_arpeggio_macro_offset
0024ed 0fea                      	add ZL, r26
0024ee 1df2                      	adc ZH, zero
                                 
0024ef 91b0 2882                 	lds r27, pulse2_arpeggio_macro_release
0024f1 17ba                      	cp r27, r26
0024f2 f429                      	brne sound_driver_instrument_routine_channel1_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
0024f3 91a0 2881                 	lds r26, pulse2_arpeggio_macro_loop
0024f5 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0024f6 f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
0024f7 c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_increment:
0024f8 95a3                      	inc r26 //increment the macro offset
0024f9 93a0 2880                 	sts pulse2_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_read:
0024fb 91b4                      	lpm r27, Z //load arpeggio data into r27
0024fc 38b0                      	cpi r27, 0x80 //check for macro end flag
0024fd f009                      	breq sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag
0024fe c041                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_check_mode:
0024ff 50a1                      	subi r26, 1 //keep the offset at the end flag
002500 93a0 2880                 	sts pulse2_arpeggio_macro_offset, r26
002502 91b0 2883                 	lds r27, pulse2_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002504 30b1                      	cpi r27, 0x01
002505 f048                      	brlo sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_release:
002506 91b0 2882                 	lds r27, pulse2_arpeggio_macro_release
002508 3fbf                      	cpi r27, 0xFF
002509 f4d1                      	brne sound_driver_instrument_routine_channel1_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_loop:
00250a 91b0 2881                 	lds r27, pulse2_arpeggio_macro_loop
00250c 3fbf                      	cpi r27, 0xFF
00250d f499                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
00250e c015                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute:
00250f 91b0 2882                 	lds r27, pulse2_arpeggio_macro_release
002511 3fbf                      	cpi r27, 0xFF
002512 f421                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_check_loop:
002513 91b0 2881                 	lds r27, pulse2_arpeggio_macro_loop //load the loop index
002515 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002516 f451                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop:
002517 91c0 2896                 	lds r28, pulse2_fx_0xy_sequence //check for 0xy effect
002519 91d0 2897                 	lds r29, pulse2_fx_0xy_sequence+1
00251b 9620                      	adiw r29:r28, 0
00251c f469                      	brne sound_driver_instrument_routine_channel1_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
00251d 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
00251e 93a0 2880                 	sts pulse2_arpeggio_macro_offset, r26 //store the last valid index into the offset
002520 cfc2                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload:
002521 93b0 2880                 	sts pulse2_arpeggio_macro_offset, r27 //store the loop index into the offset
002523 cfbf                      	rjmp sound_driver_instrument_routine_channel1_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_default:
002524 91c0 2896                 	lds r28, pulse2_fx_0xy_sequence //load 0xy effect
002526 91d0 2897                 	lds r29, pulse2_fx_0xy_sequence+1
002528 9620                      	adiw r29:r28, 0 //check for 0xy effect
002529 f099                      	breq sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel1_arpeggio_default_xy:
00252a 95d6                      	lsr r29
00252b 95c7                      	ror r28
00252c 95d7                      	ror r29
00252d 95c7                      	ror r28
00252e 95d7                      	ror r29
00252f 95c7                      	ror r28
002530 95d7                      	ror r29
002531 95c7                      	ror r28
002532 95d7                      	ror r29
002533 95d2                      	swap r29
                                 
002534 93c0 2896                 	sts pulse2_fx_0xy_sequence, r28 //store the rolled sequence
002536 93d0 2897                 	sts pulse2_fx_0xy_sequence+1, r29
002538 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002539 91a0 280f                 	lds r26, pulse2_note //load the current note index
00253b 0fac                      	add r26, r28 //add the note offset
00253c c02e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
00253d 91a0 280f                 	lds r26, pulse2_note //load the current note index
00253f c02b                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process:
002540 9220 2884                 	sts pulse2_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002542 9220 2885                 	sts pulse2_total_pitch_offset+1, zero
002544 9220 288b                 	sts pulse2_total_hi_pitch_offset, zero
002546 91a0 2883                 	lds r26, pulse2_arpeggio_macro_mode
002548 30a1                      	cpi r26, 0x01 //absolute mode
002549 f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_absolute
00254a f069                      	breq sound_driver_instrument_routine_channel1_arpeggio_process_fixed
00254b c00e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute:
00254c 91a0 280f                 	lds r26, pulse2_note //load the current note index
00254e 0fab                      	add r26, r27 //offset the note with the arpeggio data
00254f fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002550 c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_add:
002551 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002552 f0c0                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
002553 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002554 c016                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract:
002555 fda7                      	sbrc r26, 7 //check if result is negative
002556 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002557 c013                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_fixed:
002558 2fab                      	mov r26, r27 //move the arpeggio data into r26
002559 c011                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative:
00255a 91a0 280f                 	lds r26, pulse2_note //load the current note index
00255c 0fab                      	add r26, r27 //offset the note with the arpeggio data
00255d fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
00255e c008                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_add:
00255f 93a0 280f                 	sts pulse2_note, r26 //NOTE: relative mode modifies the original note index
002561 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002562 f040                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
002563 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002564 93a0 280f                 	sts pulse2_note, r26
002566 c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract:
002567 fda7                      	sbrc r26, 7 //check if result is negative
002568 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002569 93a0 280f                 	sts pulse2_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_load:
00256b e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
00256c e0f0                      	ldi ZH, HIGH(note_table << 1)
00256d 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
00256e 0fea                      	add ZL, r26 //add offset
00256f 1df2                      	adc ZH, zero
002570 91a5                      	lpm r26, Z+ //load bytes
002571 91b4                      	lpm r27, Z
002572 93a0 0a9c                 	sts TCB1_CCMPL, r26 //load the LOW bits for timer
002574 93b0 0a9d                 	sts TCB1_CCMPH, r27 //load the HIGH bits for timer
002576 93a0 28a2                 	sts pulse2_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002578 93b0 28a3                 	sts pulse2_fx_3xx_target+1, r27
00257a c000                      	rjmp sound_driver_instrument_routine_channel1_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch:
00257b 91e0 2886                 	lds ZL, pulse2_pitch_macro
00257d 91f0 2887                 	lds ZH, pulse2_pitch_macro+1
00257f 9630                      	adiw Z, 0
002580 f409                      	brne sound_driver_instrument_routine_channel1_pitch_continue
002581 c023                      	rjmp sound_driver_instrument_routine_channel1_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel1_pitch_continue:
002582 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002583 1fff                      	rol ZH
002584 91a0 2888                 	lds r26, pulse2_pitch_macro_offset
002586 0fea                      	add ZL, r26
002587 1df2                      	adc ZH, zero
                                 
002588 91b0 288a                 	lds r27, pulse2_pitch_macro_release
00258a 17ba                      	cp r27, r26
00258b f429                      	brne sound_driver_instrument_routine_channel1_pitch_increment //if the current offset is not equal to the release index, increment the offset
00258c 91a0 2889                 	lds r26, pulse2_pitch_macro_loop
00258e 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00258f f010                      	brlo sound_driver_instrument_routine_channel1_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002590 c003                      	rjmp sound_driver_instrument_routine_channel1_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_pitch_increment:
002591 95a3                      	inc r26 //increment the macro offset
002592 93a0 2888                 	sts pulse2_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_pitch_read:
002594 91b4                      	lpm r27, Z //load pitch data into r27
002595 38b0                      	cpi r27, 0x80 //check for macro end flag
002596 f479                      	brne sound_driver_instrument_routine_channel1_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_release:
002597 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002598 93a0 2888                 	sts pulse2_pitch_macro_offset, r26
00259a 91b0 288a                 	lds r27, pulse2_pitch_macro_release
00259c 3fbf                      	cpi r27, 0xFF
00259d f439                      	brne sound_driver_instrument_routine_channel1_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_loop:
00259e 91b0 2889                 	lds r27, pulse2_pitch_macro_loop //load the loop index
0025a0 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0025a1 f019                      	breq sound_driver_instrument_routine_channel1_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
0025a2 93b0 2888                 	sts pulse2_pitch_macro_offset, r27 //store the loop index into the offset
0025a4 cfd6                      	rjmp sound_driver_instrument_routine_channel1_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_default:
0025a5 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel1_pitch_calculate:
0025a6 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0025a7 937f                      	push r23
0025a8 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
0025a9 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0025aa 0367                      	mulsu r22, r23
0025ab 917f                      	pop r23
0025ac 916f                      	pop r22
                                 
0025ad 9416                      	lsr r1 //shift out the fractional bits
0025ae 9407                      	ror r0
0025af 9416                      	lsr r1
0025b0 9407                      	ror r0
0025b1 9416                      	lsr r1
0025b2 9407                      	ror r0
0025b3 9416                      	lsr r1
0025b4 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_check_negative:
0025b5 fe13                      	sbrs r1, 3 //check if result was a negative number
0025b6 c007                      	rjmp sound_driver_instrument_routine_channel1_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_negative:
0025b7 efc0                      	ldi r28, 0xF0
0025b8 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_check_divisible_8:
0025b9 70b7                      	andi r27, 0b00000111
0025ba f019                      	breq sound_driver_instrument_routine_channel1_pitch_calculate_offset
                                 
0025bb e0b1                      	ldi r27, 0x01
0025bc 0e0b                      	add r0, r27
0025bd 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_offset:
0025be 91a0 2884                 	lds r26, pulse2_total_pitch_offset
0025c0 91b0 2885                 	lds r27, pulse2_total_pitch_offset+1
0025c2 0e0a                      	add r0, r26
0025c3 1e1b                      	adc r1, r27
0025c4 9200 2884                 	sts pulse2_total_pitch_offset, r0
0025c6 9210 2885                 	sts pulse2_total_pitch_offset+1, r1
0025c8 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
0025ca 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
0025cc 0da0                      	add r26, r0 //offset the timer values
0025cd 1db1                      	adc r27, r1
                                 	
0025ce 91c0 289a                 	lds r28, pulse2_fx_1xx_total
0025d0 91d0 289b                 	lds r29, pulse2_fx_1xx_total+1
0025d2 1bac                      	sub r26, r28
0025d3 0bbd                      	sbc r27, r29
0025d4 91c0 289e                 	lds r28, pulse2_fx_2xx_total
0025d6 91d0 289f                 	lds r29, pulse2_fx_2xx_total+1
0025d8 0fac                      	add r26, r28
0025d9 1fbd                      	adc r27, r29
0025da 91c0 28b2                 	lds r28, pulse2_fx_Pxx_total
0025dc 91d0 28b3                 	lds r29, pulse2_fx_Pxx_total+1
0025de 0fac                      	add r26, r28
0025df 1fbd                      	adc r27, r29
0025e0 91c0 28b9                 	lds r28, pulse2_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
0025e2 91d0 28ba                 	lds r29, pulse2_fx_Qxy_total_offset+1
0025e4 1bac                      	sub r26, r28
0025e5 0bbd                      	sbc r27, r29
0025e6 91c0 28c0                 	lds r28, pulse2_fx_Rxy_total_offset
0025e8 91d0 28c1                 	lds r29, pulse2_fx_Rxy_total_offset+1
0025ea 0fac                      	add r26, r28
0025eb 1fbd                      	adc r27, r29
                                 
0025ec 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
0025ee 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel1_hi_pitch:
0025f0 91e0 288c                 	lds ZL, pulse2_hi_pitch_macro
0025f2 91f0 288d                 	lds ZH, pulse2_hi_pitch_macro+1
0025f4 9630                      	adiw Z, 0
0025f5 f409                      	brne sound_driver_instrument_routine_channel1_hi_pitch_continue
0025f6 c03c                      	rjmp sound_driver_instrument_routine_channel1_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel1_hi_pitch_continue:
0025f7 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0025f8 1fff                      	rol ZH
0025f9 91a0 288e                 	lds r26, pulse2_hi_pitch_macro_offset
0025fb 0fea                      	add ZL, r26
0025fc 1df2                      	adc ZH, zero
                                 
0025fd 91b0 2890                 	lds r27, pulse2_hi_pitch_macro_release
0025ff 17ba                      	cp r27, r26
002600 f429                      	brne sound_driver_instrument_routine_channel1_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002601 91a0 288f                 	lds r26, pulse2_hi_pitch_macro_loop
002603 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002604 f010                      	brlo sound_driver_instrument_routine_channel1_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002605 c003                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_increment:
002606 95a3                      	inc r26 //increment the macro offset
002607 93a0 288e                 	sts pulse2_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_hi_pitch_read:
002609 91b4                      	lpm r27, Z //load hi pitch data into r27
00260a 38b0                      	cpi r27, 0x80 //check for macro end flag
00260b f489                      	brne sound_driver_instrument_routine_channel1_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_release:
00260c 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00260d 93a0 288e                 	sts pulse2_hi_pitch_macro_offset, r26
00260f 91b0 2890                 	lds r27, pulse2_hi_pitch_macro_release
002611 3fbf                      	cpi r27, 0xFF
002612 f439                      	brne sound_driver_instrument_routine_channel1_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_loop:
002613 91b0 288f                 	lds r27, pulse2_hi_pitch_macro_loop //load the loop index
002615 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002616 f019                      	breq sound_driver_instrument_routine_channel1_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002617 93b0 288e                 	sts pulse2_hi_pitch_macro_offset, r27 //store the loop index into the offset
002619 cfd6                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_default:
00261a 91b0 288b                 	lds r27, pulse2_total_hi_pitch_offset
00261c c005                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate:
00261d 91a0 288b                 	lds r26, pulse2_total_hi_pitch_offset //load the total hi pitch offset to change
00261f 0fba                      	add r27, r26
002620 93b0 288b                 	sts pulse2_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply:
002622 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002623 937f                      	push r23
002624 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002625 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002626 0367                      	mulsu r22, r23
002627 917f                      	pop r23
002628 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_offset:
002629 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
00262b 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
00262d 0da0                      	add r26, r0 //offset the timer values
00262e 1db1                      	adc r27, r1
00262f 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
002631 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel1_duty:
002633 91e0 2891                 	lds ZL, pulse2_duty_macro
002635 91f0 2892                 	lds ZH, pulse2_duty_macro+1
002637 9630                      	adiw Z, 0
002638 f1b1                      	breq sound_driver_channel1_fx_routines //if no duty macro is in use, go to the next routine
002639 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00263a 1fff                      	rol ZH
00263b 91a0 2893                 	lds r26, pulse2_duty_macro_offset
00263d 0fea                      	add ZL, r26
00263e 1df2                      	adc ZH, zero
                                 
00263f 91b0 2895                 	lds r27, pulse2_duty_macro_release
002641 17ba                      	cp r27, r26
002642 f429                      	brne sound_driver_instrument_routine_channel1_duty_increment //if the current offset is not equal to the release index, increment the offset
002643 91a0 2894                 	lds r26, pulse2_duty_macro_loop
002645 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002646 f010                      	brlo sound_driver_instrument_routine_channel1_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002647 c027                      	rjmp sound_driver_channel1_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel1_duty_increment:
002648 95a3                      	inc r26 //increment the macro offset
002649 93a0 2893                 	sts pulse2_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_duty_read:
00264b 91b4                      	lpm r27, Z //load pitch data into r27
00264c 3fbf                      	cpi r27, 0xFF //check for macro end flag
00264d f471                      	brne sound_driver_instrument_routine_channel1_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_release:
00264e 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00264f 93a0 2893                 	sts pulse2_duty_macro_offset, r26
002651 91b0 2895                 	lds r27, pulse2_duty_macro_release
002653 3fbf                      	cpi r27, 0xFF
002654 f4d1                      	brne sound_driver_channel1_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_loop:
002655 91b0 2894                 	lds r27, pulse2_duty_macro_loop //load the loop index
002657 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002658 f0b1                      	breq sound_driver_channel1_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
002659 93b0 2893                 	sts pulse2_duty_macro_offset, r27 //store the loop index into the offset
00265b cfd7                      	rjmp sound_driver_instrument_routine_channel1_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_load:
00265c ebe0                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
00265d e5fb                      	ldi ZH, HIGH(sequences << 1)
00265e 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
00265f 1df2                      	adc ZH, zero
                                 
002660 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
002661 95b7                      	ror r27
002662 95b7                      	ror r27
002663 91a0 2808                 	lds r26, pulse2_param //load r26 with pulse2_param (register $4000)
002665 2fca                      	mov r28, r26 //store a copy of pulse2_param into r28
002666 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
002667 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
002668 c001                      	rjmp sound_driver_instrument_routine_channel1_duty_load_store
002669 c005                      	rjmp sound_driver_channel1_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel1_duty_load_store:
00266a 90d4                      	lpm pulse2_sequence, Z //store the sequence
                                 
00266b 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
00266c 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
00266d 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_routines:
                                 sound_driver_channel1_fx_1xx_routine:
00266f 91e0 2898                 	lds ZL, pulse2_fx_1xx
002671 91f0 2899                 	lds ZH, pulse2_fx_1xx+1
002673 9630                      	adiw Z, 0
002674 f051                      	breq sound_driver_channel1_fx_2xx_routine
                                 
002675 91a0 289a                 	lds r26, pulse2_fx_1xx_total //load the rate to change the pitch by
002677 91b0 289b                 	lds r27, pulse2_fx_1xx_total+1
002679 0fae                      	add r26, ZL //increase the total offset by the rate
00267a 1fbf                      	adc r27, ZH
00267b 93a0 289a                 	sts pulse2_fx_1xx_total, r26
00267d 93b0 289b                 	sts pulse2_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_2xx_routine:
00267f 91e0 289c                 	lds ZL, pulse2_fx_2xx
002681 91f0 289d                 	lds ZH, pulse2_fx_2xx+1
002683 9630                      	adiw Z, 0
002684 f051                      	breq sound_driver_channel1_fx_3xx_routine
                                 
002685 91a0 289e                 	lds r26, pulse2_fx_2xx_total //load the rate to change the pitch by
002687 91b0 289f                 	lds r27, pulse2_fx_2xx_total+1
002689 0fae                      	add r26, ZL //increase the total offset by the rate
00268a 1fbf                      	adc r27, ZH
00268b 93a0 289e                 	sts pulse2_fx_2xx_total, r26
00268d 93b0 289f                 	sts pulse2_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_3xx_routine:
00268f 91e0 28a4                 	lds ZL, pulse2_fx_3xx_speed
002691 91f0 28a5                 	lds ZH, pulse2_fx_3xx_speed+1
002693 9630                      	adiw Z, 0
002694 f409                      	brne sound_driver_channel1_fx_3xx_routine_check_start
002695 c048                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_check_start:
002696 91a0 28a0                 	lds r26, pulse2_fx_3xx_start
002698 91b0 28a1                 	lds r27, pulse2_fx_3xx_start+1
00269a 9610                      	adiw r26:r27, 0
00269b f409                      	brne sound_driver_channel1_fx_3xx_routine_main
00269c c041                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_main:
00269d 91c0 28a2                 	lds r28, pulse2_fx_3xx_target
00269f 91d0 28a3                 	lds r29, pulse2_fx_3xx_target+1
                                 
0026a1 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
0026a2 07bd                      	cpc r27, r29
0026a3 f011                      	breq sound_driver_channel1_fx_3xx_routine_disable
0026a4 f030                      	brlo sound_driver_channel1_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
0026a5 c01f                      	rjmp sound_driver_channel1_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel1_fx_3xx_routine_disable:
0026a6 9220 28a0                 	sts pulse2_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
0026a8 9220 28a1                 	sts pulse2_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
0026aa c033                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_subtract:
0026ab 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
0026ac 0bdb                      	sbc r29, r27
0026ad 91a0 28a6                 	lds r26, pulse2_fx_3xx_total_offset
0026af 91b0 28a7                 	lds r27, pulse2_fx_3xx_total_offset+1
                                 
0026b1 0fae                      	add r26, ZL //add the speed to the total offset
0026b2 1fbf                      	adc r27, ZH
0026b3 1bca                      	sub r28, r26 //invert the total difference with the total offset
0026b4 0bdb                      	sbc r29, r27
0026b5 f380                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0026b6 93a0 28a6                 	sts pulse2_fx_3xx_total_offset, r26 //store the new total offset
0026b8 93b0 28a7                 	sts pulse2_fx_3xx_total_offset+1, r27
                                 
0026ba 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the current timer period
0026bc 91b0 0a9d                 	lds r27, TCB1_CCMPH
0026be 1bac                      	sub r26, r28 //offset the current timer period with the total offset
0026bf 0bbd                      	sbc r27, r29
0026c0 93a0 0a9c                 	sts TCB1_CCMPL, r26
0026c2 93b0 0a9d                 	sts TCB1_CCMPH, r27
0026c4 c019                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_add:
0026c5 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
0026c6 0bbd                      	sbc r27, r29
0026c7 91c0 28a6                 	lds r28, pulse2_fx_3xx_total_offset
0026c9 91d0 28a7                 	lds r29, pulse2_fx_3xx_total_offset+1
                                 
0026cb 0fce                      	add r28, ZL //add the speed to the total offset
0026cc 1fdf                      	adc r29, ZH
0026cd 1bac                      	sub r26, r28 //invert the total difference with the total offset
0026ce 0bbd                      	sbc r27, r29
0026cf f2b0                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0026d0 93c0 28a6                 	sts pulse2_fx_3xx_total_offset, r28 //store the new total offset
0026d2 93d0 28a7                 	sts pulse2_fx_3xx_total_offset+1, r29
                                 
0026d4 91c0 0a9c                 	lds r28, TCB1_CCMPL //load the current timer period
0026d6 91d0 0a9d                 	lds r29, TCB1_CCMPH
0026d8 0fca                      	add r28, r26 //offset the current timer period with the total offset
0026d9 1fdb                      	adc r29, r27
0026da 93c0 0a9c                 	sts TCB1_CCMPL, r28
0026dc 93d0 0a9d                 	sts TCB1_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel1_fx_4xy_routine:
0026de 91a0 28a8                 	lds r26, pulse2_fx_4xy_speed
0026e0 15a2                      	cp r26, zero
0026e1 f409                      	brne sound_driver_channel1_fx_4xy_routine_continue
0026e2 c05c                      	rjmp sound_driver_channel1_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel1_fx_4xy_routine_continue:
0026e3 91b0 28a9                 	lds r27, pulse2_fx_4xy_depth
0026e5 91c0 28aa                 	lds r28, pulse2_fx_4xy_phase
0026e7 0fca                      	add r28, r26 //increase the phase by the speed
0026e8 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
0026e9 f008                      	brlo sound_driver_channel1_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
0026ea e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase:
0026eb 93c0 28aa                 	sts pulse2_fx_4xy_phase, r28 //store the new phase
0026ed 31c0                      	cpi r28, 16
0026ee f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_0
0026ef 32c0                      	cpi r28, 32
0026f0 f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_1
0026f1 33c0                      	cpi r28, 48
0026f2 f030                      	brlo sound_driver_channel1_fx_4xy_routine_phase_2
0026f3 c007                      	rjmp sound_driver_channel1_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_0:
0026f4 70cf                      	andi r28, 0x0F //mask for values 0-15
0026f5 c029                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_1:
0026f6 6fc0                      	ori r28, 0xF0
0026f7 95c0                      	com r28 //invert values 0-15
0026f8 c026                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_2:
0026f9 70cf                      	andi r28, 0x0F //mask for values 0-15
0026fa c003                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_3:
0026fb 6fc0                      	ori r28, 0xF0
0026fc 95c0                      	com r28 //invert values 0-15
0026fd c000                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_add:
0026fe 95b2                      	swap r27 //multiply depth by 16
0026ff 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002700 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002701 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002702 0fec                      	add ZL, r28 //offset the table by the depth+phase
002703 1df2                      	adc ZH, zero
002704 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002705 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002706 937f                      	push r23
002707 2f6c                      	mov r22, r28 //store the vibrato value into r22
002708 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002709 9f67                      	mul r22, r23
00270a 917f                      	pop r23
00270b 916f                      	pop r22
                                 
00270c 9416                      	lsr r1 //shift out the fractional bits
00270d 9407                      	ror r0
00270e 9416                      	lsr r1
00270f 9407                      	ror r0
002710 9416                      	lsr r1
002711 9407                      	ror r0
002712 9416                      	lsr r1
002713 9407                      	ror r0
                                 	
002714 91a0 0a9c                 	lds r26, TCB1_CCMPL
002716 91b0 0a9d                 	lds r27, TCB1_CCMPH
002718 0da0                      	add r26, r0
002719 1db1                      	adc r27, r1
00271a 93a0 0a9c                 	sts TCB1_CCMPL, r26
00271c 93b0 0a9d                 	sts TCB1_CCMPH, r27
00271e c020                      	rjmp sound_driver_channel1_fx_7xy_routine
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_subtract:
00271f 95b2                      	swap r27 //multiply depth by 16
002720 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002721 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002722 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002723 0fec                      	add ZL, r28 //offset the table by the depth+phase
002724 1df2                      	adc ZH, zero
002725 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002726 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002727 937f                      	push r23
002728 2f6c                      	mov r22, r28 //store the vibrato value into r22
002729 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00272a 9f67                      	mul r22, r23
00272b 917f                      	pop r23
00272c 916f                      	pop r22
                                 
00272d 9416                      	lsr r1 //shift out the fractional bits
00272e 9407                      	ror r0
00272f 9416                      	lsr r1
002730 9407                      	ror r0
002731 9416                      	lsr r1
002732 9407                      	ror r0
002733 9416                      	lsr r1
002734 9407                      	ror r0
                                 
002735 91a0 0a9c                 	lds r26, TCB1_CCMPL
002737 91b0 0a9d                 	lds r27, TCB1_CCMPH
002739 19a0                      	sub r26, r0
00273a 09b1                      	sbc r27, r1
00273b 93a0 0a9c                 	sts TCB1_CCMPL, r26
00273d 93b0 0a9d                 	sts TCB1_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_7xy_routine:
00273f 91a0 28ab                 	lds r26, pulse2_fx_7xy_speed
002741 15a2                      	cp r26, zero
002742 f0e9                      	breq sound_driver_channel1_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
002743 91b0 28ac                 	lds r27, pulse2_fx_7xy_depth
002745 91c0 28ad                 	lds r28, pulse2_fx_7xy_phase
002747 0fca                      	add r28, r26 //increase the phase by the speed
002748 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002749 f008                      	brlo sound_driver_channel1_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
00274a e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase:
00274b 93c0 28ad                 	sts pulse2_fx_7xy_phase, r28 //store the new phase
00274d 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
00274e ffc4                      	sbrs r28, 4
00274f c001                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_0
002750 c002                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel1_fx_7xy_routine_phase_0:
002751 70cf                      	andi r28, 0x0F //mask for values 0-15
002752 c003                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase_1:
002753 6fc0                      	ori r28, 0xF0
002754 95c0                      	com r28 //invert values 0-15
002755 c000                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_load:
002756 95b2                      	swap r27 //multiply depth by 16
002757 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002758 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002759 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00275a 0fec                      	add ZL, r28 //offset the table by the depth+phase
00275b 1df2                      	adc ZH, zero
00275c 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
00275d 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
00275e 93c0 28ae                 	sts pulse2_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Axy_routine:
002760 91b0 28af                 	lds r27, pulse2_fx_Axy
002762 15b2                      	cp r27, zero
002763 f0e9                      	breq sound_driver_channel1_fx_Qxy_routine //0 means that the effect is not in use
                                 	
002764 91a0 280d                 	lds r26, pulse2_fractional_volume //load fractional volume representation of the channel
002766 91c0 2808                 	lds r28, pulse2_param //load the integer volume representation of the channel
002768 2fda                      	mov r29, r26 //copy fractional volume into r29
002769 2fec                      	mov r30, r28 //copy the pulse2_param into r30
00276a 95e2                      	swap r30
00276b 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
00276c 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
00276d 17ed                      	cp r30, r29 //compare the fractional and integer volumes
00276e f009                      	breq sound_driver_channel1_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel1_fx_Axy_routine_reload:
00276f 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate:
002770 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
002771 c004                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_addition:
002772 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002773 f428                      	brcc sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002774 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
002775 c003                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_subtraction:
002776 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002777 f008                      	brcs sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002778 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_store:
002779 93a0 280d                 	sts pulse2_fractional_volume, r26 //store the new fractional volume
00277b 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
00277c 95a2                      	swap r26
00277d 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
00277e 2bca                      	or r28, r26 //store the new volume back into pulse2_param
00277f 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel1_fx_Qxy_routine:
002781 91e0 28b5                 	lds ZL, pulse2_fx_Qxy_target
002783 91f0 28b6                 	lds ZH, pulse2_fx_Qxy_target+1
002785 9630                      	adiw Z, 0
002786 f119                      	breq sound_driver_channel1_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002787 91a0 28b9                 	lds r26, pulse2_fx_Qxy_total_offset
002789 91b0 28ba                 	lds r27, pulse2_fx_Qxy_total_offset+1
00278b 91c0 0a9c                 	lds r28, TCB1_CCMPL
00278d 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
00278f 1bec                      	sub ZL, r28 //calculate the difference to the target
002790 0bfd                      	sbc ZH, r29
002791 f408                      	brsh sound_driver_channel1_fx_Qxy_routine_end //if the target has been reached (or passed)
002792 f068                      	brlo sound_driver_channel1_fx_Qxy_routine_add
                                 
                                 sound_driver_channel1_fx_Qxy_routine_end:
002793 9220 28b9                 	sts pulse2_fx_Qxy_total_offset, zero //turn off the effect
002795 9220 28ba                 	sts pulse2_fx_Qxy_total_offset+1, zero
002797 9220 28b5                 	sts pulse2_fx_Qxy_target, zero
002799 9220 28b6                 	sts pulse2_fx_Qxy_target+1, zero
00279b 91b0 28b4                 	lds r27, pulse2_fx_Qxy_target_note
00279d 93b0 280f                 	sts pulse2_note, r27 //replace the note with the final target note
00279f c00a                      	rjmp sound_driver_channel1_fx_Rxy_routine
                                 
                                 sound_driver_channel1_fx_Qxy_routine_add:
0027a0 91c0 28b7                 	lds r28, pulse2_fx_Qxy_speed
0027a2 91d0 28b8                 	lds r29, pulse2_fx_Qxy_speed+1
0027a4 0fac                      	add r26, r28 //increase the total offset by the speed
0027a5 1fbd                      	adc r27, r29
0027a6 93a0 28b9                 	sts pulse2_fx_Qxy_total_offset, r26 //store the total offset
0027a8 93b0 28ba                 	sts pulse2_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Rxy_routine:
0027aa 91e0 28bc                 	lds ZL, pulse2_fx_Rxy_target
0027ac 91f0 28bd                 	lds ZH, pulse2_fx_Rxy_target+1
0027ae 9630                      	adiw Z, 0
0027af f119                      	breq sound_driver_instrument_routine_channel2_volume //if the effect is not enabled, skip the routine
                                 
0027b0 91a0 28c0                 	lds r26, pulse2_fx_Rxy_total_offset
0027b2 91b0 28c1                 	lds r27, pulse2_fx_Rxy_total_offset+1
0027b4 91c0 0a9c                 	lds r28, TCB1_CCMPL
0027b6 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
0027b8 1bce                      	sub r28, ZL //calculate the difference to the target
0027b9 0bdf                      	sbc r29, ZH
0027ba f408                      	brsh sound_driver_channel1_fx_Rxy_routine_end //if the target has been reached (or passed)
0027bb f068                      	brlo sound_driver_channel1_fx_Rxy_routine_add
                                 
                                 sound_driver_channel1_fx_Rxy_routine_end:
0027bc 9220 28c0                 	sts pulse2_fx_Rxy_total_offset, zero //disable the effect
0027be 9220 28c1                 	sts pulse2_fx_Rxy_total_offset+1, zero
0027c0 9220 28bc                 	sts pulse2_fx_Rxy_target, zero
0027c2 9220 28bd                 	sts pulse2_fx_Rxy_target+1, zero
0027c4 91b0 28bb                 	lds r27, pulse2_fx_Rxy_target_note
0027c6 93b0 280f                 	sts pulse2_note, r27 //replace the note with the final target note
0027c8 c00a                      	rjmp sound_driver_instrument_routine_channel2_volume
                                 
                                 sound_driver_channel1_fx_Rxy_routine_add:
0027c9 91c0 28be                 	lds r28, pulse2_fx_Rxy_speed
0027cb 91d0 28bf                 	lds r29, pulse2_fx_Rxy_speed+1
0027cd 0fac                      	add r26, r28 //increase the total offset by the speed
0027ce 1fbd                      	adc r27, r29
0027cf 93a0 28c0                 	sts pulse2_fx_Rxy_total_offset, r26 //store the total offset
0027d1 93b0 28c1                 	sts pulse2_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume:
0027d3 91e0 28ca                 	lds ZL, triangle_volume_macro
0027d5 91f0 28cb                 	lds ZH, triangle_volume_macro+1
0027d7 9630                      	adiw Z, 0
0027d8 f199                      	breq sound_driver_instrument_routine_channel2_volume_default //if no volume macro is in use, do nothing
0027d9 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0027da 1fff                      	rol ZH
0027db 91a0 28cc                 	lds r26, triangle_volume_macro_offset
0027dd 0fea                      	add ZL, r26
0027de 1df2                      	adc ZH, zero
                                 
0027df 91b0 28ce                 	lds r27, triangle_volume_macro_release
0027e1 17ba                      	cp r27, r26
0027e2 f429                      	brne sound_driver_instrument_routine_channel2_volume_increment //if the current offset is not equal to the release index, increment the offset
0027e3 91a0 28cd                 	lds r26, triangle_volume_macro_loop
0027e5 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0027e6 f010                      	brlo sound_driver_instrument_routine_channel2_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0027e7 c003                      	rjmp sound_driver_instrument_routine_channel2_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_volume_increment:
0027e8 95a3                      	inc r26 //increment the macro offset
0027e9 93a0 28cc                 	sts triangle_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_volume_read:
0027eb 91b4                      	lpm r27, Z //load volume data into r27
0027ec 3fbf                      	cpi r27, 0xFF //check for macro end flag
0027ed f469                      	brne sound_driver_instrument_routine_channel2_volume_process //if the data was not the macro end flag
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_release:
0027ee 91b0 28ce                 	lds r27, triangle_volume_macro_release
0027f0 3fbf                      	cpi r27, 0xFF
0027f1 f429                      	brne sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_loop:
0027f2 91b0 28cd                 	lds r27, triangle_volume_macro_loop //load the loop index
0027f4 93b0 28cc                 	sts triangle_volume_macro_offset, r27 //store the loop index into the offset
0027f6 cfdc                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index:
0027f7 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
0027f8 93a0 28cc                 	sts triangle_volume_macro_offset, r26
0027fa cfd8                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_process:
0027fb 15b2                      	cp r27, zero
0027fc f041                      	breq sound_driver_instrument_routine_channel2_volume_process_disable
                                 sound_driver_instrument_routine_channel2_volume_process_enable:
0027fd 91b0 0aa5                 	lds r27, TCB2_INTCTRL
0027ff 30b1                      	cpi r27, TCB_CAPT_bm
002800 f459                      	brne sound_driver_instrument_routine_channel2_volume_default //if the channel has already been muted, don't enable it again
002801 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
002802 93b0 0aa5                 	sts TCB2_INTCTRL, r27
002804 c007                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 sound_driver_instrument_routine_channel2_volume_process_disable:
002805 9220 0aa5                 	sts TCB2_INTCTRL, zero
002807 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
002809 9220 0aad                 	sts TCB2_CCMPH, zero
00280b c000                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_volume_default:
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
00280c 91e0 28cf                 	lds ZL, triangle_arpeggio_macro
00280e 91f0 28d0                 	lds ZH, triangle_arpeggio_macro+1
002810 9630                      	adiw Z, 0
002811 f1d9                      	breq sound_driver_instrument_routine_channel2_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002812 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002813 1fff                      	rol ZH
002814 91a0 28d1                 	lds r26, triangle_arpeggio_macro_offset
002816 0fea                      	add ZL, r26
002817 1df2                      	adc ZH, zero
                                 
002818 91b0 28d3                 	lds r27, triangle_arpeggio_macro_release
00281a 17ba                      	cp r27, r26
00281b f429                      	brne sound_driver_instrument_routine_channel2_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
00281c 91a0 28d2                 	lds r26, triangle_arpeggio_macro_loop
00281e 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00281f f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002820 c003                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_increment:
002821 95a3                      	inc r26 //increment the macro offset
002822 93a0 28d1                 	sts triangle_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_read:
002824 91b4                      	lpm r27, Z //load arpeggio data into r27
002825 38b0                      	cpi r27, 0x80 //check for macro end flag
002826 f009                      	breq sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag
002827 c041                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_check_mode:
002828 50a1                      	subi r26, 1 //keep the offset at the end flag
002829 93a0 28d1                 	sts triangle_arpeggio_macro_offset, r26
00282b 91b0 28d4                 	lds r27, triangle_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
00282d 30b1                      	cpi r27, 0x01
00282e f048                      	brlo sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_release:
00282f 91b0 28d3                 	lds r27, triangle_arpeggio_macro_release
002831 3fbf                      	cpi r27, 0xFF
002832 f4d1                      	brne sound_driver_instrument_routine_channel2_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_loop:
002833 91b0 28d2                 	lds r27, triangle_arpeggio_macro_loop
002835 3fbf                      	cpi r27, 0xFF
002836 f499                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002837 c015                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute:
002838 91b0 28d3                 	lds r27, triangle_arpeggio_macro_release
00283a 3fbf                      	cpi r27, 0xFF
00283b f421                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_check_loop:
00283c 91b0 28d2                 	lds r27, triangle_arpeggio_macro_loop //load the loop index
00283e 3fbf                      	cpi r27, 0xFF //check if loop flag exists
00283f f451                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop:
002840 91c0 28e7                 	lds r28, triangle_fx_0xy_sequence //check for 0xy effect
002842 91d0 28e8                 	lds r29, triangle_fx_0xy_sequence+1
002844 9620                      	adiw r29:r28, 0
002845 f469                      	brne sound_driver_instrument_routine_channel2_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002846 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002847 93a0 28d1                 	sts triangle_arpeggio_macro_offset, r26 //store the last valid index into the offset
002849 cfc2                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload:
00284a 93b0 28d1                 	sts triangle_arpeggio_macro_offset, r27 //store the loop index into the offset
00284c cfbf                      	rjmp sound_driver_instrument_routine_channel2_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_default:
00284d 91c0 28e7                 	lds r28, triangle_fx_0xy_sequence //load 0xy effect
00284f 91d0 28e8                 	lds r29, triangle_fx_0xy_sequence+1
002851 9620                      	adiw r29:r28, 0 //check for 0xy effect
002852 f099                      	breq sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel2_arpeggio_default_xy:
002853 95d6                      	lsr r29
002854 95c7                      	ror r28
002855 95d7                      	ror r29
002856 95c7                      	ror r28
002857 95d7                      	ror r29
002858 95c7                      	ror r28
002859 95d7                      	ror r29
00285a 95c7                      	ror r28
00285b 95d7                      	ror r29
00285c 95d2                      	swap r29
                                 
00285d 93c0 28e7                 	sts triangle_fx_0xy_sequence, r28 //store the rolled sequence
00285f 93d0 28e8                 	sts triangle_fx_0xy_sequence+1, r29
002861 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002862 91a0 2812                 	lds r26, triangle_note //load the current note index
002864 0fac                      	add r26, r28 //add the note offset
002865 c02e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002866 91a0 2812                 	lds r26, triangle_note //load the current note index
002868 c02b                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process:
002869 9220 28d5                 	sts triangle_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
00286b 9220 28d6                 	sts triangle_total_pitch_offset+1, zero
00286d 9220 28dc                 	sts triangle_total_hi_pitch_offset, zero
00286f 91a0 28d4                 	lds r26, triangle_arpeggio_macro_mode
002871 30a1                      	cpi r26, 0x01 //absolute mode
002872 f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_absolute
002873 f069                      	breq sound_driver_instrument_routine_channel2_arpeggio_process_fixed
002874 c00e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute:
002875 91a0 2812                 	lds r26, triangle_note //load the current note index
002877 0fab                      	add r26, r27 //offset the note with the arpeggio data
002878 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002879 c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_add:
00287a 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
00287b f0c0                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
00287c e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
00287d c016                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract:
00287e fda7                      	sbrc r26, 7 //check if result is negative
00287f e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002880 c013                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_fixed:
002881 2fab                      	mov r26, r27 //move the arpeggio data into r26
002882 c011                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative:
002883 91a0 2812                 	lds r26, triangle_note //load the current note index
002885 0fab                      	add r26, r27 //offset the note with the arpeggio data
002886 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002887 c008                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_add:
002888 93a0 2812                 	sts triangle_note, r26 //NOTE: relative mode modifies the original note index
00288a 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
00288b f040                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
00288c e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
00288d 93a0 2812                 	sts triangle_note, r26
00288f c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract:
002890 fda7                      	sbrc r26, 7 //check if result is negative
002891 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002892 93a0 2812                 	sts triangle_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_load:
002894 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
002895 e0f0                      	ldi ZH, HIGH(note_table << 1)
002896 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002897 0fea                      	add ZL, r26 //add offset
002898 1df2                      	adc ZH, zero
002899 91a5                      	lpm r26, Z+ //load bytes
00289a 91b4                      	lpm r27, Z
00289b 93a0 0aac                 	sts TCB2_CCMPL, r26 //load the LOW bits for timer
00289d 93b0 0aad                 	sts TCB2_CCMPH, r27 //load the HIGH bits for timer
00289f 93a0 28f3                 	sts triangle_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
0028a1 93b0 28f4                 	sts triangle_fx_3xx_target+1, r27
0028a3 c000                      	rjmp sound_driver_instrument_routine_channel2_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch:
0028a4 91e0 28d7                 	lds ZL, triangle_pitch_macro
0028a6 91f0 28d8                 	lds ZH, triangle_pitch_macro+1
0028a8 9630                      	adiw Z, 0
0028a9 f409                      	brne sound_driver_instrument_routine_channel2_pitch_continue
0028aa c023                      	rjmp sound_driver_instrument_routine_channel2_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel2_pitch_continue:
0028ab 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0028ac 1fff                      	rol ZH
0028ad 91a0 28d9                 	lds r26, triangle_pitch_macro_offset
0028af 0fea                      	add ZL, r26
0028b0 1df2                      	adc ZH, zero
                                 
0028b1 91b0 28db                 	lds r27, triangle_pitch_macro_release
0028b3 17ba                      	cp r27, r26
0028b4 f429                      	brne sound_driver_instrument_routine_channel2_pitch_increment //if the current offset is not equal to the release index, increment the offset
0028b5 91a0 28da                 	lds r26, triangle_pitch_macro_loop
0028b7 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0028b8 f010                      	brlo sound_driver_instrument_routine_channel2_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0028b9 c003                      	rjmp sound_driver_instrument_routine_channel2_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_pitch_increment:
0028ba 95a3                      	inc r26 //increment the macro offset
0028bb 93a0 28d9                 	sts triangle_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_pitch_read:
0028bd 91b4                      	lpm r27, Z //load pitch data into r27
0028be 38b0                      	cpi r27, 0x80 //check for macro end flag
0028bf f479                      	brne sound_driver_instrument_routine_channel2_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_release:
0028c0 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0028c1 93a0 28d9                 	sts triangle_pitch_macro_offset, r26
0028c3 91b0 28db                 	lds r27, triangle_pitch_macro_release
0028c5 3fbf                      	cpi r27, 0xFF
0028c6 f439                      	brne sound_driver_instrument_routine_channel2_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_loop:
0028c7 91b0 28da                 	lds r27, triangle_pitch_macro_loop //load the loop index
0028c9 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0028ca f019                      	breq sound_driver_instrument_routine_channel2_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
0028cb 93b0 28d9                 	sts triangle_pitch_macro_offset, r27 //store the loop index into the offset
0028cd cfd6                      	rjmp sound_driver_instrument_routine_channel2_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_default:
0028ce e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel2_pitch_calculate:
0028cf 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0028d0 937f                      	push r23
0028d1 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
0028d2 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0028d3 0367                      	mulsu r22, r23
0028d4 917f                      	pop r23
0028d5 916f                      	pop r22
                                 
0028d6 9416                      	lsr r1 //shift out the fractional bits
0028d7 9407                      	ror r0
0028d8 9416                      	lsr r1
0028d9 9407                      	ror r0
0028da 9416                      	lsr r1
0028db 9407                      	ror r0
0028dc 9416                      	lsr r1
0028dd 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_check_negative:
0028de fe13                      	sbrs r1, 3 //check if result was a negative number
0028df c007                      	rjmp sound_driver_instrument_routine_channel2_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_negative:
0028e0 efc0                      	ldi r28, 0xF0
0028e1 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_check_divisible_8:
0028e2 70b7                      	andi r27, 0b00000111
0028e3 f019                      	breq sound_driver_instrument_routine_channel2_pitch_calculate_offset
                                 
0028e4 e0b1                      	ldi r27, 0x01
0028e5 0e0b                      	add r0, r27
0028e6 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_offset:
0028e7 91a0 28d5                 	lds r26, triangle_total_pitch_offset
0028e9 91b0 28d6                 	lds r27, triangle_total_pitch_offset+1
0028eb 0e0a                      	add r0, r26
0028ec 1e1b                      	adc r1, r27
0028ed 9200 28d5                 	sts triangle_total_pitch_offset, r0
0028ef 9210 28d6                 	sts triangle_total_pitch_offset+1, r1
0028f1 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
0028f3 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
0028f5 0da0                      	add r26, r0 //offset the timer values
0028f6 1db1                      	adc r27, r1
                                 	
0028f7 91c0 28eb                 	lds r28, triangle_fx_1xx_total
0028f9 91d0 28ec                 	lds r29, triangle_fx_1xx_total+1
0028fb 1bac                      	sub r26, r28
0028fc 0bbd                      	sbc r27, r29
0028fd 91c0 28ef                 	lds r28, triangle_fx_2xx_total
0028ff 91d0 28f0                 	lds r29, triangle_fx_2xx_total+1
002901 0fac                      	add r26, r28
002902 1fbd                      	adc r27, r29
002903 91c0 28fe                 	lds r28, triangle_fx_Pxx_total
002905 91d0 28ff                 	lds r29, triangle_fx_Pxx_total+1
002907 0fac                      	add r26, r28
002908 1fbd                      	adc r27, r29
002909 91c0 2905                 	lds r28, triangle_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
00290b 91d0 2906                 	lds r29, triangle_fx_Qxy_total_offset+1
00290d 1bac                      	sub r26, r28
00290e 0bbd                      	sbc r27, r29
00290f 91c0 290c                 	lds r28, triangle_fx_Rxy_total_offset
002911 91d0 290d                 	lds r29, triangle_fx_Rxy_total_offset+1
002913 0fac                      	add r26, r28
002914 1fbd                      	adc r27, r29
                                 
002915 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
002917 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel2_hi_pitch:
002919 91e0 28dd                 	lds ZL, triangle_hi_pitch_macro
00291b 91f0 28de                 	lds ZH, triangle_hi_pitch_macro+1
00291d 9630                      	adiw Z, 0
00291e f409                      	brne sound_driver_instrument_routine_channel2_hi_pitch_continue
00291f c03c                      	rjmp sound_driver_instrument_routine_channel2_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel2_hi_pitch_continue:
002920 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002921 1fff                      	rol ZH
002922 91a0 28df                 	lds r26, triangle_hi_pitch_macro_offset
002924 0fea                      	add ZL, r26
002925 1df2                      	adc ZH, zero
                                 
002926 91b0 28e1                 	lds r27, triangle_hi_pitch_macro_release
002928 17ba                      	cp r27, r26
002929 f429                      	brne sound_driver_instrument_routine_channel2_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
00292a 91a0 28e0                 	lds r26, triangle_hi_pitch_macro_loop
00292c 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00292d f010                      	brlo sound_driver_instrument_routine_channel2_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00292e c003                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_increment:
00292f 95a3                      	inc r26 //increment the macro offset
002930 93a0 28df                 	sts triangle_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_hi_pitch_read:
002932 91b4                      	lpm r27, Z //load hi pitch data into r27
002933 38b0                      	cpi r27, 0x80 //check for macro end flag
002934 f489                      	brne sound_driver_instrument_routine_channel2_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_release:
002935 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002936 93a0 28df                 	sts triangle_hi_pitch_macro_offset, r26
002938 91b0 28e1                 	lds r27, triangle_hi_pitch_macro_release
00293a 3fbf                      	cpi r27, 0xFF
00293b f439                      	brne sound_driver_instrument_routine_channel2_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_loop:
00293c 91b0 28e0                 	lds r27, triangle_hi_pitch_macro_loop //load the loop index
00293e 3fbf                      	cpi r27, 0xFF //check if there is a loop index
00293f f019                      	breq sound_driver_instrument_routine_channel2_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002940 93b0 28df                 	sts triangle_hi_pitch_macro_offset, r27 //store the loop index into the offset
002942 cfd6                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_default:
002943 91b0 28dc                 	lds r27, triangle_total_hi_pitch_offset
002945 c005                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate:
002946 91a0 28dc                 	lds r26, triangle_total_hi_pitch_offset //load the total hi pitch offset to change
002948 0fba                      	add r27, r26
002949 93b0 28dc                 	sts triangle_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply:
00294b 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00294c 937f                      	push r23
00294d 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
00294e eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00294f 0367                      	mulsu r22, r23
002950 917f                      	pop r23
002951 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_offset:
002952 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
002954 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
002956 0da0                      	add r26, r0 //offset the timer values
002957 1db1                      	adc r27, r1
002958 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
00295a 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: The triangle channel does not have a duty cycle
                                 sound_driver_instrument_routine_channel2_duty:
                                 
                                 
                                 
                                 sound_driver_channel2_fx_routines:
                                 sound_driver_channel2_fx_1xx_routine:
00295c 91e0 28e9                 	lds ZL, triangle_fx_1xx
00295e 91f0 28ea                 	lds ZH, triangle_fx_1xx+1
002960 9630                      	adiw Z, 0
002961 f051                      	breq sound_driver_channel2_fx_2xx_routine
                                 
002962 91a0 28eb                 	lds r26, triangle_fx_1xx_total //load the rate to change the pitch by
002964 91b0 28ec                 	lds r27, triangle_fx_1xx_total+1
002966 0fae                      	add r26, ZL //increase the total offset by the rate
002967 1fbf                      	adc r27, ZH
002968 93a0 28eb                 	sts triangle_fx_1xx_total, r26
00296a 93b0 28ec                 	sts triangle_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_2xx_routine:
00296c 91e0 28ed                 	lds ZL, triangle_fx_2xx
00296e 91f0 28ee                 	lds ZH, triangle_fx_2xx+1
002970 9630                      	adiw Z, 0
002971 f051                      	breq sound_driver_channel2_fx_3xx_routine
                                 
002972 91a0 28ef                 	lds r26, triangle_fx_2xx_total //load the rate to change the pitch by
002974 91b0 28f0                 	lds r27, triangle_fx_2xx_total+1
002976 0fae                      	add r26, ZL //increase the total offset by the rate
002977 1fbf                      	adc r27, ZH
002978 93a0 28ef                 	sts triangle_fx_2xx_total, r26
00297a 93b0 28f0                 	sts triangle_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_3xx_routine:
00297c 91e0 28f5                 	lds ZL, triangle_fx_3xx_speed
00297e 91f0 28f6                 	lds ZH, triangle_fx_3xx_speed+1
002980 9630                      	adiw Z, 0
002981 f409                      	brne sound_driver_channel2_fx_3xx_routine_check_start
002982 c048                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_check_start:
002983 91a0 28f1                 	lds r26, triangle_fx_3xx_start
002985 91b0 28f2                 	lds r27, triangle_fx_3xx_start+1
002987 9610                      	adiw r26:r27, 0
002988 f409                      	brne sound_driver_channel2_fx_3xx_routine_main
002989 c041                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_main:
00298a 91c0 28f3                 	lds r28, triangle_fx_3xx_target
00298c 91d0 28f4                 	lds r29, triangle_fx_3xx_target+1
                                 
00298e 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
00298f 07bd                      	cpc r27, r29
002990 f011                      	breq sound_driver_channel2_fx_3xx_routine_disable
002991 f030                      	brlo sound_driver_channel2_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002992 c01f                      	rjmp sound_driver_channel2_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel2_fx_3xx_routine_disable:
002993 9220 28f1                 	sts triangle_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002995 9220 28f2                 	sts triangle_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002997 c033                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_subtract:
002998 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002999 0bdb                      	sbc r29, r27
00299a 91a0 28f7                 	lds r26, triangle_fx_3xx_total_offset
00299c 91b0 28f8                 	lds r27, triangle_fx_3xx_total_offset+1
                                 
00299e 0fae                      	add r26, ZL //add the speed to the total offset
00299f 1fbf                      	adc r27, ZH
0029a0 1bca                      	sub r28, r26 //invert the total difference with the total offset
0029a1 0bdb                      	sbc r29, r27
0029a2 f380                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0029a3 93a0 28f7                 	sts triangle_fx_3xx_total_offset, r26 //store the new total offset
0029a5 93b0 28f8                 	sts triangle_fx_3xx_total_offset+1, r27
                                 
0029a7 91a0 0aac                 	lds r26, TCB2_CCMPL //load the current timer period
0029a9 91b0 0aad                 	lds r27, TCB2_CCMPH
0029ab 1bac                      	sub r26, r28 //offset the current timer period with the total offset
0029ac 0bbd                      	sbc r27, r29
0029ad 93a0 0aac                 	sts TCB2_CCMPL, r26
0029af 93b0 0aad                 	sts TCB2_CCMPH, r27
0029b1 c019                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_add:
0029b2 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
0029b3 0bbd                      	sbc r27, r29
0029b4 91c0 28f7                 	lds r28, triangle_fx_3xx_total_offset
0029b6 91d0 28f8                 	lds r29, triangle_fx_3xx_total_offset+1
                                 
0029b8 0fce                      	add r28, ZL //add the speed to the total offset
0029b9 1fdf                      	adc r29, ZH
0029ba 1bac                      	sub r26, r28 //invert the total difference with the total offset
0029bb 0bbd                      	sbc r27, r29
0029bc f2b0                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0029bd 93c0 28f7                 	sts triangle_fx_3xx_total_offset, r28 //store the new total offset
0029bf 93d0 28f8                 	sts triangle_fx_3xx_total_offset+1, r29
                                 
0029c1 91c0 0aac                 	lds r28, TCB2_CCMPL //load the current timer period
0029c3 91d0 0aad                 	lds r29, TCB2_CCMPH
0029c5 0fca                      	add r28, r26 //offset the current timer period with the total offset
0029c6 1fdb                      	adc r29, r27
0029c7 93c0 0aac                 	sts TCB2_CCMPL, r28
0029c9 93d0 0aad                 	sts TCB2_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel2_fx_4xy_routine:
0029cb 91a0 28f9                 	lds r26, triangle_fx_4xy_speed
0029cd 15a2                      	cp r26, zero
0029ce f409                      	brne sound_driver_channel2_fx_4xy_routine_continue
0029cf c05c                      	rjmp sound_driver_channel2_fx_Qxy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel2_fx_4xy_routine_continue:
0029d0 91b0 28fa                 	lds r27, triangle_fx_4xy_depth
0029d2 91c0 28fb                 	lds r28, triangle_fx_4xy_phase
0029d4 0fca                      	add r28, r26 //increase the phase by the speed
0029d5 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
0029d6 f008                      	brlo sound_driver_channel2_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
0029d7 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase:
0029d8 93c0 28fb                 	sts triangle_fx_4xy_phase, r28 //store the new phase
0029da 31c0                      	cpi r28, 16
0029db f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_0
0029dc 32c0                      	cpi r28, 32
0029dd f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_1
0029de 33c0                      	cpi r28, 48
0029df f030                      	brlo sound_driver_channel2_fx_4xy_routine_phase_2
0029e0 c007                      	rjmp sound_driver_channel2_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_0:
0029e1 70cf                      	andi r28, 0x0F //mask for values 0-15
0029e2 c029                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_1:
0029e3 6fc0                      	ori r28, 0xF0
0029e4 95c0                      	com r28 //invert values 0-15
0029e5 c026                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_2:
0029e6 70cf                      	andi r28, 0x0F //mask for values 0-15
0029e7 c003                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_3:
0029e8 6fc0                      	ori r28, 0xF0
0029e9 95c0                      	com r28 //invert values 0-15
0029ea c000                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_add:
0029eb 95b2                      	swap r27 //multiply depth by 16
0029ec 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0029ed e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0029ee e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0029ef 0fec                      	add ZL, r28 //offset the table by the depth+phase
0029f0 1df2                      	adc ZH, zero
0029f1 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
0029f2 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0029f3 937f                      	push r23
0029f4 2f6c                      	mov r22, r28 //store the vibrato value into r22
0029f5 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0029f6 9f67                      	mul r22, r23
0029f7 917f                      	pop r23
0029f8 916f                      	pop r22
                                 
0029f9 9416                      	lsr r1 //shift out the fractional bits
0029fa 9407                      	ror r0
0029fb 9416                      	lsr r1
0029fc 9407                      	ror r0
0029fd 9416                      	lsr r1
0029fe 9407                      	ror r0
0029ff 9416                      	lsr r1
002a00 9407                      	ror r0
                                 	
002a01 91a0 0aac                 	lds r26, TCB2_CCMPL
002a03 91b0 0aad                 	lds r27, TCB2_CCMPH
002a05 0da0                      	add r26, r0
002a06 1db1                      	adc r27, r1
002a07 93a0 0aac                 	sts TCB2_CCMPL, r26
002a09 93b0 0aad                 	sts TCB2_CCMPH, r27
002a0b c020                      	rjmp sound_driver_channel2_fx_Qxy_routine
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_subtract:
002a0c 95b2                      	swap r27 //multiply depth by 16
002a0d 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002a0e e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002a0f e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002a10 0fec                      	add ZL, r28 //offset the table by the depth+phase
002a11 1df2                      	adc ZH, zero
002a12 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002a13 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002a14 937f                      	push r23
002a15 2f6c                      	mov r22, r28 //store the vibrato value into r22
002a16 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002a17 9f67                      	mul r22, r23
002a18 917f                      	pop r23
002a19 916f                      	pop r22
                                 
002a1a 9416                      	lsr r1 //shift out the fractional bits
002a1b 9407                      	ror r0
002a1c 9416                      	lsr r1
002a1d 9407                      	ror r0
002a1e 9416                      	lsr r1
002a1f 9407                      	ror r0
002a20 9416                      	lsr r1
002a21 9407                      	ror r0
                                 
002a22 91a0 0aac                 	lds r26, TCB2_CCMPL
002a24 91b0 0aad                 	lds r27, TCB2_CCMPH
002a26 19a0                      	sub r26, r0
002a27 09b1                      	sbc r27, r1
002a28 93a0 0aac                 	sts TCB2_CCMPL, r26
002a2a 93b0 0aad                 	sts TCB2_CCMPH, r27
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel2_fx_Qxy_routine:
002a2c 91e0 2901                 	lds ZL, triangle_fx_Qxy_target
002a2e 91f0 2902                 	lds ZH, triangle_fx_Qxy_target+1
002a30 9630                      	adiw Z, 0
002a31 f119                      	breq sound_driver_channel2_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002a32 91a0 2905                 	lds r26, triangle_fx_Qxy_total_offset
002a34 91b0 2906                 	lds r27, triangle_fx_Qxy_total_offset+1
002a36 91c0 0aac                 	lds r28, TCB2_CCMPL
002a38 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
002a3a 1bec                      	sub ZL, r28 //calculate the difference to the target
002a3b 0bfd                      	sbc ZH, r29
002a3c f408                      	brsh sound_driver_channel2_fx_Qxy_routine_end //if the target has been reached (or passed)
002a3d f068                      	brlo sound_driver_channel2_fx_Qxy_routine_add
                                 
                                 sound_driver_channel2_fx_Qxy_routine_end:
002a3e 9220 2905                 	sts triangle_fx_Qxy_total_offset, zero //turn off the effect
002a40 9220 2906                 	sts triangle_fx_Qxy_total_offset+1, zero
002a42 9220 2901                 	sts triangle_fx_Qxy_target, zero
002a44 9220 2902                 	sts triangle_fx_Qxy_target+1, zero
002a46 91b0 2900                 	lds r27, triangle_fx_Qxy_target_note
002a48 93b0 2812                 	sts triangle_note, r27 //replace the note with the final target note
002a4a c00a                      	rjmp sound_driver_channel2_fx_Rxy_routine
                                 
                                 sound_driver_channel2_fx_Qxy_routine_add:
002a4b 91c0 2903                 	lds r28, triangle_fx_Qxy_speed
002a4d 91d0 2904                 	lds r29, triangle_fx_Qxy_speed+1
002a4f 0fac                      	add r26, r28 //increase the total offset by the speed
002a50 1fbd                      	adc r27, r29
002a51 93a0 2905                 	sts triangle_fx_Qxy_total_offset, r26 //store the total offset
002a53 93b0 2906                 	sts triangle_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_Rxy_routine:
002a55 91e0 2908                 	lds ZL, triangle_fx_Rxy_target
002a57 91f0 2909                 	lds ZH, triangle_fx_Rxy_target+1
002a59 9630                      	adiw Z, 0
002a5a f119                      	breq sound_driver_instrument_routine_channel3_volume //if the effect is not enabled, skip the routine
                                 
002a5b 91a0 290c                 	lds r26, triangle_fx_Rxy_total_offset
002a5d 91b0 290d                 	lds r27, triangle_fx_Rxy_total_offset+1
002a5f 91c0 0aac                 	lds r28, TCB2_CCMPL
002a61 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
002a63 1bce                      	sub r28, ZL //calculate the difference to the target
002a64 0bdf                      	sbc r29, ZH
002a65 f408                      	brsh sound_driver_channel2_fx_Rxy_routine_end //if the target has been reached (or passed)
002a66 f068                      	brlo sound_driver_channel2_fx_Rxy_routine_add
                                 
                                 sound_driver_channel2_fx_Rxy_routine_end:
002a67 9220 290c                 	sts triangle_fx_Rxy_total_offset, zero //disable the effect
002a69 9220 290d                 	sts triangle_fx_Rxy_total_offset+1, zero
002a6b 9220 2908                 	sts triangle_fx_Rxy_target, zero
002a6d 9220 2909                 	sts triangle_fx_Rxy_target+1, zero
002a6f 91b0 2907                 	lds r27, triangle_fx_Rxy_target_note
002a71 93b0 2812                 	sts triangle_note, r27 //replace the note with the final target note
002a73 c00a                      	rjmp sound_driver_instrument_routine_channel3_volume
                                 
                                 sound_driver_channel2_fx_Rxy_routine_add:
002a74 91c0 290a                 	lds r28, triangle_fx_Rxy_speed
002a76 91d0 290b                 	lds r29, triangle_fx_Rxy_speed+1
002a78 0fac                      	add r26, r28 //increase the total offset by the speed
002a79 1fbd                      	adc r27, r29
002a7a 93a0 290c                 	sts triangle_fx_Rxy_total_offset, r26 //store the total offset
002a7c 93b0 290d                 	sts triangle_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume:
002a7e 91e0 2916                 	lds ZL, noise_volume_macro
002a80 91f0 2917                 	lds ZH, noise_volume_macro+1
002a82 9630                      	adiw Z, 0
002a83 f1a1                      	breq sound_driver_instrument_routine_channel3_volume_default //if no volume macro is in use, use default multiplier of F
002a84 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002a85 1fff                      	rol ZH
002a86 91a0 2918                 	lds r26, noise_volume_macro_offset
002a88 0fea                      	add ZL, r26
002a89 1df2                      	adc ZH, zero
                                 
002a8a 91b0 291a                 	lds r27, noise_volume_macro_release
002a8c 17ba                      	cp r27, r26
002a8d f429                      	brne sound_driver_instrument_routine_channel3_volume_increment //if the current offset is not equal to the release index, increment the offset
002a8e 91a0 2919                 	lds r26, noise_volume_macro_loop
002a90 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002a91 f010                      	brlo sound_driver_instrument_routine_channel3_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002a92 c003                      	rjmp sound_driver_instrument_routine_channel3_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_volume_increment:
002a93 95a3                      	inc r26 //increment the macro offset
002a94 93a0 2918                 	sts noise_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_volume_read:
002a96 91b4                      	lpm r27, Z //load volume data into r27
002a97 3fbf                      	cpi r27, 0xFF //check for macro end flag
002a98 f469                      	brne sound_driver_instrument_routine_channel3_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_check_release:
002a99 91b0 291a                 	lds r27, noise_volume_macro_release
002a9b 3fbf                      	cpi r27, 0xFF
002a9c f429                      	brne sound_driver_instrument_routine_channel3_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_check_loop:
002a9d 91b0 2919                 	lds r27, noise_volume_macro_loop //load the loop index
002a9f 93b0 2918                 	sts noise_volume_macro_offset, r27 //store the loop index into the offset
002aa1 cfdc                      	rjmp sound_driver_instrument_routine_channel3_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_last_index:
002aa2 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002aa3 93a0 2918                 	sts noise_volume_macro_offset, r26
002aa5 cfd8                      	rjmp sound_driver_instrument_routine_channel3_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume_calculate:
002aa6 e8e4                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
002aa7 e5fc                      	ldi ZH, HIGH(volumes << 1)
002aa8 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
002aa9 0feb                      	add ZL, r27 //add offset to the table
002aaa 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel3_volume_load:
002aab 91b0 2813                 	lds r27, noise_param //load main volume
002aad 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002aae 91a0 294b                 	lds r26, noise_fx_7xy_value
002ab0 30a0                      	cpi r26, 0x00
002ab1 f481                      	brne sound_driver_instrument_routine_channel3_volume_load_7xy
                                 
002ab2 0feb                      	add ZL, r27 //offset the volume table by the main volume
002ab3 1df2                      	adc ZH, zero
002ab4 91b4                      	lpm r27, Z
002ab5 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002ab7 c023                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_default:
002ab8 91b0 2813                 	lds r27, noise_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
002aba 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002abb 91a0 294b                 	lds r26, noise_fx_7xy_value
002abd 30a0                      	cpi r26, 0x00
002abe f499                      	brne sound_driver_instrument_routine_channel3_volume_default_7xy
002abf 93b0 2816                 	sts noise_output_volume, r27
002ac1 c019                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_load_7xy:
002ac2 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002ac3 f038                      	brcs sound_driver_instrument_routine_channel3_volume_load_7xy_overflow
002ac4 f031                      	breq sound_driver_instrument_routine_channel3_volume_load_7xy_overflow
                                 
002ac5 0feb                      	add ZL, r27 //offset the volume table by the main volume
002ac6 1df2                      	adc ZH, zero
002ac7 91b4                      	lpm r27, Z
002ac8 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002aca c010                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_load_7xy_overflow:
002acb e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002acc 0feb                      	add ZL, r27 //offset the volume table by the main volume
002acd 1df2                      	adc ZH, zero
002ace 91b4                      	lpm r27, Z
002acf 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002ad1 c009                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_default_7xy:
002ad2 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002ad3 f020                      	brcs sound_driver_instrument_routine_channel3_volume_default_7xy_overflow
002ad4 f019                      	breq sound_driver_instrument_routine_channel3_volume_default_7xy_overflow
002ad5 93b0 2816                 	sts noise_output_volume, r27
002ad7 c003                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel3_volume_default_7xy_overflow:
002ad8 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002ad9 93b0 2816                 	sts noise_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002adb 91e0 291b                 	lds ZL, noise_arpeggio_macro
002add 91f0 291c                 	lds ZH, noise_arpeggio_macro+1
002adf 9630                      	adiw Z, 0
002ae0 f1d9                      	breq sound_driver_instrument_routine_channel3_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002ae1 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002ae2 1fff                      	rol ZH
002ae3 91a0 291d                 	lds r26, noise_arpeggio_macro_offset
002ae5 0fea                      	add ZL, r26
002ae6 1df2                      	adc ZH, zero
                                 
002ae7 91b0 291f                 	lds r27, noise_arpeggio_macro_release
002ae9 17ba                      	cp r27, r26
002aea f429                      	brne sound_driver_instrument_routine_channel3_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002aeb 91a0 291e                 	lds r26, noise_arpeggio_macro_loop
002aed 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002aee f010                      	brlo sound_driver_instrument_routine_channel3_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002aef c003                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_increment:
002af0 95a3                      	inc r26 //increment the macro offset
002af1 93a0 291d                 	sts noise_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_arpeggio_read:
002af3 91b4                      	lpm r27, Z //load arpeggio data into r27
002af4 38b0                      	cpi r27, 0x80 //check for macro end flag
002af5 f009                      	breq sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag
002af6 c041                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_check_mode:
002af7 50a1                      	subi r26, 1 //keep the offset at the end flag
002af8 93a0 291d                 	sts noise_arpeggio_macro_offset, r26
002afa 91b0 2920                 	lds r27, noise_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002afc 30b1                      	cpi r27, 0x01
002afd f048                      	brlo sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_fixed_relative_check_release:
002afe 91b0 291f                 	lds r27, noise_arpeggio_macro_release
002b00 3fbf                      	cpi r27, 0xFF
002b01 f4d1                      	brne sound_driver_instrument_routine_channel3_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_fixed_relative_check_loop:
002b02 91b0 291e                 	lds r27, noise_arpeggio_macro_loop
002b04 3fbf                      	cpi r27, 0xFF
002b05 f499                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002b06 c015                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute:
002b07 91b0 291f                 	lds r27, noise_arpeggio_macro_release
002b09 3fbf                      	cpi r27, 0xFF
002b0a f421                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_check_loop:
002b0b 91b0 291e                 	lds r27, noise_arpeggio_macro_loop //load the loop index
002b0d 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002b0e f451                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_no_loop:
002b0f 91c0 2933                 	lds r28, noise_fx_0xy_sequence //check for 0xy effect
002b11 91d0 2934                 	lds r29, noise_fx_0xy_sequence+1
002b13 9620                      	adiw r29:r28, 0
002b14 f469                      	brne sound_driver_instrument_routine_channel3_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002b15 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002b16 93a0 291d                 	sts noise_arpeggio_macro_offset, r26 //store the last valid index into the offset
002b18 cfc2                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload:
002b19 93b0 291d                 	sts noise_arpeggio_macro_offset, r27 //store the loop index into the offset
002b1b cfbf                      	rjmp sound_driver_instrument_routine_channel3_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_default:
002b1c 91c0 2933                 	lds r28, noise_fx_0xy_sequence //load 0xy effect
002b1e 91d0 2934                 	lds r29, noise_fx_0xy_sequence+1
002b20 9620                      	adiw r29:r28, 0 //check for 0xy effect
002b21 f099                      	breq sound_driver_instrument_routine_channel3_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel3_arpeggio_default_xy:
002b22 95d6                      	lsr r29
002b23 95c7                      	ror r28
002b24 95d7                      	ror r29
002b25 95c7                      	ror r28
002b26 95d7                      	ror r29
002b27 95c7                      	ror r28
002b28 95d7                      	ror r29
002b29 95c7                      	ror r28
002b2a 95d7                      	ror r29
002b2b 95d2                      	swap r29
                                 
002b2c 93c0 2933                 	sts noise_fx_0xy_sequence, r28 //store the rolled sequence
002b2e 93d0 2934                 	sts noise_fx_0xy_sequence+1, r29
002b30 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002b31 91a0 2817                 	lds r26, noise_note //load the current note index
002b33 0fac                      	add r26, r28 //add the note offset
002b34 c02e                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel3_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002b35 91a0 2817                 	lds r26, noise_note //load the current note index
002b37 c02b                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process:
002b38 9220 2921                 	sts noise_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002b3a 9220 2922                 	sts noise_total_pitch_offset+1, zero
002b3c 9220 2928                 	sts noise_total_hi_pitch_offset, zero
002b3e 91a0 2920                 	lds r26, noise_arpeggio_macro_mode
002b40 30a1                      	cpi r26, 0x01 //absolute mode
002b41 f010                      	brlo sound_driver_instrument_routine_channel3_arpeggio_process_absolute
002b42 f069                      	breq sound_driver_instrument_routine_channel3_arpeggio_process_fixed
002b43 c00e                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_absolute:
002b44 91a0 2817                 	lds r26, noise_note //load the current note index
002b46 0fab                      	add r26, r27 //offset the note with the arpeggio data
002b47 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002b48 c004                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_absolute_add:
002b49 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002b4a f0c0                      	brlo sound_driver_instrument_routine_channel3_arpeggio_process_load //if the result is valid, go load the new note
002b4b e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002b4c c016                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_absolute_subtract:
002b4d fda7                      	sbrc r26, 7 //check if result is negative
002b4e e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002b4f c013                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_fixed:
002b50 2fab                      	mov r26, r27 //move the arpeggio data into r26
002b51 c011                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_relative:
002b52 91a0 2817                 	lds r26, noise_note //load the current note index
002b54 0fab                      	add r26, r27 //offset the note with the arpeggio data
002b55 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002b56 c008                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_relative_add:
002b57 93a0 2817                 	sts noise_note, r26 //NOTE: relative mode modifies the original note index
002b59 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002b5a f040                      	brlo sound_driver_instrument_routine_channel3_arpeggio_process_load //if the result is valid, go load the new note
002b5b e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002b5c 93a0 2817                 	sts noise_note, r26
002b5e c004                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_relative_subtract:
002b5f fda7                      	sbrc r26, 7 //check if result is negative
002b60 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002b61 93a0 2817                 	sts noise_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_load:
002b63 e4e2                      	ldi ZL, LOW(noise_period_table << 1) //load in note table
002b64 e0f1                      	ldi ZH, HIGH(noise_period_table << 1)
002b65 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002b66 0fea                      	add ZL, r26 //add offset
002b67 1df2                      	adc ZH, zero
002b68 91a5                      	lpm r26, Z+ //load bytes
002b69 91b4                      	lpm r27, Z
002b6a 93a0 0abc                 	sts TCB3_CCMPL, r26 //load the LOW bits for timer
002b6c 93b0 0abd                 	sts TCB3_CCMPH, r27 //load the HIGH bits for timer
002b6e 93a0 293f                 	sts noise_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002b70 93b0 2940                 	sts noise_fx_3xx_target+1, r27
002b72 c000                      	rjmp sound_driver_instrument_routine_channel3_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch:
002b73 91e0 2923                 	lds ZL, noise_pitch_macro
002b75 91f0 2924                 	lds ZH, noise_pitch_macro+1
002b77 9630                      	adiw Z, 0
002b78 f409                      	brne sound_driver_instrument_routine_channel3_pitch_continue
002b79 c023                      	rjmp sound_driver_instrument_routine_channel3_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel3_pitch_continue:
002b7a 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002b7b 1fff                      	rol ZH
002b7c 91a0 2925                 	lds r26, noise_pitch_macro_offset
002b7e 0fea                      	add ZL, r26
002b7f 1df2                      	adc ZH, zero
                                 
002b80 91b0 2927                 	lds r27, noise_pitch_macro_release
002b82 17ba                      	cp r27, r26
002b83 f429                      	brne sound_driver_instrument_routine_channel3_pitch_increment //if the current offset is not equal to the release index, increment the offset
002b84 91a0 2926                 	lds r26, noise_pitch_macro_loop
002b86 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002b87 f010                      	brlo sound_driver_instrument_routine_channel3_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002b88 c003                      	rjmp sound_driver_instrument_routine_channel3_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_pitch_increment:
002b89 95a3                      	inc r26 //increment the macro offset
002b8a 93a0 2925                 	sts noise_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_pitch_read:
002b8c 91b4                      	lpm r27, Z //load pitch data into r27
002b8d 38b0                      	cpi r27, 0x80 //check for macro end flag
002b8e f479                      	brne sound_driver_instrument_routine_channel3_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag_check_release:
002b8f 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002b90 93a0 2925                 	sts noise_pitch_macro_offset, r26
002b92 91b0 2927                 	lds r27, noise_pitch_macro_release
002b94 3fbf                      	cpi r27, 0xFF
002b95 f439                      	brne sound_driver_instrument_routine_channel3_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag_check_loop:
002b96 91b0 2926                 	lds r27, noise_pitch_macro_loop //load the loop index
002b98 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002b99 f019                      	breq sound_driver_instrument_routine_channel3_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002b9a 93b0 2925                 	sts noise_pitch_macro_offset, r27 //store the loop index into the offset
002b9c cfd6                      	rjmp sound_driver_instrument_routine_channel3_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch_default:
002b9d e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel3_pitch_calculate:
002b9e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002b9f 937f                      	push r23
002ba0 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
002ba1 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002ba2 0367                      	mulsu r22, r23
002ba3 917f                      	pop r23
002ba4 916f                      	pop r22
                                 
002ba5 9416                      	lsr r1 //shift out the fractional bits
002ba6 9407                      	ror r0
002ba7 9416                      	lsr r1
002ba8 9407                      	ror r0
002ba9 9416                      	lsr r1
002baa 9407                      	ror r0
002bab 9416                      	lsr r1
002bac 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel3_pitch_calculate_check_negative:
002bad fe13                      	sbrs r1, 3 //check if result was a negative number
002bae c007                      	rjmp sound_driver_instrument_routine_channel3_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel3_pitch_calculate_negative:
002baf efc0                      	ldi r28, 0xF0
002bb0 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel3_pitch_calculate_check_divisible_8:
002bb1 70b7                      	andi r27, 0b00000111
002bb2 f019                      	breq sound_driver_instrument_routine_channel3_pitch_calculate_offset
                                 
002bb3 e0b1                      	ldi r27, 0x01
002bb4 0e0b                      	add r0, r27
002bb5 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel3_pitch_calculate_offset:
002bb6 91a0 2921                 	lds r26, noise_total_pitch_offset
002bb8 91b0 2922                 	lds r27, noise_total_pitch_offset+1
002bba 0e0a                      	add r0, r26
002bbb 1e1b                      	adc r1, r27
002bbc 9200 2921                 	sts noise_total_pitch_offset, r0
002bbe 9210 2922                 	sts noise_total_pitch_offset+1, r1
002bc0 91a0 0abc                 	lds r26, TCB3_CCMPL //load the low bits for timer
002bc2 91b0 0abd                 	lds r27, TCB3_CCMPH //load the high bits for timer
002bc4 0da0                      	add r26, r0 //offset the timer values
002bc5 1db1                      	adc r27, r1
                                 	
002bc6 91c0 2937                 	lds r28, noise_fx_1xx_total
002bc8 91d0 2938                 	lds r29, noise_fx_1xx_total+1
002bca 1bac                      	sub r26, r28
002bcb 0bbd                      	sbc r27, r29
002bcc 91c0 293b                 	lds r28, noise_fx_2xx_total
002bce 91d0 293c                 	lds r29, noise_fx_2xx_total+1
002bd0 0fac                      	add r26, r28
002bd1 1fbd                      	adc r27, r29
002bd2 91c0 294f                 	lds r28, noise_fx_Pxx_total
002bd4 91d0 2950                 	lds r29, noise_fx_Pxx_total+1
002bd6 0fac                      	add r26, r28
002bd7 1fbd                      	adc r27, r29
002bd8 91c0 2956                 	lds r28, noise_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
002bda 91d0 2957                 	lds r29, noise_fx_Qxy_total_offset+1
002bdc 1bac                      	sub r26, r28
002bdd 0bbd                      	sbc r27, r29
002bde 91c0 295d                 	lds r28, noise_fx_Rxy_total_offset
002be0 91d0 295e                 	lds r29, noise_fx_Rxy_total_offset+1
002be2 0fac                      	add r26, r28
002be3 1fbd                      	adc r27, r29
                                 
002be4 93a0 0abc                 	sts TCB3_CCMPL, r26 //store the new low bits for timer
002be6 93b0 0abd                 	sts TCB3_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel3_hi_pitch:
002be8 91e0 2929                 	lds ZL, noise_hi_pitch_macro
002bea 91f0 292a                 	lds ZH, noise_hi_pitch_macro+1
002bec 9630                      	adiw Z, 0
002bed f409                      	brne sound_driver_instrument_routine_channel3_hi_pitch_continue
002bee c03c                      	rjmp sound_driver_instrument_routine_channel3_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel3_hi_pitch_continue:
002bef 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002bf0 1fff                      	rol ZH
002bf1 91a0 292b                 	lds r26, noise_hi_pitch_macro_offset
002bf3 0fea                      	add ZL, r26
002bf4 1df2                      	adc ZH, zero
                                 
002bf5 91b0 292d                 	lds r27, noise_hi_pitch_macro_release
002bf7 17ba                      	cp r27, r26
002bf8 f429                      	brne sound_driver_instrument_routine_channel3_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002bf9 91a0 292c                 	lds r26, noise_hi_pitch_macro_loop
002bfb 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002bfc f010                      	brlo sound_driver_instrument_routine_channel3_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002bfd c003                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_increment:
002bfe 95a3                      	inc r26 //increment the macro offset
002bff 93a0 292b                 	sts noise_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_hi_pitch_read:
002c01 91b4                      	lpm r27, Z //load hi pitch data into r27
002c02 38b0                      	cpi r27, 0x80 //check for macro end flag
002c03 f489                      	brne sound_driver_instrument_routine_channel3_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag_check_release:
002c04 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002c05 93a0 292b                 	sts noise_hi_pitch_macro_offset, r26
002c07 91b0 292d                 	lds r27, noise_hi_pitch_macro_release
002c09 3fbf                      	cpi r27, 0xFF
002c0a f439                      	brne sound_driver_instrument_routine_channel3_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag_check_loop:
002c0b 91b0 292c                 	lds r27, noise_hi_pitch_macro_loop //load the loop index
002c0d 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002c0e f019                      	breq sound_driver_instrument_routine_channel3_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002c0f 93b0 292b                 	sts noise_hi_pitch_macro_offset, r27 //store the loop index into the offset
002c11 cfd6                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_default:
002c12 91b0 2928                 	lds r27, noise_total_hi_pitch_offset
002c14 c005                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate:
002c15 91a0 2928                 	lds r26, noise_total_hi_pitch_offset //load the total hi pitch offset to change
002c17 0fba                      	add r27, r26
002c18 93b0 2928                 	sts noise_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate_multiply:
002c1a 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002c1b 937f                      	push r23
002c1c 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002c1d eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002c1e 0367                      	mulsu r22, r23
002c1f 917f                      	pop r23
002c20 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate_offset:
002c21 91a0 0abc                 	lds r26, TCB3_CCMPL //load the low bits for timer
002c23 91b0 0abd                 	lds r27, TCB3_CCMPH //load the high bits for timer
002c25 0da0                      	add r26, r0 //offset the timer values
002c26 1db1                      	adc r27, r1
002c27 93a0 0abc                 	sts TCB3_CCMPL, r26 //store the new low bits for timer
002c29 93b0 0abd                 	sts TCB3_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty:
002c2b 91e0 292e                 	lds ZL, noise_duty_macro
002c2d 91f0 292f                 	lds ZH, noise_duty_macro+1
002c2f 9630                      	adiw Z, 0
002c30 f169                      	breq sound_driver_channel3_fx_routines //if no duty macro is in use, go to the next routine
002c31 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002c32 1fff                      	rol ZH
002c33 91a0 2930                 	lds r26, noise_duty_macro_offset
002c35 0fea                      	add ZL, r26
002c36 1df2                      	adc ZH, zero
                                 
002c37 91b0 2932                 	lds r27, noise_duty_macro_release
002c39 17ba                      	cp r27, r26
002c3a f429                      	brne sound_driver_instrument_routine_channel3_duty_increment //if the current offset is not equal to the release index, increment the offset
002c3b 91a0 2931                 	lds r26, noise_duty_macro_loop
002c3d 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002c3e f010                      	brlo sound_driver_instrument_routine_channel3_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002c3f c01e                      	rjmp sound_driver_channel3_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel3_duty_increment:
002c40 95a3                      	inc r26 //increment the macro offset
002c41 93a0 2930                 	sts noise_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_duty_read:
002c43 91b4                      	lpm r27, Z //load pitch data into r27
002c44 3fbf                      	cpi r27, 0xFF //check for macro end flag
002c45 f471                      	brne sound_driver_instrument_routine_channel3_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag_check_release:
002c46 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002c47 93a0 2930                 	sts noise_duty_macro_offset, r26
002c49 91b0 2932                 	lds r27, noise_duty_macro_release
002c4b 3fbf                      	cpi r27, 0xFF
002c4c f489                      	brne sound_driver_channel3_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag_check_loop:
002c4d 91b0 2931                 	lds r27, noise_duty_macro_loop //load the loop index
002c4f 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002c50 f069                      	breq sound_driver_channel3_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
002c51 93b0 2930                 	sts noise_duty_macro_offset, r27 //store the loop index into the offset
002c53 cfd7                      	rjmp sound_driver_instrument_routine_channel3_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty_load:
002c54 95b6                      	lsr r27
002c55 95b7                      	ror r27 //move mode bit to bit 7
002c56 91c0 2814                 	lds r28, noise_period
002c58 77cf                      	andi r28, 0b01111111
002c59 2bcb                      	or r28, r27 //store the new noise mode
002c5a 93c0 2813                 	sts noise_param, r28
                                 
002c5c 776f                      	andi noise_sequence_HIGH, 0b01111111
002c5d 2b6b                      	or noise_sequence_HIGH, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_routines:
                                 sound_driver_channel3_fx_1xx_routine:
002c5e 91e0 2935                 	lds ZL, noise_fx_1xx
002c60 91f0 2936                 	lds ZH, noise_fx_1xx+1
002c62 9630                      	adiw Z, 0
002c63 f051                      	breq sound_driver_channel3_fx_2xx_routine
                                 
002c64 91a0 2937                 	lds r26, noise_fx_1xx_total //load the rate to change the pitch by
002c66 91b0 2938                 	lds r27, noise_fx_1xx_total+1
002c68 0fae                      	add r26, ZL //increase the total offset by the rate
002c69 1fbf                      	adc r27, ZH
002c6a 93a0 2937                 	sts noise_fx_1xx_total, r26
002c6c 93b0 2938                 	sts noise_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_2xx_routine:
002c6e 91e0 2939                 	lds ZL, noise_fx_2xx
002c70 91f0 293a                 	lds ZH, noise_fx_2xx+1
002c72 9630                      	adiw Z, 0
002c73 f051                      	breq sound_driver_channel3_fx_3xx_routine
                                 
002c74 91a0 293b                 	lds r26, noise_fx_2xx_total //load the rate to change the pitch by
002c76 91b0 293c                 	lds r27, noise_fx_2xx_total+1
002c78 0fae                      	add r26, ZL //increase the total offset by the rate
002c79 1fbf                      	adc r27, ZH
002c7a 93a0 293b                 	sts noise_fx_2xx_total, r26
002c7c 93b0 293c                 	sts noise_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_3xx_routine:
002c7e 91e0 2941                 	lds ZL, noise_fx_3xx_speed
002c80 91f0 2942                 	lds ZH, noise_fx_3xx_speed+1
002c82 9630                      	adiw Z, 0
002c83 f409                      	brne sound_driver_channel3_fx_3xx_routine_check_start
002c84 c048                      	rjmp sound_driver_channel3_fx_4xy_routine
                                 
                                 sound_driver_channel3_fx_3xx_routine_check_start:
002c85 91a0 293d                 	lds r26, noise_fx_3xx_start
002c87 91b0 293e                 	lds r27, noise_fx_3xx_start+1
002c89 9610                      	adiw r26:r27, 0
002c8a f409                      	brne sound_driver_channel3_fx_3xx_routine_main
002c8b c041                      	rjmp sound_driver_channel3_fx_4xy_routine
                                 
                                 sound_driver_channel3_fx_3xx_routine_main:
002c8c 91c0 293f                 	lds r28, noise_fx_3xx_target
002c8e 91d0 2940                 	lds r29, noise_fx_3xx_target+1
                                 
002c90 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
002c91 07bd                      	cpc r27, r29
002c92 f011                      	breq sound_driver_channel3_fx_3xx_routine_disable
002c93 f030                      	brlo sound_driver_channel3_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002c94 c01f                      	rjmp sound_driver_channel3_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel3_fx_3xx_routine_disable:
002c95 9220 293d                 	sts noise_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002c97 9220 293e                 	sts noise_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002c99 c033                      	rjmp sound_driver_channel3_fx_4xy_routine
                                 
                                 sound_driver_channel3_fx_3xx_routine_subtract:
002c9a 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002c9b 0bdb                      	sbc r29, r27
002c9c 91a0 2943                 	lds r26, noise_fx_3xx_total_offset
002c9e 91b0 2944                 	lds r27, noise_fx_3xx_total_offset+1
                                 
002ca0 0fae                      	add r26, ZL //add the speed to the total offset
002ca1 1fbf                      	adc r27, ZH
002ca2 1bca                      	sub r28, r26 //invert the total difference with the total offset
002ca3 0bdb                      	sbc r29, r27
002ca4 f380                      	brlo sound_driver_channel3_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002ca5 93a0 2943                 	sts noise_fx_3xx_total_offset, r26 //store the new total offset
002ca7 93b0 2944                 	sts noise_fx_3xx_total_offset+1, r27
                                 
002ca9 91a0 0abc                 	lds r26, TCB3_CCMPL //load the current timer period
002cab 91b0 0abd                 	lds r27, TCB3_CCMPH
002cad 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002cae 0bbd                      	sbc r27, r29
002caf 93a0 0abc                 	sts TCB3_CCMPL, r26
002cb1 93b0 0abd                 	sts TCB3_CCMPH, r27
002cb3 c019                      	rjmp sound_driver_channel3_fx_4xy_routine
                                 
                                 sound_driver_channel3_fx_3xx_routine_add:
002cb4 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002cb5 0bbd                      	sbc r27, r29
002cb6 91c0 2943                 	lds r28, noise_fx_3xx_total_offset
002cb8 91d0 2944                 	lds r29, noise_fx_3xx_total_offset+1
                                 
002cba 0fce                      	add r28, ZL //add the speed to the total offset
002cbb 1fdf                      	adc r29, ZH
002cbc 1bac                      	sub r26, r28 //invert the total difference with the total offset
002cbd 0bbd                      	sbc r27, r29
002cbe f2b0                      	brlo sound_driver_channel3_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002cbf 93c0 2943                 	sts noise_fx_3xx_total_offset, r28 //store the new total offset
002cc1 93d0 2944                 	sts noise_fx_3xx_total_offset+1, r29
                                 
002cc3 91c0 0abc                 	lds r28, TCB3_CCMPL //load the current timer period
002cc5 91d0 0abd                 	lds r29, TCB3_CCMPH
002cc7 0fca                      	add r28, r26 //offset the current timer period with the total offset
002cc8 1fdb                      	adc r29, r27
002cc9 93c0 0abc                 	sts TCB3_CCMPL, r28
002ccb 93d0 0abd                 	sts TCB3_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel3_fx_4xy_routine:
002ccd 91a0 2945                 	lds r26, noise_fx_4xy_speed
002ccf 15a2                      	cp r26, zero
002cd0 f409                      	brne sound_driver_channel3_fx_4xy_routine_continue
002cd1 c05c                      	rjmp sound_driver_channel3_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel3_fx_4xy_routine_continue:
002cd2 91b0 2946                 	lds r27, noise_fx_4xy_depth
002cd4 91c0 2947                 	lds r28, noise_fx_4xy_phase
002cd6 0fca                      	add r28, r26 //increase the phase by the speed
002cd7 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002cd8 f008                      	brlo sound_driver_channel3_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002cd9 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase:
002cda 93c0 2947                 	sts noise_fx_4xy_phase, r28 //store the new phase
002cdc 31c0                      	cpi r28, 16
002cdd f028                      	brlo sound_driver_channel3_fx_4xy_routine_phase_0
002cde 32c0                      	cpi r28, 32
002cdf f028                      	brlo sound_driver_channel3_fx_4xy_routine_phase_1
002ce0 33c0                      	cpi r28, 48
002ce1 f030                      	brlo sound_driver_channel3_fx_4xy_routine_phase_2
002ce2 c007                      	rjmp sound_driver_channel3_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_0:
002ce3 70cf                      	andi r28, 0x0F //mask for values 0-15
002ce4 c029                      	rjmp sound_driver_channel3_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_1:
002ce5 6fc0                      	ori r28, 0xF0
002ce6 95c0                      	com r28 //invert values 0-15
002ce7 c026                      	rjmp sound_driver_channel3_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_2:
002ce8 70cf                      	andi r28, 0x0F //mask for values 0-15
002ce9 c003                      	rjmp sound_driver_channel3_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_3:
002cea 6fc0                      	ori r28, 0xF0
002ceb 95c0                      	com r28 //invert values 0-15
002cec c000                      	rjmp sound_driver_channel3_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel3_fx_4xy_routine_load_add:
002ced 95b2                      	swap r27 //multiply depth by 16
002cee 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002cef e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002cf0 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002cf1 0fec                      	add ZL, r28 //offset the table by the depth+phase
002cf2 1df2                      	adc ZH, zero
002cf3 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002cf4 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002cf5 937f                      	push r23
002cf6 2f6c                      	mov r22, r28 //store the vibrato value into r22
002cf7 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002cf8 9f67                      	mul r22, r23
002cf9 917f                      	pop r23
002cfa 916f                      	pop r22
                                 
002cfb 9416                      	lsr r1 //shift out the fractional bits
002cfc 9407                      	ror r0
002cfd 9416                      	lsr r1
002cfe 9407                      	ror r0
002cff 9416                      	lsr r1
002d00 9407                      	ror r0
002d01 9416                      	lsr r1
002d02 9407                      	ror r0
                                 	
002d03 91a0 0abc                 	lds r26, TCB3_CCMPL
002d05 91b0 0abd                 	lds r27, TCB3_CCMPH
002d07 0da0                      	add r26, r0
002d08 1db1                      	adc r27, r1
002d09 93a0 0abc                 	sts TCB3_CCMPL, r26
002d0b 93b0 0abd                 	sts TCB3_CCMPH, r27
002d0d c020                      	rjmp sound_driver_channel3_fx_7xy_routine
                                 
                                 sound_driver_channel3_fx_4xy_routine_load_subtract:
002d0e 95b2                      	swap r27 //multiply depth by 16
002d0f 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002d10 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002d11 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002d12 0fec                      	add ZL, r28 //offset the table by the depth+phase
002d13 1df2                      	adc ZH, zero
002d14 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002d15 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002d16 937f                      	push r23
002d17 2f6c                      	mov r22, r28 //store the vibrato value into r22
002d18 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002d19 9f67                      	mul r22, r23
002d1a 917f                      	pop r23
002d1b 916f                      	pop r22
                                 
002d1c 9416                      	lsr r1 //shift out the fractional bits
002d1d 9407                      	ror r0
002d1e 9416                      	lsr r1
002d1f 9407                      	ror r0
002d20 9416                      	lsr r1
002d21 9407                      	ror r0
002d22 9416                      	lsr r1
002d23 9407                      	ror r0
                                 
002d24 91a0 0abc                 	lds r26, TCB3_CCMPL
002d26 91b0 0abd                 	lds r27, TCB3_CCMPH
002d28 19a0                      	sub r26, r0
002d29 09b1                      	sbc r27, r1
002d2a 93a0 0abc                 	sts TCB3_CCMPL, r26
002d2c 93b0 0abd                 	sts TCB3_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_7xy_routine:
002d2e 91a0 2948                 	lds r26, noise_fx_7xy_speed
002d30 15a2                      	cp r26, zero
002d31 f0e9                      	breq sound_driver_channel3_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
002d32 91b0 2949                 	lds r27, noise_fx_7xy_depth
002d34 91c0 294a                 	lds r28, noise_fx_7xy_phase
002d36 0fca                      	add r28, r26 //increase the phase by the speed
002d37 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002d38 f008                      	brlo sound_driver_channel3_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
002d39 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel3_fx_7xy_routine_phase:
002d3a 93c0 294a                 	sts noise_fx_7xy_phase, r28 //store the new phase
002d3c 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
002d3d ffc4                      	sbrs r28, 4
002d3e c001                      	rjmp sound_driver_channel3_fx_7xy_routine_phase_0
002d3f c002                      	rjmp sound_driver_channel3_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel3_fx_7xy_routine_phase_0:
002d40 70cf                      	andi r28, 0x0F //mask for values 0-15
002d41 c003                      	rjmp sound_driver_channel3_fx_7xy_routine_load
                                 
                                 sound_driver_channel3_fx_7xy_routine_phase_1:
002d42 6fc0                      	ori r28, 0xF0
002d43 95c0                      	com r28 //invert values 0-15
002d44 c000                      	rjmp sound_driver_channel3_fx_7xy_routine_load
                                 
                                 sound_driver_channel3_fx_7xy_routine_load:
002d45 95b2                      	swap r27 //multiply depth by 16
002d46 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002d47 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002d48 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002d49 0fec                      	add ZL, r28 //offset the table by the depth+phase
002d4a 1df2                      	adc ZH, zero
002d4b 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002d4c 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
002d4d 93c0 294b                 	sts noise_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Axy_routine:
002d4f 91b0 294c                 	lds r27, noise_fx_Axy
002d51 15b2                      	cp r27, zero
002d52 f0e9                      	breq sound_driver_channel3_fx_Qxy_routine //0 means that the effect is not in use
                                 	
002d53 91a0 2815                 	lds r26, noise_fractional_volume //load fractional volume representation of the channel
002d55 91c0 2813                 	lds r28, noise_param //load the integer volume representation of the channel
002d57 2fda                      	mov r29, r26 //copy fractional volume into r29
002d58 2fec                      	mov r30, r28 //copy the noise_param into r30
002d59 95e2                      	swap r30
002d5a 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
002d5b 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
002d5c 17ed                      	cp r30, r29 //compare the fractional and integer volumes
002d5d f009                      	breq sound_driver_channel3_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel3_fx_Axy_routine_reload:
002d5e 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate:
002d5f fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
002d60 c004                      	rjmp sound_driver_channel3_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_addition:
002d61 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002d62 f428                      	brcc sound_driver_channel3_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002d63 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
002d64 c003                      	rjmp sound_driver_channel3_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_subtraction:
002d65 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002d66 f008                      	brcs sound_driver_channel3_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002d67 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_store:
002d68 93a0 2815                 	sts noise_fractional_volume, r26 //store the new fractional volume
002d6a 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
002d6b 95a2                      	swap r26
002d6c 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
002d6d 2bca                      	or r28, r26 //store the new volume back into noise_param
002d6e 93c0 2813                 	sts noise_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel3_fx_Qxy_routine:
002d70 91e0 2952                 	lds ZL, noise_fx_Qxy_target
002d72 91f0 2953                 	lds ZH, noise_fx_Qxy_target+1
002d74 9630                      	adiw Z, 0
002d75 f119                      	breq sound_driver_channel3_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002d76 91a0 2956                 	lds r26, noise_fx_Qxy_total_offset
002d78 91b0 2957                 	lds r27, noise_fx_Qxy_total_offset+1
002d7a 91c0 0abc                 	lds r28, TCB3_CCMPL
002d7c 91d0 0abd                 	lds r29, TCB3_CCMPH
                                 
002d7e 1bec                      	sub ZL, r28 //calculate the difference to the target
002d7f 0bfd                      	sbc ZH, r29
002d80 f408                      	brsh sound_driver_channel3_fx_Qxy_routine_end //if the target has been reached (or passed)
002d81 f068                      	brlo sound_driver_channel3_fx_Qxy_routine_add
                                 
                                 sound_driver_channel3_fx_Qxy_routine_end:
002d82 9220 2956                 	sts noise_fx_Qxy_total_offset, zero //turn off the effect
002d84 9220 2957                 	sts noise_fx_Qxy_total_offset+1, zero
002d86 9220 2952                 	sts noise_fx_Qxy_target, zero
002d88 9220 2953                 	sts noise_fx_Qxy_target+1, zero
002d8a 91b0 2951                 	lds r27, noise_fx_Qxy_target_note
002d8c 93b0 2817                 	sts noise_note, r27 //replace the note with the final target note
002d8e c00a                      	rjmp sound_driver_channel3_fx_Rxy_routine
                                 
                                 sound_driver_channel3_fx_Qxy_routine_add:
002d8f 91c0 2954                 	lds r28, noise_fx_Qxy_speed
002d91 91d0 2955                 	lds r29, noise_fx_Qxy_speed+1
002d93 0fac                      	add r26, r28 //increase the total offset by the speed
002d94 1fbd                      	adc r27, r29
002d95 93a0 2956                 	sts noise_fx_Qxy_total_offset, r26 //store the total offset
002d97 93b0 2957                 	sts noise_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Rxy_routine:
002d99 91e0 2959                 	lds ZL, noise_fx_Rxy_target
002d9b 91f0 295a                 	lds ZH, noise_fx_Rxy_target+1
002d9d 9630                      	adiw Z, 0
002d9e f119                      	breq sound_driver_instrument_routine_channel4_volume //if the effect is not enabled, skip the routine
                                 
002d9f 91a0 295d                 	lds r26, noise_fx_Rxy_total_offset
002da1 91b0 295e                 	lds r27, noise_fx_Rxy_total_offset+1
002da3 91c0 0abc                 	lds r28, TCB3_CCMPL
002da5 91d0 0abd                 	lds r29, TCB3_CCMPH
                                 
002da7 1bce                      	sub r28, ZL //calculate the difference to the target
002da8 0bdf                      	sbc r29, ZH
002da9 f408                      	brsh sound_driver_channel3_fx_Rxy_routine_end //if the target has been reached (or passed)
002daa f068                      	brlo sound_driver_channel3_fx_Rxy_routine_add
                                 
                                 sound_driver_channel3_fx_Rxy_routine_end:
002dab 9220 295d                 	sts noise_fx_Rxy_total_offset, zero //disable the effect
002dad 9220 295e                 	sts noise_fx_Rxy_total_offset+1, zero
002daf 9220 2959                 	sts noise_fx_Rxy_target, zero
002db1 9220 295a                 	sts noise_fx_Rxy_target+1, zero
002db3 91b0 2958                 	lds r27, noise_fx_Rxy_target_note
002db5 93b0 2817                 	sts noise_note, r27 //replace the note with the final target note
002db7 c00a                      	rjmp sound_driver_instrument_routine_channel4_volume
                                 
                                 sound_driver_channel3_fx_Rxy_routine_add:
002db8 91c0 295b                 	lds r28, noise_fx_Rxy_speed
002dba 91d0 295c                 	lds r29, noise_fx_Rxy_speed+1
002dbc 0fac                      	add r26, r28 //increase the total offset by the speed
002dbd 1fbd                      	adc r27, r29
002dbe 93a0 295d                 	sts noise_fx_Rxy_total_offset, r26 //store the total offset
002dc0 93b0 295e                 	sts noise_fx_Rxy_total_offset+1, r27
                                 
                                 sound_driver_instrument_routine_channel4_volume:
                                 
                                 sound_driver_exit:
002dc2 91ff                      	pop r31
002dc3 91ef                      	pop r30
002dc4 91df                      	pop r29
002dc5 91cf                      	pop r28
002dc6 940c 1293                 	jmp sequence_1_3 + 3 //+3 is to skip the stack instructions since we already pushed them
                                 
                                 
                                 
                                 //TABLES
002dc8 7f05
002dc9 010a
002dca 0214
002dcb 0328
002dcc 0450
002dcd 051e
002dce 0607
002dcf 070d
002dd0 0806
002dd1 090c
002dd2 0a18
002dd3 0b30
002dd4 0c60
002dd5 0d24
002dd6 0e08
002dd7 0f10                      length: .db $05, $7F, $0A, $01, $14, $02, $28, $03, $50, $04, $1E, $05, $07, $06, $0D, $07, $06, $08, $0C, $09, $18, $0A, $30, $0B, $60, $0C, $24, $0D, $08, $0E, $10, $0F
                                 
                                 //pulse sequences: 12.5%, 25%, 50%, 75%
002dd8 0301
002dd9 fc0f                      sequences: .db 0b00000001, 0b00000011, 0b00001111, 0b11111100
                                 
                                 //list of famitracker fx: http://famitracker.com/wiki/index.php?title=Effect_list
                                 channel0_fx:
002dda 14cf
002ddb 14d4
002ddc 14f0
002ddd 150c
002dde 152f                      	.dw sound_driver_channel0_fx_0xy, sound_driver_channel0_fx_1xx, sound_driver_channel0_fx_2xx, sound_driver_channel0_fx_3xx, sound_driver_channel0_fx_4xy
002ddf 153a
002de0 1547
002de1 154a
002de2 154d
002de3 1550                      	.dw sound_driver_channel0_fx_7xy, sound_driver_channel0_fx_Axy, sound_driver_channel0_fx_Bxx, sound_driver_channel0_fx_Cxx, sound_driver_channel0_fx_Dxx
002de4 1553
002de5 155b
002de6 155e
002de7 156b
002de8 156c                      	.dw sound_driver_channel0_fx_Exx, sound_driver_channel0_fx_Fxx, sound_driver_channel0_fx_Gxx, sound_driver_channel0_fx_Hxy, sound_driver_channel0_fx_Ixy
002de9 156d
002dea 156e
002deb 156f
002dec 1587
002ded 15cd                      	.dw sound_driver_channel0_fx_Hxx, sound_driver_channel0_fx_Ixx, sound_driver_channel0_fx_Pxx, sound_driver_channel0_fx_Qxy, sound_driver_channel0_fx_Rxy
002dee 1612
002def 161f
002df0 1633
002df1 1634
002df2 1635                      	.dw sound_driver_channel0_fx_Sxx, sound_driver_channel0_fx_Vxx, sound_driver_channel0_fx_Wxx, sound_driver_channel0_fx_Xxx, sound_driver_channel0_fx_Yxx
002df3 1636                      	.dw sound_driver_channel0_fx_Zxx
                                 
                                 channel1_fx:
002df4 17c1
002df5 17c6
002df6 17e2
002df7 17fe
002df8 1821                      	.dw sound_driver_channel1_fx_0xy, sound_driver_channel1_fx_1xx, sound_driver_channel1_fx_2xx, sound_driver_channel1_fx_3xx, sound_driver_channel1_fx_4xy
002df9 182c
002dfa 1839
002dfb 183c
002dfc 183f
002dfd 1842                      	.dw sound_driver_channel1_fx_7xy, sound_driver_channel1_fx_Axy, sound_driver_channel1_fx_Bxx, sound_driver_channel1_fx_Cxx, sound_driver_channel1_fx_Dxx
002dfe 1845
002dff 184d
002e00 1850
002e01 185d
002e02 185e                      	.dw sound_driver_channel1_fx_Exx, sound_driver_channel1_fx_Fxx, sound_driver_channel1_fx_Gxx, sound_driver_channel1_fx_Hxy, sound_driver_channel1_fx_Ixy
002e03 185f
002e04 1860
002e05 1861
002e06 1879
002e07 18bf                      	.dw sound_driver_channel1_fx_Hxx, sound_driver_channel1_fx_Ixx, sound_driver_channel1_fx_Pxx, sound_driver_channel1_fx_Qxy, sound_driver_channel1_fx_Rxy
002e08 1904
002e09 1911
002e0a 1925
002e0b 1926
002e0c 1927                      	.dw sound_driver_channel1_fx_Sxx, sound_driver_channel1_fx_Vxx, sound_driver_channel1_fx_Wxx, sound_driver_channel1_fx_Xxx, sound_driver_channel1_fx_Yxx
002e0d 1928                      	.dw sound_driver_channel1_fx_Zxx
                                 
                                 channel2_fx:
002e0e 1aa6
002e0f 1aab
002e10 1ac7
002e11 1ae3
002e12 1b06                      	.dw sound_driver_channel2_fx_0xy, sound_driver_channel2_fx_1xx, sound_driver_channel2_fx_2xx, sound_driver_channel2_fx_3xx, sound_driver_channel2_fx_4xy
002e13 1b11
002e14 1b12
002e15 1b13
002e16 1b16
002e17 1b19                      	.dw sound_driver_channel2_fx_7xy, sound_driver_channel2_fx_Axy, sound_driver_channel2_fx_Bxx, sound_driver_channel2_fx_Cxx, sound_driver_channel2_fx_Dxx
002e18 1b1c
002e19 1b29
002e1a 1b2c
002e1b 1b39
002e1c 1b3a                      	.dw sound_driver_channel2_fx_Exx, sound_driver_channel2_fx_Fxx, sound_driver_channel2_fx_Gxx, sound_driver_channel2_fx_Hxy, sound_driver_channel2_fx_Ixy
002e1d 1b3b
002e1e 1b3c
002e1f 1b3d
002e20 1b55
002e21 1b9b                      	.dw sound_driver_channel2_fx_Hxx, sound_driver_channel2_fx_Ixx, sound_driver_channel2_fx_Pxx, sound_driver_channel2_fx_Qxy, sound_driver_channel2_fx_Rxy
002e22 1be0
002e23 1bed
002e24 1bee
002e25 1bef
002e26 1bf0                      	.dw sound_driver_channel2_fx_Sxx, sound_driver_channel2_fx_Vxx, sound_driver_channel2_fx_Wxx, sound_driver_channel2_fx_Xxx, sound_driver_channel2_fx_Yxx
002e27 1bf1                      	.dw sound_driver_channel2_fx_Zxx
                                 
                                 channel3_fx:
002e28 1d73
002e29 1d78
002e2a 1d94
002e2b 1db0
002e2c 1dd3                      	.dw sound_driver_channel3_fx_0xy, sound_driver_channel3_fx_1xx, sound_driver_channel3_fx_2xx, sound_driver_channel3_fx_3xx, sound_driver_channel3_fx_4xy
002e2d 1dde
002e2e 1deb
002e2f 1dee
002e30 1df1
002e31 1df4                      	.dw sound_driver_channel3_fx_7xy, sound_driver_channel3_fx_Axy, sound_driver_channel3_fx_Bxx, sound_driver_channel3_fx_Cxx, sound_driver_channel3_fx_Dxx
002e32 1df7
002e33 1dfe
002e34 1e01
002e35 1e0e
002e36 1e0f                      	.dw sound_driver_channel3_fx_Exx, sound_driver_channel3_fx_Fxx, sound_driver_channel3_fx_Gxx, sound_driver_channel3_fx_Hxy, sound_driver_channel3_fx_Ixy
002e37 1e10
002e38 1e11
002e39 1e12
002e3a 1e2a
002e3b 1e70                      	.dw sound_driver_channel3_fx_Hxx, sound_driver_channel3_fx_Ixx, sound_driver_channel3_fx_Pxx, sound_driver_channel3_fx_Qxy, sound_driver_channel3_fx_Rxy
002e3c 1eb5
002e3d 1ec2
002e3e 1ecd
002e3f 1ece
002e40 1ecf                      	.dw sound_driver_channel3_fx_Sxx, sound_driver_channel3_fx_Vxx, sound_driver_channel3_fx_Wxx, sound_driver_channel3_fx_Xxx, sound_driver_channel3_fx_Yxx
002e41 1ed0                      	.dw sound_driver_channel3_fx_Zxx
                                 
                                 //famitracker volumes table: http://famitracker.com/wiki/index.php?title=Volume
                                 volumes:
002e42 0000
002e43 0000
002e44 0000
002e45 0000
002e46 0000
002e47 0000
002e48 0000
002e49 0000                      	.db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
002e4a 0100
002e4b 0101
002e4c 0101
002e4d 0101
002e4e 0101
002e4f 0101
002e50 0101
002e51 0101                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
002e52 0100
002e53 0101
002e54 0101
002e55 0101
002e56 0101
002e57 0101
002e58 0101
002e59 0201                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02
002e5a 0100
002e5b 0101
002e5c 0101
002e5d 0101
002e5e 0101
002e5f 0202
002e60 0202
002e61 0302                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03
002e62 0100
002e63 0101
002e64 0101
002e65 0101
002e66 0202
002e67 0202
002e68 0303
002e69 0403                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04
002e6a 0100
002e6b 0101
002e6c 0101
002e6d 0202
002e6e 0302
002e6f 0303
002e70 0404
002e71 0504                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05
002e72 0100
002e73 0101
002e74 0201
002e75 0202
002e76 0303
002e77 0404
002e78 0504
002e79 0605                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x06
002e7a 0100
002e7b 0101
002e7c 0201
002e7d 0302
002e7e 0403
002e7f 0504
002e80 0605
002e81 0706                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07
002e82 0100
002e83 0101
002e84 0202
002e85 0303
002e86 0404
002e87 0505
002e88 0606
002e89 0807                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07, 0x08
002e8a 0100
002e8b 0101
002e8c 0302
002e8d 0403
002e8e 0504
002e8f 0606
002e90 0707
002e91 0908                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09
002e92 0100
002e93 0201
002e94 0302
002e95 0404
002e96 0605
002e97 0706
002e98 0808
002e99 0a09                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A
002e9a 0100
002e9b 0201
002e9c 0302
002e9d 0504
002e9e 0605
002e9f 0807
002ea0 0908
002ea1 0b0a                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B
002ea2 0100
002ea3 0201
002ea4 0403
002ea5 0504
002ea6 0706
002ea7 0808
002ea8 0a09
002ea9 0c0b                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B, 0x0C
002eaa 0100
002eab 0201
002eac 0403
002ead 0605
002eae 0706
002eaf 0908
002eb0 0b0a
002eb1 0d0c                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D
002eb2 0100
002eb3 0201
002eb4 0403
002eb5 0605
002eb6 0807
002eb7 0a09
002eb8 0c0b
002eb9 0e0d                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E
002eba 0100
002ebb 0302
002ebc 0504
002ebd 0706
002ebe 0908
002ebf 0b0a
002ec0 0d0c


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega4809" register use summary:
x  :   0 y  :   0 z  : 248 r0 : 196 r1 : 212 r2 : 725 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   6 r11:   4 r12:   9 
r13:   6 r14:   4 r15:   9 r16:   7 r17:   6 r18:   7 r19:   6 r20:   4 
r21:   9 r22: 174 r23: 160 r24:   0 r25:  24 r26: 955 r27:1189 r28: 687 
r29: 356 r30: 374 r31: 333 
Registers used: 25 out of 35 (71.4%)

"ATmega4809" instruction use summary:
.lds  :   0 .sts  :   0 adc   : 144 add   : 191 adiw  : 106 and   :   0 
andi  :  99 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   7 brcs  :  13 break :   0 breq  : 173 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  81 brlt  :   0 brmi  :   0 
brne  : 121 brpl  :   0 brsh  :  31 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :   0 cbr   :   5 
clc   :   0 clh   :   0 cli   :   8 cln   :   0 clr   :   5 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :  16 cp    : 101 cpc   :  10 
cpi   : 168 cpse  :  20 dec   :  35 des   :   0 eor   :   2 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   4 in    :   7 inc   :  48 
jmp   :  11 ld    :   0 ldd   :   0 ldi   : 294 lds   : 719 lpm   : 260 
lsl   :  79 lsr   : 171 mov   : 139 movw  :   0 mul   :  28 muls  :   0 
mulsu :  12 neg   :   0 nop   :   0 or    :  26 ori   :  12 out   :   9 
pop   : 115 push  : 109 rcall :  50 ret   :  32 reti  :   7 rjmp  : 518 
rol   :  53 ror   : 192 sbc   :  40 sbci  :   0 sbi   :   0 sbic  :   0 
sbis  :   0 sbiw  :   0 sbr   :  12 sbrc  :  29 sbrs  :  20 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   :1421 sub   :  58 subi  :  45 swap  :  46 tst   :   0 wdr   :   0 

Instructions used: 52 out of 114 (45.6%)

"ATmega4809" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x005d84  15918   7910  23828   49152  48.5%
[.dseg] 0x002800 0x002962      0    354    354    6144   5.8%
[.eseg] 0x000000 0x000000      0      0      0     256   0.0%

Assembly complete, 0 errors, 55 warnings
