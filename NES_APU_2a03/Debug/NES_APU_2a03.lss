
AVRASM ver. 2.2.8  C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm Sat Jan 23 04:35:20 2021

C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
                                 
                                 
                                 ; NES_APU_2a03.asm
                                 ;
                                 ; Created: 11/29/2020 1:44:10 AM
                                 ; Author : Tennyson Cheng
                                 ;
                                 
                                 .list
                                 
                                 .dseg
002800                           pulse1_param: .byte 1 //$4000 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002801                           pulse1_sweep_param: .byte 1 //$4001 EPPP.NSSS = Enable, Period, Negate, Shift
                                 //NOTE: In order to account for multiplier, we use 16 instead of 11 bits for the timer
002802                           pulse1_timerL: .byte 1 //$4002 LLLL.LLLL = Low 8 bits for timer
002803                           pulse1_timerH: .byte 1 //$4002 HHHH.HHHH = High 8 bits for timer
002804                           pulse1_length: .byte 1 //$4003 000l.llll = Length counter load
002805                           pulse1_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002806                           pulse1_output_volume: .byte 1 //this is the final output volume of pulse 1
002807                           pulse1_note: .byte 1 //the current note index in the note table
                                 
002808                           pulse2_param: .byte 1 //$4004 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002809                           pulse2_sweep_param: .byte 1 //$4005 EPPP.NSSS = Enable, Period, Negate, Shift
00280a                           pulse2_timerL: .byte 1 //$4006 LLLL.LLLL = Low 8 bits for timer
00280b                           pulse2_timerH: .byte 1 //$4006 HHHH.HHHH = High 8 bits for timer
00280c                           pulse2_length: .byte 1 //$4007 000l.llll = Length counter load
00280d                           pulse2_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
00280e                           pulse2_output_volume: .byte 1 //this is the final output volume of pulse 2
00280f                           pulse2_note: .byte 1 //the current note index in the note table
                                 
002810                           triangle_timerL: .byte 1 //$400A LLLL.LLLL = Low 8 bits for timer
002811                           triangle_timerH: .byte 1 //$400A HHHH.HHHH = High 8 bits for time
002812                           triangle_note: .byte 1 //the current note index in the note table
                                 
002813                           noise_param: .byte 1 //$400C 00lc.vvvv = Length counter halt/Loop flag, Constant volume flag, Volume
002814                           noise_period: .byte 1 //$400E M000.PPPP = Mode, Period
002815                           noise_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002816                           noise_output_volume: .byte 1 //this is the final output volume of pulse 2
002817                           noise_note: .byte 1 //the current note index in the period table
                                 
002818                           song_frames: .byte 2
00281a                           song_frame_offset: .byte 2
00281c                           song_size: .byte 2
00281e                           song_speed: .byte 1
                                 //song_channel_delay_reload: .byte 1 //bit 0-4 represents channels 0-4. a set bit means that there is a delay that needs to be calculated for that channel.
00281f                           song_fx_Bxx: .byte 1
002820                           song_fx_Cxx: .byte 1
002821                           song_fx_Dxx: .byte 1
                                 
                                 //PULSE 1
002822                           pulse1_pattern: .byte 2
002824                           pulse1_pattern_delay_rows: .byte 1
002825                           pulse1_pattern_delay_frames: .byte 1
002826                           pulse1_pattern_offset: .byte 2
                                 
002828                           pulse1_volume_macro: .byte 2
00282a                           pulse1_volume_macro_offset: .byte 1
00282b                           pulse1_volume_macro_loop: .byte 1
00282c                           pulse1_volume_macro_release: .byte 1
                                 
00282d                           pulse1_arpeggio_macro: .byte 2
00282f                           pulse1_arpeggio_macro_offset: .byte 1
002830                           pulse1_arpeggio_macro_loop: .byte 1
002831                           pulse1_arpeggio_macro_release: .byte 1
002832                           pulse1_arpeggio_macro_mode: .byte 1
                                 
002833                           pulse1_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002835                           pulse1_pitch_macro: .byte 2
002837                           pulse1_pitch_macro_offset: .byte 1
002838                           pulse1_pitch_macro_loop: .byte 1
002839                           pulse1_pitch_macro_release: .byte 1
                                 
00283a                           pulse1_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00283b                           pulse1_hi_pitch_macro: .byte 2
00283d                           pulse1_hi_pitch_macro_offset: .byte 1
00283e                           pulse1_hi_pitch_macro_loop: .byte 1
00283f                           pulse1_hi_pitch_macro_release: .byte 1
                                 
002840                           pulse1_duty_macro: .byte 2
002842                           pulse1_duty_macro_offset: .byte 1
002843                           pulse1_duty_macro_loop: .byte 1
002844                           pulse1_duty_macro_release: .byte 1
                                 
002845                           pulse1_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002847                           pulse1_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002849                           pulse1_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00284b                           pulse1_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
00284d                           pulse1_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
00284f                           pulse1_fx_3xx_start: .byte 2 //the starting note period
002851                           pulse1_fx_3xx_target: .byte 2 //target note period
002853                           pulse1_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
002855                           pulse1_fx_3xx_total_offset: .byte 2
002857                           pulse1_fx_4xy_speed: .byte 1
002858                           pulse1_fx_4xy_depth: .byte 1
002859                           pulse1_fx_4xy_phase: .byte 1
00285a                           pulse1_fx_7xy_speed: .byte 1
00285b                           pulse1_fx_7xy_depth: .byte 1
00285c                           pulse1_fx_7xy_phase: .byte 1
00285d                           pulse1_fx_7xy_value: .byte 1 //value to offset the volume
00285e                           pulse1_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
00285f                           pulse1_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002860                           pulse1_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002861                           pulse1_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
002863                           pulse1_fx_Qxy_target: .byte 2 //target note period
002865                           pulse1_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002867                           pulse1_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002869                           pulse1_fx_Rxy_target: .byte 2 //target note period
00286b                           pulse1_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
00286d                           pulse1_fx_Rxy_total_offset: .byte 2
00286f                           pulse1_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002870                           pulse1_fx_Sxx_post: .byte 1
                                 
                                 //PULSE 2
002871                           pulse2_pattern: .byte 2
002873                           pulse2_pattern_delay_rows: .byte 1
002874                           pulse2_pattern_delay_frames: .byte 1
002875                           pulse2_pattern_offset: .byte 2
                                 
002877                           pulse2_volume_macro: .byte 2
002879                           pulse2_volume_macro_offset: .byte 1
00287a                           pulse2_volume_macro_loop: .byte 1
00287b                           pulse2_volume_macro_release: .byte 1
                                 
00287c                           pulse2_arpeggio_macro: .byte 2
00287e                           pulse2_arpeggio_macro_offset: .byte 1
00287f                           pulse2_arpeggio_macro_loop: .byte 1
002880                           pulse2_arpeggio_macro_release: .byte 1
002881                           pulse2_arpeggio_macro_mode: .byte 1
                                 
002882                           pulse2_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002884                           pulse2_pitch_macro: .byte 2
002886                           pulse2_pitch_macro_offset: .byte 1
002887                           pulse2_pitch_macro_loop: .byte 1
002888                           pulse2_pitch_macro_release: .byte 1
                                 
002889                           pulse2_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00288a                           pulse2_hi_pitch_macro: .byte 2
00288c                           pulse2_hi_pitch_macro_offset: .byte 1
00288d                           pulse2_hi_pitch_macro_loop: .byte 1
00288e                           pulse2_hi_pitch_macro_release: .byte 1
                                 
00288f                           pulse2_duty_macro: .byte 2
002891                           pulse2_duty_macro_offset: .byte 1
002892                           pulse2_duty_macro_loop: .byte 1
002893                           pulse2_duty_macro_release: .byte 1
                                 
002894                           pulse2_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002896                           pulse2_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002898                           pulse2_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00289a                           pulse2_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
00289c                           pulse2_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
00289e                           pulse2_fx_3xx_start: .byte 2 //the starting note period
0028a0                           pulse2_fx_3xx_target: .byte 2 //target note period
0028a2                           pulse2_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028a4                           pulse2_fx_3xx_total_offset: .byte 2
0028a6                           pulse2_fx_4xy_speed: .byte 1
0028a7                           pulse2_fx_4xy_depth: .byte 1
0028a8                           pulse2_fx_4xy_phase: .byte 1
0028a9                           pulse2_fx_7xy_speed: .byte 1
0028aa                           pulse2_fx_7xy_depth: .byte 1
0028ab                           pulse2_fx_7xy_phase: .byte 1
0028ac                           pulse2_fx_7xy_value: .byte 1 //value to offset the volume
0028ad                           pulse2_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
0028ae                           pulse2_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028af                           pulse2_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028b0                           pulse2_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
0028b2                           pulse2_fx_Qxy_target: .byte 2 //target note period
0028b4                           pulse2_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
0028b6                           pulse2_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
0028b8                           pulse2_fx_Rxy_target: .byte 2 //target note period
0028ba                           pulse2_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
0028bc                           pulse2_fx_Rxy_total_offset: .byte 2
0028be                           pulse2_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
0028bf                           pulse2_fx_Sxx_post: .byte 1
                                 
                                 //TRIANGLE
0028c0                           triangle_pattern: .byte 2
0028c2                           triangle_pattern_delay_rows: .byte 1
0028c3                           triangle_pattern_delay_frames: .byte 1
0028c4                           triangle_pattern_offset: .byte 2
                                 
0028c6                           triangle_volume_macro: .byte 2
0028c8                           triangle_volume_macro_offset: .byte 1
0028c9                           triangle_volume_macro_loop: .byte 1
0028ca                           triangle_volume_macro_release: .byte 1
                                 
0028cb                           triangle_arpeggio_macro: .byte 2
0028cd                           triangle_arpeggio_macro_offset: .byte 1
0028ce                           triangle_arpeggio_macro_loop: .byte 1
0028cf                           triangle_arpeggio_macro_release: .byte 1
0028d0                           triangle_arpeggio_macro_mode: .byte 1
                                 
0028d1                           triangle_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
0028d3                           triangle_pitch_macro: .byte 2
0028d5                           triangle_pitch_macro_offset: .byte 1
0028d6                           triangle_pitch_macro_loop: .byte 1
0028d7                           triangle_pitch_macro_release: .byte 1
                                 
0028d8                           triangle_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
0028d9                           triangle_hi_pitch_macro: .byte 2
0028db                           triangle_hi_pitch_macro_offset: .byte 1
0028dc                           triangle_hi_pitch_macro_loop: .byte 1
0028dd                           triangle_hi_pitch_macro_release: .byte 1
                                 
0028de                           triangle_duty_macro: .byte 2
0028e0                           triangle_duty_macro_offset: .byte 1
0028e1                           triangle_duty_macro_loop: .byte 1
0028e2                           triangle_duty_macro_release: .byte 1
                                 
0028e3                           triangle_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
0028e5                           triangle_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
0028e7                           triangle_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
0028e9                           triangle_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
0028eb                           triangle_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
0028ed                           triangle_fx_3xx_start: .byte 2 //the starting note period
0028ef                           triangle_fx_3xx_target: .byte 2 //target note period
0028f1                           triangle_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028f3                           triangle_fx_3xx_total_offset: .byte 2
0028f5                           triangle_fx_4xy_speed: .byte 1
0028f6                           triangle_fx_4xy_depth: .byte 1
0028f7                           triangle_fx_4xy_phase: .byte 1
0028f8                           triangle_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028f9                           triangle_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028fa                           triangle_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
0028fc                           triangle_fx_Qxy_target: .byte 2 //target note period
0028fe                           triangle_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002900                           triangle_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002902                           triangle_fx_Rxy_target: .byte 2 //target note period
002904                           triangle_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
002906                           triangle_fx_Rxy_total_offset: .byte 2
002908                           triangle_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002909                           triangle_fx_Sxx_post: .byte 1
                                 
                                 //NOISE
00290a                           noise_pattern: .byte 2
00290c                           noise_pattern_delay_rows: .byte 1
00290d                           noise_pattern_delay_frames: .byte 1
00290e                           noise_pattern_offset: .byte 2
                                 
002910                           noise_volume_macro: .byte 2
002912                           noise_volume_macro_offset: .byte 1
002913                           noise_volume_macro_loop: .byte 1
002914                           noise_volume_macro_release: .byte 1
                                 
002915                           noise_arpeggio_macro: .byte 2
002917                           noise_arpeggio_macro_offset: .byte 1
002918                           noise_arpeggio_macro_loop: .byte 1
002919                           noise_arpeggio_macro_release: .byte 1
00291a                           noise_arpeggio_macro_mode: .byte 1
                                 
00291b                           noise_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
00291d                           noise_pitch_macro: .byte 2
00291f                           noise_pitch_macro_offset: .byte 1
002920                           noise_pitch_macro_loop: .byte 1
002921                           noise_pitch_macro_release: .byte 1
                                 
002922                           noise_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
002923                           noise_hi_pitch_macro: .byte 2
002925                           noise_hi_pitch_macro_offset: .byte 1
002926                           noise_hi_pitch_macro_loop: .byte 1
002927                           noise_hi_pitch_macro_release: .byte 1
                                 
002928                           noise_duty_macro: .byte 2
00292a                           noise_duty_macro_offset: .byte 1
00292b                           noise_duty_macro_loop: .byte 1
00292c                           noise_duty_macro_release: .byte 1
                                 
00292d                           noise_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
00292f                           noise_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002931                           noise_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
002933                           noise_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
002935                           noise_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
002937                           noise_fx_3xx_start: .byte 2 //the starting note period
002939                           noise_fx_3xx_target: .byte 2 //target note period
00293b                           noise_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
00293d                           noise_fx_3xx_total_offset: .byte 2
00293f                           noise_fx_4xy_speed: .byte 1
002940                           noise_fx_4xy_depth: .byte 1
002941                           noise_fx_4xy_phase: .byte 1
002942                           noise_fx_7xy_speed: .byte 1
002943                           noise_fx_7xy_depth: .byte 1
002944                           noise_fx_7xy_phase: .byte 1
002945                           noise_fx_7xy_value: .byte 1 //value to offset the volume
002946                           noise_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
002947                           noise_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002948                           noise_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002949                           noise_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
00294b                           noise_fx_Qxy_target: .byte 2 //target note period
00294d                           noise_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
00294f                           noise_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002951                           noise_fx_Rxy_target: .byte 2 //target note period
002953                           noise_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
002955                           noise_fx_Rxy_total_offset: .byte 2
002957                           noise_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002958                           noise_fx_Sxx_post: .byte 1
                                 
                                 //DPCM
002959                           dcpm_pattern_delay: .byte 1
                                 
                                 .cseg
                                 
                                 //NOTE: zero is defined in order to use the cp instruction without the need to load 0x00 into a register beforehand
                                 .def zero = r2
                                 .def pulse_channel_flags = r25 //[pulse1.pulse2] RSlc.RSlc = Reload, Start, Length halt/Loop, Constant volume
                                 .def pulse1_sequence = r10
                                 .def pulse1_length_counter = r11
                                 .def pulse1_sweep = r12 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse1_volume_divider = r16 //0000.PPPP = Period divider
                                 .def pulse1_volume_decay = r17 //0000.dddd = Decay
                                 .def pulse2_sequence = r13
                                 .def pulse2_length_counter = r14
                                 .def pulse2_sweep = r15 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse2_volume_divider = r18 //0000.PPPP = Period divider
                                 .def pulse2_volume_decay = r19 //0000.dddd = Decay
                                 .def triangle_sequence = r20
                                 .def noise_sequence_LOW = r21
                                 .def noise_sequence_HIGH = r22
                                 
                                 reset:
000000 940c 1155                 	jmp init
                                 
                                 .org TCA0_OVF_vect
00000e 940c 1600                 	jmp sound_driver
                                 
                                 .org TCA0_CMP0_vect
000012 940c 1507                 	jmp sequence_0_2
                                 
                                 .org TCA0_CMP1_vect
000014 940c 1512                 	jmp sequence_1_3
                                 
                                 .org TCA0_CMP2_vect
000016 940c 1507                 	jmp sequence_0_2
                                 
                                 .org TCB0_INT_vect
000018 940c 1529                 	jmp pulse1_sequence_routine
                                 
                                 .org TCB1_INT_vect
00001a 940c 1576                 	jmp pulse2_sequence_routine
                                 
                                 .org TCB2_INT_vect
000032 940c 15c3                 	jmp triangle_sequence_routine
                                 
                                 .org TCB3_INT_vect
000048 940c 15ce                 	jmp noise_sequence_routine
                                 
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(33): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(48): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(80): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(82): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(87): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(88): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(89): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(90): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(93): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(95): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(96): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(97): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(99): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(104): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(107): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(109): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(110): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(111): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(112): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(113): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(115): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(116): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(119): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(120): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(128): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(129): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(131): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(132): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(133): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(134): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(136): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(137): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(139): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(141): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(143): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(146): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(150): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(152): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(153): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(154): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(157): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(159): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(160): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(162): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(166): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(205): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(207): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(208): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(209): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(212): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(213): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(214): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(217): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(219): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(225): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(226): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(230): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(231): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(238): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
                                 .list
                                 
                                 init:
                                 	//MAIN CLOCK
001155 edc8                      	ldi r28, CPU_CCP_IOREG_gc //protected write
001156 93c0 0034                 	sts CPU_CCP, r28
001158 e0c0                      	ldi r28, 0 << CLKCTRL_PEN_bp //disable prescaler for 20 MHz on main clock
001159 93c0 0061                 	sts CLKCTRL_MCLKCTRLB, r28
                                 
                                 	//ZERO
00115b 2422                      	clr zero
                                 
                                 	//MEMORY
00115c e3c0                      	ldi r28, 0b00110000
00115d 93c0 2800                 	sts pulse1_param, r28
00115f e8c0                      	ldi r28, 0b10000000
001160 93c0 2801                 	sts pulse1_sweep_param, r28
001162 efcf                      	ldi r28, 0xFF
001163 93c0 2802                 	sts pulse1_timerL, r28
001165 93c0 2803                 	sts pulse1_timerH, r28
001167 93c0 2804                 	sts pulse1_length, r28
                                 
001169 e3c0                      	ldi r28, 0b00110000
00116a 93c0 2808                 	sts pulse2_param, r28
00116c e8c0                      	ldi r28, 0b10000000
00116d 93c0 2809                 	sts pulse2_sweep_param, r28
00116f efcf                      	ldi r28, 0xFF
001170 93c0 280a                 	sts pulse2_timerL, r28
001172 93c0 280b                 	sts pulse2_timerH, r28
001174 93c0 280c                 	sts pulse2_length, r28
                                 
001176 efcf                      	ldi r28, 0xFF
001177 93c0 2810                 	sts triangle_timerL, r28
001179 93c0 2811                 	sts triangle_timerH, r28
                                 
00117b e3c0                      	ldi r28, 0b00110000
00117c 93c0 2813                 	sts noise_param, r28
00117e e0cf                      	ldi r28, 0b00001111
00117f 93c0 2814                 	sts noise_period, r28
                                 
001181 e0c2                      	ldi r28, 0x02
001182 93c0 281a                 	sts song_frame_offset, r28
001184 9220 281b                 	sts song_frame_offset+1, zero
001186 efcf                      	ldi r28, 0xFF
001187 93c0 281f                 	sts song_fx_Bxx, r28
001189 9220 2820                 	sts song_fx_Cxx, zero
00118b 9220 2821                 	sts song_fx_Dxx, zero
00118d e4ee                      	ldi ZL, LOW(song0_frames << 1)
00118e e0f3                      	ldi ZH, HIGH(song0_frames << 1)
00118f 93e0 2818                 	sts song_frames, ZL
001191 93f0 2819                 	sts song_frames+1, ZH
001193 91c5                      	lpm r28, Z+ //load the song size
001194 91d5                      	lpm r29, Z+
001195 93c0 281c                 	sts song_size, r28
001197 93d0 281d                 	sts song_size+1, r29
001199 9220 281e                 	sts song_speed, zero
                                 
                                 	//CHANNEL 0
00119b 91c5                      	lpm r28, Z+
00119c 91d5                      	lpm r29, Z+
00119d 0fcc                      	lsl r28
00119e 1fdd                      	rol r29
00119f 93c0 2822                 	sts pulse1_pattern, r28
0011a1 93d0 2823                 	sts pulse1_pattern+1, r29
0011a3 9220 2824                 	sts pulse1_pattern_delay_rows, zero
0011a5 9220 2825                 	sts pulse1_pattern_delay_frames, zero
0011a7 9220 2826                 	sts pulse1_pattern_offset, zero
0011a9 9220 2827                 	sts pulse1_pattern_offset+1, zero
                                 
                                 	//CHANNEL 1
0011ab 91c5                      	lpm r28, Z+
0011ac 91d5                      	lpm r29, Z+
0011ad 0fcc                      	lsl r28
0011ae 1fdd                      	rol r29
0011af 93c0 2871                 	sts pulse2_pattern, r28
0011b1 93d0 2872                 	sts pulse2_pattern+1, r29
0011b3 9220 2873                 	sts pulse2_pattern_delay_rows, zero
0011b5 9220 2874                 	sts pulse2_pattern_delay_frames, zero
0011b7 9220 2875                 	sts pulse2_pattern_offset, zero
0011b9 9220 2876                 	sts pulse2_pattern_offset+1, zero
                                 
                                 	//CHANNEL 2
0011bb 91c5                      	lpm r28, Z+
0011bc 91d5                      	lpm r29, Z+
0011bd 0fcc                      	lsl r28
0011be 1fdd                      	rol r29
0011bf 93c0 28c0                 	sts triangle_pattern, r28
0011c1 93d0 28c1                 	sts triangle_pattern+1, r29
0011c3 9220 28c2                 	sts triangle_pattern_delay_rows, zero
0011c5 9220 28c3                 	sts triangle_pattern_delay_frames, zero
0011c7 9220 28c4                 	sts triangle_pattern_offset, zero
0011c9 9220 28c5                 	sts triangle_pattern_offset+1, zero
                                 
                                 	//CHANNEL 3
0011cb 91c5                      	lpm r28, Z+
0011cc 91d5                      	lpm r29, Z+
0011cd 0fcc                      	lsl r28
0011ce 1fdd                      	rol r29
0011cf 93c0 290a                 	sts noise_pattern, r28
0011d1 93d0 290b                 	sts noise_pattern+1, r29
0011d3 9220 290c                 	sts noise_pattern_delay_rows, zero
0011d5 9220 290d                 	sts noise_pattern_delay_frames, zero
0011d7 9220 290e                 	sts noise_pattern_offset, zero
0011d9 9220 290f                 	sts noise_pattern_offset+1, zero
                                 
                                 	//CHANNEL 0 instrument macros
0011db efcf                      	ldi r28, 0xFF
0011dc 9220 282a                 	sts pulse1_volume_macro_offset, zero
0011de 93c0 282b                 	sts pulse1_volume_macro_loop, r28
0011e0 93c0 282c                 	sts pulse1_volume_macro_release, r28
0011e2 9220 282f                 	sts pulse1_arpeggio_macro_offset, zero
0011e4 93c0 2830                 	sts pulse1_arpeggio_macro_loop, r28
0011e6 93c0 2831                 	sts pulse1_arpeggio_macro_release, r28
0011e8 93c0 2832                 	sts pulse1_arpeggio_macro_mode, r28
0011ea 9220 2837                 	sts pulse1_pitch_macro_offset, zero
0011ec 93c0 2838                 	sts pulse1_pitch_macro_loop, r28
0011ee 93c0 2839                 	sts pulse1_pitch_macro_release, r28
0011f0 9220 283d                 	sts pulse1_hi_pitch_macro_offset, zero
0011f2 93c0 283e                 	sts pulse1_hi_pitch_macro_loop, r28
0011f4 93c0 283f                 	sts pulse1_hi_pitch_macro_release, r28
0011f6 9220 2842                 	sts pulse1_duty_macro_offset, zero
0011f8 93c0 2843                 	sts pulse1_duty_macro_loop, r28
0011fa 93c0 2844                 	sts pulse1_duty_macro_release, r28
                                 
0011fc 9220 2828                 	sts pulse1_volume_macro, zero
0011fe 9220 2829                 	sts pulse1_volume_macro+1, zero
001200 9220 282d                 	sts pulse1_arpeggio_macro, zero
001202 9220 282e                 	sts pulse1_arpeggio_macro+1, zero
001204 9220 2833                 	sts pulse1_total_pitch_offset, zero
001206 9220 2834                 	sts pulse1_total_pitch_offset+1, zero
001208 9220 2835                 	sts pulse1_pitch_macro, zero
00120a 9220 2836                 	sts pulse1_pitch_macro+1, zero
00120c 9220 283a                 	sts pulse1_total_hi_pitch_offset, zero
00120e 9220 283b                 	sts pulse1_hi_pitch_macro, zero
001210 9220 283c                 	sts pulse1_hi_pitch_macro+1, zero
001212 9220 2840                 	sts pulse1_duty_macro, zero
001214 9220 2841                 	sts pulse1_duty_macro+1, zero
                                 
                                 	//CHANNEL 0 ENVELOPE
001216 e00f                      	ldi pulse1_volume_divider, 0x0F
001217 9110 2800                 	lds pulse1_volume_decay, pulse1_param
001219 701f                      	andi pulse1_volume_decay, 0x0F //mask for VVVV bits
00121a 9190 2800                 	lds pulse_channel_flags, pulse1_param
00121c 7390                      	andi pulse_channel_flags, 0b00110000
00121d 6490                      	sbr pulse_channel_flags, 0b01000000 //set start flag
00121e 9220 2806                 	sts pulse1_output_volume, zero
001220 93c0 2805                 	sts pulse1_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 0 LENGTH
001222 2ebc                      	mov pulse1_length_counter, r28
                                 
                                 	//CHANNEL 0 SEQUENCE
001223 e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
001224 2eac                      	mov pulse1_sequence, r28
                                 
                                 	//CHANNEL 0 SWEEP
001225 90c0 2801                 	lds pulse1_sweep, pulse1_sweep_param
001227 94c2                      	swap pulse1_sweep //swap data from high byte and low byte
001228 6890                      	sbr pulse_channel_flags, 0b10000000 //set reload flag
                                 
                                 	//CHANNEL 0 FX
001229 efcf                      	ldi r28, 0xFF
00122a 9220 2845                 	sts pulse1_fx_0xy_sequence, zero
00122c 9220 2846                 	sts pulse1_fx_0xy_sequence+1, zero
00122e 9220 2847                 	sts pulse1_fx_1xx, zero
001230 9220 2848                 	sts pulse1_fx_1xx+1, zero
001232 9220 2849                 	sts pulse1_fx_1xx_total, zero
001234 9220 284a                 	sts pulse1_fx_1xx_total+1, zero
001236 9220 284b                 	sts pulse1_fx_2xx, zero
001238 9220 284c                 	sts pulse1_fx_2xx+1, zero
00123a 9220 284d                 	sts pulse1_fx_2xx_total, zero
00123c 9220 284e                 	sts pulse1_fx_2xx_total+1, zero
00123e 9220 284f                 	sts pulse1_fx_3xx_start, zero
001240 9220 2850                 	sts pulse1_fx_3xx_start+1, zero
001242 9220 2851                 	sts pulse1_fx_3xx_target, zero
001244 9220 2852                 	sts pulse1_fx_3xx_target+1, zero
001246 9220 2853                 	sts pulse1_fx_3xx_speed, zero
001248 9220 2854                 	sts pulse1_fx_3xx_speed+1, zero
00124a 9220 2855                 	sts pulse1_fx_3xx_total_offset, zero
00124c 9220 2856                 	sts pulse1_fx_3xx_total_offset+1, zero
00124e 9220 2857                 	sts pulse1_fx_4xy_speed, zero
001250 9220 2858                 	sts pulse1_fx_4xy_depth, zero
001252 9220 2859                 	sts pulse1_fx_4xy_phase, zero
001254 9220 285a                 	sts pulse1_fx_7xy_speed, zero
001256 9220 285b                 	sts pulse1_fx_7xy_depth, zero
001258 9220 285c                 	sts pulse1_fx_7xy_phase, zero
00125a 9220 285d                 	sts pulse1_fx_7xy_value, zero
00125c 9220 285e                 	sts pulse1_fx_Axy, zero
00125e 93c0 285f                 	sts pulse1_fx_Gxx_pre, r28
001260 93c0 2860                 	sts pulse1_fx_Gxx_post, r28
001262 9220 2861                 	sts pulse1_fx_Pxx_total, zero
001264 9220 2862                 	sts pulse1_fx_Pxx_total+1, zero
001266 9220 2863                 	sts pulse1_fx_Qxy_target, zero
001268 9220 2864                 	sts pulse1_fx_Qxy_target+1, zero
00126a 9220 2865                 	sts pulse1_fx_Qxy_speed, zero
00126c 9220 2866                 	sts pulse1_fx_Qxy_speed+1, zero
00126e 9220 2867                 	sts pulse1_fx_Qxy_total_offset, zero
001270 9220 2868                 	sts pulse1_fx_Qxy_total_offset+1, zero
001272 9220 2869                 	sts pulse1_fx_Rxy_target, zero
001274 9220 286a                 	sts pulse1_fx_Rxy_target+1, zero
001276 9220 286b                 	sts pulse1_fx_Rxy_speed, zero
001278 9220 286c                 	sts pulse1_fx_Rxy_speed+1, zero
00127a 9220 286d                 	sts pulse1_fx_Rxy_total_offset, zero
00127c 9220 286e                 	sts pulse1_fx_Rxy_total_offset+1, zero
00127e 93c0 286f                 	sts pulse1_fx_Sxx_pre, r28
001280 93c0 2870                 	sts pulse1_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 1 instrument macros
001282 efcf                      	ldi r28, 0xFF
001283 9220 2879                 	sts pulse2_volume_macro_offset, zero
001285 93c0 287a                 	sts pulse2_volume_macro_loop, r28
001287 93c0 287b                 	sts pulse2_volume_macro_release, r28
001289 9220 287e                 	sts pulse2_arpeggio_macro_offset, zero
00128b 93c0 287f                 	sts pulse2_arpeggio_macro_loop, r28
00128d 93c0 2880                 	sts pulse2_arpeggio_macro_release, r28
00128f 93c0 2881                 	sts pulse2_arpeggio_macro_mode, r28
001291 9220 2886                 	sts pulse2_pitch_macro_offset, zero
001293 93c0 2887                 	sts pulse2_pitch_macro_loop, r28
001295 93c0 2888                 	sts pulse2_pitch_macro_release, r28
001297 9220 288c                 	sts pulse2_hi_pitch_macro_offset, zero
001299 93c0 288d                 	sts pulse2_hi_pitch_macro_loop, r28
00129b 93c0 288e                 	sts pulse2_hi_pitch_macro_release, r28
00129d 9220 2891                 	sts pulse2_duty_macro_offset, zero
00129f 93c0 2892                 	sts pulse2_duty_macro_loop, r28
0012a1 93c0 2893                 	sts pulse2_duty_macro_release, r28
                                 
0012a3 9220 2877                 	sts pulse2_volume_macro, zero
0012a5 9220 2878                 	sts pulse2_volume_macro+1, zero
0012a7 9220 287c                 	sts pulse2_arpeggio_macro, zero
0012a9 9220 287d                 	sts pulse2_arpeggio_macro+1, zero
0012ab 9220 2882                 	sts pulse2_total_pitch_offset, zero
0012ad 9220 2883                 	sts pulse2_total_pitch_offset+1, zero
0012af 9220 2884                 	sts pulse2_pitch_macro, zero
0012b1 9220 2885                 	sts pulse2_pitch_macro+1, zero
0012b3 9220 2889                 	sts pulse2_total_hi_pitch_offset, zero
0012b5 9220 288a                 	sts pulse2_hi_pitch_macro, zero
0012b7 9220 288b                 	sts pulse2_hi_pitch_macro+1, zero
0012b9 9220 288f                 	sts pulse2_duty_macro, zero
0012bb 9220 2890                 	sts pulse2_duty_macro+1, zero
                                 
                                 	//CHANNEL 1 ENVELOPE
0012bd e02f                      	ldi pulse2_volume_divider, 0x0F
0012be 9130 2808                 	lds pulse2_volume_decay, pulse2_param
0012c0 703f                      	andi pulse2_volume_decay, 0x0F //mask for VVVV bits
0012c1 91d0 2808                 	lds r29, pulse2_param
0012c3 73d0                      	andi r29, 0b00110000
0012c4 62d0                      	sbr r29, 0b0100000 //set start flag
0012c5 95d2                      	swap r29
0012c6 2b9d                      	or pulse_channel_flags, r29
0012c7 9220 280e                 	sts pulse2_output_volume, zero
0012c9 93c0 280d                 	sts pulse2_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 1 LENGTH
0012cb 2eec                      	mov pulse2_length_counter, r28
                                 
                                 	//CHANNEL 1 SEQUENCE
0012cc e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
0012cd 2edc                      	mov pulse2_sequence, r28
                                 
                                 	//CHANNEL 1 SWEEP
0012ce 90f0 2809                 	lds pulse2_sweep, pulse2_sweep_param
0012d0 94f2                      	swap pulse2_sweep //swap data from high byte and low byte
0012d1 6098                      	sbr pulse_channel_flags, 0b00001000 //set reload flag
                                 
                                 	//CHANNEL 1 FX
0012d2 efcf                      	ldi r28, 0xFF
0012d3 9220 2894                 	sts pulse2_fx_0xy_sequence, zero
0012d5 9220 2895                 	sts pulse2_fx_0xy_sequence+1, zero
0012d7 9220 2896                 	sts pulse2_fx_1xx, zero
0012d9 9220 2897                 	sts pulse2_fx_1xx+1, zero
0012db 9220 2898                 	sts pulse2_fx_1xx_total, zero
0012dd 9220 2899                 	sts pulse2_fx_1xx_total+1, zero
0012df 9220 289a                 	sts pulse2_fx_2xx, zero
0012e1 9220 289b                 	sts pulse2_fx_2xx+1, zero
0012e3 9220 289c                 	sts pulse2_fx_2xx_total, zero
0012e5 9220 289d                 	sts pulse2_fx_2xx_total+1, zero
0012e7 9220 289e                 	sts pulse2_fx_3xx_start, zero
0012e9 9220 289f                 	sts pulse2_fx_3xx_start+1, zero
0012eb 9220 28a0                 	sts pulse2_fx_3xx_target, zero
0012ed 9220 28a1                 	sts pulse2_fx_3xx_target+1, zero
0012ef 9220 28a2                 	sts pulse2_fx_3xx_speed, zero
0012f1 9220 28a3                 	sts pulse2_fx_3xx_speed+1, zero
0012f3 9220 28a4                 	sts pulse2_fx_3xx_total_offset, zero
0012f5 9220 28a5                 	sts pulse2_fx_3xx_total_offset+1, zero
0012f7 9220 28a6                 	sts pulse2_fx_4xy_speed, zero
0012f9 9220 28a7                 	sts pulse2_fx_4xy_depth, zero
0012fb 9220 28a8                 	sts pulse2_fx_4xy_phase, zero
0012fd 9220 28a9                 	sts pulse2_fx_7xy_speed, zero
0012ff 9220 28aa                 	sts pulse2_fx_7xy_depth, zero
001301 9220 28ab                 	sts pulse2_fx_7xy_phase, zero
001303 9220 28ac                 	sts pulse2_fx_7xy_value, zero
001305 9220 28ad                 	sts pulse2_fx_Axy, zero
001307 93c0 28ae                 	sts pulse2_fx_Gxx_pre, r28
001309 93c0 28af                 	sts pulse2_fx_Gxx_post, r28
00130b 9220 28b0                 	sts pulse2_fx_Pxx_total, zero
00130d 9220 28b1                 	sts pulse2_fx_Pxx_total+1, zero
00130f 9220 28b2                 	sts pulse2_fx_Qxy_target, zero
001311 9220 28b3                 	sts pulse2_fx_Qxy_target+1, zero
001313 9220 28b4                 	sts pulse2_fx_Qxy_speed, zero
001315 9220 28b5                 	sts pulse2_fx_Qxy_speed+1, zero
001317 9220 28b6                 	sts pulse2_fx_Qxy_total_offset, zero
001319 9220 28b7                 	sts pulse2_fx_Qxy_total_offset+1, zero
00131b 9220 28b8                 	sts pulse2_fx_Rxy_target, zero
00131d 9220 28b9                 	sts pulse2_fx_Rxy_target+1, zero
00131f 9220 28ba                 	sts pulse2_fx_Rxy_speed, zero
001321 9220 28bb                 	sts pulse2_fx_Rxy_speed+1, zero
001323 9220 28bc                 	sts pulse2_fx_Rxy_total_offset, zero
001325 9220 28bd                 	sts pulse2_fx_Rxy_total_offset+1, zero
001327 93c0 28be                 	sts pulse2_fx_Sxx_pre, r28
001329 93c0 28bf                 	sts pulse2_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 2 instrument macros
00132b efcf                      	ldi r28, 0xFF
00132c 9220 28c8                 	sts triangle_volume_macro_offset, zero
00132e 93c0 28c9                 	sts triangle_volume_macro_loop, r28
001330 93c0 28ca                 	sts triangle_volume_macro_release, r28
001332 9220 28cd                 	sts triangle_arpeggio_macro_offset, zero
001334 93c0 28ce                 	sts triangle_arpeggio_macro_loop, r28
001336 93c0 28cf                 	sts triangle_arpeggio_macro_release, r28
001338 93c0 28d0                 	sts triangle_arpeggio_macro_mode, r28
00133a 9220 28d5                 	sts triangle_pitch_macro_offset, zero
00133c 93c0 28d6                 	sts triangle_pitch_macro_loop, r28
00133e 93c0 28d7                 	sts triangle_pitch_macro_release, r28
001340 9220 28db                 	sts triangle_hi_pitch_macro_offset, zero
001342 93c0 28dc                 	sts triangle_hi_pitch_macro_loop, r28
001344 93c0 28dd                 	sts triangle_hi_pitch_macro_release, r28
001346 9220 28e0                 	sts triangle_duty_macro_offset, zero
001348 93c0 28e1                 	sts triangle_duty_macro_loop, r28
00134a 93c0 28e2                 	sts triangle_duty_macro_release, r28
                                 
00134c 9220 28c6                 	sts triangle_volume_macro, zero
00134e 9220 28c7                 	sts triangle_volume_macro+1, zero
001350 9220 28cb                 	sts triangle_arpeggio_macro, zero
001352 9220 28cc                 	sts triangle_arpeggio_macro+1, zero
001354 9220 28d1                 	sts triangle_total_pitch_offset, zero
001356 9220 28d2                 	sts triangle_total_pitch_offset+1, zero
001358 9220 28d3                 	sts triangle_pitch_macro, zero
00135a 9220 28d4                 	sts triangle_pitch_macro+1, zero
00135c 9220 28d8                 	sts triangle_total_hi_pitch_offset, zero
00135e 9220 28d9                 	sts triangle_hi_pitch_macro, zero
001360 9220 28da                 	sts triangle_hi_pitch_macro+1, zero
001362 9220 28de                 	sts triangle_duty_macro, zero
001364 9220 28df                 	sts triangle_duty_macro+1, zero
                                 
                                 	//CHANNEL 2 SEQUENCE
001366 e0c0                      	ldi r28, 0b00000000 //reset sequence to 0
001367 2f4c                      	mov triangle_sequence, r28
                                 
                                 	//CHANNEL 2 FX
001368 efcf                      	ldi r28, 0xFF
001369 9220 28e3                 	sts triangle_fx_0xy_sequence, zero
00136b 9220 28e4                 	sts triangle_fx_0xy_sequence+1, zero
00136d 9220 28e5                 	sts triangle_fx_1xx, zero
00136f 9220 28e6                 	sts triangle_fx_1xx+1, zero
001371 9220 28e7                 	sts triangle_fx_1xx_total, zero
001373 9220 28e8                 	sts triangle_fx_1xx_total+1, zero
001375 9220 28e9                 	sts triangle_fx_2xx, zero
001377 9220 28ea                 	sts triangle_fx_2xx+1, zero
001379 9220 28eb                 	sts triangle_fx_2xx_total, zero
00137b 9220 28ec                 	sts triangle_fx_2xx_total+1, zero
00137d 9220 28ed                 	sts triangle_fx_3xx_start, zero
00137f 9220 28ee                 	sts triangle_fx_3xx_start+1, zero
001381 9220 28ef                 	sts triangle_fx_3xx_target, zero
001383 9220 28f0                 	sts triangle_fx_3xx_target+1, zero
001385 9220 28f1                 	sts triangle_fx_3xx_speed, zero
001387 9220 28f2                 	sts triangle_fx_3xx_speed+1, zero
001389 9220 28f3                 	sts triangle_fx_3xx_total_offset, zero
00138b 9220 28f4                 	sts triangle_fx_3xx_total_offset+1, zero
00138d 9220 28f5                 	sts triangle_fx_4xy_speed, zero
00138f 9220 28f6                 	sts triangle_fx_4xy_depth, zero
001391 9220 28f7                 	sts triangle_fx_4xy_phase, zero
001393 93c0 28f8                 	sts triangle_fx_Gxx_pre, r28
001395 93c0 28f9                 	sts triangle_fx_Gxx_post, r28
001397 9220 28fa                 	sts triangle_fx_Pxx_total, zero
001399 9220 28fb                 	sts triangle_fx_Pxx_total+1, zero
00139b 9220 28fc                 	sts triangle_fx_Qxy_target, zero
00139d 9220 28fd                 	sts triangle_fx_Qxy_target+1, zero
00139f 9220 28fe                 	sts triangle_fx_Qxy_speed, zero
0013a1 9220 28ff                 	sts triangle_fx_Qxy_speed+1, zero
0013a3 9220 2900                 	sts triangle_fx_Qxy_total_offset, zero
0013a5 9220 2901                 	sts triangle_fx_Qxy_total_offset+1, zero
0013a7 9220 2902                 	sts triangle_fx_Rxy_target, zero
0013a9 9220 2903                 	sts triangle_fx_Rxy_target+1, zero
0013ab 9220 2904                 	sts triangle_fx_Rxy_speed, zero
0013ad 9220 2905                 	sts triangle_fx_Rxy_speed+1, zero
0013af 9220 2906                 	sts triangle_fx_Rxy_total_offset, zero
0013b1 9220 2907                 	sts triangle_fx_Rxy_total_offset+1, zero
0013b3 93c0 2908                 	sts triangle_fx_Sxx_pre, r28
0013b5 93c0 2909                 	sts triangle_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 3 instrument macros
0013b7 efcf                      	ldi r28, 0xFF
0013b8 9220 2912                 	sts noise_volume_macro_offset, zero
0013ba 93c0 2913                 	sts noise_volume_macro_loop, r28
0013bc 93c0 2914                 	sts noise_volume_macro_release, r28
0013be 9220 2917                 	sts noise_arpeggio_macro_offset, zero
0013c0 93c0 2918                 	sts noise_arpeggio_macro_loop, r28
0013c2 93c0 2919                 	sts noise_arpeggio_macro_release, r28
0013c4 93c0 291a                 	sts noise_arpeggio_macro_mode, r28
0013c6 9220 291f                 	sts noise_pitch_macro_offset, zero
0013c8 93c0 2920                 	sts noise_pitch_macro_loop, r28
0013ca 93c0 2921                 	sts noise_pitch_macro_release, r28
0013cc 9220 2925                 	sts noise_hi_pitch_macro_offset, zero
0013ce 93c0 2926                 	sts noise_hi_pitch_macro_loop, r28
0013d0 93c0 2927                 	sts noise_hi_pitch_macro_release, r28
0013d2 9220 292a                 	sts noise_duty_macro_offset, zero
0013d4 93c0 292b                 	sts noise_duty_macro_loop, r28
0013d6 93c0 292c                 	sts noise_duty_macro_release, r28
                                 
0013d8 9220 2910                 	sts noise_volume_macro, zero
0013da 9220 2911                 	sts noise_volume_macro+1, zero
0013dc 9220 2915                 	sts noise_arpeggio_macro, zero
0013de 9220 2916                 	sts noise_arpeggio_macro+1, zero
0013e0 9220 291b                 	sts noise_total_pitch_offset, zero
0013e2 9220 291c                 	sts noise_total_pitch_offset+1, zero
0013e4 9220 291d                 	sts noise_pitch_macro, zero
0013e6 9220 291e                 	sts noise_pitch_macro+1, zero
0013e8 9220 2922                 	sts noise_total_hi_pitch_offset, zero
0013ea 9220 2923                 	sts noise_hi_pitch_macro, zero
0013ec 9220 2924                 	sts noise_hi_pitch_macro+1, zero
0013ee 9220 2928                 	sts noise_duty_macro, zero
0013f0 9220 2929                 	sts noise_duty_macro+1, zero
                                 
                                 	//CHANNEL 3 VOLUME
0013f2 9220 2816                 	sts noise_output_volume, zero
0013f4 93c0 2815                 	sts noise_fractional_volume, r28 //initialize fractional volume to max value
                                 
                                 	//CHANNEL 3 SEQUENCE
0013f6 e0c1                      	ldi r28, 0b00000001 //noise sequence is reset to 0x0001
0013f7 2f5c                      	mov noise_sequence_LOW, r28
0013f8 2d62                      	mov noise_sequence_HIGH, zero
                                 
                                 	//CHANNEL 3 FX
0013f9 efcf                      	ldi r28, 0xFF
0013fa 9220 292d                 	sts noise_fx_0xy_sequence, zero
0013fc 9220 292e                 	sts noise_fx_0xy_sequence+1, zero
0013fe 9220 292f                 	sts noise_fx_1xx, zero
001400 9220 2930                 	sts noise_fx_1xx+1, zero
001402 9220 2931                 	sts noise_fx_1xx_total, zero
001404 9220 2932                 	sts noise_fx_1xx_total+1, zero
001406 9220 2933                 	sts noise_fx_2xx, zero
001408 9220 2934                 	sts noise_fx_2xx+1, zero
00140a 9220 2935                 	sts noise_fx_2xx_total, zero
00140c 9220 2936                 	sts noise_fx_2xx_total+1, zero
00140e 9220 2937                 	sts noise_fx_3xx_start, zero
001410 9220 2938                 	sts noise_fx_3xx_start+1, zero
001412 9220 2939                 	sts noise_fx_3xx_target, zero
001414 9220 293a                 	sts noise_fx_3xx_target+1, zero
001416 9220 293b                 	sts noise_fx_3xx_speed, zero
001418 9220 293c                 	sts noise_fx_3xx_speed+1, zero
00141a 9220 293d                 	sts noise_fx_3xx_total_offset, zero
00141c 9220 293e                 	sts noise_fx_3xx_total_offset+1, zero
00141e 9220 293f                 	sts noise_fx_4xy_speed, zero
001420 9220 2940                 	sts noise_fx_4xy_depth, zero
001422 9220 2941                 	sts noise_fx_4xy_phase, zero
001424 9220 2942                 	sts noise_fx_7xy_speed, zero
001426 9220 2943                 	sts noise_fx_7xy_depth, zero
001428 9220 2944                 	sts noise_fx_7xy_phase, zero
00142a 9220 2945                 	sts noise_fx_7xy_value, zero
00142c 9220 2946                 	sts noise_fx_Axy, zero
00142e 93c0 2947                 	sts noise_fx_Gxx_pre, r28
001430 93c0 2948                 	sts noise_fx_Gxx_post, r28
001432 9220 2949                 	sts noise_fx_Pxx_total, zero
001434 9220 294a                 	sts noise_fx_Pxx_total+1, zero
001436 9220 294b                 	sts noise_fx_Qxy_target, zero
001438 9220 294c                 	sts noise_fx_Qxy_target+1, zero
00143a 9220 294d                 	sts noise_fx_Qxy_speed, zero
00143c 9220 294e                 	sts noise_fx_Qxy_speed+1, zero
00143e 9220 294f                 	sts noise_fx_Qxy_total_offset, zero
001440 9220 2950                 	sts noise_fx_Qxy_total_offset+1, zero
001442 9220 2951                 	sts noise_fx_Rxy_target, zero
001444 9220 2952                 	sts noise_fx_Rxy_target+1, zero
001446 9220 2953                 	sts noise_fx_Rxy_speed, zero
001448 9220 2954                 	sts noise_fx_Rxy_speed+1, zero
00144a 9220 2955                 	sts noise_fx_Rxy_total_offset, zero
00144c 9220 2956                 	sts noise_fx_Rxy_total_offset+1, zero
00144e 93c0 2957                 	sts noise_fx_Sxx_pre, r28
001450 93c0 2958                 	sts noise_fx_Sxx_post, r28
                                 
                                 	//PINS
001452 efcf                      	ldi r28, 0xFF
001453 b9c0                      	out VPORTA_DIR, r28 //set all pins in VPORTA to output
                                 
                                 	//TIMERS
                                 	//Frame Counter
                                 	//NOTE:The frame counter will be defaulted to NTSC mode (60 Hz, 120 Hz, 240 Hz)
                                 	//Each interrupt will be setup to interrupt every 240 Hz clock
                                 	//CMP0 = sequence 0, CMP1 = sequence 1, CMP2 = sequence 2, OVF = sequence 3/sound driver
                                 	//Sequence 3 will clock the sound driver every 60Hz, in which new audio data is read and written to the registers
                                 	//Timer period Calculation: (0.00416666666 * 20000000/64)-1 = 1301.08333125 = 0x0515
                                 	//The ATmega4809 is cofigured to run at 20000000 Hz
                                 	//0.00416666666 seconds is the period for 240 Hz
                                 	//The /64 comes from the prescaler divider used
001454 e7c0                      	ldi r28, TCA_SINGLE_CMP0EN_bm | TCA_SINGLE_CMP1EN_bm | TCA_SINGLE_CMP2EN_bm | TCA_SINGLE_WGMODE_NORMAL_gc //interrupt mode
001455 93c0 0a01                 	sts TCA0_SINGLE_CTRLB, r28
001457 e7c1                      	ldi r28, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP1_bm | TCA_SINGLE_CMP2_bm | TCA_SINGLE_OVF_bm //enable overflow and compare interrupts
001458 93c0 0a0a                 	sts TCA0_SINGLE_INTCTRL, r28
00145a e1c5                      	ldi r28, 0x15 //set the period for CMP0
00145b 93c0 0a28                 	sts TCA0_SINGLE_CMP0, r28
00145d e0c5                      	ldi r28, 0x05
00145e 93c0 0a29                 	sts TCA0_SINGLE_CMP0 + 1, r28
001460 e2cb                      	ldi r28, 0x2B //set the period for CMP1
001461 93c0 0a2a                 	sts TCA0_SINGLE_CMP1, r28
001463 e0ca                      	ldi r28, 0x0A
001464 93c0 0a2b                 	sts TCA0_SINGLE_CMP1 + 1, r28
001466 e4c1                      	ldi r28, 0x41 //set the period for CMP2
001467 93c0 0a2c                 	sts TCA0_SINGLE_CMP2, r28
001469 e0cf                      	ldi r28, 0x0F
00146a 93c0 0a2d                 	sts TCA0_SINGLE_CMP2 + 1, r28
00146c e5c7                      	ldi r28, 0x57 //set the period for OVF
00146d 93c0 0a26                 	sts TCA0_SINGLE_PER, r28
00146f e1c4                      	ldi r28, 0x14
001470 93c0 0a27                 	sts TCA0_SINGLE_PER + 1, r28
001472 e0cb                      	ldi r28, TCA_SINGLE_CLKSEL_DIV64_gc | TCA_SINGLE_ENABLE_bm //use prescale divider of 64 and enable timer
001473 93c0 0a00                 	sts TCA0_SINGLE_CTRLA, r28
                                 
                                 	//NOTE: Channel Timers are clocked (20/2)/(0.8948865) = 11.1746014718 times faster than the NES APU
                                 	//Because of this, we multiply all the NES timer values by 11.1746014718 beforehand
                                 	//Since we rotate the sequence when the timer goes from t-(t-1) to 0, instead of 0 to t like the NES, we add 1 to the NES timers before multiplying
                                 	//The ATmega4809 is configured to run at 20 MHz
                                 	//The /2 comes from the prescaler divider used
                                 	//0.8948865 MHz is the speed of the NTSC NES APU
                                 	//NOTE: This means that any offset to the pitch for the NES timers would be multiplied by 11.1746014718 aswell.
                                 	//Pulse 1
001475 e0c0                      	ldi r28, TCB_CNTMODE_INT_gc //interrupt mode
001476 93c0 0a81                 	sts TCB0_CTRLB, r28
001478 e0c1                      	ldi r28, TCB_CAPT_bm //enable interrupts
001479 93c0 0a85                 	sts TCB0_INTCTRL, r28
00147b 91c0 2802                 	lds r28, pulse1_timerL //load the LOW bits for timer
00147d 93c0 0a8c                 	sts TCB0_CCMPL, r28
00147f 91c0 2803                 	lds r28, pulse1_timerH //load the HIGH bits for timer
001481 93c0 0a8d                 	sts TCB0_CCMPH, r28
001483 e0c3                      	ldi r28, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
001484 93c0 0a80                 	sts TCB0_CTRLA, r28
                                 
                                 	//PULSE 2
001486 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
001487 93b0 0a91                 	sts TCB1_CTRLB, r27
001489 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
00148a 93b0 0a95                 	sts TCB1_INTCTRL, r27
00148c 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
00148e 93b0 0a9c                 	sts TCB1_CCMPL, r27
001490 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
001492 93b0 0a9d                 	sts TCB1_CCMPH, r27
001494 e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
001495 93b0 0a90                 	sts TCB1_CTRLA, r27
                                 
                                 	//NOTE: The triangle timer is clocked at the same speed as the NES CPU, aka twice the NES APU.
                                 	//Therefore, we won't be using a /2 clock divider like we did with the pulse timers.
                                 	//TRIANGLE
001497 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
001498 93b0 0aa1                 	sts TCB2_CTRLB, r27
00149a e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
                                 	//sts TCB2_INTCTRL, r27 //keep interrupts disabled to mute channel since triangle doesn't have volume bits
00149b 91b0 2810                 	lds r27, triangle_timerL //load the LOW bits for timer
00149d 93b0 0aac                 	sts TCB2_CCMPL, r27
00149f 91b0 2811                 	lds r27, triangle_timerH //load the HIGH bits for timer
0014a1 93b0 0aad                 	sts TCB2_CCMPH, r27
0014a3 e0b1                      	ldi r27, TCB_CLKSEL_CLKDIV1_gc | TCB_ENABLE_bm //use prescaler divider of 1 and enable timer
0014a4 93b0 0aa0                 	sts TCB2_CTRLA, r27
0014a6 9478                      	sei //global interrupt enable
                                 
                                 	//NOISE
0014a7 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
0014a8 93b0 0ab1                 	sts TCB3_CTRLB, r27
0014aa e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
0014ab 93b0 0ab5                 	sts TCB3_INTCTRL, r27
0014ad 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
0014af 93b0 0abc                 	sts TCB3_CCMPL, r27
0014b1 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
0014b3 93b0 0abd                 	sts TCB3_CCMPH, r27
0014b5 e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
0014b6 93b0 0ab0                 	sts TCB3_CTRLA, r27
                                 
                                 
                                 
                                 //https://wiki.nesdev.com/w/index.php/APU_Mixer
                                 volume_mixer:
0014b8 91c0 2806                 	lds r28, pulse1_output_volume
0014ba 91d0 280e                 	lds r29, pulse2_output_volume
                                 
                                 volume_mixer_pulse1:
0014bc fea0                      	sbrs pulse1_sequence, 0 //if the sequence output is zero, return
0014bd c015                      	rjmp volume_mixer_pulse1_off
                                 
0014be 14b2                      	cp pulse1_length_counter, zero //if length is zero, return
0014bf f099                      	breq volume_mixer_pulse1_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
0014c0 91e0 0a8c                 	lds r30, TCB0_CCMPL
0014c2 e5f9                      	ldi r31, 0x059
0014c3 17ef                      	cp r30, r31
0014c4 91e0 0a8d                 	lds r30, TCB0_CCMPH
0014c6 e0f0                      	ldi r31, 0x00
0014c7 07ef                      	cpc r30, r31
0014c8 f050                      	brlo volume_mixer_pulse1_off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $5965
0014c9 91e0 0a8c                 	lds r30, TCB0_CCMPL
0014cb e6f6                      	ldi r31, 0x66
0014cc 17ef                      	cp r30, r31
0014cd 91e0 0a8d                 	lds r30, TCB0_CCMPH
0014cf e5f9                      	ldi r31, 0x59
0014d0 07ef                      	cpc r30, r31
0014d1 f408                      	brsh volume_mixer_pulse1_off
0014d2 c001                      	rjmp volume_mixer_pulse2 //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse1_off:
0014d3 27cc                      	clr r28
                                 
                                 volume_mixer_pulse2:
0014d4 fed0                      	sbrs pulse2_sequence, 0 //if the sequence output is zero, return
0014d5 c015                      	rjmp volume_mixer_pulse2_off
                                 
0014d6 14e2                      	cp pulse2_length_counter, zero //if length is zero, return
0014d7 f099                      	breq volume_mixer_pulse2_off
                                 
0014d8 91e0 0a9c                 	lds r30, TCB1_CCMPL
0014da e5f9                      	ldi r31, 0x059
0014db 17ef                      	cp r30, r31
0014dc 91e0 0a9d                 	lds r30, TCB1_CCMPH
0014de e0f0                      	ldi r31, 0x00
0014df 07ef                      	cpc r30, r31
0014e0 f050                      	brlo volume_mixer_pulse2_off
                                 
0014e1 91e0 0a9c                 	lds r30, TCB1_CCMPL
0014e3 e6f6                      	ldi r31, 0x66
0014e4 17ef                      	cp r30, r31
0014e5 91e0 0a9d                 	lds r30, TCB1_CCMPH
0014e7 e5f9                      	ldi r31, 0x59
0014e8 07ef                      	cpc r30, r31
0014e9 f408                      	brsh volume_mixer_pulse2_off
0014ea c001                      	rjmp volume_mixer_pulse_out //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse2_off:
0014eb 27dd                      	clr r29
                                 
                                 volume_mixer_pulse_out:
0014ec 0fcd                      	add r28, r29
0014ed e6e2                      	ldi ZL, LOW(pulse_volume_table << 1)
0014ee e0f2                      	ldi ZH, HIGH(pulse_volume_table << 1)
0014ef 0fec                      	add ZL, r28
0014f0 1df2                      	adc ZH, zero
0014f1 91c4                      	lpm r28, Z
                                 
                                 volume_mixer_tnd_triangle:
0014f2 2fd4                      	mov r29, triangle_sequence
0014f3 fdd4                      	sbrc r29, 4 //check 5th bit
0014f4 95d0                      	com r29
0014f5 70df                      	andi r29, 0x0F
0014f6 2fed                      	mov r30, r29
0014f7 0fde                      	add r29, r30 //multiply the triangle volume by 3
0014f8 0fde                      	add r29, r30
                                 
                                 volume_mixer_tnd_noise:
0014f9 ff50                      	sbrs noise_sequence_LOW, 0 //check 0th bit, skip if set
0014fa c004                      	rjmp volume_mixer_tnd_out
0014fb 91e0 2816                 	lds r30, noise_output_volume
0014fd 0fee                      	lsl r30 //multiply noise volume by 2
0014fe 0fde                      	add r29, r30
                                 
                                 volume_mixer_tnd_out:
0014ff e8e2                      	ldi ZL, LOW(tnd_volume_table << 1)
001500 e0f2                      	ldi ZH, HIGH(tnd_volume_table << 1)
001501 0fed                      	add ZL, r29
001502 1df2                      	adc ZH, zero
001503 91d4                      	lpm r29, Z
                                 
                                 volume_mixer_output:
001504 0fcd                      	add r28, r29
001505 b9c1                      	out VPORTA_OUT, r28
001506 cfb1                      	rjmp volume_mixer
                                 
                                 
                                 
                                 //FRAME COUNTER/AUDIO SAMPLE ISR
                                 sequence_0_2:
001507 b7bf                      	in r27, CPU_SREG
001508 93bf                      	push r27
001509 94f8                      	cli
                                 
                                 	//ENVELOPE
00150a d053                      	rcall pulse1_envelope_routine
00150b d09f                      	rcall pulse2_envelope_routine
                                 
00150c e5b0                      	ldi r27, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP2_bm //clear OVF flag
00150d 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
00150f 91bf                      	pop r27
001510 bfbf                      	out CPU_SREG, r27
001511 9518                      	reti
                                 
                                 sequence_1_3:
001512 b7bf                      	in r27, CPU_SREG
001513 93bf                      	push r27
001514 94f8                      	cli
                                 
                                 	//ENVELOPE
001515 d048                      	rcall pulse1_envelope_routine
001516 d094                      	rcall pulse2_envelope_routine
                                 
                                 	//SWEEP
001517 fcc3                      	sbrc pulse1_sweep, 3 //check if the sweep enable bit is cleared
001518 d01b                      	rcall pulse1_sweep_routine
001519 fcf3                      	sbrc pulse2_sweep, 3
00151a d066                      	rcall pulse2_sweep_routine
                                 
                                 	//LENGTH
                                 	//NOTE: The length routine is relatively simple, so we will not be using clocks to rjmp and ret to a seperate lable
                                 sequence_1_3_pulse1_length:
00151b fd95                      	sbrc pulse_channel_flags, 5 //check if the length counter halt bit is cleared
00151c c002                      	rjmp sequence_1_3_pulse2_length
00151d 10b2                      	cpse pulse1_length_counter, zero //if length counter is already 0, don't decrement
00151e 94ba                      	dec pulse1_length_counter
                                 sequence_1_3_pulse2_length:
00151f fd91                      	sbrc pulse_channel_flags, 1 //check if the length counter halt bit is cleared
001520 c002                      	rjmp sequence_1_3_exit
001521 10e2                      	cpse pulse2_length_counter, zero //if length counter is already 0, don't decrement
001522 94ea                      	dec pulse2_length_counter
                                 
                                 sequence_1_3_exit:
001523 e2b1                      	ldi r27, TCA_SINGLE_CMP1_bm | TCA_SINGLE_OVF_bm //clear OVF flag
001524 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
001526 91bf                      	pop r27
001527 bfbf                      	out CPU_SREG, r27
001528 9518                      	reti
                                 
                                 //PULSE 1 ROUTINES
                                 pulse1_sequence_routine:
001529 b7bf                      	in r27, CPU_SREG
00152a 93bf                      	push r27
00152b 94f8                      	cli
                                 
00152c 0caa                      	lsl pulse1_sequence //shifts sequence to the left
00152d 1ca2                      	adc pulse1_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
00152e e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
00152f 93b0 0a86                 	sts TCB0_INTFLAGS, r27
001531 91bf                      	pop r27
001532 bfbf                      	out CPU_SREG, r27
001533 9518                      	reti
                                 
                                 pulse1_sweep_routine:
001534 2dbc                      	mov r27, pulse1_sweep
001535 70b7                      	andi r27, 0x07 //mask for period divider bits
001536 f4f9                      	brne pulse1_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse1_sweep_routine_action: //if the divider is == 0, update the pulse timer period
001537 93df                      	push r29
001538 2ddc                      	mov r29, pulse1_sweep
001539 95d2                      	swap r29
00153a 70d7                      	andi r29, 0x07 //mask for shift bits
00153b f411                      	brne pulse1_sweep_routine_action_main //shift != 0
00153c 91df                      	pop r29
00153d c019                      	rjmp pulse1_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse1_sweep_routine_action_main:
00153e 91a0 0a8c                 	lds r26, TCB0_CCMPL
001540 91b0 0a8d                 	lds r27, TCB0_CCMPH
                                 pulse1_sweep_routine_action_main_loop:
001542 95b6                      	lsr r27
001543 95a7                      	ror r26
001544 95da                      	dec r29
001545 f7e1                      	brne pulse1_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
001546 fec7                      	sbrs pulse1_sweep, 7 //check the negate flag
001547 c002                      	rjmp pulse1_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
001548 95a0                      	com r26 //pulse1 uses one's complement if the negate flag is set
001549 95b0                      	com r27
                                 
                                 pulse1_sweep_routine_action_main_add:
00154a 91d0 0a8c                 	lds r29, TCB0_CCMPL //perform addition to get new timer period
00154c 0fad                      	add r26, r29
00154d 91d0 0a8d                 	lds r29, TCB0_CCMPH
00154f 1fbd                      	adc r27, r29
                                 
001550 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new LOW bits for timer
001552 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new HIGH bits for timer
                                 	
001554 91df                      	pop r29
001555 c001                      	rjmp pulse1_sweep_routine_check_reload
                                 
                                 pulse1_sweep_routine_decrement_divider:
001556 94ca                      	dec pulse1_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse1_sweep_routine_check_reload:
001557 ff97                      	sbrs pulse_channel_flags, 7 //if the reload flag is set, reload the sweep divider
001558 9508                      	ret
                                 
                                 pulse1_sweep_reload:
001559 90c0 2801                 	lds pulse1_sweep, pulse1_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
00155b 94c2                      	swap pulse1_sweep //bring data from high byte to low byte
00155c 779f                      	cbr pulse_channel_flags, 0b10000000 //clear reload flag
00155d 9508                      	ret
                                 
                                 
                                 
                                 pulse1_envelope_routine:
00155e fd96                      	sbrc pulse_channel_flags, 6 //check if start flag is cleared
00155f c010                      	rjmp pulse1_envelope_routine_clear_start
                                 
001560 3000                      	cpi pulse1_volume_divider, 0x00 //check if the divider is 0
001561 f011                      	breq PC+3 //if the divider == 0, check loop flag
001562 950a                      	dec pulse1_volume_divider //if the divider != 0, decrement and return
001563 9508                      	ret
                                 
001564 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the divider == 0, reset the divider period
001566 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
001567 ff95                      	sbrs pulse_channel_flags, 5 //check if the loop flag is set
001568 c002                      	rjmp pulse1_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
001569 e01f                      	ldi pulse1_volume_decay, 0x0F //if the loop flag is set, reset decay and return
00156a 9508                      	ret
                                 
                                 pulse1_envelope_routine_decrement_decay:
00156b 3010                      	cpi pulse1_volume_decay, 0x00 //check if the decay is 0
00156c f409                      	brne PC+2 //if decay != 0, go decrement
00156d 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
00156e 951a                      	dec pulse1_volume_decay
00156f 9508                      	ret
                                 
                                 pulse1_envelope_routine_clear_start:
001570 7b9f                      	cbr pulse_channel_flags, 0b01000000 //if the start flag is set, clear it
001571 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the start flag is set, reset the divider period
001573 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
001574 e01f                      	ldi pulse1_volume_decay, 0x0F //if the start flag is set, reset decay
001575 9508                      	ret
                                 
                                 //PULSE 2 ROUTINES
                                 pulse2_sequence_routine:
001576 b7bf                      	in r27, CPU_SREG
001577 93bf                      	push r27
001578 94f8                      	cli
                                 
001579 0cdd                      	lsl pulse2_sequence //shifts sequence to the left
00157a 1cd2                      	adc pulse2_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
00157b e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
00157c 93b0 0a96                 	sts TCB1_INTFLAGS, r27
00157e 91bf                      	pop r27
00157f bfbf                      	out CPU_SREG, r27
001580 9518                      	reti
                                 
                                 pulse2_sweep_routine:
001581 2dbf                      	mov r27, pulse2_sweep
001582 70b7                      	andi r27, 0x07 //mask for period divider bits
001583 f4f9                      	brne pulse2_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse2_sweep_routine_action: //if the divider is == 0, update the pulse timer period
001584 93df                      	push r29
001585 2ddf                      	mov r29, pulse2_sweep
001586 95d2                      	swap r29
001587 70d7                      	andi r29, 0x07 //mask for shift bits
001588 f411                      	brne pulse2_sweep_routine_action_main //shift != 0
001589 91df                      	pop r29
00158a c019                      	rjmp pulse2_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse2_sweep_routine_action_main:
00158b 91a0 0a9c                 	lds r26, TCB1_CCMPL
00158d 91b0 0a9d                 	lds r27, TCB1_CCMPH
                                 pulse2_sweep_routine_action_main_loop:
00158f 95b6                      	lsr r27
001590 95a7                      	ror r26
001591 95da                      	dec r29
001592 f7e1                      	brne pulse2_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
001593 fef7                      	sbrs pulse2_sweep, 7 //check the negate flag
001594 c002                      	rjmp pulse2_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
001595 95a0                      	com r26 //pulse2 uses one's complement if the negate flag is set
001596 95b0                      	com r27
                                 
                                 pulse2_sweep_routine_action_main_add:
001597 91d0 0a9c                 	lds r29, TCB1_CCMPL //perform addition to get new timer period
001599 0fad                      	add r26, r29
00159a 91d0 0a9d                 	lds r29, TCB1_CCMPH
00159c 1fbd                      	adc r27, r29
                                 
00159d 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new LOW bits for timer
00159f 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new HIGH bits for timer
                                 	
0015a1 91df                      	pop r29
0015a2 c001                      	rjmp pulse2_sweep_routine_check_reload
                                 
                                 pulse2_sweep_routine_decrement_divider:
0015a3 94fa                      	dec pulse2_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse2_sweep_routine_check_reload:
0015a4 ff93                      	sbrs pulse_channel_flags, 3 //if the reload flag is set, reload the sweep divider
0015a5 9508                      	ret
                                 
                                 pulse2_sweep_reload:
0015a6 90f0 2809                 	lds pulse2_sweep, pulse2_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
0015a8 94f2                      	swap pulse2_sweep //bring data from high byte to low byte
0015a9 7f97                      	cbr pulse_channel_flags, 0b00001000 //clear reload flag
0015aa 9508                      	ret
                                 
                                 
                                 
                                 pulse2_envelope_routine:
0015ab fd92                      	sbrc pulse_channel_flags, 2 //check if start flag is cleared
0015ac c010                      	rjmp pulse2_envelope_routine_clear_start
                                 
0015ad 3020                      	cpi pulse2_volume_divider, 0x00 //check if the divider is 0
0015ae f011                      	breq PC+3 //if the divider == 0, check loop flag
0015af 952a                      	dec pulse2_volume_divider //if the divider != 0, decrement and return
0015b0 9508                      	ret
                                 
0015b1 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the divider == 0, reset the divider period
0015b3 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
0015b4 ff91                      	sbrs pulse_channel_flags, 1 //check if the loop flag is set
0015b5 c002                      	rjmp pulse2_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
0015b6 e03f                      	ldi pulse2_volume_decay, 0x0F //if the loop flag is set, reset decay and return
0015b7 9508                      	ret
                                 
                                 pulse2_envelope_routine_decrement_decay:
0015b8 3030                      	cpi pulse2_volume_decay, 0x00 //check if the decay is 0
0015b9 f409                      	brne PC+2 //if decay != 0, go decrement
0015ba 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
0015bb 953a                      	dec pulse2_volume_decay
0015bc 9508                      	ret
                                 
                                 pulse2_envelope_routine_clear_start:
0015bd 7f9b                      	cbr pulse_channel_flags, 0b00000100 //if the start flag is set, clear it
0015be 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the start flag is set, reset the divider period
0015c0 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
0015c1 e03f                      	ldi pulse2_volume_decay, 0x0F //if the start flag is set, reset decay
0015c2 9508                      	ret
                                 
                                 //TRIANGLE ROUTINES
                                 triangle_sequence_routine:
0015c3 b7bf                      	in r27, CPU_SREG
0015c4 93bf                      	push r27
0015c5 94f8                      	cli
                                 
0015c6 5f4f                      	subi triangle_sequence, -1 //increment sequence by 1
0015c7 714f                      	andi triangle_sequence, 0b00011111 //mask out bits 5, 6 and 7 NOTE: the sequence only needs bits 0-4.
                                 
0015c8 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
0015c9 93b0 0aa6                 	sts TCB2_INTFLAGS, r27
0015cb 91bf                      	pop r27
0015cc bfbf                      	out CPU_SREG, r27
0015cd 9518                      	reti
                                 
                                 //NOISE ROUTINES
                                 noise_sequence_routine:
0015ce b7bf                      	in r27, CPU_SREG
0015cf 93bf                      	push r27
0015d0 94f8                      	cli
                                 
0015d1 2fa5                      	mov r26, noise_sequence_LOW
0015d2 fd67                      	sbrc noise_sequence_HIGH, 7 //skip if MODE bit is clear
0015d3 c00b                      	rjmp noise_sequence_routine_mode_set
                                 
                                 noise_sequence_routine_mode_clear:
0015d4 95a6                      	lsr r26 //move the 1th bit to the 0th bit place
0015d5 27a5                      	eor r26, noise_sequence_LOW
0015d6 fda0                      	sbrc r26, 0 //skip if the EOR of bit 0 and 1 is clear
0015d7 c003                      	rjmp noise_sequence_routine_mode_clear_EOR_set
                                 
                                 noise_sequence_routine_mode_clear_EOR_clear:
0015d8 9566                      	lsr noise_sequence_HIGH
0015d9 9557                      	ror noise_sequence_LOW
0015da c013                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_clear_EOR_set:
0015db 9566                      	lsr noise_sequence_HIGH
0015dc 9557                      	ror noise_sequence_LOW
0015dd 6460                      	ori noise_sequence_HIGH, 0b01000000 //set the 14th bit
0015de c00f                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_set:
0015df 0faa                      	lsl r26
0015e0 1faa                      	rol r26
0015e1 1faa                      	rol r26 //move the 6th bit to the 0th bit place
0015e2 27a5                      	eor r26, noise_sequence_LOW
0015e3 fda0                      	sbrc r26, 0 //skip if the EOR of bit 0 and 1 is clear
0015e4 c005                      	rjmp noise_sequence_routine_mode_set_EOR_set
                                 
                                 noise_sequence_routine_mode_set_EOR_clear:
0015e5 776f                      	cbr noise_sequence_HIGH, 0b10000000 //clear the MODE flag
0015e6 9566                      	lsr noise_sequence_HIGH
0015e7 9557                      	ror noise_sequence_LOW
0015e8 6860                      	sbr noise_sequence_HIGH, 0b10000000 //set the MODE flag
0015e9 c004                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_set_EOR_set:
0015ea 9566                      	lsr noise_sequence_HIGH
0015eb 9557                      	ror noise_sequence_LOW
0015ec 6860                      	sbr noise_sequence_HIGH, 0b10000000 //set the MODE flag
0015ed c000                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_exit:
0015ee e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
0015ef 93b0 0ab6                 	sts TCB3_INTFLAGS, r27
0015f1 91bf                      	pop r27
0015f2 bfbf                      	out CPU_SREG, r27
0015f3 9518                      	reti
                                 
                                 //CONVERTERS
                                 //converts and loads 5 bit length to corresponding 8 bit length value into r29
                                 length_converter:
0015f4 ece0                      	ldi ZL, LOW(length << 1)
0015f5 e6f0                      	ldi ZH, HIGH(length << 1)
0015f6 0fed                      	add ZL, r29
0015f7 1df2                      	adc ZH, zero
0015f8 91d4                      	lpm r29, Z
0015f9 9508                      	ret
                                 
                                 //loads pulse sequence into r29
                                 duty_cycle_sequences:
0015fa eee0                      	ldi ZL, LOW(sequences << 1)
0015fb e6f0                      	ldi ZH, HIGH(sequences << 1)
0015fc 0fed                      	add ZL, r29
0015fd 1df2                      	adc ZH, zero
0015fe 91d4                      	lpm r29, Z
0015ff 9508                      	ret
                                 
                                 
                                 
                                 //SOUND DRIVER
                                 sound_driver:
001600 b7bf                      	in r27, CPU_SREG
001601 93bf                      	push r27
001602 94f8                      	cli
001603 93cf                      	push r28
001604 93df                      	push r29
001605 93ef                      	push r30
001606 93ff                      	push r31
                                 
                                 	//SOUND DRIVER
001607 91a0 281f                 	lds r26, song_fx_Bxx
001609 3faf                      	cpi r26, 0xFF //0xFF means that the flag is disabled
00160a f4a9                      	brne sound_driver_fx_Bxx_routine
00160b 91a0 2820                 	lds r26, song_fx_Cxx
00160d 11a2                      	cpse r26, zero
00160e c08b                      	rjmp sound_driver_fx_Cxx_routine
00160f 91a0 2821                 	lds r26, song_fx_Dxx
001611 11a2                      	cpse r26, zero
001612 c096                      	rjmp sound_driver_fx_Dxx_routine
                                 
001613 91a0 281a                 	lds r26, song_frame_offset
001615 91b0 281b                 	lds r27, song_frame_offset+1
001617 91c0 281c                 	lds r28, song_size
001619 91d0 281d                 	lds r29, song_size+1
00161b 17ac                      	cp r26, r28
00161c 07bd                      	cpc r27, r29
00161d f408                      	brsh sound_driver_fx_song_loop
00161e c101                      	rjmp sound_driver_channel0
                                 
                                 
                                 sound_driver_fx_song_loop:
00161f e0a0                      	ldi r26, 0x00
                                 sound_driver_fx_Bxx_routine:
001620 91e0 2818                 	lds ZL, song_frames
001622 91f0 2819                 	lds ZH, song_frames+1
001624 27cc                      	clr r28 //initialize r29:r28 to 0
001625 27dd                      	clr r29
001626 95a3                      	inc r26 //increment xx parameter by 1
                                 sound_driver_fx_Bxx_routine_loop:
001627 95aa                      	dec r26
001628 f011                      	breq sound_driver_fx_Bxx_routine_loop_exit //once r26 == 0, r29:r28 will hold Bxx*(5*2).
001629 962a                      	adiw r29:r28, 10 //increment the offset by 10 because 5 channels, and each address takes 2 bytes (5*2 = 10)
00162a cffc                      	rjmp sound_driver_fx_Bxx_routine_loop
                                 
                                 sound_driver_fx_Bxx_routine_loop_exit:
00162b 9622                      	adiw r29:r28, 2 //add 2 to skip the first 2 bytes (first 2 bytes is the song size)
00162c 93c0 281a                 	sts song_frame_offset, r28
00162e 93d0 281b                 	sts song_frame_offset+1, r29
001630 0fec                      	add ZL, r28
001631 1ffd                      	adc ZH, r29
                                 
001632 91a5                      	lpm r26, Z+ //load the address of the frame(pattern)
001633 91b5                      	lpm r27, Z+
001634 0faa                      	lsl r26
001635 1fbb                      	rol r27
001636 93a0 2822                 	sts pulse1_pattern, r26
001638 93b0 2823                 	sts pulse1_pattern+1, r27
00163a 91a5                      	lpm r26, Z+
00163b 91b5                      	lpm r27, Z+
00163c 0faa                      	lsl r26
00163d 1fbb                      	rol r27
00163e 93a0 2871                 	sts pulse2_pattern, r26
001640 93b0 2872                 	sts pulse2_pattern+1, r27
001642 91a5                      	lpm r26, Z+
001643 91b5                      	lpm r27, Z+
001644 0faa                      	lsl r26
001645 1fbb                      	rol r27
001646 93a0 28c0                 	sts triangle_pattern, r26
001648 93b0 28c1                 	sts triangle_pattern+1, r27
00164a 91a5                      	lpm r26, Z+
00164b 91b5                      	lpm r27, Z+
00164c 0faa                      	lsl r26
00164d 1fbb                      	rol r27
00164e 93a0 290a                 	sts noise_pattern, r26
001650 93b0 290b                 	sts noise_pattern+1, r27
                                 
001652 9220 2826                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001654 9220 2827                 	sts pulse1_pattern_offset+1, zero
001656 9220 2824                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
001658 9220 2825                 	sts pulse1_pattern_delay_frames, zero
00165a 9220 2875                 	sts pulse2_pattern_offset, zero
00165c 9220 2876                 	sts pulse2_pattern_offset+1, zero
00165e 9220 2873                 	sts pulse2_pattern_delay_rows, zero
001660 9220 2874                 	sts pulse2_pattern_delay_frames, zero
001662 9220 28c4                 	sts triangle_pattern_offset, zero
001664 9220 28c5                 	sts triangle_pattern_offset+1, zero
001666 9220 28c2                 	sts triangle_pattern_delay_rows, zero
001668 9220 28c3                 	sts triangle_pattern_delay_frames, zero
00166a 9220 290e                 	sts noise_pattern_offset, zero
00166c 9220 290f                 	sts noise_pattern_offset+1, zero
00166e 9220 290c                 	sts noise_pattern_delay_rows, zero
001670 9220 290d                 	sts noise_pattern_delay_frames, zero
                                 
001672 efaf                      	ldi r26, 0xFF
001673 93a0 285f                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
001675 93a0 2860                 	sts pulse1_fx_Gxx_post, r26
001677 93a0 286f                 	sts pulse1_fx_Sxx_pre, r26
001679 93a0 2870                 	sts pulse1_fx_Sxx_post, r26
00167b 93a0 28ae                 	sts pulse2_fx_Gxx_pre, r26
00167d 93a0 28af                 	sts pulse2_fx_Gxx_post, r26
00167f 93a0 28be                 	sts pulse2_fx_Sxx_pre, r26
001681 93a0 28bf                 	sts pulse2_fx_Sxx_post, r26
001683 93a0 28f8                 	sts triangle_fx_Gxx_pre, r26
001685 93a0 28f9                 	sts triangle_fx_Gxx_post, r26
001687 93a0 2908                 	sts triangle_fx_Sxx_pre, r26
001689 93a0 2909                 	sts triangle_fx_Sxx_post, r26
00168b 93a0 2947                 	sts noise_fx_Gxx_pre, r26
00168d 93a0 2948                 	sts noise_fx_Gxx_post, r26
00168f 93a0 2957                 	sts noise_fx_Sxx_pre, r26
001691 93a0 2958                 	sts noise_fx_Sxx_post, r26
                                 
001693 93a0 281f                 	sts song_fx_Bxx, r26 //reset all song effects
001695 9220 2820                 	sts song_fx_Cxx, zero
001697 9220 2821                 	sts song_fx_Dxx, zero
001699 c086                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_fx_Cxx_routine:
00169a 91ff                      	pop r31
00169b 91ef                      	pop r30
00169c 91df                      	pop r29
00169d 91cf                      	pop r28
00169e 91bf                      	pop r27
00169f bfbf                      	out CPU_SREG, r27
0016a0 94f8                      	cli //disable global interrupts
                                 		
0016a1 efaf                      	ldi r26, 0xFF
0016a2 93a0 281f                 	sts song_fx_Bxx, r26 //reset all song effects
0016a4 9220 2820                 	sts song_fx_Cxx, zero
0016a6 9220 2821                 	sts song_fx_Dxx, zero
0016a8 9518                      	reti
                                 
                                 sound_driver_fx_Dxx_routine:
0016a9 91e0 2818                 	lds ZL, song_frames
0016ab 91f0 2819                 	lds ZH, song_frames+1
0016ad 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
0016af 91b0 281b                 	lds r27, song_frame_offset+1
0016b1 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
0016b2 93a0 281a                 	sts song_frame_offset, r26
0016b4 93b0 281b                 	sts song_frame_offset+1, r27
0016b6 0fea                      	add ZL, r26
0016b7 1ffb                      	adc ZH, r27
                                 
0016b8 91a5                      	lpm r26, Z+ //load the address of the next pattern
0016b9 91b5                      	lpm r27, Z+
0016ba 0faa                      	lsl r26
0016bb 1fbb                      	rol r27
0016bc 93a0 2822                 	sts pulse1_pattern, r26
0016be 93b0 2823                 	sts pulse1_pattern+1, r27
0016c0 91a5                      	lpm r26, Z+
0016c1 91b5                      	lpm r27, Z+
0016c2 0faa                      	lsl r26
0016c3 1fbb                      	rol r27
0016c4 93a0 2871                 	sts pulse2_pattern, r26
0016c6 93b0 2872                 	sts pulse2_pattern+1, r27
0016c8 91a5                      	lpm r26, Z+
0016c9 91b5                      	lpm r27, Z+
0016ca 0faa                      	lsl r26
0016cb 1fbb                      	rol r27
0016cc 93a0 28c0                 	sts triangle_pattern, r26
0016ce 93b0 28c1                 	sts triangle_pattern+1, r27
0016d0 91a5                      	lpm r26, Z+
0016d1 91b5                      	lpm r27, Z+
0016d2 0faa                      	lsl r26
0016d3 1fbb                      	rol r27
0016d4 93a0 290a                 	sts noise_pattern, r26
0016d6 93b0 290b                 	sts noise_pattern+1, r27
                                 
0016d8 9220 2826                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
0016da 9220 2827                 	sts pulse1_pattern_offset+1, zero
0016dc 9220 2824                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
0016de 9220 2825                 	sts pulse1_pattern_delay_frames, zero
0016e0 9220 2875                 	sts pulse2_pattern_offset, zero
0016e2 9220 2876                 	sts pulse2_pattern_offset+1, zero
0016e4 9220 2873                 	sts pulse2_pattern_delay_rows, zero
0016e6 9220 2874                 	sts pulse2_pattern_delay_frames, zero
0016e8 9220 28c4                 	sts triangle_pattern_offset, zero
0016ea 9220 28c5                 	sts triangle_pattern_offset+1, zero
0016ec 9220 28c2                 	sts triangle_pattern_delay_rows, zero
0016ee 9220 28c3                 	sts triangle_pattern_delay_frames, zero
0016f0 9220 290e                 	sts noise_pattern_offset, zero
0016f2 9220 290f                 	sts noise_pattern_offset+1, zero
0016f4 9220 290c                 	sts noise_pattern_delay_rows, zero
0016f6 9220 290d                 	sts noise_pattern_delay_frames, zero
                                 
0016f8 efaf                      	ldi r26, 0xFF
0016f9 93a0 285f                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
0016fb 93a0 2860                 	sts pulse1_fx_Gxx_post, r26
0016fd 93a0 286f                 	sts pulse1_fx_Sxx_pre, r26
0016ff 93a0 2870                 	sts pulse1_fx_Sxx_post, r26
001701 93a0 28ae                 	sts pulse2_fx_Gxx_pre, r26
001703 93a0 28af                 	sts pulse2_fx_Gxx_post, r26
001705 93a0 28be                 	sts pulse2_fx_Sxx_pre, r26
001707 93a0 28bf                 	sts pulse2_fx_Sxx_post, r26
001709 93a0 28f8                 	sts triangle_fx_Gxx_pre, r26
00170b 93a0 28f9                 	sts triangle_fx_Gxx_post, r26
00170d 93a0 2908                 	sts triangle_fx_Sxx_pre, r26
00170f 93a0 2909                 	sts triangle_fx_Sxx_post, r26
001711 93a0 2947                 	sts noise_fx_Gxx_pre, r26
001713 93a0 2948                 	sts noise_fx_Gxx_post, r26
001715 93a0 2957                 	sts noise_fx_Sxx_pre, r26
001717 93a0 2958                 	sts noise_fx_Sxx_post, r26
                                 
001719 93a0 281f                 	sts song_fx_Bxx, r26 //reset all song effects
00171b 9220 2820                 	sts song_fx_Cxx, zero
00171d 9220 2821                 	sts song_fx_Dxx, zero
00171f c000                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0:
001720 91a0 2824                 	lds r26, pulse1_pattern_delay_rows
001722 91b0 2825                 	lds r27, pulse1_pattern_delay_frames
001724 9610                      	adiw r27:r26, 0
001725 f009                      	breq sound_driver_channel0_main //if the pattern delay is 0, proceed with sound driver procedures
001726 c2e4                      	rjmp sound_driver_channel0_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel0_main:
001727 91e0 2822                 	lds ZL, pulse1_pattern //current pattern for pulse 1
001729 91f0 2823                 	lds ZH, pulse1_pattern+1
00172b 91a0 2826                 	lds r26, pulse1_pattern_offset //current offset in the pattern for pulse 1
00172d 91b0 2827                 	lds r27, pulse1_pattern_offset+1
00172f 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001730 1ffb                      	adc ZH, r27
001731 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel0_check_if_note: //check if data is a note (0x00 - 0x56)
001732 35b7                      	cpi r27, 0x57
001733 f408                      	brsh sound_driver_channel0_check_if_volume
001734 c180                      	rjmp sound_driver_channel0_note
                                 sound_driver_channel0_check_if_volume: //check if data is volume (0x57-0x66)
001735 36b7                      	cpi r27, 0x67
001736 f408                      	brsh sound_driver_channel0_check_if_delay
001737 c1ba                      	rjmp sound_driver_channel0_volume
                                 sound_driver_channel0_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001738 3eb3                      	cpi r27, 0xE3
001739 f408                      	brsh sound_driver_channel0_check_if_instrument
00173a c1c1                      	rjmp sound_driver_channel0_delay
                                 sound_driver_channel0_check_if_instrument: //check for instrument flag (0xE3)
00173b f409                      	brne sound_driver_channel0_check_if_release
00173c c1c4                      	rjmp sound_driver_channel0_instrument_change 
                                 sound_driver_channel0_check_if_release: //check for note release flag (0xE4)
00173d 3eb4                      	cpi r27, 0xE4
00173e f409                      	brne sound_driver_channel0_check_if_end
00173f c26d                      	rjmp sound_driver_channel0_release
                                 sound_driver_channel0_check_if_end:
001740 3fbf                      	cpi r27, 0xFF
001741 f409                      	brne sound_driver_channel0_check_if_fx
001742 c28f                      	rjmp sound_driver_channel0_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel0_check_if_fx: //fx flags (0xE5 - 0xFE)
001743 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001744 91a4                      	lpm r26, Z //load the fx data into r26
001745 d2bb                      	rcall sound_driver_channel0_increment_offset_twice
                                 
001746 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001747 eee4                      	ldi ZL, LOW(channel0_fx << 1) //load in note table
001748 e6f0                      	ldi ZH, HIGH(channel0_fx << 1)
001749 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
00174a 0feb                      	add ZL, r27 //add offset
00174b 1df2                      	adc ZH, zero
00174c 91c5                      	lpm r28, Z+ //load address bytes
00174d 91d4                      	lpm r29, Z
00174e 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
00174f 2ffd                      	mov ZH, r29
001750 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel0_fx_0xy:
001751 93a0 2845                 	sts pulse1_fx_0xy_sequence, r26
001753 9220 2846                 	sts pulse1_fx_0xy_sequence+1, zero
001755 cfd1                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel0_fx_1xx:
001756 9220 284b                 	sts pulse1_fx_2xx, zero //turn off any 2xx pitch slide down
001758 9220 284c                 	sts pulse1_fx_2xx+1, zero
00175a 9220 2845                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
00175c 9220 2846                 	sts pulse1_fx_0xy_sequence+1, zero
00175e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00175f 937f                      	push r23
001760 2f6a                      	mov r22, r26 //store the rate into r22
001761 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001762 9f67                      	mul r22, r23
001763 917f                      	pop r23
001764 916f                      	pop r22
                                 
001765 9416                      	lsr r1 //shift out the fractional bits
001766 9407                      	ror r0
001767 9416                      	lsr r1
001768 9407                      	ror r0
001769 9416                      	lsr r1
00176a 9407                      	ror r0
00176b 9416                      	lsr r1
00176c 9407                      	ror r0
00176d 9200 2847                 	sts pulse1_fx_1xx, r0
00176f 9210 2848                 	sts pulse1_fx_1xx+1, r1
001771 cfb5                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel0_fx_2xx:
001772 9220 2847                 	sts pulse1_fx_1xx, zero //turn off any 1xx pitch slide down
001774 9220 2848                 	sts pulse1_fx_1xx+1, zero
001776 9220 2845                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
001778 9220 2846                 	sts pulse1_fx_0xy_sequence+1, zero
00177a 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00177b 937f                      	push r23
00177c 2f6a                      	mov r22, r26 //store the rate into r22
00177d eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00177e 9f67                      	mul r22, r23
00177f 917f                      	pop r23
001780 916f                      	pop r22
                                 
001781 9416                      	lsr r1 //shift out the fractional bits
001782 9407                      	ror r0
001783 9416                      	lsr r1
001784 9407                      	ror r0
001785 9416                      	lsr r1
001786 9407                      	ror r0
001787 9416                      	lsr r1
001788 9407                      	ror r0
001789 9200 284b                 	sts pulse1_fx_2xx, r0
00178b 9210 284c                 	sts pulse1_fx_2xx+1, r1
00178d cf99                      	rjmp sound_driver_channel0_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel0_fx_3xx:
00178e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00178f 937f                      	push r23
001790 2f6a                      	mov r22, r26 //store the rate into r22
001791 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001792 9f67                      	mul r22, r23
001793 917f                      	pop r23
001794 916f                      	pop r22
                                 
001795 9416                      	lsr r1 //shift out the fractional bits
001796 9407                      	ror r0
001797 9416                      	lsr r1
001798 9407                      	ror r0
001799 9416                      	lsr r1
00179a 9407                      	ror r0
00179b 9416                      	lsr r1
00179c 9407                      	ror r0
00179d 9200 2853                 	sts pulse1_fx_3xx_speed, r0
00179f 9210 2854                 	sts pulse1_fx_3xx_speed+1, r1
                                 
0017a1 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
0017a2 c001                      	rjmp sound_driver_channel0_fx_3xx_enabled
0017a3 cf83                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_3xx_enabled:
0017a4 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
0017a6 91b0 0a8d                 	lds r27, TCB0_CCMPH
0017a8 93a0 284f                 	sts pulse1_fx_3xx_start, r26
0017aa 93b0 2850                 	sts pulse1_fx_3xx_start+1, r27
                                 
0017ac 9220 2855                 	sts pulse1_fx_3xx_total_offset, zero
0017ae 9220 2856                 	sts pulse1_fx_3xx_total_offset+1, zero
0017b0 cf76                      	rjmp sound_driver_channel0_main
                                 
                                 //VIBRATO
                                 sound_driver_channel0_fx_4xy:
0017b1 2fba                      	mov r27, r26
0017b2 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
0017b3 95a2                      	swap r26
0017b4 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0017b5 93a0 2857                 	sts pulse1_fx_4xy_speed, r26
0017b7 93b0 2858                 	sts pulse1_fx_4xy_depth, r27
0017b9 9220 2859                 	sts pulse1_fx_4xy_phase, zero //reset the phase to 0
0017bb cf6b                      	rjmp sound_driver_channel0_main
                                 
                                 //TREMELO
                                 sound_driver_channel0_fx_7xy:
0017bc 2fba                      	mov r27, r26
0017bd 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
0017be 95a2                      	swap r26
0017bf 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0017c0 93a0 285a                 	sts pulse1_fx_7xy_speed, r26
0017c2 93b0 285b                 	sts pulse1_fx_7xy_depth, r27
0017c4 9220 285c                 	sts pulse1_fx_7xy_phase, zero //reset the phase to 0
0017c6 9220 285d                 	sts pulse1_fx_7xy_value, zero //reset the tremelo value
0017c8 cf5e                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel0_fx_Axy:
0017c9 93a0 285e                 	sts pulse1_fx_Axy, r26
0017cb cf5b                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel0_fx_Bxx:
0017cc 93a0 281f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
0017ce cf58                      	rjmp sound_driver_channel0_main
                                 
                                 //HALT
                                 sound_driver_channel0_fx_Cxx:
0017cf 93b0 2820                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
0017d1 cf55                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel0_fx_Dxx:
0017d2 93b0 2821                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
0017d4 cf52                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME
                                 sound_driver_channel0_fx_Exx:
0017d5 91b0 2800                 	lds r27, pulse1_param
0017d7 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
0017d8 2bba                      	or r27, r26 //move new VVVV bits into pulse1_param
0017d9 93b0 2800                 	sts pulse1_param, r27
0017db 6096                      	sbr pulse_channel_flags, 6
0017dc cf4a                      	rjmp sound_driver_channel0_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel0_fx_Fxx:
0017dd 93a0 281e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
0017df cf47                      	rjmp sound_driver_channel0_main
                                 
                                 //DELAY
                                 sound_driver_channel0_fx_Gxx:
0017e0 15a2                      	cp r26, zero
0017e1 f051                      	breq sound_driver_channel0_fx_Gxx_invalid
0017e2 91b0 281e                 	lds r27, song_speed
0017e4 17ab                      	cp r26, r27
0017e5 f430                      	brsh sound_driver_channel0_fx_Gxx_invalid
0017e6 93a0 285f                 	sts pulse1_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
0017e8 e0b1                      	ldi r27, 0x01
0017e9 93b0 2824                 	sts pulse1_pattern_delay_rows, r27
0017eb c222                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Gxx_invalid:
0017ec cf3a                      	rjmp sound_driver_channel0_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel0_fx_Hxy: //hardware sweep up
0017ed cf39                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixy: //hardware sweep down
0017ee cf38                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Hxx: //FDS modulation depth
0017ef cf37                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixx: //FDS modulation speed
0017f0 cf36                      	rjmp sound_driver_channel0_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel0_fx_Pxx:
0017f1 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0017f2 937f                      	push r23
0017f3 2f6a                      	mov r22, r26
0017f4 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0017f5 0367                      	mulsu r22, r23
0017f6 917f                      	pop r23
0017f7 916f                      	pop r22
0017f8 9416                      	lsr r1 //shift out the fractional bits
0017f9 9407                      	ror r0
0017fa 9416                      	lsr r1
0017fb 9407                      	ror r0
0017fc 9416                      	lsr r1
0017fd 9407                      	ror r0
0017fe 9416                      	lsr r1
0017ff 9407                      	ror r0
001800 fe13                      	sbrs r1, 3 //check if result was a negative number
001801 c002                      	rjmp sound_driver_channel0_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel0_fx_Pxx_negative:
001802 efb0                      	ldi r27, 0xF0
001803 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel0_fx_Pxx_store:
001804 9200 2861                 	sts pulse1_fx_Pxx_total, r0
001806 9210 2862                 	sts pulse1_fx_Pxx_total+1, r1
001808 cf1e                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel0_fx_Qxy:
                                 sound_driver_channel0_fx_Qxy_check_arpeggio_macro:
001809 91e0 282d                 	lds ZL, pulse1_arpeggio_macro
00180b 91f0 282e                 	lds ZH, pulse1_arpeggio_macro+1
00180d 9630                      	adiw Z, 0
00180e f009                      	breq sound_driver_channel0_fx_Qxy_check_pitch_macro
00180f cf17                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_pitch_macro:
001810 91e0 2835                 	lds ZL, pulse1_pitch_macro
001812 91f0 2836                 	lds ZH, pulse1_pitch_macro+1
001814 9630                      	adiw Z, 0
001815 f009                      	breq sound_driver_channel0_fx_Qxy_check_hi_pitch_macro
001816 cf10                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_hi_pitch_macro:
001817 91e0 283b                 	lds ZL, pulse1_hi_pitch_macro
001819 91f0 283c                 	lds ZH, pulse1_hi_pitch_macro+1
00181b 9630                      	adiw Z, 0
00181c f009                      	breq sound_driver_channel0_fx_Qxy_process
00181d cf09                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_process:
00181e 2fba                      	mov r27, r26 //copy fx parameters into r27
00181f 70bf                      	andi r27, 0x0F //mask note index offset
001820 91c0 2807                 	lds r28, pulse1_note //load current note index
001822 0fbc                      	add r27, r28
001823 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001824 f008                      	brlo sound_driver_channel0_fx_Qxy_process_continue
001825 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel0_fx_Qxy_process_continue:
001826 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001827 e0f0                      	ldi ZH, HIGH(note_table << 1)
001828 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001829 0feb                      	add ZL, r27 //add offset
00182a 1df2                      	adc ZH, zero
00182b 91c5                      	lpm r28, Z+ //load bytes
00182c 91d4                      	lpm r29, Z
00182d 93c0 2863                 	sts pulse1_fx_Qxy_target, r28 //load the LOW bits for the target period
00182f 93d0 2864                 	sts pulse1_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
001831 95a2                      	swap r26
001832 70af                      	andi r26, 0x0F //mask effect speed
001833 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001834 95a3                      	inc r26 //increment the speed by 1
                                 
001835 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001836 937f                      	push r23
001837 2f6a                      	mov r22, r26 //store the speed data into r27
001838 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001839 9f67                      	mul r22, r23
00183a 917f                      	pop r23
00183b 916f                      	pop r22
                                 
00183c 9416                      	lsr r1 //shift out the fractional bits
00183d 9407                      	ror r0
00183e 9416                      	lsr r1
00183f 9407                      	ror r0
001840 9416                      	lsr r1
001841 9407                      	ror r0
001842 9416                      	lsr r1
001843 9407                      	ror r0
                                 
001844 9200 2865                 	sts pulse1_fx_Qxy_speed, r0 //store the effect speed
001846 9210 2866                 	sts pulse1_fx_Qxy_speed+1, r1
001848 9220 2867                 	sts pulse1_fx_Qxy_total_offset, zero
00184a 9220 2868                 	sts pulse1_fx_Qxy_total_offset+1, zero
00184c ceda                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel0_fx_Rxy:
                                 sound_driver_channel0_fx_Rxy_check_arpeggio_macro:
00184d 91e0 282d                 	lds ZL, pulse1_arpeggio_macro
00184f 91f0 282e                 	lds ZH, pulse1_arpeggio_macro+1
001851 9630                      	adiw Z, 0
001852 f009                      	breq sound_driver_channel0_fx_Rxy_check_pitch_macro
001853 ced3                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_pitch_macro:
001854 91e0 2835                 	lds ZL, pulse1_pitch_macro
001856 91f0 2836                 	lds ZH, pulse1_pitch_macro+1
001858 9630                      	adiw Z, 0
001859 f009                      	breq sound_driver_channel0_fx_Rxy_check_hi_pitch_macro
00185a cecc                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_hi_pitch_macro:
00185b 91e0 283b                 	lds ZL, pulse1_hi_pitch_macro
00185d 91f0 283c                 	lds ZH, pulse1_hi_pitch_macro+1
00185f 9630                      	adiw Z, 0
001860 f009                      	breq sound_driver_channel0_fx_Rxy_process
001861 cec5                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_process:
001862 2fba                      	mov r27, r26 //copy fx parameters into r27
001863 70bf                      	andi r27, 0x0F //mask note index offset
001864 91c0 2807                 	lds r28, pulse1_note //load current note index
001866 1bcb                      	sub r28, r27
001867 f408                      	brcc sound_driver_channel0_fx_Rxy_process_continue
001868 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel0_fx_Rxy_process_continue:
001869 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
00186a e0f0                      	ldi ZH, HIGH(note_table << 1)
00186b 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
00186c 0fec                      	add ZL, r28 //add offset
00186d 1df2                      	adc ZH, zero
00186e 91c5                      	lpm r28, Z+ //load bytes
00186f 91d4                      	lpm r29, Z
001870 93c0 2869                 	sts pulse1_fx_Rxy_target, r28 //load the LOW bits for the target period
001872 93d0 286a                 	sts pulse1_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
001874 95a2                      	swap r26
001875 70af                      	andi r26, 0x0F //mask effect speed
001876 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001877 95a3                      	inc r26 //increment the speed by 1
                                 
001878 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001879 937f                      	push r23
00187a 2f6a                      	mov r22, r26 //store the speed data into r27
00187b eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00187c 9f67                      	mul r22, r23
00187d 917f                      	pop r23
00187e 916f                      	pop r22
                                 
00187f 9416                      	lsr r1 //shift out the fractional bits
001880 9407                      	ror r0
001881 9416                      	lsr r1
001882 9407                      	ror r0
001883 9416                      	lsr r1
001884 9407                      	ror r0
001885 9416                      	lsr r1
001886 9407                      	ror r0
                                 
001887 9200 286b                 	sts pulse1_fx_Rxy_speed, r0 //store the effect speed
001889 9210 286c                 	sts pulse1_fx_Rxy_speed+1, r1
00188b 9220 286d                 	sts pulse1_fx_Rxy_total_offset, zero
00188d 9220 286e                 	sts pulse1_fx_Rxy_total_offset+1, zero
00188f ce97                      	rjmp sound_driver_channel0_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel0_fx_Sxx:
001890 15a2                      	cp r26, zero
001891 f051                      	breq sound_driver_channel0_fx_Sxx_invalid
001892 91b0 281e                 	lds r27, song_speed
001894 17ab                      	cp r26, r27
001895 f430                      	brsh sound_driver_channel0_fx_Sxx_invalid
001896 93a0 286f                 	sts pulse1_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001898 e0b1                      	ldi r27, 0x01
001899 93b0 2824                 	sts pulse1_pattern_delay_rows, r27
00189b c172                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Sxx_invalid:
00189c ce8a                      	rjmp sound_driver_channel0_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel0_fx_Vxx:
00189d eee0                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
00189e e6f0                      	ldi ZH, HIGH(sequences << 1)
00189f 0fea                      	add ZL, r26 //offset the pointer
0018a0 1df2                      	adc ZH, zero
                                 
0018a1 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
0018a2 95a7                      	ror r26
0018a3 95a7                      	ror r26
0018a4 91b0 2800                 	lds r27, pulse1_param //load r27 with pulse1_param (register $4000)
0018a6 2fcb                      	mov r28, r27 //store a copy of pulse1_param into r28
0018a7 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
0018a8 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
0018a9 c001                      	rjmp sound_driver_channel0_fx_Vxx_store
0018aa ce7c                      	rjmp sound_driver_channel0_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel0_fx_Vxx_store:
0018ab 90a4                      	lpm pulse1_sequence, Z //store the sequence
                                 
0018ac 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
0018ad 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
0018ae 93c0 2800                 	sts pulse1_param, r28
0018b0 ce76                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_Wxx: //DPCM sample speed
0018b1 ce75                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Xxx: //DPCM sample retrigger
0018b2 ce74                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Yxx: //DPCM sample offset
0018b3 ce73                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Zxx: //DPCM sample delta counter
0018b4 ce72                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 sound_driver_channel0_note:
0018b5 93b0 2807                 	sts pulse1_note, r27 //store the note index
0018b7 e0a3                      	ldi r26, 0x03
0018b8 e0b2                      	ldi r27, 0x02
0018b9 93b0 282a                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
0018bb 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26
0018bd 93b0 2837                 	sts pulse1_pitch_macro_offset, r27
0018bf 93b0 283d                 	sts pulse1_hi_pitch_macro_offset, r27
0018c1 93b0 2842                 	sts pulse1_duty_macro_offset, r27
0018c3 9220 2833                 	sts pulse1_total_pitch_offset, zero //reset the pitch and hi pitch offset
0018c5 9220 2834                 	sts pulse1_total_pitch_offset+1, zero
0018c7 9220 283a                 	sts pulse1_total_hi_pitch_offset, zero
0018c9 9220 2849                 	sts pulse1_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
0018cb 9220 284a                 	sts pulse1_fx_1xx_total+1, zero
0018cd 9220 284d                 	sts pulse1_fx_2xx_total, zero
0018cf 9220 284e                 	sts pulse1_fx_2xx_total+1, zero
0018d1 9220 2855                 	sts pulse1_fx_3xx_total_offset, zero //reset 3xx offset
0018d3 9220 2856                 	sts pulse1_fx_3xx_total_offset+1, zero
0018d5 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
0018d7 91b0 0a8d                 	lds r27, TCB0_CCMPH
0018d9 93a0 284f                 	sts pulse1_fx_3xx_start, r26
0018db 93b0 2850                 	sts pulse1_fx_3xx_start+1, r27
0018dd 9220 2801                 	sts pulse1_sweep_param, zero //reset any sweep effect
0018df 6097                      	sbr pulse_channel_flags, 7 //set reload flag
0018e0 9220 2863                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0018e2 9220 2864                 	sts pulse1_fx_Qxy_target+1, zero
0018e4 9220 2867                 	sts pulse1_fx_Qxy_total_offset, zero
0018e6 9220 2868                 	sts pulse1_fx_Qxy_total_offset+1, zero
0018e8 9220 2869                 	sts pulse1_fx_Rxy_target, zero
0018ea 9220 286a                 	sts pulse1_fx_Rxy_target+1, zero
0018ec 9220 286d                 	sts pulse1_fx_Rxy_total_offset, zero
0018ee 9220 286e                 	sts pulse1_fx_Rxy_total_offset+1, zero
0018f0 d106                      	rcall sound_driver_channel0_increment_offset
0018f1 ce35                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_volume:
0018f2 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
0018f3 91a0 2800                 	lds r26, pulse1_param
0018f5 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
0018f6 2bab                      	or r26, r27 //move new VVVV bits into pulse1_param
0018f7 93a0 2800                 	sts pulse1_param, r26
0018f9 6096                      	sbr pulse_channel_flags, 6
0018fa d0fc                      	rcall sound_driver_channel0_increment_offset
0018fb ce2b                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_delay:
0018fc 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
0018fd 93b0 2824                 	sts pulse1_pattern_delay_rows, r27
0018ff d0f7                      	rcall sound_driver_channel0_increment_offset
001900 c10d                      	rjmp sound_driver_channel1
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change:
001901 9220 2828                 	sts pulse1_volume_macro, zero //reset all macro addresses
001903 9220 2829                 	sts pulse1_volume_macro+1, zero
001905 9220 282d                 	sts pulse1_arpeggio_macro, zero
001907 9220 282e                 	sts pulse1_arpeggio_macro+1, zero
001909 9220 2835                 	sts pulse1_pitch_macro, zero
00190b 9220 2836                 	sts pulse1_pitch_macro+1, zero
00190d 9220 283b                 	sts pulse1_hi_pitch_macro, zero
00190f 9220 283c                 	sts pulse1_hi_pitch_macro+1, zero
001911 9220 2840                 	sts pulse1_duty_macro, zero
001913 9220 2841                 	sts pulse1_duty_macro+1, zero
001915 9220 2833                 	sts pulse1_total_pitch_offset, zero //reset the pitch offset
001917 9220 2834                 	sts pulse1_total_pitch_offset+1, zero
001919 9220 283a                 	sts pulse1_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
00191b 9631                      	adiw Z, 1 //point to the byte next to the flag
00191c 91b4                      	lpm r27, Z //store the instrument offset into r27
00191d e7e1                      	ldi ZL, LOW(instruments) //point Z to instruments table
00191e e1f0                      	ldi ZH, HIGH(instruments)
00191f 0feb                      	add ZL, r27 //point Z to offsetted instrument
001920 1df2                      	adc ZH, zero
001921 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001922 1fff                      	rol ZH
001923 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001924 91b4                      	lpm r27, Z
                                 
001925 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001926 1fbb                      	rol r27
001927 2fea                      	mov ZL, r26
001928 2ffb                      	mov ZH, r27
001929 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
00192a 9632                      	adiw Z, 2 //point Z to the address of the macro
00192b e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel0_instrument_change_macro_loop:
00192c 95aa                      	dec r26
00192d f019                      	breq sound_driver_channel0_instrument_change_exit
00192e 95b6                      	lsr r27
00192f f078                      	brcs sound_driver_channel0_instrument_change_load_macro
001930 cffb                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_exit:
001931 e0a3                      	ldi r26, 0x03
001932 e0b2                      	ldi r27, 0x02
001933 93b0 282a                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
001935 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26
001937 93b0 2837                 	sts pulse1_pitch_macro_offset, r27
001939 93b0 283d                 	sts pulse1_hi_pitch_macro_offset, r27
00193b 93b0 2842                 	sts pulse1_duty_macro_offset, r27
00193d d0c3                      	rcall sound_driver_channel0_increment_offset_twice
00193e cde8                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_load_macro:
00193f 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001940 91d5                      	lpm r29, Z+
                                 
001941 30a5                      	cpi r26, 5
001942 f039                      	breq sound_driver_channel0_instrument_change_load_macro_volume
001943 30a4                      	cpi r26, 4
001944 f079                      	breq sound_driver_channel0_instrument_change_load_macro_arpeggio
001945 30a3                      	cpi r26, 3
001946 f0d9                      	breq sound_driver_channel0_instrument_change_load_macro_pitch
001947 30a2                      	cpi r26, 2
001948 f159                      	breq sound_driver_channel0_instrument_change_load_macro_hi_pitch
001949 c03c                      	rjmp sound_driver_channel0_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel0_instrument_change_load_macro_volume:
00194a 93c0 2828                 	sts pulse1_volume_macro, r28
00194c 93d0 2829                 	sts pulse1_volume_macro+1, r29
00194e d041                      	rcall sound_driver_channel0_instrument_change_read_header
00194f 93c0 282c                 	sts pulse1_volume_macro_release, r28
001951 93d0 282b                 	sts pulse1_volume_macro_loop, r29
001953 cfd8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 	
                                 sound_driver_channel0_instrument_change_load_macro_arpeggio:
001954 93c0 282d                 	sts pulse1_arpeggio_macro, r28
001956 93d0 282e                 	sts pulse1_arpeggio_macro+1, r29
001958 9220 2863                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00195a 9220 2864                 	sts pulse1_fx_Qxy_target+1, zero
00195c 9220 2869                 	sts pulse1_fx_Rxy_target, zero
00195e 9220 286a                 	sts pulse1_fx_Rxy_target+1, zero
001960 d03a                      	rcall sound_driver_channel0_instrument_change_read_header_arpeggio
001961 cfca                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_pitch:
001962 93c0 2835                 	sts pulse1_pitch_macro, r28
001964 93d0 2836                 	sts pulse1_pitch_macro+1, r29
001966 9220 2863                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001968 9220 2864                 	sts pulse1_fx_Qxy_target+1, zero
00196a 9220 2869                 	sts pulse1_fx_Rxy_target, zero
00196c 9220 286a                 	sts pulse1_fx_Rxy_target+1, zero
00196e d021                      	rcall sound_driver_channel0_instrument_change_read_header
00196f 93c0 2839                 	sts pulse1_pitch_macro_release, r28
001971 93d0 2838                 	sts pulse1_pitch_macro_loop, r29
001973 cfb8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_hi_pitch:
001974 93c0 283b                 	sts pulse1_hi_pitch_macro, r28
001976 93d0 283c                 	sts pulse1_hi_pitch_macro+1, r29
001978 9220 2863                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00197a 9220 2864                 	sts pulse1_fx_Qxy_target+1, zero
00197c 9220 2869                 	sts pulse1_fx_Rxy_target, zero
00197e 9220 286a                 	sts pulse1_fx_Rxy_target+1, zero
001980 d00f                      	rcall sound_driver_channel0_instrument_change_read_header
001981 93c0 283f                 	sts pulse1_hi_pitch_macro_release, r28
001983 93d0 283e                 	sts pulse1_hi_pitch_macro_loop, r29
001985 cfa6                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_duty:
001986 93c0 2840                 	sts pulse1_duty_macro, r28
001988 93d0 2841                 	sts pulse1_duty_macro+1, r29
00198a d005                      	rcall sound_driver_channel0_instrument_change_read_header
00198b 93c0 2844                 	sts pulse1_duty_macro_release, r28
00198d 93d0 2843                 	sts pulse1_duty_macro_loop, r29
00198f cf9c                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_read_header:
001990 93ef                      	push ZL
001991 93ff                      	push ZH
001992 2fec                      	mov ZL, r28
001993 2ffd                      	mov ZH, r29
001994 0fee                      	lsl ZL
001995 1fff                      	rol ZH
001996 91c5                      	lpm r28, Z+
001997 91d4                      	lpm r29, Z
001998 91ff                      	pop ZH
001999 91ef                      	pop ZL
00199a 9508                      	ret
                                 
                                 sound_driver_channel0_instrument_change_read_header_arpeggio:
00199b 93ef                      	push ZL
00199c 93ff                      	push ZH
00199d 2fec                      	mov ZL, r28
00199e 2ffd                      	mov ZH, r29
00199f 0fee                      	lsl ZL
0019a0 1fff                      	rol ZH
0019a1 91c5                      	lpm r28, Z+
0019a2 91d5                      	lpm r29, Z+
0019a3 93c0 2831                 	sts pulse1_arpeggio_macro_release, r28
0019a5 93d0 2830                 	sts pulse1_arpeggio_macro_loop, r29
0019a7 91c4                      	lpm r28, Z
0019a8 93c0 2832                 	sts pulse1_arpeggio_macro_mode, r28
0019aa 91ff                      	pop ZH
0019ab 91ef                      	pop ZL
0019ac 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel0_release:
                                 sound_driver_channel0_release_volume:
0019ad 91b0 282c                 	lds r27, pulse1_volume_macro_release
0019af 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
0019b0 f019                      	breq sound_driver_channel0_release_arpeggio //if the macro has no release flag, check the next macro
0019b1 95b3                      	inc r27
0019b2 93b0 282a                 	sts pulse1_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel0_release_arpeggio:
0019b4 91b0 2831                 	lds r27, pulse1_arpeggio_macro_release
0019b6 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
0019b7 f019                      	breq sound_driver_channel0_release_pitch
0019b8 95b3                      	inc r27
0019b9 93b0 282f                 	sts pulse1_arpeggio_macro_offset, r27
                                 sound_driver_channel0_release_pitch:
0019bb 91b0 2839                 	lds r27, pulse1_pitch_macro_release
0019bd 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
0019be f019                      	breq sound_driver_channel0_release_hi_pitch
0019bf 95b3                      	inc r27
0019c0 93b0 2837                 	sts pulse1_pitch_macro_offset, r27
                                 sound_driver_channel0_release_hi_pitch:
0019c2 91b0 283f                 	lds r27, pulse1_hi_pitch_macro_release
0019c4 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
0019c5 f019                      	breq sound_driver_channel0_release_duty
0019c6 95b3                      	inc r27
0019c7 93b0 283d                 	sts pulse1_hi_pitch_macro_offset, r27
                                 sound_driver_channel0_release_duty:
0019c9 91b0 2844                 	lds r27, pulse1_duty_macro_release
0019cb 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
0019cc f019                      	breq sound_driver_channel0_release_exit
0019cd 95b3                      	inc r27
0019ce 93b0 2842                 	sts pulse1_duty_macro_offset, r27
                                 sound_driver_channel0_release_exit:
0019d0 d026                      	rcall sound_driver_channel0_increment_offset
0019d1 cd55                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_next_pattern:
0019d2 91e0 2818                 	lds ZL, song_frames
0019d4 91f0 2819                 	lds ZH, song_frames+1
0019d6 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
0019d8 91b0 281b                 	lds r27, song_frame_offset+1
0019da 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
0019db 93a0 281a                 	sts song_frame_offset, r26
0019dd 93b0 281b                 	sts song_frame_offset+1, r27
                                 
0019df 91c0 281c                 	lds r28, song_size
0019e1 91d0 281d                 	lds r29, song_size+1
0019e3 17ac                      	cp r26, r28
0019e4 07bd                      	cpc r27, r29
0019e5 f010                      	brlo sound_driver_channel0_next_pattern_exists
0019e6 940c 305a                 	jmp sound_driver_exit
                                 
                                 sound_driver_channel0_next_pattern_exists:
0019e8 0fea                      	add ZL, r26
0019e9 1ffb                      	adc ZH, r27
                                 
0019ea 91a5                      	lpm r26, Z+ //load the address of the next pattern
0019eb 91b4                      	lpm r27, Z
0019ec 0faa                      	lsl r26
0019ed 1fbb                      	rol r27
0019ee 93a0 2822                 	sts pulse1_pattern, r26
0019f0 93b0 2823                 	sts pulse1_pattern+1, r27
                                 
0019f2 9220 2826                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
0019f4 9220 2827                 	sts pulse1_pattern_offset+1, zero
0019f6 cd30                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_increment_offset:
0019f7 91e0 2826                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
0019f9 91f0 2827                 	lds ZH, pulse1_pattern_offset+1
0019fb 9631                      	adiw Z, 1
0019fc 93e0 2826                 	sts pulse1_pattern_offset, ZL
0019fe 93f0 2827                 	sts pulse1_pattern_offset+1, ZH
001a00 9508                      	ret
                                 
                                 sound_driver_channel0_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001a01 91e0 2826                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
001a03 91f0 2827                 	lds ZH, pulse1_pattern_offset+1
001a05 9632                      	adiw Z, 2 //increment the pointer twice
001a06 93e0 2826                 	sts pulse1_pattern_offset, ZL
001a08 93f0 2827                 	sts pulse1_pattern_offset+1, ZH
001a0a 9508                      	ret
                                 
                                 sound_driver_channel0_decrement_frame_delay:
001a0b 95ba                      	dec r27
001a0c 93b0 2825                 	sts pulse1_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel1:
001a0e 91a0 2873                 	lds r26, pulse2_pattern_delay_rows
001a10 91b0 2874                 	lds r27, pulse2_pattern_delay_frames
001a12 9610                      	adiw r27:r26, 0
001a13 f009                      	breq sound_driver_channel1_main //if the pattern delay is 0, proceed with sound driver procedures
001a14 c2d7                      	rjmp sound_driver_channel1_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel1_main:
001a15 91e0 2871                 	lds ZL, pulse2_pattern //current pattern for pulse 2
001a17 91f0 2872                 	lds ZH, pulse2_pattern+1
001a19 91a0 2875                 	lds r26, pulse2_pattern_offset //current offset in the pattern for pulse 2
001a1b 91b0 2876                 	lds r27, pulse2_pattern_offset+1
001a1d 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001a1e 1ffb                      	adc ZH, r27
001a1f 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel1_check_if_note: //check if data is a note (0x00 - 0x56)
001a20 35b7                      	cpi r27, 0x57
001a21 f408                      	brsh sound_driver_channel1_check_if_volume
001a22 c180                      	rjmp sound_driver_channel1_note
                                 sound_driver_channel1_check_if_volume: //check if data is volume (0x57-0x66)
001a23 36b7                      	cpi r27, 0x67
001a24 f408                      	brsh sound_driver_channel1_check_if_delay
001a25 c1ba                      	rjmp sound_driver_channel1_volume
                                 sound_driver_channel1_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001a26 3eb3                      	cpi r27, 0xE3
001a27 f408                      	brsh sound_driver_channel1_check_if_instrument
001a28 c1c1                      	rjmp sound_driver_channel1_delay
                                 sound_driver_channel1_check_if_instrument: //check for instrument flag (0xE3)
001a29 f409                      	brne sound_driver_channel1_check_if_release
001a2a c1c4                      	rjmp sound_driver_channel1_instrument_change 
                                 sound_driver_channel1_check_if_release: //check for note release flag (0xE4)
001a2b 3eb4                      	cpi r27, 0xE4
001a2c f409                      	brne sound_driver_channel1_check_if_end
001a2d c26d                      	rjmp sound_driver_channel1_release
                                 sound_driver_channel1_check_if_end:
001a2e 3fbf                      	cpi r27, 0xFF
001a2f f409                      	brne sound_driver_channel1_check_if_fx
001a30 c28f                      	rjmp sound_driver_channel1_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel1_check_if_fx: //fx flags (0xE5 - 0xFE)
001a31 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001a32 91a4                      	lpm r26, Z //load the fx data into r26
001a33 d2ae                      	rcall sound_driver_channel1_increment_offset_twice
                                 
001a34 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001a35 e1e8                      	ldi ZL, LOW(channel1_fx << 1) //load in note table
001a36 e6f1                      	ldi ZH, HIGH(channel1_fx << 1)
001a37 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001a38 0feb                      	add ZL, r27 //add offset
001a39 1df2                      	adc ZH, zero
001a3a 91c5                      	lpm r28, Z+ //load address bytes
001a3b 91d4                      	lpm r29, Z
001a3c 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001a3d 2ffd                      	mov ZH, r29
001a3e 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel1_fx_0xy:
001a3f 93a0 2894                 	sts pulse2_fx_0xy_sequence, r26
001a41 9220 2895                 	sts pulse2_fx_0xy_sequence+1, zero
001a43 cfd1                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel1_fx_1xx:
001a44 9220 289a                 	sts pulse2_fx_2xx, zero //turn off any 2xx pitch slide down
001a46 9220 289b                 	sts pulse2_fx_2xx+1, zero
001a48 9220 2894                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
001a4a 9220 2895                 	sts pulse2_fx_0xy_sequence+1, zero
001a4c 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001a4d 937f                      	push r23
001a4e 2f6a                      	mov r22, r26 //store the rate into r22
001a4f eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001a50 9f67                      	mul r22, r23
001a51 917f                      	pop r23
001a52 916f                      	pop r22
                                 
001a53 9416                      	lsr r1 //shift out the fractional bits
001a54 9407                      	ror r0
001a55 9416                      	lsr r1
001a56 9407                      	ror r0
001a57 9416                      	lsr r1
001a58 9407                      	ror r0
001a59 9416                      	lsr r1
001a5a 9407                      	ror r0
001a5b 9200 2896                 	sts pulse2_fx_1xx, r0
001a5d 9210 2897                 	sts pulse2_fx_1xx+1, r1
001a5f cfb5                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel1_fx_2xx:
001a60 9220 2896                 	sts pulse2_fx_1xx, zero //turn off any 1xx pitch slide down
001a62 9220 2897                 	sts pulse2_fx_1xx+1, zero
001a64 9220 2894                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
001a66 9220 2895                 	sts pulse2_fx_0xy_sequence+1, zero
001a68 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001a69 937f                      	push r23
001a6a 2f6a                      	mov r22, r26 //store the rate into r22
001a6b eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001a6c 9f67                      	mul r22, r23
001a6d 917f                      	pop r23
001a6e 916f                      	pop r22
                                 
001a6f 9416                      	lsr r1 //shift out the fractional bits
001a70 9407                      	ror r0
001a71 9416                      	lsr r1
001a72 9407                      	ror r0
001a73 9416                      	lsr r1
001a74 9407                      	ror r0
001a75 9416                      	lsr r1
001a76 9407                      	ror r0
001a77 9200 289a                 	sts pulse2_fx_2xx, r0
001a79 9210 289b                 	sts pulse2_fx_2xx+1, r1
001a7b cf99                      	rjmp sound_driver_channel1_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel1_fx_3xx:
001a7c 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001a7d 937f                      	push r23
001a7e 2f6a                      	mov r22, r26 //store the rate into r22
001a7f eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001a80 9f67                      	mul r22, r23
001a81 917f                      	pop r23
001a82 916f                      	pop r22
                                 
001a83 9416                      	lsr r1 //shift out the fractional bits
001a84 9407                      	ror r0
001a85 9416                      	lsr r1
001a86 9407                      	ror r0
001a87 9416                      	lsr r1
001a88 9407                      	ror r0
001a89 9416                      	lsr r1
001a8a 9407                      	ror r0
001a8b 9200 28a2                 	sts pulse2_fx_3xx_speed, r0
001a8d 9210 28a3                 	sts pulse2_fx_3xx_speed+1, r1
                                 
001a8f 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001a90 c001                      	rjmp sound_driver_channel1_fx_3xx_enabled
001a91 cf83                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_3xx_enabled:
001a92 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001a94 91b0 0a9d                 	lds r27, TCB1_CCMPH
001a96 93a0 289e                 	sts pulse2_fx_3xx_start, r26
001a98 93b0 289f                 	sts pulse2_fx_3xx_start+1, r27
                                 
001a9a 9220 28a4                 	sts pulse2_fx_3xx_total_offset, zero
001a9c 9220 28a5                 	sts pulse2_fx_3xx_total_offset+1, zero
001a9e cf76                      	rjmp sound_driver_channel1_main
                                 
                                 //VIBRATO
                                 sound_driver_channel1_fx_4xy:
001a9f 2fba                      	mov r27, r26
001aa0 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001aa1 95a2                      	swap r26
001aa2 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001aa3 93a0 28a6                 	sts pulse2_fx_4xy_speed, r26
001aa5 93b0 28a7                 	sts pulse2_fx_4xy_depth, r27
001aa7 9220 28a8                 	sts pulse2_fx_4xy_phase, zero //reset the phase to 0
001aa9 cf6b                      	rjmp sound_driver_channel1_main
                                 
                                 //TREMELO
                                 sound_driver_channel1_fx_7xy:
001aaa 2fba                      	mov r27, r26
001aab 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001aac 95a2                      	swap r26
001aad 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001aae 93a0 28a9                 	sts pulse2_fx_7xy_speed, r26
001ab0 93b0 28aa                 	sts pulse2_fx_7xy_depth, r27
001ab2 9220 28ab                 	sts pulse2_fx_7xy_phase, zero //reset the phase to 0
001ab4 9220 28ac                 	sts pulse2_fx_7xy_value, zero //reset the tremelo value
001ab6 cf5e                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel1_fx_Axy:
001ab7 93a0 28ad                 	sts pulse2_fx_Axy, r26
001ab9 cf5b                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel1_fx_Bxx:
001aba 93a0 281f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001abc cf58                      	rjmp sound_driver_channel1_main
                                 
                                 //HALT
                                 sound_driver_channel1_fx_Cxx:
001abd 93b0 2820                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001abf cf55                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel1_fx_Dxx:
001ac0 93b0 2821                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001ac2 cf52                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME
                                 sound_driver_channel1_fx_Exx:
001ac3 91b0 2808                 	lds r27, pulse2_param
001ac5 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
001ac6 2bba                      	or r27, r26 //move new VVVV bits into pulse2_param
001ac7 93b0 2808                 	sts pulse2_param, r27
001ac9 6092                      	sbr pulse_channel_flags, 2
001aca cf4a                      	rjmp sound_driver_channel1_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel1_fx_Fxx:
001acb 93a0 281e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001acd cf47                      	rjmp sound_driver_channel1_main
                                 
                                 //DELAY
                                 sound_driver_channel1_fx_Gxx:
001ace 15a2                      	cp r26, zero
001acf f051                      	breq sound_driver_channel1_fx_Gxx_invalid
001ad0 91b0 281e                 	lds r27, song_speed
001ad2 17ab                      	cp r26, r27
001ad3 f430                      	brsh sound_driver_channel1_fx_Gxx_invalid
001ad4 93a0 28ae                 	sts pulse2_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001ad6 e0b1                      	ldi r27, 0x01
001ad7 93b0 2873                 	sts pulse2_pattern_delay_rows, r27
001ad9 c215                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Gxx_invalid:
001ada cf3a                      	rjmp sound_driver_channel1_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel1_fx_Hxy: //hardware sweep up
001adb cf39                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixy: //hardware sweep down
001adc cf38                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Hxx: //FDS modulation depth
001add cf37                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixx: //FDS modulation speed
001ade cf36                      	rjmp sound_driver_channel1_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel1_fx_Pxx:
001adf 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001ae0 937f                      	push r23
001ae1 2f6a                      	mov r22, r26
001ae2 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001ae3 0367                      	mulsu r22, r23
001ae4 917f                      	pop r23
001ae5 916f                      	pop r22
001ae6 9416                      	lsr r1 //shift out the fractional bits
001ae7 9407                      	ror r0
001ae8 9416                      	lsr r1
001ae9 9407                      	ror r0
001aea 9416                      	lsr r1
001aeb 9407                      	ror r0
001aec 9416                      	lsr r1
001aed 9407                      	ror r0
001aee fe13                      	sbrs r1, 3 //check if result was a negative number
001aef c002                      	rjmp sound_driver_channel1_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel1_fx_Pxx_negative:
001af0 efb0                      	ldi r27, 0xF0
001af1 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel1_fx_Pxx_store:
001af2 9200 28b0                 	sts pulse2_fx_Pxx_total, r0
001af4 9210 28b1                 	sts pulse2_fx_Pxx_total+1, r1
001af6 cf1e                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel1_fx_Qxy:
                                 sound_driver_channel1_fx_Qxy_check_arpeggio_macro:
001af7 91e0 287c                 	lds ZL, pulse2_arpeggio_macro
001af9 91f0 287d                 	lds ZH, pulse2_arpeggio_macro+1
001afb 9630                      	adiw Z, 0
001afc f009                      	breq sound_driver_channel1_fx_Qxy_check_pitch_macro
001afd cf17                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_pitch_macro:
001afe 91e0 2884                 	lds ZL, pulse2_pitch_macro
001b00 91f0 2885                 	lds ZH, pulse2_pitch_macro+1
001b02 9630                      	adiw Z, 0
001b03 f009                      	breq sound_driver_channel1_fx_Qxy_check_hi_pitch_macro
001b04 cf10                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_hi_pitch_macro:
001b05 91e0 288a                 	lds ZL, pulse2_hi_pitch_macro
001b07 91f0 288b                 	lds ZH, pulse2_hi_pitch_macro+1
001b09 9630                      	adiw Z, 0
001b0a f009                      	breq sound_driver_channel1_fx_Qxy_process
001b0b cf09                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_process:
001b0c 2fba                      	mov r27, r26 //copy fx parameters into r27
001b0d 70bf                      	andi r27, 0x0F //mask note index offset
001b0e 91c0 280f                 	lds r28, pulse2_note //load current note index
001b10 0fbc                      	add r27, r28
001b11 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001b12 f008                      	brlo sound_driver_channel1_fx_Qxy_process_continue
001b13 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel1_fx_Qxy_process_continue:
001b14 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001b15 e0f0                      	ldi ZH, HIGH(note_table << 1)
001b16 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001b17 0feb                      	add ZL, r27 //add offset
001b18 1df2                      	adc ZH, zero
001b19 91c5                      	lpm r28, Z+ //load bytes
001b1a 91d4                      	lpm r29, Z
001b1b 93c0 28b2                 	sts pulse2_fx_Qxy_target, r28 //load the LOW bits for the target period
001b1d 93d0 28b3                 	sts pulse2_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
001b1f 95a2                      	swap r26
001b20 70af                      	andi r26, 0x0F //mask effect speed
001b21 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001b22 95a3                      	inc r26 //increment the speed by 1
                                 
001b23 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001b24 937f                      	push r23
001b25 2f6a                      	mov r22, r26 //store the speed data into r27
001b26 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001b27 9f67                      	mul r22, r23
001b28 917f                      	pop r23
001b29 916f                      	pop r22
                                 
001b2a 9416                      	lsr r1 //shift out the fractional bits
001b2b 9407                      	ror r0
001b2c 9416                      	lsr r1
001b2d 9407                      	ror r0
001b2e 9416                      	lsr r1
001b2f 9407                      	ror r0
001b30 9416                      	lsr r1
001b31 9407                      	ror r0
                                 
001b32 9200 28b4                 	sts pulse2_fx_Qxy_speed, r0 //store the effect speed
001b34 9210 28b5                 	sts pulse2_fx_Qxy_speed+1, r1
001b36 9220 28b6                 	sts pulse2_fx_Qxy_total_offset, zero
001b38 9220 28b7                 	sts pulse2_fx_Qxy_total_offset+1, zero
001b3a ceda                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel1_fx_Rxy:
                                 sound_driver_channel1_fx_Rxy_check_arpeggio_macro:
001b3b 91e0 287c                 	lds ZL, pulse2_arpeggio_macro
001b3d 91f0 287d                 	lds ZH, pulse2_arpeggio_macro+1
001b3f 9630                      	adiw Z, 0
001b40 f009                      	breq sound_driver_channel1_fx_Rxy_check_pitch_macro
001b41 ced3                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_pitch_macro:
001b42 91e0 2884                 	lds ZL, pulse2_pitch_macro
001b44 91f0 2885                 	lds ZH, pulse2_pitch_macro+1
001b46 9630                      	adiw Z, 0
001b47 f009                      	breq sound_driver_channel1_fx_Rxy_check_hi_pitch_macro
001b48 cecc                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_hi_pitch_macro:
001b49 91e0 288a                 	lds ZL, pulse2_hi_pitch_macro
001b4b 91f0 288b                 	lds ZH, pulse2_hi_pitch_macro+1
001b4d 9630                      	adiw Z, 0
001b4e f009                      	breq sound_driver_channel1_fx_Rxy_process
001b4f cec5                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_process:
001b50 2fba                      	mov r27, r26 //copy fx parameters into r27
001b51 70bf                      	andi r27, 0x0F //mask note index offset
001b52 91c0 280f                 	lds r28, pulse2_note //load current note index
001b54 1bcb                      	sub r28, r27
001b55 f408                      	brcc sound_driver_channel1_fx_Rxy_process_continue
001b56 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel1_fx_Rxy_process_continue:
001b57 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001b58 e0f0                      	ldi ZH, HIGH(note_table << 1)
001b59 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001b5a 0fec                      	add ZL, r28 //add offset
001b5b 1df2                      	adc ZH, zero
001b5c 91c5                      	lpm r28, Z+ //load bytes
001b5d 91d4                      	lpm r29, Z
001b5e 93c0 28b8                 	sts pulse2_fx_Rxy_target, r28 //load the LOW bits for the target period
001b60 93d0 28b9                 	sts pulse2_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
001b62 95a2                      	swap r26
001b63 70af                      	andi r26, 0x0F //mask effect speed
001b64 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001b65 95a3                      	inc r26 //increment the speed by 1
                                 
001b66 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001b67 937f                      	push r23
001b68 2f6a                      	mov r22, r26 //store the speed data into r27
001b69 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001b6a 9f67                      	mul r22, r23
001b6b 917f                      	pop r23
001b6c 916f                      	pop r22
                                 
001b6d 9416                      	lsr r1 //shift out the fractional bits
001b6e 9407                      	ror r0
001b6f 9416                      	lsr r1
001b70 9407                      	ror r0
001b71 9416                      	lsr r1
001b72 9407                      	ror r0
001b73 9416                      	lsr r1
001b74 9407                      	ror r0
                                 
001b75 9200 28ba                 	sts pulse2_fx_Rxy_speed, r0 //store the effect speed
001b77 9210 28bb                 	sts pulse2_fx_Rxy_speed+1, r1
001b79 9220 28bc                 	sts pulse2_fx_Rxy_total_offset, zero
001b7b 9220 28bd                 	sts pulse2_fx_Rxy_total_offset+1, zero
001b7d ce97                      	rjmp sound_driver_channel1_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel1_fx_Sxx:
001b7e 15a2                      	cp r26, zero
001b7f f051                      	breq sound_driver_channel1_fx_Sxx_invalid
001b80 91b0 281e                 	lds r27, song_speed
001b82 17ab                      	cp r26, r27
001b83 f430                      	brsh sound_driver_channel1_fx_Sxx_invalid
001b84 93a0 28be                 	sts pulse2_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001b86 e0b1                      	ldi r27, 0x01
001b87 93b0 2873                 	sts pulse2_pattern_delay_rows, r27
001b89 c165                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Sxx_invalid:
001b8a ce8a                      	rjmp sound_driver_channel1_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel1_fx_Vxx:
001b8b eee0                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
001b8c e6f0                      	ldi ZH, HIGH(sequences << 1)
001b8d 0fea                      	add ZL, r26 //offset the pointer
001b8e 1df2                      	adc ZH, zero
                                 
001b8f 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
001b90 95a7                      	ror r26
001b91 95a7                      	ror r26
001b92 91b0 2808                 	lds r27, pulse2_param //load r27 with pulse2_param (register $4000)
001b94 2fcb                      	mov r28, r27 //store a copy of pulse2_param into r28
001b95 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
001b96 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
001b97 c001                      	rjmp sound_driver_channel1_fx_Vxx_store
001b98 ce7c                      	rjmp sound_driver_channel1_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel1_fx_Vxx_store:
001b99 90d4                      	lpm pulse2_sequence, Z //store the sequence
                                 
001b9a 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
001b9b 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
001b9c 93c0 2808                 	sts pulse2_param, r28
001b9e ce76                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_Wxx: //DPCM sample speed
001b9f ce75                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Xxx: //DPCM sample retrigger
001ba0 ce74                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Yxx: //DPCM sample offset
001ba1 ce73                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Zxx: //DPCM sample delta counter
001ba2 ce72                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 sound_driver_channel1_note:
001ba3 93b0 280f                 	sts pulse2_note, r27 //store the note index
001ba5 e0a3                      	ldi r26, 0x03
001ba6 e0b2                      	ldi r27, 0x02
001ba7 93b0 2879                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
001ba9 93a0 287e                 	sts pulse2_arpeggio_macro_offset, r26
001bab 93b0 2886                 	sts pulse2_pitch_macro_offset, r27
001bad 93b0 288c                 	sts pulse2_hi_pitch_macro_offset, r27
001baf 93b0 2891                 	sts pulse2_duty_macro_offset, r27
001bb1 9220 2882                 	sts pulse2_total_pitch_offset, zero //reset the pitch and hi pitch offset
001bb3 9220 2883                 	sts pulse2_total_pitch_offset+1, zero
001bb5 9220 2889                 	sts pulse2_total_hi_pitch_offset, zero
001bb7 9220 2898                 	sts pulse2_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001bb9 9220 2899                 	sts pulse2_fx_1xx_total+1, zero
001bbb 9220 289c                 	sts pulse2_fx_2xx_total, zero
001bbd 9220 289d                 	sts pulse2_fx_2xx_total+1, zero
001bbf 9220 28a4                 	sts pulse2_fx_3xx_total_offset, zero //reset 3xx offset
001bc1 9220 28a5                 	sts pulse2_fx_3xx_total_offset+1, zero
001bc3 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001bc5 91b0 0a9d                 	lds r27, TCB1_CCMPH
001bc7 93a0 289e                 	sts pulse2_fx_3xx_start, r26
001bc9 93b0 289f                 	sts pulse2_fx_3xx_start+1, r27
001bcb 9220 2809                 	sts pulse2_sweep_param, zero //reset any sweep effect
001bcd 6093                      	sbr pulse_channel_flags, 3 //set reload flag
001bce 9220 28b2                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001bd0 9220 28b3                 	sts pulse2_fx_Qxy_target+1, zero
001bd2 9220 28b6                 	sts pulse2_fx_Qxy_total_offset, zero
001bd4 9220 28b7                 	sts pulse2_fx_Qxy_total_offset+1, zero
001bd6 9220 28b8                 	sts pulse2_fx_Rxy_target, zero
001bd8 9220 28b9                 	sts pulse2_fx_Rxy_target+1, zero
001bda 9220 28bc                 	sts pulse2_fx_Rxy_total_offset, zero
001bdc 9220 28bd                 	sts pulse2_fx_Rxy_total_offset+1, zero
001bde d0f9                      	rcall sound_driver_channel1_increment_offset
001bdf ce35                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_volume:
001be0 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001be1 91a0 2808                 	lds r26, pulse2_param
001be3 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001be4 2bab                      	or r26, r27 //move new VVVV bits into pulse2_param
001be5 93a0 2808                 	sts pulse2_param, r26
001be7 6092                      	sbr pulse_channel_flags, 2
001be8 d0ef                      	rcall sound_driver_channel1_increment_offset
001be9 ce2b                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_delay:
001bea 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001beb 93b0 2873                 	sts pulse2_pattern_delay_rows, r27
001bed d0ea                      	rcall sound_driver_channel1_increment_offset
001bee c100                      	rjmp sound_driver_channel2
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change:
001bef 9220 2877                 	sts pulse2_volume_macro, zero //reset all macro addresses
001bf1 9220 2878                 	sts pulse2_volume_macro+1, zero
001bf3 9220 287c                 	sts pulse2_arpeggio_macro, zero
001bf5 9220 287d                 	sts pulse2_arpeggio_macro+1, zero
001bf7 9220 2884                 	sts pulse2_pitch_macro, zero
001bf9 9220 2885                 	sts pulse2_pitch_macro+1, zero
001bfb 9220 288a                 	sts pulse2_hi_pitch_macro, zero
001bfd 9220 288b                 	sts pulse2_hi_pitch_macro+1, zero
001bff 9220 288f                 	sts pulse2_duty_macro, zero
001c01 9220 2890                 	sts pulse2_duty_macro+1, zero
001c03 9220 2882                 	sts pulse2_total_pitch_offset, zero //reset the pitch offset
001c05 9220 2883                 	sts pulse2_total_pitch_offset+1, zero
001c07 9220 2889                 	sts pulse2_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001c09 9631                      	adiw Z, 1 //point to the byte next to the flag
001c0a 91b4                      	lpm r27, Z //store the instrument offset into r27
001c0b e7e1                      	ldi ZL, LOW(instruments) //point Z to instruments table
001c0c e1f0                      	ldi ZH, HIGH(instruments)
001c0d 0feb                      	add ZL, r27 //point Z to offsetted instrument
001c0e 1df2                      	adc ZH, zero
001c0f 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001c10 1fff                      	rol ZH
001c11 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001c12 91b4                      	lpm r27, Z
                                 
001c13 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001c14 1fbb                      	rol r27
001c15 2fea                      	mov ZL, r26
001c16 2ffb                      	mov ZH, r27
001c17 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001c18 9632                      	adiw Z, 2 //point Z to the address of the macro
001c19 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel1_instrument_change_macro_loop:
001c1a 95aa                      	dec r26
001c1b f019                      	breq sound_driver_channel1_instrument_change_exit
001c1c 95b6                      	lsr r27
001c1d f078                      	brcs sound_driver_channel1_instrument_change_load_macro
001c1e cffb                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_exit:
001c1f e0a3                      	ldi r26, 0x03
001c20 e0b2                      	ldi r27, 0x02
001c21 93b0 2879                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
001c23 93a0 287e                 	sts pulse2_arpeggio_macro_offset, r26
001c25 93b0 2886                 	sts pulse2_pitch_macro_offset, r27
001c27 93b0 288c                 	sts pulse2_hi_pitch_macro_offset, r27
001c29 93b0 2891                 	sts pulse2_duty_macro_offset, r27
001c2b d0b6                      	rcall sound_driver_channel1_increment_offset_twice
001c2c cde8                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_load_macro:
001c2d 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001c2e 91d5                      	lpm r29, Z+
                                 
001c2f 30a5                      	cpi r26, 5
001c30 f039                      	breq sound_driver_channel1_instrument_change_load_macro_volume
001c31 30a4                      	cpi r26, 4
001c32 f079                      	breq sound_driver_channel1_instrument_change_load_macro_arpeggio
001c33 30a3                      	cpi r26, 3
001c34 f0d9                      	breq sound_driver_channel1_instrument_change_load_macro_pitch
001c35 30a2                      	cpi r26, 2
001c36 f159                      	breq sound_driver_channel1_instrument_change_load_macro_hi_pitch
001c37 c03c                      	rjmp sound_driver_channel1_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel1_instrument_change_load_macro_volume:
001c38 93c0 2877                 	sts pulse2_volume_macro, r28
001c3a 93d0 2878                 	sts pulse2_volume_macro+1, r29
001c3c d041                      	rcall sound_driver_channel1_instrument_change_read_header
001c3d 93c0 287b                 	sts pulse2_volume_macro_release, r28
001c3f 93d0 287a                 	sts pulse2_volume_macro_loop, r29
001c41 cfd8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 	
                                 sound_driver_channel1_instrument_change_load_macro_arpeggio:
001c42 93c0 287c                 	sts pulse2_arpeggio_macro, r28
001c44 93d0 287d                 	sts pulse2_arpeggio_macro+1, r29
001c46 9220 28b2                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001c48 9220 28b3                 	sts pulse2_fx_Qxy_target+1, zero
001c4a 9220 28b8                 	sts pulse2_fx_Rxy_target, zero
001c4c 9220 28b9                 	sts pulse2_fx_Rxy_target+1, zero
001c4e d03a                      	rcall sound_driver_channel1_instrument_change_read_header_arpeggio
001c4f cfca                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_pitch:
001c50 93c0 2884                 	sts pulse2_pitch_macro, r28
001c52 93d0 2885                 	sts pulse2_pitch_macro+1, r29
001c54 9220 28b2                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001c56 9220 28b3                 	sts pulse2_fx_Qxy_target+1, zero
001c58 9220 28b8                 	sts pulse2_fx_Rxy_target, zero
001c5a 9220 28b9                 	sts pulse2_fx_Rxy_target+1, zero
001c5c d021                      	rcall sound_driver_channel1_instrument_change_read_header
001c5d 93c0 2888                 	sts pulse2_pitch_macro_release, r28
001c5f 93d0 2887                 	sts pulse2_pitch_macro_loop, r29
001c61 cfb8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_hi_pitch:
001c62 93c0 288a                 	sts pulse2_hi_pitch_macro, r28
001c64 93d0 288b                 	sts pulse2_hi_pitch_macro+1, r29
001c66 9220 28b2                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001c68 9220 28b3                 	sts pulse2_fx_Qxy_target+1, zero
001c6a 9220 28b8                 	sts pulse2_fx_Rxy_target, zero
001c6c 9220 28b9                 	sts pulse2_fx_Rxy_target+1, zero
001c6e d00f                      	rcall sound_driver_channel1_instrument_change_read_header
001c6f 93c0 288e                 	sts pulse2_hi_pitch_macro_release, r28
001c71 93d0 288d                 	sts pulse2_hi_pitch_macro_loop, r29
001c73 cfa6                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_duty:
001c74 93c0 288f                 	sts pulse2_duty_macro, r28
001c76 93d0 2890                 	sts pulse2_duty_macro+1, r29
001c78 d005                      	rcall sound_driver_channel1_instrument_change_read_header
001c79 93c0 2893                 	sts pulse2_duty_macro_release, r28
001c7b 93d0 2892                 	sts pulse2_duty_macro_loop, r29
001c7d cf9c                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_read_header:
001c7e 93ef                      	push ZL
001c7f 93ff                      	push ZH
001c80 2fec                      	mov ZL, r28
001c81 2ffd                      	mov ZH, r29
001c82 0fee                      	lsl ZL
001c83 1fff                      	rol ZH
001c84 91c5                      	lpm r28, Z+
001c85 91d4                      	lpm r29, Z
001c86 91ff                      	pop ZH
001c87 91ef                      	pop ZL
001c88 9508                      	ret
                                 
                                 sound_driver_channel1_instrument_change_read_header_arpeggio:
001c89 93ef                      	push ZL
001c8a 93ff                      	push ZH
001c8b 2fec                      	mov ZL, r28
001c8c 2ffd                      	mov ZH, r29
001c8d 0fee                      	lsl ZL
001c8e 1fff                      	rol ZH
001c8f 91c5                      	lpm r28, Z+
001c90 91d5                      	lpm r29, Z+
001c91 93c0 2880                 	sts pulse2_arpeggio_macro_release, r28
001c93 93d0 287f                 	sts pulse2_arpeggio_macro_loop, r29
001c95 91c4                      	lpm r28, Z
001c96 93c0 2881                 	sts pulse2_arpeggio_macro_mode, r28
001c98 91ff                      	pop ZH
001c99 91ef                      	pop ZL
001c9a 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel1_release:
                                 sound_driver_channel1_release_volume:
001c9b 91b0 287b                 	lds r27, pulse2_volume_macro_release
001c9d 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001c9e f019                      	breq sound_driver_channel1_release_arpeggio //if the macro has no release flag, check the next macro
001c9f 95b3                      	inc r27
001ca0 93b0 2879                 	sts pulse2_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel1_release_arpeggio:
001ca2 91b0 2880                 	lds r27, pulse2_arpeggio_macro_release
001ca4 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001ca5 f019                      	breq sound_driver_channel1_release_pitch
001ca6 95b3                      	inc r27
001ca7 93b0 287e                 	sts pulse2_arpeggio_macro_offset, r27
                                 sound_driver_channel1_release_pitch:
001ca9 91b0 2888                 	lds r27, pulse2_pitch_macro_release
001cab 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001cac f019                      	breq sound_driver_channel1_release_hi_pitch
001cad 95b3                      	inc r27
001cae 93b0 2886                 	sts pulse2_pitch_macro_offset, r27
                                 sound_driver_channel1_release_hi_pitch:
001cb0 91b0 288e                 	lds r27, pulse2_hi_pitch_macro_release
001cb2 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001cb3 f019                      	breq sound_driver_channel1_release_duty
001cb4 95b3                      	inc r27
001cb5 93b0 288c                 	sts pulse2_hi_pitch_macro_offset, r27
                                 sound_driver_channel1_release_duty:
001cb7 91b0 2893                 	lds r27, pulse2_duty_macro_release
001cb9 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001cba f019                      	breq sound_driver_channel1_release_exit
001cbb 95b3                      	inc r27
001cbc 93b0 2891                 	sts pulse2_duty_macro_offset, r27
                                 sound_driver_channel1_release_exit:
001cbe d019                      	rcall sound_driver_channel1_increment_offset
001cbf cd55                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_next_pattern:
001cc0 91e0 2818                 	lds ZL, song_frames
001cc2 91f0 2819                 	lds ZH, song_frames+1
001cc4 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001cc6 91b0 281b                 	lds r27, song_frame_offset+1
001cc8 9612                      	adiw r27:r26, 2 //offset for channel 1
001cc9 0fea                      	add ZL, r26
001cca 1ffb                      	adc ZH, r27
                                 
001ccb 91a5                      	lpm r26, Z+ //load the address of the next pattern
001ccc 91b4                      	lpm r27, Z
001ccd 0faa                      	lsl r26
001cce 1fbb                      	rol r27
001ccf 93a0 2871                 	sts pulse2_pattern, r26
001cd1 93b0 2872                 	sts pulse2_pattern+1, r27
                                 
001cd3 9220 2875                 	sts pulse2_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001cd5 9220 2876                 	sts pulse2_pattern_offset+1, zero
001cd7 cd3d                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_increment_offset:
001cd8 91e0 2875                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001cda 91f0 2876                 	lds ZH, pulse2_pattern_offset+1
001cdc 9631                      	adiw Z, 1
001cdd 93e0 2875                 	sts pulse2_pattern_offset, ZL
001cdf 93f0 2876                 	sts pulse2_pattern_offset+1, ZH
001ce1 9508                      	ret
                                 
                                 sound_driver_channel1_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001ce2 91e0 2875                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001ce4 91f0 2876                 	lds ZH, pulse2_pattern_offset+1
001ce6 9632                      	adiw Z, 2 //increment the pointer twice
001ce7 93e0 2875                 	sts pulse2_pattern_offset, ZL
001ce9 93f0 2876                 	sts pulse2_pattern_offset+1, ZH
001ceb 9508                      	ret
                                 
                                 sound_driver_channel1_decrement_frame_delay:
001cec 95ba                      	dec r27
001ced 93b0 2874                 	sts pulse2_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel2:
001cef 91a0 28c2                 	lds r26, triangle_pattern_delay_rows
001cf1 91b0 28c3                 	lds r27, triangle_pattern_delay_frames
001cf3 9610                      	adiw r27:r26, 0
001cf4 f009                      	breq sound_driver_channel2_main //if the pattern delay is 0, proceed with sound driver procedures
001cf5 c2bf                      	rjmp sound_driver_channel2_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel2_main:
001cf6 91e0 28c0                 	lds ZL, triangle_pattern //current pattern for triangle
001cf8 91f0 28c1                 	lds ZH, triangle_pattern+1
001cfa 91a0 28c4                 	lds r26, triangle_pattern_offset //current offset in the pattern for triangle
001cfc 91b0 28c5                 	lds r27, triangle_pattern_offset+1
001cfe 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001cff 1ffb                      	adc ZH, r27
001d00 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel2_check_if_note: //check if data is a note (0x00 - 0x56)
001d01 35b7                      	cpi r27, 0x57
001d02 f408                      	brsh sound_driver_channel2_check_if_volume
001d03 c164                      	rjmp sound_driver_channel2_note
                                 sound_driver_channel2_check_if_volume: //check if data is volume (0x57-0x66)
001d04 36b7                      	cpi r27, 0x67
001d05 f408                      	brsh sound_driver_channel2_check_if_delay
001d06 c19e                      	rjmp sound_driver_channel2_volume
                                 sound_driver_channel2_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001d07 3eb3                      	cpi r27, 0xE3
001d08 f408                      	brsh sound_driver_channel2_check_if_instrument
001d09 c1a9                      	rjmp sound_driver_channel2_delay
                                 sound_driver_channel2_check_if_instrument: //check for instrument flag (0xE3)
001d0a f409                      	brne sound_driver_channel2_check_if_release
001d0b c1ac                      	rjmp sound_driver_channel2_instrument_change 
                                 sound_driver_channel2_check_if_release: //check for note release flag (0xE4)
001d0c 3eb4                      	cpi r27, 0xE4
001d0d f409                      	brne sound_driver_channel2_check_if_end
001d0e c255                      	rjmp sound_driver_channel2_release
                                 sound_driver_channel2_check_if_end:
001d0f 3fbf                      	cpi r27, 0xFF
001d10 f409                      	brne sound_driver_channel2_check_if_fx
001d11 c277                      	rjmp sound_driver_channel2_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel2_check_if_fx: //fx flags (0xE5 - 0xFE)
001d12 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001d13 91a4                      	lpm r26, Z //load the fx data into r26
001d14 d296                      	rcall sound_driver_channel2_increment_offset_twice
                                 
001d15 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001d16 e4ec                      	ldi ZL, LOW(channel2_fx << 1) //load in note table
001d17 e6f1                      	ldi ZH, HIGH(channel2_fx << 1)
001d18 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001d19 0feb                      	add ZL, r27 //add offset
001d1a 1df2                      	adc ZH, zero
001d1b 91c5                      	lpm r28, Z+ //load address bytes
001d1c 91d4                      	lpm r29, Z
001d1d 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001d1e 2ffd                      	mov ZH, r29
001d1f 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel2_fx_0xy:
001d20 93a0 28e3                 	sts triangle_fx_0xy_sequence, r26
001d22 9220 28e4                 	sts triangle_fx_0xy_sequence+1, zero
001d24 cfd1                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel2_fx_1xx:
001d25 9220 28e9                 	sts triangle_fx_2xx, zero //turn off any 2xx pitch slide down
001d27 9220 28ea                 	sts triangle_fx_2xx+1, zero
001d29 9220 28e3                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001d2b 9220 28e4                 	sts triangle_fx_0xy_sequence+1, zero
001d2d 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001d2e 937f                      	push r23
001d2f 2f6a                      	mov r22, r26 //store the rate into r22
001d30 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001d31 9f67                      	mul r22, r23
001d32 917f                      	pop r23
001d33 916f                      	pop r22
                                 
001d34 9416                      	lsr r1 //shift out the fractional bits
001d35 9407                      	ror r0
001d36 9416                      	lsr r1
001d37 9407                      	ror r0
001d38 9416                      	lsr r1
001d39 9407                      	ror r0
001d3a 9416                      	lsr r1
001d3b 9407                      	ror r0
001d3c 9200 28e5                 	sts triangle_fx_1xx, r0
001d3e 9210 28e6                 	sts triangle_fx_1xx+1, r1
001d40 cfb5                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel2_fx_2xx:
001d41 9220 28e5                 	sts triangle_fx_1xx, zero //turn off any 1xx pitch slide down
001d43 9220 28e6                 	sts triangle_fx_1xx+1, zero
001d45 9220 28e3                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001d47 9220 28e4                 	sts triangle_fx_0xy_sequence+1, zero
001d49 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001d4a 937f                      	push r23
001d4b 2f6a                      	mov r22, r26 //store the rate into r22
001d4c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001d4d 9f67                      	mul r22, r23
001d4e 917f                      	pop r23
001d4f 916f                      	pop r22
                                 
001d50 9416                      	lsr r1 //shift out the fractional bits
001d51 9407                      	ror r0
001d52 9416                      	lsr r1
001d53 9407                      	ror r0
001d54 9416                      	lsr r1
001d55 9407                      	ror r0
001d56 9416                      	lsr r1
001d57 9407                      	ror r0
001d58 9200 28e9                 	sts triangle_fx_2xx, r0
001d5a 9210 28ea                 	sts triangle_fx_2xx+1, r1
001d5c cf99                      	rjmp sound_driver_channel2_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel2_fx_3xx:
001d5d 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001d5e 937f                      	push r23
001d5f 2f6a                      	mov r22, r26 //store the rate into r22
001d60 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001d61 9f67                      	mul r22, r23
001d62 917f                      	pop r23
001d63 916f                      	pop r22
                                 
001d64 9416                      	lsr r1 //shift out the fractional bits
001d65 9407                      	ror r0
001d66 9416                      	lsr r1
001d67 9407                      	ror r0
001d68 9416                      	lsr r1
001d69 9407                      	ror r0
001d6a 9416                      	lsr r1
001d6b 9407                      	ror r0
001d6c 9200 28f1                 	sts triangle_fx_3xx_speed, r0
001d6e 9210 28f2                 	sts triangle_fx_3xx_speed+1, r1
                                 
001d70 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001d71 c001                      	rjmp sound_driver_channel2_fx_3xx_enabled
001d72 cf83                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_3xx_enabled:
001d73 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001d75 91b0 0aad                 	lds r27, TCB2_CCMPH
001d77 93a0 28ed                 	sts triangle_fx_3xx_start, r26
001d79 93b0 28ee                 	sts triangle_fx_3xx_start+1, r27
                                 
001d7b 9220 28f3                 	sts triangle_fx_3xx_total_offset, zero
001d7d 9220 28f4                 	sts triangle_fx_3xx_total_offset+1, zero
001d7f cf76                      	rjmp sound_driver_channel2_main
                                 
                                 //VIBRATO
                                 sound_driver_channel2_fx_4xy:
001d80 2fba                      	mov r27, r26
001d81 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001d82 95a2                      	swap r26
001d83 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001d84 93a0 28f5                 	sts triangle_fx_4xy_speed, r26
001d86 93b0 28f6                 	sts triangle_fx_4xy_depth, r27
001d88 9220 28f7                 	sts triangle_fx_4xy_phase, zero //reset the phase to 0
001d8a cf6b                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_7xy: //tremelo
001d8b cf6a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Axy: //volume slide
001d8c cf69                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel2_fx_Bxx:
001d8d 93a0 281f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001d8f cf66                      	rjmp sound_driver_channel2_main
                                 
                                 //HALT
                                 sound_driver_channel2_fx_Cxx:
001d90 93b0 2820                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001d92 cf63                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel2_fx_Dxx:
001d93 93b0 2821                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001d95 cf60                      	rjmp sound_driver_channel2_main
                                 
                                 //VOLUME
                                 sound_driver_channel2_fx_Exx:
001d96 15a2                      	cp r26, zero
001d97 f021                      	breq sound_driver_channel2_fx_Exx_disable
                                 sound_driver_channel2_fx_Exx_enable:
001d98 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001d99 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001d9b cf5a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Exx_disable:
001d9c 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
001d9e 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
001da0 9220 0aad                 	sts TCB2_CCMPH, zero
001da2 cf53                      	rjmp sound_driver_channel2_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel2_fx_Fxx:
001da3 93a0 281e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001da5 cf50                      	rjmp sound_driver_channel2_main
                                 
                                 //DELAY
                                 sound_driver_channel2_fx_Gxx:
001da6 15a2                      	cp r26, zero
001da7 f051                      	breq sound_driver_channel2_fx_Gxx_invalid
001da8 91b0 281e                 	lds r27, song_speed
001daa 17ab                      	cp r26, r27
001dab f430                      	brsh sound_driver_channel2_fx_Gxx_invalid
001dac 93a0 28f8                 	sts triangle_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001dae e0b1                      	ldi r27, 0x01
001daf 93b0 28c2                 	sts triangle_pattern_delay_rows, r27
001db1 c206                      	rjmp sound_driver_channel3
                                 sound_driver_channel2_fx_Gxx_invalid:
001db2 cf43                      	rjmp sound_driver_channel2_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Hxy: //hardware sweep up
001db3 cf42                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixy: //hardware sweep down
001db4 cf41                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Hxx: //FDS modulation depth
001db5 cf40                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixx: //FDS modulation speed
001db6 cf3f                      	rjmp sound_driver_channel2_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel2_fx_Pxx:
001db7 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001db8 937f                      	push r23
001db9 2f6a                      	mov r22, r26
001dba eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001dbb 0367                      	mulsu r22, r23
001dbc 917f                      	pop r23
001dbd 916f                      	pop r22
001dbe 9416                      	lsr r1 //shift out the fractional bits
001dbf 9407                      	ror r0
001dc0 9416                      	lsr r1
001dc1 9407                      	ror r0
001dc2 9416                      	lsr r1
001dc3 9407                      	ror r0
001dc4 9416                      	lsr r1
001dc5 9407                      	ror r0
001dc6 fe13                      	sbrs r1, 3 //check if result was a negative number
001dc7 c002                      	rjmp sound_driver_channel2_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel2_fx_Pxx_negative:
001dc8 efb0                      	ldi r27, 0xF0
001dc9 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel2_fx_Pxx_store:
001dca 9200 28fa                 	sts triangle_fx_Pxx_total, r0
001dcc 9210 28fb                 	sts triangle_fx_Pxx_total+1, r1
001dce cf27                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel2_fx_Qxy:
                                 sound_driver_channel2_fx_Qxy_check_arpeggio_macro:
001dcf 91e0 28cb                 	lds ZL, triangle_arpeggio_macro
001dd1 91f0 28cc                 	lds ZH, triangle_arpeggio_macro+1
001dd3 9630                      	adiw Z, 0
001dd4 f009                      	breq sound_driver_channel2_fx_Qxy_check_pitch_macro
001dd5 cf20                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_pitch_macro:
001dd6 91e0 28d3                 	lds ZL, triangle_pitch_macro
001dd8 91f0 28d4                 	lds ZH, triangle_pitch_macro+1
001dda 9630                      	adiw Z, 0
001ddb f009                      	breq sound_driver_channel2_fx_Qxy_check_hi_pitch_macro
001ddc cf19                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_hi_pitch_macro:
001ddd 91e0 28d9                 	lds ZL, triangle_hi_pitch_macro
001ddf 91f0 28da                 	lds ZH, triangle_hi_pitch_macro+1
001de1 9630                      	adiw Z, 0
001de2 f009                      	breq sound_driver_channel2_fx_Qxy_process
001de3 cf12                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_process:
001de4 2fba                      	mov r27, r26 //copy fx parameters into r27
001de5 70bf                      	andi r27, 0x0F //mask note index offset
001de6 91c0 2812                 	lds r28, triangle_note //load current note index
001de8 0fbc                      	add r27, r28
001de9 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001dea f008                      	brlo sound_driver_channel2_fx_Qxy_process_continue
001deb e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel2_fx_Qxy_process_continue:
001dec e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001ded e0f0                      	ldi ZH, HIGH(note_table << 1)
001dee 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001def 0feb                      	add ZL, r27 //add offset
001df0 1df2                      	adc ZH, zero
001df1 91c5                      	lpm r28, Z+ //load bytes
001df2 91d4                      	lpm r29, Z
001df3 93c0 28fc                 	sts triangle_fx_Qxy_target, r28 //load the LOW bits for the target period
001df5 93d0 28fd                 	sts triangle_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
001df7 95a2                      	swap r26
001df8 70af                      	andi r26, 0x0F //mask effect speed
001df9 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001dfa 95a3                      	inc r26 //increment the speed by 1
                                 
001dfb 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001dfc 937f                      	push r23
001dfd 2f6a                      	mov r22, r26 //store the speed data into r27
001dfe eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001dff 9f67                      	mul r22, r23
001e00 917f                      	pop r23
001e01 916f                      	pop r22
                                 
001e02 9416                      	lsr r1 //shift out the fractional bits
001e03 9407                      	ror r0
001e04 9416                      	lsr r1
001e05 9407                      	ror r0
001e06 9416                      	lsr r1
001e07 9407                      	ror r0
001e08 9416                      	lsr r1
001e09 9407                      	ror r0
                                 
001e0a 9200 28fe                 	sts triangle_fx_Qxy_speed, r0 //store the effect speed
001e0c 9210 28ff                 	sts triangle_fx_Qxy_speed+1, r1
001e0e 9220 2900                 	sts triangle_fx_Qxy_total_offset, zero
001e10 9220 2901                 	sts triangle_fx_Qxy_total_offset+1, zero
001e12 cee3                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel2_fx_Rxy:
                                 sound_driver_channel2_fx_Rxy_check_arpeggio_macro:
001e13 91e0 28cb                 	lds ZL, triangle_arpeggio_macro
001e15 91f0 28cc                 	lds ZH, triangle_arpeggio_macro+1
001e17 9630                      	adiw Z, 0
001e18 f009                      	breq sound_driver_channel2_fx_Rxy_check_pitch_macro
001e19 cedc                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_pitch_macro:
001e1a 91e0 28d3                 	lds ZL, triangle_pitch_macro
001e1c 91f0 28d4                 	lds ZH, triangle_pitch_macro+1
001e1e 9630                      	adiw Z, 0
001e1f f009                      	breq sound_driver_channel2_fx_Rxy_check_hi_pitch_macro
001e20 ced5                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_hi_pitch_macro:
001e21 91e0 28d9                 	lds ZL, triangle_hi_pitch_macro
001e23 91f0 28da                 	lds ZH, triangle_hi_pitch_macro+1
001e25 9630                      	adiw Z, 0
001e26 f009                      	breq sound_driver_channel2_fx_Rxy_process
001e27 cece                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_process:
001e28 2fba                      	mov r27, r26 //copy fx parameters into r27
001e29 70bf                      	andi r27, 0x0F //mask note index offset
001e2a 91c0 2812                 	lds r28, triangle_note //load current note index
001e2c 1bcb                      	sub r28, r27
001e2d f408                      	brcc sound_driver_channel2_fx_Rxy_process_continue
001e2e e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel2_fx_Rxy_process_continue:
001e2f e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001e30 e0f0                      	ldi ZH, HIGH(note_table << 1)
001e31 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001e32 0fec                      	add ZL, r28 //add offset
001e33 1df2                      	adc ZH, zero
001e34 91c5                      	lpm r28, Z+ //load bytes
001e35 91d4                      	lpm r29, Z
001e36 93c0 2902                 	sts triangle_fx_Rxy_target, r28 //load the LOW bits for the target period
001e38 93d0 2903                 	sts triangle_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
001e3a 95a2                      	swap r26
001e3b 70af                      	andi r26, 0x0F //mask effect speed
001e3c 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001e3d 95a3                      	inc r26 //increment the speed by 1
                                 
001e3e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001e3f 937f                      	push r23
001e40 2f6a                      	mov r22, r26 //store the speed data into r27
001e41 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001e42 9f67                      	mul r22, r23
001e43 917f                      	pop r23
001e44 916f                      	pop r22
                                 
001e45 9416                      	lsr r1 //shift out the fractional bits
001e46 9407                      	ror r0
001e47 9416                      	lsr r1
001e48 9407                      	ror r0
001e49 9416                      	lsr r1
001e4a 9407                      	ror r0
001e4b 9416                      	lsr r1
001e4c 9407                      	ror r0
                                 
001e4d 9200 2904                 	sts triangle_fx_Rxy_speed, r0 //store the effect speed
001e4f 9210 2905                 	sts triangle_fx_Rxy_speed+1, r1
001e51 9220 2906                 	sts triangle_fx_Rxy_total_offset, zero
001e53 9220 2907                 	sts triangle_fx_Rxy_total_offset+1, zero
001e55 cea0                      	rjmp sound_driver_channel2_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel2_fx_Sxx:
001e56 15a2                      	cp r26, zero
001e57 f051                      	breq sound_driver_channel2_fx_Sxx_invalid
001e58 91b0 281e                 	lds r27, song_speed
001e5a 17ab                      	cp r26, r27
001e5b f430                      	brsh sound_driver_channel2_fx_Sxx_invalid
001e5c 93a0 2908                 	sts triangle_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001e5e e0b1                      	ldi r27, 0x01
001e5f 93b0 28c2                 	sts triangle_pattern_delay_rows, r27
001e61 c156                      	rjmp sound_driver_channel3
                                 sound_driver_channel2_fx_Sxx_invalid:
001e62 ce93                      	rjmp sound_driver_channel2_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Vxx: //duty
001e63 ce92                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Wxx: //DPCM sample speed
001e64 ce91                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Xxx: //DPCM sample retrigger
001e65 ce90                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Yxx: //DPCM sample offset
001e66 ce8f                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Zxx: //DPCM sample delta counter
001e67 ce8e                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 sound_driver_channel2_note:
001e68 93b0 2812                 	sts triangle_note, r27 //store the note index
001e6a e0a3                      	ldi r26, 0x03
001e6b e0b2                      	ldi r27, 0x02
001e6c 93b0 28c8                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
001e6e 93a0 28cd                 	sts triangle_arpeggio_macro_offset, r26
001e70 93b0 28d5                 	sts triangle_pitch_macro_offset, r27
001e72 93b0 28db                 	sts triangle_hi_pitch_macro_offset, r27
001e74 93b0 28e0                 	sts triangle_duty_macro_offset, r27
001e76 9220 28d1                 	sts triangle_total_pitch_offset, zero //reset the pitch and hi pitch offset
001e78 9220 28d2                 	sts triangle_total_pitch_offset+1, zero
001e7a 9220 28d8                 	sts triangle_total_hi_pitch_offset, zero
001e7c 9220 28e7                 	sts triangle_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001e7e 9220 28e8                 	sts triangle_fx_1xx_total+1, zero
001e80 9220 28eb                 	sts triangle_fx_2xx_total, zero
001e82 9220 28ec                 	sts triangle_fx_2xx_total+1, zero
001e84 9220 28f3                 	sts triangle_fx_3xx_total_offset, zero //reset 3xx offset
001e86 9220 28f4                 	sts triangle_fx_3xx_total_offset+1, zero
001e88 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001e8a 91b0 0aad                 	lds r27, TCB2_CCMPH
001e8c 93a0 28ed                 	sts triangle_fx_3xx_start, r26
001e8e 93b0 28ee                 	sts triangle_fx_3xx_start+1, r27
001e90 9220 28fc                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001e92 9220 28fd                 	sts triangle_fx_Qxy_target+1, zero
001e94 9220 2900                 	sts triangle_fx_Qxy_total_offset, zero
001e96 9220 2901                 	sts triangle_fx_Qxy_total_offset+1, zero
001e98 9220 2902                 	sts triangle_fx_Rxy_target, zero
001e9a 9220 2903                 	sts triangle_fx_Rxy_target+1, zero
001e9c 9220 2906                 	sts triangle_fx_Rxy_total_offset, zero
001e9e 9220 2907                 	sts triangle_fx_Rxy_total_offset+1, zero
001ea0 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001ea1 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001ea3 d0fd                      	rcall sound_driver_channel2_increment_offset
001ea4 ce51                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_volume:
001ea5 d0fb                      	rcall sound_driver_channel2_increment_offset
001ea6 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001ea7 f021                      	breq sound_driver_channel2_volume_disable
                                 sound_driver_channel2_volume_enable:
001ea8 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001ea9 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001eab ce4a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_volume_disable:
001eac 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
001eae 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
001eb0 9220 0aad                 	sts TCB2_CCMPH, zero
001eb2 ce43                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_delay:
001eb3 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001eb4 93b0 28c2                 	sts triangle_pattern_delay_rows, r27
001eb6 d0ea                      	rcall sound_driver_channel2_increment_offset
001eb7 c100                      	rjmp sound_driver_channel3
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change:
001eb8 9220 28c6                 	sts triangle_volume_macro, zero //reset all macro addresses
001eba 9220 28c7                 	sts triangle_volume_macro+1, zero
001ebc 9220 28cb                 	sts triangle_arpeggio_macro, zero
001ebe 9220 28cc                 	sts triangle_arpeggio_macro+1, zero
001ec0 9220 28d3                 	sts triangle_pitch_macro, zero
001ec2 9220 28d4                 	sts triangle_pitch_macro+1, zero
001ec4 9220 28d9                 	sts triangle_hi_pitch_macro, zero
001ec6 9220 28da                 	sts triangle_hi_pitch_macro+1, zero
001ec8 9220 28de                 	sts triangle_duty_macro, zero
001eca 9220 28df                 	sts triangle_duty_macro+1, zero
001ecc 9220 28d1                 	sts triangle_total_pitch_offset, zero //reset the pitch offset
001ece 9220 28d2                 	sts triangle_total_pitch_offset+1, zero
001ed0 9220 28d8                 	sts triangle_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001ed2 9631                      	adiw Z, 1 //point to the byte next to the flag
001ed3 91b4                      	lpm r27, Z //store the instrument offset into r27
001ed4 e7e1                      	ldi ZL, LOW(instruments) //point Z to instruments table
001ed5 e1f0                      	ldi ZH, HIGH(instruments)
001ed6 0feb                      	add ZL, r27 //point Z to offsetted instrument
001ed7 1df2                      	adc ZH, zero
001ed8 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001ed9 1fff                      	rol ZH
001eda 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001edb 91b4                      	lpm r27, Z
                                 
001edc 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001edd 1fbb                      	rol r27
001ede 2fea                      	mov ZL, r26
001edf 2ffb                      	mov ZH, r27
001ee0 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001ee1 9632                      	adiw Z, 2 //point Z to the address of the macro
001ee2 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel2_instrument_change_macro_loop:
001ee3 95aa                      	dec r26
001ee4 f019                      	breq sound_driver_channel2_instrument_change_exit
001ee5 95b6                      	lsr r27
001ee6 f078                      	brcs sound_driver_channel2_instrument_change_load_macro
001ee7 cffb                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_exit:
001ee8 e0a3                      	ldi r26, 0x03
001ee9 e0b2                      	ldi r27, 0x02
001eea 93b0 28c8                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
001eec 93a0 28cd                 	sts triangle_arpeggio_macro_offset, r26
001eee 93b0 28d5                 	sts triangle_pitch_macro_offset, r27
001ef0 93b0 28db                 	sts triangle_hi_pitch_macro_offset, r27
001ef2 93b0 28e0                 	sts triangle_duty_macro_offset, r27
001ef4 d0b6                      	rcall sound_driver_channel2_increment_offset_twice
001ef5 ce00                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_load_macro:
001ef6 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001ef7 91d5                      	lpm r29, Z+
                                 
001ef8 30a5                      	cpi r26, 5
001ef9 f039                      	breq sound_driver_channel2_instrument_change_load_macro_volume
001efa 30a4                      	cpi r26, 4
001efb f079                      	breq sound_driver_channel2_instrument_change_load_macro_arpeggio
001efc 30a3                      	cpi r26, 3
001efd f0d9                      	breq sound_driver_channel2_instrument_change_load_macro_pitch
001efe 30a2                      	cpi r26, 2
001eff f159                      	breq sound_driver_channel2_instrument_change_load_macro_hi_pitch
001f00 c03c                      	rjmp sound_driver_channel2_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel2_instrument_change_load_macro_volume:
001f01 93c0 28c6                 	sts triangle_volume_macro, r28
001f03 93d0 28c7                 	sts triangle_volume_macro+1, r29
001f05 d041                      	rcall sound_driver_channel2_instrument_change_read_header
001f06 93c0 28ca                 	sts triangle_volume_macro_release, r28
001f08 93d0 28c9                 	sts triangle_volume_macro_loop, r29
001f0a cfd8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 	
                                 sound_driver_channel2_instrument_change_load_macro_arpeggio:
001f0b 93c0 28cb                 	sts triangle_arpeggio_macro, r28
001f0d 93d0 28cc                 	sts triangle_arpeggio_macro+1, r29
001f0f 9220 28fc                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001f11 9220 28fd                 	sts triangle_fx_Qxy_target+1, zero
001f13 9220 2902                 	sts triangle_fx_Rxy_target, zero
001f15 9220 2903                 	sts triangle_fx_Rxy_target+1, zero
001f17 d03a                      	rcall sound_driver_channel2_instrument_change_read_header_arpeggio
001f18 cfca                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_pitch:
001f19 93c0 28d3                 	sts triangle_pitch_macro, r28
001f1b 93d0 28d4                 	sts triangle_pitch_macro+1, r29
001f1d 9220 28fc                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001f1f 9220 28fd                 	sts triangle_fx_Qxy_target+1, zero
001f21 9220 2902                 	sts triangle_fx_Rxy_target, zero
001f23 9220 2903                 	sts triangle_fx_Rxy_target+1, zero
001f25 d021                      	rcall sound_driver_channel2_instrument_change_read_header
001f26 93c0 28d7                 	sts triangle_pitch_macro_release, r28
001f28 93d0 28d6                 	sts triangle_pitch_macro_loop, r29
001f2a cfb8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_hi_pitch:
001f2b 93c0 28d9                 	sts triangle_hi_pitch_macro, r28
001f2d 93d0 28da                 	sts triangle_hi_pitch_macro+1, r29
001f2f 9220 28fc                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001f31 9220 28fd                 	sts triangle_fx_Qxy_target+1, zero
001f33 9220 2902                 	sts triangle_fx_Rxy_target, zero
001f35 9220 2903                 	sts triangle_fx_Rxy_target+1, zero
001f37 d00f                      	rcall sound_driver_channel2_instrument_change_read_header
001f38 93c0 28dd                 	sts triangle_hi_pitch_macro_release, r28
001f3a 93d0 28dc                 	sts triangle_hi_pitch_macro_loop, r29
001f3c cfa6                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_duty:
001f3d 93c0 28de                 	sts triangle_duty_macro, r28
001f3f 93d0 28df                 	sts triangle_duty_macro+1, r29
001f41 d005                      	rcall sound_driver_channel2_instrument_change_read_header
001f42 93c0 28e2                 	sts triangle_duty_macro_release, r28
001f44 93d0 28e1                 	sts triangle_duty_macro_loop, r29
001f46 cf9c                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_read_header:
001f47 93ef                      	push ZL
001f48 93ff                      	push ZH
001f49 2fec                      	mov ZL, r28
001f4a 2ffd                      	mov ZH, r29
001f4b 0fee                      	lsl ZL
001f4c 1fff                      	rol ZH
001f4d 91c5                      	lpm r28, Z+
001f4e 91d4                      	lpm r29, Z
001f4f 91ff                      	pop ZH
001f50 91ef                      	pop ZL
001f51 9508                      	ret
                                 
                                 sound_driver_channel2_instrument_change_read_header_arpeggio:
001f52 93ef                      	push ZL
001f53 93ff                      	push ZH
001f54 2fec                      	mov ZL, r28
001f55 2ffd                      	mov ZH, r29
001f56 0fee                      	lsl ZL
001f57 1fff                      	rol ZH
001f58 91c5                      	lpm r28, Z+
001f59 91d5                      	lpm r29, Z+
001f5a 93c0 28cf                 	sts triangle_arpeggio_macro_release, r28
001f5c 93d0 28ce                 	sts triangle_arpeggio_macro_loop, r29
001f5e 91c4                      	lpm r28, Z
001f5f 93c0 28d0                 	sts triangle_arpeggio_macro_mode, r28
001f61 91ff                      	pop ZH
001f62 91ef                      	pop ZL
001f63 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel2_release:
                                 sound_driver_channel2_release_volume:
001f64 91b0 28ca                 	lds r27, triangle_volume_macro_release
001f66 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001f67 f019                      	breq sound_driver_channel2_release_arpeggio //if the macro has no release flag, check the next macro
001f68 95b3                      	inc r27
001f69 93b0 28c8                 	sts triangle_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel2_release_arpeggio:
001f6b 91b0 28cf                 	lds r27, triangle_arpeggio_macro_release
001f6d 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001f6e f019                      	breq sound_driver_channel2_release_pitch
001f6f 95b3                      	inc r27
001f70 93b0 28cd                 	sts triangle_arpeggio_macro_offset, r27
                                 sound_driver_channel2_release_pitch:
001f72 91b0 28d7                 	lds r27, triangle_pitch_macro_release
001f74 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001f75 f019                      	breq sound_driver_channel2_release_hi_pitch
001f76 95b3                      	inc r27
001f77 93b0 28d5                 	sts triangle_pitch_macro_offset, r27
                                 sound_driver_channel2_release_hi_pitch:
001f79 91b0 28dd                 	lds r27, triangle_hi_pitch_macro_release
001f7b 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001f7c f019                      	breq sound_driver_channel2_release_duty
001f7d 95b3                      	inc r27
001f7e 93b0 28db                 	sts triangle_hi_pitch_macro_offset, r27
                                 sound_driver_channel2_release_duty:
001f80 91b0 28e2                 	lds r27, triangle_duty_macro_release
001f82 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001f83 f019                      	breq sound_driver_channel2_release_exit
001f84 95b3                      	inc r27
001f85 93b0 28e0                 	sts triangle_duty_macro_offset, r27
                                 sound_driver_channel2_release_exit:
001f87 d019                      	rcall sound_driver_channel2_increment_offset
001f88 cd6d                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_next_pattern:
001f89 91e0 2818                 	lds ZL, song_frames
001f8b 91f0 2819                 	lds ZH, song_frames+1
001f8d 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001f8f 91b0 281b                 	lds r27, song_frame_offset+1
001f91 9614                      	adiw r27:r26, 4 //offset for channel 2
001f92 0fea                      	add ZL, r26
001f93 1ffb                      	adc ZH, r27
                                 
001f94 91a5                      	lpm r26, Z+ //load the address of the next pattern
001f95 91b4                      	lpm r27, Z
001f96 0faa                      	lsl r26
001f97 1fbb                      	rol r27
001f98 93a0 28c0                 	sts triangle_pattern, r26
001f9a 93b0 28c1                 	sts triangle_pattern+1, r27
                                 
001f9c 9220 28c4                 	sts triangle_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001f9e 9220 28c5                 	sts triangle_pattern_offset+1, zero
001fa0 cd55                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_increment_offset:
001fa1 91e0 28c4                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
001fa3 91f0 28c5                 	lds ZH, triangle_pattern_offset+1
001fa5 9631                      	adiw Z, 1
001fa6 93e0 28c4                 	sts triangle_pattern_offset, ZL
001fa8 93f0 28c5                 	sts triangle_pattern_offset+1, ZH
001faa 9508                      	ret
                                 
                                 sound_driver_channel2_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001fab 91e0 28c4                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
001fad 91f0 28c5                 	lds ZH, triangle_pattern_offset+1
001faf 9632                      	adiw Z, 2 //increment the pointer twice
001fb0 93e0 28c4                 	sts triangle_pattern_offset, ZL
001fb2 93f0 28c5                 	sts triangle_pattern_offset+1, ZH
001fb4 9508                      	ret
                                 
                                 sound_driver_channel2_decrement_frame_delay:
001fb5 95ba                      	dec r27
001fb6 93b0 28c3                 	sts triangle_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel3:
001fb8 91a0 290c                 	lds r26, noise_pattern_delay_rows
001fba 91b0 290d                 	lds r27, noise_pattern_delay_frames
001fbc 9610                      	adiw r27:r26, 0
001fbd f009                      	breq sound_driver_channel3_main //if the pattern delay is 0, proceed with sound driver procedures
001fbe c2cd                      	rjmp sound_driver_channel3_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel3_main:
001fbf 91e0 290a                 	lds ZL, noise_pattern //current pattern for noise
001fc1 91f0 290b                 	lds ZH, noise_pattern+1
001fc3 91a0 290e                 	lds r26, noise_pattern_offset //current offset in the pattern for noise
001fc5 91b0 290f                 	lds r27, noise_pattern_offset+1
001fc7 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001fc8 1ffb                      	adc ZH, r27
001fc9 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel3_check_if_note: //check if data is a note (0x00 - 0x56)
001fca 35b7                      	cpi r27, 0x57
001fcb f408                      	brsh sound_driver_channel3_check_if_volume
001fcc c176                      	rjmp sound_driver_channel3_note
                                 sound_driver_channel3_check_if_volume: //check if data is volume (0x57-0x66)
001fcd 36b7                      	cpi r27, 0x67
001fce f408                      	brsh sound_driver_channel3_check_if_delay
001fcf c1ad                      	rjmp sound_driver_channel3_volume
                                 sound_driver_channel3_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001fd0 3eb3                      	cpi r27, 0xE3
001fd1 f408                      	brsh sound_driver_channel3_check_if_instrument
001fd2 c1b3                      	rjmp sound_driver_channel3_delay
                                 sound_driver_channel3_check_if_instrument: //check for instrument flag (0xE3)
001fd3 f409                      	brne sound_driver_channel3_check_if_release
001fd4 c1b6                      	rjmp sound_driver_channel3_instrument_change 
                                 sound_driver_channel3_check_if_release: //check for note release flag (0xE4)
001fd5 3eb4                      	cpi r27, 0xE4
001fd6 f409                      	brne sound_driver_channel3_check_if_end
001fd7 c25f                      	rjmp sound_driver_channel3_release
                                 sound_driver_channel3_check_if_end:
001fd8 3fbf                      	cpi r27, 0xFF
001fd9 f409                      	brne sound_driver_channel3_check_if_fx
001fda c281                      	rjmp sound_driver_channel3_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel3_check_if_fx: //fx flags (0xE5 - 0xFE)
001fdb 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001fdc 91a4                      	lpm r26, Z //load the fx data into r26
001fdd d2a4                      	rcall sound_driver_channel3_increment_offset_twice
                                 
001fde 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001fdf e8e0                      	ldi ZL, LOW(channel3_fx << 1) //load in note table
001fe0 e6f1                      	ldi ZH, HIGH(channel3_fx << 1)
001fe1 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001fe2 0feb                      	add ZL, r27 //add offset
001fe3 1df2                      	adc ZH, zero
001fe4 91c5                      	lpm r28, Z+ //load address bytes
001fe5 91d4                      	lpm r29, Z
001fe6 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001fe7 2ffd                      	mov ZH, r29
001fe8 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel3_fx_0xy:
001fe9 93a0 292d                 	sts noise_fx_0xy_sequence, r26
001feb 9220 292e                 	sts noise_fx_0xy_sequence+1, zero
001fed cfd1                      	rjmp sound_driver_channel3_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel3_fx_1xx:
001fee 9220 2933                 	sts noise_fx_2xx, zero //turn off any 2xx pitch slide down
001ff0 9220 2934                 	sts noise_fx_2xx+1, zero
001ff2 9220 292d                 	sts noise_fx_0xy_sequence, zero //disable any 0xy effect
001ff4 9220 292e                 	sts noise_fx_0xy_sequence+1, zero
001ff6 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001ff7 937f                      	push r23
001ff8 2f6a                      	mov r22, r26 //store the rate into r22
001ff9 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001ffa 9f67                      	mul r22, r23
001ffb 917f                      	pop r23
001ffc 916f                      	pop r22
                                 
001ffd 9416                      	lsr r1 //shift out the fractional bits
001ffe 9407                      	ror r0
001fff 9416                      	lsr r1
002000 9407                      	ror r0
002001 9416                      	lsr r1
002002 9407                      	ror r0
002003 9416                      	lsr r1
002004 9407                      	ror r0
002005 9200 292f                 	sts noise_fx_1xx, r0
002007 9210 2930                 	sts noise_fx_1xx+1, r1
002009 cfb5                      	rjmp sound_driver_channel3_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel3_fx_2xx:
00200a 9220 292f                 	sts noise_fx_1xx, zero //turn off any 1xx pitch slide down
00200c 9220 2930                 	sts noise_fx_1xx+1, zero
00200e 9220 292d                 	sts noise_fx_0xy_sequence, zero //disable any 0xy effect
002010 9220 292e                 	sts noise_fx_0xy_sequence+1, zero
002012 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002013 937f                      	push r23
002014 2f6a                      	mov r22, r26 //store the rate into r22
002015 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002016 9f67                      	mul r22, r23
002017 917f                      	pop r23
002018 916f                      	pop r22
                                 
002019 9416                      	lsr r1 //shift out the fractional bits
00201a 9407                      	ror r0
00201b 9416                      	lsr r1
00201c 9407                      	ror r0
00201d 9416                      	lsr r1
00201e 9407                      	ror r0
00201f 9416                      	lsr r1
002020 9407                      	ror r0
002021 9200 2933                 	sts noise_fx_2xx, r0
002023 9210 2934                 	sts noise_fx_2xx+1, r1
002025 cf99                      	rjmp sound_driver_channel3_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel3_fx_3xx:
002026 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002027 937f                      	push r23
002028 2f6a                      	mov r22, r26 //store the rate into r22
002029 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00202a 9f67                      	mul r22, r23
00202b 917f                      	pop r23
00202c 916f                      	pop r22
                                 
00202d 9416                      	lsr r1 //shift out the fractional bits
00202e 9407                      	ror r0
00202f 9416                      	lsr r1
002030 9407                      	ror r0
002031 9416                      	lsr r1
002032 9407                      	ror r0
002033 9416                      	lsr r1
002034 9407                      	ror r0
002035 9200 293b                 	sts noise_fx_3xx_speed, r0
002037 9210 293c                 	sts noise_fx_3xx_speed+1, r1
                                 
002039 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
00203a c001                      	rjmp sound_driver_channel3_fx_3xx_enabled
00203b cf83                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_3xx_enabled:
00203c 91a0 0abc                 	lds r26, TCB3_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
00203e 91b0 0abd                 	lds r27, TCB3_CCMPH
002040 93a0 2937                 	sts noise_fx_3xx_start, r26
002042 93b0 2938                 	sts noise_fx_3xx_start+1, r27
                                 
002044 9220 293d                 	sts noise_fx_3xx_total_offset, zero
002046 9220 293e                 	sts noise_fx_3xx_total_offset+1, zero
002048 cf76                      	rjmp sound_driver_channel3_main
                                 
                                 //VIBRATO
                                 sound_driver_channel3_fx_4xy:
002049 2fba                      	mov r27, r26
00204a 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
00204b 95a2                      	swap r26
00204c 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
00204d 93a0 293f                 	sts noise_fx_4xy_speed, r26
00204f 93b0 2940                 	sts noise_fx_4xy_depth, r27
002051 9220 2941                 	sts noise_fx_4xy_phase, zero //reset the phase to 0
002053 cf6b                      	rjmp sound_driver_channel3_main
                                 
                                 //TREMELO
                                 sound_driver_channel3_fx_7xy:
002054 2fba                      	mov r27, r26
002055 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
002056 95a2                      	swap r26
002057 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
002058 93a0 2942                 	sts noise_fx_7xy_speed, r26
00205a 93b0 2943                 	sts noise_fx_7xy_depth, r27
00205c 9220 2944                 	sts noise_fx_7xy_phase, zero //reset the phase to 0
00205e 9220 2945                 	sts noise_fx_7xy_value, zero //reset the tremelo value
002060 cf5e                      	rjmp sound_driver_channel3_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel3_fx_Axy:
002061 93a0 2946                 	sts noise_fx_Axy, r26
002063 cf5b                      	rjmp sound_driver_channel3_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel3_fx_Bxx:
002064 93a0 281f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
002066 cf58                      	rjmp sound_driver_channel3_main
                                 
                                 //HALT
                                 sound_driver_channel3_fx_Cxx:
002067 93b0 2820                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
002069 cf55                      	rjmp sound_driver_channel3_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel3_fx_Dxx:
00206a 93b0 2821                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
00206c cf52                      	rjmp sound_driver_channel3_main
                                 
                                 //VOLUME
                                 sound_driver_channel3_fx_Exx:
00206d 91b0 2813                 	lds r27, noise_param
00206f 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
002070 2bba                      	or r27, r26 //move new VVVV bits into noise_param
002071 93b0 2813                 	sts noise_param, r27
002073 cf4b                      	rjmp sound_driver_channel3_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel3_fx_Fxx:
002074 93a0 281e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
002076 cf48                      	rjmp sound_driver_channel3_main
                                 
                                 //DELAY
                                 sound_driver_channel3_fx_Gxx:
002077 15a2                      	cp r26, zero
002078 f051                      	breq sound_driver_channel3_fx_Gxx_invalid
002079 91b0 281e                 	lds r27, song_speed
00207b 17ab                      	cp r26, r27
00207c f430                      	brsh sound_driver_channel3_fx_Gxx_invalid
00207d 93a0 2947                 	sts noise_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
00207f e0b1                      	ldi r27, 0x01
002080 93b0 290c                 	sts noise_pattern_delay_rows, r27
002082 c20c                      	rjmp sound_driver_channel4
                                 sound_driver_channel3_fx_Gxx_invalid:
002083 cf3b                      	rjmp sound_driver_channel3_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel3_fx_Hxy: //hardware sweep up
002084 cf3a                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Ixy: //hardware sweep down
002085 cf39                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Hxx: //FDS modulation depth
002086 cf38                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Ixx: //FDS modulation speed
002087 cf37                      	rjmp sound_driver_channel3_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel3_fx_Pxx:
002088 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002089 937f                      	push r23
00208a 2f6a                      	mov r22, r26
00208b eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00208c 0367                      	mulsu r22, r23
00208d 917f                      	pop r23
00208e 916f                      	pop r22
00208f 9416                      	lsr r1 //shift out the fractional bits
002090 9407                      	ror r0
002091 9416                      	lsr r1
002092 9407                      	ror r0
002093 9416                      	lsr r1
002094 9407                      	ror r0
002095 9416                      	lsr r1
002096 9407                      	ror r0
002097 fe13                      	sbrs r1, 3 //check if result was a negative number
002098 c002                      	rjmp sound_driver_channel3_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel3_fx_Pxx_negative:
002099 efb0                      	ldi r27, 0xF0
00209a 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel3_fx_Pxx_store:
00209b 9200 2949                 	sts noise_fx_Pxx_total, r0
00209d 9210 294a                 	sts noise_fx_Pxx_total+1, r1
00209f cf1f                      	rjmp sound_driver_channel3_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel3_fx_Qxy:
                                 sound_driver_channel3_fx_Qxy_check_arpeggio_macro:
0020a0 91e0 2915                 	lds ZL, noise_arpeggio_macro
0020a2 91f0 2916                 	lds ZH, noise_arpeggio_macro+1
0020a4 9630                      	adiw Z, 0
0020a5 f009                      	breq sound_driver_channel3_fx_Qxy_check_pitch_macro
0020a6 cf18                      	rjmp sound_driver_channel3_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Qxy_check_pitch_macro:
0020a7 91e0 291d                 	lds ZL, noise_pitch_macro
0020a9 91f0 291e                 	lds ZH, noise_pitch_macro+1
0020ab 9630                      	adiw Z, 0
0020ac f009                      	breq sound_driver_channel3_fx_Qxy_check_hi_pitch_macro
0020ad cf11                      	rjmp sound_driver_channel3_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Qxy_check_hi_pitch_macro:
0020ae 91e0 2923                 	lds ZL, noise_hi_pitch_macro
0020b0 91f0 2924                 	lds ZH, noise_hi_pitch_macro+1
0020b2 9630                      	adiw Z, 0
0020b3 f009                      	breq sound_driver_channel3_fx_Qxy_process
0020b4 cf0a                      	rjmp sound_driver_channel3_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Qxy_process:
0020b5 2fba                      	mov r27, r26 //copy fx parameters into r27
0020b6 70bf                      	andi r27, 0x0F //mask note index offset
0020b7 91c0 2817                 	lds r28, noise_note //load current note index
0020b9 0fbc                      	add r27, r28
0020ba 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
0020bb f008                      	brlo sound_driver_channel3_fx_Qxy_process_continue
0020bc e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel3_fx_Qxy_process_continue:
0020bd e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0020be e0f0                      	ldi ZH, HIGH(note_table << 1)
0020bf 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
0020c0 0feb                      	add ZL, r27 //add offset
0020c1 1df2                      	adc ZH, zero
0020c2 91c5                      	lpm r28, Z+ //load bytes
0020c3 91d4                      	lpm r29, Z
0020c4 93c0 294b                 	sts noise_fx_Qxy_target, r28 //load the LOW bits for the target period
0020c6 93d0 294c                 	sts noise_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
0020c8 95a2                      	swap r26
0020c9 70af                      	andi r26, 0x0F //mask effect speed
0020ca 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0020cb 95a3                      	inc r26 //increment the speed by 1
                                 
0020cc 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0020cd 937f                      	push r23
0020ce 2f6a                      	mov r22, r26 //store the speed data into r27
0020cf eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0020d0 9f67                      	mul r22, r23
0020d1 917f                      	pop r23
0020d2 916f                      	pop r22
                                 
0020d3 9416                      	lsr r1 //shift out the fractional bits
0020d4 9407                      	ror r0
0020d5 9416                      	lsr r1
0020d6 9407                      	ror r0
0020d7 9416                      	lsr r1
0020d8 9407                      	ror r0
0020d9 9416                      	lsr r1
0020da 9407                      	ror r0
                                 
0020db 9200 294d                 	sts noise_fx_Qxy_speed, r0 //store the effect speed
0020dd 9210 294e                 	sts noise_fx_Qxy_speed+1, r1
0020df 9220 294f                 	sts noise_fx_Qxy_total_offset, zero
0020e1 9220 2950                 	sts noise_fx_Qxy_total_offset+1, zero
0020e3 cedb                      	rjmp sound_driver_channel3_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel3_fx_Rxy:
                                 sound_driver_channel3_fx_Rxy_check_arpeggio_macro:
0020e4 91e0 2915                 	lds ZL, noise_arpeggio_macro
0020e6 91f0 2916                 	lds ZH, noise_arpeggio_macro+1
0020e8 9630                      	adiw Z, 0
0020e9 f009                      	breq sound_driver_channel3_fx_Rxy_check_pitch_macro
0020ea ced4                      	rjmp sound_driver_channel3_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Rxy_check_pitch_macro:
0020eb 91e0 291d                 	lds ZL, noise_pitch_macro
0020ed 91f0 291e                 	lds ZH, noise_pitch_macro+1
0020ef 9630                      	adiw Z, 0
0020f0 f009                      	breq sound_driver_channel3_fx_Rxy_check_hi_pitch_macro
0020f1 cecd                      	rjmp sound_driver_channel3_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Rxy_check_hi_pitch_macro:
0020f2 91e0 2923                 	lds ZL, noise_hi_pitch_macro
0020f4 91f0 2924                 	lds ZH, noise_hi_pitch_macro+1
0020f6 9630                      	adiw Z, 0
0020f7 f009                      	breq sound_driver_channel3_fx_Rxy_process
0020f8 cec6                      	rjmp sound_driver_channel3_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Rxy_process:
0020f9 2fba                      	mov r27, r26 //copy fx parameters into r27
0020fa 70bf                      	andi r27, 0x0F //mask note index offset
0020fb 91c0 2817                 	lds r28, noise_note //load current note index
0020fd 1bcb                      	sub r28, r27
0020fe f408                      	brcc sound_driver_channel3_fx_Rxy_process_continue
0020ff e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel3_fx_Rxy_process_continue:
002100 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
002101 e0f0                      	ldi ZH, HIGH(note_table << 1)
002102 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
002103 0fec                      	add ZL, r28 //add offset
002104 1df2                      	adc ZH, zero
002105 91c5                      	lpm r28, Z+ //load bytes
002106 91d4                      	lpm r29, Z
002107 93c0 2951                 	sts noise_fx_Rxy_target, r28 //load the LOW bits for the target period
002109 93d0 2952                 	sts noise_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
00210b 95a2                      	swap r26
00210c 70af                      	andi r26, 0x0F //mask effect speed
00210d 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
00210e 95a3                      	inc r26 //increment the speed by 1
                                 
00210f 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002110 937f                      	push r23
002111 2f6a                      	mov r22, r26 //store the speed data into r27
002112 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002113 9f67                      	mul r22, r23
002114 917f                      	pop r23
002115 916f                      	pop r22
                                 
002116 9416                      	lsr r1 //shift out the fractional bits
002117 9407                      	ror r0
002118 9416                      	lsr r1
002119 9407                      	ror r0
00211a 9416                      	lsr r1
00211b 9407                      	ror r0
00211c 9416                      	lsr r1
00211d 9407                      	ror r0
                                 
00211e 9200 2953                 	sts noise_fx_Rxy_speed, r0 //store the effect speed
002120 9210 2954                 	sts noise_fx_Rxy_speed+1, r1
002122 9220 2955                 	sts noise_fx_Rxy_total_offset, zero
002124 9220 2956                 	sts noise_fx_Rxy_total_offset+1, zero
002126 ce98                      	rjmp sound_driver_channel3_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel3_fx_Sxx:
002127 15a2                      	cp r26, zero
002128 f051                      	breq sound_driver_channel3_fx_Sxx_invalid
002129 91b0 281e                 	lds r27, song_speed
00212b 17ab                      	cp r26, r27
00212c f430                      	brsh sound_driver_channel3_fx_Sxx_invalid
00212d 93a0 2957                 	sts noise_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
00212f e0b1                      	ldi r27, 0x01
002130 93b0 290c                 	sts noise_pattern_delay_rows, r27
002132 c15c                      	rjmp sound_driver_channel4
                                 sound_driver_channel3_fx_Sxx_invalid:
002133 ce8b                      	rjmp sound_driver_channel3_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel3_fx_Vxx:
002134 95a6                      	lsr r26
002135 95a7                      	ror r26 //move mode bit to bit 7
002136 91b0 2814                 	lds r27, noise_period
002138 77bf                      	andi r27, 0b01111111
002139 2bba                      	or r27, r26 //store the new noise mode
00213a 93b0 2813                 	sts noise_param, r27
                                 
00213c 776f                      	andi noise_sequence_HIGH, 0b01111111
00213d 2b6a                      	or noise_sequence_HIGH, r26
00213e ce80                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_Wxx: //DPCM sample speed
00213f ce7f                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Xxx: //DPCM sample retrigger
002140 ce7e                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Yxx: //DPCM sample offset
002141 ce7d                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Zxx: //DPCM sample delta counter
002142 ce7c                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 sound_driver_channel3_note:
002143 93b0 2817                 	sts noise_note, r27 //store the note index
002145 e0a3                      	ldi r26, 0x03
002146 e0b2                      	ldi r27, 0x02
002147 93b0 2912                 	sts noise_volume_macro_offset, r27 //reset all macro offsets
002149 93a0 2917                 	sts noise_arpeggio_macro_offset, r26
00214b 93b0 291f                 	sts noise_pitch_macro_offset, r27
00214d 93b0 2925                 	sts noise_hi_pitch_macro_offset, r27
00214f 93b0 292a                 	sts noise_duty_macro_offset, r27
002151 9220 291b                 	sts noise_total_pitch_offset, zero //reset the pitch and hi pitch offset
002153 9220 291c                 	sts noise_total_pitch_offset+1, zero
002155 9220 2922                 	sts noise_total_hi_pitch_offset, zero
002157 9220 2931                 	sts noise_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
002159 9220 2932                 	sts noise_fx_1xx_total+1, zero
00215b 9220 2935                 	sts noise_fx_2xx_total, zero
00215d 9220 2936                 	sts noise_fx_2xx_total+1, zero
00215f 9220 293d                 	sts noise_fx_3xx_total_offset, zero //reset 3xx offset
002161 9220 293e                 	sts noise_fx_3xx_total_offset+1, zero
002163 91a0 0abc                 	lds r26, TCB3_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
002165 91b0 0abd                 	lds r27, TCB3_CCMPH
002167 93a0 2937                 	sts noise_fx_3xx_start, r26
002169 93b0 2938                 	sts noise_fx_3xx_start+1, r27
00216b 9220 294b                 	sts noise_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00216d 9220 294c                 	sts noise_fx_Qxy_target+1, zero
00216f 9220 294f                 	sts noise_fx_Qxy_total_offset, zero
002171 9220 2950                 	sts noise_fx_Qxy_total_offset+1, zero
002173 9220 2951                 	sts noise_fx_Rxy_target, zero
002175 9220 2952                 	sts noise_fx_Rxy_target+1, zero
002177 9220 2955                 	sts noise_fx_Rxy_total_offset, zero
002179 9220 2956                 	sts noise_fx_Rxy_total_offset+1, zero
00217b d0fc                      	rcall sound_driver_channel3_increment_offset
00217c ce42                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_volume:
00217d 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
00217e 91a0 2813                 	lds r26, noise_param
002180 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
002181 2bab                      	or r26, r27 //move new VVVV bits into noise_param
002182 93a0 2813                 	sts noise_param, r26
002184 d0f3                      	rcall sound_driver_channel3_increment_offset
002185 ce39                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_delay:
002186 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
002187 93b0 290c                 	sts noise_pattern_delay_rows, r27
002189 d0ee                      	rcall sound_driver_channel3_increment_offset
00218a c104                      	rjmp sound_driver_channel4
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change:
00218b 9220 2910                 	sts noise_volume_macro, zero //reset all macro addresses
00218d 9220 2911                 	sts noise_volume_macro+1, zero
00218f 9220 2915                 	sts noise_arpeggio_macro, zero
002191 9220 2916                 	sts noise_arpeggio_macro+1, zero
002193 9220 291d                 	sts noise_pitch_macro, zero
002195 9220 291e                 	sts noise_pitch_macro+1, zero
002197 9220 2923                 	sts noise_hi_pitch_macro, zero
002199 9220 2924                 	sts noise_hi_pitch_macro+1, zero
00219b 9220 2928                 	sts noise_duty_macro, zero
00219d 9220 2929                 	sts noise_duty_macro+1, zero
00219f 9220 291b                 	sts noise_total_pitch_offset, zero //reset the pitch offset
0021a1 9220 291c                 	sts noise_total_pitch_offset+1, zero
0021a3 9220 2922                 	sts noise_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
0021a5 9631                      	adiw Z, 1 //point to the byte next to the flag
0021a6 91b4                      	lpm r27, Z //store the instrument offset into r27
0021a7 e7e1                      	ldi ZL, LOW(instruments) //point Z to instruments table
0021a8 e1f0                      	ldi ZH, HIGH(instruments)
0021a9 0feb                      	add ZL, r27 //point Z to offsetted instrument
0021aa 1df2                      	adc ZH, zero
0021ab 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
0021ac 1fff                      	rol ZH
0021ad 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
0021ae 91b4                      	lpm r27, Z
                                 
0021af 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
0021b0 1fbb                      	rol r27
0021b1 2fea                      	mov ZL, r26
0021b2 2ffb                      	mov ZH, r27
0021b3 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
0021b4 9632                      	adiw Z, 2 //point Z to the address of the macro
0021b5 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel3_instrument_change_macro_loop:
0021b6 95aa                      	dec r26
0021b7 f019                      	breq sound_driver_channel3_instrument_change_exit
0021b8 95b6                      	lsr r27
0021b9 f078                      	brcs sound_driver_channel3_instrument_change_load_macro
0021ba cffb                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_exit:
0021bb e0a3                      	ldi r26, 0x03
0021bc e0b2                      	ldi r27, 0x02
0021bd 93b0 2912                 	sts noise_volume_macro_offset, r27 //reset all macro offsets
0021bf 93a0 2917                 	sts noise_arpeggio_macro_offset, r26
0021c1 93b0 291f                 	sts noise_pitch_macro_offset, r27
0021c3 93b0 2925                 	sts noise_hi_pitch_macro_offset, r27
0021c5 93b0 292a                 	sts noise_duty_macro_offset, r27
0021c7 d0ba                      	rcall sound_driver_channel3_increment_offset_twice
0021c8 cdf6                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_load_macro:
0021c9 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
0021ca 91d5                      	lpm r29, Z+
                                 
0021cb 30a5                      	cpi r26, 5
0021cc f039                      	breq sound_driver_channel3_instrument_change_load_macro_volume
0021cd 30a4                      	cpi r26, 4
0021ce f079                      	breq sound_driver_channel3_instrument_change_load_macro_arpeggio
0021cf 30a3                      	cpi r26, 3
0021d0 f0d9                      	breq sound_driver_channel3_instrument_change_load_macro_pitch
0021d1 30a2                      	cpi r26, 2
0021d2 f159                      	breq sound_driver_channel3_instrument_change_load_macro_hi_pitch
0021d3 c03c                      	rjmp sound_driver_channel3_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel3_instrument_change_load_macro_volume:
0021d4 93c0 2910                 	sts noise_volume_macro, r28
0021d6 93d0 2911                 	sts noise_volume_macro+1, r29
0021d8 d041                      	rcall sound_driver_channel3_instrument_change_read_header
0021d9 93c0 2914                 	sts noise_volume_macro_release, r28
0021db 93d0 2913                 	sts noise_volume_macro_loop, r29
0021dd cfd8                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 	
                                 sound_driver_channel3_instrument_change_load_macro_arpeggio:
0021de 93c0 2915                 	sts noise_arpeggio_macro, r28
0021e0 93d0 2916                 	sts noise_arpeggio_macro+1, r29
0021e2 9220 294b                 	sts noise_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0021e4 9220 294c                 	sts noise_fx_Qxy_target+1, zero
0021e6 9220 2951                 	sts noise_fx_Rxy_target, zero
0021e8 9220 2952                 	sts noise_fx_Rxy_target+1, zero
0021ea d03a                      	rcall sound_driver_channel3_instrument_change_read_header_arpeggio
0021eb cfca                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_pitch:
0021ec 93c0 291d                 	sts noise_pitch_macro, r28
0021ee 93d0 291e                 	sts noise_pitch_macro+1, r29
0021f0 9220 294b                 	sts noise_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0021f2 9220 294c                 	sts noise_fx_Qxy_target+1, zero
0021f4 9220 2951                 	sts noise_fx_Rxy_target, zero
0021f6 9220 2952                 	sts noise_fx_Rxy_target+1, zero
0021f8 d021                      	rcall sound_driver_channel3_instrument_change_read_header
0021f9 93c0 2921                 	sts noise_pitch_macro_release, r28
0021fb 93d0 2920                 	sts noise_pitch_macro_loop, r29
0021fd cfb8                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_hi_pitch:
0021fe 93c0 2923                 	sts noise_hi_pitch_macro, r28
002200 93d0 2924                 	sts noise_hi_pitch_macro+1, r29
002202 9220 294b                 	sts noise_fx_Qxy_target, zero //reset the Qxy, Rxy effects
002204 9220 294c                 	sts noise_fx_Qxy_target+1, zero
002206 9220 2951                 	sts noise_fx_Rxy_target, zero
002208 9220 2952                 	sts noise_fx_Rxy_target+1, zero
00220a d00f                      	rcall sound_driver_channel3_instrument_change_read_header
00220b 93c0 2927                 	sts noise_hi_pitch_macro_release, r28
00220d 93d0 2926                 	sts noise_hi_pitch_macro_loop, r29
00220f cfa6                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_duty:
002210 93c0 2928                 	sts noise_duty_macro, r28
002212 93d0 2929                 	sts noise_duty_macro+1, r29
002214 d005                      	rcall sound_driver_channel3_instrument_change_read_header
002215 93c0 292c                 	sts noise_duty_macro_release, r28
002217 93d0 292b                 	sts noise_duty_macro_loop, r29
002219 cf9c                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_read_header:
00221a 93ef                      	push ZL
00221b 93ff                      	push ZH
00221c 2fec                      	mov ZL, r28
00221d 2ffd                      	mov ZH, r29
00221e 0fee                      	lsl ZL
00221f 1fff                      	rol ZH
002220 91c5                      	lpm r28, Z+
002221 91d4                      	lpm r29, Z
002222 91ff                      	pop ZH
002223 91ef                      	pop ZL
002224 9508                      	ret
                                 
                                 sound_driver_channel3_instrument_change_read_header_arpeggio:
002225 93ef                      	push ZL
002226 93ff                      	push ZH
002227 2fec                      	mov ZL, r28
002228 2ffd                      	mov ZH, r29
002229 0fee                      	lsl ZL
00222a 1fff                      	rol ZH
00222b 91c5                      	lpm r28, Z+
00222c 91d5                      	lpm r29, Z+
00222d 93c0 2919                 	sts noise_arpeggio_macro_release, r28
00222f 93d0 2918                 	sts noise_arpeggio_macro_loop, r29
002231 91c4                      	lpm r28, Z
002232 93c0 291a                 	sts noise_arpeggio_macro_mode, r28
002234 91ff                      	pop ZH
002235 91ef                      	pop ZL
002236 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel3_release:
                                 sound_driver_channel3_release_volume:
002237 91b0 2914                 	lds r27, noise_volume_macro_release
002239 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
00223a f019                      	breq sound_driver_channel3_release_arpeggio //if the macro has no release flag, check the next macro
00223b 95b3                      	inc r27
00223c 93b0 2912                 	sts noise_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel3_release_arpeggio:
00223e 91b0 2919                 	lds r27, noise_arpeggio_macro_release
002240 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
002241 f019                      	breq sound_driver_channel3_release_pitch
002242 95b3                      	inc r27
002243 93b0 2917                 	sts noise_arpeggio_macro_offset, r27
                                 sound_driver_channel3_release_pitch:
002245 91b0 2921                 	lds r27, noise_pitch_macro_release
002247 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
002248 f019                      	breq sound_driver_channel3_release_hi_pitch
002249 95b3                      	inc r27
00224a 93b0 291f                 	sts noise_pitch_macro_offset, r27
                                 sound_driver_channel3_release_hi_pitch:
00224c 91b0 2927                 	lds r27, noise_hi_pitch_macro_release
00224e 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
00224f f019                      	breq sound_driver_channel3_release_duty
002250 95b3                      	inc r27
002251 93b0 2925                 	sts noise_hi_pitch_macro_offset, r27
                                 sound_driver_channel3_release_duty:
002253 91b0 292c                 	lds r27, noise_duty_macro_release
002255 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
002256 f019                      	breq sound_driver_channel3_release_exit
002257 95b3                      	inc r27
002258 93b0 292a                 	sts noise_duty_macro_offset, r27
                                 sound_driver_channel3_release_exit:
00225a d01d                      	rcall sound_driver_channel3_increment_offset
00225b cd63                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_next_pattern:
00225c 91e0 2818                 	lds ZL, song_frames
00225e 91f0 2819                 	lds ZH, song_frames+1
002260 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
002262 91b0 281b                 	lds r27, song_frame_offset+1
002264 93a0 281a                 	sts song_frame_offset, r26
002266 93b0 281b                 	sts song_frame_offset+1, r27
002268 9616                      	adiw r27:r26, 6 //offset for channel 3
002269 0fea                      	add ZL, r26
00226a 1ffb                      	adc ZH, r27
                                 
00226b 91a5                      	lpm r26, Z+ //load the address of the next pattern
00226c 91b4                      	lpm r27, Z
00226d 0faa                      	lsl r26
00226e 1fbb                      	rol r27
00226f 93a0 290a                 	sts noise_pattern, r26
002271 93b0 290b                 	sts noise_pattern+1, r27
                                 
002273 9220 290e                 	sts noise_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
002275 9220 290f                 	sts noise_pattern_offset+1, zero
002277 cd47                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_increment_offset:
002278 91e0 290e                 	lds ZL, noise_pattern_offset //current offset in the pattern for noise
00227a 91f0 290f                 	lds ZH, noise_pattern_offset+1
00227c 9631                      	adiw Z, 1
00227d 93e0 290e                 	sts noise_pattern_offset, ZL
00227f 93f0 290f                 	sts noise_pattern_offset+1, ZH
002281 9508                      	ret
                                 
                                 sound_driver_channel3_increment_offset_twice: //used for data that takes up 2 bytes worth of space
002282 91e0 290e                 	lds ZL, noise_pattern_offset //current offset in the pattern for noise
002284 91f0 290f                 	lds ZH, noise_pattern_offset+1
002286 9632                      	adiw Z, 2 //increment the pointer twice
002287 93e0 290e                 	sts noise_pattern_offset, ZL
002289 93f0 290f                 	sts noise_pattern_offset+1, ZH
00228b 9508                      	ret
                                 
                                 sound_driver_channel3_decrement_frame_delay:
00228c 95ba                      	dec r27
00228d 93b0 290d                 	sts noise_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel4:
                                 
                                 sound_driver_calculate_delays:
00228f 91f0 281e                 	lds r31, song_speed
002291 2fef                      	mov r30, r31
002292 50e1                      	subi r30, 1
                                 sound_driver_calculate_delays_pulse1:
002293 91a0 2825                 	lds r26, pulse1_pattern_delay_frames
002295 11a2                      	cpse r26, zero
002296 c042                      	rjmp sound_driver_calculate_delays_pulse2
002297 c000                      	rjmp sound_driver_calculate_delays_pulse1_main
                                 
                                 sound_driver_calculate_delays_pulse1_main:
002298 2faf                      	mov r26, r31 //move the speed to r26
002299 91b0 2824                 	lds r27, pulse1_pattern_delay_rows //decrement the delay rows
00229b 15b2                      	cp r27, zero
00229c f409                      	brne PC+2
00229d c03b                      	rjmp sound_driver_calculate_delays_pulse2
00229e 95ba                      	dec r27
00229f 93b0 2824                 	sts pulse1_pattern_delay_rows, r27
0022a1 11b2                      	cpse r27, zero
0022a2 c034                      	rjmp sound_driver_calculate_delays_pulse1_store
0022a3 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx:
0022a4 efbf                      	ldi r27, 0xFF
0022a5 91c0 286f                 	lds r28, pulse1_fx_Sxx_pre
0022a7 91d0 2870                 	lds r29, pulse1_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse1_Sxx_check_pre:
0022a9 17cb                      	cp r28, r27
0022aa f009                      	breq sound_driver_calculate_delays_pulse1_Sxx_check_post
0022ab c00d                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_pre
                                 sound_driver_calculate_delays_pulse1_Sxx_check_post:
0022ac 17db                      	cp r29, r27
0022ad f009                      	breq sound_driver_calculate_delays_pulse1_Gxx
0022ae c015                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx:
0022af 91c0 285f                 	lds r28, pulse1_fx_Gxx_pre
0022b1 91d0 2860                 	lds r29, pulse1_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse1_Gxx_check_pre:
0022b3 17cb                      	cp r28, r27
0022b4 f009                      	breq sound_driver_calculate_delays_pulse1_Gxx_check_post
0022b5 c012                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_pre
                                 sound_driver_calculate_delays_pulse1_Gxx_check_post:
0022b6 17db                      	cp r29, r27
0022b7 f0f9                      	breq sound_driver_calculate_delays_pulse1_store
0022b8 c01a                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_pre:
0022b9 93b0 286f                 	sts pulse1_fx_Sxx_pre, r27
0022bb 1bec                      	sub r30, r28 //(song speed)-1-Sxx
0022bc 93e0 2870                 	sts pulse1_fx_Sxx_post, r30
0022be 95ca                      	dec r28
0022bf 93c0 2825                 	sts pulse1_pattern_delay_frames, r28
0022c1 2fef                      	mov r30, r31
0022c2 50e1                      	subi r30, 1
0022c3 c015                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_post:
0022c4 93b0 2870                 	sts pulse1_fx_Sxx_post, r27
0022c6 2fad                      	mov r26, r29
0022c7 c00f                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx_pre:
0022c8 93b0 285f                 	sts pulse1_fx_Gxx_pre, r27
0022ca 1bec                      	sub r30, r28 //(song speed)-1-Sxx
0022cb 93e0 2860                 	sts pulse1_fx_Gxx_post, r30
0022cd 95ca                      	dec r28
0022ce 93c0 2825                 	sts pulse1_pattern_delay_frames, r28
0022d0 2fef                      	mov r30, r31
0022d1 50e1                      	subi r30, 1
0022d2 c006                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse1_Gxx_post:
0022d3 93b0 2860                 	sts pulse1_fx_Gxx_post, r27
0022d5 2fad                      	mov r26, r29
0022d6 c000                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_store:
0022d7 93a0 2825                 	sts pulse1_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_pulse2:
0022d9 91a0 2874                 	lds r26, pulse2_pattern_delay_frames
0022db 11a2                      	cpse r26, zero
0022dc c042                      	rjmp sound_driver_calculate_delays_triangle
0022dd c000                      	rjmp sound_driver_calculate_delays_pulse2_main
                                 
                                 sound_driver_calculate_delays_pulse2_main:
0022de 2faf                      	mov r26, r31 //move the speed to r26
0022df 91b0 2873                 	lds r27, pulse2_pattern_delay_rows //decrement the delay rows
0022e1 15b2                      	cp r27, zero
0022e2 f409                      	brne PC+2
0022e3 c03b                      	rjmp sound_driver_calculate_delays_triangle
0022e4 95ba                      	dec r27
0022e5 93b0 2873                 	sts pulse2_pattern_delay_rows, r27
0022e7 11b2                      	cpse r27, zero
0022e8 c034                      	rjmp sound_driver_calculate_delays_pulse2_store
0022e9 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx:
0022ea efbf                      	ldi r27, 0xFF
0022eb 91c0 28be                 	lds r28, pulse2_fx_Sxx_pre
0022ed 91d0 28bf                 	lds r29, pulse2_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse2_Sxx_check_pre:
0022ef 17cb                      	cp r28, r27
0022f0 f009                      	breq sound_driver_calculate_delays_pulse2_Sxx_check_post
0022f1 c00d                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_pre
                                 sound_driver_calculate_delays_pulse2_Sxx_check_post:
0022f2 17db                      	cp r29, r27
0022f3 f009                      	breq sound_driver_calculate_delays_pulse2_Gxx
0022f4 c015                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx:
0022f5 91c0 28ae                 	lds r28, pulse2_fx_Gxx_pre
0022f7 91d0 28af                 	lds r29, pulse2_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse2_Gxx_check_pre:
0022f9 17cb                      	cp r28, r27
0022fa f009                      	breq sound_driver_calculate_delays_pulse2_Gxx_check_post
0022fb c012                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_pre
                                 sound_driver_calculate_delays_pulse2_Gxx_check_post:
0022fc 17db                      	cp r29, r27
0022fd f0f9                      	breq sound_driver_calculate_delays_pulse2_store
0022fe c01a                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_pre:
0022ff 93b0 28be                 	sts pulse2_fx_Sxx_pre, r27
002301 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002302 93e0 28bf                 	sts pulse2_fx_Sxx_post, r30
002304 95ca                      	dec r28
002305 93c0 2874                 	sts pulse2_pattern_delay_frames, r28
002307 2fef                      	mov r30, r31
002308 50e1                      	subi r30, 1
002309 cfcf                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_post:
00230a 93b0 28bf                 	sts pulse2_fx_Sxx_post, r27
00230c 2fad                      	mov r26, r29
00230d c00f                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx_pre:
00230e 93b0 28ae                 	sts pulse2_fx_Gxx_pre, r27
002310 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002311 93e0 28af                 	sts pulse2_fx_Gxx_post, r30
002313 95ca                      	dec r28
002314 93c0 2874                 	sts pulse2_pattern_delay_frames, r28
002316 2fef                      	mov r30, r31
002317 50e1                      	subi r30, 1
002318 cfc0                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse2_Gxx_post:
002319 93b0 28af                 	sts pulse2_fx_Gxx_post, r27
00231b 2fad                      	mov r26, r29
00231c c000                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_store:
00231d 93a0 2874                 	sts pulse2_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_triangle:
00231f 91a0 28c3                 	lds r26, triangle_pattern_delay_frames
002321 11a2                      	cpse r26, zero
002322 c042                      	rjmp sound_driver_calculate_delays_noise
002323 c000                      	rjmp sound_driver_calculate_delays_triangle_main
                                 
                                 sound_driver_calculate_delays_triangle_main:
002324 2faf                      	mov r26, r31 //move the speed to r26
002325 91b0 28c2                 	lds r27, triangle_pattern_delay_rows //decrement the delay rows
002327 15b2                      	cp r27, zero
002328 f409                      	brne PC+2
002329 c03b                      	rjmp sound_driver_calculate_delays_noise
00232a 95ba                      	dec r27
00232b 93b0 28c2                 	sts triangle_pattern_delay_rows, r27
00232d 11b2                      	cpse r27, zero
00232e c034                      	rjmp sound_driver_calculate_delays_triangle_store
00232f 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_triangle_Sxx:
002330 efbf                      	ldi r27, 0xFF
002331 91c0 2908                 	lds r28, triangle_fx_Sxx_pre
002333 91d0 2909                 	lds r29, triangle_fx_Sxx_post
                                 sound_driver_calculate_delays_triangle_Sxx_check_pre:
002335 17cb                      	cp r28, r27
002336 f009                      	breq sound_driver_calculate_delays_triangle_Sxx_check_post
002337 c00d                      	rjmp sound_driver_calculate_delays_triangle_Sxx_pre
                                 sound_driver_calculate_delays_triangle_Sxx_check_post:
002338 17db                      	cp r29, r27
002339 f009                      	breq sound_driver_calculate_delays_triangle_Gxx
00233a c015                      	rjmp sound_driver_calculate_delays_triangle_Sxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Gxx:
00233b 91c0 28f8                 	lds r28, triangle_fx_Gxx_pre
00233d 91d0 28f9                 	lds r29, triangle_fx_Gxx_post
                                 sound_driver_calculate_delays_triangle_Gxx_check_pre:
00233f 17cb                      	cp r28, r27
002340 f009                      	breq sound_driver_calculate_delays_triangle_Gxx_check_post
002341 c012                      	rjmp sound_driver_calculate_delays_triangle_Gxx_pre
                                 sound_driver_calculate_delays_triangle_Gxx_check_post:
002342 17db                      	cp r29, r27
002343 f0f9                      	breq sound_driver_calculate_delays_triangle_store
002344 c01a                      	rjmp sound_driver_calculate_delays_triangle_Gxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_pre:
002345 93b0 2908                 	sts triangle_fx_Sxx_pre, r27
002347 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002348 93e0 2909                 	sts triangle_fx_Sxx_post, r30
00234a 95ca                      	dec r28
00234b 93c0 28c3                 	sts triangle_pattern_delay_frames, r28
00234d 2fef                      	mov r30, r31
00234e 50e1                      	subi r30, 1
00234f c015                      	rjmp sound_driver_calculate_delays_noise
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_post:
002350 93b0 2909                 	sts triangle_fx_Sxx_post, r27
002352 2fad                      	mov r26, r29
002353 c00f                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_Gxx_pre:
002354 93b0 28f8                 	sts triangle_fx_Gxx_pre, r27
002356 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002357 93e0 28f9                 	sts triangle_fx_Gxx_post, r30
002359 95ca                      	dec r28
00235a 93c0 28c3                 	sts triangle_pattern_delay_frames, r28
00235c 2fef                      	mov r30, r31
00235d 50e1                      	subi r30, 1
00235e c006                      	rjmp sound_driver_calculate_delays_noise
                                 	
                                 sound_driver_calculate_delays_triangle_Gxx_post:
00235f 93b0 28f9                 	sts triangle_fx_Gxx_post, r27
002361 2fad                      	mov r26, r29
002362 c000                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_store:
002363 93a0 28c3                 	sts triangle_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_noise:
002365 91a0 290d                 	lds r26, noise_pattern_delay_frames
002367 11a2                      	cpse r26, zero
002368 c042                      	rjmp sound_driver_calculate_delays_dpcm
002369 c000                      	rjmp sound_driver_calculate_delays_noise_main
                                 
                                 sound_driver_calculate_delays_noise_main:
00236a 2faf                      	mov r26, r31 //move the speed to r26
00236b 91b0 290c                 	lds r27, noise_pattern_delay_rows //decrement the delay rows
00236d 15b2                      	cp r27, zero
00236e f409                      	brne PC+2
00236f c03b                      	rjmp sound_driver_calculate_delays_dpcm
002370 95ba                      	dec r27
002371 93b0 290c                 	sts noise_pattern_delay_rows, r27
002373 11b2                      	cpse r27, zero
002374 c034                      	rjmp sound_driver_calculate_delays_noise_store
002375 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_noise_Sxx:
002376 efbf                      	ldi r27, 0xFF
002377 91c0 2957                 	lds r28, noise_fx_Sxx_pre
002379 91d0 2958                 	lds r29, noise_fx_Sxx_post
                                 sound_driver_calculate_delays_noise_Sxx_check_pre:
00237b 17cb                      	cp r28, r27
00237c f009                      	breq sound_driver_calculate_delays_noise_Sxx_check_post
00237d c00d                      	rjmp sound_driver_calculate_delays_noise_Sxx_pre
                                 sound_driver_calculate_delays_noise_Sxx_check_post:
00237e 17db                      	cp r29, r27
00237f f009                      	breq sound_driver_calculate_delays_noise_Gxx
002380 c015                      	rjmp sound_driver_calculate_delays_noise_Sxx_post
                                 
                                 sound_driver_calculate_delays_noise_Gxx:
002381 91c0 2947                 	lds r28, noise_fx_Gxx_pre
002383 91d0 2948                 	lds r29, noise_fx_Gxx_post
                                 sound_driver_calculate_delays_noise_Gxx_check_pre:
002385 17cb                      	cp r28, r27
002386 f009                      	breq sound_driver_calculate_delays_noise_Gxx_check_post
002387 c012                      	rjmp sound_driver_calculate_delays_noise_Gxx_pre
                                 sound_driver_calculate_delays_noise_Gxx_check_post:
002388 17db                      	cp r29, r27
002389 f0f9                      	breq sound_driver_calculate_delays_noise_store
00238a c01a                      	rjmp sound_driver_calculate_delays_noise_Gxx_post
                                 
                                 sound_driver_calculate_delays_noise_Sxx_pre:
00238b 93b0 2957                 	sts noise_fx_Sxx_pre, r27
00238d 1bec                      	sub r30, r28 //(song speed)-1-Sxx
00238e 93e0 2958                 	sts noise_fx_Sxx_post, r30
002390 95ca                      	dec r28
002391 93c0 290d                 	sts noise_pattern_delay_frames, r28
002393 2fef                      	mov r30, r31
002394 50e1                      	subi r30, 1
002395 c015                      	rjmp sound_driver_calculate_delays_dpcm
                                 
                                 sound_driver_calculate_delays_noise_Sxx_post:
002396 93b0 2958                 	sts noise_fx_Sxx_post, r27
002398 2fad                      	mov r26, r29
002399 c00f                      	rjmp sound_driver_calculate_delays_noise_store
                                 
                                 sound_driver_calculate_delays_noise_Gxx_pre:
00239a 93b0 2947                 	sts noise_fx_Gxx_pre, r27
00239c 1bec                      	sub r30, r28 //(song speed)-1-Sxx
00239d 93e0 2948                 	sts noise_fx_Gxx_post, r30
00239f 95ca                      	dec r28
0023a0 93c0 290d                 	sts noise_pattern_delay_frames, r28
0023a2 2fef                      	mov r30, r31
0023a3 50e1                      	subi r30, 1
0023a4 c006                      	rjmp sound_driver_calculate_delays_dpcm
                                 	
                                 sound_driver_calculate_delays_noise_Gxx_post:
0023a5 93b0 2948                 	sts noise_fx_Gxx_post, r27
0023a7 2fad                      	mov r26, r29
0023a8 c000                      	rjmp sound_driver_calculate_delays_noise_store
                                 
                                 sound_driver_calculate_delays_noise_store:
0023a9 93a0 290d                 	sts noise_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_dpcm:
                                 
                                 sound_driver_instrument_fx_routine:
                                 sound_driver_instrument_routine_channel0_volume:
0023ab 91e0 2828                 	lds ZL, pulse1_volume_macro
0023ad 91f0 2829                 	lds ZH, pulse1_volume_macro+1
0023af 9630                      	adiw Z, 0
0023b0 f1a1                      	breq sound_driver_instrument_routine_channel0_volume_default //if no volume macro is in use, use default multiplier of F
0023b1 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0023b2 1fff                      	rol ZH
0023b3 91a0 282a                 	lds r26, pulse1_volume_macro_offset
0023b5 0fea                      	add ZL, r26
0023b6 1df2                      	adc ZH, zero
                                 
0023b7 91b0 282c                 	lds r27, pulse1_volume_macro_release
0023b9 17ba                      	cp r27, r26
0023ba f429                      	brne sound_driver_instrument_routine_channel0_volume_increment //if the current offset is not equal to the release index, increment the offset
0023bb 91a0 282b                 	lds r26, pulse1_volume_macro_loop
0023bd 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0023be f010                      	brlo sound_driver_instrument_routine_channel0_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0023bf c003                      	rjmp sound_driver_instrument_routine_channel0_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_volume_increment:
0023c0 95a3                      	inc r26 //increment the macro offset
0023c1 93a0 282a                 	sts pulse1_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_volume_read:
0023c3 91b4                      	lpm r27, Z //load volume data into r27
0023c4 3fbf                      	cpi r27, 0xFF //check for macro end flag
0023c5 f469                      	brne sound_driver_instrument_routine_channel0_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_release:
0023c6 91b0 282c                 	lds r27, pulse1_volume_macro_release
0023c8 3fbf                      	cpi r27, 0xFF
0023c9 f429                      	brne sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_loop:
0023ca 91b0 282b                 	lds r27, pulse1_volume_macro_loop //load the loop index
0023cc 93b0 282a                 	sts pulse1_volume_macro_offset, r27 //store the loop index into the offset
0023ce cfdc                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index:
0023cf 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
0023d0 93a0 282a                 	sts pulse1_volume_macro_offset, r26
0023d2 cfd8                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_calculate:
0023d3 ebe4                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
0023d4 e6f1                      	ldi ZH, HIGH(volumes << 1)
0023d5 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
0023d6 0feb                      	add ZL, r27 //add offset to the table
0023d7 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel0_volume_load:
0023d8 91b0 2800                 	lds r27, pulse1_param //load main volume
0023da 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
0023db 91a0 285d                 	lds r26, pulse1_fx_7xy_value
0023dd 30a0                      	cpi r26, 0x00
0023de f481                      	brne sound_driver_instrument_routine_channel0_volume_load_7xy
                                 
0023df 0feb                      	add ZL, r27 //offset the volume table by the main volume
0023e0 1df2                      	adc ZH, zero
0023e1 91b4                      	lpm r27, Z
0023e2 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
0023e4 c024                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default:
0023e5 91b0 2800                 	lds r27, pulse1_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
0023e7 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
0023e8 91a0 285d                 	lds r26, pulse1_fx_7xy_value
0023ea 30a0                      	cpi r26, 0x00
0023eb f4a1                      	brne sound_driver_instrument_routine_channel0_volume_default_7xy
0023ec 93b0 2806                 	sts pulse1_output_volume, r27
0023ee c01a                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy:
0023ef 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
0023f0 f040                      	brcs sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
0023f1 f039                      	breq sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
0023f2 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
                                 
0023f3 0feb                      	add ZL, r27 //offset the volume table by the main volume
0023f4 1df2                      	adc ZH, zero
0023f5 91b4                      	lpm r27, Z
0023f6 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
0023f8 c010                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy_overflow:
0023f9 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
0023fa 0feb                      	add ZL, r27 //offset the volume table by the main volume
0023fb 1df2                      	adc ZH, zero
0023fc 91b4                      	lpm r27, Z
0023fd 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
0023ff c009                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default_7xy:
002400 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002401 f020                      	brcs sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
002402 f019                      	breq sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
002403 93b0 2806                 	sts pulse1_output_volume, r27
002405 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel0_volume_default_7xy_overflow:
002406 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002407 93b0 2806                 	sts pulse1_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002409 91e0 282d                 	lds ZL, pulse1_arpeggio_macro
00240b 91f0 282e                 	lds ZH, pulse1_arpeggio_macro+1
00240d 9630                      	adiw Z, 0
00240e f1d9                      	breq sound_driver_instrument_routine_channel0_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
00240f 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002410 1fff                      	rol ZH
002411 91a0 282f                 	lds r26, pulse1_arpeggio_macro_offset
002413 0fea                      	add ZL, r26
002414 1df2                      	adc ZH, zero
                                 
002415 91b0 2831                 	lds r27, pulse1_arpeggio_macro_release
002417 17ba                      	cp r27, r26
002418 f429                      	brne sound_driver_instrument_routine_channel0_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002419 91a0 2830                 	lds r26, pulse1_arpeggio_macro_loop
00241b 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00241c f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
00241d c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_increment:
00241e 95a3                      	inc r26 //increment the macro offset
00241f 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_read:
002421 91b4                      	lpm r27, Z //load arpeggio data into r27
002422 38b0                      	cpi r27, 0x80 //check for macro end flag
002423 f009                      	breq sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag
002424 c041                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_check_mode:
002425 50a1                      	subi r26, 1 //keep the offset at the end flag
002426 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26
002428 91b0 2832                 	lds r27, pulse1_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
00242a 30b1                      	cpi r27, 0x01
00242b f048                      	brlo sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_release:
00242c 91b0 2831                 	lds r27, pulse1_arpeggio_macro_release
00242e 3fbf                      	cpi r27, 0xFF
00242f f4d1                      	brne sound_driver_instrument_routine_channel0_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_loop:
002430 91b0 2830                 	lds r27, pulse1_arpeggio_macro_loop
002432 3fbf                      	cpi r27, 0xFF
002433 f499                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002434 c015                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute:
002435 91b0 2831                 	lds r27, pulse1_arpeggio_macro_release
002437 3fbf                      	cpi r27, 0xFF
002438 f421                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_check_loop:
002439 91b0 2830                 	lds r27, pulse1_arpeggio_macro_loop //load the loop index
00243b 3fbf                      	cpi r27, 0xFF //check if loop flag exists
00243c f451                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop:
00243d 91c0 2845                 	lds r28, pulse1_fx_0xy_sequence //check for 0xy effect
00243f 91d0 2846                 	lds r29, pulse1_fx_0xy_sequence+1
002441 9620                      	adiw r29:r28, 0
002442 f469                      	brne sound_driver_instrument_routine_channel0_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002443 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002444 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26 //store the last valid index into the offset
002446 cfc2                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload:
002447 93b0 282f                 	sts pulse1_arpeggio_macro_offset, r27 //store the loop index into the offset
002449 cfbf                      	rjmp sound_driver_instrument_routine_channel0_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_default:
00244a 91c0 2845                 	lds r28, pulse1_fx_0xy_sequence //load 0xy effect
00244c 91d0 2846                 	lds r29, pulse1_fx_0xy_sequence+1
00244e 9620                      	adiw r29:r28, 0 //check for 0xy effect
00244f f099                      	breq sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel0_arpeggio_default_xy:
002450 95d6                      	lsr r29
002451 95c7                      	ror r28
002452 95d7                      	ror r29
002453 95c7                      	ror r28
002454 95d7                      	ror r29
002455 95c7                      	ror r28
002456 95d7                      	ror r29
002457 95c7                      	ror r28
002458 95d7                      	ror r29
002459 95d2                      	swap r29
                                 
00245a 93c0 2845                 	sts pulse1_fx_0xy_sequence, r28 //store the rolled sequence
00245c 93d0 2846                 	sts pulse1_fx_0xy_sequence+1, r29
00245e 70cf                      	andi r28, 0x0F //mask out the 4 LSB
00245f 91a0 2807                 	lds r26, pulse1_note //load the current note index
002461 0fac                      	add r26, r28 //add the note offset
002462 c02e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002463 91a0 2807                 	lds r26, pulse1_note //load the current note index
002465 c02b                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process:
002466 9220 2833                 	sts pulse1_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002468 9220 2834                 	sts pulse1_total_pitch_offset+1, zero
00246a 9220 283a                 	sts pulse1_total_hi_pitch_offset, zero
00246c 91a0 2832                 	lds r26, pulse1_arpeggio_macro_mode
00246e 30a1                      	cpi r26, 0x01 //absolute mode
00246f f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_absolute
002470 f069                      	breq sound_driver_instrument_routine_channel0_arpeggio_process_fixed
002471 c00e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute:
002472 91a0 2807                 	lds r26, pulse1_note //load the current note index
002474 0fab                      	add r26, r27 //offset the note with the arpeggio data
002475 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002476 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_add:
002477 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002478 f0c0                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
002479 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
00247a c016                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract:
00247b fda7                      	sbrc r26, 7 //check if result is negative
00247c e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
00247d c013                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_fixed:
00247e 2fab                      	mov r26, r27 //move the arpeggio data into r26
00247f c011                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative:
002480 91a0 2807                 	lds r26, pulse1_note //load the current note index
002482 0fab                      	add r26, r27 //offset the note with the arpeggio data
002483 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002484 c008                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_add:
002485 93a0 2807                 	sts pulse1_note, r26 //NOTE: relative mode modifies the original note index
002487 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002488 f040                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
002489 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
00248a 93a0 2807                 	sts pulse1_note, r26
00248c c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract:
00248d fda7                      	sbrc r26, 7 //check if result is negative
00248e e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
00248f 93a0 2807                 	sts pulse1_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_load:
002491 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
002492 e0f0                      	ldi ZH, HIGH(note_table << 1)
002493 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002494 0fea                      	add ZL, r26 //add offset
002495 1df2                      	adc ZH, zero
002496 91a5                      	lpm r26, Z+ //load bytes
002497 91b4                      	lpm r27, Z
002498 93a0 0a8c                 	sts TCB0_CCMPL, r26 //load the LOW bits for timer
00249a 93b0 0a8d                 	sts TCB0_CCMPH, r27 //load the HIGH bits for timer
00249c 93a0 2851                 	sts pulse1_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
00249e 93b0 2852                 	sts pulse1_fx_3xx_target+1, r27
0024a0 c000                      	rjmp sound_driver_instrument_routine_channel0_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch:
0024a1 91e0 2835                 	lds ZL, pulse1_pitch_macro
0024a3 91f0 2836                 	lds ZH, pulse1_pitch_macro+1
0024a5 9630                      	adiw Z, 0
0024a6 f409                      	brne sound_driver_instrument_routine_channel0_pitch_continue
0024a7 c023                      	rjmp sound_driver_instrument_routine_channel0_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel0_pitch_continue:
0024a8 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0024a9 1fff                      	rol ZH
0024aa 91a0 2837                 	lds r26, pulse1_pitch_macro_offset
0024ac 0fea                      	add ZL, r26
0024ad 1df2                      	adc ZH, zero
                                 
0024ae 91b0 2839                 	lds r27, pulse1_pitch_macro_release
0024b0 17ba                      	cp r27, r26
0024b1 f429                      	brne sound_driver_instrument_routine_channel0_pitch_increment //if the current offset is not equal to the release index, increment the offset
0024b2 91a0 2838                 	lds r26, pulse1_pitch_macro_loop
0024b4 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0024b5 f010                      	brlo sound_driver_instrument_routine_channel0_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0024b6 c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_pitch_increment:
0024b7 95a3                      	inc r26 //increment the macro offset
0024b8 93a0 2837                 	sts pulse1_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_pitch_read:
0024ba 91b4                      	lpm r27, Z //load pitch data into r27
0024bb 38b0                      	cpi r27, 0x80 //check for macro end flag
0024bc f479                      	brne sound_driver_instrument_routine_channel0_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_release:
0024bd 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0024be 93a0 2837                 	sts pulse1_pitch_macro_offset, r26
0024c0 91b0 2839                 	lds r27, pulse1_pitch_macro_release
0024c2 3fbf                      	cpi r27, 0xFF
0024c3 f439                      	brne sound_driver_instrument_routine_channel0_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_loop:
0024c4 91b0 2838                 	lds r27, pulse1_pitch_macro_loop //load the loop index
0024c6 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0024c7 f019                      	breq sound_driver_instrument_routine_channel0_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
0024c8 93b0 2837                 	sts pulse1_pitch_macro_offset, r27 //store the loop index into the offset
0024ca cfd6                      	rjmp sound_driver_instrument_routine_channel0_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_default:
0024cb e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel0_pitch_calculate:
0024cc 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0024cd 937f                      	push r23
0024ce 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
0024cf eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0024d0 0367                      	mulsu r22, r23
0024d1 917f                      	pop r23
0024d2 916f                      	pop r22
                                 
0024d3 9416                      	lsr r1 //shift out the fractional bits
0024d4 9407                      	ror r0
0024d5 9416                      	lsr r1
0024d6 9407                      	ror r0
0024d7 9416                      	lsr r1
0024d8 9407                      	ror r0
0024d9 9416                      	lsr r1
0024da 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_check_negative:
0024db fe13                      	sbrs r1, 3 //check if result was a negative number
0024dc c007                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_negative:
0024dd efc0                      	ldi r28, 0xF0
0024de 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_check_divisible_8:
0024df 70b7                      	andi r27, 0b00000111
0024e0 f019                      	breq sound_driver_instrument_routine_channel0_pitch_calculate_offset
                                 
0024e1 e0b1                      	ldi r27, 0x01
0024e2 0e0b                      	add r0, r27
0024e3 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_offset:
0024e4 91a0 2833                 	lds r26, pulse1_total_pitch_offset
0024e6 91b0 2834                 	lds r27, pulse1_total_pitch_offset+1
0024e8 0e0a                      	add r0, r26
0024e9 1e1b                      	adc r1, r27
0024ea 9200 2833                 	sts pulse1_total_pitch_offset, r0
0024ec 9210 2834                 	sts pulse1_total_pitch_offset+1, r1
0024ee 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
0024f0 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
0024f2 0da0                      	add r26, r0 //offset the timer values
0024f3 1db1                      	adc r27, r1
                                 	
0024f4 91c0 2849                 	lds r28, pulse1_fx_1xx_total
0024f6 91d0 284a                 	lds r29, pulse1_fx_1xx_total+1
0024f8 1bac                      	sub r26, r28
0024f9 0bbd                      	sbc r27, r29
0024fa 91c0 284d                 	lds r28, pulse1_fx_2xx_total
0024fc 91d0 284e                 	lds r29, pulse1_fx_2xx_total+1
0024fe 0fac                      	add r26, r28
0024ff 1fbd                      	adc r27, r29
002500 91c0 2861                 	lds r28, pulse1_fx_Pxx_total
002502 91d0 2862                 	lds r29, pulse1_fx_Pxx_total+1
002504 0fac                      	add r26, r28
002505 1fbd                      	adc r27, r29
002506 91c0 2867                 	lds r28, pulse1_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
002508 91d0 2868                 	lds r29, pulse1_fx_Qxy_total_offset+1
00250a 1bac                      	sub r26, r28
00250b 0bbd                      	sbc r27, r29
00250c 91c0 286d                 	lds r28, pulse1_fx_Rxy_total_offset
00250e 91d0 286e                 	lds r29, pulse1_fx_Rxy_total_offset+1
002510 0fac                      	add r26, r28
002511 1fbd                      	adc r27, r29
                                 
002512 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
002514 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel0_hi_pitch:
002516 91e0 283b                 	lds ZL, pulse1_hi_pitch_macro
002518 91f0 283c                 	lds ZH, pulse1_hi_pitch_macro+1
00251a 9630                      	adiw Z, 0
00251b f409                      	brne sound_driver_instrument_routine_channel0_hi_pitch_continue
00251c c03c                      	rjmp sound_driver_instrument_routine_channel0_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel0_hi_pitch_continue:
00251d 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00251e 1fff                      	rol ZH
00251f 91a0 283d                 	lds r26, pulse1_hi_pitch_macro_offset
002521 0fea                      	add ZL, r26
002522 1df2                      	adc ZH, zero
                                 
002523 91b0 283f                 	lds r27, pulse1_hi_pitch_macro_release
002525 17ba                      	cp r27, r26
002526 f429                      	brne sound_driver_instrument_routine_channel0_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002527 91a0 283e                 	lds r26, pulse1_hi_pitch_macro_loop
002529 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00252a f010                      	brlo sound_driver_instrument_routine_channel0_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00252b c003                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_increment:
00252c 95a3                      	inc r26 //increment the macro offset
00252d 93a0 283d                 	sts pulse1_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_hi_pitch_read:
00252f 91b4                      	lpm r27, Z //load hi pitch data into r27
002530 38b0                      	cpi r27, 0x80 //check for macro end flag
002531 f489                      	brne sound_driver_instrument_routine_channel0_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_release:
002532 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002533 93a0 283d                 	sts pulse1_hi_pitch_macro_offset, r26
002535 91b0 283f                 	lds r27, pulse1_hi_pitch_macro_release
002537 3fbf                      	cpi r27, 0xFF
002538 f439                      	brne sound_driver_instrument_routine_channel0_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_loop:
002539 91b0 283e                 	lds r27, pulse1_hi_pitch_macro_loop //load the loop index
00253b 3fbf                      	cpi r27, 0xFF //check if there is a loop index
00253c f019                      	breq sound_driver_instrument_routine_channel0_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
00253d 93b0 283d                 	sts pulse1_hi_pitch_macro_offset, r27 //store the loop index into the offset
00253f cfd6                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_default:
002540 91b0 283a                 	lds r27, pulse1_total_hi_pitch_offset
002542 c005                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate:
002543 91a0 283a                 	lds r26, pulse1_total_hi_pitch_offset //load the total hi pitch offset to change
002545 0fba                      	add r27, r26
002546 93b0 283a                 	sts pulse1_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply:
002548 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002549 937f                      	push r23
00254a 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
00254b eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00254c 0367                      	mulsu r22, r23
00254d 917f                      	pop r23
00254e 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_offset:
00254f 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
002551 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
002553 0da0                      	add r26, r0 //offset the timer values
002554 1db1                      	adc r27, r1
002555 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
002557 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel0_duty:
002559 91e0 2840                 	lds ZL, pulse1_duty_macro
00255b 91f0 2841                 	lds ZH, pulse1_duty_macro+1
00255d 9630                      	adiw Z, 0
00255e f1b1                      	breq sound_driver_channel0_fx_routines //if no duty macro is in use, go to the next routine
00255f 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002560 1fff                      	rol ZH
002561 91a0 2842                 	lds r26, pulse1_duty_macro_offset
002563 0fea                      	add ZL, r26
002564 1df2                      	adc ZH, zero
                                 
002565 91b0 2844                 	lds r27, pulse1_duty_macro_release
002567 17ba                      	cp r27, r26
002568 f429                      	brne sound_driver_instrument_routine_channel0_duty_increment //if the current offset is not equal to the release index, increment the offset
002569 91a0 2843                 	lds r26, pulse1_duty_macro_loop
00256b 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00256c f010                      	brlo sound_driver_instrument_routine_channel0_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00256d c027                      	rjmp sound_driver_channel0_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel0_duty_increment:
00256e 95a3                      	inc r26 //increment the macro offset
00256f 93a0 2842                 	sts pulse1_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_duty_read:
002571 91b4                      	lpm r27, Z //load pitch data into r27
002572 3fbf                      	cpi r27, 0xFF //check for macro end flag
002573 f471                      	brne sound_driver_instrument_routine_channel0_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_release:
002574 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002575 93a0 2842                 	sts pulse1_duty_macro_offset, r26
002577 91b0 2844                 	lds r27, pulse1_duty_macro_release
002579 3fbf                      	cpi r27, 0xFF
00257a f4d1                      	brne sound_driver_channel0_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_loop:
00257b 91b0 2843                 	lds r27, pulse1_duty_macro_loop //load the loop index
00257d 3fbf                      	cpi r27, 0xFF //check if there is a loop index
00257e f0b1                      	breq sound_driver_channel0_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
00257f 93b0 2842                 	sts pulse1_duty_macro_offset, r27 //store the loop index into the offset
002581 cfd7                      	rjmp sound_driver_instrument_routine_channel0_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_load:
002582 eee0                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
002583 e6f0                      	ldi ZH, HIGH(sequences << 1)
002584 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
002585 1df2                      	adc ZH, zero
                                 
002586 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
002587 95b7                      	ror r27
002588 95b7                      	ror r27
002589 91a0 2800                 	lds r26, pulse1_param //load r26 with pulse1_param (register $4000)
00258b 2fca                      	mov r28, r26 //store a copy of pulse1_param into r28
00258c 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
00258d 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
00258e c001                      	rjmp sound_driver_instrument_routine_channel0_duty_load_store
00258f c005                      	rjmp sound_driver_channel0_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel0_duty_load_store:
002590 90a4                      	lpm pulse1_sequence, Z //store the sequence
                                 
002591 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
002592 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
002593 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_routines:
                                 sound_driver_channel0_fx_1xx_routine:
002595 91e0 2847                 	lds ZL, pulse1_fx_1xx
002597 91f0 2848                 	lds ZH, pulse1_fx_1xx+1
002599 9630                      	adiw Z, 0
00259a f051                      	breq sound_driver_channel0_fx_2xx_routine
                                 
00259b 91a0 2849                 	lds r26, pulse1_fx_1xx_total //load the rate to change the pitch by
00259d 91b0 284a                 	lds r27, pulse1_fx_1xx_total+1
00259f 0fae                      	add r26, ZL //increase the total offset by the rate
0025a0 1fbf                      	adc r27, ZH
0025a1 93a0 2849                 	sts pulse1_fx_1xx_total, r26
0025a3 93b0 284a                 	sts pulse1_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_2xx_routine:
0025a5 91e0 284b                 	lds ZL, pulse1_fx_2xx
0025a7 91f0 284c                 	lds ZH, pulse1_fx_2xx+1
0025a9 9630                      	adiw Z, 0
0025aa f051                      	breq sound_driver_channel0_fx_3xx_routine
                                 
0025ab 91a0 284d                 	lds r26, pulse1_fx_2xx_total //load the rate to change the pitch by
0025ad 91b0 284e                 	lds r27, pulse1_fx_2xx_total+1
0025af 0fae                      	add r26, ZL //increase the total offset by the rate
0025b0 1fbf                      	adc r27, ZH
0025b1 93a0 284d                 	sts pulse1_fx_2xx_total, r26
0025b3 93b0 284e                 	sts pulse1_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_3xx_routine:
0025b5 91e0 2853                 	lds ZL, pulse1_fx_3xx_speed
0025b7 91f0 2854                 	lds ZH, pulse1_fx_3xx_speed+1
0025b9 9630                      	adiw Z, 0
0025ba f409                      	brne sound_driver_channel0_fx_3xx_routine_check_start
0025bb c048                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_check_start:
0025bc 91a0 284f                 	lds r26, pulse1_fx_3xx_start
0025be 91b0 2850                 	lds r27, pulse1_fx_3xx_start+1
0025c0 9610                      	adiw r26:r27, 0
0025c1 f409                      	brne sound_driver_channel0_fx_3xx_routine_main
0025c2 c041                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_main:
0025c3 91c0 2851                 	lds r28, pulse1_fx_3xx_target
0025c5 91d0 2852                 	lds r29, pulse1_fx_3xx_target+1
                                 
0025c7 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
0025c8 07bd                      	cpc r27, r29
0025c9 f011                      	breq sound_driver_channel0_fx_3xx_routine_disable
0025ca f030                      	brlo sound_driver_channel0_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
0025cb c01f                      	rjmp sound_driver_channel0_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel0_fx_3xx_routine_disable:
0025cc 9220 284f                 	sts pulse1_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
0025ce 9220 2850                 	sts pulse1_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
0025d0 c033                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_subtract:
0025d1 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
0025d2 0bdb                      	sbc r29, r27
0025d3 91a0 2855                 	lds r26, pulse1_fx_3xx_total_offset
0025d5 91b0 2856                 	lds r27, pulse1_fx_3xx_total_offset+1
                                 
0025d7 0fae                      	add r26, ZL //add the speed to the total offset
0025d8 1fbf                      	adc r27, ZH
0025d9 1bca                      	sub r28, r26 //invert the total difference with the total offset
0025da 0bdb                      	sbc r29, r27
0025db f380                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0025dc 93a0 2855                 	sts pulse1_fx_3xx_total_offset, r26 //store the new total offset
0025de 93b0 2856                 	sts pulse1_fx_3xx_total_offset+1, r27
                                 
0025e0 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the current timer period
0025e2 91b0 0a8d                 	lds r27, TCB0_CCMPH
0025e4 1bac                      	sub r26, r28 //offset the current timer period with the total offset
0025e5 0bbd                      	sbc r27, r29
0025e6 93a0 0a8c                 	sts TCB0_CCMPL, r26
0025e8 93b0 0a8d                 	sts TCB0_CCMPH, r27
0025ea c019                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_add:
0025eb 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
0025ec 0bbd                      	sbc r27, r29
0025ed 91c0 2855                 	lds r28, pulse1_fx_3xx_total_offset
0025ef 91d0 2856                 	lds r29, pulse1_fx_3xx_total_offset+1
                                 
0025f1 0fce                      	add r28, ZL //add the speed to the total offset
0025f2 1fdf                      	adc r29, ZH
0025f3 1bac                      	sub r26, r28 //invert the total difference with the total offset
0025f4 0bbd                      	sbc r27, r29
0025f5 f2b0                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0025f6 93c0 2855                 	sts pulse1_fx_3xx_total_offset, r28 //store the new total offset
0025f8 93d0 2856                 	sts pulse1_fx_3xx_total_offset+1, r29
                                 
0025fa 91c0 0a8c                 	lds r28, TCB0_CCMPL //load the current timer period
0025fc 91d0 0a8d                 	lds r29, TCB0_CCMPH
0025fe 0fca                      	add r28, r26 //offset the current timer period with the total offset
0025ff 1fdb                      	adc r29, r27
002600 93c0 0a8c                 	sts TCB0_CCMPL, r28
002602 93d0 0a8d                 	sts TCB0_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel0_fx_4xy_routine:
002604 91a0 2857                 	lds r26, pulse1_fx_4xy_speed
002606 15a2                      	cp r26, zero
002607 f409                      	brne sound_driver_channel0_fx_4xy_routine_continue
002608 c05c                      	rjmp sound_driver_channel0_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel0_fx_4xy_routine_continue:
002609 91b0 2858                 	lds r27, pulse1_fx_4xy_depth
00260b 91c0 2859                 	lds r28, pulse1_fx_4xy_phase
00260d 0fca                      	add r28, r26 //increase the phase by the speed
00260e 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
00260f f008                      	brlo sound_driver_channel0_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002610 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase:
002611 93c0 2859                 	sts pulse1_fx_4xy_phase, r28 //store the new phase
002613 31c0                      	cpi r28, 16
002614 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_0
002615 32c0                      	cpi r28, 32
002616 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_1
002617 33c0                      	cpi r28, 48
002618 f030                      	brlo sound_driver_channel0_fx_4xy_routine_phase_2
002619 c007                      	rjmp sound_driver_channel0_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_0:
00261a 70cf                      	andi r28, 0x0F //mask for values 0-15
00261b c029                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_1:
00261c 6fc0                      	ori r28, 0xF0
00261d 95c0                      	com r28 //invert values 0-15
00261e c026                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_2:
00261f 70cf                      	andi r28, 0x0F //mask for values 0-15
002620 c003                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_3:
002621 6fc0                      	ori r28, 0xF0
002622 95c0                      	com r28 //invert values 0-15
002623 c000                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_add:
002624 95b2                      	swap r27 //multiply depth by 16
002625 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002626 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002627 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002628 0fec                      	add ZL, r28 //offset the table by the depth+phase
002629 1df2                      	adc ZH, zero
00262a 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
00262b 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00262c 937f                      	push r23
00262d 2f6c                      	mov r22, r28 //store the vibrato value into r22
00262e eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00262f 9f67                      	mul r22, r23
002630 917f                      	pop r23
002631 916f                      	pop r22
                                 
002632 9416                      	lsr r1 //shift out the fractional bits
002633 9407                      	ror r0
002634 9416                      	lsr r1
002635 9407                      	ror r0
002636 9416                      	lsr r1
002637 9407                      	ror r0
002638 9416                      	lsr r1
002639 9407                      	ror r0
                                 	
00263a 91a0 0a8c                 	lds r26, TCB0_CCMPL
00263c 91b0 0a8d                 	lds r27, TCB0_CCMPH
00263e 0da0                      	add r26, r0
00263f 1db1                      	adc r27, r1
002640 93a0 0a8c                 	sts TCB0_CCMPL, r26
002642 93b0 0a8d                 	sts TCB0_CCMPH, r27
002644 c020                      	rjmp sound_driver_channel0_fx_7xy_routine
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_subtract:
002645 95b2                      	swap r27 //multiply depth by 16
002646 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002647 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002648 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002649 0fec                      	add ZL, r28 //offset the table by the depth+phase
00264a 1df2                      	adc ZH, zero
00264b 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
00264c 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00264d 937f                      	push r23
00264e 2f6c                      	mov r22, r28 //store the vibrato value into r22
00264f eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002650 9f67                      	mul r22, r23
002651 917f                      	pop r23
002652 916f                      	pop r22
                                 
002653 9416                      	lsr r1 //shift out the fractional bits
002654 9407                      	ror r0
002655 9416                      	lsr r1
002656 9407                      	ror r0
002657 9416                      	lsr r1
002658 9407                      	ror r0
002659 9416                      	lsr r1
00265a 9407                      	ror r0
                                 
00265b 91a0 0a8c                 	lds r26, TCB0_CCMPL
00265d 91b0 0a8d                 	lds r27, TCB0_CCMPH
00265f 19a0                      	sub r26, r0
002660 09b1                      	sbc r27, r1
002661 93a0 0a8c                 	sts TCB0_CCMPL, r26
002663 93b0 0a8d                 	sts TCB0_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_7xy_routine:
002665 91a0 285a                 	lds r26, pulse1_fx_7xy_speed
002667 15a2                      	cp r26, zero
002668 f0f1                      	breq sound_driver_channel0_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
002669 91b0 285b                 	lds r27, pulse1_fx_7xy_depth
00266b 91c0 285c                 	lds r28, pulse1_fx_7xy_phase
00266d 0fca                      	add r28, r26 //increase the phase by the speed
00266e 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
00266f f010                      	brlo sound_driver_channel0_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
002670 e0c0                      	ldi r28, 0x00
002671 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase:
002672 93c0 285c                 	sts pulse1_fx_7xy_phase, r28 //store the new phase
002674 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
002675 ffc4                      	sbrs r28, 4
002676 c001                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_0
002677 c002                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel0_fx_7xy_routine_phase_0:
002678 70cf                      	andi r28, 0x0F //mask for values 0-15
002679 c003                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase_1:
00267a 6fc0                      	ori r28, 0xF0
00267b 95c0                      	com r28 //invert values 0-15
00267c c000                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_load:
00267d 95b2                      	swap r27 //multiply depth by 16
00267e 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
00267f e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002680 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002681 0fec                      	add ZL, r28 //offset the table by the depth+phase
002682 1df2                      	adc ZH, zero
002683 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002684 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
002685 93c0 285d                 	sts pulse1_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Axy_routine:
002687 91b0 285e                 	lds r27, pulse1_fx_Axy
002689 15b2                      	cp r27, zero
00268a f0e9                      	breq sound_driver_channel0_fx_Qxy_routine //0 means that the effect is not in use
                                 	
00268b 91a0 2805                 	lds r26, pulse1_fractional_volume //load fractional volume representation of the channel
00268d 91c0 2800                 	lds r28, pulse1_param //load the integer volume representation of the channel
00268f 2fda                      	mov r29, r26 //copy fractional volume into r29
002690 2fec                      	mov r30, r28 //copy the pulse1_param into r30
002691 95e2                      	swap r30
002692 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
002693 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
002694 17ed                      	cp r30, r29 //compare the fractional and integer volumes
002695 f009                      	breq sound_driver_channel0_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel0_fx_Axy_routine_reload:
002696 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate:
002697 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
002698 c004                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_addition:
002699 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
00269a f428                      	brcc sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
00269b efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
00269c c003                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_subtraction:
00269d 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
00269e f008                      	brcs sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
00269f e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_store:
0026a0 93a0 2805                 	sts pulse1_fractional_volume, r26 //store the new fractional volume
0026a2 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
0026a3 95a2                      	swap r26
0026a4 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
0026a5 2bca                      	or r28, r26 //store the new volume back into pulse1_param
0026a6 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel0_fx_Qxy_routine:
0026a8 91e0 2863                 	lds ZL, pulse1_fx_Qxy_target
0026aa 91f0 2864                 	lds ZH, pulse1_fx_Qxy_target+1
0026ac 9630                      	adiw Z, 0
0026ad f139                      	breq sound_driver_channel0_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
0026ae 91a0 2867                 	lds r26, pulse1_fx_Qxy_total_offset
0026b0 91b0 2868                 	lds r27, pulse1_fx_Qxy_total_offset+1
0026b2 91c0 0a8c                 	lds r28, TCB0_CCMPL
0026b4 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
0026b6 1bec                      	sub ZL, r28 //calculate the difference to the target
0026b7 0bfd                      	sbc ZH, r29
0026b8 f408                      	brsh sound_driver_channel0_fx_Qxy_routine_end //if the target has been reached (or passed)
0026b9 f088                      	brlo sound_driver_channel0_fx_Qxy_routine_add
                                 
                                 sound_driver_channel0_fx_Qxy_routine_end:
0026ba 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
0026bb 0bbf                      	sbc r27, ZH
                                 
0026bc 91c0 2861                 	lds r28, pulse1_fx_Pxx_total
0026be 91d0 2862                 	lds r29, pulse1_fx_Pxx_total+1
                                 
0026c0 0fac                      	add r26, r28
0026c1 1fbd                      	adc r27, r29
                                 
0026c2 93a0 2867                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
0026c4 93b0 2868                 	sts pulse1_fx_Qxy_total_offset+1, r27
0026c6 9220 2863                 	sts pulse1_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
0026c8 9220 2864                 	sts pulse1_fx_Qxy_target+1, zero
0026ca c00a                      	rjmp sound_driver_channel0_fx_Rxy_routine
                                 
                                 sound_driver_channel0_fx_Qxy_routine_add:
0026cb 91c0 2865                 	lds r28, pulse1_fx_Qxy_speed
0026cd 91d0 2866                 	lds r29, pulse1_fx_Qxy_speed+1
0026cf 0fac                      	add r26, r28 //increase the total offset by the speed
0026d0 1fbd                      	adc r27, r29
0026d1 93a0 2867                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
0026d3 93b0 2868                 	sts pulse1_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Rxy_routine:
0026d5 91e0 2869                 	lds ZL, pulse1_fx_Rxy_target
0026d7 91f0 286a                 	lds ZH, pulse1_fx_Rxy_target+1
0026d9 9630                      	adiw Z, 0
0026da f139                      	breq sound_driver_instrument_routine_channel1_volume //if the effect is not enabled, skip the routine
                                 
0026db 91a0 286d                 	lds r26, pulse1_fx_Rxy_total_offset
0026dd 91b0 286e                 	lds r27, pulse1_fx_Rxy_total_offset+1
0026df 91c0 0a8c                 	lds r28, TCB0_CCMPL
0026e1 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
0026e3 1bce                      	sub r28, ZL //calculate the difference to the target
0026e4 0bdf                      	sbc r29, ZH
0026e5 f408                      	brsh sound_driver_channel0_fx_Rxy_routine_end //if the target has been reached (or passed)
0026e6 f088                      	brlo sound_driver_channel0_fx_Rxy_routine_add
                                 
                                 sound_driver_channel0_fx_Rxy_routine_end:
0026e7 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
0026e8 0bbd                      	sbc r27, r29
                                 
0026e9 91c0 2861                 	lds r28, pulse1_fx_Pxx_total
0026eb 91d0 2862                 	lds r29, pulse1_fx_Pxx_total+1
                                 
0026ed 0fac                      	add r26, r28
0026ee 1fbd                      	adc r27, r29
                                 
0026ef 93a0 286d                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
0026f1 93b0 286e                 	sts pulse1_fx_Rxy_total_offset+1, r27
0026f3 9220 2869                 	sts pulse1_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
0026f5 9220 286a                 	sts pulse1_fx_Rxy_target+1, zero
0026f7 c00a                      	rjmp sound_driver_instrument_routine_channel1_volume
                                 
                                 sound_driver_channel0_fx_Rxy_routine_add:
0026f8 91c0 286b                 	lds r28, pulse1_fx_Rxy_speed
0026fa 91d0 286c                 	lds r29, pulse1_fx_Rxy_speed+1
0026fc 0fac                      	add r26, r28 //increase the total offset by the speed
0026fd 1fbd                      	adc r27, r29
0026fe 93a0 286d                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
002700 93b0 286e                 	sts pulse1_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume:
002702 91e0 2877                 	lds ZL, pulse2_volume_macro
002704 91f0 2878                 	lds ZH, pulse2_volume_macro+1
002706 9630                      	adiw Z, 0
002707 f1a1                      	breq sound_driver_instrument_routine_channel1_volume_default //if no volume macro is in use, use default multiplier of F
002708 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002709 1fff                      	rol ZH
00270a 91a0 2879                 	lds r26, pulse2_volume_macro_offset
00270c 0fea                      	add ZL, r26
00270d 1df2                      	adc ZH, zero
                                 
00270e 91b0 287b                 	lds r27, pulse2_volume_macro_release
002710 17ba                      	cp r27, r26
002711 f429                      	brne sound_driver_instrument_routine_channel1_volume_increment //if the current offset is not equal to the release index, increment the offset
002712 91a0 287a                 	lds r26, pulse2_volume_macro_loop
002714 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002715 f010                      	brlo sound_driver_instrument_routine_channel1_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002716 c003                      	rjmp sound_driver_instrument_routine_channel1_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_volume_increment:
002717 95a3                      	inc r26 //increment the macro offset
002718 93a0 2879                 	sts pulse2_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_volume_read:
00271a 91b4                      	lpm r27, Z //load volume data into r27
00271b 3fbf                      	cpi r27, 0xFF //check for macro end flag
00271c f469                      	brne sound_driver_instrument_routine_channel1_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_release:
00271d 91b0 287b                 	lds r27, pulse2_volume_macro_release
00271f 3fbf                      	cpi r27, 0xFF
002720 f429                      	brne sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_loop:
002721 91b0 287a                 	lds r27, pulse2_volume_macro_loop //load the loop index
002723 93b0 2879                 	sts pulse2_volume_macro_offset, r27 //store the loop index into the offset
002725 cfdc                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index:
002726 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002727 93a0 2879                 	sts pulse2_volume_macro_offset, r26
002729 cfd8                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_calculate:
00272a ebe4                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
00272b e6f1                      	ldi ZH, HIGH(volumes << 1)
00272c 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
00272d 0feb                      	add ZL, r27 //add offset to the table
00272e 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel1_volume_load:
00272f 91b0 2808                 	lds r27, pulse2_param //load main volume
002731 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002732 91a0 28ac                 	lds r26, pulse2_fx_7xy_value
002734 30a0                      	cpi r26, 0x00
002735 f481                      	brne sound_driver_instrument_routine_channel1_volume_load_7xy
                                 
002736 0feb                      	add ZL, r27 //offset the volume table by the main volume
002737 1df2                      	adc ZH, zero
002738 91b4                      	lpm r27, Z
002739 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
00273b c024                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default:
00273c 91b0 2808                 	lds r27, pulse2_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
00273e 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
00273f 91a0 28ac                 	lds r26, pulse2_fx_7xy_value
002741 30a0                      	cpi r26, 0x00
002742 f4a1                      	brne sound_driver_instrument_routine_channel1_volume_default_7xy
002743 93b0 280e                 	sts pulse2_output_volume, r27
002745 c01a                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy:
002746 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002747 f040                      	brcs sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
002748 f039                      	breq sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
002749 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
                                 
00274a 0feb                      	add ZL, r27 //offset the volume table by the main volume
00274b 1df2                      	adc ZH, zero
00274c 91b4                      	lpm r27, Z
00274d 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
00274f c010                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy_overflow:
002750 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002751 0feb                      	add ZL, r27 //offset the volume table by the main volume
002752 1df2                      	adc ZH, zero
002753 91b4                      	lpm r27, Z
002754 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
002756 c009                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default_7xy:
002757 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002758 f020                      	brcs sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
002759 f019                      	breq sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
00275a 93b0 280e                 	sts pulse2_output_volume, r27
00275c c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel1_volume_default_7xy_overflow:
00275d e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
00275e 93b0 280e                 	sts pulse2_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002760 91e0 287c                 	lds ZL, pulse2_arpeggio_macro
002762 91f0 287d                 	lds ZH, pulse2_arpeggio_macro+1
002764 9630                      	adiw Z, 0
002765 f1d9                      	breq sound_driver_instrument_routine_channel1_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002766 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002767 1fff                      	rol ZH
002768 91a0 287e                 	lds r26, pulse2_arpeggio_macro_offset
00276a 0fea                      	add ZL, r26
00276b 1df2                      	adc ZH, zero
                                 
00276c 91b0 2880                 	lds r27, pulse2_arpeggio_macro_release
00276e 17ba                      	cp r27, r26
00276f f429                      	brne sound_driver_instrument_routine_channel1_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002770 91a0 287f                 	lds r26, pulse2_arpeggio_macro_loop
002772 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002773 f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002774 c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_increment:
002775 95a3                      	inc r26 //increment the macro offset
002776 93a0 287e                 	sts pulse2_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_read:
002778 91b4                      	lpm r27, Z //load arpeggio data into r27
002779 38b0                      	cpi r27, 0x80 //check for macro end flag
00277a f009                      	breq sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag
00277b c041                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_check_mode:
00277c 50a1                      	subi r26, 1 //keep the offset at the end flag
00277d 93a0 287e                 	sts pulse2_arpeggio_macro_offset, r26
00277f 91b0 2881                 	lds r27, pulse2_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002781 30b1                      	cpi r27, 0x01
002782 f048                      	brlo sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_release:
002783 91b0 2880                 	lds r27, pulse2_arpeggio_macro_release
002785 3fbf                      	cpi r27, 0xFF
002786 f4d1                      	brne sound_driver_instrument_routine_channel1_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_loop:
002787 91b0 287f                 	lds r27, pulse2_arpeggio_macro_loop
002789 3fbf                      	cpi r27, 0xFF
00278a f499                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
00278b c015                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute:
00278c 91b0 2880                 	lds r27, pulse2_arpeggio_macro_release
00278e 3fbf                      	cpi r27, 0xFF
00278f f421                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_check_loop:
002790 91b0 287f                 	lds r27, pulse2_arpeggio_macro_loop //load the loop index
002792 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002793 f451                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop:
002794 91c0 2894                 	lds r28, pulse2_fx_0xy_sequence //check for 0xy effect
002796 91d0 2895                 	lds r29, pulse2_fx_0xy_sequence+1
002798 9620                      	adiw r29:r28, 0
002799 f469                      	brne sound_driver_instrument_routine_channel1_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
00279a 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
00279b 93a0 287e                 	sts pulse2_arpeggio_macro_offset, r26 //store the last valid index into the offset
00279d cfc2                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload:
00279e 93b0 287e                 	sts pulse2_arpeggio_macro_offset, r27 //store the loop index into the offset
0027a0 cfbf                      	rjmp sound_driver_instrument_routine_channel1_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_default:
0027a1 91c0 2894                 	lds r28, pulse2_fx_0xy_sequence //load 0xy effect
0027a3 91d0 2895                 	lds r29, pulse2_fx_0xy_sequence+1
0027a5 9620                      	adiw r29:r28, 0 //check for 0xy effect
0027a6 f099                      	breq sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel1_arpeggio_default_xy:
0027a7 95d6                      	lsr r29
0027a8 95c7                      	ror r28
0027a9 95d7                      	ror r29
0027aa 95c7                      	ror r28
0027ab 95d7                      	ror r29
0027ac 95c7                      	ror r28
0027ad 95d7                      	ror r29
0027ae 95c7                      	ror r28
0027af 95d7                      	ror r29
0027b0 95d2                      	swap r29
                                 
0027b1 93c0 2894                 	sts pulse2_fx_0xy_sequence, r28 //store the rolled sequence
0027b3 93d0 2895                 	sts pulse2_fx_0xy_sequence+1, r29
0027b5 70cf                      	andi r28, 0x0F //mask out the 4 LSB
0027b6 91a0 280f                 	lds r26, pulse2_note //load the current note index
0027b8 0fac                      	add r26, r28 //add the note offset
0027b9 c02e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
0027ba 91a0 280f                 	lds r26, pulse2_note //load the current note index
0027bc c02b                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process:
0027bd 9220 2882                 	sts pulse2_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
0027bf 9220 2883                 	sts pulse2_total_pitch_offset+1, zero
0027c1 9220 2889                 	sts pulse2_total_hi_pitch_offset, zero
0027c3 91a0 2881                 	lds r26, pulse2_arpeggio_macro_mode
0027c5 30a1                      	cpi r26, 0x01 //absolute mode
0027c6 f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_absolute
0027c7 f069                      	breq sound_driver_instrument_routine_channel1_arpeggio_process_fixed
0027c8 c00e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute:
0027c9 91a0 280f                 	lds r26, pulse2_note //load the current note index
0027cb 0fab                      	add r26, r27 //offset the note with the arpeggio data
0027cc fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0027cd c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_add:
0027ce 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0027cf f0c0                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
0027d0 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0027d1 c016                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract:
0027d2 fda7                      	sbrc r26, 7 //check if result is negative
0027d3 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0027d4 c013                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_fixed:
0027d5 2fab                      	mov r26, r27 //move the arpeggio data into r26
0027d6 c011                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative:
0027d7 91a0 280f                 	lds r26, pulse2_note //load the current note index
0027d9 0fab                      	add r26, r27 //offset the note with the arpeggio data
0027da fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0027db c008                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_add:
0027dc 93a0 280f                 	sts pulse2_note, r26 //NOTE: relative mode modifies the original note index
0027de 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0027df f040                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
0027e0 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0027e1 93a0 280f                 	sts pulse2_note, r26
0027e3 c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract:
0027e4 fda7                      	sbrc r26, 7 //check if result is negative
0027e5 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0027e6 93a0 280f                 	sts pulse2_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_load:
0027e8 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0027e9 e0f0                      	ldi ZH, HIGH(note_table << 1)
0027ea 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
0027eb 0fea                      	add ZL, r26 //add offset
0027ec 1df2                      	adc ZH, zero
0027ed 91a5                      	lpm r26, Z+ //load bytes
0027ee 91b4                      	lpm r27, Z
0027ef 93a0 0a9c                 	sts TCB1_CCMPL, r26 //load the LOW bits for timer
0027f1 93b0 0a9d                 	sts TCB1_CCMPH, r27 //load the HIGH bits for timer
0027f3 93a0 28a0                 	sts pulse2_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
0027f5 93b0 28a1                 	sts pulse2_fx_3xx_target+1, r27
0027f7 c000                      	rjmp sound_driver_instrument_routine_channel1_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch:
0027f8 91e0 2884                 	lds ZL, pulse2_pitch_macro
0027fa 91f0 2885                 	lds ZH, pulse2_pitch_macro+1
0027fc 9630                      	adiw Z, 0
0027fd f409                      	brne sound_driver_instrument_routine_channel1_pitch_continue
0027fe c023                      	rjmp sound_driver_instrument_routine_channel1_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel1_pitch_continue:
0027ff 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002800 1fff                      	rol ZH
002801 91a0 2886                 	lds r26, pulse2_pitch_macro_offset
002803 0fea                      	add ZL, r26
002804 1df2                      	adc ZH, zero
                                 
002805 91b0 2888                 	lds r27, pulse2_pitch_macro_release
002807 17ba                      	cp r27, r26
002808 f429                      	brne sound_driver_instrument_routine_channel1_pitch_increment //if the current offset is not equal to the release index, increment the offset
002809 91a0 2887                 	lds r26, pulse2_pitch_macro_loop
00280b 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00280c f010                      	brlo sound_driver_instrument_routine_channel1_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00280d c003                      	rjmp sound_driver_instrument_routine_channel1_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_pitch_increment:
00280e 95a3                      	inc r26 //increment the macro offset
00280f 93a0 2886                 	sts pulse2_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_pitch_read:
002811 91b4                      	lpm r27, Z //load pitch data into r27
002812 38b0                      	cpi r27, 0x80 //check for macro end flag
002813 f479                      	brne sound_driver_instrument_routine_channel1_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_release:
002814 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002815 93a0 2886                 	sts pulse2_pitch_macro_offset, r26
002817 91b0 2888                 	lds r27, pulse2_pitch_macro_release
002819 3fbf                      	cpi r27, 0xFF
00281a f439                      	brne sound_driver_instrument_routine_channel1_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_loop:
00281b 91b0 2887                 	lds r27, pulse2_pitch_macro_loop //load the loop index
00281d 3fbf                      	cpi r27, 0xFF //check if there is a loop index
00281e f019                      	breq sound_driver_instrument_routine_channel1_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
00281f 93b0 2886                 	sts pulse2_pitch_macro_offset, r27 //store the loop index into the offset
002821 cfd6                      	rjmp sound_driver_instrument_routine_channel1_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_default:
002822 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel1_pitch_calculate:
002823 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002824 937f                      	push r23
002825 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
002826 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002827 0367                      	mulsu r22, r23
002828 917f                      	pop r23
002829 916f                      	pop r22
                                 
00282a 9416                      	lsr r1 //shift out the fractional bits
00282b 9407                      	ror r0
00282c 9416                      	lsr r1
00282d 9407                      	ror r0
00282e 9416                      	lsr r1
00282f 9407                      	ror r0
002830 9416                      	lsr r1
002831 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_check_negative:
002832 fe13                      	sbrs r1, 3 //check if result was a negative number
002833 c007                      	rjmp sound_driver_instrument_routine_channel1_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_negative:
002834 efc0                      	ldi r28, 0xF0
002835 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_check_divisible_8:
002836 70b7                      	andi r27, 0b00000111
002837 f019                      	breq sound_driver_instrument_routine_channel1_pitch_calculate_offset
                                 
002838 e0b1                      	ldi r27, 0x01
002839 0e0b                      	add r0, r27
00283a 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_offset:
00283b 91a0 2882                 	lds r26, pulse2_total_pitch_offset
00283d 91b0 2883                 	lds r27, pulse2_total_pitch_offset+1
00283f 0e0a                      	add r0, r26
002840 1e1b                      	adc r1, r27
002841 9200 2882                 	sts pulse2_total_pitch_offset, r0
002843 9210 2883                 	sts pulse2_total_pitch_offset+1, r1
002845 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
002847 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
002849 0da0                      	add r26, r0 //offset the timer values
00284a 1db1                      	adc r27, r1
                                 	
00284b 91c0 2898                 	lds r28, pulse2_fx_1xx_total
00284d 91d0 2899                 	lds r29, pulse2_fx_1xx_total+1
00284f 1bac                      	sub r26, r28
002850 0bbd                      	sbc r27, r29
002851 91c0 289c                 	lds r28, pulse2_fx_2xx_total
002853 91d0 289d                 	lds r29, pulse2_fx_2xx_total+1
002855 0fac                      	add r26, r28
002856 1fbd                      	adc r27, r29
002857 91c0 28b0                 	lds r28, pulse2_fx_Pxx_total
002859 91d0 28b1                 	lds r29, pulse2_fx_Pxx_total+1
00285b 0fac                      	add r26, r28
00285c 1fbd                      	adc r27, r29
00285d 91c0 28b6                 	lds r28, pulse2_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
00285f 91d0 28b7                 	lds r29, pulse2_fx_Qxy_total_offset+1
002861 1bac                      	sub r26, r28
002862 0bbd                      	sbc r27, r29
002863 91c0 28bc                 	lds r28, pulse2_fx_Rxy_total_offset
002865 91d0 28bd                 	lds r29, pulse2_fx_Rxy_total_offset+1
002867 0fac                      	add r26, r28
002868 1fbd                      	adc r27, r29
                                 
002869 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
00286b 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel1_hi_pitch:
00286d 91e0 288a                 	lds ZL, pulse2_hi_pitch_macro
00286f 91f0 288b                 	lds ZH, pulse2_hi_pitch_macro+1
002871 9630                      	adiw Z, 0
002872 f409                      	brne sound_driver_instrument_routine_channel1_hi_pitch_continue
002873 c03c                      	rjmp sound_driver_instrument_routine_channel1_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel1_hi_pitch_continue:
002874 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002875 1fff                      	rol ZH
002876 91a0 288c                 	lds r26, pulse2_hi_pitch_macro_offset
002878 0fea                      	add ZL, r26
002879 1df2                      	adc ZH, zero
                                 
00287a 91b0 288e                 	lds r27, pulse2_hi_pitch_macro_release
00287c 17ba                      	cp r27, r26
00287d f429                      	brne sound_driver_instrument_routine_channel1_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
00287e 91a0 288d                 	lds r26, pulse2_hi_pitch_macro_loop
002880 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002881 f010                      	brlo sound_driver_instrument_routine_channel1_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002882 c003                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_increment:
002883 95a3                      	inc r26 //increment the macro offset
002884 93a0 288c                 	sts pulse2_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_hi_pitch_read:
002886 91b4                      	lpm r27, Z //load hi pitch data into r27
002887 38b0                      	cpi r27, 0x80 //check for macro end flag
002888 f489                      	brne sound_driver_instrument_routine_channel1_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_release:
002889 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00288a 93a0 288c                 	sts pulse2_hi_pitch_macro_offset, r26
00288c 91b0 288e                 	lds r27, pulse2_hi_pitch_macro_release
00288e 3fbf                      	cpi r27, 0xFF
00288f f439                      	brne sound_driver_instrument_routine_channel1_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_loop:
002890 91b0 288d                 	lds r27, pulse2_hi_pitch_macro_loop //load the loop index
002892 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002893 f019                      	breq sound_driver_instrument_routine_channel1_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002894 93b0 288c                 	sts pulse2_hi_pitch_macro_offset, r27 //store the loop index into the offset
002896 cfd6                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_default:
002897 91b0 2889                 	lds r27, pulse2_total_hi_pitch_offset
002899 c005                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate:
00289a 91a0 2889                 	lds r26, pulse2_total_hi_pitch_offset //load the total hi pitch offset to change
00289c 0fba                      	add r27, r26
00289d 93b0 2889                 	sts pulse2_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply:
00289f 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0028a0 937f                      	push r23
0028a1 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
0028a2 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0028a3 0367                      	mulsu r22, r23
0028a4 917f                      	pop r23
0028a5 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_offset:
0028a6 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
0028a8 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
0028aa 0da0                      	add r26, r0 //offset the timer values
0028ab 1db1                      	adc r27, r1
0028ac 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
0028ae 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel1_duty:
0028b0 91e0 288f                 	lds ZL, pulse2_duty_macro
0028b2 91f0 2890                 	lds ZH, pulse2_duty_macro+1
0028b4 9630                      	adiw Z, 0
0028b5 f1b1                      	breq sound_driver_channel1_fx_routines //if no duty macro is in use, go to the next routine
0028b6 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0028b7 1fff                      	rol ZH
0028b8 91a0 2891                 	lds r26, pulse2_duty_macro_offset
0028ba 0fea                      	add ZL, r26
0028bb 1df2                      	adc ZH, zero
                                 
0028bc 91b0 2893                 	lds r27, pulse2_duty_macro_release
0028be 17ba                      	cp r27, r26
0028bf f429                      	brne sound_driver_instrument_routine_channel1_duty_increment //if the current offset is not equal to the release index, increment the offset
0028c0 91a0 2892                 	lds r26, pulse2_duty_macro_loop
0028c2 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0028c3 f010                      	brlo sound_driver_instrument_routine_channel1_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0028c4 c027                      	rjmp sound_driver_channel1_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel1_duty_increment:
0028c5 95a3                      	inc r26 //increment the macro offset
0028c6 93a0 2891                 	sts pulse2_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_duty_read:
0028c8 91b4                      	lpm r27, Z //load pitch data into r27
0028c9 3fbf                      	cpi r27, 0xFF //check for macro end flag
0028ca f471                      	brne sound_driver_instrument_routine_channel1_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_release:
0028cb 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0028cc 93a0 2891                 	sts pulse2_duty_macro_offset, r26
0028ce 91b0 2893                 	lds r27, pulse2_duty_macro_release
0028d0 3fbf                      	cpi r27, 0xFF
0028d1 f4d1                      	brne sound_driver_channel1_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_loop:
0028d2 91b0 2892                 	lds r27, pulse2_duty_macro_loop //load the loop index
0028d4 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0028d5 f0b1                      	breq sound_driver_channel1_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
0028d6 93b0 2891                 	sts pulse2_duty_macro_offset, r27 //store the loop index into the offset
0028d8 cfd7                      	rjmp sound_driver_instrument_routine_channel1_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_load:
0028d9 eee0                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
0028da e6f0                      	ldi ZH, HIGH(sequences << 1)
0028db 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
0028dc 1df2                      	adc ZH, zero
                                 
0028dd 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
0028de 95b7                      	ror r27
0028df 95b7                      	ror r27
0028e0 91a0 2808                 	lds r26, pulse2_param //load r26 with pulse2_param (register $4000)
0028e2 2fca                      	mov r28, r26 //store a copy of pulse2_param into r28
0028e3 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
0028e4 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
0028e5 c001                      	rjmp sound_driver_instrument_routine_channel1_duty_load_store
0028e6 c005                      	rjmp sound_driver_channel1_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel1_duty_load_store:
0028e7 90d4                      	lpm pulse2_sequence, Z //store the sequence
                                 
0028e8 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
0028e9 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
0028ea 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_routines:
                                 sound_driver_channel1_fx_1xx_routine:
0028ec 91e0 2896                 	lds ZL, pulse2_fx_1xx
0028ee 91f0 2897                 	lds ZH, pulse2_fx_1xx+1
0028f0 9630                      	adiw Z, 0
0028f1 f051                      	breq sound_driver_channel1_fx_2xx_routine
                                 
0028f2 91a0 2898                 	lds r26, pulse2_fx_1xx_total //load the rate to change the pitch by
0028f4 91b0 2899                 	lds r27, pulse2_fx_1xx_total+1
0028f6 0fae                      	add r26, ZL //increase the total offset by the rate
0028f7 1fbf                      	adc r27, ZH
0028f8 93a0 2898                 	sts pulse2_fx_1xx_total, r26
0028fa 93b0 2899                 	sts pulse2_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_2xx_routine:
0028fc 91e0 289a                 	lds ZL, pulse2_fx_2xx
0028fe 91f0 289b                 	lds ZH, pulse2_fx_2xx+1
002900 9630                      	adiw Z, 0
002901 f051                      	breq sound_driver_channel1_fx_3xx_routine
                                 
002902 91a0 289c                 	lds r26, pulse2_fx_2xx_total //load the rate to change the pitch by
002904 91b0 289d                 	lds r27, pulse2_fx_2xx_total+1
002906 0fae                      	add r26, ZL //increase the total offset by the rate
002907 1fbf                      	adc r27, ZH
002908 93a0 289c                 	sts pulse2_fx_2xx_total, r26
00290a 93b0 289d                 	sts pulse2_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_3xx_routine:
00290c 91e0 28a2                 	lds ZL, pulse2_fx_3xx_speed
00290e 91f0 28a3                 	lds ZH, pulse2_fx_3xx_speed+1
002910 9630                      	adiw Z, 0
002911 f409                      	brne sound_driver_channel1_fx_3xx_routine_check_start
002912 c048                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_check_start:
002913 91a0 289e                 	lds r26, pulse2_fx_3xx_start
002915 91b0 289f                 	lds r27, pulse2_fx_3xx_start+1
002917 9610                      	adiw r26:r27, 0
002918 f409                      	brne sound_driver_channel1_fx_3xx_routine_main
002919 c041                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_main:
00291a 91c0 28a0                 	lds r28, pulse2_fx_3xx_target
00291c 91d0 28a1                 	lds r29, pulse2_fx_3xx_target+1
                                 
00291e 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
00291f 07bd                      	cpc r27, r29
002920 f011                      	breq sound_driver_channel1_fx_3xx_routine_disable
002921 f030                      	brlo sound_driver_channel1_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002922 c01f                      	rjmp sound_driver_channel1_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel1_fx_3xx_routine_disable:
002923 9220 289e                 	sts pulse2_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002925 9220 289f                 	sts pulse2_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002927 c033                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_subtract:
002928 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002929 0bdb                      	sbc r29, r27
00292a 91a0 28a4                 	lds r26, pulse2_fx_3xx_total_offset
00292c 91b0 28a5                 	lds r27, pulse2_fx_3xx_total_offset+1
                                 
00292e 0fae                      	add r26, ZL //add the speed to the total offset
00292f 1fbf                      	adc r27, ZH
002930 1bca                      	sub r28, r26 //invert the total difference with the total offset
002931 0bdb                      	sbc r29, r27
002932 f380                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002933 93a0 28a4                 	sts pulse2_fx_3xx_total_offset, r26 //store the new total offset
002935 93b0 28a5                 	sts pulse2_fx_3xx_total_offset+1, r27
                                 
002937 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the current timer period
002939 91b0 0a9d                 	lds r27, TCB1_CCMPH
00293b 1bac                      	sub r26, r28 //offset the current timer period with the total offset
00293c 0bbd                      	sbc r27, r29
00293d 93a0 0a9c                 	sts TCB1_CCMPL, r26
00293f 93b0 0a9d                 	sts TCB1_CCMPH, r27
002941 c019                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_add:
002942 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002943 0bbd                      	sbc r27, r29
002944 91c0 28a4                 	lds r28, pulse2_fx_3xx_total_offset
002946 91d0 28a5                 	lds r29, pulse2_fx_3xx_total_offset+1
                                 
002948 0fce                      	add r28, ZL //add the speed to the total offset
002949 1fdf                      	adc r29, ZH
00294a 1bac                      	sub r26, r28 //invert the total difference with the total offset
00294b 0bbd                      	sbc r27, r29
00294c f2b0                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
00294d 93c0 28a4                 	sts pulse2_fx_3xx_total_offset, r28 //store the new total offset
00294f 93d0 28a5                 	sts pulse2_fx_3xx_total_offset+1, r29
                                 
002951 91c0 0a9c                 	lds r28, TCB1_CCMPL //load the current timer period
002953 91d0 0a9d                 	lds r29, TCB1_CCMPH
002955 0fca                      	add r28, r26 //offset the current timer period with the total offset
002956 1fdb                      	adc r29, r27
002957 93c0 0a9c                 	sts TCB1_CCMPL, r28
002959 93d0 0a9d                 	sts TCB1_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel1_fx_4xy_routine:
00295b 91a0 28a6                 	lds r26, pulse2_fx_4xy_speed
00295d 15a2                      	cp r26, zero
00295e f409                      	brne sound_driver_channel1_fx_4xy_routine_continue
00295f c05c                      	rjmp sound_driver_channel1_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel1_fx_4xy_routine_continue:
002960 91b0 28a7                 	lds r27, pulse2_fx_4xy_depth
002962 91c0 28a8                 	lds r28, pulse2_fx_4xy_phase
002964 0fca                      	add r28, r26 //increase the phase by the speed
002965 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
002966 f008                      	brlo sound_driver_channel1_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002967 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase:
002968 93c0 28a8                 	sts pulse2_fx_4xy_phase, r28 //store the new phase
00296a 31c0                      	cpi r28, 16
00296b f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_0
00296c 32c0                      	cpi r28, 32
00296d f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_1
00296e 33c0                      	cpi r28, 48
00296f f030                      	brlo sound_driver_channel1_fx_4xy_routine_phase_2
002970 c007                      	rjmp sound_driver_channel1_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_0:
002971 70cf                      	andi r28, 0x0F //mask for values 0-15
002972 c029                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_1:
002973 6fc0                      	ori r28, 0xF0
002974 95c0                      	com r28 //invert values 0-15
002975 c026                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_2:
002976 70cf                      	andi r28, 0x0F //mask for values 0-15
002977 c003                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_3:
002978 6fc0                      	ori r28, 0xF0
002979 95c0                      	com r28 //invert values 0-15
00297a c000                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_add:
00297b 95b2                      	swap r27 //multiply depth by 16
00297c 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
00297d e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00297e e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00297f 0fec                      	add ZL, r28 //offset the table by the depth+phase
002980 1df2                      	adc ZH, zero
002981 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002982 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002983 937f                      	push r23
002984 2f6c                      	mov r22, r28 //store the vibrato value into r22
002985 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002986 9f67                      	mul r22, r23
002987 917f                      	pop r23
002988 916f                      	pop r22
                                 
002989 9416                      	lsr r1 //shift out the fractional bits
00298a 9407                      	ror r0
00298b 9416                      	lsr r1
00298c 9407                      	ror r0
00298d 9416                      	lsr r1
00298e 9407                      	ror r0
00298f 9416                      	lsr r1
002990 9407                      	ror r0
                                 	
002991 91a0 0a9c                 	lds r26, TCB1_CCMPL
002993 91b0 0a9d                 	lds r27, TCB1_CCMPH
002995 0da0                      	add r26, r0
002996 1db1                      	adc r27, r1
002997 93a0 0a9c                 	sts TCB1_CCMPL, r26
002999 93b0 0a9d                 	sts TCB1_CCMPH, r27
00299b c020                      	rjmp sound_driver_channel1_fx_7xy_routine
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_subtract:
00299c 95b2                      	swap r27 //multiply depth by 16
00299d 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
00299e e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00299f e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0029a0 0fec                      	add ZL, r28 //offset the table by the depth+phase
0029a1 1df2                      	adc ZH, zero
0029a2 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
0029a3 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0029a4 937f                      	push r23
0029a5 2f6c                      	mov r22, r28 //store the vibrato value into r22
0029a6 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0029a7 9f67                      	mul r22, r23
0029a8 917f                      	pop r23
0029a9 916f                      	pop r22
                                 
0029aa 9416                      	lsr r1 //shift out the fractional bits
0029ab 9407                      	ror r0
0029ac 9416                      	lsr r1
0029ad 9407                      	ror r0
0029ae 9416                      	lsr r1
0029af 9407                      	ror r0
0029b0 9416                      	lsr r1
0029b1 9407                      	ror r0
                                 
0029b2 91a0 0a9c                 	lds r26, TCB1_CCMPL
0029b4 91b0 0a9d                 	lds r27, TCB1_CCMPH
0029b6 19a0                      	sub r26, r0
0029b7 09b1                      	sbc r27, r1
0029b8 93a0 0a9c                 	sts TCB1_CCMPL, r26
0029ba 93b0 0a9d                 	sts TCB1_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_7xy_routine:
0029bc 91a0 28a9                 	lds r26, pulse2_fx_7xy_speed
0029be 15a2                      	cp r26, zero
0029bf f0f1                      	breq sound_driver_channel1_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
0029c0 91b0 28aa                 	lds r27, pulse2_fx_7xy_depth
0029c2 91c0 28ab                 	lds r28, pulse2_fx_7xy_phase
0029c4 0fca                      	add r28, r26 //increase the phase by the speed
0029c5 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
0029c6 f010                      	brlo sound_driver_channel1_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
0029c7 e0c0                      	ldi r28, 0x00
0029c8 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase:
0029c9 93c0 28ab                 	sts pulse2_fx_7xy_phase, r28 //store the new phase
0029cb 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
0029cc ffc4                      	sbrs r28, 4
0029cd c001                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_0
0029ce c002                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel1_fx_7xy_routine_phase_0:
0029cf 70cf                      	andi r28, 0x0F //mask for values 0-15
0029d0 c003                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase_1:
0029d1 6fc0                      	ori r28, 0xF0
0029d2 95c0                      	com r28 //invert values 0-15
0029d3 c000                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_load:
0029d4 95b2                      	swap r27 //multiply depth by 16
0029d5 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0029d6 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0029d7 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0029d8 0fec                      	add ZL, r28 //offset the table by the depth+phase
0029d9 1df2                      	adc ZH, zero
0029da 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
0029db 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
0029dc 93c0 28ac                 	sts pulse2_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Axy_routine:
0029de 91b0 28ad                 	lds r27, pulse2_fx_Axy
0029e0 15b2                      	cp r27, zero
0029e1 f0e9                      	breq sound_driver_channel1_fx_Qxy_routine //0 means that the effect is not in use
                                 	
0029e2 91a0 280d                 	lds r26, pulse2_fractional_volume //load fractional volume representation of the channel
0029e4 91c0 2808                 	lds r28, pulse2_param //load the integer volume representation of the channel
0029e6 2fda                      	mov r29, r26 //copy fractional volume into r29
0029e7 2fec                      	mov r30, r28 //copy the pulse2_param into r30
0029e8 95e2                      	swap r30
0029e9 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
0029ea 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
0029eb 17ed                      	cp r30, r29 //compare the fractional and integer volumes
0029ec f009                      	breq sound_driver_channel1_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel1_fx_Axy_routine_reload:
0029ed 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate:
0029ee fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
0029ef c004                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_addition:
0029f0 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0029f1 f428                      	brcc sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0029f2 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
0029f3 c003                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_subtraction:
0029f4 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0029f5 f008                      	brcs sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0029f6 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_store:
0029f7 93a0 280d                 	sts pulse2_fractional_volume, r26 //store the new fractional volume
0029f9 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
0029fa 95a2                      	swap r26
0029fb 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
0029fc 2bca                      	or r28, r26 //store the new volume back into pulse2_param
0029fd 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel1_fx_Qxy_routine:
0029ff 91e0 28b2                 	lds ZL, pulse2_fx_Qxy_target
002a01 91f0 28b3                 	lds ZH, pulse2_fx_Qxy_target+1
002a03 9630                      	adiw Z, 0
002a04 f139                      	breq sound_driver_channel1_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002a05 91a0 28b6                 	lds r26, pulse2_fx_Qxy_total_offset
002a07 91b0 28b7                 	lds r27, pulse2_fx_Qxy_total_offset+1
002a09 91c0 0a9c                 	lds r28, TCB1_CCMPL
002a0b 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
002a0d 1bec                      	sub ZL, r28 //calculate the difference to the target
002a0e 0bfd                      	sbc ZH, r29
002a0f f408                      	brsh sound_driver_channel1_fx_Qxy_routine_end //if the target has been reached (or passed)
002a10 f088                      	brlo sound_driver_channel1_fx_Qxy_routine_add
                                 
                                 sound_driver_channel1_fx_Qxy_routine_end:
002a11 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
002a12 0bbf                      	sbc r27, ZH
                                 
002a13 91c0 28b0                 	lds r28, pulse2_fx_Pxx_total
002a15 91d0 28b1                 	lds r29, pulse2_fx_Pxx_total+1
                                 
002a17 0fac                      	add r26, r28
002a18 1fbd                      	adc r27, r29
                                 
002a19 93a0 28b6                 	sts pulse2_fx_Qxy_total_offset, r26 //store the total offset
002a1b 93b0 28b7                 	sts pulse2_fx_Qxy_total_offset+1, r27
002a1d 9220 28b2                 	sts pulse2_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
002a1f 9220 28b3                 	sts pulse2_fx_Qxy_target+1, zero
002a21 c00a                      	rjmp sound_driver_channel1_fx_Rxy_routine
                                 
                                 sound_driver_channel1_fx_Qxy_routine_add:
002a22 91c0 28b4                 	lds r28, pulse2_fx_Qxy_speed
002a24 91d0 28b5                 	lds r29, pulse2_fx_Qxy_speed+1
002a26 0fac                      	add r26, r28 //increase the total offset by the speed
002a27 1fbd                      	adc r27, r29
002a28 93a0 28b6                 	sts pulse2_fx_Qxy_total_offset, r26 //store the total offset
002a2a 93b0 28b7                 	sts pulse2_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Rxy_routine:
002a2c 91e0 28b8                 	lds ZL, pulse2_fx_Rxy_target
002a2e 91f0 28b9                 	lds ZH, pulse2_fx_Rxy_target+1
002a30 9630                      	adiw Z, 0
002a31 f139                      	breq sound_driver_instrument_routine_channel2_volume //if the effect is not enabled, skip the routine
                                 
002a32 91a0 28bc                 	lds r26, pulse2_fx_Rxy_total_offset
002a34 91b0 28bd                 	lds r27, pulse2_fx_Rxy_total_offset+1
002a36 91c0 0a9c                 	lds r28, TCB1_CCMPL
002a38 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
002a3a 1bce                      	sub r28, ZL //calculate the difference to the target
002a3b 0bdf                      	sbc r29, ZH
002a3c f408                      	brsh sound_driver_channel1_fx_Rxy_routine_end //if the target has been reached (or passed)
002a3d f088                      	brlo sound_driver_channel1_fx_Rxy_routine_add
                                 
                                 sound_driver_channel1_fx_Rxy_routine_end:
002a3e 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
002a3f 0bbd                      	sbc r27, r29
                                 
002a40 91c0 28b0                 	lds r28, pulse2_fx_Pxx_total
002a42 91d0 28b1                 	lds r29, pulse2_fx_Pxx_total+1
                                 
002a44 0fac                      	add r26, r28
002a45 1fbd                      	adc r27, r29
                                 
002a46 93a0 28bc                 	sts pulse2_fx_Rxy_total_offset, r26 //store the total offset
002a48 93b0 28bd                 	sts pulse2_fx_Rxy_total_offset+1, r27
002a4a 9220 28b8                 	sts pulse2_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
002a4c 9220 28b9                 	sts pulse2_fx_Rxy_target+1, zero
002a4e c00a                      	rjmp sound_driver_instrument_routine_channel2_volume
                                 
                                 sound_driver_channel1_fx_Rxy_routine_add:
002a4f 91c0 28ba                 	lds r28, pulse2_fx_Rxy_speed
002a51 91d0 28bb                 	lds r29, pulse2_fx_Rxy_speed+1
002a53 0fac                      	add r26, r28 //increase the total offset by the speed
002a54 1fbd                      	adc r27, r29
002a55 93a0 28bc                 	sts pulse2_fx_Rxy_total_offset, r26 //store the total offset
002a57 93b0 28bd                 	sts pulse2_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume:
002a59 91e0 28c6                 	lds ZL, triangle_volume_macro
002a5b 91f0 28c7                 	lds ZH, triangle_volume_macro+1
002a5d 9630                      	adiw Z, 0
002a5e f199                      	breq sound_driver_instrument_routine_channel2_volume_default //if no volume macro is in use, do nothing
002a5f 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002a60 1fff                      	rol ZH
002a61 91a0 28c8                 	lds r26, triangle_volume_macro_offset
002a63 0fea                      	add ZL, r26
002a64 1df2                      	adc ZH, zero
                                 
002a65 91b0 28ca                 	lds r27, triangle_volume_macro_release
002a67 17ba                      	cp r27, r26
002a68 f429                      	brne sound_driver_instrument_routine_channel2_volume_increment //if the current offset is not equal to the release index, increment the offset
002a69 91a0 28c9                 	lds r26, triangle_volume_macro_loop
002a6b 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002a6c f010                      	brlo sound_driver_instrument_routine_channel2_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002a6d c003                      	rjmp sound_driver_instrument_routine_channel2_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_volume_increment:
002a6e 95a3                      	inc r26 //increment the macro offset
002a6f 93a0 28c8                 	sts triangle_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_volume_read:
002a71 91b4                      	lpm r27, Z //load volume data into r27
002a72 3fbf                      	cpi r27, 0xFF //check for macro end flag
002a73 f469                      	brne sound_driver_instrument_routine_channel2_volume_process //if the data was not the macro end flag
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_release:
002a74 91b0 28ca                 	lds r27, triangle_volume_macro_release
002a76 3fbf                      	cpi r27, 0xFF
002a77 f429                      	brne sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_loop:
002a78 91b0 28c9                 	lds r27, triangle_volume_macro_loop //load the loop index
002a7a 93b0 28c8                 	sts triangle_volume_macro_offset, r27 //store the loop index into the offset
002a7c cfdc                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index:
002a7d 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002a7e 93a0 28c8                 	sts triangle_volume_macro_offset, r26
002a80 cfd8                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_process:
002a81 15b2                      	cp r27, zero
002a82 f041                      	breq sound_driver_instrument_routine_channel2_volume_process_disable
                                 sound_driver_instrument_routine_channel2_volume_process_enable:
002a83 91b0 0aa5                 	lds r27, TCB2_INTCTRL
002a85 30b1                      	cpi r27, TCB_CAPT_bm
002a86 f459                      	brne sound_driver_instrument_routine_channel2_volume_default //if the channel has already been muted, don't enable it again
002a87 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
002a88 93b0 0aa5                 	sts TCB2_INTCTRL, r27
002a8a c007                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 sound_driver_instrument_routine_channel2_volume_process_disable:
002a8b 9220 0aa5                 	sts TCB2_INTCTRL, zero
002a8d 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
002a8f 9220 0aad                 	sts TCB2_CCMPH, zero
002a91 c000                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_volume_default:
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002a92 91e0 28cb                 	lds ZL, triangle_arpeggio_macro
002a94 91f0 28cc                 	lds ZH, triangle_arpeggio_macro+1
002a96 9630                      	adiw Z, 0
002a97 f1d9                      	breq sound_driver_instrument_routine_channel2_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002a98 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002a99 1fff                      	rol ZH
002a9a 91a0 28cd                 	lds r26, triangle_arpeggio_macro_offset
002a9c 0fea                      	add ZL, r26
002a9d 1df2                      	adc ZH, zero
                                 
002a9e 91b0 28cf                 	lds r27, triangle_arpeggio_macro_release
002aa0 17ba                      	cp r27, r26
002aa1 f429                      	brne sound_driver_instrument_routine_channel2_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002aa2 91a0 28ce                 	lds r26, triangle_arpeggio_macro_loop
002aa4 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002aa5 f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002aa6 c003                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_increment:
002aa7 95a3                      	inc r26 //increment the macro offset
002aa8 93a0 28cd                 	sts triangle_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_read:
002aaa 91b4                      	lpm r27, Z //load arpeggio data into r27
002aab 38b0                      	cpi r27, 0x80 //check for macro end flag
002aac f009                      	breq sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag
002aad c041                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_check_mode:
002aae 50a1                      	subi r26, 1 //keep the offset at the end flag
002aaf 93a0 28cd                 	sts triangle_arpeggio_macro_offset, r26
002ab1 91b0 28d0                 	lds r27, triangle_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002ab3 30b1                      	cpi r27, 0x01
002ab4 f048                      	brlo sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_release:
002ab5 91b0 28cf                 	lds r27, triangle_arpeggio_macro_release
002ab7 3fbf                      	cpi r27, 0xFF
002ab8 f4d1                      	brne sound_driver_instrument_routine_channel2_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_loop:
002ab9 91b0 28ce                 	lds r27, triangle_arpeggio_macro_loop
002abb 3fbf                      	cpi r27, 0xFF
002abc f499                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002abd c015                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute:
002abe 91b0 28cf                 	lds r27, triangle_arpeggio_macro_release
002ac0 3fbf                      	cpi r27, 0xFF
002ac1 f421                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_check_loop:
002ac2 91b0 28ce                 	lds r27, triangle_arpeggio_macro_loop //load the loop index
002ac4 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002ac5 f451                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop:
002ac6 91c0 28e3                 	lds r28, triangle_fx_0xy_sequence //check for 0xy effect
002ac8 91d0 28e4                 	lds r29, triangle_fx_0xy_sequence+1
002aca 9620                      	adiw r29:r28, 0
002acb f469                      	brne sound_driver_instrument_routine_channel2_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002acc 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002acd 93a0 28cd                 	sts triangle_arpeggio_macro_offset, r26 //store the last valid index into the offset
002acf cfc2                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload:
002ad0 93b0 28cd                 	sts triangle_arpeggio_macro_offset, r27 //store the loop index into the offset
002ad2 cfbf                      	rjmp sound_driver_instrument_routine_channel2_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_default:
002ad3 91c0 28e3                 	lds r28, triangle_fx_0xy_sequence //load 0xy effect
002ad5 91d0 28e4                 	lds r29, triangle_fx_0xy_sequence+1
002ad7 9620                      	adiw r29:r28, 0 //check for 0xy effect
002ad8 f099                      	breq sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel2_arpeggio_default_xy:
002ad9 95d6                      	lsr r29
002ada 95c7                      	ror r28
002adb 95d7                      	ror r29
002adc 95c7                      	ror r28
002add 95d7                      	ror r29
002ade 95c7                      	ror r28
002adf 95d7                      	ror r29
002ae0 95c7                      	ror r28
002ae1 95d7                      	ror r29
002ae2 95d2                      	swap r29
                                 
002ae3 93c0 28e3                 	sts triangle_fx_0xy_sequence, r28 //store the rolled sequence
002ae5 93d0 28e4                 	sts triangle_fx_0xy_sequence+1, r29
002ae7 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002ae8 91a0 2812                 	lds r26, triangle_note //load the current note index
002aea 0fac                      	add r26, r28 //add the note offset
002aeb c02e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002aec 91a0 2812                 	lds r26, triangle_note //load the current note index
002aee c02b                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process:
002aef 9220 28d1                 	sts triangle_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002af1 9220 28d2                 	sts triangle_total_pitch_offset+1, zero
002af3 9220 28d8                 	sts triangle_total_hi_pitch_offset, zero
002af5 91a0 28d0                 	lds r26, triangle_arpeggio_macro_mode
002af7 30a1                      	cpi r26, 0x01 //absolute mode
002af8 f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_absolute
002af9 f069                      	breq sound_driver_instrument_routine_channel2_arpeggio_process_fixed
002afa c00e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute:
002afb 91a0 2812                 	lds r26, triangle_note //load the current note index
002afd 0fab                      	add r26, r27 //offset the note with the arpeggio data
002afe fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002aff c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_add:
002b00 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002b01 f0c0                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
002b02 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002b03 c016                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract:
002b04 fda7                      	sbrc r26, 7 //check if result is negative
002b05 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002b06 c013                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_fixed:
002b07 2fab                      	mov r26, r27 //move the arpeggio data into r26
002b08 c011                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative:
002b09 91a0 2812                 	lds r26, triangle_note //load the current note index
002b0b 0fab                      	add r26, r27 //offset the note with the arpeggio data
002b0c fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002b0d c008                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_add:
002b0e 93a0 2812                 	sts triangle_note, r26 //NOTE: relative mode modifies the original note index
002b10 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002b11 f040                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
002b12 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002b13 93a0 2812                 	sts triangle_note, r26
002b15 c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract:
002b16 fda7                      	sbrc r26, 7 //check if result is negative
002b17 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002b18 93a0 2812                 	sts triangle_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_load:
002b1a e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
002b1b e0f0                      	ldi ZH, HIGH(note_table << 1)
002b1c 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002b1d 0fea                      	add ZL, r26 //add offset
002b1e 1df2                      	adc ZH, zero
002b1f 91a5                      	lpm r26, Z+ //load bytes
002b20 91b4                      	lpm r27, Z
002b21 93a0 0aac                 	sts TCB2_CCMPL, r26 //load the LOW bits for timer
002b23 93b0 0aad                 	sts TCB2_CCMPH, r27 //load the HIGH bits for timer
002b25 93a0 28ef                 	sts triangle_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002b27 93b0 28f0                 	sts triangle_fx_3xx_target+1, r27
002b29 c000                      	rjmp sound_driver_instrument_routine_channel2_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch:
002b2a 91e0 28d3                 	lds ZL, triangle_pitch_macro
002b2c 91f0 28d4                 	lds ZH, triangle_pitch_macro+1
002b2e 9630                      	adiw Z, 0
002b2f f409                      	brne sound_driver_instrument_routine_channel2_pitch_continue
002b30 c023                      	rjmp sound_driver_instrument_routine_channel2_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel2_pitch_continue:
002b31 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002b32 1fff                      	rol ZH
002b33 91a0 28d5                 	lds r26, triangle_pitch_macro_offset
002b35 0fea                      	add ZL, r26
002b36 1df2                      	adc ZH, zero
                                 
002b37 91b0 28d7                 	lds r27, triangle_pitch_macro_release
002b39 17ba                      	cp r27, r26
002b3a f429                      	brne sound_driver_instrument_routine_channel2_pitch_increment //if the current offset is not equal to the release index, increment the offset
002b3b 91a0 28d6                 	lds r26, triangle_pitch_macro_loop
002b3d 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002b3e f010                      	brlo sound_driver_instrument_routine_channel2_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002b3f c003                      	rjmp sound_driver_instrument_routine_channel2_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_pitch_increment:
002b40 95a3                      	inc r26 //increment the macro offset
002b41 93a0 28d5                 	sts triangle_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_pitch_read:
002b43 91b4                      	lpm r27, Z //load pitch data into r27
002b44 38b0                      	cpi r27, 0x80 //check for macro end flag
002b45 f479                      	brne sound_driver_instrument_routine_channel2_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_release:
002b46 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002b47 93a0 28d5                 	sts triangle_pitch_macro_offset, r26
002b49 91b0 28d7                 	lds r27, triangle_pitch_macro_release
002b4b 3fbf                      	cpi r27, 0xFF
002b4c f439                      	brne sound_driver_instrument_routine_channel2_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_loop:
002b4d 91b0 28d6                 	lds r27, triangle_pitch_macro_loop //load the loop index
002b4f 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002b50 f019                      	breq sound_driver_instrument_routine_channel2_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002b51 93b0 28d5                 	sts triangle_pitch_macro_offset, r27 //store the loop index into the offset
002b53 cfd6                      	rjmp sound_driver_instrument_routine_channel2_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_default:
002b54 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel2_pitch_calculate:
002b55 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002b56 937f                      	push r23
002b57 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
002b58 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002b59 0367                      	mulsu r22, r23
002b5a 917f                      	pop r23
002b5b 916f                      	pop r22
                                 
002b5c 9416                      	lsr r1 //shift out the fractional bits
002b5d 9407                      	ror r0
002b5e 9416                      	lsr r1
002b5f 9407                      	ror r0
002b60 9416                      	lsr r1
002b61 9407                      	ror r0
002b62 9416                      	lsr r1
002b63 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_check_negative:
002b64 fe13                      	sbrs r1, 3 //check if result was a negative number
002b65 c007                      	rjmp sound_driver_instrument_routine_channel2_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_negative:
002b66 efc0                      	ldi r28, 0xF0
002b67 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_check_divisible_8:
002b68 70b7                      	andi r27, 0b00000111
002b69 f019                      	breq sound_driver_instrument_routine_channel2_pitch_calculate_offset
                                 
002b6a e0b1                      	ldi r27, 0x01
002b6b 0e0b                      	add r0, r27
002b6c 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_offset:
002b6d 91a0 28d1                 	lds r26, triangle_total_pitch_offset
002b6f 91b0 28d2                 	lds r27, triangle_total_pitch_offset+1
002b71 0e0a                      	add r0, r26
002b72 1e1b                      	adc r1, r27
002b73 9200 28d1                 	sts triangle_total_pitch_offset, r0
002b75 9210 28d2                 	sts triangle_total_pitch_offset+1, r1
002b77 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
002b79 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
002b7b 0da0                      	add r26, r0 //offset the timer values
002b7c 1db1                      	adc r27, r1
                                 	
002b7d 91c0 28e7                 	lds r28, triangle_fx_1xx_total
002b7f 91d0 28e8                 	lds r29, triangle_fx_1xx_total+1
002b81 1bac                      	sub r26, r28
002b82 0bbd                      	sbc r27, r29
002b83 91c0 28eb                 	lds r28, triangle_fx_2xx_total
002b85 91d0 28ec                 	lds r29, triangle_fx_2xx_total+1
002b87 0fac                      	add r26, r28
002b88 1fbd                      	adc r27, r29
002b89 91c0 28fa                 	lds r28, triangle_fx_Pxx_total
002b8b 91d0 28fb                 	lds r29, triangle_fx_Pxx_total+1
002b8d 0fac                      	add r26, r28
002b8e 1fbd                      	adc r27, r29
002b8f 91c0 2900                 	lds r28, triangle_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
002b91 91d0 2901                 	lds r29, triangle_fx_Qxy_total_offset+1
002b93 1bac                      	sub r26, r28
002b94 0bbd                      	sbc r27, r29
002b95 91c0 2906                 	lds r28, triangle_fx_Rxy_total_offset
002b97 91d0 2907                 	lds r29, triangle_fx_Rxy_total_offset+1
002b99 0fac                      	add r26, r28
002b9a 1fbd                      	adc r27, r29
                                 
002b9b 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
002b9d 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel2_hi_pitch:
002b9f 91e0 28d9                 	lds ZL, triangle_hi_pitch_macro
002ba1 91f0 28da                 	lds ZH, triangle_hi_pitch_macro+1
002ba3 9630                      	adiw Z, 0
002ba4 f409                      	brne sound_driver_instrument_routine_channel2_hi_pitch_continue
002ba5 c03c                      	rjmp sound_driver_instrument_routine_channel2_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel2_hi_pitch_continue:
002ba6 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002ba7 1fff                      	rol ZH
002ba8 91a0 28db                 	lds r26, triangle_hi_pitch_macro_offset
002baa 0fea                      	add ZL, r26
002bab 1df2                      	adc ZH, zero
                                 
002bac 91b0 28dd                 	lds r27, triangle_hi_pitch_macro_release
002bae 17ba                      	cp r27, r26
002baf f429                      	brne sound_driver_instrument_routine_channel2_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002bb0 91a0 28dc                 	lds r26, triangle_hi_pitch_macro_loop
002bb2 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002bb3 f010                      	brlo sound_driver_instrument_routine_channel2_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002bb4 c003                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_increment:
002bb5 95a3                      	inc r26 //increment the macro offset
002bb6 93a0 28db                 	sts triangle_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_hi_pitch_read:
002bb8 91b4                      	lpm r27, Z //load hi pitch data into r27
002bb9 38b0                      	cpi r27, 0x80 //check for macro end flag
002bba f489                      	brne sound_driver_instrument_routine_channel2_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_release:
002bbb 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002bbc 93a0 28db                 	sts triangle_hi_pitch_macro_offset, r26
002bbe 91b0 28dd                 	lds r27, triangle_hi_pitch_macro_release
002bc0 3fbf                      	cpi r27, 0xFF
002bc1 f439                      	brne sound_driver_instrument_routine_channel2_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_loop:
002bc2 91b0 28dc                 	lds r27, triangle_hi_pitch_macro_loop //load the loop index
002bc4 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002bc5 f019                      	breq sound_driver_instrument_routine_channel2_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002bc6 93b0 28db                 	sts triangle_hi_pitch_macro_offset, r27 //store the loop index into the offset
002bc8 cfd6                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_default:
002bc9 91b0 28d8                 	lds r27, triangle_total_hi_pitch_offset
002bcb c005                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate:
002bcc 91a0 28d8                 	lds r26, triangle_total_hi_pitch_offset //load the total hi pitch offset to change
002bce 0fba                      	add r27, r26
002bcf 93b0 28d8                 	sts triangle_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply:
002bd1 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002bd2 937f                      	push r23
002bd3 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002bd4 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002bd5 0367                      	mulsu r22, r23
002bd6 917f                      	pop r23
002bd7 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_offset:
002bd8 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
002bda 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
002bdc 0da0                      	add r26, r0 //offset the timer values
002bdd 1db1                      	adc r27, r1
002bde 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
002be0 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: The triangle channel does not have a duty cycle
                                 sound_driver_instrument_routine_channel2_duty:
                                 
                                 
                                 
                                 sound_driver_channel2_fx_routines:
                                 sound_driver_channel2_fx_1xx_routine:
002be2 91e0 28e5                 	lds ZL, triangle_fx_1xx
002be4 91f0 28e6                 	lds ZH, triangle_fx_1xx+1
002be6 9630                      	adiw Z, 0
002be7 f051                      	breq sound_driver_channel2_fx_2xx_routine
                                 
002be8 91a0 28e7                 	lds r26, triangle_fx_1xx_total //load the rate to change the pitch by
002bea 91b0 28e8                 	lds r27, triangle_fx_1xx_total+1
002bec 0fae                      	add r26, ZL //increase the total offset by the rate
002bed 1fbf                      	adc r27, ZH
002bee 93a0 28e7                 	sts triangle_fx_1xx_total, r26
002bf0 93b0 28e8                 	sts triangle_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_2xx_routine:
002bf2 91e0 28e9                 	lds ZL, triangle_fx_2xx
002bf4 91f0 28ea                 	lds ZH, triangle_fx_2xx+1
002bf6 9630                      	adiw Z, 0
002bf7 f051                      	breq sound_driver_channel2_fx_3xx_routine
                                 
002bf8 91a0 28eb                 	lds r26, triangle_fx_2xx_total //load the rate to change the pitch by
002bfa 91b0 28ec                 	lds r27, triangle_fx_2xx_total+1
002bfc 0fae                      	add r26, ZL //increase the total offset by the rate
002bfd 1fbf                      	adc r27, ZH
002bfe 93a0 28eb                 	sts triangle_fx_2xx_total, r26
002c00 93b0 28ec                 	sts triangle_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_3xx_routine:
002c02 91e0 28f1                 	lds ZL, triangle_fx_3xx_speed
002c04 91f0 28f2                 	lds ZH, triangle_fx_3xx_speed+1
002c06 9630                      	adiw Z, 0
002c07 f409                      	brne sound_driver_channel2_fx_3xx_routine_check_start
002c08 c048                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_check_start:
002c09 91a0 28ed                 	lds r26, triangle_fx_3xx_start
002c0b 91b0 28ee                 	lds r27, triangle_fx_3xx_start+1
002c0d 9610                      	adiw r26:r27, 0
002c0e f409                      	brne sound_driver_channel2_fx_3xx_routine_main
002c0f c041                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_main:
002c10 91c0 28ef                 	lds r28, triangle_fx_3xx_target
002c12 91d0 28f0                 	lds r29, triangle_fx_3xx_target+1
                                 
002c14 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
002c15 07bd                      	cpc r27, r29
002c16 f011                      	breq sound_driver_channel2_fx_3xx_routine_disable
002c17 f030                      	brlo sound_driver_channel2_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002c18 c01f                      	rjmp sound_driver_channel2_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel2_fx_3xx_routine_disable:
002c19 9220 28ed                 	sts triangle_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002c1b 9220 28ee                 	sts triangle_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002c1d c033                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_subtract:
002c1e 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002c1f 0bdb                      	sbc r29, r27
002c20 91a0 28f3                 	lds r26, triangle_fx_3xx_total_offset
002c22 91b0 28f4                 	lds r27, triangle_fx_3xx_total_offset+1
                                 
002c24 0fae                      	add r26, ZL //add the speed to the total offset
002c25 1fbf                      	adc r27, ZH
002c26 1bca                      	sub r28, r26 //invert the total difference with the total offset
002c27 0bdb                      	sbc r29, r27
002c28 f380                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002c29 93a0 28f3                 	sts triangle_fx_3xx_total_offset, r26 //store the new total offset
002c2b 93b0 28f4                 	sts triangle_fx_3xx_total_offset+1, r27
                                 
002c2d 91a0 0aac                 	lds r26, TCB2_CCMPL //load the current timer period
002c2f 91b0 0aad                 	lds r27, TCB2_CCMPH
002c31 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002c32 0bbd                      	sbc r27, r29
002c33 93a0 0aac                 	sts TCB2_CCMPL, r26
002c35 93b0 0aad                 	sts TCB2_CCMPH, r27
002c37 c019                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_add:
002c38 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002c39 0bbd                      	sbc r27, r29
002c3a 91c0 28f3                 	lds r28, triangle_fx_3xx_total_offset
002c3c 91d0 28f4                 	lds r29, triangle_fx_3xx_total_offset+1
                                 
002c3e 0fce                      	add r28, ZL //add the speed to the total offset
002c3f 1fdf                      	adc r29, ZH
002c40 1bac                      	sub r26, r28 //invert the total difference with the total offset
002c41 0bbd                      	sbc r27, r29
002c42 f2b0                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002c43 93c0 28f3                 	sts triangle_fx_3xx_total_offset, r28 //store the new total offset
002c45 93d0 28f4                 	sts triangle_fx_3xx_total_offset+1, r29
                                 
002c47 91c0 0aac                 	lds r28, TCB2_CCMPL //load the current timer period
002c49 91d0 0aad                 	lds r29, TCB2_CCMPH
002c4b 0fca                      	add r28, r26 //offset the current timer period with the total offset
002c4c 1fdb                      	adc r29, r27
002c4d 93c0 0aac                 	sts TCB2_CCMPL, r28
002c4f 93d0 0aad                 	sts TCB2_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel2_fx_4xy_routine:
002c51 91a0 28f5                 	lds r26, triangle_fx_4xy_speed
002c53 15a2                      	cp r26, zero
002c54 f409                      	brne sound_driver_channel2_fx_4xy_routine_continue
002c55 c05c                      	rjmp sound_driver_channel2_fx_Qxy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel2_fx_4xy_routine_continue:
002c56 91b0 28f6                 	lds r27, triangle_fx_4xy_depth
002c58 91c0 28f7                 	lds r28, triangle_fx_4xy_phase
002c5a 0fca                      	add r28, r26 //increase the phase by the speed
002c5b 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
002c5c f008                      	brlo sound_driver_channel2_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002c5d 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase:
002c5e 93c0 28f7                 	sts triangle_fx_4xy_phase, r28 //store the new phase
002c60 31c0                      	cpi r28, 16
002c61 f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_0
002c62 32c0                      	cpi r28, 32
002c63 f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_1
002c64 33c0                      	cpi r28, 48
002c65 f030                      	brlo sound_driver_channel2_fx_4xy_routine_phase_2
002c66 c007                      	rjmp sound_driver_channel2_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_0:
002c67 70cf                      	andi r28, 0x0F //mask for values 0-15
002c68 c029                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_1:
002c69 6fc0                      	ori r28, 0xF0
002c6a 95c0                      	com r28 //invert values 0-15
002c6b c026                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_2:
002c6c 70cf                      	andi r28, 0x0F //mask for values 0-15
002c6d c003                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_3:
002c6e 6fc0                      	ori r28, 0xF0
002c6f 95c0                      	com r28 //invert values 0-15
002c70 c000                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_add:
002c71 95b2                      	swap r27 //multiply depth by 16
002c72 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002c73 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002c74 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002c75 0fec                      	add ZL, r28 //offset the table by the depth+phase
002c76 1df2                      	adc ZH, zero
002c77 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002c78 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002c79 937f                      	push r23
002c7a 2f6c                      	mov r22, r28 //store the vibrato value into r22
002c7b eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002c7c 9f67                      	mul r22, r23
002c7d 917f                      	pop r23
002c7e 916f                      	pop r22
                                 
002c7f 9416                      	lsr r1 //shift out the fractional bits
002c80 9407                      	ror r0
002c81 9416                      	lsr r1
002c82 9407                      	ror r0
002c83 9416                      	lsr r1
002c84 9407                      	ror r0
002c85 9416                      	lsr r1
002c86 9407                      	ror r0
                                 	
002c87 91a0 0aac                 	lds r26, TCB2_CCMPL
002c89 91b0 0aad                 	lds r27, TCB2_CCMPH
002c8b 0da0                      	add r26, r0
002c8c 1db1                      	adc r27, r1
002c8d 93a0 0aac                 	sts TCB2_CCMPL, r26
002c8f 93b0 0aad                 	sts TCB2_CCMPH, r27
002c91 c020                      	rjmp sound_driver_channel2_fx_Qxy_routine
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_subtract:
002c92 95b2                      	swap r27 //multiply depth by 16
002c93 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002c94 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002c95 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002c96 0fec                      	add ZL, r28 //offset the table by the depth+phase
002c97 1df2                      	adc ZH, zero
002c98 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002c99 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002c9a 937f                      	push r23
002c9b 2f6c                      	mov r22, r28 //store the vibrato value into r22
002c9c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002c9d 9f67                      	mul r22, r23
002c9e 917f                      	pop r23
002c9f 916f                      	pop r22
                                 
002ca0 9416                      	lsr r1 //shift out the fractional bits
002ca1 9407                      	ror r0
002ca2 9416                      	lsr r1
002ca3 9407                      	ror r0
002ca4 9416                      	lsr r1
002ca5 9407                      	ror r0
002ca6 9416                      	lsr r1
002ca7 9407                      	ror r0
                                 
002ca8 91a0 0aac                 	lds r26, TCB2_CCMPL
002caa 91b0 0aad                 	lds r27, TCB2_CCMPH
002cac 19a0                      	sub r26, r0
002cad 09b1                      	sbc r27, r1
002cae 93a0 0aac                 	sts TCB2_CCMPL, r26
002cb0 93b0 0aad                 	sts TCB2_CCMPH, r27
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel2_fx_Qxy_routine:
002cb2 91e0 28fc                 	lds ZL, triangle_fx_Qxy_target
002cb4 91f0 28fd                 	lds ZH, triangle_fx_Qxy_target+1
002cb6 9630                      	adiw Z, 0
002cb7 f139                      	breq sound_driver_channel2_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002cb8 91a0 2900                 	lds r26, triangle_fx_Qxy_total_offset
002cba 91b0 2901                 	lds r27, triangle_fx_Qxy_total_offset+1
002cbc 91c0 0aac                 	lds r28, TCB2_CCMPL
002cbe 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
002cc0 1bec                      	sub ZL, r28 //calculate the difference to the target
002cc1 0bfd                      	sbc ZH, r29
002cc2 f408                      	brsh sound_driver_channel2_fx_Qxy_routine_end //if the target has been reached (or passed)
002cc3 f088                      	brlo sound_driver_channel2_fx_Qxy_routine_add
                                 
                                 sound_driver_channel2_fx_Qxy_routine_end:
002cc4 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
002cc5 0bbf                      	sbc r27, ZH
                                 
002cc6 91c0 28fa                 	lds r28, triangle_fx_Pxx_total
002cc8 91d0 28fb                 	lds r29, triangle_fx_Pxx_total+1
                                 
002cca 0fac                      	add r26, r28
002ccb 1fbd                      	adc r27, r29
                                 
002ccc 93a0 2900                 	sts triangle_fx_Qxy_total_offset, r26 //store the total offset
002cce 93b0 2901                 	sts triangle_fx_Qxy_total_offset+1, r27
002cd0 9220 28fc                 	sts triangle_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
002cd2 9220 28fd                 	sts triangle_fx_Qxy_target+1, zero
002cd4 c00a                      	rjmp sound_driver_channel2_fx_Rxy_routine
                                 
                                 sound_driver_channel2_fx_Qxy_routine_add:
002cd5 91c0 28fe                 	lds r28, triangle_fx_Qxy_speed
002cd7 91d0 28ff                 	lds r29, triangle_fx_Qxy_speed+1
002cd9 0fac                      	add r26, r28 //increase the total offset by the speed
002cda 1fbd                      	adc r27, r29
002cdb 93a0 2900                 	sts triangle_fx_Qxy_total_offset, r26 //store the total offset
002cdd 93b0 2901                 	sts triangle_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_Rxy_routine:
002cdf 91e0 2902                 	lds ZL, triangle_fx_Rxy_target
002ce1 91f0 2903                 	lds ZH, triangle_fx_Rxy_target+1
002ce3 9630                      	adiw Z, 0
002ce4 f139                      	breq sound_driver_instrument_routine_channel3_volume //if the effect is not enabled, skip the routine
                                 
002ce5 91a0 2906                 	lds r26, triangle_fx_Rxy_total_offset
002ce7 91b0 2907                 	lds r27, triangle_fx_Rxy_total_offset+1
002ce9 91c0 0aac                 	lds r28, TCB2_CCMPL
002ceb 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
002ced 1bce                      	sub r28, ZL //calculate the difference to the target
002cee 0bdf                      	sbc r29, ZH
002cef f408                      	brsh sound_driver_channel2_fx_Rxy_routine_end //if the target has been reached (or passed)
002cf0 f088                      	brlo sound_driver_channel2_fx_Rxy_routine_add
                                 
                                 sound_driver_channel2_fx_Rxy_routine_end:
002cf1 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
002cf2 0bbd                      	sbc r27, r29
                                 
002cf3 91c0 28fa                 	lds r28, triangle_fx_Pxx_total
002cf5 91d0 28fb                 	lds r29, triangle_fx_Pxx_total+1
                                 
002cf7 0fac                      	add r26, r28
002cf8 1fbd                      	adc r27, r29
                                 
002cf9 93a0 2906                 	sts triangle_fx_Rxy_total_offset, r26 //store the total offset
002cfb 93b0 2907                 	sts triangle_fx_Rxy_total_offset+1, r27
002cfd 9220 2902                 	sts triangle_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
002cff 9220 2903                 	sts triangle_fx_Rxy_target+1, zero
002d01 c00a                      	rjmp sound_driver_instrument_routine_channel3_volume
                                 
                                 sound_driver_channel2_fx_Rxy_routine_add:
002d02 91c0 2904                 	lds r28, triangle_fx_Rxy_speed
002d04 91d0 2905                 	lds r29, triangle_fx_Rxy_speed+1
002d06 0fac                      	add r26, r28 //increase the total offset by the speed
002d07 1fbd                      	adc r27, r29
002d08 93a0 2906                 	sts triangle_fx_Rxy_total_offset, r26 //store the total offset
002d0a 93b0 2907                 	sts triangle_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume:
002d0c 91e0 2910                 	lds ZL, noise_volume_macro
002d0e 91f0 2911                 	lds ZH, noise_volume_macro+1
002d10 9630                      	adiw Z, 0
002d11 f1a1                      	breq sound_driver_instrument_routine_channel3_volume_default //if no volume macro is in use, use default multiplier of F
002d12 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002d13 1fff                      	rol ZH
002d14 91a0 2912                 	lds r26, noise_volume_macro_offset
002d16 0fea                      	add ZL, r26
002d17 1df2                      	adc ZH, zero
                                 
002d18 91b0 2914                 	lds r27, noise_volume_macro_release
002d1a 17ba                      	cp r27, r26
002d1b f429                      	brne sound_driver_instrument_routine_channel3_volume_increment //if the current offset is not equal to the release index, increment the offset
002d1c 91a0 2913                 	lds r26, noise_volume_macro_loop
002d1e 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002d1f f010                      	brlo sound_driver_instrument_routine_channel3_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002d20 c003                      	rjmp sound_driver_instrument_routine_channel3_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_volume_increment:
002d21 95a3                      	inc r26 //increment the macro offset
002d22 93a0 2912                 	sts noise_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_volume_read:
002d24 91b4                      	lpm r27, Z //load volume data into r27
002d25 3fbf                      	cpi r27, 0xFF //check for macro end flag
002d26 f469                      	brne sound_driver_instrument_routine_channel3_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_check_release:
002d27 91b0 2914                 	lds r27, noise_volume_macro_release
002d29 3fbf                      	cpi r27, 0xFF
002d2a f429                      	brne sound_driver_instrument_routine_channel3_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_check_loop:
002d2b 91b0 2913                 	lds r27, noise_volume_macro_loop //load the loop index
002d2d 93b0 2912                 	sts noise_volume_macro_offset, r27 //store the loop index into the offset
002d2f cfdc                      	rjmp sound_driver_instrument_routine_channel3_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_last_index:
002d30 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002d31 93a0 2912                 	sts noise_volume_macro_offset, r26
002d33 cfd8                      	rjmp sound_driver_instrument_routine_channel3_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume_calculate:
002d34 ebe4                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
002d35 e6f1                      	ldi ZH, HIGH(volumes << 1)
002d36 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
002d37 0feb                      	add ZL, r27 //add offset to the table
002d38 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel3_volume_load:
002d39 91b0 2813                 	lds r27, noise_param //load main volume
002d3b 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002d3c 91a0 2945                 	lds r26, noise_fx_7xy_value
002d3e 30a0                      	cpi r26, 0x00
002d3f f481                      	brne sound_driver_instrument_routine_channel3_volume_load_7xy
                                 
002d40 0feb                      	add ZL, r27 //offset the volume table by the main volume
002d41 1df2                      	adc ZH, zero
002d42 91b4                      	lpm r27, Z
002d43 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002d45 c024                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_default:
002d46 91b0 2813                 	lds r27, noise_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
002d48 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002d49 91a0 2945                 	lds r26, noise_fx_7xy_value
002d4b 30a0                      	cpi r26, 0x00
002d4c f4a1                      	brne sound_driver_instrument_routine_channel3_volume_default_7xy
002d4d 93b0 2816                 	sts noise_output_volume, r27
002d4f c01a                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_load_7xy:
002d50 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002d51 f040                      	brcs sound_driver_instrument_routine_channel3_volume_load_7xy_overflow
002d52 f039                      	breq sound_driver_instrument_routine_channel3_volume_load_7xy_overflow
002d53 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
                                 
002d54 0feb                      	add ZL, r27 //offset the volume table by the main volume
002d55 1df2                      	adc ZH, zero
002d56 91b4                      	lpm r27, Z
002d57 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002d59 c010                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_load_7xy_overflow:
002d5a e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002d5b 0feb                      	add ZL, r27 //offset the volume table by the main volume
002d5c 1df2                      	adc ZH, zero
002d5d 91b4                      	lpm r27, Z
002d5e 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002d60 c009                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_default_7xy:
002d61 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002d62 f020                      	brcs sound_driver_instrument_routine_channel3_volume_default_7xy_overflow
002d63 f019                      	breq sound_driver_instrument_routine_channel3_volume_default_7xy_overflow
002d64 93b0 2816                 	sts noise_output_volume, r27
002d66 c003                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel3_volume_default_7xy_overflow:
002d67 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002d68 93b0 2816                 	sts noise_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002d6a 91e0 2915                 	lds ZL, noise_arpeggio_macro
002d6c 91f0 2916                 	lds ZH, noise_arpeggio_macro+1
002d6e 9630                      	adiw Z, 0
002d6f f1d9                      	breq sound_driver_instrument_routine_channel3_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002d70 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002d71 1fff                      	rol ZH
002d72 91a0 2917                 	lds r26, noise_arpeggio_macro_offset
002d74 0fea                      	add ZL, r26
002d75 1df2                      	adc ZH, zero
                                 
002d76 91b0 2919                 	lds r27, noise_arpeggio_macro_release
002d78 17ba                      	cp r27, r26
002d79 f429                      	brne sound_driver_instrument_routine_channel3_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002d7a 91a0 2918                 	lds r26, noise_arpeggio_macro_loop
002d7c 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002d7d f010                      	brlo sound_driver_instrument_routine_channel3_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002d7e c003                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_increment:
002d7f 95a3                      	inc r26 //increment the macro offset
002d80 93a0 2917                 	sts noise_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_arpeggio_read:
002d82 91b4                      	lpm r27, Z //load arpeggio data into r27
002d83 38b0                      	cpi r27, 0x80 //check for macro end flag
002d84 f009                      	breq sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag
002d85 c041                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_check_mode:
002d86 50a1                      	subi r26, 1 //keep the offset at the end flag
002d87 93a0 2917                 	sts noise_arpeggio_macro_offset, r26
002d89 91b0 291a                 	lds r27, noise_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002d8b 30b1                      	cpi r27, 0x01
002d8c f048                      	brlo sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_fixed_relative_check_release:
002d8d 91b0 2919                 	lds r27, noise_arpeggio_macro_release
002d8f 3fbf                      	cpi r27, 0xFF
002d90 f4d1                      	brne sound_driver_instrument_routine_channel3_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_fixed_relative_check_loop:
002d91 91b0 2918                 	lds r27, noise_arpeggio_macro_loop
002d93 3fbf                      	cpi r27, 0xFF
002d94 f499                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002d95 c015                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute:
002d96 91b0 2919                 	lds r27, noise_arpeggio_macro_release
002d98 3fbf                      	cpi r27, 0xFF
002d99 f421                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_check_loop:
002d9a 91b0 2918                 	lds r27, noise_arpeggio_macro_loop //load the loop index
002d9c 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002d9d f451                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_no_loop:
002d9e 91c0 292d                 	lds r28, noise_fx_0xy_sequence //check for 0xy effect
002da0 91d0 292e                 	lds r29, noise_fx_0xy_sequence+1
002da2 9620                      	adiw r29:r28, 0
002da3 f469                      	brne sound_driver_instrument_routine_channel3_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002da4 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002da5 93a0 2917                 	sts noise_arpeggio_macro_offset, r26 //store the last valid index into the offset
002da7 cfc2                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload:
002da8 93b0 2917                 	sts noise_arpeggio_macro_offset, r27 //store the loop index into the offset
002daa cfbf                      	rjmp sound_driver_instrument_routine_channel3_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_default:
002dab 91c0 292d                 	lds r28, noise_fx_0xy_sequence //load 0xy effect
002dad 91d0 292e                 	lds r29, noise_fx_0xy_sequence+1
002daf 9620                      	adiw r29:r28, 0 //check for 0xy effect
002db0 f099                      	breq sound_driver_instrument_routine_channel3_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel3_arpeggio_default_xy:
002db1 95d6                      	lsr r29
002db2 95c7                      	ror r28
002db3 95d7                      	ror r29
002db4 95c7                      	ror r28
002db5 95d7                      	ror r29
002db6 95c7                      	ror r28
002db7 95d7                      	ror r29
002db8 95c7                      	ror r28
002db9 95d7                      	ror r29
002dba 95d2                      	swap r29
                                 
002dbb 93c0 292d                 	sts noise_fx_0xy_sequence, r28 //store the rolled sequence
002dbd 93d0 292e                 	sts noise_fx_0xy_sequence+1, r29
002dbf 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002dc0 91a0 2817                 	lds r26, noise_note //load the current note index
002dc2 0fac                      	add r26, r28 //add the note offset
002dc3 c02e                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel3_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002dc4 91a0 2817                 	lds r26, noise_note //load the current note index
002dc6 c02b                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process:
002dc7 9220 291b                 	sts noise_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002dc9 9220 291c                 	sts noise_total_pitch_offset+1, zero
002dcb 9220 2922                 	sts noise_total_hi_pitch_offset, zero
002dcd 91a0 291a                 	lds r26, noise_arpeggio_macro_mode
002dcf 30a1                      	cpi r26, 0x01 //absolute mode
002dd0 f010                      	brlo sound_driver_instrument_routine_channel3_arpeggio_process_absolute
002dd1 f069                      	breq sound_driver_instrument_routine_channel3_arpeggio_process_fixed
002dd2 c00e                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_absolute:
002dd3 91a0 2817                 	lds r26, noise_note //load the current note index
002dd5 0fab                      	add r26, r27 //offset the note with the arpeggio data
002dd6 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002dd7 c004                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_absolute_add:
002dd8 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002dd9 f0c0                      	brlo sound_driver_instrument_routine_channel3_arpeggio_process_load //if the result is valid, go load the new note
002dda e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002ddb c016                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_absolute_subtract:
002ddc fda7                      	sbrc r26, 7 //check if result is negative
002ddd e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002dde c013                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_fixed:
002ddf 2fab                      	mov r26, r27 //move the arpeggio data into r26
002de0 c011                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_relative:
002de1 91a0 2817                 	lds r26, noise_note //load the current note index
002de3 0fab                      	add r26, r27 //offset the note with the arpeggio data
002de4 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002de5 c008                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_relative_add:
002de6 93a0 2817                 	sts noise_note, r26 //NOTE: relative mode modifies the original note index
002de8 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002de9 f040                      	brlo sound_driver_instrument_routine_channel3_arpeggio_process_load //if the result is valid, go load the new note
002dea e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002deb 93a0 2817                 	sts noise_note, r26
002ded c004                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_relative_subtract:
002dee fda7                      	sbrc r26, 7 //check if result is negative
002def e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002df0 93a0 2817                 	sts noise_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_load:
002df2 e4e2                      	ldi ZL, LOW(noise_period_table << 1) //load in note table
002df3 e0f1                      	ldi ZH, HIGH(noise_period_table << 1)
002df4 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002df5 0fea                      	add ZL, r26 //add offset
002df6 1df2                      	adc ZH, zero
002df7 91a5                      	lpm r26, Z+ //load bytes
002df8 91b4                      	lpm r27, Z
002df9 93a0 0abc                 	sts TCB3_CCMPL, r26 //load the LOW bits for timer
002dfb 93b0 0abd                 	sts TCB3_CCMPH, r27 //load the HIGH bits for timer
002dfd 93a0 2939                 	sts noise_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002dff 93b0 293a                 	sts noise_fx_3xx_target+1, r27
002e01 c000                      	rjmp sound_driver_instrument_routine_channel3_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch:
002e02 91e0 291d                 	lds ZL, noise_pitch_macro
002e04 91f0 291e                 	lds ZH, noise_pitch_macro+1
002e06 9630                      	adiw Z, 0
002e07 f409                      	brne sound_driver_instrument_routine_channel3_pitch_continue
002e08 c023                      	rjmp sound_driver_instrument_routine_channel3_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel3_pitch_continue:
002e09 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002e0a 1fff                      	rol ZH
002e0b 91a0 291f                 	lds r26, noise_pitch_macro_offset
002e0d 0fea                      	add ZL, r26
002e0e 1df2                      	adc ZH, zero
                                 
002e0f 91b0 2921                 	lds r27, noise_pitch_macro_release
002e11 17ba                      	cp r27, r26
002e12 f429                      	brne sound_driver_instrument_routine_channel3_pitch_increment //if the current offset is not equal to the release index, increment the offset
002e13 91a0 2920                 	lds r26, noise_pitch_macro_loop
002e15 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002e16 f010                      	brlo sound_driver_instrument_routine_channel3_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002e17 c003                      	rjmp sound_driver_instrument_routine_channel3_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_pitch_increment:
002e18 95a3                      	inc r26 //increment the macro offset
002e19 93a0 291f                 	sts noise_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_pitch_read:
002e1b 91b4                      	lpm r27, Z //load pitch data into r27
002e1c 38b0                      	cpi r27, 0x80 //check for macro end flag
002e1d f479                      	brne sound_driver_instrument_routine_channel3_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag_check_release:
002e1e 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002e1f 93a0 291f                 	sts noise_pitch_macro_offset, r26
002e21 91b0 2921                 	lds r27, noise_pitch_macro_release
002e23 3fbf                      	cpi r27, 0xFF
002e24 f439                      	brne sound_driver_instrument_routine_channel3_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag_check_loop:
002e25 91b0 2920                 	lds r27, noise_pitch_macro_loop //load the loop index
002e27 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002e28 f019                      	breq sound_driver_instrument_routine_channel3_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002e29 93b0 291f                 	sts noise_pitch_macro_offset, r27 //store the loop index into the offset
002e2b cfd6                      	rjmp sound_driver_instrument_routine_channel3_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch_default:
002e2c e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel3_pitch_calculate:
002e2d 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002e2e 937f                      	push r23
002e2f 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
002e30 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002e31 0367                      	mulsu r22, r23
002e32 917f                      	pop r23
002e33 916f                      	pop r22
                                 
002e34 9416                      	lsr r1 //shift out the fractional bits
002e35 9407                      	ror r0
002e36 9416                      	lsr r1
002e37 9407                      	ror r0
002e38 9416                      	lsr r1
002e39 9407                      	ror r0
002e3a 9416                      	lsr r1
002e3b 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel3_pitch_calculate_check_negative:
002e3c fe13                      	sbrs r1, 3 //check if result was a negative number
002e3d c007                      	rjmp sound_driver_instrument_routine_channel3_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel3_pitch_calculate_negative:
002e3e efc0                      	ldi r28, 0xF0
002e3f 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel3_pitch_calculate_check_divisible_8:
002e40 70b7                      	andi r27, 0b00000111
002e41 f019                      	breq sound_driver_instrument_routine_channel3_pitch_calculate_offset
                                 
002e42 e0b1                      	ldi r27, 0x01
002e43 0e0b                      	add r0, r27
002e44 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel3_pitch_calculate_offset:
002e45 91a0 291b                 	lds r26, noise_total_pitch_offset
002e47 91b0 291c                 	lds r27, noise_total_pitch_offset+1
002e49 0e0a                      	add r0, r26
002e4a 1e1b                      	adc r1, r27
002e4b 9200 291b                 	sts noise_total_pitch_offset, r0
002e4d 9210 291c                 	sts noise_total_pitch_offset+1, r1
002e4f 91a0 0abc                 	lds r26, TCB3_CCMPL //load the low bits for timer
002e51 91b0 0abd                 	lds r27, TCB3_CCMPH //load the high bits for timer
002e53 0da0                      	add r26, r0 //offset the timer values
002e54 1db1                      	adc r27, r1
                                 	
002e55 91c0 2931                 	lds r28, noise_fx_1xx_total
002e57 91d0 2932                 	lds r29, noise_fx_1xx_total+1
002e59 1bac                      	sub r26, r28
002e5a 0bbd                      	sbc r27, r29
002e5b 91c0 2935                 	lds r28, noise_fx_2xx_total
002e5d 91d0 2936                 	lds r29, noise_fx_2xx_total+1
002e5f 0fac                      	add r26, r28
002e60 1fbd                      	adc r27, r29
002e61 91c0 2949                 	lds r28, noise_fx_Pxx_total
002e63 91d0 294a                 	lds r29, noise_fx_Pxx_total+1
002e65 0fac                      	add r26, r28
002e66 1fbd                      	adc r27, r29
002e67 91c0 294f                 	lds r28, noise_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
002e69 91d0 2950                 	lds r29, noise_fx_Qxy_total_offset+1
002e6b 1bac                      	sub r26, r28
002e6c 0bbd                      	sbc r27, r29
002e6d 91c0 2955                 	lds r28, noise_fx_Rxy_total_offset
002e6f 91d0 2956                 	lds r29, noise_fx_Rxy_total_offset+1
002e71 0fac                      	add r26, r28
002e72 1fbd                      	adc r27, r29
                                 
002e73 93a0 0abc                 	sts TCB3_CCMPL, r26 //store the new low bits for timer
002e75 93b0 0abd                 	sts TCB3_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel3_hi_pitch:
002e77 91e0 2923                 	lds ZL, noise_hi_pitch_macro
002e79 91f0 2924                 	lds ZH, noise_hi_pitch_macro+1
002e7b 9630                      	adiw Z, 0
002e7c f409                      	brne sound_driver_instrument_routine_channel3_hi_pitch_continue
002e7d c03c                      	rjmp sound_driver_instrument_routine_channel3_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel3_hi_pitch_continue:
002e7e 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002e7f 1fff                      	rol ZH
002e80 91a0 2925                 	lds r26, noise_hi_pitch_macro_offset
002e82 0fea                      	add ZL, r26
002e83 1df2                      	adc ZH, zero
                                 
002e84 91b0 2927                 	lds r27, noise_hi_pitch_macro_release
002e86 17ba                      	cp r27, r26
002e87 f429                      	brne sound_driver_instrument_routine_channel3_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002e88 91a0 2926                 	lds r26, noise_hi_pitch_macro_loop
002e8a 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002e8b f010                      	brlo sound_driver_instrument_routine_channel3_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002e8c c003                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_increment:
002e8d 95a3                      	inc r26 //increment the macro offset
002e8e 93a0 2925                 	sts noise_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_hi_pitch_read:
002e90 91b4                      	lpm r27, Z //load hi pitch data into r27
002e91 38b0                      	cpi r27, 0x80 //check for macro end flag
002e92 f489                      	brne sound_driver_instrument_routine_channel3_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag_check_release:
002e93 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002e94 93a0 2925                 	sts noise_hi_pitch_macro_offset, r26
002e96 91b0 2927                 	lds r27, noise_hi_pitch_macro_release
002e98 3fbf                      	cpi r27, 0xFF
002e99 f439                      	brne sound_driver_instrument_routine_channel3_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag_check_loop:
002e9a 91b0 2926                 	lds r27, noise_hi_pitch_macro_loop //load the loop index
002e9c 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002e9d f019                      	breq sound_driver_instrument_routine_channel3_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002e9e 93b0 2925                 	sts noise_hi_pitch_macro_offset, r27 //store the loop index into the offset
002ea0 cfd6                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_default:
002ea1 91b0 2922                 	lds r27, noise_total_hi_pitch_offset
002ea3 c005                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate:
002ea4 91a0 2922                 	lds r26, noise_total_hi_pitch_offset //load the total hi pitch offset to change
002ea6 0fba                      	add r27, r26
002ea7 93b0 2922                 	sts noise_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate_multiply:
002ea9 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002eaa 937f                      	push r23
002eab 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002eac eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002ead 0367                      	mulsu r22, r23
002eae 917f                      	pop r23
002eaf 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate_offset:
002eb0 91a0 0abc                 	lds r26, TCB3_CCMPL //load the low bits for timer
002eb2 91b0 0abd                 	lds r27, TCB3_CCMPH //load the high bits for timer
002eb4 0da0                      	add r26, r0 //offset the timer values
002eb5 1db1                      	adc r27, r1
002eb6 93a0 0abc                 	sts TCB3_CCMPL, r26 //store the new low bits for timer
002eb8 93b0 0abd                 	sts TCB3_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty:
002eba 91e0 2928                 	lds ZL, noise_duty_macro
002ebc 91f0 2929                 	lds ZH, noise_duty_macro+1
002ebe 9630                      	adiw Z, 0
002ebf f169                      	breq sound_driver_channel3_fx_routines //if no duty macro is in use, go to the next routine
002ec0 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002ec1 1fff                      	rol ZH
002ec2 91a0 292a                 	lds r26, noise_duty_macro_offset
002ec4 0fea                      	add ZL, r26
002ec5 1df2                      	adc ZH, zero
                                 
002ec6 91b0 292c                 	lds r27, noise_duty_macro_release
002ec8 17ba                      	cp r27, r26
002ec9 f429                      	brne sound_driver_instrument_routine_channel3_duty_increment //if the current offset is not equal to the release index, increment the offset
002eca 91a0 292b                 	lds r26, noise_duty_macro_loop
002ecc 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002ecd f010                      	brlo sound_driver_instrument_routine_channel3_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002ece c01e                      	rjmp sound_driver_channel3_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel3_duty_increment:
002ecf 95a3                      	inc r26 //increment the macro offset
002ed0 93a0 292a                 	sts noise_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_duty_read:
002ed2 91b4                      	lpm r27, Z //load pitch data into r27
002ed3 3fbf                      	cpi r27, 0xFF //check for macro end flag
002ed4 f471                      	brne sound_driver_instrument_routine_channel3_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag_check_release:
002ed5 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002ed6 93a0 292a                 	sts noise_duty_macro_offset, r26
002ed8 91b0 292c                 	lds r27, noise_duty_macro_release
002eda 3fbf                      	cpi r27, 0xFF
002edb f489                      	brne sound_driver_channel3_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag_check_loop:
002edc 91b0 292b                 	lds r27, noise_duty_macro_loop //load the loop index
002ede 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002edf f069                      	breq sound_driver_channel3_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
002ee0 93b0 292a                 	sts noise_duty_macro_offset, r27 //store the loop index into the offset
002ee2 cfd7                      	rjmp sound_driver_instrument_routine_channel3_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty_load:
002ee3 95b6                      	lsr r27
002ee4 95b7                      	ror r27 //move mode bit to bit 7
002ee5 91c0 2814                 	lds r28, noise_period
002ee7 77cf                      	andi r28, 0b01111111
002ee8 2bcb                      	or r28, r27 //store the new noise mode
002ee9 93c0 2813                 	sts noise_param, r28
                                 
002eeb 776f                      	andi noise_sequence_HIGH, 0b01111111
002eec 2b6b                      	or noise_sequence_HIGH, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_routines:
                                 sound_driver_channel3_fx_1xx_routine:
002eed 91e0 292f                 	lds ZL, noise_fx_1xx
002eef 91f0 2930                 	lds ZH, noise_fx_1xx+1
002ef1 9630                      	adiw Z, 0
002ef2 f051                      	breq sound_driver_channel3_fx_2xx_routine
                                 
002ef3 91a0 2931                 	lds r26, noise_fx_1xx_total //load the rate to change the pitch by
002ef5 91b0 2932                 	lds r27, noise_fx_1xx_total+1
002ef7 0fae                      	add r26, ZL //increase the total offset by the rate
002ef8 1fbf                      	adc r27, ZH
002ef9 93a0 2931                 	sts noise_fx_1xx_total, r26
002efb 93b0 2932                 	sts noise_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_2xx_routine:
002efd 91e0 2933                 	lds ZL, noise_fx_2xx
002eff 91f0 2934                 	lds ZH, noise_fx_2xx+1
002f01 9630                      	adiw Z, 0
002f02 f051                      	breq sound_driver_channel3_fx_3xx_routine
                                 
002f03 91a0 2935                 	lds r26, noise_fx_2xx_total //load the rate to change the pitch by
002f05 91b0 2936                 	lds r27, noise_fx_2xx_total+1
002f07 0fae                      	add r26, ZL //increase the total offset by the rate
002f08 1fbf                      	adc r27, ZH
002f09 93a0 2935                 	sts noise_fx_2xx_total, r26
002f0b 93b0 2936                 	sts noise_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_3xx_routine:
002f0d 91e0 293b                 	lds ZL, noise_fx_3xx_speed
002f0f 91f0 293c                 	lds ZH, noise_fx_3xx_speed+1
002f11 9630                      	adiw Z, 0
002f12 f409                      	brne sound_driver_channel3_fx_3xx_routine_check_start
002f13 c048                      	rjmp sound_driver_channel3_fx_4xy_routine
                                 
                                 sound_driver_channel3_fx_3xx_routine_check_start:
002f14 91a0 2937                 	lds r26, noise_fx_3xx_start
002f16 91b0 2938                 	lds r27, noise_fx_3xx_start+1
002f18 9610                      	adiw r26:r27, 0
002f19 f409                      	brne sound_driver_channel3_fx_3xx_routine_main
002f1a c041                      	rjmp sound_driver_channel3_fx_4xy_routine
                                 
                                 sound_driver_channel3_fx_3xx_routine_main:
002f1b 91c0 2939                 	lds r28, noise_fx_3xx_target
002f1d 91d0 293a                 	lds r29, noise_fx_3xx_target+1
                                 
002f1f 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
002f20 07bd                      	cpc r27, r29
002f21 f011                      	breq sound_driver_channel3_fx_3xx_routine_disable
002f22 f030                      	brlo sound_driver_channel3_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002f23 c01f                      	rjmp sound_driver_channel3_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel3_fx_3xx_routine_disable:
002f24 9220 2937                 	sts noise_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002f26 9220 2938                 	sts noise_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002f28 c033                      	rjmp sound_driver_channel3_fx_4xy_routine
                                 
                                 sound_driver_channel3_fx_3xx_routine_subtract:
002f29 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002f2a 0bdb                      	sbc r29, r27
002f2b 91a0 293d                 	lds r26, noise_fx_3xx_total_offset
002f2d 91b0 293e                 	lds r27, noise_fx_3xx_total_offset+1
                                 
002f2f 0fae                      	add r26, ZL //add the speed to the total offset
002f30 1fbf                      	adc r27, ZH
002f31 1bca                      	sub r28, r26 //invert the total difference with the total offset
002f32 0bdb                      	sbc r29, r27
002f33 f380                      	brlo sound_driver_channel3_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002f34 93a0 293d                 	sts noise_fx_3xx_total_offset, r26 //store the new total offset
002f36 93b0 293e                 	sts noise_fx_3xx_total_offset+1, r27
                                 
002f38 91a0 0abc                 	lds r26, TCB3_CCMPL //load the current timer period
002f3a 91b0 0abd                 	lds r27, TCB3_CCMPH
002f3c 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002f3d 0bbd                      	sbc r27, r29
002f3e 93a0 0abc                 	sts TCB3_CCMPL, r26
002f40 93b0 0abd                 	sts TCB3_CCMPH, r27
002f42 c019                      	rjmp sound_driver_channel3_fx_4xy_routine
                                 
                                 sound_driver_channel3_fx_3xx_routine_add:
002f43 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002f44 0bbd                      	sbc r27, r29
002f45 91c0 293d                 	lds r28, noise_fx_3xx_total_offset
002f47 91d0 293e                 	lds r29, noise_fx_3xx_total_offset+1
                                 
002f49 0fce                      	add r28, ZL //add the speed to the total offset
002f4a 1fdf                      	adc r29, ZH
002f4b 1bac                      	sub r26, r28 //invert the total difference with the total offset
002f4c 0bbd                      	sbc r27, r29
002f4d f2b0                      	brlo sound_driver_channel3_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002f4e 93c0 293d                 	sts noise_fx_3xx_total_offset, r28 //store the new total offset
002f50 93d0 293e                 	sts noise_fx_3xx_total_offset+1, r29
                                 
002f52 91c0 0abc                 	lds r28, TCB3_CCMPL //load the current timer period
002f54 91d0 0abd                 	lds r29, TCB3_CCMPH
002f56 0fca                      	add r28, r26 //offset the current timer period with the total offset
002f57 1fdb                      	adc r29, r27
002f58 93c0 0abc                 	sts TCB3_CCMPL, r28
002f5a 93d0 0abd                 	sts TCB3_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel3_fx_4xy_routine:
002f5c 91a0 293f                 	lds r26, noise_fx_4xy_speed
002f5e 15a2                      	cp r26, zero
002f5f f409                      	brne sound_driver_channel3_fx_4xy_routine_continue
002f60 c05c                      	rjmp sound_driver_channel3_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel3_fx_4xy_routine_continue:
002f61 91b0 2940                 	lds r27, noise_fx_4xy_depth
002f63 91c0 2941                 	lds r28, noise_fx_4xy_phase
002f65 0fca                      	add r28, r26 //increase the phase by the speed
002f66 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
002f67 f008                      	brlo sound_driver_channel3_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002f68 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase:
002f69 93c0 2941                 	sts noise_fx_4xy_phase, r28 //store the new phase
002f6b 31c0                      	cpi r28, 16
002f6c f028                      	brlo sound_driver_channel3_fx_4xy_routine_phase_0
002f6d 32c0                      	cpi r28, 32
002f6e f028                      	brlo sound_driver_channel3_fx_4xy_routine_phase_1
002f6f 33c0                      	cpi r28, 48
002f70 f030                      	brlo sound_driver_channel3_fx_4xy_routine_phase_2
002f71 c007                      	rjmp sound_driver_channel3_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_0:
002f72 70cf                      	andi r28, 0x0F //mask for values 0-15
002f73 c029                      	rjmp sound_driver_channel3_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_1:
002f74 6fc0                      	ori r28, 0xF0
002f75 95c0                      	com r28 //invert values 0-15
002f76 c026                      	rjmp sound_driver_channel3_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_2:
002f77 70cf                      	andi r28, 0x0F //mask for values 0-15
002f78 c003                      	rjmp sound_driver_channel3_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_3:
002f79 6fc0                      	ori r28, 0xF0
002f7a 95c0                      	com r28 //invert values 0-15
002f7b c000                      	rjmp sound_driver_channel3_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel3_fx_4xy_routine_load_add:
002f7c 95b2                      	swap r27 //multiply depth by 16
002f7d 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002f7e e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002f7f e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002f80 0fec                      	add ZL, r28 //offset the table by the depth+phase
002f81 1df2                      	adc ZH, zero
002f82 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002f83 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002f84 937f                      	push r23
002f85 2f6c                      	mov r22, r28 //store the vibrato value into r22
002f86 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002f87 9f67                      	mul r22, r23
002f88 917f                      	pop r23
002f89 916f                      	pop r22
                                 
002f8a 9416                      	lsr r1 //shift out the fractional bits
002f8b 9407                      	ror r0
002f8c 9416                      	lsr r1
002f8d 9407                      	ror r0
002f8e 9416                      	lsr r1
002f8f 9407                      	ror r0
002f90 9416                      	lsr r1
002f91 9407                      	ror r0
                                 	
002f92 91a0 0abc                 	lds r26, TCB3_CCMPL
002f94 91b0 0abd                 	lds r27, TCB3_CCMPH
002f96 0da0                      	add r26, r0
002f97 1db1                      	adc r27, r1
002f98 93a0 0abc                 	sts TCB3_CCMPL, r26
002f9a 93b0 0abd                 	sts TCB3_CCMPH, r27
002f9c c020                      	rjmp sound_driver_channel3_fx_7xy_routine
                                 
                                 sound_driver_channel3_fx_4xy_routine_load_subtract:
002f9d 95b2                      	swap r27 //multiply depth by 16
002f9e 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002f9f e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002fa0 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002fa1 0fec                      	add ZL, r28 //offset the table by the depth+phase
002fa2 1df2                      	adc ZH, zero
002fa3 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002fa4 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002fa5 937f                      	push r23
002fa6 2f6c                      	mov r22, r28 //store the vibrato value into r22
002fa7 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002fa8 9f67                      	mul r22, r23
002fa9 917f                      	pop r23
002faa 916f                      	pop r22
                                 
002fab 9416                      	lsr r1 //shift out the fractional bits
002fac 9407                      	ror r0
002fad 9416                      	lsr r1
002fae 9407                      	ror r0
002faf 9416                      	lsr r1
002fb0 9407                      	ror r0
002fb1 9416                      	lsr r1
002fb2 9407                      	ror r0
                                 
002fb3 91a0 0abc                 	lds r26, TCB3_CCMPL
002fb5 91b0 0abd                 	lds r27, TCB3_CCMPH
002fb7 19a0                      	sub r26, r0
002fb8 09b1                      	sbc r27, r1
002fb9 93a0 0abc                 	sts TCB3_CCMPL, r26
002fbb 93b0 0abd                 	sts TCB3_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_7xy_routine:
002fbd 91a0 2942                 	lds r26, noise_fx_7xy_speed
002fbf 15a2                      	cp r26, zero
002fc0 f0f1                      	breq sound_driver_channel3_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
002fc1 91b0 2943                 	lds r27, noise_fx_7xy_depth
002fc3 91c0 2944                 	lds r28, noise_fx_7xy_phase
002fc5 0fca                      	add r28, r26 //increase the phase by the speed
002fc6 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
002fc7 f010                      	brlo sound_driver_channel3_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
002fc8 e0c0                      	ldi r28, 0x00
002fc9 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel3_fx_7xy_routine_phase:
002fca 93c0 2944                 	sts noise_fx_7xy_phase, r28 //store the new phase
002fcc 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
002fcd ffc4                      	sbrs r28, 4
002fce c001                      	rjmp sound_driver_channel3_fx_7xy_routine_phase_0
002fcf c002                      	rjmp sound_driver_channel3_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel3_fx_7xy_routine_phase_0:
002fd0 70cf                      	andi r28, 0x0F //mask for values 0-15
002fd1 c003                      	rjmp sound_driver_channel3_fx_7xy_routine_load
                                 
                                 sound_driver_channel3_fx_7xy_routine_phase_1:
002fd2 6fc0                      	ori r28, 0xF0
002fd3 95c0                      	com r28 //invert values 0-15
002fd4 c000                      	rjmp sound_driver_channel3_fx_7xy_routine_load
                                 
                                 sound_driver_channel3_fx_7xy_routine_load:
002fd5 95b2                      	swap r27 //multiply depth by 16
002fd6 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002fd7 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002fd8 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002fd9 0fec                      	add ZL, r28 //offset the table by the depth+phase
002fda 1df2                      	adc ZH, zero
002fdb 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002fdc 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
002fdd 93c0 2945                 	sts noise_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Axy_routine:
002fdf 91b0 2946                 	lds r27, noise_fx_Axy
002fe1 15b2                      	cp r27, zero
002fe2 f0e9                      	breq sound_driver_channel3_fx_Qxy_routine //0 means that the effect is not in use
                                 	
002fe3 91a0 2815                 	lds r26, noise_fractional_volume //load fractional volume representation of the channel
002fe5 91c0 2813                 	lds r28, noise_param //load the integer volume representation of the channel
002fe7 2fda                      	mov r29, r26 //copy fractional volume into r29
002fe8 2fec                      	mov r30, r28 //copy the noise_param into r30
002fe9 95e2                      	swap r30
002fea 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
002feb 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
002fec 17ed                      	cp r30, r29 //compare the fractional and integer volumes
002fed f009                      	breq sound_driver_channel3_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel3_fx_Axy_routine_reload:
002fee 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate:
002fef fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
002ff0 c004                      	rjmp sound_driver_channel3_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_addition:
002ff1 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002ff2 f428                      	brcc sound_driver_channel3_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002ff3 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
002ff4 c003                      	rjmp sound_driver_channel3_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_subtraction:
002ff5 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002ff6 f008                      	brcs sound_driver_channel3_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002ff7 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_store:
002ff8 93a0 2815                 	sts noise_fractional_volume, r26 //store the new fractional volume
002ffa 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
002ffb 95a2                      	swap r26
002ffc 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
002ffd 2bca                      	or r28, r26 //store the new volume back into noise_param
002ffe 93c0 2813                 	sts noise_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel3_fx_Qxy_routine:
003000 91e0 294b                 	lds ZL, noise_fx_Qxy_target
003002 91f0 294c                 	lds ZH, noise_fx_Qxy_target+1
003004 9630                      	adiw Z, 0
003005 f139                      	breq sound_driver_channel3_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
003006 91a0 294f                 	lds r26, noise_fx_Qxy_total_offset
003008 91b0 2950                 	lds r27, noise_fx_Qxy_total_offset+1
00300a 91c0 0abc                 	lds r28, TCB3_CCMPL
00300c 91d0 0abd                 	lds r29, TCB3_CCMPH
                                 
00300e 1bec                      	sub ZL, r28 //calculate the difference to the target
00300f 0bfd                      	sbc ZH, r29
003010 f408                      	brsh sound_driver_channel3_fx_Qxy_routine_end //if the target has been reached (or passed)
003011 f088                      	brlo sound_driver_channel3_fx_Qxy_routine_add
                                 
                                 sound_driver_channel3_fx_Qxy_routine_end:
003012 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
003013 0bbf                      	sbc r27, ZH
                                 
003014 91c0 2949                 	lds r28, noise_fx_Pxx_total
003016 91d0 294a                 	lds r29, noise_fx_Pxx_total+1
                                 
003018 0fac                      	add r26, r28
003019 1fbd                      	adc r27, r29
                                 
00301a 93a0 294f                 	sts noise_fx_Qxy_total_offset, r26 //store the total offset
00301c 93b0 2950                 	sts noise_fx_Qxy_total_offset+1, r27
00301e 9220 294b                 	sts noise_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
003020 9220 294c                 	sts noise_fx_Qxy_target+1, zero
003022 c00a                      	rjmp sound_driver_channel3_fx_Rxy_routine
                                 
                                 sound_driver_channel3_fx_Qxy_routine_add:
003023 91c0 294d                 	lds r28, noise_fx_Qxy_speed
003025 91d0 294e                 	lds r29, noise_fx_Qxy_speed+1
003027 0fac                      	add r26, r28 //increase the total offset by the speed
003028 1fbd                      	adc r27, r29
003029 93a0 294f                 	sts noise_fx_Qxy_total_offset, r26 //store the total offset
00302b 93b0 2950                 	sts noise_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Rxy_routine:
00302d 91e0 2951                 	lds ZL, noise_fx_Rxy_target
00302f 91f0 2952                 	lds ZH, noise_fx_Rxy_target+1
003031 9630                      	adiw Z, 0
003032 f139                      	breq sound_driver_instrument_routine_channel4_volume //if the effect is not enabled, skip the routine
                                 
003033 91a0 2955                 	lds r26, noise_fx_Rxy_total_offset
003035 91b0 2956                 	lds r27, noise_fx_Rxy_total_offset+1
003037 91c0 0abc                 	lds r28, TCB3_CCMPL
003039 91d0 0abd                 	lds r29, TCB3_CCMPH
                                 
00303b 1bce                      	sub r28, ZL //calculate the difference to the target
00303c 0bdf                      	sbc r29, ZH
00303d f408                      	brsh sound_driver_channel3_fx_Rxy_routine_end //if the target has been reached (or passed)
00303e f088                      	brlo sound_driver_channel3_fx_Rxy_routine_add
                                 
                                 sound_driver_channel3_fx_Rxy_routine_end:
00303f 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
003040 0bbd                      	sbc r27, r29
                                 
003041 91c0 2949                 	lds r28, noise_fx_Pxx_total
003043 91d0 294a                 	lds r29, noise_fx_Pxx_total+1
                                 
003045 0fac                      	add r26, r28
003046 1fbd                      	adc r27, r29
                                 
003047 93a0 2955                 	sts noise_fx_Rxy_total_offset, r26 //store the total offset
003049 93b0 2956                 	sts noise_fx_Rxy_total_offset+1, r27
00304b 9220 2951                 	sts noise_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
00304d 9220 2952                 	sts noise_fx_Rxy_target+1, zero
00304f c00a                      	rjmp sound_driver_instrument_routine_channel4_volume
                                 
                                 sound_driver_channel3_fx_Rxy_routine_add:
003050 91c0 2953                 	lds r28, noise_fx_Rxy_speed
003052 91d0 2954                 	lds r29, noise_fx_Rxy_speed+1
003054 0fac                      	add r26, r28 //increase the total offset by the speed
003055 1fbd                      	adc r27, r29
003056 93a0 2955                 	sts noise_fx_Rxy_total_offset, r26 //store the total offset
003058 93b0 2956                 	sts noise_fx_Rxy_total_offset+1, r27
                                 
                                 sound_driver_instrument_routine_channel4_volume:
                                 
                                 sound_driver_exit:
00305a 91ff                      	pop r31
00305b 91ef                      	pop r30
00305c 91df                      	pop r29
00305d 91cf                      	pop r28
00305e 940c 1515                 	jmp sequence_1_3 + 3 //+3 is to skip the stack instructions since we already pushed them
                                 
                                 
                                 
                                 //TABLES
003060 7f05
003061 010a
003062 0214
003063 0328
003064 0450
003065 051e
003066 0607
003067 070d
003068 0806
003069 090c
00306a 0a18
00306b 0b30
00306c 0c60
00306d 0d24
00306e 0e08
00306f 0f10                      length: .db $05, $7F, $0A, $01, $14, $02, $28, $03, $50, $04, $1E, $05, $07, $06, $0D, $07, $06, $08, $0C, $09, $18, $0A, $30, $0B, $60, $0C, $24, $0D, $08, $0E, $10, $0F
                                 
                                 //pulse sequences: 12.5%, 25%, 50%, 75%
003070 0301
003071 fc0f                      sequences: .db 0b00000001, 0b00000011, 0b00001111, 0b11111100
                                 
                                 //list of famitracker fx: http://famitracker.com/wiki/index.php?title=Effect_list
                                 channel0_fx:
003072 1751
003073 1756
003074 1772
003075 178e
003076 17b1                      	.dw sound_driver_channel0_fx_0xy, sound_driver_channel0_fx_1xx, sound_driver_channel0_fx_2xx, sound_driver_channel0_fx_3xx, sound_driver_channel0_fx_4xy
003077 17bc
003078 17c9
003079 17cc
00307a 17cf
00307b 17d2                      	.dw sound_driver_channel0_fx_7xy, sound_driver_channel0_fx_Axy, sound_driver_channel0_fx_Bxx, sound_driver_channel0_fx_Cxx, sound_driver_channel0_fx_Dxx
00307c 17d5
00307d 17dd
00307e 17e0
00307f 17ed
003080 17ee                      	.dw sound_driver_channel0_fx_Exx, sound_driver_channel0_fx_Fxx, sound_driver_channel0_fx_Gxx, sound_driver_channel0_fx_Hxy, sound_driver_channel0_fx_Ixy
003081 17ef
003082 17f0
003083 17f1
003084 1809
003085 184d                      	.dw sound_driver_channel0_fx_Hxx, sound_driver_channel0_fx_Ixx, sound_driver_channel0_fx_Pxx, sound_driver_channel0_fx_Qxy, sound_driver_channel0_fx_Rxy
003086 1890
003087 189d
003088 18b1
003089 18b2
00308a 18b3                      	.dw sound_driver_channel0_fx_Sxx, sound_driver_channel0_fx_Vxx, sound_driver_channel0_fx_Wxx, sound_driver_channel0_fx_Xxx, sound_driver_channel0_fx_Yxx
00308b 18b4                      	.dw sound_driver_channel0_fx_Zxx
                                 
                                 channel1_fx:
00308c 1a3f
00308d 1a44
00308e 1a60
00308f 1a7c
003090 1a9f                      	.dw sound_driver_channel1_fx_0xy, sound_driver_channel1_fx_1xx, sound_driver_channel1_fx_2xx, sound_driver_channel1_fx_3xx, sound_driver_channel1_fx_4xy
003091 1aaa
003092 1ab7
003093 1aba
003094 1abd
003095 1ac0                      	.dw sound_driver_channel1_fx_7xy, sound_driver_channel1_fx_Axy, sound_driver_channel1_fx_Bxx, sound_driver_channel1_fx_Cxx, sound_driver_channel1_fx_Dxx
003096 1ac3
003097 1acb
003098 1ace
003099 1adb
00309a 1adc                      	.dw sound_driver_channel1_fx_Exx, sound_driver_channel1_fx_Fxx, sound_driver_channel1_fx_Gxx, sound_driver_channel1_fx_Hxy, sound_driver_channel1_fx_Ixy
00309b 1add
00309c 1ade
00309d 1adf
00309e 1af7
00309f 1b3b                      	.dw sound_driver_channel1_fx_Hxx, sound_driver_channel1_fx_Ixx, sound_driver_channel1_fx_Pxx, sound_driver_channel1_fx_Qxy, sound_driver_channel1_fx_Rxy
0030a0 1b7e
0030a1 1b8b
0030a2 1b9f
0030a3 1ba0
0030a4 1ba1                      	.dw sound_driver_channel1_fx_Sxx, sound_driver_channel1_fx_Vxx, sound_driver_channel1_fx_Wxx, sound_driver_channel1_fx_Xxx, sound_driver_channel1_fx_Yxx
0030a5 1ba2                      	.dw sound_driver_channel1_fx_Zxx
                                 
                                 channel2_fx:
0030a6 1d20
0030a7 1d25
0030a8 1d41
0030a9 1d5d
0030aa 1d80                      	.dw sound_driver_channel2_fx_0xy, sound_driver_channel2_fx_1xx, sound_driver_channel2_fx_2xx, sound_driver_channel2_fx_3xx, sound_driver_channel2_fx_4xy
0030ab 1d8b
0030ac 1d8c
0030ad 1d8d
0030ae 1d90
0030af 1d93                      	.dw sound_driver_channel2_fx_7xy, sound_driver_channel2_fx_Axy, sound_driver_channel2_fx_Bxx, sound_driver_channel2_fx_Cxx, sound_driver_channel2_fx_Dxx
0030b0 1d96
0030b1 1da3
0030b2 1da6
0030b3 1db3
0030b4 1db4                      	.dw sound_driver_channel2_fx_Exx, sound_driver_channel2_fx_Fxx, sound_driver_channel2_fx_Gxx, sound_driver_channel2_fx_Hxy, sound_driver_channel2_fx_Ixy
0030b5 1db5
0030b6 1db6
0030b7 1db7
0030b8 1dcf
0030b9 1e13                      	.dw sound_driver_channel2_fx_Hxx, sound_driver_channel2_fx_Ixx, sound_driver_channel2_fx_Pxx, sound_driver_channel2_fx_Qxy, sound_driver_channel2_fx_Rxy
0030ba 1e56
0030bb 1e63
0030bc 1e64
0030bd 1e65
0030be 1e66                      	.dw sound_driver_channel2_fx_Sxx, sound_driver_channel2_fx_Vxx, sound_driver_channel2_fx_Wxx, sound_driver_channel2_fx_Xxx, sound_driver_channel2_fx_Yxx
0030bf 1e67                      	.dw sound_driver_channel2_fx_Zxx
                                 
                                 channel3_fx:
0030c0 1fe9
0030c1 1fee
0030c2 200a
0030c3 2026
0030c4 2049                      	.dw sound_driver_channel3_fx_0xy, sound_driver_channel3_fx_1xx, sound_driver_channel3_fx_2xx, sound_driver_channel3_fx_3xx, sound_driver_channel3_fx_4xy
0030c5 2054
0030c6 2061
0030c7 2064
0030c8 2067
0030c9 206a                      	.dw sound_driver_channel3_fx_7xy, sound_driver_channel3_fx_Axy, sound_driver_channel3_fx_Bxx, sound_driver_channel3_fx_Cxx, sound_driver_channel3_fx_Dxx
0030ca 206d
0030cb 2074
0030cc 2077
0030cd 2084
0030ce 2085                      	.dw sound_driver_channel3_fx_Exx, sound_driver_channel3_fx_Fxx, sound_driver_channel3_fx_Gxx, sound_driver_channel3_fx_Hxy, sound_driver_channel3_fx_Ixy
0030cf 2086
0030d0 2087
0030d1 2088
0030d2 20a0
0030d3 20e4                      	.dw sound_driver_channel3_fx_Hxx, sound_driver_channel3_fx_Ixx, sound_driver_channel3_fx_Pxx, sound_driver_channel3_fx_Qxy, sound_driver_channel3_fx_Rxy
0030d4 2127
0030d5 2134
0030d6 213f
0030d7 2140
0030d8 2141                      	.dw sound_driver_channel3_fx_Sxx, sound_driver_channel3_fx_Vxx, sound_driver_channel3_fx_Wxx, sound_driver_channel3_fx_Xxx, sound_driver_channel3_fx_Yxx
0030d9 2142                      	.dw sound_driver_channel3_fx_Zxx
                                 
                                 //famitracker volumes table: http://famitracker.com/wiki/index.php?title=Volume
                                 volumes:
0030da 0000
0030db 0000
0030dc 0000
0030dd 0000
0030de 0000
0030df 0000
0030e0 0000
0030e1 0000                      	.db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
0030e2 0100
0030e3 0101
0030e4 0101
0030e5 0101
0030e6 0101
0030e7 0101
0030e8 0101
0030e9 0101                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
0030ea 0100
0030eb 0101
0030ec 0101
0030ed 0101
0030ee 0101
0030ef 0101
0030f0 0101
0030f1 0201                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02
0030f2 0100
0030f3 0101
0030f4 0101
0030f5 0101
0030f6 0101
0030f7 0202
0030f8 0202
0030f9 0302                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03
0030fa 0100
0030fb 0101
0030fc 0101
0030fd 0101
0030fe 0202
0030ff 0202
003100 0303
003101 0403                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04
003102 0100
003103 0101
003104 0101
003105 0202
003106 0302
003107 0303
003108 0404
003109 0504                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05
00310a 0100
00310b 0101
00310c 0201
00310d 0202
00310e 0303
00310f 0404
003110 0504
003111 0605                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x06
003112 0100
003113 0101
003114 0201
003115 0302
003116 0403
003117 0504
003118 0605
003119 0706                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07
00311a 0100
00311b 0101
00311c 0202
00311d 0303
00311e 0404
00311f 0505
003120 0606
003121 0807                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07, 0x08
003122 0100
003123 0101
003124 0302
003125 0403
003126 0504
003127 0606
003128 0707
003129 0908                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09
00312a 0100
00312b 0201
00312c 0302
00312d 0404
00312e 0605
00312f 0706
003130 0808
003131 0a09                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A
003132 0100
003133 0201
003134 0302
003135 0504
003136 0605
003137 0807
003138 0908
003139 0b0a                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B
00313a 0100
00313b 0201
00313c 0403
00313d 0504
00313e 0706
00313f 0808
003140 0a09
003141 0c0b                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B, 0x0C
003142 0100
003143 0201
003144 0403
003145 0605
003146 0706
003147 0908
003148 0b0a
003149 0d0c                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D
00314a 0100
00314b 0201
00314c 0403
00314d 0605
00314e 0807
00314f 0a09
003150 0c0b
003151 0e0d                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E
003152 0100
003153 0302
003154 0504
003155 0706
003156 0908
003157 0b0a
003158 0d0c


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega4809" register use summary:
x  :   0 y  :   0 z  : 248 r0 : 196 r1 : 212 r2 : 701 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   6 r11:   4 r12:   9 
r13:   6 r14:   4 r15:   9 r16:   7 r17:   6 r18:   7 r19:   6 r20:   4 
r21:   9 r22: 174 r23: 160 r24:   0 r25:  24 r26: 979 r27:1196 r28: 706 
r29: 376 r30: 378 r31: 337 
Registers used: 25 out of 35 (71.4%)

"ATmega4809" instruction use summary:
.lds  :   0 .sts  :   0 adc   : 152 add   : 199 adiw  : 106 and   :   0 
andi  :  99 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   7 brcs  :  13 break :   0 breq  : 173 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  81 brlt  :   0 brmi  :   0 
brne  : 121 brpl  :   0 brsh  :  31 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :   0 cbr   :   5 
clc   :   0 clh   :   0 cli   :   8 cln   :   0 clr   :   5 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :  16 cp    : 101 cpc   :  10 
cpi   : 168 cpse  :  20 dec   :  35 des   :   0 eor   :   2 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   4 in    :   7 inc   :  48 
jmp   :  11 ld    :   0 ldd   :   0 ldi   : 293 lds   : 727 lpm   : 260 
lsl   :  79 lsr   : 171 mov   : 139 movw  :   0 mul   :  28 muls  :   0 
mulsu :  12 neg   :   0 nop   :   0 or    :  26 ori   :  12 out   :   9 
pop   : 115 push  : 109 rcall :  50 ret   :  32 reti  :   7 rjmp  : 518 
rol   :  53 ror   : 192 sbc   :  48 sbci  :   0 sbi   :   0 sbic  :   0 
sbis  :   0 sbiw  :   0 sbr   :  12 sbrc  :  29 sbrs  :  20 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   :1397 sub   :  66 subi  :  52 swap  :  46 tst   :   0 wdr   :   0 

Instructions used: 52 out of 114 (45.6%)

"ATmega4809" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x0062b4  15930   9226  25156   49152  51.2%
[.dseg] 0x002800 0x00295a      0    346    346    6144   5.6%
[.eseg] 0x000000 0x000000      0      0      0     256   0.0%

Assembly complete, 0 errors, 59 warnings
