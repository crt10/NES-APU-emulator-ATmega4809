
AVRASM ver. 2.2.8  C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm Thu Dec 31 02:01:01 2020

C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(91): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(91): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
                                 
                                 
                                 ; NES_APU_2a03.asm
                                 ;
                                 ; Created: 11/29/2020 1:44:10 AM
                                 ; Author : Tennyson Cheng
                                 ;
                                 
                                 .list
                                 
                                 .dseg
002800                           pulse1_param: .byte 1 //$4000 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002801                           pulse1_sweep_param: .byte 1 //$4001 EPPP.NSSS = Enable, Period, Negate, Shift
                                 //NOTE: In order to account for multiplier, we use 16 instead of 11 bits for the timer
002802                           pulse1_timerL: .byte 1 //$4002 LLLL.LLLL = Low 8 bits for timer
002803                           pulse1_timerH: .byte 1 //$4002 HHHH.HHHH = High 8 bits for timer
002804                           pulse1_length: .byte 1 //$4002 000l.llll = Length counter load
002805                           pulse1_output_volume: .byte 1 //this is the final output volume of pulse 1
002806                           pulse1_note: .byte 1 //the current note index in the note table
                                 
002807                           song_frames: .byte 2
002809                           song_frame_offset: .byte 2
                                 
00280b                           pulse1_pattern: .byte 2
00280d                           pulse1_pattern_delay: .byte 1
00280e                           pulse1_pattern_offset: .byte 2
                                 
002810                           pulse1_volume_macro: .byte 2
002812                           pulse1_volume_macro_offset: .byte 1
002813                           pulse1_volume_macro_loop: .byte 1
002814                           pulse1_volume_macro_release: .byte 1
002815                           pulse1_arpeggio_macro: .byte 2
002817                           pulse1_arpeggio_macro_offset: .byte 1
002818                           pulse1_arpeggio_macro_loop: .byte 1
002819                           pulse1_arpeggio_macro_release: .byte 1
00281a                           pulse1_arpeggio_macro_mode: .byte 1
00281b                           pulse1_pitch_macro: .byte 2
00281d                           pulse1_pitch_macro_offset: .byte 1
00281e                           pulse1_pitch_macro_loop: .byte 1
00281f                           pulse1_pitch_macro_release: .byte 1
002820                           pulse1_hi_pitch_macro: .byte 2
002822                           pulse1_hi_pitch_macro_offset: .byte 1
002823                           pulse1_hi_pitch_macro_loop: .byte 1
002824                           pulse1_hi_pitch_macro_release: .byte 1
002825                           pulse1_duty_macro: .byte 2
002827                           pulse1_duty_macro_offset: .byte 1
002828                           pulse1_duty_macro_loop: .byte 1
002829                           pulse1_duty_macro_release: .byte 1
                                 
00282a                           pulse2_pattern_delay: .byte 1
00282b                           triangle_pattern_delay: .byte 1
00282c                           noise_pattern_delay: .byte 1
00282d                           dcpm_pattern_delay: .byte 1
                                 
                                 .cseg
                                 
                                 //NOTE: r30 and r31 are reserved for conversion routines, since lpm can only be used with the Z register
                                 //r28 and r29 are reserved for non-interrupt routines
                                 //r26 and r27 are reserved for interrupt routines, but interrupt routines may use r28 and r29
                                 //If an interrupt uses r28 and r29, then they must be pushed and popped (this should be limited as much as possible)
                                 //This was done in order to save clock cycles due to constantly pushing/popping registers
                                 //NOTE: zero is defined in order to use the cp instruction without the need to load 0x00 into a register beforehand
                                 .def zero = r0
                                 .def channel_flags = r25 //[pulse1.pulse2] RSlc.0000 = Reload, Start, Length halt/Loop, Constant volume
                                 .def pulse1_sequence = r13
                                 .def pulse1_length_counter = r14
                                 .def pulse1_sweep = r15 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse1_volume_divider = r16 //0000.PPPP = Period divider
                                 .def pulse1_volume_decay = r17 //0000.dddd = Decay
                                 
                                 reset:
000000 940c 0175                 	jmp init
                                 
                                 .org TCA0_OVF_vect
00000e 940c 0266                 	jmp sound_driver
                                 
                                 .org TCA0_CMP0_vect
000012 940c 024c                 	jmp sequence_0_2
                                 
                                 .org TCA0_CMP1_vect
000014 940c 0256                 	jmp sequence_1_3
                                 
                                 .org TCA0_CMP2_vect
000016 940c 024c                 	jmp sequence_0_2
                                 
                                 .org TCB0_INT_vect
000018 940c 0442                 	jmp pulse1_sequence_routine
                                 
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(18): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(91): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(19): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(91): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(22): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(91): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(27): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(91): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(32): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(91): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(37): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(91): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(70): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(91): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(71): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(91): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(72): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(91): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(73): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(91): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(74): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(91): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(75): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(91): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(76): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(91): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(77): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(91): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(78): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(91): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(79): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(91): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(80): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(91): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(81): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(91): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
                                 .list
                                 
                                 init:
                                 	//MAIN CLOCK
000175 edb8                      	ldi r27, CPU_CCP_IOREG_gc //protected write
000176 93b0 0034                 	sts CPU_CCP, r27
000178 e0b0                      	ldi r27, 0 << CLKCTRL_PEN_bp //disable prescaler for 20 MHz on main clock
000179 93b0 0061                 	sts CLKCTRL_MCLKCTRLB, r27
                                 
                                 /*	//TEST FOR C4, 1 SECOND, 50% DD
                                 	ldi r26, 0x97
                                 	ldi r27, 0x12
                                 	ldi r26, 0x15
                                 	ldi r27, 0x09
                                 	sts pulse1_timerL, r26
                                 	sts pulse1_timerH, r27
                                 	ldi r27, 0b10111111
                                 	sts pulse1_param, r27
                                 	ldi r27, 0x01
                                 	sts pulse1_length, r27
                                 	//TEST FOR SWEEP UP
                                 	ldi r27, 0b11111111
                                 	sts pulse1_sweep_param, r27*/
                                 
                                 	//ZERO
00017b 2400                      	clr zero
                                 
                                 	//MEMORY
00017c e3b0                      	ldi r27, 0b00110000
00017d 93b0 2800                 	sts pulse1_param, r27
00017f e8b0                      	ldi r27, 0b10000000
000180 93b0 2801                 	sts pulse1_sweep_param, r27
000182 efbf                      	ldi r27, 0xFF
000183 93b0 2802                 	sts pulse1_timerL, r27
000185 93b0 2803                 	sts pulse1_timerH, r27
000187 93b0 2804                 	sts pulse1_length, r27
                                 
000189 e0b0                      	ldi r27, 0x00
00018a 93b0 2809                 	sts song_frame_offset, r27
00018c 93b0 280a                 	sts song_frame_offset+1, r27
00018e eee2                      	ldi ZL, LOW(song0_frames << 1)
00018f e0f0                      	ldi ZH, HIGH(song0_frames << 1)
000190 93e0 2807                 	sts song_frames, ZL
000192 93f0 2808                 	sts song_frames+1, ZH
                                 
                                 	//CHANNEL 0 TEST
000194 e0b0                      	ldi r27, 0x00
000195 0feb                      	add ZL, r27
000196 1df0                      	adc ZH, zero
000197 91a5                      	lpm r26, Z+
000198 91b4                      	lpm r27, Z
000199 0faa                      	lsl r26
00019a 1fbb                      	rol r27
00019b 93a0 280b                 	sts pulse1_pattern, r26
00019d 93b0 280c                 	sts pulse1_pattern+1, r27
00019f e0b0                      	ldi r27, 0x00
0001a0 9200 280d                 	sts pulse1_pattern_delay, zero
0001a2 9200 280e                 	sts pulse1_pattern_offset, zero
0001a4 9200 280f                 	sts pulse1_pattern_offset+1, zero
                                 
                                 	//channel 0 instrument macros
0001a6 efbf                      	ldi r27, 0xFF
0001a7 9200 2812                 	sts pulse1_volume_macro_offset, zero
0001a9 93b0 2813                 	sts pulse1_volume_macro_loop, r27
0001ab 93b0 2814                 	sts pulse1_volume_macro_release, r27
0001ad 9200 2817                 	sts pulse1_arpeggio_macro_offset, zero
0001af 93b0 2818                 	sts pulse1_arpeggio_macro_loop, r27
0001b1 93b0 2819                 	sts pulse1_arpeggio_macro_release, r27
0001b3 93b0 281a                 	sts pulse1_arpeggio_macro_mode, r27
0001b5 9200 281d                 	sts pulse1_pitch_macro_offset, zero
0001b7 93b0 281e                 	sts pulse1_pitch_macro_loop, r27
0001b9 93b0 281f                 	sts pulse1_pitch_macro_release, r27
0001bb 9200 2822                 	sts pulse1_hi_pitch_macro_offset, zero
0001bd 93b0 2823                 	sts pulse1_hi_pitch_macro_loop, r27
0001bf 93b0 2824                 	sts pulse1_hi_pitch_macro_release, r27
0001c1 9200 2827                 	sts pulse1_duty_macro_offset, zero
0001c3 93b0 2828                 	sts pulse1_duty_macro_loop, r27
0001c5 93b0 2829                 	sts pulse1_duty_macro_release, r27
                                 
0001c7 9200 2810                 	sts pulse1_volume_macro, zero
0001c9 9200 2811                 	sts pulse1_volume_macro+1, zero
0001cb 9200 2815                 	sts pulse1_arpeggio_macro, zero
0001cd 9200 2816                 	sts pulse1_arpeggio_macro+1, zero
0001cf 9200 281b                 	sts pulse1_pitch_macro, zero
0001d1 9200 281c                 	sts pulse1_pitch_macro+1, zero
0001d3 9200 2820                 	sts pulse1_hi_pitch_macro, zero
0001d5 9200 2821                 	sts pulse1_hi_pitch_macro+1, zero
0001d7 9200 2825                 	sts pulse1_duty_macro, zero
0001d9 9200 2826                 	sts pulse1_duty_macro+1, zero
                                 
0001db 9200 282a                 	sts pulse2_pattern_delay, zero
0001dd 9200 282b                 	sts triangle_pattern_delay, zero
0001df 9200 282c                 	sts noise_pattern_delay, zero
0001e1 9200 282d                 	sts dcpm_pattern_delay, zero
                                 
                                 	//PINS
0001e3 efbf                      	ldi r27, 0xFF //set all pins in VPORTD to output
0001e4 b9b0                      	out VPORTA_DIR, r27
                                 
                                 	//ENVELOPE
0001e5 e00f                      	ldi pulse1_volume_divider, 0x0F
0001e6 9110 2800                 	lds pulse1_volume_decay, pulse1_param
0001e8 701f                      	andi pulse1_volume_decay, 0x0F //mask for VVVV bits
0001e9 9190 2800                 	lds channel_flags, pulse1_param
0001eb 7390                      	andi channel_flags, 0b00110000
0001ec 6490                      	sbr channel_flags, 0b01000000 //set start flag
0001ed 9200 2805                 	sts pulse1_output_volume, zero
                                 	
                                 	//LENGTH
0001ef 91d0 2804                 	lds r29, pulse1_length
0001f1 d29d                      	rcall length_converter
0001f2 2eed                      	mov pulse1_length_counter, r29
                                 
                                 	//SEQUENCE
0001f3 91d0 2800                 	lds r29, pulse1_param //load param for sequence table
0001f5 0fdd                      	lsl r29 //shift duty cycle bits to LSB
0001f6 1fdd                      	rol r29
0001f7 1fdd                      	rol r29
0001f8 70d3                      	andi r29, 0b00000011 //mask duty cycle bits
0001f9 d2ab                      	rcall duty_cycle_sequences
0001fa 2edd                      	mov pulse1_sequence, r29
                                 
                                 	//SWEEP
0001fb 90f0 2801                 	lds pulse1_sweep, pulse1_sweep_param
0001fd 94f2                      	swap pulse1_sweep //swap data from high byte and low byte
0001fe 6890                      	sbr channel_flags, 0b10000000 //set reload flag
                                 
                                 	//TIMERS
                                 	//Frame Counter
                                 	//NOTE:The frame counter will be defaulted to NTSC mode (60 Hz, 120 Hz, 240 Hz)
                                 	//Each interrupt will be setup to interrupt every 240 Hz clock
                                 	//CMP0 = sequence 0, CMP1 = sequence 1, CMP2 = sequence 2, OVF = sequence 3/sound driver
                                 	//Sequence 3 will clock the sound driver every 60Hz, in which new audio data is read and written to the registers
                                 	//Timer period Calculation: (0.00416666666 * 20000000/64)-1 = 1301.08333125 = 0x0515
                                 	//The ATmega4809 is cofigured to run at 20000000 Hz
                                 	//0.00416666666 seconds is the period for 240 Hz
                                 	//The /64 comes from the prescaler divider used
0001ff e7b0                      	ldi r27, TCA_SINGLE_CMP0EN_bm | TCA_SINGLE_CMP1EN_bm | TCA_SINGLE_CMP2EN_bm | TCA_SINGLE_WGMODE_NORMAL_gc //interrupt mode
000200 93b0 0a01                 	sts TCA0_SINGLE_CTRLB, r27
000202 e7b1                      	ldi r27, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP1_bm | TCA_SINGLE_CMP2_bm | TCA_SINGLE_OVF_bm //enable overflow and compare interrupts
000203 93b0 0a0a                 	sts TCA0_SINGLE_INTCTRL, r27
000205 e1b5                      	ldi r27, 0x15 //set the period for CMP0
000206 93b0 0a28                 	sts TCA0_SINGLE_CMP0, r27
000208 e0b5                      	ldi r27, 0x05
000209 93b0 0a29                 	sts TCA0_SINGLE_CMP0 + 1, r27
00020b e2bb                      	ldi r27, 0x2B //set the period for CMP1
00020c 93b0 0a2a                 	sts TCA0_SINGLE_CMP1, r27
00020e e0ba                      	ldi r27, 0x0A
00020f 93b0 0a2b                 	sts TCA0_SINGLE_CMP1 + 1, r27
000211 e4b1                      	ldi r27, 0x41 //set the period for CMP2
000212 93b0 0a2c                 	sts TCA0_SINGLE_CMP2, r27
000214 e0bf                      	ldi r27, 0x0F
000215 93b0 0a2d                 	sts TCA0_SINGLE_CMP2 + 1, r27
000217 e5b7                      	ldi r27, 0x57 //set the period for OVF
000218 93b0 0a26                 	sts TCA0_SINGLE_PER, r27
00021a e1b4                      	ldi r27, 0x14
00021b 93b0 0a27                 	sts TCA0_SINGLE_PER + 1, r27
00021d e0bb                      	ldi r27, TCA_SINGLE_CLKSEL_DIV64_gc | TCA_SINGLE_ENABLE_bm //use prescale divider of 64 and enable timer
00021e 93b0 0a00                 	sts TCA0_SINGLE_CTRLA, r27
                                 
                                 	//NOTE: Channel Timers are clocked (20/2)/(0.8948865) = 11.1746014718 times faster than the NES APU
                                 	//Because of this, we multiply all the NES timer values by 11.1746014718 beforehand 
                                 	//Since we rotate the sequence when the timer goes from t-(t-1) to 0, instead of 0 to t like the NES, we add 1 to the NES timers before multiplying
                                 	//The ATmega4809 is configured to run at 20 MHz
                                 	//The /2 comes from the prescaler divider used
                                 	//0.8948865 MHz is the speed of the NTSC NES APU
                                 	//Pulse 1
000220 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
000221 93b0 0a81                 	sts TCB0_CTRLB, r27
000223 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
000224 93b0 0a85                 	sts TCB0_INTCTRL, r27
000226 91b0 2802                 	lds r27, pulse1_timerL //load the LOW bits for timer
000228 93b0 0a8c                 	sts TCB0_CCMPL, r27
00022a 91b0 2803                 	lds r27, pulse1_timerH //load the HIGH bits for timer
00022c 93b0 0a8d                 	sts TCB0_CCMPH, r27
00022e e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
00022f 93b0 0a80                 	sts TCB0_CTRLA, r27
000231 9478                      	sei //global interrupt enable
                                 
                                 pulse1:
000232 fed0                      	sbrs pulse1_sequence, 0 //if the sequence output is zero, return
000233 c012                      	rjmp pulse1_off
                                 
000234 14e0                      	cp pulse1_length_counter, zero //if length is zero, return
000235 f081                      	breq pulse1_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
                                 pulse1_check_timer_08:
000236 91c0 0a8c                 	lds r28, TCB0_CCMPL
000238 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 pulse1_check_timer_08_HIGH:
00023a 30d1                      	cpi r29, 0x01 //check timer HIGH period
00023b f008                      	brlo pulse1_check_timer_08_LOW //if the timer HIGH period is $00, check the LOW period
00023c c002                      	rjmp pulse1_check_timer_7FF_HIGH //if the timer HIGH period is > $01, check > $07FF condition
                                 pulse1_check_timer_08_LOW:
00023d 35c9                      	cpi r28, 0x59 //check timer LOW period
00023e f038                      	brlo pulse1_off //if the HIGH period == $00 && LOW period <= $59, pulse off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $5965
                                 pulse1_check_timer_7FF_HIGH:
00023f 35d9                      	cpi r29, 0x59 //check timer HIGH period
000240 f038                      	brlo pulse1_on //if the HIGH period is < $59, then all conditions have passed and pulse is not muted
000241 f009                      	breq pulse1_check_timer_7FF_LOW //if the HIGH period is == $59, we go check if the LOW period is < $65
000242 c003                      	rjmp pulse1_off //pulse off if HIGH period is > $59
                                 pulse1_check_timer_7FF_LOW:
000243 36c5                      	cpi r28, 0x65 //check timer LOW period
000244 f408                      	brsh pulse1_off //if the HIGH period == $59 && LOW period >= $65, pulse off
000245 c002                      	rjmp pulse1_on //if the HIGH period == $59 && LOW period < $65, pulse on
                                 
                                 pulse1_off:
000246 b801                      	out VPORTA_OUT, zero
000247 cfea                      	rjmp pulse1
                                 
                                 pulse1_on:
000248 91d0 2805                 	lds r29, pulse1_output_volume
                                 /*	cpse r29, zero
                                 	rjmp pulse1_off //if VVVV bits are 0, then there is no volume (channel off)*/
                                 
00024a b9d1                      	out VPORTA_OUT, r29
00024b cfe6                      	rjmp pulse1
                                 
                                 //FRAME COUNTER/AUDIO SAMPLE ISR
                                 sequence_0_2:
00024c b7bf                      	in r27, CPU_SREG
00024d 93bf                      	push r27
00024e 94f8                      	cli
                                 
                                 	//ENVELOPE
00024f d227                      	rcall pulse1_envelope_routine
                                 
000250 e5b0                      	ldi r27, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP2_bm //clear OVF flag
000251 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
000253 91bf                      	pop r27
000254 bfbf                      	out CPU_SREG, r27
000255 9518                      	reti
                                 
                                 sequence_1_3:
000256 b7bf                      	in r27, CPU_SREG
000257 93bf                      	push r27
000258 94f8                      	cli
                                 
                                 	//ENVELOPE
000259 d21d                      	rcall pulse1_envelope_routine
                                 
                                 	//SWEEP
00025a fcf3                      	sbrc pulse1_sweep, 3 //check if the sweep enable bit is cleared
00025b d1f1                      	rcall pulse1_sweep_routine
                                 
                                 	//LENGTH
                                 	//NOTE: The length routine is relatively simple, so we will not be using clocks to rjmp and ret to a seperate lable
00025c fd95                      	sbrc channel_flags, 5 //check if the length counter halt bit is cleared
00025d c002                      	rjmp sequence_1_3_exit
00025e 10e0                      	cpse pulse1_length_counter, zero //if length counter is already 0, don't decrement
00025f 94ea                      	dec pulse1_length_counter
                                 
                                 sequence_1_3_exit:
000260 e2b1                      	ldi r27, TCA_SINGLE_CMP1_bm | TCA_SINGLE_OVF_bm //clear OVF flag
000261 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
000263 91bf                      	pop r27
000264 bfbf                      	out CPU_SREG, r27
000265 9518                      	reti
                                 
                                 sound_driver:
000266 b7bf                      	in r27, CPU_SREG
000267 93bf                      	push r27
000268 94f8                      	cli
000269 93cf                      	push r28
00026a 93df                      	push r29
                                 
                                 	//SOUND DRIVER
00026b 91b0 280d                 	lds r27, pulse1_pattern_delay
00026d 11b0                      	cpse r27, zero //if the pattern delay is 0, proceed with sound driver procedures
00026e c11b                      	rjmp sound_driver_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 
                                 
                                 sound_driver_channel0:
00026f 91e0 280b                 	lds ZL, pulse1_pattern //current pattern for pulse 1
000271 91f0 280c                 	lds ZH, pulse1_pattern+1
000273 91a0 280e                 	lds r26, pulse1_pattern_offset //current offset in the pattern for pulse 1
000275 91b0 280f                 	lds r27, pulse1_pattern_offset+1
000277 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
000278 1ffb                      	adc ZH, r27
000279 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel0_check_if_note: //check if data is a note (0x00 - 0x56)
00027a 35b7                      	cpi r27, 0x57
00027b f408                      	brsh sound_driver_channel0_check_if_volume
00027c c00d                      	rjmp sound_driver_channel0_note
                                 sound_driver_channel0_check_if_volume: //check if data is volume (0x57-0x66)
00027d 36b7                      	cpi r27, 0x67
00027e f408                      	brsh sound_driver_channel0_check_if_delay
00027f c018                      	rjmp sound_driver_channel0_volume
                                 sound_driver_channel0_check_if_delay: //check if data is a delay (0x67 - 0xE1)
000280 3eb2                      	cpi r27, 0xE2
000281 f408                      	brsh sound_driver_channel0_check_if_instrument
000282 c01f                      	rjmp sound_driver_channel0_delay
                                 sound_driver_channel0_check_if_instrument: //check for instrument flag (0xE2)
000283 f409                      	brne sound_driver_channel0_check_if_release
000284 c022                      	rjmp sound_driver_channel0_instrument_change 
                                 sound_driver_channel0_check_if_release: //check for note release flag (0xE3)
000285 3eb3                      	cpi r27, 0xE3
000286 f409                      	brne sound_driver_channel0_check_if_end
000287 c0ad                      	rjmp sound_driver_channel0_release
                                 sound_driver_channel0_check_if_fx: //binary search for fx flags (0xE4 - 0xFE)
                                 
                                 sound_driver_channel0_check_if_end:
000288 3fbf                      	cpi r27, 0xFF //check if data is the last byte of data (0xFF)
000289 c0d0                      	rjmp sound_driver_channel0_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel0_note:
00028a 93b0 2806                 	sts pulse1_note, r27 //store the note index
00028c 9200 2812                 	sts pulse1_volume_macro_offset, zero //reset all macro offsets
00028e 9200 2817                 	sts pulse1_arpeggio_macro_offset, zero
000290 9200 281d                 	sts pulse1_pitch_macro_offset, zero
000292 9200 2822                 	sts pulse1_hi_pitch_macro_offset, zero
000294 9200 2827                 	sts pulse1_duty_macro_offset, zero
000296 d0df                      	rcall sound_driver_channel0_increment_offset
000297 cfd7                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0_volume:
000298 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
000299 91a0 2800                 	lds r26, pulse1_param
00029b 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
00029c 2bab                      	or r26, r27 //move new VVVV bits into pulse1_param
00029d 93a0 2800                 	sts pulse1_param, r26
00029f 6096                      	sbr channel_flags, 6
0002a0 d0d5                      	rcall sound_driver_channel0_increment_offset
0002a1 cfcd                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0_delay:
0002a2 56b7                      	subi r27, 0x67 //NOTE: the delay values are offset by the highest volume value, which is 0x66
0002a3 93b0 280d                 	sts pulse1_pattern_delay, r27
0002a5 d0d0                      	rcall sound_driver_channel0_increment_offset
0002a6 c0e6                      	rjmp sound_driver_instrument_routine
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change:
0002a7 9200 2810                 	sts pulse1_volume_macro, zero //reset all macro addresses
0002a9 9200 2811                 	sts pulse1_volume_macro+1, zero
0002ab 9200 2815                 	sts pulse1_arpeggio_macro, zero
0002ad 9200 2816                 	sts pulse1_arpeggio_macro+1, zero
0002af 9200 281b                 	sts pulse1_pitch_macro, zero
0002b1 9200 281c                 	sts pulse1_pitch_macro+1, zero
0002b3 9200 2820                 	sts pulse1_hi_pitch_macro, zero
0002b5 9200 2821                 	sts pulse1_hi_pitch_macro+1, zero
0002b7 9200 2825                 	sts pulse1_duty_macro, zero
0002b9 9200 2826                 	sts pulse1_duty_macro+1, zero
                                 
0002bb 9631                      	adiw Z, 1 //point to the byte next to the flag
0002bc 91b4                      	lpm r27, Z //store the instrument offset into r27
0002bd e1e1                      	ldi ZL, LOW(instruments) //point Z to instruments table
0002be e0f1                      	ldi ZH, HIGH(instruments)
0002bf 0feb                      	add ZL, r27 //point Z to offsetted instrument
0002c0 1df0                      	adc ZH, zero
0002c1 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
0002c2 1fff                      	rol ZH
0002c3 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
0002c4 91b4                      	lpm r27, Z
                                 
0002c5 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
0002c6 1fbb                      	rol r27
0002c7 2fea                      	mov ZL, r26
0002c8 2ffb                      	mov ZH, r27
0002c9 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
0002ca 9632                      	adiw Z, 2 //point Z to the address of the macro
0002cb e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel0_instrument_change_macro_loop:
0002cc 95aa                      	dec r26
0002cd f1e1                      	breq sound_driver_channel0_instrument_change_exit
0002ce 95b6                      	lsr r27
0002cf f008                      	brcs sound_driver_channel0_instrument_change_load_macro
0002d0 cffb                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro:
0002d1 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
0002d2 91d5                      	lpm r29, Z+
                                 
0002d3 30a5                      	cpi r26, 5
0002d4 f039                      	breq sound_driver_channel0_instrument_change_load_macro_volume
0002d5 30a4                      	cpi r26, 4
0002d6 f079                      	breq sound_driver_channel0_instrument_change_load_macro_arpeggio
0002d7 30a3                      	cpi r26, 3
0002d8 f099                      	breq sound_driver_channel0_instrument_change_load_macro_pitch
0002d9 30a2                      	cpi r26, 2
0002da f0d9                      	breq sound_driver_channel0_instrument_change_load_macro_hi_pitch
0002db c024                      	rjmp sound_driver_channel0_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel0_instrument_change_load_macro_volume:
0002dc 93c0 2810                 	sts pulse1_volume_macro, r28
0002de 93d0 2811                 	sts pulse1_volume_macro+1, r29
0002e0 d037                      	rcall sound_driver_channel0_instrument_change_read_header
0002e1 93c0 2814                 	sts pulse1_volume_macro_release, r28
0002e3 93d0 2813                 	sts pulse1_volume_macro_loop, r29
0002e5 cfe6                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 	
                                 sound_driver_channel0_instrument_change_load_macro_arpeggio:
0002e6 93c0 2815                 	sts pulse1_arpeggio_macro, r28
0002e8 93d0 2816                 	sts pulse1_arpeggio_macro+1, r29
0002ea d038                      	rcall sound_driver_channel0_instrument_change_read_header_arpeggio
0002eb cfe0                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_pitch:
0002ec 93c0 281b                 	sts pulse1_pitch_macro, r28
0002ee 93d0 281c                 	sts pulse1_pitch_macro+1, r29
0002f0 d027                      	rcall sound_driver_channel0_instrument_change_read_header
0002f1 93c0 2814                 	sts pulse1_volume_macro_release, r28
0002f3 93d0 2813                 	sts pulse1_volume_macro_loop, r29
0002f5 cfd6                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_hi_pitch:
0002f6 93c0 2820                 	sts pulse1_hi_pitch_macro, r28
0002f8 93d0 2821                 	sts pulse1_hi_pitch_macro+1, r29
0002fa d01d                      	rcall sound_driver_channel0_instrument_change_read_header
0002fb 93c0 2814                 	sts pulse1_volume_macro_release, r28
0002fd 93d0 2813                 	sts pulse1_volume_macro_loop, r29
0002ff cfcc                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_duty:
000300 93c0 2825                 	sts pulse1_duty_macro, r28
000302 93d0 2826                 	sts pulse1_duty_macro+1, r29
000304 d013                      	rcall sound_driver_channel0_instrument_change_read_header
000305 93c0 2814                 	sts pulse1_volume_macro_release, r28
000307 93d0 2813                 	sts pulse1_volume_macro_loop, r29
000309 cfc2                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_exit:
00030a e0a3                      	ldi r26, 0x03
00030b e0b2                      	ldi r27, 0x02
00030c 93b0 2812                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
00030e 93a0 2817                 	sts pulse1_arpeggio_macro_offset, r26
000310 93b0 281d                 	sts pulse1_pitch_macro_offset, r27
000312 93b0 2822                 	sts pulse1_hi_pitch_macro_offset, r27
000314 93b0 2827                 	sts pulse1_duty_macro_offset, r27
000316 d069                      	rcall sound_driver_channel0_increment_offset_twice
000317 cf57                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_channel0_instrument_change_read_header:
000318 93ef                      	push ZL
000319 93ff                      	push ZH
00031a 2fec                      	mov ZL, r28
00031b 2ffd                      	mov ZH, r29
00031c 0fee                      	lsl ZL
00031d 1fff                      	rol ZH
00031e 91c5                      	lpm r28, Z+
00031f 91d4                      	lpm r29, Z
000320 91ff                      	pop ZH
000321 91ef                      	pop ZL
000322 9508                      	ret
                                 
                                 sound_driver_channel0_instrument_change_read_header_arpeggio:
000323 93ef                      	push ZL
000324 93ff                      	push ZH
000325 2fec                      	mov ZL, r28
000326 2ffd                      	mov ZH, r29
000327 0fee                      	lsl ZL
000328 1fff                      	rol ZH
000329 91c5                      	lpm r28, Z+
00032a 91d5                      	lpm r29, Z+
00032b 93c0 2819                 	sts pulse1_arpeggio_macro_release, r28
00032d 93d0 2818                 	sts pulse1_arpeggio_macro_loop, r29
00032f 91c4                      	lpm r28, Z
000330 93c0 281a                 	sts pulse1_arpeggio_macro_mode, r28
000332 91ff                      	pop ZH
000333 91ef                      	pop ZL
000334 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel0_release:
                                 sound_driver_channel0_release_volume:
000335 91b0 2814                 	lds r27, pulse1_volume_macro_release
000337 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
000338 f019                      	breq sound_driver_channel0_release_arpeggio //if the macro has no release flag, check the next macro
000339 95b3                      	inc r27
00033a 93b0 2812                 	sts pulse1_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel0_release_arpeggio:
00033c 91b0 2819                 	lds r27, pulse1_arpeggio_macro_release
00033e 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
00033f f019                      	breq sound_driver_channel0_release_pitch
000340 95b3                      	inc r27
000341 93b0 2817                 	sts pulse1_arpeggio_macro_offset, r27
                                 sound_driver_channel0_release_pitch:
000343 91b0 281f                 	lds r27, pulse1_pitch_macro_release
000345 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
000346 f019                      	breq sound_driver_channel0_release_hi_pitch
000347 95b3                      	inc r27
000348 93b0 281d                 	sts pulse1_pitch_macro_offset, r27
                                 sound_driver_channel0_release_hi_pitch:
00034a 91b0 2824                 	lds r27, pulse1_hi_pitch_macro_release
00034c 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
00034d f019                      	breq sound_driver_channel0_release_duty
00034e 95b3                      	inc r27
00034f 93b0 2822                 	sts pulse1_hi_pitch_macro_offset, r27
                                 sound_driver_channel0_release_duty:
000351 91b0 2829                 	lds r27, pulse1_duty_macro_release
000353 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
000354 f019                      	breq sound_driver_channel0_release_exit
000355 95b3                      	inc r27
000356 93b0 2827                 	sts pulse1_duty_macro_offset, r27
                                 sound_driver_channel0_release_exit:
000358 d01d                      	rcall sound_driver_channel0_increment_offset
000359 cf15                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0_next_pattern:
00035a 91e0 2807                 	lds ZL, song_frames
00035c 91f0 2808                 	lds ZH, song_frames+1
00035e 91a0 2809                 	lds r26, song_frame_offset //we must offset to the appropriate channel
000360 91b0 280a                 	lds r27, song_frame_offset+1
000362 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
000363 93a0 2809                 	sts song_frame_offset, r26
000365 93b0 280a                 	sts song_frame_offset+1, r27
                                 	//adiw r27:r26, 2 //offset for channel 1 (test)
000367 0fea                      	add ZL, r26
000368 1ffb                      	adc ZH, r27
                                 
000369 91a5                      	lpm r26, Z+ //load the address of the next pattern
00036a 91b4                      	lpm r27, Z
00036b 0faa                      	lsl r26
00036c 1fbb                      	rol r27
00036d 93a0 280b                 	sts pulse1_pattern, r26
00036f 93b0 280c                 	sts pulse1_pattern+1, r27
                                 
000371 9200 280e                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
000373 9200 280f                 	sts pulse1_pattern_offset+1, zero
000375 cef9                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0_increment_offset:
000376 91e0 280e                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
000378 91f0 280f                 	lds ZH, pulse1_pattern_offset+1
00037a 9631                      	adiw Z, 1
00037b 93e0 280e                 	sts pulse1_pattern_offset, ZL
00037d 93f0 280f                 	sts pulse1_pattern_offset+1, ZH
00037f 9508                      	ret
                                 
                                 sound_driver_channel0_increment_offset_twice: //used for data that takes up 2 bytes worth of space
000380 91e0 280e                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
000382 91f0 280f                 	lds ZH, pulse1_pattern_offset+1
000384 9632                      	adiw Z, 2 //increment the pointer twice
000385 93e0 280e                 	sts pulse1_pattern_offset, ZL
000387 93f0 280f                 	sts pulse1_pattern_offset+1, ZH
000389 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_decrement_frame_delay:
00038a 95ba                      	dec r27
00038b 93b0 280d                 	sts pulse1_pattern_delay, r27
                                 
                                 sound_driver_instrument_routine:
                                 sound_driver_instrument_routine_channel0_volume:
00038d 91e0 2810                 	lds ZL, pulse1_volume_macro
00038f 91f0 2811                 	lds ZH, pulse1_volume_macro+1
000391 9630                      	adiw Z, 0
000392 f109                      	breq sound_driver_instrument_routine_channel0_volume_default //if no volume macro is in use, use default multiplier of F
000393 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
000394 1fff                      	rol ZH
000395 91a0 2812                 	lds r26, pulse1_volume_macro_offset
000397 0fea                      	add ZL, r26
000398 1df0                      	adc ZH, zero
                                 
000399 91b0 2814                 	lds r27, pulse1_volume_macro_release
00039b 17ba                      	cp r27, r26
00039c f429                      	brne sound_driver_instrument_routine_channel0_volume_increment //if the current offset is not equal to the release index, increment the offset
00039d 91a0 2813                 	lds r26, pulse1_volume_macro_loop
00039f 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0003a0 f040                      	brlo sound_driver_instrument_routine_channel0_volume_macro_end_flag+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index
0003a1 c003                      	rjmp sound_driver_instrument_routine_channel0_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_volume_increment:
0003a2 95a3                      	inc r26 //increment the macro offset
0003a3 93a0 2812                 	sts pulse1_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_volume_read:
0003a5 91b4                      	lpm r27, Z //load volume data into r27
0003a6 3fbf                      	cpi r27, 0xFF //check for macro end flag
0003a7 f429                      	brne sound_driver_instrument_routine_channel0_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag:
0003a8 91b0 2813                 	lds r27, pulse1_volume_macro_loop //load the loop index
0003aa 93b0 2812                 	sts pulse1_volume_macro_offset, r27 //store the loop index into the offset
0003ac cfe0                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel0_volume_calculate:
0003ad e5ea                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
0003ae e0f9                      	ldi ZH, HIGH(volumes << 1)
                                 
0003af 95b3                      	inc r27
                                 sound_driver_instrument_routine_channel0_volume_table_offset:
0003b0 95ba                      	dec r27
0003b1 f041                      	breq sound_driver_instrument_routine_channel0_volume_load
0003b2 9670                      	adiw Z, 16 //move to next row in volume table
0003b3 cffc                      	rjmp sound_driver_instrument_routine_channel0_volume_table_offset
                                 
                                 sound_driver_instrument_routine_channel0_volume_default:
0003b4 91b0 2800                 	lds r27, pulse1_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
0003b6 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
0003b7 93b0 2805                 	sts pulse1_output_volume, r27
0003b9 c008                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load:
0003ba 91b0 2800                 	lds r27, pulse1_param //load main volume
0003bc 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
0003bd 0feb                      	add ZL, r27 //offset the volume table by the main volume
0003be 1df0                      	adc ZH, zero
0003bf 91b4                      	lpm r27, Z
0003c0 93b0 2805                 	sts pulse1_output_volume, r27 //store the new output volume
                                 	
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio:
0003c2 91e0 2815                 	lds ZL, pulse1_arpeggio_macro
0003c4 91f0 2816                 	lds ZH, pulse1_arpeggio_macro+1
0003c6 9630                      	adiw Z, 0
0003c7 f1d9                      	breq sound_driver_instrument_routine_channel0_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
0003c8 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0003c9 1fff                      	rol ZH
0003ca 91a0 2817                 	lds r26, pulse1_arpeggio_macro_offset
0003cc 0fea                      	add ZL, r26
0003cd 1df0                      	adc ZH, zero
                                 
0003ce 91b0 2819                 	lds r27, pulse1_arpeggio_macro_release
0003d0 17ba                      	cp r27, r26
0003d1 f429                      	brne sound_driver_instrument_routine_channel0_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
0003d2 91a0 2818                 	lds r26, pulse1_arpeggio_macro_loop
0003d4 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0003d5 f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
0003d6 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_increment:
0003d7 95a3                      	inc r26 //increment the macro offset
0003d8 93a0 2817                 	sts pulse1_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_read:
0003da 91b4                      	lpm r27, Z //load arpeggio data into r27
0003db 38b0                      	cpi r27, 0x80 //check for macro end flag
0003dc f4f9                      	brne sound_driver_instrument_routine_channel0_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_check_mode:
0003dd 50a1                      	subi r26, 1 //keep the offset at the end flag
0003de 93a0 2817                 	sts pulse1_arpeggio_macro_offset, r26
0003e0 91b0 281a                 	lds r27, pulse1_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
0003e2 30b1                      	cpi r27, 0x01
0003e3 f048                      	brlo sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_release:
0003e4 91b0 2819                 	lds r27, pulse1_arpeggio_macro_release
0003e6 3fbf                      	cpi r27, 0xFF
0003e7 f4d9                      	brne sound_driver_instrument_routine_channel0_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_loop:
0003e8 91b0 2818                 	lds r27, pulse1_arpeggio_macro_loop
0003ea 3fbf                      	cpi r27, 0xFF
0003eb f469                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
0003ec c016                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute:
0003ed 91b0 2819                 	lds r27, pulse1_arpeggio_macro_release
0003ef 3fbf                      	cpi r27, 0xFF
0003f0 f421                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_check_loop:
0003f1 91b0 2818                 	lds r27, pulse1_arpeggio_macro_loop //load the loop index
0003f3 3fbf                      	cpi r27, 0xFF //check if loop flag exists
0003f4 f421                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_no_loop:
0003f5 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
0003f6 93a0 2817                 	sts pulse1_arpeggio_macro_offset, r26 //store the last valid index into the offset
0003f8 cfc9                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload:
0003f9 93b0 2817                 	sts pulse1_arpeggio_macro_offset, r27 //store the loop index into the offset
0003fb cfc6                      	rjmp sound_driver_instrument_routine_channel0_arpeggio //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process:
0003fc 91a0 281a                 	lds r26, pulse1_arpeggio_macro_mode
0003fe 30a0                      	cpi r26, 0x00 //absolute mode
0003ff f031                      	breq sound_driver_instrument_routine_channel0_arpeggio_process_absolute
000400 30a1                      	cpi r26, 0x01 //fixed mode
000401 f081                      	breq sound_driver_instrument_routine_channel0_arpeggio_process_fixed
000402 c011                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_default:
000403 91a0 2806                 	lds r26, pulse1_note //load the current note index
000405 c020                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute:
000406 91a0 2806                 	lds r26, pulse1_note //load the current note index
000408 0fab                      	add r26, r27 //offset the note with the arpeggio data
000409 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
00040a c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_add:
00040b 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
00040c f0c8                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
00040d e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
00040e c017                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract:
00040f fda7                      	sbrc r26, 7 //check if result is negative
000410 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
000411 c014                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_fixed:
000412 2fab                      	mov r26, r27 //move the arpeggio data into r26
000413 c012                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative:
000414 91a0 2806                 	lds r26, pulse1_note //load the current note index
000416 0fab                      	add r26, r27 //offset the note with the arpeggio data
000417 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
000418 c008                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_add:
000419 93a0 2806                 	sts pulse1_note, r26 //NOTE: relative mode modifies the original note index
00041b 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
00041c f048                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
00041d e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
00041e 93a0 2806                 	sts pulse1_note, r26
000420 c005                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract:
000421 fda7                      	sbrc r26, 7 //check if result is negative
000422 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
000423 93a0 2806                 	sts pulse1_note, r26
000425 c000                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_load:
000426 e3e4                      	ldi ZL, LOW(note_table << 1) //load in note table
000427 e0f0                      	ldi ZH, HIGH(note_table << 1)
000428 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
000429 0fea                      	add ZL, r26 //add offset
00042a 1df0                      	adc ZH, zero
00042b 91a5                      	lpm r26, Z+ //load bytes
00042c 91b4                      	lpm r27, Z
00042d 93a0 0a8c                 	sts TCB0_CCMPL, r26 //load the LOW bits for timer
00042f 93b0 0a8d                 	sts TCB0_CCMPH, r27 //load the HIGH bits for timer
                                 /*	sts TCB0_CNTL, zero
                                 	sts TCB0_CNTH, zero*/
000431 c000                      	rjmp sound_driver_instrument_routine_channel0_pitch
                                 
                                 sound_driver_instrument_routine_channel0_pitch:
000432 91e0 281b                 	lds ZL, pulse1_pitch_macro
000434 91f0 281c                 	lds ZH, pulse1_pitch_macro+1
                                 
000436 91e0 2820                 	lds ZL, pulse1_hi_pitch_macro
000438 91f0 2821                 	lds ZH, pulse1_hi_pitch_macro+1
                                 
00043a 91e0 2825                 	lds ZL, pulse1_duty_macro
00043c 91f0 2826                 	lds ZH, pulse1_duty_macro+1
                                 
00043e c000                      	rjmp sound_driver_exit
                                 
                                 sound_driver_exit:
00043f 91df                      	pop r29
000440 91cf                      	pop r28
000441 ce17                      	rjmp sequence_1_3 + 3 //+3 is to skip the stack instructions since we already pushed them
                                 
                                 //PULSE 1 ROUTINES
                                 pulse1_sequence_routine:
000442 b7bf                      	in r27, CPU_SREG
000443 93bf                      	push r27
000444 94f8                      	cli
                                 
000445 0cdd                      	lsl pulse1_sequence //shifts sequence to the left
000446 1cd0                      	adc pulse1_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
000447 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
000448 93b0 0a86                 	sts TCB0_INTFLAGS, r27
00044a 91bf                      	pop r27
00044b bfbf                      	out CPU_SREG, r27
00044c 9518                      	reti
                                 
                                 pulse1_sweep_routine:
00044d 2dbf                      	mov r27, pulse1_sweep
00044e 70b7                      	andi r27, 0x07 //mask for period divider bits
00044f f4f9                      	brne pulse1_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse1_sweep_routine_action: //if the divider is == 0, update the pulse timer period
000450 93df                      	push r29
000451 2ddf                      	mov r29, pulse1_sweep
000452 95d2                      	swap r29
000453 70d7                      	andi r29, 0x07 //mask for shift bits
000454 f409                      	brne PC+2 //check of shift == 0
000455 91df                      	pop r29
000456 c019                      	rjmp pulse1_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
000457 91a0 0a8c                 	lds r26, TCB0_CCMPL
000459 91b0 0a8d                 	lds r27, TCB0_CCMPH
00045b 95b6                      	lsr r27
00045c 95a7                      	ror r26
00045d 95da                      	dec r29
00045e f7e1                      	brne PC-3 //keep looping/shifting until shift count is 0
                                 
00045f fef7                      	sbrs pulse1_sweep, 7 //check the negate flag
000460 c002                      	rjmp PC+3 //if negate flag was clear, go straight to addition
                                 
000461 95a0                      	com r26 //pulse1 uses one's complement if the negate flag is set
000462 95b0                      	com r27
                                 
000463 91d0 0a8c                 	lds r29, TCB0_CCMPL //perform addition to get new timer period
000465 0fad                      	add r26, r29
000466 91d0 0a8d                 	lds r29, TCB0_CCMPH
000468 1fbd                      	adc r27, r29
                                 
000469 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new LOW bits for timer
00046b 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new HIGH bits for timer
                                 
                                 	//sts pulse1_timerL, r26
                                 	//sts pulse1_timerH, r27
                                 
                                 /*	//Sweep Test
                                 	mov r29, pulse1_sweep //invert the negate bit
                                 	ldi r27, 0b10000000
                                 	eor r29, r27
                                 	ori r29, 0b01111111
                                 
                                 	lds r27, pulse1_sweep_param //reload the pulse sweep divider params
                                 	swap r27
                                 	ori r27, 0b10000000
                                 	and r27, r29
                                 	mov pulse1_sweep, r27
                                 	sbr channel_flags, 0b10000000*/
                                 	
00046d 91df                      	pop r29
00046e c001                      	rjmp pulse1_sweep_routine_check_reload
                                 
                                 pulse1_sweep_routine_decrement_divider:
00046f 94fa                      	dec pulse1_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse1_sweep_routine_check_reload:
000470 ff97                      	sbrs channel_flags, 7 //if the reload flag is set, reload the sweep divider
000471 9508                      	ret
                                 
                                 pulse1_sweep_reload:
000472 90f0 2801                 	lds pulse1_sweep, pulse1_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
000474 94f2                      	swap pulse1_sweep //bring data from high byte to low byte
000475 779f                      	cbr channel_flags, 0b10000000 //clear ready flag
000476 9508                      	ret
                                 
                                 pulse1_envelope_routine:
000477 fd96                      	sbrc channel_flags, 6 //check if start flag is cleared
000478 c010                      	rjmp pulse1_envelope_routine_clear_start
                                 
000479 3000                      	cpi pulse1_volume_divider, 0x00 //check if the divider is 0
00047a f011                      	breq PC+3 //if the divider == 0, check loop flag
00047b 950a                      	dec pulse1_volume_divider //if the divider != 0, decrement and return
00047c 9508                      	ret
                                 
00047d 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the divider == 0, reset the divider period
00047f 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
000480 ff95                      	sbrs channel_flags, 5 //check if the loop flag is set
000481 c002                      	rjmp pulse1_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
000482 e01f                      	ldi pulse1_volume_decay, 0x0F //if the loop flag is set, reset decay and return
000483 9508                      	ret
                                 
                                 pulse1_envelope_routine_decrement_decay:
000484 3010                      	cpi pulse1_volume_decay, 0x00 //check if the decay is 0
000485 f409                      	brne PC+2 //if decay != 0, go decrement
000486 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
000487 951a                      	dec pulse1_volume_decay
000488 9508                      	ret
                                 
                                 pulse1_envelope_routine_clear_start:
000489 7b9f                      	cbr channel_flags, 0b01000000 //if the start flag is set, clear it
00048a 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the start flag is set, reset the divider period
00048c 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
00048d e01f                      	ldi pulse1_volume_decay, 0x0F //if the start flag is set, reset decay
00048e 9508                      	ret
                                 
                                 //CONVERTERS (TABLES)
                                 //converts and loads 5 bit length to corresponding 8 bit length value into r29
                                 length_converter:
00048f e0f9                      	ldi ZH, HIGH(length << 1)
000490 e2ea                      	ldi ZL, LOW(length << 1)
000491 0fed                      	add ZL, r29
000492 1df0                      	adc ZH, zero
000493 91d4                      	lpm r29, Z
000494 9508                      	ret
                                 
000495 7f05
000496 010a
000497 0214
000498 0328
000499 0450
00049a 051e
00049b 0607
00049c 070d
00049d 0806
00049e 090c
00049f 0a18
0004a0 0b30
0004a1 0c60
0004a2 0d24
0004a3 0e08
0004a4 0f10                      length: .db $05, $7F, $0A, $01, $14, $02, $28, $03, $50, $04, $1E, $05, $07, $06, $0D, $07, $06, $08, $0C, $09, $18, $0A, $30, $0B, $60, $0C, $24, $0D, $08, $0E, $10, $0F
                                 
                                 //loads pulse sequence into r29
                                 duty_cycle_sequences:
0004a5 e0f9                      	ldi ZH, HIGH(sequences << 1)
0004a6 e5e6                      	ldi ZL, LOW(sequences << 1)
0004a7 0fed                      	add ZL, r29
0004a8 1df0                      	adc ZH, zero
0004a9 91d4                      	lpm r29, Z
0004aa 9508                      	ret
                                 
                                 //pulse sequences: 12.5%, 25%, 50%, 75%
0004ab 0301
0004ac fc0f                      sequences: .db 0b00000001, 0b00000011, 0b00001111, 0b11111100
                                 
                                 //famitracker volumes table: http://famitracker.com/wiki/index.php?title=Volume
                                 volumes:
0004ad 0000
0004ae 0000
0004af 0000
0004b0 0000
0004b1 0000
0004b2 0000
0004b3 0000
0004b4 0000                      	.db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
0004b5 0100
0004b6 0101
0004b7 0101
0004b8 0101
0004b9 0101
0004ba 0101
0004bb 0101
0004bc 0101                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
0004bd 0100
0004be 0101
0004bf 0101
0004c0 0101
0004c1 0101
0004c2 0101
0004c3 0101
0004c4 0201                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02
0004c5 0100
0004c6 0101
0004c7 0101
0004c8 0101
0004c9 0101
0004ca 0202
0004cb 0202
0004cc 0302                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03
0004cd 0100
0004ce 0101
0004cf 0101
0004d0 0101
0004d1 0202
0004d2 0202
0004d3 0303
0004d4 0403                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04
0004d5 0100
0004d6 0101
0004d7 0101
0004d8 0202
0004d9 0302
0004da 0303
0004db 0404
0004dc 0504                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05
0004dd 0100
0004de 0101
0004df 0201
0004e0 0202
0004e1 0303
0004e2 0404
0004e3 0504
0004e4 0605                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x06
0004e5 0100
0004e6 0101
0004e7 0201
0004e8 0302
0004e9 0403
0004ea 0504
0004eb 0605
0004ec 0706                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07
0004ed 0100
0004ee 0101
0004ef 0202
0004f0 0303
0004f1 0404
0004f2 0505
0004f3 0606
0004f4 0807                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07, 0x08
0004f5 0100
0004f6 0101
0004f7 0302
0004f8 0403
0004f9 0504
0004fa 0606
0004fb 0707
0004fc 0908                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09
0004fd 0100
0004fe 0201
0004ff 0302
000500 0404
000501 0605
000502 0706
000503 0808
000504 0a09                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A
000505 0100
000506 0201
000507 0302
000508 0504
000509 0605
00050a 0807
00050b 0908
00050c 0b0a                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B
00050d 0100
00050e 0201
00050f 0403
000510 0504
000511 0706
000512 0808
000513 0a09
000514 0c0b                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B, 0x0C
000515 0100
000516 0201
000517 0403
000518 0605
000519 0706
00051a 0908
00051b 0b0a
00051c 0d0c                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D
00051d 0100
00051e 0201
00051f 0403
000520 0605
000521 0807
000522 0a09
000523 0c0b
000524 0e0d                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E
000525 0100
000526 0302
000527 0504
000528 0706
000529 0908
00052a 0b0a
00052b 0d0c


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega4809" register use summary:
x  :   0 y  :   0 z  :  30 r0 :  54 r1 :   0 r2 :   0 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 
r13:   4 r14:   4 r15:   9 r16:   7 r17:   6 r18:   0 r19:   0 r20:   0 
r21:   0 r22:   0 r23:   0 r24:   0 r25:  11 r26:  74 r27: 190 r28:  22 
r29:  45 r30:  40 r31:  40 
Registers used: 14 out of 35 (40.0%)

"ATmega4809" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  12 add   :  13 adiw  :   8 and   :   0 
andi  :  10 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   0 brcs  :   1 break :   0 breq  :  18 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   8 brlt  :   0 brmi  :   0 
brne  :  14 brpl  :   0 brsh  :   4 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :   0 cbr   :   2 
clc   :   0 clh   :   0 cli   :   4 cln   :   0 clr   :   1 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :   2 cp    :   5 cpc   :   0 
cpi   :  31 cpse  :   2 dec   :   8 des   :   0 eor   :   0 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   0 in    :   4 inc   :   8 
jmp   :   6 ld    :   0 ldd   :   0 ldi   :  49 lds   :  64 lpm   :  37 
lsl   :  11 lsr   :   2 mov   :  11 movw  :   0 mul   :   0 muls  :   0 
mulsu :   0 neg   :   0 nop   :   0 or    :   1 ori   :   0 out   :   6 
pop   :  11 push  :  11 rcall :  15 ret   :  13 reti  :   3 rjmp  :  52 
rol   :  10 ror   :   1 sbc   :   0 sbci  :   0 sbi   :   0 sbic  :   0 
sbis  :   0 sbiw  :   0 sbr   :   3 sbrc  :   7 sbrs  :   4 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   : 141 sub   :   0 subi  :   4 swap  :   3 tst   :   0 wdr   :   0 

Instructions used: 43 out of 114 (37.7%)

"ATmega4809" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x000a5a   1636    986   2622   49152   5.3%
[.dseg] 0x002800 0x00282e      0     46     46    6144   0.7%
[.eseg] 0x000000 0x000000      0      0      0     256   0.0%

Assembly complete, 0 errors, 18 warnings
