
AVRASM ver. 2.2.8  C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm Sat Jan 16 18:34:51 2021

C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
                                 
                                 
                                 ; NES_APU_2a03.asm
                                 ;
                                 ; Created: 11/29/2020 1:44:10 AM
                                 ; Author : Tennyson Cheng
                                 ;
                                 
                                 .list
                                 
                                 .dseg
002800                           pulse1_param: .byte 1 //$4000 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002801                           pulse1_sweep_param: .byte 1 //$4001 EPPP.NSSS = Enable, Period, Negate, Shift
                                 //NOTE: In order to account for multiplier, we use 16 instead of 11 bits for the timer
002802                           pulse1_timerL: .byte 1 //$4002 LLLL.LLLL = Low 8 bits for timer
002803                           pulse1_timerH: .byte 1 //$4002 HHHH.HHHH = High 8 bits for timer
002804                           pulse1_length: .byte 1 //$4003 000l.llll = Length counter load
002805                           pulse1_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002806                           pulse1_output_volume: .byte 1 //this is the final output volume of pulse 1
002807                           pulse1_note: .byte 1 //the current note index in the note table
                                 
002808                           pulse2_param: .byte 1 //$4004 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002809                           pulse2_sweep_param: .byte 1 //$4001 EPPP.NSSS = Enable, Period, Negate, Shift
00280a                           pulse2_timerL: .byte 1 //$4005 LLLL.LLLL = Low 8 bits for timer
00280b                           pulse2_timerH: .byte 1 //$4006 HHHH.HHHH = High 8 bits for timer
00280c                           pulse2_length: .byte 1 //$4007 000l.llll = Length counter load
00280d                           pulse2_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
00280e                           pulse2_output_volume: .byte 1 //this is the final output volume of pulse 2
00280f                           pulse2_note: .byte 1 //the current note index in the note table
                                 
002810                           song_frames: .byte 2
002812                           song_frame_offset: .byte 2
002814                           song_size: .byte 2
002816                           song_speed: .byte 1
                                 //song_channel_delay_reload: .byte 1 //bit 0-4 represents channels 0-4. a set bit means that there is a delay that needs to be calculated for that channel.
002817                           song_fx_Bxx: .byte 1
002818                           song_fx_Cxx: .byte 1
002819                           song_fx_Dxx: .byte 1
                                 
                                 //PULSE 1
00281a                           pulse1_pattern: .byte 2
00281c                           pulse1_pattern_delay_rows: .byte 1
00281d                           pulse1_pattern_delay_frames: .byte 1
00281e                           pulse1_pattern_offset: .byte 2
                                 
002820                           pulse1_volume_macro: .byte 2
002822                           pulse1_volume_macro_offset: .byte 1
002823                           pulse1_volume_macro_loop: .byte 1
002824                           pulse1_volume_macro_release: .byte 1
                                 
002825                           pulse1_arpeggio_macro: .byte 2
002827                           pulse1_arpeggio_macro_offset: .byte 1
002828                           pulse1_arpeggio_macro_loop: .byte 1
002829                           pulse1_arpeggio_macro_release: .byte 1
00282a                           pulse1_arpeggio_macro_mode: .byte 1
                                 
00282b                           pulse1_total_pitch_offset: .byte 1 //used to reference the overall change in pitch for the pitch macro
00282c                           pulse1_pitch_macro: .byte 2
00282e                           pulse1_pitch_macro_offset: .byte 1
00282f                           pulse1_pitch_macro_loop: .byte 1
002830                           pulse1_pitch_macro_release: .byte 1
                                 
002831                           pulse1_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
002832                           pulse1_hi_pitch_macro: .byte 2
002834                           pulse1_hi_pitch_macro_offset: .byte 1
002835                           pulse1_hi_pitch_macro_loop: .byte 1
002836                           pulse1_hi_pitch_macro_release: .byte 1
                                 
002837                           pulse1_duty_macro: .byte 2
002839                           pulse1_duty_macro_offset: .byte 1
00283a                           pulse1_duty_macro_loop: .byte 1
00283b                           pulse1_duty_macro_release: .byte 1
                                 
00283c                           pulse1_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
00283e                           pulse1_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002840                           pulse1_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
002842                           pulse1_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
002844                           pulse1_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
002846                           pulse1_fx_3xx_start: .byte 2 //the starting note period
002848                           pulse1_fx_3xx_target: .byte 2 //target note period
00284a                           pulse1_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
00284c                           pulse1_fx_3xx_total_offset: .byte 2
00284e                           pulse1_fx_4xy_speed: .byte 1
00284f                           pulse1_fx_4xy_depth: .byte 1
002850                           pulse1_fx_4xy_phase: .byte 1
002851                           pulse1_fx_7xy_speed: .byte 1
002852                           pulse1_fx_7xy_depth: .byte 1
002853                           pulse1_fx_7xy_phase: .byte 1
002854                           pulse1_fx_7xy_value: .byte 1 //value to offset the volume
002855                           pulse1_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
002856                           pulse1_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002857                           pulse1_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002858                           pulse1_fx_Pxx: .byte 1 //refers to the fine pitch offset set by the Pxx effect
002859                           pulse1_fx_Qxy_target: .byte 2 //target note period
00285b                           pulse1_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
00285d                           pulse1_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
00285f                           pulse1_fx_Rxy_target: .byte 2 //target note period
002861                           pulse1_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
002863                           pulse1_fx_Rxy_total_offset: .byte 2
002865                           pulse1_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002866                           pulse1_fx_Sxx_post: .byte 1
                                 
                                 //PULSE 2
002867                           pulse2_pattern: .byte 2
002869                           pulse2_pattern_delay_rows: .byte 1
00286a                           pulse2_pattern_delay_frames: .byte 1
00286b                           pulse2_pattern_offset: .byte 2
                                 
00286d                           pulse2_volume_macro: .byte 2
00286f                           pulse2_volume_macro_offset: .byte 1
002870                           pulse2_volume_macro_loop: .byte 1
002871                           pulse2_volume_macro_release: .byte 1
                                 
002872                           pulse2_arpeggio_macro: .byte 2
002874                           pulse2_arpeggio_macro_offset: .byte 1
002875                           pulse2_arpeggio_macro_loop: .byte 1
002876                           pulse2_arpeggio_macro_release: .byte 1
002877                           pulse2_arpeggio_macro_mode: .byte 1
                                 
002878                           pulse2_total_pitch_offset: .byte 1 //used to reference the overall change in pitch for the pitch macro
002879                           pulse2_pitch_macro: .byte 2
00287b                           pulse2_pitch_macro_offset: .byte 1
00287c                           pulse2_pitch_macro_loop: .byte 1
00287d                           pulse2_pitch_macro_release: .byte 1
                                 
00287e                           pulse2_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00287f                           pulse2_hi_pitch_macro: .byte 2
002881                           pulse2_hi_pitch_macro_offset: .byte 1
002882                           pulse2_hi_pitch_macro_loop: .byte 1
002883                           pulse2_hi_pitch_macro_release: .byte 1
                                 
002884                           pulse2_duty_macro: .byte 2
002886                           pulse2_duty_macro_offset: .byte 1
002887                           pulse2_duty_macro_loop: .byte 1
002888                           pulse2_duty_macro_release: .byte 1
                                 
002889                           pulse2_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
00288b                           pulse2_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
00288d                           pulse2_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00288f                           pulse2_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
002891                           pulse2_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
002893                           pulse2_fx_3xx_start: .byte 2 //the starting note period
002895                           pulse2_fx_3xx_target: .byte 2 //target note period
002897                           pulse2_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
002899                           pulse2_fx_3xx_total_offset: .byte 2
00289b                           pulse2_fx_4xy_speed: .byte 1
00289c                           pulse2_fx_4xy_depth: .byte 1
00289d                           pulse2_fx_4xy_phase: .byte 1
00289e                           pulse2_fx_7xy_speed: .byte 1
00289f                           pulse2_fx_7xy_depth: .byte 1
0028a0                           pulse2_fx_7xy_phase: .byte 1
0028a1                           pulse2_fx_7xy_value: .byte 1 //value to offset the volume
0028a2                           pulse2_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
0028a3                           pulse2_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028a4                           pulse2_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028a5                           pulse2_fx_Pxx: .byte 1 //refers to the fine pitch offset set by the Pxx effect
0028a6                           pulse2_fx_Qxy_target: .byte 2 //target note period
0028a8                           pulse2_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
0028aa                           pulse2_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
0028ac                           pulse2_fx_Rxy_target: .byte 2 //target note period
0028ae                           pulse2_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
0028b0                           pulse2_fx_Rxy_total_offset: .byte 2
0028b2                           pulse2_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
0028b3                           pulse2_fx_Sxx_post: .byte 1
                                 
0028b4                           triangle_pattern_delay: .byte 1
0028b5                           noise_pattern_delay: .byte 1
0028b6                           dcpm_pattern_delay: .byte 1
                                 
                                 .cseg
                                 
                                 //NOTE: zero is defined in order to use the cp instruction without the need to load 0x00 into a register beforehand
                                 .def zero = r2
                                 .def channel_flags = r25 //[pulse1.pulse2] RSlc.RSlc = Reload, Start, Length halt/Loop, Constant volume
                                 .def pulse1_sequence = r10
                                 .def pulse1_length_counter = r11
                                 .def pulse1_sweep = r12 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse1_volume_divider = r16 //0000.PPPP = Period divider
                                 .def pulse1_volume_decay = r17 //0000.dddd = Decay
                                 .def pulse2_sequence = r13
                                 .def pulse2_length_counter = r14
                                 .def pulse2_sweep = r15 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse2_volume_divider = r18 //0000.PPPP = Period divider
                                 .def pulse2_volume_decay = r19 //0000.dddd = Decay
                                 
                                 reset:
000000 940c 11d5                 	jmp init
                                 
                                 .org TCA0_OVF_vect
00000e 940c 14a8                 	jmp sound_driver
                                 
                                 .org TCA0_CMP0_vect
000012 940c 13e0                 	jmp sequence_0_2
                                 
                                 .org TCA0_CMP1_vect
000014 940c 13eb                 	jmp sequence_1_3
                                 
                                 .org TCA0_CMP2_vect
000016 940c 13e0                 	jmp sequence_0_2
                                 
                                 .org TCB0_INT_vect
000018 940c 1402                 	jmp pulse1_sequence_routine
                                 
                                 .org TCB1_INT_vect
00001a 940c 144f                 	jmp pulse2_sequence_routine
                                 
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(66): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(67): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(68): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(69): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(70): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(71): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(72): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(73): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(74): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(75): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(76): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(77): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(78): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(79): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(80): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(81): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(83): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(84): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(86): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(87): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(88): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(90): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(91): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(92): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(94): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(95): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(96): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(97): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(100): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(101): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(102): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(105): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(107): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(108): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(109): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(116): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(117): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(118): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(123): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(126): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(128): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(129): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(130): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(131): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(132): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(133): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(134): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(135): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(136): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(139): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(140): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(141): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(145): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(146): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(147): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(148): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(150): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(151): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(152): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(153): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(155): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(156): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(157): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(158): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(159): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(160): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(163): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(164): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(165): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(276): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(277): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(278): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(280): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(285): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(286): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(287): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(288): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(289): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(290): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(291): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(292): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(293): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(295): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(299): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(300): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(301): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(302): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(304): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(305): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(307): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(311): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(315): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(316): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(317): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(318): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(320): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(321): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(322): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(325): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(326): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(329): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(330): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(332): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(339): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(340): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
                                 .list
                                 
                                 init:
                                 	//MAIN CLOCK
0011d5 edc8                      	ldi r28, CPU_CCP_IOREG_gc //protected write
0011d6 93c0 0034                 	sts CPU_CCP, r28
0011d8 e0c0                      	ldi r28, 0 << CLKCTRL_PEN_bp //disable prescaler for 20 MHz on main clock
0011d9 93c0 0061                 	sts CLKCTRL_MCLKCTRLB, r28
                                 
                                 	//ZERO
0011db 2422                      	clr zero
                                 
                                 	//MEMORY
0011dc e3c0                      	ldi r28, 0b00110000
0011dd 93c0 2800                 	sts pulse1_param, r28
0011df e8c0                      	ldi r28, 0b10000000
0011e0 93c0 2801                 	sts pulse1_sweep_param, r28
0011e2 efcf                      	ldi r28, 0xFF
0011e3 93c0 2802                 	sts pulse1_timerL, r28
0011e5 93c0 2803                 	sts pulse1_timerH, r28
0011e7 93c0 2804                 	sts pulse1_length, r28
                                 
0011e9 e3c0                      	ldi r28, 0b00110000
0011ea 93c0 2808                 	sts pulse2_param, r28
0011ec e8c0                      	ldi r28, 0b10000000
0011ed 93c0 2809                 	sts pulse2_sweep_param, r28
0011ef efcf                      	ldi r28, 0xFF
0011f0 93c0 280a                 	sts pulse2_timerL, r28
0011f2 93c0 280b                 	sts pulse2_timerH, r28
0011f4 93c0 280c                 	sts pulse2_length, r28
                                 
0011f6 e0c2                      	ldi r28, 0x02
0011f7 93c0 2812                 	sts song_frame_offset, r28
0011f9 9220 2813                 	sts song_frame_offset+1, zero
0011fb eee6                      	ldi ZL, LOW(song0_frames << 1)
0011fc e0f1                      	ldi ZH, HIGH(song0_frames << 1)
0011fd 93e0 2810                 	sts song_frames, ZL
0011ff 93f0 2811                 	sts song_frames+1, ZH
001201 91c5                      	lpm r28, Z+ //load the song size
001202 91d5                      	lpm r29, Z+
001203 93c0 2814                 	sts song_size, r28
001205 93d0 2815                 	sts song_size+1, r29
001207 9220 2816                 	sts song_speed, zero
                                 
                                 	//CHANNEL 0
001209 91c5                      	lpm r28, Z+
00120a 91d5                      	lpm r29, Z+
00120b 0fcc                      	lsl r28
00120c 1fdd                      	rol r29
00120d 93c0 281a                 	sts pulse1_pattern, r28
00120f 93d0 281b                 	sts pulse1_pattern+1, r29
001211 9220 281c                 	sts pulse1_pattern_delay_rows, zero
001213 9220 281d                 	sts pulse1_pattern_delay_frames, zero
001215 9220 281e                 	sts pulse1_pattern_offset, zero
001217 9220 281f                 	sts pulse1_pattern_offset+1, zero
                                 
                                 	//CHANNEL 1
001219 91c5                      	lpm r28, Z+
00121a 91d5                      	lpm r29, Z+
00121b 0fcc                      	lsl r28
00121c 1fdd                      	rol r29
00121d 93c0 2867                 	sts pulse2_pattern, r28
00121f 93d0 2868                 	sts pulse2_pattern+1, r29
001221 9220 2869                 	sts pulse2_pattern_delay_rows, zero
001223 9220 286a                 	sts pulse2_pattern_delay_frames, zero
001225 9220 286b                 	sts pulse2_pattern_offset, zero
001227 9220 286c                 	sts pulse2_pattern_offset+1, zero
                                 
                                 	//CHANNEL 0 instrument macros
001229 efcf                      	ldi r28, 0xFF
00122a 9220 2822                 	sts pulse1_volume_macro_offset, zero
00122c 93c0 2823                 	sts pulse1_volume_macro_loop, r28
00122e 93c0 2824                 	sts pulse1_volume_macro_release, r28
001230 9220 2827                 	sts pulse1_arpeggio_macro_offset, zero
001232 93c0 2828                 	sts pulse1_arpeggio_macro_loop, r28
001234 93c0 2829                 	sts pulse1_arpeggio_macro_release, r28
001236 93c0 282a                 	sts pulse1_arpeggio_macro_mode, r28
001238 9220 282e                 	sts pulse1_pitch_macro_offset, zero
00123a 93c0 282f                 	sts pulse1_pitch_macro_loop, r28
00123c 93c0 2830                 	sts pulse1_pitch_macro_release, r28
00123e 9220 2834                 	sts pulse1_hi_pitch_macro_offset, zero
001240 93c0 2835                 	sts pulse1_hi_pitch_macro_loop, r28
001242 93c0 2836                 	sts pulse1_hi_pitch_macro_release, r28
001244 9220 2839                 	sts pulse1_duty_macro_offset, zero
001246 93c0 283a                 	sts pulse1_duty_macro_loop, r28
001248 93c0 283b                 	sts pulse1_duty_macro_release, r28
                                 
00124a 9220 2820                 	sts pulse1_volume_macro, zero
00124c 9220 2821                 	sts pulse1_volume_macro+1, zero
00124e 9220 2825                 	sts pulse1_arpeggio_macro, zero
001250 9220 2826                 	sts pulse1_arpeggio_macro+1, zero
001252 9220 282b                 	sts pulse1_total_pitch_offset, zero
001254 9220 282c                 	sts pulse1_pitch_macro, zero
001256 9220 282d                 	sts pulse1_pitch_macro+1, zero
001258 9220 2831                 	sts pulse1_total_hi_pitch_offset, zero
00125a 9220 2832                 	sts pulse1_hi_pitch_macro, zero
00125c 9220 2833                 	sts pulse1_hi_pitch_macro+1, zero
00125e 9220 2837                 	sts pulse1_duty_macro, zero
001260 9220 2838                 	sts pulse1_duty_macro+1, zero
                                 
                                 	//CHANNEL 0 ENVELOPE
001262 e00f                      	ldi pulse1_volume_divider, 0x0F
001263 9110 2800                 	lds pulse1_volume_decay, pulse1_param
001265 701f                      	andi pulse1_volume_decay, 0x0F //mask for VVVV bits
001266 9190 2800                 	lds channel_flags, pulse1_param
001268 7390                      	andi channel_flags, 0b00110000
001269 6490                      	sbr channel_flags, 0b01000000 //set start flag
00126a 9220 2806                 	sts pulse1_output_volume, zero
00126c 93c0 2805                 	sts pulse1_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 0 LENGTH
00126e 2ebc                      	mov pulse1_length_counter, r28
                                 
                                 	//CHANNEL 0 SEQUENCE
00126f e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
001270 2eac                      	mov pulse1_sequence, r28
                                 
                                 	//CHANNEL 0 SWEEP
001271 90c0 2801                 	lds pulse1_sweep, pulse1_sweep_param
001273 94c2                      	swap pulse1_sweep //swap data from high byte and low byte
001274 6890                      	sbr channel_flags, 0b10000000 //set reload flag
                                 
                                 	//CHANNEL 0 FX
001275 efcf                      	ldi r28, 0xFF
001276 93c0 2817                 	sts song_fx_Bxx, r28
001278 9220 2818                 	sts song_fx_Cxx, zero
00127a 9220 2819                 	sts song_fx_Dxx, zero
00127c 9220 283c                 	sts pulse1_fx_0xy_sequence, zero
00127e 9220 283d                 	sts pulse1_fx_0xy_sequence+1, zero
001280 9220 283e                 	sts pulse1_fx_1xx, zero
001282 9220 283f                 	sts pulse1_fx_1xx+1, zero
001284 9220 2840                 	sts pulse1_fx_1xx_total, zero
001286 9220 2841                 	sts pulse1_fx_1xx_total+1, zero
001288 9220 2842                 	sts pulse1_fx_2xx, zero
00128a 9220 2843                 	sts pulse1_fx_2xx+1, zero
00128c 9220 2844                 	sts pulse1_fx_2xx_total, zero
00128e 9220 2845                 	sts pulse1_fx_2xx_total+1, zero
001290 9220 2846                 	sts pulse1_fx_3xx_start, zero
001292 9220 2847                 	sts pulse1_fx_3xx_start+1, zero
001294 9220 2848                 	sts pulse1_fx_3xx_target, zero
001296 9220 2849                 	sts pulse1_fx_3xx_target+1, zero
001298 9220 284a                 	sts pulse1_fx_3xx_speed, zero
00129a 9220 284b                 	sts pulse1_fx_3xx_speed+1, zero
00129c 9220 284c                 	sts pulse1_fx_3xx_total_offset, zero
00129e 9220 284d                 	sts pulse1_fx_3xx_total_offset+1, zero
0012a0 9220 284e                 	sts pulse1_fx_4xy_speed, zero
0012a2 9220 284f                 	sts pulse1_fx_4xy_depth, zero
0012a4 9220 2850                 	sts pulse1_fx_4xy_phase, zero
0012a6 9220 2851                 	sts pulse1_fx_7xy_speed, zero
0012a8 9220 2852                 	sts pulse1_fx_7xy_depth, zero
0012aa 9220 2853                 	sts pulse1_fx_7xy_phase, zero
0012ac 9220 2854                 	sts pulse1_fx_7xy_value, zero
0012ae 9220 2855                 	sts pulse1_fx_Axy, zero
0012b0 93c0 2856                 	sts pulse1_fx_Gxx_pre, r28
0012b2 93c0 2857                 	sts pulse1_fx_Gxx_post, r28
0012b4 9220 2858                 	sts pulse1_fx_Pxx, zero
0012b6 9220 2859                 	sts pulse1_fx_Qxy_target, zero
0012b8 9220 285a                 	sts pulse1_fx_Qxy_target+1, zero
0012ba 9220 285b                 	sts pulse1_fx_Qxy_speed, zero
0012bc 9220 285c                 	sts pulse1_fx_Qxy_speed+1, zero
0012be 9220 285d                 	sts pulse1_fx_Qxy_total_offset, zero
0012c0 9220 285e                 	sts pulse1_fx_Qxy_total_offset+1, zero
0012c2 9220 285f                 	sts pulse1_fx_Rxy_target, zero
0012c4 9220 2860                 	sts pulse1_fx_Rxy_target+1, zero
0012c6 9220 2861                 	sts pulse1_fx_Rxy_speed, zero
0012c8 9220 2862                 	sts pulse1_fx_Rxy_speed+1, zero
0012ca 9220 2863                 	sts pulse1_fx_Rxy_total_offset, zero
0012cc 9220 2864                 	sts pulse1_fx_Rxy_total_offset+1, zero
0012ce 93c0 2865                 	sts pulse1_fx_Sxx_pre, r28
0012d0 93c0 2866                 	sts pulse1_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 1 instrument macros
0012d2 efcf                      	ldi r28, 0xFF
0012d3 9220 286f                 	sts pulse2_volume_macro_offset, zero
0012d5 93c0 2870                 	sts pulse2_volume_macro_loop, r28
0012d7 93c0 2871                 	sts pulse2_volume_macro_release, r28
0012d9 9220 2874                 	sts pulse2_arpeggio_macro_offset, zero
0012db 93c0 2875                 	sts pulse2_arpeggio_macro_loop, r28
0012dd 93c0 2876                 	sts pulse2_arpeggio_macro_release, r28
0012df 93c0 2877                 	sts pulse2_arpeggio_macro_mode, r28
0012e1 9220 287b                 	sts pulse2_pitch_macro_offset, zero
0012e3 93c0 287c                 	sts pulse2_pitch_macro_loop, r28
0012e5 93c0 287d                 	sts pulse2_pitch_macro_release, r28
0012e7 9220 2881                 	sts pulse2_hi_pitch_macro_offset, zero
0012e9 93c0 2882                 	sts pulse2_hi_pitch_macro_loop, r28
0012eb 93c0 2883                 	sts pulse2_hi_pitch_macro_release, r28
0012ed 9220 2886                 	sts pulse2_duty_macro_offset, zero
0012ef 93c0 2887                 	sts pulse2_duty_macro_loop, r28
0012f1 93c0 2888                 	sts pulse2_duty_macro_release, r28
                                 
0012f3 9220 286d                 	sts pulse2_volume_macro, zero
0012f5 9220 286e                 	sts pulse2_volume_macro+1, zero
0012f7 9220 2872                 	sts pulse2_arpeggio_macro, zero
0012f9 9220 2873                 	sts pulse2_arpeggio_macro+1, zero
0012fb 9220 2878                 	sts pulse2_total_pitch_offset, zero
0012fd 9220 2879                 	sts pulse2_pitch_macro, zero
0012ff 9220 287a                 	sts pulse2_pitch_macro+1, zero
001301 9220 287e                 	sts pulse2_total_hi_pitch_offset, zero
001303 9220 287f                 	sts pulse2_hi_pitch_macro, zero
001305 9220 2880                 	sts pulse2_hi_pitch_macro+1, zero
001307 9220 2884                 	sts pulse2_duty_macro, zero
001309 9220 2885                 	sts pulse2_duty_macro+1, zero
                                 
                                 	//CHANNEL 1 ENVELOPE
00130b e02f                      	ldi pulse2_volume_divider, 0x0F
00130c 9130 2808                 	lds pulse2_volume_decay, pulse2_param
00130e 703f                      	andi pulse2_volume_decay, 0x0F //mask for VVVV bits
00130f 91d0 2808                 	lds r29, pulse2_param
001311 73d0                      	andi r29, 0b00110000
001312 62d0                      	sbr r29, 0b0100000 //set start flag
001313 95d2                      	swap r29
001314 2b9d                      	or channel_flags, r29
001315 9220 280e                 	sts pulse2_output_volume, zero
001317 93c0 280d                 	sts pulse2_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 1 LENGTH
001319 2eec                      	mov pulse2_length_counter, r28
                                 
                                 	//CHANNEL 1 SEQUENCE
00131a e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
00131b 2edc                      	mov pulse2_sequence, r28
                                 
                                 	//CHANNEL 1 SWEEP
00131c 90f0 2809                 	lds pulse2_sweep, pulse2_sweep_param
00131e 94f2                      	swap pulse2_sweep //swap data from high byte and low byte
00131f 6098                      	sbr channel_flags, 0b00001000 //set reload flag
                                 
                                 	//CHANNEL 1 FX
001320 efcf                      	ldi r28, 0xFF
001321 93c0 2817                 	sts song_fx_Bxx, r28
001323 9220 2818                 	sts song_fx_Cxx, zero
001325 9220 2819                 	sts song_fx_Dxx, zero
001327 9220 2889                 	sts pulse2_fx_0xy_sequence, zero
001329 9220 288a                 	sts pulse2_fx_0xy_sequence+1, zero
00132b 9220 288b                 	sts pulse2_fx_1xx, zero
00132d 9220 288c                 	sts pulse2_fx_1xx+1, zero
00132f 9220 288d                 	sts pulse2_fx_1xx_total, zero
001331 9220 288e                 	sts pulse2_fx_1xx_total+1, zero
001333 9220 288f                 	sts pulse2_fx_2xx, zero
001335 9220 2890                 	sts pulse2_fx_2xx+1, zero
001337 9220 2891                 	sts pulse2_fx_2xx_total, zero
001339 9220 2892                 	sts pulse2_fx_2xx_total+1, zero
00133b 9220 2893                 	sts pulse2_fx_3xx_start, zero
00133d 9220 2894                 	sts pulse2_fx_3xx_start+1, zero
00133f 9220 2895                 	sts pulse2_fx_3xx_target, zero
001341 9220 2896                 	sts pulse2_fx_3xx_target+1, zero
001343 9220 2897                 	sts pulse2_fx_3xx_speed, zero
001345 9220 2898                 	sts pulse2_fx_3xx_speed+1, zero
001347 9220 2899                 	sts pulse2_fx_3xx_total_offset, zero
001349 9220 289a                 	sts pulse2_fx_3xx_total_offset+1, zero
00134b 9220 289b                 	sts pulse2_fx_4xy_speed, zero
00134d 9220 289c                 	sts pulse2_fx_4xy_depth, zero
00134f 9220 289d                 	sts pulse2_fx_4xy_phase, zero
001351 9220 289e                 	sts pulse2_fx_7xy_speed, zero
001353 9220 289f                 	sts pulse2_fx_7xy_depth, zero
001355 9220 28a0                 	sts pulse2_fx_7xy_phase, zero
001357 9220 28a1                 	sts pulse2_fx_7xy_value, zero
001359 9220 28a2                 	sts pulse2_fx_Axy, zero
00135b 93c0 28a3                 	sts pulse2_fx_Gxx_pre, r28
00135d 93c0 28a4                 	sts pulse2_fx_Gxx_post, r28
00135f 9220 28a5                 	sts pulse2_fx_Pxx, zero
001361 9220 28a6                 	sts pulse2_fx_Qxy_target, zero
001363 9220 28a7                 	sts pulse2_fx_Qxy_target+1, zero
001365 9220 28a8                 	sts pulse2_fx_Qxy_speed, zero
001367 9220 28a9                 	sts pulse2_fx_Qxy_speed+1, zero
001369 9220 28aa                 	sts pulse2_fx_Qxy_total_offset, zero
00136b 9220 28ab                 	sts pulse2_fx_Qxy_total_offset+1, zero
00136d 9220 28ac                 	sts pulse2_fx_Rxy_target, zero
00136f 9220 28ad                 	sts pulse2_fx_Rxy_target+1, zero
001371 9220 28ae                 	sts pulse2_fx_Rxy_speed, zero
001373 9220 28af                 	sts pulse2_fx_Rxy_speed+1, zero
001375 9220 28b0                 	sts pulse2_fx_Rxy_total_offset, zero
001377 9220 28b1                 	sts pulse2_fx_Rxy_total_offset+1, zero
001379 93c0 28b2                 	sts pulse2_fx_Sxx_pre, r28
00137b 93c0 28b3                 	sts pulse2_fx_Sxx_post, r28
                                 
                                 
                                 	//PINS
00137d efcf                      	ldi r28, 0xFF
00137e b9c0                      	out VPORTA_DIR, r28 //set all pins in VPORTD to output
                                 
                                 	//TIMERS
                                 	//Frame Counter
                                 	//NOTE:The frame counter will be defaulted to NTSC mode (60 Hz, 120 Hz, 240 Hz)
                                 	//Each interrupt will be setup to interrupt every 240 Hz clock
                                 	//CMP0 = sequence 0, CMP1 = sequence 1, CMP2 = sequence 2, OVF = sequence 3/sound driver
                                 	//Sequence 3 will clock the sound driver every 60Hz, in which new audio data is read and written to the registers
                                 	//Timer period Calculation: (0.00416666666 * 20000000/64)-1 = 1301.08333125 = 0x0515
                                 	//The ATmega4809 is cofigured to run at 20000000 Hz
                                 	//0.00416666666 seconds is the period for 240 Hz
                                 	//The /64 comes from the prescaler divider used
00137f e7c0                      	ldi r28, TCA_SINGLE_CMP0EN_bm | TCA_SINGLE_CMP1EN_bm | TCA_SINGLE_CMP2EN_bm | TCA_SINGLE_WGMODE_NORMAL_gc //interrupt mode
001380 93c0 0a01                 	sts TCA0_SINGLE_CTRLB, r28
001382 e7c1                      	ldi r28, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP1_bm | TCA_SINGLE_CMP2_bm | TCA_SINGLE_OVF_bm //enable overflow and compare interrupts
001383 93c0 0a0a                 	sts TCA0_SINGLE_INTCTRL, r28
001385 e1c5                      	ldi r28, 0x15 //set the period for CMP0
001386 93c0 0a28                 	sts TCA0_SINGLE_CMP0, r28
001388 e0c5                      	ldi r28, 0x05
001389 93c0 0a29                 	sts TCA0_SINGLE_CMP0 + 1, r28
00138b e2cb                      	ldi r28, 0x2B //set the period for CMP1
00138c 93c0 0a2a                 	sts TCA0_SINGLE_CMP1, r28
00138e e0ca                      	ldi r28, 0x0A
00138f 93c0 0a2b                 	sts TCA0_SINGLE_CMP1 + 1, r28
001391 e4c1                      	ldi r28, 0x41 //set the period for CMP2
001392 93c0 0a2c                 	sts TCA0_SINGLE_CMP2, r28
001394 e0cf                      	ldi r28, 0x0F
001395 93c0 0a2d                 	sts TCA0_SINGLE_CMP2 + 1, r28
001397 e5c7                      	ldi r28, 0x57 //set the period for OVF
001398 93c0 0a26                 	sts TCA0_SINGLE_PER, r28
00139a e1c4                      	ldi r28, 0x14
00139b 93c0 0a27                 	sts TCA0_SINGLE_PER + 1, r28
00139d e0cb                      	ldi r28, TCA_SINGLE_CLKSEL_DIV64_gc | TCA_SINGLE_ENABLE_bm //use prescale divider of 64 and enable timer
00139e 93c0 0a00                 	sts TCA0_SINGLE_CTRLA, r28
                                 
                                 	//NOTE: Channel Timers are clocked (20/2)/(0.8948865) = 11.1746014718 times faster than the NES APU
                                 	//Because of this, we multiply all the NES timer values by 11.1746014718 beforehand
                                 	//Since we rotate the sequence when the timer goes from t-(t-1) to 0, instead of 0 to t like the NES, we add 1 to the NES timers before multiplying
                                 	//The ATmega4809 is configured to run at 20 MHz
                                 	//The /2 comes from the prescaler divider used
                                 	//0.8948865 MHz is the speed of the NTSC NES APU
                                 	//NOTE: This means that any offset to the pitch for the NES timers would be multiplied by 11.1746014718 aswell.
                                 	//Pulse 1
0013a0 e0c0                      	ldi r28, TCB_CNTMODE_INT_gc //interrupt mode
0013a1 93c0 0a81                 	sts TCB0_CTRLB, r28
0013a3 e0c1                      	ldi r28, TCB_CAPT_bm //enable interrupts
0013a4 93c0 0a85                 	sts TCB0_INTCTRL, r28
0013a6 91c0 2802                 	lds r28, pulse1_timerL //load the LOW bits for timer
0013a8 93c0 0a8c                 	sts TCB0_CCMPL, r28
0013aa 91c0 2803                 	lds r28, pulse1_timerH //load the HIGH bits for timer
0013ac 93c0 0a8d                 	sts TCB0_CCMPH, r28
0013ae e0c3                      	ldi r28, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
0013af 93c0 0a80                 	sts TCB0_CTRLA, r28
                                 
                                 	//PULSE 2
0013b1 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
0013b2 93b0 0a91                 	sts TCB1_CTRLB, r27
0013b4 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
0013b5 93b0 0a95                 	sts TCB1_INTCTRL, r27
0013b7 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
0013b9 93b0 0a9c                 	sts TCB1_CCMPL, r27
0013bb 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
0013bd 93b0 0a9d                 	sts TCB1_CCMPH, r27
0013bf e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
0013c0 93b0 0a90                 	sts TCB1_CTRLA, r27
0013c2 9478                      	sei //global interrupt enable
                                 
                                 pulse1:
0013c3 fea0                      	sbrs pulse1_sequence, 0 //if the sequence output is zero, return
0013c4 c015                      	rjmp pulse1_off
                                 
0013c5 14b2                      	cp pulse1_length_counter, zero //if length is zero, return
0013c6 f099                      	breq pulse1_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
0013c7 91c0 0a8c                 	lds r28, TCB0_CCMPL
0013c9 e5d9                      	ldi r29, 0x059
0013ca 17cd                      	cp r28, r29
0013cb 91c0 0a8d                 	lds r28, TCB0_CCMPH
0013cd e0d0                      	ldi r29, 0x00
0013ce 07cd                      	cpc r28, r29
0013cf f050                      	brlo pulse1_off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $5965
0013d0 91c0 0a8c                 	lds r28, TCB0_CCMPL
0013d2 e6d6                      	ldi r29, 0x66
0013d3 17cd                      	cp r28, r29
0013d4 91c0 0a8d                 	lds r28, TCB0_CCMPH
0013d6 e5d9                      	ldi r29, 0x59
0013d7 07cd                      	cpc r28, r29
0013d8 f408                      	brsh pulse1_off
0013d9 c002                      	rjmp pulse1_on //if the HIGH period == $59 && LOW period < $65, pulse on
                                 
                                 pulse1_off:
0013da b821                      	out VPORTA_OUT, zero
0013db cfe7                      	rjmp pulse1
                                 
                                 pulse1_on:
0013dc 91d0 2806                 	lds r29, pulse1_output_volume
                                 
0013de b9d1                      	out VPORTA_OUT, r29
0013df cfe3                      	rjmp pulse1
                                 
                                 //FRAME COUNTER/AUDIO SAMPLE ISR
                                 sequence_0_2:
0013e0 b7bf                      	in r27, CPU_SREG
0013e1 93bf                      	push r27
0013e2 94f8                      	cli
                                 
                                 	//ENVELOPE
0013e3 d053                      	rcall pulse1_envelope_routine
0013e4 d09f                      	rcall pulse2_envelope_routine
                                 
0013e5 e5b0                      	ldi r27, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP2_bm //clear OVF flag
0013e6 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
0013e8 91bf                      	pop r27
0013e9 bfbf                      	out CPU_SREG, r27
0013ea 9518                      	reti
                                 
                                 sequence_1_3:
0013eb b7bf                      	in r27, CPU_SREG
0013ec 93bf                      	push r27
0013ed 94f8                      	cli
                                 
                                 	//ENVELOPE
0013ee d048                      	rcall pulse1_envelope_routine
0013ef d094                      	rcall pulse2_envelope_routine
                                 
                                 	//SWEEP
0013f0 fcc3                      	sbrc pulse1_sweep, 3 //check if the sweep enable bit is cleared
0013f1 d01b                      	rcall pulse1_sweep_routine
0013f2 fcf3                      	sbrc pulse2_sweep, 3
0013f3 d066                      	rcall pulse2_sweep_routine
                                 
                                 	//LENGTH
                                 	//NOTE: The length routine is relatively simple, so we will not be using clocks to rjmp and ret to a seperate lable
                                 sequence_1_3_pulse1_length:
0013f4 fd95                      	sbrc channel_flags, 5 //check if the length counter halt bit is cleared
0013f5 c002                      	rjmp sequence_1_3_pulse2_length
0013f6 10b2                      	cpse pulse1_length_counter, zero //if length counter is already 0, don't decrement
0013f7 94ba                      	dec pulse1_length_counter
                                 sequence_1_3_pulse2_length:
0013f8 fd91                      	sbrc channel_flags, 1 //check if the length counter halt bit is cleared
0013f9 c002                      	rjmp sequence_1_3_exit
0013fa 10e2                      	cpse pulse2_length_counter, zero //if length counter is already 0, don't decrement
0013fb 94ea                      	dec pulse2_length_counter
                                 
                                 sequence_1_3_exit:
0013fc e2b1                      	ldi r27, TCA_SINGLE_CMP1_bm | TCA_SINGLE_OVF_bm //clear OVF flag
0013fd 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
0013ff 91bf                      	pop r27
001400 bfbf                      	out CPU_SREG, r27
001401 9518                      	reti
                                 
                                 //PULSE 1 ROUTINES
                                 pulse1_sequence_routine:
001402 b7bf                      	in r27, CPU_SREG
001403 93bf                      	push r27
001404 94f8                      	cli
                                 
001405 0caa                      	lsl pulse1_sequence //shifts sequence to the left
001406 1ca2                      	adc pulse1_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
001407 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
001408 93b0 0a86                 	sts TCB0_INTFLAGS, r27
00140a 91bf                      	pop r27
00140b bfbf                      	out CPU_SREG, r27
00140c 9518                      	reti
                                 
                                 pulse1_sweep_routine:
00140d 2dbc                      	mov r27, pulse1_sweep
00140e 70b7                      	andi r27, 0x07 //mask for period divider bits
00140f f4f9                      	brne pulse1_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse1_sweep_routine_action: //if the divider is == 0, update the pulse timer period
001410 93df                      	push r29
001411 2ddc                      	mov r29, pulse1_sweep
001412 95d2                      	swap r29
001413 70d7                      	andi r29, 0x07 //mask for shift bits
001414 f411                      	brne pulse1_sweep_routine_action_main //shift != 0
001415 91df                      	pop r29
001416 c019                      	rjmp pulse1_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse1_sweep_routine_action_main:
001417 91a0 0a8c                 	lds r26, TCB0_CCMPL
001419 91b0 0a8d                 	lds r27, TCB0_CCMPH
                                 pulse1_sweep_routine_action_main_loop:
00141b 95b6                      	lsr r27
00141c 95a7                      	ror r26
00141d 95da                      	dec r29
00141e f7e1                      	brne pulse1_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
00141f fec7                      	sbrs pulse1_sweep, 7 //check the negate flag
001420 c002                      	rjmp pulse1_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
001421 95a0                      	com r26 //pulse1 uses one's complement if the negate flag is set
001422 95b0                      	com r27
                                 
                                 pulse1_sweep_routine_action_main_add:
001423 91d0 0a8c                 	lds r29, TCB0_CCMPL //perform addition to get new timer period
001425 0fad                      	add r26, r29
001426 91d0 0a8d                 	lds r29, TCB0_CCMPH
001428 1fbd                      	adc r27, r29
                                 
001429 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new LOW bits for timer
00142b 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new HIGH bits for timer
                                 	
00142d 91df                      	pop r29
00142e c001                      	rjmp pulse1_sweep_routine_check_reload
                                 
                                 pulse1_sweep_routine_decrement_divider:
00142f 94ca                      	dec pulse1_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse1_sweep_routine_check_reload:
001430 ff97                      	sbrs channel_flags, 7 //if the reload flag is set, reload the sweep divider
001431 9508                      	ret
                                 
                                 pulse1_sweep_reload:
001432 90c0 2801                 	lds pulse1_sweep, pulse1_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
001434 94c2                      	swap pulse1_sweep //bring data from high byte to low byte
001435 779f                      	cbr channel_flags, 0b10000000 //clear reload flag
001436 9508                      	ret
                                 
                                 
                                 
                                 pulse1_envelope_routine:
001437 fd96                      	sbrc channel_flags, 6 //check if start flag is cleared
001438 c010                      	rjmp pulse1_envelope_routine_clear_start
                                 
001439 3000                      	cpi pulse1_volume_divider, 0x00 //check if the divider is 0
00143a f011                      	breq PC+3 //if the divider == 0, check loop flag
00143b 950a                      	dec pulse1_volume_divider //if the divider != 0, decrement and return
00143c 9508                      	ret
                                 
00143d 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the divider == 0, reset the divider period
00143f 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
001440 ff95                      	sbrs channel_flags, 5 //check if the loop flag is set
001441 c002                      	rjmp pulse1_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
001442 e01f                      	ldi pulse1_volume_decay, 0x0F //if the loop flag is set, reset decay and return
001443 9508                      	ret
                                 
                                 pulse1_envelope_routine_decrement_decay:
001444 3010                      	cpi pulse1_volume_decay, 0x00 //check if the decay is 0
001445 f409                      	brne PC+2 //if decay != 0, go decrement
001446 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
001447 951a                      	dec pulse1_volume_decay
001448 9508                      	ret
                                 
                                 pulse1_envelope_routine_clear_start:
001449 7b9f                      	cbr channel_flags, 0b01000000 //if the start flag is set, clear it
00144a 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the start flag is set, reset the divider period
00144c 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
00144d e01f                      	ldi pulse1_volume_decay, 0x0F //if the start flag is set, reset decay
00144e 9508                      	ret
                                 
                                 //PULSE 2 ROUTINES
                                 pulse2_sequence_routine:
00144f b7bf                      	in r27, CPU_SREG
001450 93bf                      	push r27
001451 94f8                      	cli
                                 
001452 0cdd                      	lsl pulse2_sequence //shifts sequence to the left
001453 1cd2                      	adc pulse2_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
001454 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
001455 93b0 0a96                 	sts TCB1_INTFLAGS, r27
001457 91bf                      	pop r27
001458 bfbf                      	out CPU_SREG, r27
001459 9518                      	reti
                                 
                                 pulse2_sweep_routine:
00145a 2dbf                      	mov r27, pulse2_sweep
00145b 70b7                      	andi r27, 0x07 //mask for period divider bits
00145c f4f9                      	brne pulse2_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse2_sweep_routine_action: //if the divider is == 0, update the pulse timer period
00145d 93df                      	push r29
00145e 2ddf                      	mov r29, pulse2_sweep
00145f 95d2                      	swap r29
001460 70d7                      	andi r29, 0x07 //mask for shift bits
001461 f411                      	brne pulse2_sweep_routine_action_main //shift != 0
001462 91df                      	pop r29
001463 c019                      	rjmp pulse2_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse2_sweep_routine_action_main:
001464 91a0 0a9c                 	lds r26, TCB1_CCMPL
001466 91b0 0a9d                 	lds r27, TCB1_CCMPH
                                 pulse2_sweep_routine_action_main_loop:
001468 95b6                      	lsr r27
001469 95a7                      	ror r26
00146a 95da                      	dec r29
00146b f7e1                      	brne pulse2_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
00146c fef7                      	sbrs pulse2_sweep, 7 //check the negate flag
00146d c002                      	rjmp pulse2_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
00146e 95a0                      	com r26 //pulse2 uses one's complement if the negate flag is set
00146f 95b0                      	com r27
                                 
                                 pulse2_sweep_routine_action_main_add:
001470 91d0 0a9c                 	lds r29, TCB1_CCMPL //perform addition to get new timer period
001472 0fad                      	add r26, r29
001473 91d0 0a9d                 	lds r29, TCB1_CCMPH
001475 1fbd                      	adc r27, r29
                                 
001476 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new LOW bits for timer
001478 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new HIGH bits for timer
                                 	
00147a 91df                      	pop r29
00147b c001                      	rjmp pulse2_sweep_routine_check_reload
                                 
                                 pulse2_sweep_routine_decrement_divider:
00147c 94fa                      	dec pulse2_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse2_sweep_routine_check_reload:
00147d ff93                      	sbrs channel_flags, 3 //if the reload flag is set, reload the sweep divider
00147e 9508                      	ret
                                 
                                 pulse2_sweep_reload:
00147f 90f0 2809                 	lds pulse2_sweep, pulse2_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
001481 94f2                      	swap pulse2_sweep //bring data from high byte to low byte
001482 7f97                      	cbr channel_flags, 0b00001000 //clear reload flag
001483 9508                      	ret
                                 
                                 
                                 
                                 pulse2_envelope_routine:
001484 fd92                      	sbrc channel_flags, 2 //check if start flag is cleared
001485 c010                      	rjmp pulse2_envelope_routine_clear_start
                                 
001486 3020                      	cpi pulse2_volume_divider, 0x00 //check if the divider is 0
001487 f011                      	breq PC+3 //if the divider == 0, check loop flag
001488 952a                      	dec pulse2_volume_divider //if the divider != 0, decrement and return
001489 9508                      	ret
                                 
00148a 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the divider == 0, reset the divider period
00148c 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
00148d ff91                      	sbrs channel_flags, 1 //check if the loop flag is set
00148e c002                      	rjmp pulse2_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
00148f e03f                      	ldi pulse2_volume_decay, 0x0F //if the loop flag is set, reset decay and return
001490 9508                      	ret
                                 
                                 pulse2_envelope_routine_decrement_decay:
001491 3030                      	cpi pulse2_volume_decay, 0x00 //check if the decay is 0
001492 f409                      	brne PC+2 //if decay != 0, go decrement
001493 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
001494 953a                      	dec pulse2_volume_decay
001495 9508                      	ret
                                 
                                 pulse2_envelope_routine_clear_start:
001496 7f9b                      	cbr channel_flags, 0b00000100 //if the start flag is set, clear it
001497 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the start flag is set, reset the divider period
001499 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
00149a e03f                      	ldi pulse2_volume_decay, 0x0F //if the start flag is set, reset decay
00149b 9508                      	ret
                                 
                                 
                                 
                                 //CONVERTERS
                                 //converts and loads 5 bit length to corresponding 8 bit length value into r29
                                 length_converter:
00149c e9e8                      	ldi ZL, LOW(length << 1)
00149d e4f4                      	ldi ZH, HIGH(length << 1)
00149e 0fed                      	add ZL, r29
00149f 1df2                      	adc ZH, zero
0014a0 91d4                      	lpm r29, Z
0014a1 9508                      	ret
                                 
                                 //loads pulse sequence into r29
                                 duty_cycle_sequences:
0014a2 ebe8                      	ldi ZL, LOW(sequences << 1)
0014a3 e4f4                      	ldi ZH, HIGH(sequences << 1)
0014a4 0fed                      	add ZL, r29
0014a5 1df2                      	adc ZH, zero
0014a6 91d4                      	lpm r29, Z
0014a7 9508                      	ret
                                 
                                 
                                 
                                 //SOUND DRIVER
                                 sound_driver:
0014a8 b7bf                      	in r27, CPU_SREG
0014a9 93bf                      	push r27
0014aa 94f8                      	cli
0014ab 93cf                      	push r28
0014ac 93df                      	push r29
                                 
                                 	//SOUND DRIVER
0014ad 91a0 2817                 	lds r26, song_fx_Bxx
0014af 3faf                      	cpi r26, 0xFF //0xFF means that the flag is disabled
0014b0 f4a9                      	brne sound_driver_fx_Bxx_routine
0014b1 91a0 2818                 	lds r26, song_fx_Cxx
0014b3 11a2                      	cpse r26, zero
0014b4 c04b                      	rjmp sound_driver_fx_Cxx_routine
0014b5 91a0 2819                 	lds r26, song_fx_Dxx
0014b7 11a2                      	cpse r26, zero
0014b8 c056                      	rjmp sound_driver_fx_Dxx_routine
                                 
0014b9 91a0 2812                 	lds r26, song_frame_offset
0014bb 91b0 2813                 	lds r27, song_frame_offset+1
0014bd 91c0 2814                 	lds r28, song_size
0014bf 91d0 2815                 	lds r29, song_size+1
0014c1 17ac                      	cp r26, r28
0014c2 07bd                      	cpc r27, r29
0014c3 f408                      	brsh sound_driver_fx_song_loop
0014c4 c081                      	rjmp sound_driver_channel0
                                 
                                 
                                 sound_driver_fx_song_loop:
0014c5 e0a0                      	ldi r26, 0x00
                                 sound_driver_fx_Bxx_routine:
0014c6 91e0 2810                 	lds ZL, song_frames
0014c8 91f0 2811                 	lds ZH, song_frames+1
0014ca 27cc                      	clr r28 //initialize r29:r28 to 0
0014cb 27dd                      	clr r29
0014cc 95a3                      	inc r26 //increment xx parameter by 1
                                 sound_driver_fx_Bxx_routine_loop:
0014cd 95aa                      	dec r26
0014ce f011                      	breq sound_driver_fx_Bxx_routine_loop_exit //once r26 == 0, r29:r28 will hold Bxx*(5*2).
0014cf 962a                      	adiw r29:r28, 10 //increment the offset by 10 because 5 channels, and each address takes 2 bytes (5*2 = 10)
0014d0 cffc                      	rjmp sound_driver_fx_Bxx_routine_loop
                                 
                                 sound_driver_fx_Bxx_routine_loop_exit:
0014d1 9622                      	adiw r29:r28, 2 //add 2 to skip the first 2 bytes (first 2 bytes is the song size)
0014d2 93c0 2812                 	sts song_frame_offset, r28
0014d4 93d0 2813                 	sts song_frame_offset+1, r29
0014d6 0fec                      	add ZL, r28
0014d7 1ffd                      	adc ZH, r29
                                 
0014d8 91a5                      	lpm r26, Z+ //load the address of the frame(pattern)
0014d9 91b5                      	lpm r27, Z+
0014da 0faa                      	lsl r26
0014db 1fbb                      	rol r27
0014dc 93a0 281a                 	sts pulse1_pattern, r26
0014de 93b0 281b                 	sts pulse1_pattern+1, r27
0014e0 91a5                      	lpm r26, Z+
0014e1 91b5                      	lpm r27, Z+
0014e2 0faa                      	lsl r26
0014e3 1fbb                      	rol r27
0014e4 93a0 2867                 	sts pulse2_pattern, r26
0014e6 93b0 2868                 	sts pulse2_pattern+1, r27
                                 
0014e8 9220 281e                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
0014ea 9220 281f                 	sts pulse1_pattern_offset+1, zero
0014ec 9220 281c                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
0014ee 9220 281d                 	sts pulse1_pattern_delay_frames, zero
0014f0 9220 286b                 	sts pulse2_pattern_offset, zero
0014f2 9220 286c                 	sts pulse2_pattern_offset+1, zero
0014f4 9220 2869                 	sts pulse2_pattern_delay_rows, zero
0014f6 9220 286a                 	sts pulse2_pattern_delay_frames, zero
                                 
0014f8 efaf                      	ldi r26, 0xFF
0014f9 93a0 2817                 	sts song_fx_Bxx, r26 //reset all song effects
0014fb 9220 2818                 	sts song_fx_Cxx, zero
0014fd 9220 2819                 	sts song_fx_Dxx, zero
0014ff c046                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_fx_Cxx_routine:
001500 91df                      	pop r29
001501 91cf                      	pop r28
001502 91bf                      	pop r27
001503 bfbf                      	out CPU_SREG, r27
001504 94f8                      	cli //disable global interrupts
                                 		
001505 efaf                      	ldi r26, 0xFF
001506 93a0 2817                 	sts song_fx_Bxx, r26 //reset all song effects
001508 9220 2818                 	sts song_fx_Cxx, zero
00150a 9220 2819                 	sts song_fx_Dxx, zero
                                 
00150c 9220 2806                 	sts pulse1_output_volume, zero //mute all channels
00150e 9518                      	reti
                                 
                                 sound_driver_fx_Dxx_routine:
00150f 91e0 2810                 	lds ZL, song_frames
001511 91f0 2811                 	lds ZH, song_frames+1
001513 91a0 2812                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001515 91b0 2813                 	lds r27, song_frame_offset+1
001517 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
001518 93a0 2812                 	sts song_frame_offset, r26
00151a 93b0 2813                 	sts song_frame_offset+1, r27
00151c 0fea                      	add ZL, r26
00151d 1ffb                      	adc ZH, r27
                                 
00151e 91a5                      	lpm r26, Z+ //load the address of the next pattern
00151f 91b5                      	lpm r27, Z+
001520 0faa                      	lsl r26
001521 1fbb                      	rol r27
001522 93a0 281a                 	sts pulse1_pattern, r26
001524 93b0 281b                 	sts pulse1_pattern+1, r27
001526 91a5                      	lpm r26, Z+
001527 91b5                      	lpm r27, Z+
001528 0faa                      	lsl r26
001529 1fbb                      	rol r27
00152a 93a0 2867                 	sts pulse2_pattern, r26
00152c 93b0 2868                 	sts pulse2_pattern+1, r27
                                 
00152e 9220 281e                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001530 9220 281f                 	sts pulse1_pattern_offset+1, zero
001532 9220 281c                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
001534 9220 281d                 	sts pulse1_pattern_delay_frames, zero
001536 9220 286b                 	sts pulse2_pattern_offset, zero
001538 9220 286c                 	sts pulse2_pattern_offset+1, zero
00153a 9220 2869                 	sts pulse2_pattern_delay_rows, zero
00153c 9220 286a                 	sts pulse2_pattern_delay_frames, zero
                                 
00153e efaf                      	ldi r26, 0xFF
00153f 93a0 2817                 	sts song_fx_Bxx, r26 //reset all song effects
001541 9220 2818                 	sts song_fx_Cxx, zero
001543 9220 2819                 	sts song_fx_Dxx, zero
001545 c000                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0:
001546 91a0 281c                 	lds r26, pulse1_pattern_delay_rows
001548 91b0 281d                 	lds r27, pulse1_pattern_delay_frames
00154a 9610                      	adiw r27:r26, 0
00154b f009                      	breq sound_driver_channel0_main //if the pattern delay is 0, proceed with sound driver procedures
00154c c2cf                      	rjmp sound_driver_channel0_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel0_main:
00154d 91e0 281a                 	lds ZL, pulse1_pattern //current pattern for pulse 1
00154f 91f0 281b                 	lds ZH, pulse1_pattern+1
001551 91a0 281e                 	lds r26, pulse1_pattern_offset //current offset in the pattern for pulse 1
001553 91b0 281f                 	lds r27, pulse1_pattern_offset+1
001555 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001556 1ffb                      	adc ZH, r27
001557 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel0_check_if_note: //check if data is a note (0x00 - 0x56)
001558 35b7                      	cpi r27, 0x57
001559 f408                      	brsh sound_driver_channel0_check_if_volume
00155a c178                      	rjmp sound_driver_channel0_note
                                 sound_driver_channel0_check_if_volume: //check if data is volume (0x57-0x66)
00155b 36b7                      	cpi r27, 0x67
00155c f408                      	brsh sound_driver_channel0_check_if_delay
00155d c1b0                      	rjmp sound_driver_channel0_volume
                                 sound_driver_channel0_check_if_delay: //check if data is a delay (0x67 - 0xE2)
00155e 3eb3                      	cpi r27, 0xE3
00155f f408                      	brsh sound_driver_channel0_check_if_instrument
001560 c1b7                      	rjmp sound_driver_channel0_delay
                                 sound_driver_channel0_check_if_instrument: //check for instrument flag (0xE3)
001561 f409                      	brne sound_driver_channel0_check_if_release
001562 c1ba                      	rjmp sound_driver_channel0_instrument_change 
                                 sound_driver_channel0_check_if_release: //check for note release flag (0xE4)
001563 3eb4                      	cpi r27, 0xE4
001564 f409                      	brne sound_driver_channel0_check_if_end
001565 c261                      	rjmp sound_driver_channel0_release
                                 sound_driver_channel0_check_if_end:
001566 3fbf                      	cpi r27, 0xFF
001567 f409                      	brne sound_driver_channel0_check_if_fx
001568 c283                      	rjmp sound_driver_channel0_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel0_check_if_fx: //fx flags (0xE5 - 0xFE)
001569 9631                      	adiw Z, 1 //point Z to the byte next to the flag
00156a 91a4                      	lpm r26, Z //load the fx data into r26
00156b d2a6                      	rcall sound_driver_channel0_increment_offset_twice
                                 
00156c 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
00156d ebec                      	ldi ZL, LOW(channel0_fx << 1) //load in note table
00156e e4f4                      	ldi ZH, HIGH(channel0_fx << 1)
00156f 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001570 0feb                      	add ZL, r27 //add offset
001571 1df2                      	adc ZH, zero
001572 91c5                      	lpm r28, Z+ //load address bytes
001573 91d4                      	lpm r29, Z
001574 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001575 2ffd                      	mov ZH, r29
001576 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel0_fx_0xy:
001577 93a0 283c                 	sts pulse1_fx_0xy_sequence, r26
001579 9220 283d                 	sts pulse1_fx_0xy_sequence+1, zero
00157b cfd1                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel0_fx_1xx:
00157c 9220 2842                 	sts pulse1_fx_2xx, zero //turn off any 2xx pitch slide down
00157e 9220 2843                 	sts pulse1_fx_2xx+1, zero
001580 9220 283c                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
001582 9220 283d                 	sts pulse1_fx_0xy_sequence+1, zero
001584 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001585 937f                      	push r23
001586 2f6a                      	mov r22, r26 //store the rate into r22
001587 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001588 9f67                      	mul r22, r23
001589 917f                      	pop r23
00158a 916f                      	pop r22
                                 
00158b 9416                      	lsr r1 //shift out the fractional bits
00158c 9407                      	ror r0
00158d 9416                      	lsr r1
00158e 9407                      	ror r0
00158f 9416                      	lsr r1
001590 9407                      	ror r0
001591 9416                      	lsr r1
001592 9407                      	ror r0
001593 9200 283e                 	sts pulse1_fx_1xx, r0
001595 9210 283f                 	sts pulse1_fx_1xx+1, r1
001597 cfb5                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel0_fx_2xx:
001598 9220 283e                 	sts pulse1_fx_1xx, zero //turn off any 1xx pitch slide down
00159a 9220 283f                 	sts pulse1_fx_1xx+1, zero
00159c 9220 283c                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
00159e 9220 283d                 	sts pulse1_fx_0xy_sequence+1, zero
0015a0 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0015a1 937f                      	push r23
0015a2 2f6a                      	mov r22, r26 //store the rate into r22
0015a3 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0015a4 9f67                      	mul r22, r23
0015a5 917f                      	pop r23
0015a6 916f                      	pop r22
                                 
0015a7 9416                      	lsr r1 //shift out the fractional bits
0015a8 9407                      	ror r0
0015a9 9416                      	lsr r1
0015aa 9407                      	ror r0
0015ab 9416                      	lsr r1
0015ac 9407                      	ror r0
0015ad 9416                      	lsr r1
0015ae 9407                      	ror r0
0015af 9200 2842                 	sts pulse1_fx_2xx, r0
0015b1 9210 2843                 	sts pulse1_fx_2xx+1, r1
0015b3 cf99                      	rjmp sound_driver_channel0_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel0_fx_3xx:
0015b4 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0015b5 937f                      	push r23
0015b6 2f6a                      	mov r22, r26 //store the rate into r22
0015b7 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0015b8 9f67                      	mul r22, r23
0015b9 917f                      	pop r23
0015ba 916f                      	pop r22
                                 
0015bb 9416                      	lsr r1 //shift out the fractional bits
0015bc 9407                      	ror r0
0015bd 9416                      	lsr r1
0015be 9407                      	ror r0
0015bf 9416                      	lsr r1
0015c0 9407                      	ror r0
0015c1 9416                      	lsr r1
0015c2 9407                      	ror r0
0015c3 9200 284a                 	sts pulse1_fx_3xx_speed, r0
0015c5 9210 284b                 	sts pulse1_fx_3xx_speed+1, r1
                                 
0015c7 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
0015c8 c001                      	rjmp sound_driver_channel0_fx_3xx_enabled
0015c9 cf83                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_3xx_enabled:
0015ca 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
0015cc 91b0 0a8d                 	lds r27, TCB0_CCMPH
0015ce 93a0 2846                 	sts pulse1_fx_3xx_start, r26
0015d0 93b0 2847                 	sts pulse1_fx_3xx_start+1, r27
                                 
0015d2 9220 284c                 	sts pulse1_fx_3xx_total_offset, zero
0015d4 9220 284d                 	sts pulse1_fx_3xx_total_offset+1, zero
0015d6 cf76                      	rjmp sound_driver_channel0_main
                                 
                                 //VIBRATO
                                 sound_driver_channel0_fx_4xy:
0015d7 2fba                      	mov r27, r26
0015d8 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
0015d9 95a2                      	swap r26
0015da 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0015db 93a0 284e                 	sts pulse1_fx_4xy_speed, r26
0015dd 93b0 284f                 	sts pulse1_fx_4xy_depth, r27
0015df 9220 2850                 	sts pulse1_fx_4xy_phase, zero //reset the phase to 0
0015e1 cf6b                      	rjmp sound_driver_channel0_main
                                 
                                 //TREMELO
                                 sound_driver_channel0_fx_7xy:
0015e2 2fba                      	mov r27, r26
0015e3 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
0015e4 95a2                      	swap r26
0015e5 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0015e6 93a0 2851                 	sts pulse1_fx_7xy_speed, r26
0015e8 93b0 2852                 	sts pulse1_fx_7xy_depth, r27
0015ea 9220 2853                 	sts pulse1_fx_7xy_phase, zero //reset the phase to 0
0015ec 9220 2854                 	sts pulse1_fx_7xy_value, zero //reset the tremelo value
0015ee cf5e                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel0_fx_Axy:
0015ef 93a0 2855                 	sts pulse1_fx_Axy, r26
0015f1 cf5b                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel0_fx_Bxx:
0015f2 93a0 2817                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
0015f4 cf58                      	rjmp sound_driver_channel0_main
                                 
                                 //HALT
                                 sound_driver_channel0_fx_Cxx:
0015f5 93b0 2818                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
0015f7 cf55                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel0_fx_Dxx:
0015f8 93b0 2819                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
0015fa cf52                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME
                                 sound_driver_channel0_fx_Exx:
0015fb 91b0 2800                 	lds r27, pulse1_param
0015fd 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
0015fe 2bba                      	or r27, r26 //move new VVVV bits into pulse1_param
0015ff 93b0 2800                 	sts pulse1_param, r27
001601 6096                      	sbr channel_flags, 6
001602 cf4a                      	rjmp sound_driver_channel0_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel0_fx_Fxx:
001603 93a0 2816                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001605 cf47                      	rjmp sound_driver_channel0_main
                                 
                                 //DELAY
                                 sound_driver_channel0_fx_Gxx:
001606 15a2                      	cp r26, zero
001607 f051                      	breq sound_driver_channel0_fx_Gxx_invalid
001608 91b0 2816                 	lds r27, song_speed
00160a 17ab                      	cp r26, r27
00160b f430                      	brsh sound_driver_channel0_fx_Gxx_invalid
00160c 93a0 2856                 	sts pulse1_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
00160e e0b1                      	ldi r27, 0x01
00160f 93b0 281c                 	sts pulse1_pattern_delay_rows, r27
001611 c20d                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Gxx_invalid:
001612 cf3a                      	rjmp sound_driver_channel0_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel0_fx_Hxy: //hardware sweep up
001613 95a2                      	swap r26
001614 68a8                      	ori r26, 0b10001000 //enable negate and enable sweep flag
001615 2eca                      	mov pulse1_sweep, r26
001616 92c0 2801                 	sts pulse1_sweep_param, pulse1_sweep
001618 6097                      	sbr channel_flags, 7 //set reload flag
001619 cf33                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_Ixy: //hardware sweep down
00161a 95a2                      	swap r26
00161b 77af                      	andi r26, 0b01111111 //disable negate flag
00161c 60a8                      	ori r26, 0b00001000 //enable sweep flag
00161d 2eca                      	mov pulse1_sweep, r26
00161e 92c0 2801                 	sts pulse1_sweep_param, pulse1_sweep
001620 6097                      	sbr channel_flags, 7 //set reload flag
001621 cf2b                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_Hxx: //FDS modulation depth
001622 cf2a                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixx: //FDS modulation speed
001623 cf29                      	rjmp sound_driver_channel0_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel0_fx_Pxx:
001624 93a0 2858                 	sts pulse1_fx_Pxx, r26
001626 cf26                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel0_fx_Qxy:
                                 sound_driver_channel0_fx_Qxy_check_arpeggio_macro:
001627 91e0 2825                 	lds ZL, pulse1_arpeggio_macro
001629 91f0 2826                 	lds ZH, pulse1_arpeggio_macro+1
00162b 9630                      	adiw Z, 0
00162c f009                      	breq sound_driver_channel0_fx_Qxy_check_pitch_macro
00162d cf1f                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_pitch_macro:
00162e 91e0 282c                 	lds ZL, pulse1_pitch_macro
001630 91f0 282d                 	lds ZH, pulse1_pitch_macro+1
001632 9630                      	adiw Z, 0
001633 f009                      	breq sound_driver_channel0_fx_Qxy_check_hi_pitch_macro
001634 cf18                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_hi_pitch_macro:
001635 91e0 2832                 	lds ZL, pulse1_hi_pitch_macro
001637 91f0 2833                 	lds ZH, pulse1_hi_pitch_macro+1
001639 9630                      	adiw Z, 0
00163a f009                      	breq sound_driver_channel0_fx_Qxy_process
00163b cf11                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_process:
00163c 2fba                      	mov r27, r26 //copy fx parameters into r27
00163d 70bf                      	andi r27, 0x0F //mask note index offset
00163e 91c0 2807                 	lds r28, pulse1_note //load current note index
001640 0fbc                      	add r27, r28
001641 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001642 f008                      	brlo sound_driver_channel0_fx_Qxy_process_continue
001643 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel0_fx_Qxy_process_continue:
001644 e3e8                      	ldi ZL, LOW(note_table << 1) //load in note table
001645 e0f0                      	ldi ZH, HIGH(note_table << 1)
001646 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001647 0feb                      	add ZL, r27 //add offset
001648 1df2                      	adc ZH, zero
001649 91c5                      	lpm r28, Z+ //load bytes
00164a 91d4                      	lpm r29, Z
00164b 93c0 2859                 	sts pulse1_fx_Qxy_target, r28 //load the LOW bits for the target period
00164d 93d0 285a                 	sts pulse1_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
00164f 95a2                      	swap r26
001650 70af                      	andi r26, 0x0F //mask effect speed
001651 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001652 95a3                      	inc r26 //increment the speed by 1
                                 
001653 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001654 937f                      	push r23
001655 2f6a                      	mov r22, r26 //store the speed data into r27
001656 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001657 9f67                      	mul r22, r23
001658 917f                      	pop r23
001659 916f                      	pop r22
                                 
00165a 9416                      	lsr r1 //shift out the fractional bits
00165b 9407                      	ror r0
00165c 9416                      	lsr r1
00165d 9407                      	ror r0
00165e 9416                      	lsr r1
00165f 9407                      	ror r0
001660 9416                      	lsr r1
001661 9407                      	ror r0
                                 
001662 9200 285b                 	sts pulse1_fx_Qxy_speed, r0 //store the effect speed
001664 9210 285c                 	sts pulse1_fx_Qxy_speed+1, r1
001666 9220 285d                 	sts pulse1_fx_Qxy_total_offset, zero
001668 9220 285e                 	sts pulse1_fx_Qxy_total_offset+1, zero
00166a cee2                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel0_fx_Rxy:
                                 sound_driver_channel0_fx_Rxy_check_arpeggio_macro:
00166b 91e0 2825                 	lds ZL, pulse1_arpeggio_macro
00166d 91f0 2826                 	lds ZH, pulse1_arpeggio_macro+1
00166f 9630                      	adiw Z, 0
001670 f009                      	breq sound_driver_channel0_fx_Rxy_check_pitch_macro
001671 cedb                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_pitch_macro:
001672 91e0 282c                 	lds ZL, pulse1_pitch_macro
001674 91f0 282d                 	lds ZH, pulse1_pitch_macro+1
001676 9630                      	adiw Z, 0
001677 f009                      	breq sound_driver_channel0_fx_Rxy_check_hi_pitch_macro
001678 ced4                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_hi_pitch_macro:
001679 91e0 2832                 	lds ZL, pulse1_hi_pitch_macro
00167b 91f0 2833                 	lds ZH, pulse1_hi_pitch_macro+1
00167d 9630                      	adiw Z, 0
00167e f009                      	breq sound_driver_channel0_fx_Rxy_process
00167f cecd                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_process:
001680 2fba                      	mov r27, r26 //copy fx parameters into r27
001681 70bf                      	andi r27, 0x0F //mask note index offset
001682 91c0 2807                 	lds r28, pulse1_note //load current note index
001684 1bcb                      	sub r28, r27
001685 f408                      	brcc sound_driver_channel0_fx_Rxy_process_continue
001686 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel0_fx_Rxy_process_continue:
001687 e3e8                      	ldi ZL, LOW(note_table << 1) //load in note table
001688 e0f0                      	ldi ZH, HIGH(note_table << 1)
001689 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
00168a 0fec                      	add ZL, r28 //add offset
00168b 1df2                      	adc ZH, zero
00168c 91c5                      	lpm r28, Z+ //load bytes
00168d 91d4                      	lpm r29, Z
00168e 93c0 285f                 	sts pulse1_fx_Rxy_target, r28 //load the LOW bits for the target period
001690 93d0 2860                 	sts pulse1_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
001692 95a2                      	swap r26
001693 70af                      	andi r26, 0x0F //mask effect speed
001694 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001695 95a3                      	inc r26 //increment the speed by 1
                                 
001696 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001697 937f                      	push r23
001698 2f6a                      	mov r22, r26 //store the speed data into r27
001699 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00169a 9f67                      	mul r22, r23
00169b 917f                      	pop r23
00169c 916f                      	pop r22
                                 
00169d 9416                      	lsr r1 //shift out the fractional bits
00169e 9407                      	ror r0
00169f 9416                      	lsr r1
0016a0 9407                      	ror r0
0016a1 9416                      	lsr r1
0016a2 9407                      	ror r0
0016a3 9416                      	lsr r1
0016a4 9407                      	ror r0
                                 
0016a5 9200 2861                 	sts pulse1_fx_Rxy_speed, r0 //store the effect speed
0016a7 9210 2862                 	sts pulse1_fx_Rxy_speed+1, r1
0016a9 9220 2863                 	sts pulse1_fx_Rxy_total_offset, zero
0016ab 9220 2864                 	sts pulse1_fx_Rxy_total_offset+1, zero
0016ad ce9f                      	rjmp sound_driver_channel0_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel0_fx_Sxx:
0016ae 15a2                      	cp r26, zero
0016af f051                      	breq sound_driver_channel0_fx_Sxx_invalid
0016b0 91b0 2816                 	lds r27, song_speed
0016b2 17ab                      	cp r26, r27
0016b3 f430                      	brsh sound_driver_channel0_fx_Sxx_invalid
0016b4 93a0 2865                 	sts pulse1_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
0016b6 e0b1                      	ldi r27, 0x01
0016b7 93b0 281c                 	sts pulse1_pattern_delay_rows, r27
0016b9 c165                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Sxx_invalid:
0016ba ce92                      	rjmp sound_driver_channel0_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel0_fx_Vxx:
0016bb ebe8                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
0016bc e4f4                      	ldi ZH, HIGH(sequences << 1)
0016bd 0fea                      	add ZL, r26 //offset the pointer
0016be 1df2                      	adc ZH, zero
                                 
0016bf 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
0016c0 95a7                      	ror r26
0016c1 95a7                      	ror r26
0016c2 91b0 2800                 	lds r27, pulse1_param //load r27 with pulse1_param (register $4000)
0016c4 2fcb                      	mov r28, r27 //store a copy of pulse1_param into r28
0016c5 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
0016c6 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
0016c7 c001                      	rjmp sound_driver_channel0_fx_Vxx_store
0016c8 ce84                      	rjmp sound_driver_channel0_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel0_fx_Vxx_store:
0016c9 90a4                      	lpm pulse1_sequence, Z //store the sequence
                                 
0016ca 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
0016cb 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
0016cc 93c0 2800                 	sts pulse1_param, r28
0016ce ce7e                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_Wxx: //DPCM sample speed
0016cf ce7d                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Xxx: //DPCM sample retrigger
0016d0 ce7c                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Yxx: //DPCM sample offset
0016d1 ce7b                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Zxx: //DPCM sample delta counter
0016d2 ce7a                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 sound_driver_channel0_note:
0016d3 93b0 2807                 	sts pulse1_note, r27 //store the note index
0016d5 e0a3                      	ldi r26, 0x03
0016d6 e0b2                      	ldi r27, 0x02
0016d7 93b0 2822                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
0016d9 93a0 2827                 	sts pulse1_arpeggio_macro_offset, r26
0016db 93b0 282e                 	sts pulse1_pitch_macro_offset, r27
0016dd 93b0 2834                 	sts pulse1_hi_pitch_macro_offset, r27
0016df 93b0 2839                 	sts pulse1_duty_macro_offset, r27
0016e1 9220 282b                 	sts pulse1_total_pitch_offset, zero //reset the pitch and hi pitch offset
0016e3 9220 2831                 	sts pulse1_total_hi_pitch_offset, zero
0016e5 9220 2840                 	sts pulse1_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
0016e7 9220 2841                 	sts pulse1_fx_1xx_total+1, zero
0016e9 9220 2844                 	sts pulse1_fx_2xx_total, zero
0016eb 9220 2845                 	sts pulse1_fx_2xx_total+1, zero
0016ed 9220 284c                 	sts pulse1_fx_3xx_total_offset, zero //reset 3xx offset
0016ef 9220 284d                 	sts pulse1_fx_3xx_total_offset+1, zero
0016f1 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
0016f3 91b0 0a8d                 	lds r27, TCB0_CCMPH
0016f5 93a0 2846                 	sts pulse1_fx_3xx_start, r26
0016f7 93b0 2847                 	sts pulse1_fx_3xx_start+1, r27
0016f9 9220 2801                 	sts pulse1_sweep_param, zero //reset any sweep effect
0016fb 6097                      	sbr channel_flags, 7 //set reload flag
0016fc 9220 2859                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0016fe 9220 285a                 	sts pulse1_fx_Qxy_target+1, zero
001700 9220 285d                 	sts pulse1_fx_Qxy_total_offset, zero
001702 9220 285e                 	sts pulse1_fx_Qxy_total_offset+1, zero
001704 9220 285f                 	sts pulse1_fx_Rxy_target, zero
001706 9220 2860                 	sts pulse1_fx_Rxy_target+1, zero
001708 9220 2863                 	sts pulse1_fx_Rxy_total_offset, zero
00170a 9220 2864                 	sts pulse1_fx_Rxy_total_offset+1, zero
00170c d0fb                      	rcall sound_driver_channel0_increment_offset
00170d ce3f                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_volume:
00170e 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
00170f 91a0 2800                 	lds r26, pulse1_param
001711 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001712 2bab                      	or r26, r27 //move new VVVV bits into pulse1_param
001713 93a0 2800                 	sts pulse1_param, r26
001715 6096                      	sbr channel_flags, 6
001716 d0f1                      	rcall sound_driver_channel0_increment_offset
001717 ce35                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_delay:
001718 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001719 93b0 281c                 	sts pulse1_pattern_delay_rows, r27
00171b d0ec                      	rcall sound_driver_channel0_increment_offset
00171c c102                      	rjmp sound_driver_channel1
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change:
00171d 9220 2820                 	sts pulse1_volume_macro, zero //reset all macro addresses
00171f 9220 2821                 	sts pulse1_volume_macro+1, zero
001721 9220 2825                 	sts pulse1_arpeggio_macro, zero
001723 9220 2826                 	sts pulse1_arpeggio_macro+1, zero
001725 9220 282c                 	sts pulse1_pitch_macro, zero
001727 9220 282d                 	sts pulse1_pitch_macro+1, zero
001729 9220 2832                 	sts pulse1_hi_pitch_macro, zero
00172b 9220 2833                 	sts pulse1_hi_pitch_macro+1, zero
00172d 9220 2837                 	sts pulse1_duty_macro, zero
00172f 9220 2838                 	sts pulse1_duty_macro+1, zero
001731 9220 282b                 	sts pulse1_total_pitch_offset, zero //reset the pitch offset
001733 9220 2831                 	sts pulse1_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001735 9631                      	adiw Z, 1 //point to the byte next to the flag
001736 91b4                      	lpm r27, Z //store the instrument offset into r27
001737 ebe5                      	ldi ZL, LOW(instruments) //point Z to instruments table
001738 e0ff                      	ldi ZH, HIGH(instruments)
001739 0feb                      	add ZL, r27 //point Z to offsetted instrument
00173a 1df2                      	adc ZH, zero
00173b 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
00173c 1fff                      	rol ZH
00173d 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
00173e 91b4                      	lpm r27, Z
                                 
00173f 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001740 1fbb                      	rol r27
001741 2fea                      	mov ZL, r26
001742 2ffb                      	mov ZH, r27
001743 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001744 9632                      	adiw Z, 2 //point Z to the address of the macro
001745 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel0_instrument_change_macro_loop:
001746 95aa                      	dec r26
001747 f019                      	breq sound_driver_channel0_instrument_change_exit
001748 95b6                      	lsr r27
001749 f078                      	brcs sound_driver_channel0_instrument_change_load_macro
00174a cffb                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_exit:
00174b e0a3                      	ldi r26, 0x03
00174c e0b2                      	ldi r27, 0x02
00174d 93b0 2822                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
00174f 93a0 2827                 	sts pulse1_arpeggio_macro_offset, r26
001751 93b0 282e                 	sts pulse1_pitch_macro_offset, r27
001753 93b0 2834                 	sts pulse1_hi_pitch_macro_offset, r27
001755 93b0 2839                 	sts pulse1_duty_macro_offset, r27
001757 d0ba                      	rcall sound_driver_channel0_increment_offset_twice
001758 cdf4                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_load_macro:
001759 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
00175a 91d5                      	lpm r29, Z+
                                 
00175b 30a5                      	cpi r26, 5
00175c f039                      	breq sound_driver_channel0_instrument_change_load_macro_volume
00175d 30a4                      	cpi r26, 4
00175e f079                      	breq sound_driver_channel0_instrument_change_load_macro_arpeggio
00175f 30a3                      	cpi r26, 3
001760 f0d9                      	breq sound_driver_channel0_instrument_change_load_macro_pitch
001761 30a2                      	cpi r26, 2
001762 f159                      	breq sound_driver_channel0_instrument_change_load_macro_hi_pitch
001763 c03c                      	rjmp sound_driver_channel0_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel0_instrument_change_load_macro_volume:
001764 93c0 2820                 	sts pulse1_volume_macro, r28
001766 93d0 2821                 	sts pulse1_volume_macro+1, r29
001768 d041                      	rcall sound_driver_channel0_instrument_change_read_header
001769 93c0 2824                 	sts pulse1_volume_macro_release, r28
00176b 93d0 2823                 	sts pulse1_volume_macro_loop, r29
00176d cfd8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 	
                                 sound_driver_channel0_instrument_change_load_macro_arpeggio:
00176e 93c0 2825                 	sts pulse1_arpeggio_macro, r28
001770 93d0 2826                 	sts pulse1_arpeggio_macro+1, r29
001772 9220 2859                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001774 9220 285a                 	sts pulse1_fx_Qxy_target+1, zero
001776 9220 285f                 	sts pulse1_fx_Rxy_target, zero
001778 9220 2860                 	sts pulse1_fx_Rxy_target+1, zero
00177a d03a                      	rcall sound_driver_channel0_instrument_change_read_header_arpeggio
00177b cfca                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_pitch:
00177c 93c0 282c                 	sts pulse1_pitch_macro, r28
00177e 93d0 282d                 	sts pulse1_pitch_macro+1, r29
001780 9220 2859                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001782 9220 285a                 	sts pulse1_fx_Qxy_target+1, zero
001784 9220 285f                 	sts pulse1_fx_Rxy_target, zero
001786 9220 2860                 	sts pulse1_fx_Rxy_target+1, zero
001788 d021                      	rcall sound_driver_channel0_instrument_change_read_header
001789 93c0 2830                 	sts pulse1_pitch_macro_release, r28
00178b 93d0 282f                 	sts pulse1_pitch_macro_loop, r29
00178d cfb8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_hi_pitch:
00178e 93c0 2832                 	sts pulse1_hi_pitch_macro, r28
001790 93d0 2833                 	sts pulse1_hi_pitch_macro+1, r29
001792 9220 2859                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001794 9220 285a                 	sts pulse1_fx_Qxy_target+1, zero
001796 9220 285f                 	sts pulse1_fx_Rxy_target, zero
001798 9220 2860                 	sts pulse1_fx_Rxy_target+1, zero
00179a d00f                      	rcall sound_driver_channel0_instrument_change_read_header
00179b 93c0 2836                 	sts pulse1_hi_pitch_macro_release, r28
00179d 93d0 2835                 	sts pulse1_hi_pitch_macro_loop, r29
00179f cfa6                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_duty:
0017a0 93c0 2837                 	sts pulse1_duty_macro, r28
0017a2 93d0 2838                 	sts pulse1_duty_macro+1, r29
0017a4 d005                      	rcall sound_driver_channel0_instrument_change_read_header
0017a5 93c0 283b                 	sts pulse1_duty_macro_release, r28
0017a7 93d0 283a                 	sts pulse1_duty_macro_loop, r29
0017a9 cf9c                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_read_header:
0017aa 93ef                      	push ZL
0017ab 93ff                      	push ZH
0017ac 2fec                      	mov ZL, r28
0017ad 2ffd                      	mov ZH, r29
0017ae 0fee                      	lsl ZL
0017af 1fff                      	rol ZH
0017b0 91c5                      	lpm r28, Z+
0017b1 91d4                      	lpm r29, Z
0017b2 91ff                      	pop ZH
0017b3 91ef                      	pop ZL
0017b4 9508                      	ret
                                 
                                 sound_driver_channel0_instrument_change_read_header_arpeggio:
0017b5 93ef                      	push ZL
0017b6 93ff                      	push ZH
0017b7 2fec                      	mov ZL, r28
0017b8 2ffd                      	mov ZH, r29
0017b9 0fee                      	lsl ZL
0017ba 1fff                      	rol ZH
0017bb 91c5                      	lpm r28, Z+
0017bc 91d5                      	lpm r29, Z+
0017bd 93c0 2829                 	sts pulse1_arpeggio_macro_release, r28
0017bf 93d0 2828                 	sts pulse1_arpeggio_macro_loop, r29
0017c1 91c4                      	lpm r28, Z
0017c2 93c0 282a                 	sts pulse1_arpeggio_macro_mode, r28
0017c4 91ff                      	pop ZH
0017c5 91ef                      	pop ZL
0017c6 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel0_release:
                                 sound_driver_channel0_release_volume:
0017c7 91b0 2824                 	lds r27, pulse1_volume_macro_release
0017c9 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
0017ca f019                      	breq sound_driver_channel0_release_arpeggio //if the macro has no release flag, check the next macro
0017cb 95b3                      	inc r27
0017cc 93b0 2822                 	sts pulse1_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel0_release_arpeggio:
0017ce 91b0 2829                 	lds r27, pulse1_arpeggio_macro_release
0017d0 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
0017d1 f019                      	breq sound_driver_channel0_release_pitch
0017d2 95b3                      	inc r27
0017d3 93b0 2827                 	sts pulse1_arpeggio_macro_offset, r27
                                 sound_driver_channel0_release_pitch:
0017d5 91b0 2830                 	lds r27, pulse1_pitch_macro_release
0017d7 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
0017d8 f019                      	breq sound_driver_channel0_release_hi_pitch
0017d9 95b3                      	inc r27
0017da 93b0 282e                 	sts pulse1_pitch_macro_offset, r27
                                 sound_driver_channel0_release_hi_pitch:
0017dc 91b0 2836                 	lds r27, pulse1_hi_pitch_macro_release
0017de 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
0017df f019                      	breq sound_driver_channel0_release_duty
0017e0 95b3                      	inc r27
0017e1 93b0 2834                 	sts pulse1_hi_pitch_macro_offset, r27
                                 sound_driver_channel0_release_duty:
0017e3 91b0 283b                 	lds r27, pulse1_duty_macro_release
0017e5 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
0017e6 f019                      	breq sound_driver_channel0_release_exit
0017e7 95b3                      	inc r27
0017e8 93b0 2839                 	sts pulse1_duty_macro_offset, r27
                                 sound_driver_channel0_release_exit:
0017ea d01d                      	rcall sound_driver_channel0_increment_offset
0017eb cd61                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_next_pattern:
0017ec 91e0 2810                 	lds ZL, song_frames
0017ee 91f0 2811                 	lds ZH, song_frames+1
0017f0 91a0 2812                 	lds r26, song_frame_offset //we must offset to the appropriate channel
0017f2 91b0 2813                 	lds r27, song_frame_offset+1
0017f4 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
0017f5 93a0 2812                 	sts song_frame_offset, r26
0017f7 93b0 2813                 	sts song_frame_offset+1, r27
0017f9 0fea                      	add ZL, r26
0017fa 1ffb                      	adc ZH, r27
                                 
0017fb 91a5                      	lpm r26, Z+ //load the address of the next pattern
0017fc 91b4                      	lpm r27, Z
0017fd 0faa                      	lsl r26
0017fe 1fbb                      	rol r27
0017ff 93a0 281a                 	sts pulse1_pattern, r26
001801 93b0 281b                 	sts pulse1_pattern+1, r27
                                 
001803 9220 281e                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001805 9220 281f                 	sts pulse1_pattern_offset+1, zero
001807 cd45                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_increment_offset:
001808 91e0 281e                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
00180a 91f0 281f                 	lds ZH, pulse1_pattern_offset+1
00180c 9631                      	adiw Z, 1
00180d 93e0 281e                 	sts pulse1_pattern_offset, ZL
00180f 93f0 281f                 	sts pulse1_pattern_offset+1, ZH
001811 9508                      	ret
                                 
                                 sound_driver_channel0_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001812 91e0 281e                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
001814 91f0 281f                 	lds ZH, pulse1_pattern_offset+1
001816 9632                      	adiw Z, 2 //increment the pointer twice
001817 93e0 281e                 	sts pulse1_pattern_offset, ZL
001819 93f0 281f                 	sts pulse1_pattern_offset+1, ZH
00181b 9508                      	ret
                                 
                                 sound_driver_channel0_decrement_frame_delay:
00181c 95ba                      	dec r27
00181d 93b0 281d                 	sts pulse1_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel1:
00181f 91a0 2869                 	lds r26, pulse2_pattern_delay_rows
001821 91b0 286a                 	lds r27, pulse2_pattern_delay_frames
001823 9610                      	adiw r27:r26, 0
001824 f009                      	breq sound_driver_channel1_main //if the pattern delay is 0, proceed with sound driver procedures
001825 c2cb                      	rjmp sound_driver_channel1_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel1_main:
001826 91e0 2867                 	lds ZL, pulse2_pattern //current pattern for pulse 2
001828 91f0 2868                 	lds ZH, pulse2_pattern+1
00182a 91a0 286b                 	lds r26, pulse2_pattern_offset //current offset in the pattern for pulse 2
00182c 91b0 286c                 	lds r27, pulse2_pattern_offset+1
00182e 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
00182f 1ffb                      	adc ZH, r27
001830 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel1_check_if_note: //check if data is a note (0x00 - 0x56)
001831 35b7                      	cpi r27, 0x57
001832 f408                      	brsh sound_driver_channel1_check_if_volume
001833 c178                      	rjmp sound_driver_channel1_note
                                 sound_driver_channel1_check_if_volume: //check if data is volume (0x57-0x66)
001834 36b7                      	cpi r27, 0x67
001835 f408                      	brsh sound_driver_channel1_check_if_delay
001836 c1b0                      	rjmp sound_driver_channel1_volume
                                 sound_driver_channel1_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001837 3eb3                      	cpi r27, 0xE3
001838 f408                      	brsh sound_driver_channel1_check_if_instrument
001839 c1b7                      	rjmp sound_driver_channel1_delay
                                 sound_driver_channel1_check_if_instrument: //check for instrument flag (0xE3)
00183a f409                      	brne sound_driver_channel1_check_if_release
00183b c1ba                      	rjmp sound_driver_channel1_instrument_change 
                                 sound_driver_channel1_check_if_release: //check for note release flag (0xE4)
00183c 3eb4                      	cpi r27, 0xE4
00183d f409                      	brne sound_driver_channel1_check_if_end
00183e c261                      	rjmp sound_driver_channel1_release
                                 sound_driver_channel1_check_if_end:
00183f 3fbf                      	cpi r27, 0xFF
001840 f409                      	brne sound_driver_channel1_check_if_fx
001841 c283                      	rjmp sound_driver_channel1_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel1_check_if_fx: //fx flags (0xE5 - 0xFE)
001842 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001843 91a4                      	lpm r26, Z //load the fx data into r26
001844 d2a2                      	rcall sound_driver_channel1_increment_offset_twice
                                 
001845 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001846 efe0                      	ldi ZL, LOW(channel1_fx << 1) //load in note table
001847 e4f4                      	ldi ZH, HIGH(channel1_fx << 1)
001848 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001849 0feb                      	add ZL, r27 //add offset
00184a 1df2                      	adc ZH, zero
00184b 91c5                      	lpm r28, Z+ //load address bytes
00184c 91d4                      	lpm r29, Z
00184d 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
00184e 2ffd                      	mov ZH, r29
00184f 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel1_fx_0xy:
001850 93a0 2889                 	sts pulse2_fx_0xy_sequence, r26
001852 9220 288a                 	sts pulse2_fx_0xy_sequence+1, zero
001854 cfd1                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel1_fx_1xx:
001855 9220 288f                 	sts pulse2_fx_2xx, zero //turn off any 2xx pitch slide down
001857 9220 2890                 	sts pulse2_fx_2xx+1, zero
001859 9220 2889                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
00185b 9220 288a                 	sts pulse2_fx_0xy_sequence+1, zero
00185d 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00185e 937f                      	push r23
00185f 2f6a                      	mov r22, r26 //store the rate into r22
001860 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001861 9f67                      	mul r22, r23
001862 917f                      	pop r23
001863 916f                      	pop r22
                                 
001864 9416                      	lsr r1 //shift out the fractional bits
001865 9407                      	ror r0
001866 9416                      	lsr r1
001867 9407                      	ror r0
001868 9416                      	lsr r1
001869 9407                      	ror r0
00186a 9416                      	lsr r1
00186b 9407                      	ror r0
00186c 9200 288b                 	sts pulse2_fx_1xx, r0
00186e 9210 288c                 	sts pulse2_fx_1xx+1, r1
001870 cfb5                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel1_fx_2xx:
001871 9220 288b                 	sts pulse2_fx_1xx, zero //turn off any 1xx pitch slide down
001873 9220 288c                 	sts pulse2_fx_1xx+1, zero
001875 9220 2889                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
001877 9220 288a                 	sts pulse2_fx_0xy_sequence+1, zero
001879 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00187a 937f                      	push r23
00187b 2f6a                      	mov r22, r26 //store the rate into r22
00187c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00187d 9f67                      	mul r22, r23
00187e 917f                      	pop r23
00187f 916f                      	pop r22
                                 
001880 9416                      	lsr r1 //shift out the fractional bits
001881 9407                      	ror r0
001882 9416                      	lsr r1
001883 9407                      	ror r0
001884 9416                      	lsr r1
001885 9407                      	ror r0
001886 9416                      	lsr r1
001887 9407                      	ror r0
001888 9200 288f                 	sts pulse2_fx_2xx, r0
00188a 9210 2890                 	sts pulse2_fx_2xx+1, r1
00188c cf99                      	rjmp sound_driver_channel1_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel1_fx_3xx:
00188d 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00188e 937f                      	push r23
00188f 2f6a                      	mov r22, r26 //store the rate into r22
001890 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001891 9f67                      	mul r22, r23
001892 917f                      	pop r23
001893 916f                      	pop r22
                                 
001894 9416                      	lsr r1 //shift out the fractional bits
001895 9407                      	ror r0
001896 9416                      	lsr r1
001897 9407                      	ror r0
001898 9416                      	lsr r1
001899 9407                      	ror r0
00189a 9416                      	lsr r1
00189b 9407                      	ror r0
00189c 9200 2897                 	sts pulse2_fx_3xx_speed, r0
00189e 9210 2898                 	sts pulse2_fx_3xx_speed+1, r1
                                 
0018a0 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
0018a1 c001                      	rjmp sound_driver_channel1_fx_3xx_enabled
0018a2 cf83                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_3xx_enabled:
0018a3 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
0018a5 91b0 0a9d                 	lds r27, TCB1_CCMPH
0018a7 93a0 2893                 	sts pulse2_fx_3xx_start, r26
0018a9 93b0 2894                 	sts pulse2_fx_3xx_start+1, r27
                                 
0018ab 9220 2899                 	sts pulse2_fx_3xx_total_offset, zero
0018ad 9220 289a                 	sts pulse2_fx_3xx_total_offset+1, zero
0018af cf76                      	rjmp sound_driver_channel1_main
                                 
                                 //VIBRATO
                                 sound_driver_channel1_fx_4xy:
0018b0 2fba                      	mov r27, r26
0018b1 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
0018b2 95a2                      	swap r26
0018b3 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0018b4 93a0 289b                 	sts pulse2_fx_4xy_speed, r26
0018b6 93b0 289c                 	sts pulse2_fx_4xy_depth, r27
0018b8 9220 289d                 	sts pulse2_fx_4xy_phase, zero //reset the phase to 0
0018ba cf6b                      	rjmp sound_driver_channel1_main
                                 
                                 //TREMELO
                                 sound_driver_channel1_fx_7xy:
0018bb 2fba                      	mov r27, r26
0018bc 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
0018bd 95a2                      	swap r26
0018be 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0018bf 93a0 289e                 	sts pulse2_fx_7xy_speed, r26
0018c1 93b0 289f                 	sts pulse2_fx_7xy_depth, r27
0018c3 9220 28a0                 	sts pulse2_fx_7xy_phase, zero //reset the phase to 0
0018c5 9220 28a1                 	sts pulse2_fx_7xy_value, zero //reset the tremelo value
0018c7 cf5e                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel1_fx_Axy:
0018c8 93a0 28a2                 	sts pulse2_fx_Axy, r26
0018ca cf5b                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel1_fx_Bxx:
0018cb 93a0 2817                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
0018cd cf58                      	rjmp sound_driver_channel1_main
                                 
                                 //HALT
                                 sound_driver_channel1_fx_Cxx:
0018ce 93b0 2818                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
0018d0 cf55                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel1_fx_Dxx:
0018d1 93b0 2819                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
0018d3 cf52                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME
                                 sound_driver_channel1_fx_Exx:
0018d4 91b0 2808                 	lds r27, pulse2_param
0018d6 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
0018d7 2bba                      	or r27, r26 //move new VVVV bits into pulse2_param
0018d8 93b0 2808                 	sts pulse2_param, r27
0018da 6092                      	sbr channel_flags, 2
0018db cf4a                      	rjmp sound_driver_channel1_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel1_fx_Fxx:
0018dc 93a0 2816                 	sts song_speed, r26 //NOTE: only changes to speed are supported
0018de cf47                      	rjmp sound_driver_channel1_main
                                 
                                 //DELAY
                                 sound_driver_channel1_fx_Gxx:
0018df 15a2                      	cp r26, zero
0018e0 f051                      	breq sound_driver_channel1_fx_Gxx_invalid
0018e1 91b0 2816                 	lds r27, song_speed
0018e3 17ab                      	cp r26, r27
0018e4 f430                      	brsh sound_driver_channel1_fx_Gxx_invalid
0018e5 93a0 28a3                 	sts pulse2_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
0018e7 e0b1                      	ldi r27, 0x01
0018e8 93b0 2869                 	sts pulse2_pattern_delay_rows, r27
0018ea c209                      	rjmp sound_driver_calculate_delays
                                 sound_driver_channel1_fx_Gxx_invalid:
0018eb cf3a                      	rjmp sound_driver_channel1_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel1_fx_Hxy: //hardware sweep up
0018ec 95a2                      	swap r26
0018ed 68a8                      	ori r26, 0b10001000 //enable negate and enable sweep flag
0018ee 2efa                      	mov pulse2_sweep, r26
0018ef 92f0 2809                 	sts pulse2_sweep_param, pulse2_sweep
0018f1 6093                      	sbr channel_flags, 3 //set reload flag
0018f2 cf33                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_Ixy: //hardware sweep down
0018f3 95a2                      	swap r26
0018f4 77af                      	andi r26, 0b01111111 //disable negate flag
0018f5 60a8                      	ori r26, 0b00001000 //enable sweep flag
0018f6 2efa                      	mov pulse2_sweep, r26
0018f7 92f0 2809                 	sts pulse2_sweep_param, pulse2_sweep
0018f9 6093                      	sbr channel_flags, 3 //set reload flag
0018fa cf2b                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_Hxx: //FDS modulation depth
0018fb cf2a                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixx: //FDS modulation speed
0018fc cf29                      	rjmp sound_driver_channel1_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel1_fx_Pxx:
0018fd 93a0 28a5                 	sts pulse2_fx_Pxx, r26
0018ff cf26                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel1_fx_Qxy:
                                 sound_driver_channel1_fx_Qxy_check_arpeggio_macro:
001900 91e0 2872                 	lds ZL, pulse2_arpeggio_macro
001902 91f0 2873                 	lds ZH, pulse2_arpeggio_macro+1
001904 9630                      	adiw Z, 0
001905 f009                      	breq sound_driver_channel1_fx_Qxy_check_pitch_macro
001906 cf1f                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_pitch_macro:
001907 91e0 2879                 	lds ZL, pulse2_pitch_macro
001909 91f0 287a                 	lds ZH, pulse2_pitch_macro+1
00190b 9630                      	adiw Z, 0
00190c f009                      	breq sound_driver_channel1_fx_Qxy_check_hi_pitch_macro
00190d cf18                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_hi_pitch_macro:
00190e 91e0 287f                 	lds ZL, pulse2_hi_pitch_macro
001910 91f0 2880                 	lds ZH, pulse2_hi_pitch_macro+1
001912 9630                      	adiw Z, 0
001913 f009                      	breq sound_driver_channel1_fx_Qxy_process
001914 cf11                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_process:
001915 2fba                      	mov r27, r26 //copy fx parameters into r27
001916 70bf                      	andi r27, 0x0F //mask note index offset
001917 91c0 280f                 	lds r28, pulse2_note //load current note index
001919 0fbc                      	add r27, r28
00191a 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
00191b f008                      	brlo sound_driver_channel1_fx_Qxy_process_continue
00191c e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel1_fx_Qxy_process_continue:
00191d e3e8                      	ldi ZL, LOW(note_table << 1) //load in note table
00191e e0f0                      	ldi ZH, HIGH(note_table << 1)
00191f 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001920 0feb                      	add ZL, r27 //add offset
001921 1df2                      	adc ZH, zero
001922 91c5                      	lpm r28, Z+ //load bytes
001923 91d4                      	lpm r29, Z
001924 93c0 28a6                 	sts pulse2_fx_Qxy_target, r28 //load the LOW bits for the target period
001926 93d0 28a7                 	sts pulse2_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
001928 95a2                      	swap r26
001929 70af                      	andi r26, 0x0F //mask effect speed
00192a 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
00192b 95a3                      	inc r26 //increment the speed by 1
                                 
00192c 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00192d 937f                      	push r23
00192e 2f6a                      	mov r22, r26 //store the speed data into r27
00192f eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001930 9f67                      	mul r22, r23
001931 917f                      	pop r23
001932 916f                      	pop r22
                                 
001933 9416                      	lsr r1 //shift out the fractional bits
001934 9407                      	ror r0
001935 9416                      	lsr r1
001936 9407                      	ror r0
001937 9416                      	lsr r1
001938 9407                      	ror r0
001939 9416                      	lsr r1
00193a 9407                      	ror r0
                                 
00193b 9200 28a8                 	sts pulse2_fx_Qxy_speed, r0 //store the effect speed
00193d 9210 28a9                 	sts pulse2_fx_Qxy_speed+1, r1
00193f 9220 28aa                 	sts pulse2_fx_Qxy_total_offset, zero
001941 9220 28ab                 	sts pulse2_fx_Qxy_total_offset+1, zero
001943 cee2                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel1_fx_Rxy:
                                 sound_driver_channel1_fx_Rxy_check_arpeggio_macro:
001944 91e0 2872                 	lds ZL, pulse2_arpeggio_macro
001946 91f0 2873                 	lds ZH, pulse2_arpeggio_macro+1
001948 9630                      	adiw Z, 0
001949 f009                      	breq sound_driver_channel1_fx_Rxy_check_pitch_macro
00194a cedb                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_pitch_macro:
00194b 91e0 2879                 	lds ZL, pulse2_pitch_macro
00194d 91f0 287a                 	lds ZH, pulse2_pitch_macro+1
00194f 9630                      	adiw Z, 0
001950 f009                      	breq sound_driver_channel1_fx_Rxy_check_hi_pitch_macro
001951 ced4                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_hi_pitch_macro:
001952 91e0 287f                 	lds ZL, pulse2_hi_pitch_macro
001954 91f0 2880                 	lds ZH, pulse2_hi_pitch_macro+1
001956 9630                      	adiw Z, 0
001957 f009                      	breq sound_driver_channel1_fx_Rxy_process
001958 cecd                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_process:
001959 2fba                      	mov r27, r26 //copy fx parameters into r27
00195a 70bf                      	andi r27, 0x0F //mask note index offset
00195b 91c0 280f                 	lds r28, pulse2_note //load current note index
00195d 1bcb                      	sub r28, r27
00195e f408                      	brcc sound_driver_channel1_fx_Rxy_process_continue
00195f e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel1_fx_Rxy_process_continue:
001960 e3e8                      	ldi ZL, LOW(note_table << 1) //load in note table
001961 e0f0                      	ldi ZH, HIGH(note_table << 1)
001962 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001963 0fec                      	add ZL, r28 //add offset
001964 1df2                      	adc ZH, zero
001965 91c5                      	lpm r28, Z+ //load bytes
001966 91d4                      	lpm r29, Z
001967 93c0 28ac                 	sts pulse2_fx_Rxy_target, r28 //load the LOW bits for the target period
001969 93d0 28ad                 	sts pulse2_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
00196b 95a2                      	swap r26
00196c 70af                      	andi r26, 0x0F //mask effect speed
00196d 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
00196e 95a3                      	inc r26 //increment the speed by 1
                                 
00196f 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001970 937f                      	push r23
001971 2f6a                      	mov r22, r26 //store the speed data into r27
001972 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001973 9f67                      	mul r22, r23
001974 917f                      	pop r23
001975 916f                      	pop r22
                                 
001976 9416                      	lsr r1 //shift out the fractional bits
001977 9407                      	ror r0
001978 9416                      	lsr r1
001979 9407                      	ror r0
00197a 9416                      	lsr r1
00197b 9407                      	ror r0
00197c 9416                      	lsr r1
00197d 9407                      	ror r0
                                 
00197e 9200 28ae                 	sts pulse2_fx_Rxy_speed, r0 //store the effect speed
001980 9210 28af                 	sts pulse2_fx_Rxy_speed+1, r1
001982 9220 28b0                 	sts pulse2_fx_Rxy_total_offset, zero
001984 9220 28b1                 	sts pulse2_fx_Rxy_total_offset+1, zero
001986 ce9f                      	rjmp sound_driver_channel1_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel1_fx_Sxx:
001987 15a2                      	cp r26, zero
001988 f051                      	breq sound_driver_channel1_fx_Sxx_invalid
001989 91b0 2816                 	lds r27, song_speed
00198b 17ab                      	cp r26, r27
00198c f430                      	brsh sound_driver_channel1_fx_Sxx_invalid
00198d 93a0 28b2                 	sts pulse2_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
00198f e0b1                      	ldi r27, 0x01
001990 93b0 2869                 	sts pulse2_pattern_delay_rows, r27
001992 c161                      	rjmp sound_driver_calculate_delays
                                 sound_driver_channel1_fx_Sxx_invalid:
001993 ce92                      	rjmp sound_driver_channel1_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel1_fx_Vxx:
001994 ebe8                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
001995 e4f4                      	ldi ZH, HIGH(sequences << 1)
001996 0fea                      	add ZL, r26 //offset the pointer
001997 1df2                      	adc ZH, zero
                                 
001998 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
001999 95a7                      	ror r26
00199a 95a7                      	ror r26
00199b 91b0 2808                 	lds r27, pulse2_param //load r27 with pulse2_param (register $4000)
00199d 2fcb                      	mov r28, r27 //store a copy of pulse2_param into r28
00199e 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
00199f 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
0019a0 c001                      	rjmp sound_driver_channel1_fx_Vxx_store
0019a1 ce84                      	rjmp sound_driver_channel1_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel1_fx_Vxx_store:
0019a2 90d4                      	lpm pulse2_sequence, Z //store the sequence
                                 
0019a3 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
0019a4 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
0019a5 93c0 2808                 	sts pulse2_param, r28
0019a7 ce7e                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_Wxx: //DPCM sample speed
0019a8 ce7d                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Xxx: //DPCM sample retrigger
0019a9 ce7c                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Yxx: //DPCM sample offset
0019aa ce7b                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Zxx: //DPCM sample delta counter
0019ab ce7a                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 sound_driver_channel1_note:
0019ac 93b0 280f                 	sts pulse2_note, r27 //store the note index
0019ae e0a3                      	ldi r26, 0x03
0019af e0b2                      	ldi r27, 0x02
0019b0 93b0 286f                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
0019b2 93a0 2874                 	sts pulse2_arpeggio_macro_offset, r26
0019b4 93b0 287b                 	sts pulse2_pitch_macro_offset, r27
0019b6 93b0 2881                 	sts pulse2_hi_pitch_macro_offset, r27
0019b8 93b0 2886                 	sts pulse2_duty_macro_offset, r27
0019ba 9220 2878                 	sts pulse2_total_pitch_offset, zero //reset the pitch and hi pitch offset
0019bc 9220 287e                 	sts pulse2_total_hi_pitch_offset, zero
0019be 9220 288d                 	sts pulse2_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
0019c0 9220 288e                 	sts pulse2_fx_1xx_total+1, zero
0019c2 9220 2891                 	sts pulse2_fx_2xx_total, zero
0019c4 9220 2892                 	sts pulse2_fx_2xx_total+1, zero
0019c6 9220 2899                 	sts pulse2_fx_3xx_total_offset, zero //reset 3xx offset
0019c8 9220 289a                 	sts pulse2_fx_3xx_total_offset+1, zero
0019ca 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
0019cc 91b0 0a9d                 	lds r27, TCB1_CCMPH
0019ce 93a0 2893                 	sts pulse2_fx_3xx_start, r26
0019d0 93b0 2894                 	sts pulse2_fx_3xx_start+1, r27
0019d2 9220 2809                 	sts pulse2_sweep_param, zero //reset any sweep effect
0019d4 6093                      	sbr channel_flags, 3 //set reload flag
0019d5 9220 28a6                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0019d7 9220 28a7                 	sts pulse2_fx_Qxy_target+1, zero
0019d9 9220 28aa                 	sts pulse2_fx_Qxy_total_offset, zero
0019db 9220 28ab                 	sts pulse2_fx_Qxy_total_offset+1, zero
0019dd 9220 28ac                 	sts pulse2_fx_Rxy_target, zero
0019df 9220 28ad                 	sts pulse2_fx_Rxy_target+1, zero
0019e1 9220 28b0                 	sts pulse2_fx_Rxy_total_offset, zero
0019e3 9220 28b1                 	sts pulse2_fx_Rxy_total_offset+1, zero
0019e5 d0f7                      	rcall sound_driver_channel1_increment_offset
0019e6 ce3f                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_volume:
0019e7 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
0019e8 91a0 2808                 	lds r26, pulse2_param
0019ea 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
0019eb 2bab                      	or r26, r27 //move new VVVV bits into pulse2_param
0019ec 93a0 2808                 	sts pulse2_param, r26
0019ee 6092                      	sbr channel_flags, 2
0019ef d0ed                      	rcall sound_driver_channel1_increment_offset
0019f0 ce35                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_delay:
0019f1 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
0019f2 93b0 2869                 	sts pulse2_pattern_delay_rows, r27
0019f4 d0e8                      	rcall sound_driver_channel1_increment_offset
0019f5 c0fe                      	rjmp sound_driver_calculate_delays
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change:
0019f6 9220 286d                 	sts pulse2_volume_macro, zero //reset all macro addresses
0019f8 9220 286e                 	sts pulse2_volume_macro+1, zero
0019fa 9220 2872                 	sts pulse2_arpeggio_macro, zero
0019fc 9220 2873                 	sts pulse2_arpeggio_macro+1, zero
0019fe 9220 2879                 	sts pulse2_pitch_macro, zero
001a00 9220 287a                 	sts pulse2_pitch_macro+1, zero
001a02 9220 287f                 	sts pulse2_hi_pitch_macro, zero
001a04 9220 2880                 	sts pulse2_hi_pitch_macro+1, zero
001a06 9220 2884                 	sts pulse2_duty_macro, zero
001a08 9220 2885                 	sts pulse2_duty_macro+1, zero
001a0a 9220 2878                 	sts pulse2_total_pitch_offset, zero //reset the pitch offset
001a0c 9220 287e                 	sts pulse2_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001a0e 9631                      	adiw Z, 1 //point to the byte next to the flag
001a0f 91b4                      	lpm r27, Z //store the instrument offset into r27
001a10 ebe5                      	ldi ZL, LOW(instruments) //point Z to instruments table
001a11 e0ff                      	ldi ZH, HIGH(instruments)
001a12 0feb                      	add ZL, r27 //point Z to offsetted instrument
001a13 1df2                      	adc ZH, zero
001a14 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001a15 1fff                      	rol ZH
001a16 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001a17 91b4                      	lpm r27, Z
                                 
001a18 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001a19 1fbb                      	rol r27
001a1a 2fea                      	mov ZL, r26
001a1b 2ffb                      	mov ZH, r27
001a1c 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001a1d 9632                      	adiw Z, 2 //point Z to the address of the macro
001a1e e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel1_instrument_change_macro_loop:
001a1f 95aa                      	dec r26
001a20 f019                      	breq sound_driver_channel1_instrument_change_exit
001a21 95b6                      	lsr r27
001a22 f078                      	brcs sound_driver_channel1_instrument_change_load_macro
001a23 cffb                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_exit:
001a24 e0a3                      	ldi r26, 0x03
001a25 e0b2                      	ldi r27, 0x02
001a26 93b0 286f                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
001a28 93a0 2874                 	sts pulse2_arpeggio_macro_offset, r26
001a2a 93b0 287b                 	sts pulse2_pitch_macro_offset, r27
001a2c 93b0 2881                 	sts pulse2_hi_pitch_macro_offset, r27
001a2e 93b0 2886                 	sts pulse2_duty_macro_offset, r27
001a30 d0b6                      	rcall sound_driver_channel1_increment_offset_twice
001a31 cdf4                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_load_macro:
001a32 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001a33 91d5                      	lpm r29, Z+
                                 
001a34 30a5                      	cpi r26, 5
001a35 f039                      	breq sound_driver_channel1_instrument_change_load_macro_volume
001a36 30a4                      	cpi r26, 4
001a37 f079                      	breq sound_driver_channel1_instrument_change_load_macro_arpeggio
001a38 30a3                      	cpi r26, 3
001a39 f0d9                      	breq sound_driver_channel1_instrument_change_load_macro_pitch
001a3a 30a2                      	cpi r26, 2
001a3b f159                      	breq sound_driver_channel1_instrument_change_load_macro_hi_pitch
001a3c c03c                      	rjmp sound_driver_channel1_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel1_instrument_change_load_macro_volume:
001a3d 93c0 286d                 	sts pulse2_volume_macro, r28
001a3f 93d0 286e                 	sts pulse2_volume_macro+1, r29
001a41 d041                      	rcall sound_driver_channel1_instrument_change_read_header
001a42 93c0 2871                 	sts pulse2_volume_macro_release, r28
001a44 93d0 2870                 	sts pulse2_volume_macro_loop, r29
001a46 cfd8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 	
                                 sound_driver_channel1_instrument_change_load_macro_arpeggio:
001a47 93c0 2872                 	sts pulse2_arpeggio_macro, r28
001a49 93d0 2873                 	sts pulse2_arpeggio_macro+1, r29
001a4b 9220 28a6                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001a4d 9220 28a7                 	sts pulse2_fx_Qxy_target+1, zero
001a4f 9220 28ac                 	sts pulse2_fx_Rxy_target, zero
001a51 9220 28ad                 	sts pulse2_fx_Rxy_target+1, zero
001a53 d03a                      	rcall sound_driver_channel1_instrument_change_read_header_arpeggio
001a54 cfca                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_pitch:
001a55 93c0 2879                 	sts pulse2_pitch_macro, r28
001a57 93d0 287a                 	sts pulse2_pitch_macro+1, r29
001a59 9220 28a6                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001a5b 9220 28a7                 	sts pulse2_fx_Qxy_target+1, zero
001a5d 9220 28ac                 	sts pulse2_fx_Rxy_target, zero
001a5f 9220 28ad                 	sts pulse2_fx_Rxy_target+1, zero
001a61 d021                      	rcall sound_driver_channel1_instrument_change_read_header
001a62 93c0 287d                 	sts pulse2_pitch_macro_release, r28
001a64 93d0 287c                 	sts pulse2_pitch_macro_loop, r29
001a66 cfb8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_hi_pitch:
001a67 93c0 287f                 	sts pulse2_hi_pitch_macro, r28
001a69 93d0 2880                 	sts pulse2_hi_pitch_macro+1, r29
001a6b 9220 28a6                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001a6d 9220 28a7                 	sts pulse2_fx_Qxy_target+1, zero
001a6f 9220 28ac                 	sts pulse2_fx_Rxy_target, zero
001a71 9220 28ad                 	sts pulse2_fx_Rxy_target+1, zero
001a73 d00f                      	rcall sound_driver_channel1_instrument_change_read_header
001a74 93c0 2883                 	sts pulse2_hi_pitch_macro_release, r28
001a76 93d0 2882                 	sts pulse2_hi_pitch_macro_loop, r29
001a78 cfa6                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_duty:
001a79 93c0 2884                 	sts pulse2_duty_macro, r28
001a7b 93d0 2885                 	sts pulse2_duty_macro+1, r29
001a7d d005                      	rcall sound_driver_channel1_instrument_change_read_header
001a7e 93c0 2888                 	sts pulse2_duty_macro_release, r28
001a80 93d0 2887                 	sts pulse2_duty_macro_loop, r29
001a82 cf9c                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_read_header:
001a83 93ef                      	push ZL
001a84 93ff                      	push ZH
001a85 2fec                      	mov ZL, r28
001a86 2ffd                      	mov ZH, r29
001a87 0fee                      	lsl ZL
001a88 1fff                      	rol ZH
001a89 91c5                      	lpm r28, Z+
001a8a 91d4                      	lpm r29, Z
001a8b 91ff                      	pop ZH
001a8c 91ef                      	pop ZL
001a8d 9508                      	ret
                                 
                                 sound_driver_channel1_instrument_change_read_header_arpeggio:
001a8e 93ef                      	push ZL
001a8f 93ff                      	push ZH
001a90 2fec                      	mov ZL, r28
001a91 2ffd                      	mov ZH, r29
001a92 0fee                      	lsl ZL
001a93 1fff                      	rol ZH
001a94 91c5                      	lpm r28, Z+
001a95 91d5                      	lpm r29, Z+
001a96 93c0 2876                 	sts pulse2_arpeggio_macro_release, r28
001a98 93d0 2875                 	sts pulse2_arpeggio_macro_loop, r29
001a9a 91c4                      	lpm r28, Z
001a9b 93c0 2877                 	sts pulse2_arpeggio_macro_mode, r28
001a9d 91ff                      	pop ZH
001a9e 91ef                      	pop ZL
001a9f 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel1_release:
                                 sound_driver_channel1_release_volume:
001aa0 91b0 2871                 	lds r27, pulse2_volume_macro_release
001aa2 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001aa3 f019                      	breq sound_driver_channel1_release_arpeggio //if the macro has no release flag, check the next macro
001aa4 95b3                      	inc r27
001aa5 93b0 286f                 	sts pulse2_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel1_release_arpeggio:
001aa7 91b0 2876                 	lds r27, pulse2_arpeggio_macro_release
001aa9 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001aaa f019                      	breq sound_driver_channel1_release_pitch
001aab 95b3                      	inc r27
001aac 93b0 2874                 	sts pulse2_arpeggio_macro_offset, r27
                                 sound_driver_channel1_release_pitch:
001aae 91b0 287d                 	lds r27, pulse2_pitch_macro_release
001ab0 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001ab1 f019                      	breq sound_driver_channel1_release_hi_pitch
001ab2 95b3                      	inc r27
001ab3 93b0 287b                 	sts pulse2_pitch_macro_offset, r27
                                 sound_driver_channel1_release_hi_pitch:
001ab5 91b0 2883                 	lds r27, pulse2_hi_pitch_macro_release
001ab7 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001ab8 f019                      	breq sound_driver_channel1_release_duty
001ab9 95b3                      	inc r27
001aba 93b0 2881                 	sts pulse2_hi_pitch_macro_offset, r27
                                 sound_driver_channel1_release_duty:
001abc 91b0 2888                 	lds r27, pulse2_duty_macro_release
001abe 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001abf f019                      	breq sound_driver_channel1_release_exit
001ac0 95b3                      	inc r27
001ac1 93b0 2886                 	sts pulse2_duty_macro_offset, r27
                                 sound_driver_channel1_release_exit:
001ac3 d019                      	rcall sound_driver_channel1_increment_offset
001ac4 cd61                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_next_pattern:
001ac5 91e0 2810                 	lds ZL, song_frames
001ac7 91f0 2811                 	lds ZH, song_frames+1
001ac9 91a0 2812                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001acb 91b0 2813                 	lds r27, song_frame_offset+1
001acd 9612                      	adiw r27:r26, 2 //offset for channel 1
001ace 0fea                      	add ZL, r26
001acf 1ffb                      	adc ZH, r27
                                 
001ad0 91a5                      	lpm r26, Z+ //load the address of the next pattern
001ad1 91b4                      	lpm r27, Z
001ad2 0faa                      	lsl r26
001ad3 1fbb                      	rol r27
001ad4 93a0 2867                 	sts pulse2_pattern, r26
001ad6 93b0 2868                 	sts pulse2_pattern+1, r27
                                 
001ad8 9220 286b                 	sts pulse2_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001ada 9220 286c                 	sts pulse2_pattern_offset+1, zero
001adc cd49                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_increment_offset:
001add 91e0 286b                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001adf 91f0 286c                 	lds ZH, pulse2_pattern_offset+1
001ae1 9631                      	adiw Z, 1
001ae2 93e0 286b                 	sts pulse2_pattern_offset, ZL
001ae4 93f0 286c                 	sts pulse2_pattern_offset+1, ZH
001ae6 9508                      	ret
                                 
                                 sound_driver_channel1_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001ae7 91e0 286b                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001ae9 91f0 286c                 	lds ZH, pulse2_pattern_offset+1
001aeb 9632                      	adiw Z, 2 //increment the pointer twice
001aec 93e0 286b                 	sts pulse2_pattern_offset, ZL
001aee 93f0 286c                 	sts pulse2_pattern_offset+1, ZH
001af0 9508                      	ret
                                 
                                 sound_driver_channel1_decrement_frame_delay:
001af1 95ba                      	dec r27
001af2 93b0 286a                 	sts pulse2_pattern_delay_frames, r27
                                 
                                 
                                 sound_driver_calculate_delays:
001af4 91f0 2816                 	lds r31, song_speed
001af6 2fef                      	mov r30, r31
001af7 50e1                      	subi r30, 1
                                 sound_driver_calculate_delays_pulse1:
001af8 91a0 281d                 	lds r26, pulse1_pattern_delay_frames
001afa 11a2                      	cpse r26, zero
001afb c042                      	rjmp sound_driver_calculate_delays_pulse2
001afc c000                      	rjmp sound_driver_calculate_delays_pulse1_main
                                 
                                 sound_driver_calculate_delays_pulse1_main:
001afd 2faf                      	mov r26, r31 //move the speed to r26
001afe 91b0 281c                 	lds r27, pulse1_pattern_delay_rows //decrement the delay rows
001b00 15b2                      	cp r27, zero
001b01 f409                      	brne PC+2
001b02 c03b                      	rjmp sound_driver_calculate_delays_pulse2
001b03 95ba                      	dec r27
001b04 93b0 281c                 	sts pulse1_pattern_delay_rows, r27
001b06 11b2                      	cpse r27, zero
001b07 c034                      	rjmp sound_driver_calculate_delays_pulse1_store
001b08 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx:
001b09 efbf                      	ldi r27, 0xFF
001b0a 91c0 2865                 	lds r28, pulse1_fx_Sxx_pre
001b0c 91d0 2866                 	lds r29, pulse1_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse1_Sxx_check_pre:
001b0e 17cb                      	cp r28, r27
001b0f f009                      	breq sound_driver_calculate_delays_pulse1_Sxx_check_post
001b10 c00d                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_pre
                                 sound_driver_calculate_delays_pulse1_Sxx_check_post:
001b11 17db                      	cp r29, r27
001b12 f009                      	breq sound_driver_calculate_delays_pulse1_Gxx
001b13 c015                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx:
001b14 91c0 2856                 	lds r28, pulse1_fx_Gxx_pre
001b16 91d0 2857                 	lds r29, pulse1_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse1_Gxx_check_pre:
001b18 17cb                      	cp r28, r27
001b19 f009                      	breq sound_driver_calculate_delays_pulse1_Gxx_check_post
001b1a c012                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_pre
                                 sound_driver_calculate_delays_pulse1_Gxx_check_post:
001b1b 17db                      	cp r29, r27
001b1c f0f9                      	breq sound_driver_calculate_delays_pulse1_store
001b1d c01a                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_pre:
001b1e 93b0 2865                 	sts pulse1_fx_Sxx_pre, r27
001b20 1bec                      	sub r30, r28 //(song speed)-1-Sxx
001b21 93e0 2866                 	sts pulse1_fx_Sxx_post, r30
001b23 95ca                      	dec r28
001b24 93c0 281d                 	sts pulse1_pattern_delay_frames, r28
001b26 2fef                      	mov r30, r31
001b27 50e1                      	subi r30, 1
001b28 c015                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_post:
001b29 93b0 2866                 	sts pulse1_fx_Sxx_post, r27
001b2b 2fad                      	mov r26, r29
001b2c c00f                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx_pre:
001b2d 93b0 2856                 	sts pulse1_fx_Gxx_pre, r27
001b2f 1bec                      	sub r30, r28 //(song speed)-1-Sxx
001b30 93e0 2857                 	sts pulse1_fx_Gxx_post, r30
001b32 95ca                      	dec r28
001b33 93c0 281d                 	sts pulse1_pattern_delay_frames, r28
001b35 2fef                      	mov r30, r31
001b36 50e1                      	subi r30, 1
001b37 c006                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse1_Gxx_post:
001b38 93b0 2857                 	sts pulse1_fx_Gxx_post, r27
001b3a 2fad                      	mov r26, r29
001b3b c000                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_store:
001b3c 93a0 281d                 	sts pulse1_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_pulse2:
001b3e 91a0 286a                 	lds r26, pulse2_pattern_delay_frames
001b40 11a2                      	cpse r26, zero
001b41 c042                      	rjmp sound_driver_calculate_delays_triangle
001b42 c000                      	rjmp sound_driver_calculate_delays_pulse2_main
                                 
                                 sound_driver_calculate_delays_pulse2_main:
001b43 2faf                      	mov r26, r31 //move the speed to r26
001b44 91b0 2869                 	lds r27, pulse2_pattern_delay_rows //decrement the delay rows
001b46 15b2                      	cp r27, zero
001b47 f409                      	brne PC+2
001b48 c03b                      	rjmp sound_driver_calculate_delays_triangle
001b49 95ba                      	dec r27
001b4a 93b0 2869                 	sts pulse2_pattern_delay_rows, r27
001b4c 11b2                      	cpse r27, zero
001b4d c034                      	rjmp sound_driver_calculate_delays_pulse2_store
001b4e 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx:
001b4f efbf                      	ldi r27, 0xFF
001b50 91c0 28b2                 	lds r28, pulse2_fx_Sxx_pre
001b52 91d0 28b3                 	lds r29, pulse2_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse2_Sxx_check_pre:
001b54 17cb                      	cp r28, r27
001b55 f009                      	breq sound_driver_calculate_delays_pulse2_Sxx_check_post
001b56 c00d                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_pre
                                 sound_driver_calculate_delays_pulse2_Sxx_check_post:
001b57 17db                      	cp r29, r27
001b58 f009                      	breq sound_driver_calculate_delays_pulse2_Gxx
001b59 c015                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx:
001b5a 91c0 28a3                 	lds r28, pulse2_fx_Gxx_pre
001b5c 91d0 28a4                 	lds r29, pulse2_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse2_Gxx_check_pre:
001b5e 17cb                      	cp r28, r27
001b5f f009                      	breq sound_driver_calculate_delays_pulse2_Gxx_check_post
001b60 c012                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_pre
                                 sound_driver_calculate_delays_pulse2_Gxx_check_post:
001b61 17db                      	cp r29, r27
001b62 f0f9                      	breq sound_driver_calculate_delays_pulse2_store
001b63 c01a                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_pre:
001b64 93b0 28b2                 	sts pulse2_fx_Sxx_pre, r27
001b66 1bec                      	sub r30, r28 //(song speed)-1-Sxx
001b67 93e0 28b3                 	sts pulse2_fx_Sxx_post, r30
001b69 95ca                      	dec r28
001b6a 93c0 286a                 	sts pulse2_pattern_delay_frames, r28
001b6c 2fef                      	mov r30, r31
001b6d 50e1                      	subi r30, 1
001b6e cfcf                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_post:
001b6f 93b0 28b3                 	sts pulse2_fx_Sxx_post, r27
001b71 2fad                      	mov r26, r29
001b72 c00f                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx_pre:
001b73 93b0 28a3                 	sts pulse2_fx_Gxx_pre, r27
001b75 1bec                      	sub r30, r28 //(song speed)-1-Sxx
001b76 93e0 28a4                 	sts pulse2_fx_Gxx_post, r30
001b78 95ca                      	dec r28
001b79 93c0 286a                 	sts pulse2_pattern_delay_frames, r28
001b7b 2fef                      	mov r30, r31
001b7c 50e1                      	subi r30, 1
001b7d cfc0                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse2_Gxx_post:
001b7e 93b0 28a4                 	sts pulse2_fx_Gxx_post, r27
001b80 2fad                      	mov r26, r29
001b81 c000                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_store:
001b82 93a0 286a                 	sts pulse2_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_triangle:
                                 
                                 
                                 
                                 sound_driver_instrument_fx_routine:
                                 sound_driver_instrument_routine_channel0_volume:
001b84 91e0 2820                 	lds ZL, pulse1_volume_macro
001b86 91f0 2821                 	lds ZH, pulse1_volume_macro+1
001b88 9630                      	adiw Z, 0
001b89 f1a1                      	breq sound_driver_instrument_routine_channel0_volume_default //if no volume macro is in use, use default multiplier of F
001b8a 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
001b8b 1fff                      	rol ZH
001b8c 91a0 2822                 	lds r26, pulse1_volume_macro_offset
001b8e 0fea                      	add ZL, r26
001b8f 1df2                      	adc ZH, zero
                                 
001b90 91b0 2824                 	lds r27, pulse1_volume_macro_release
001b92 17ba                      	cp r27, r26
001b93 f429                      	brne sound_driver_instrument_routine_channel0_volume_increment //if the current offset is not equal to the release index, increment the offset
001b94 91a0 2823                 	lds r26, pulse1_volume_macro_loop
001b96 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
001b97 f010                      	brlo sound_driver_instrument_routine_channel0_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
001b98 c003                      	rjmp sound_driver_instrument_routine_channel0_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_volume_increment:
001b99 95a3                      	inc r26 //increment the macro offset
001b9a 93a0 2822                 	sts pulse1_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_volume_read:
001b9c 91b4                      	lpm r27, Z //load volume data into r27
001b9d 3fbf                      	cpi r27, 0xFF //check for macro end flag
001b9e f469                      	brne sound_driver_instrument_routine_channel0_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_release:
001b9f 91b0 2824                 	lds r27, pulse1_volume_macro_release
001ba1 3fbf                      	cpi r27, 0xFF
001ba2 f429                      	brne sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_loop:
001ba3 91b0 2823                 	lds r27, pulse1_volume_macro_loop //load the loop index
001ba5 93b0 2822                 	sts pulse1_volume_macro_offset, r27 //store the loop index into the offset
001ba7 cfdc                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index:
001ba8 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
001ba9 93a0 2822                 	sts pulse1_volume_macro_offset, r26
001bab cfd8                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_calculate:
001bac e2e4                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
001bad e4f5                      	ldi ZH, HIGH(volumes << 1)
001bae 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
001baf 0feb                      	add ZL, r27 //add offset to the table
001bb0 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel0_volume_load:
001bb1 91b0 2800                 	lds r27, pulse1_param //load main volume
001bb3 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
001bb4 91a0 2854                 	lds r26, pulse1_fx_7xy_value
001bb6 30a0                      	cpi r26, 0x00
001bb7 f481                      	brne sound_driver_instrument_routine_channel0_volume_load_7xy
                                 
001bb8 0feb                      	add ZL, r27 //offset the volume table by the main volume
001bb9 1df2                      	adc ZH, zero
001bba 91b4                      	lpm r27, Z
001bbb 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
001bbd c024                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default:
001bbe 91b0 2800                 	lds r27, pulse1_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
001bc0 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
001bc1 91a0 2854                 	lds r26, pulse1_fx_7xy_value
001bc3 30a0                      	cpi r26, 0x00
001bc4 f4a1                      	brne sound_driver_instrument_routine_channel0_volume_default_7xy
001bc5 93b0 2806                 	sts pulse1_output_volume, r27
001bc7 c01a                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy:
001bc8 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
001bc9 f040                      	brcs sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
001bca f039                      	breq sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
001bcb e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
                                 
001bcc 0feb                      	add ZL, r27 //offset the volume table by the main volume
001bcd 1df2                      	adc ZH, zero
001bce 91b4                      	lpm r27, Z
001bcf 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
001bd1 c010                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy_overflow:
001bd2 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
001bd3 0feb                      	add ZL, r27 //offset the volume table by the main volume
001bd4 1df2                      	adc ZH, zero
001bd5 91b4                      	lpm r27, Z
001bd6 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
001bd8 c009                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default_7xy:
001bd9 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
001bda f020                      	brcs sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
001bdb f019                      	breq sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
001bdc 93b0 2806                 	sts pulse1_output_volume, r27
001bde c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel0_volume_default_7xy_overflow:
001bdf e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
001be0 93b0 2806                 	sts pulse1_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
001be2 91e0 2825                 	lds ZL, pulse1_arpeggio_macro
001be4 91f0 2826                 	lds ZH, pulse1_arpeggio_macro+1
001be6 9630                      	adiw Z, 0
001be7 f1d9                      	breq sound_driver_instrument_routine_channel0_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
001be8 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
001be9 1fff                      	rol ZH
001bea 91a0 2827                 	lds r26, pulse1_arpeggio_macro_offset
001bec 0fea                      	add ZL, r26
001bed 1df2                      	adc ZH, zero
                                 
001bee 91b0 2829                 	lds r27, pulse1_arpeggio_macro_release
001bf0 17ba                      	cp r27, r26
001bf1 f429                      	brne sound_driver_instrument_routine_channel0_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
001bf2 91a0 2828                 	lds r26, pulse1_arpeggio_macro_loop
001bf4 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
001bf5 f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
001bf6 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_increment:
001bf7 95a3                      	inc r26 //increment the macro offset
001bf8 93a0 2827                 	sts pulse1_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_read:
001bfa 91b4                      	lpm r27, Z //load arpeggio data into r27
001bfb 38b0                      	cpi r27, 0x80 //check for macro end flag
001bfc f009                      	breq sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag
001bfd c041                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_check_mode:
001bfe 50a1                      	subi r26, 1 //keep the offset at the end flag
001bff 93a0 2827                 	sts pulse1_arpeggio_macro_offset, r26
001c01 91b0 282a                 	lds r27, pulse1_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
001c03 30b1                      	cpi r27, 0x01
001c04 f048                      	brlo sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_release:
001c05 91b0 2829                 	lds r27, pulse1_arpeggio_macro_release
001c07 3fbf                      	cpi r27, 0xFF
001c08 f4d1                      	brne sound_driver_instrument_routine_channel0_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_loop:
001c09 91b0 2828                 	lds r27, pulse1_arpeggio_macro_loop
001c0b 3fbf                      	cpi r27, 0xFF
001c0c f499                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
001c0d c015                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute:
001c0e 91b0 2829                 	lds r27, pulse1_arpeggio_macro_release
001c10 3fbf                      	cpi r27, 0xFF
001c11 f421                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_check_loop:
001c12 91b0 2828                 	lds r27, pulse1_arpeggio_macro_loop //load the loop index
001c14 3fbf                      	cpi r27, 0xFF //check if loop flag exists
001c15 f451                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop:
001c16 91c0 283c                 	lds r28, pulse1_fx_0xy_sequence //check for 0xy effect
001c18 91d0 283d                 	lds r29, pulse1_fx_0xy_sequence+1
001c1a 9620                      	adiw r29:r28, 0
001c1b f469                      	brne sound_driver_instrument_routine_channel0_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
001c1c 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
001c1d 93a0 2827                 	sts pulse1_arpeggio_macro_offset, r26 //store the last valid index into the offset
001c1f cfc2                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload:
001c20 93b0 2827                 	sts pulse1_arpeggio_macro_offset, r27 //store the loop index into the offset
001c22 cfbf                      	rjmp sound_driver_instrument_routine_channel0_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_default:
001c23 91c0 283c                 	lds r28, pulse1_fx_0xy_sequence //load 0xy effect
001c25 91d0 283d                 	lds r29, pulse1_fx_0xy_sequence+1
001c27 9620                      	adiw r29:r28, 0 //check for 0xy effect
001c28 f099                      	breq sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel0_arpeggio_default_xy:
001c29 95d6                      	lsr r29
001c2a 95c7                      	ror r28
001c2b 95d7                      	ror r29
001c2c 95c7                      	ror r28
001c2d 95d7                      	ror r29
001c2e 95c7                      	ror r28
001c2f 95d7                      	ror r29
001c30 95c7                      	ror r28
001c31 95d7                      	ror r29
001c32 95d2                      	swap r29
                                 
001c33 93c0 283c                 	sts pulse1_fx_0xy_sequence, r28 //store the rolled sequence
001c35 93d0 283d                 	sts pulse1_fx_0xy_sequence+1, r29
001c37 70cf                      	andi r28, 0x0F //mask out the 4 LSB
001c38 91a0 2807                 	lds r26, pulse1_note //load the current note index
001c3a 0fac                      	add r26, r28 //add the note offset
001c3b c02c                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
001c3c 91a0 2807                 	lds r26, pulse1_note //load the current note index
001c3e c029                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process:
001c3f 9220 282b                 	sts pulse1_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
001c41 9220 2831                 	sts pulse1_total_hi_pitch_offset, zero
001c43 91a0 282a                 	lds r26, pulse1_arpeggio_macro_mode
001c45 30a1                      	cpi r26, 0x01 //absolute mode
001c46 f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_absolute
001c47 f069                      	breq sound_driver_instrument_routine_channel0_arpeggio_process_fixed
001c48 c00e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute:
001c49 91a0 2807                 	lds r26, pulse1_note //load the current note index
001c4b 0fab                      	add r26, r27 //offset the note with the arpeggio data
001c4c fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
001c4d c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_add:
001c4e 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
001c4f f0c0                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
001c50 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
001c51 c016                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract:
001c52 fda7                      	sbrc r26, 7 //check if result is negative
001c53 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
001c54 c013                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_fixed:
001c55 2fab                      	mov r26, r27 //move the arpeggio data into r26
001c56 c011                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative:
001c57 91a0 2807                 	lds r26, pulse1_note //load the current note index
001c59 0fab                      	add r26, r27 //offset the note with the arpeggio data
001c5a fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
001c5b c008                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_add:
001c5c 93a0 2807                 	sts pulse1_note, r26 //NOTE: relative mode modifies the original note index
001c5e 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
001c5f f040                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
001c60 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
001c61 93a0 2807                 	sts pulse1_note, r26
001c63 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract:
001c64 fda7                      	sbrc r26, 7 //check if result is negative
001c65 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
001c66 93a0 2807                 	sts pulse1_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_load:
001c68 e3e8                      	ldi ZL, LOW(note_table << 1) //load in note table
001c69 e0f0                      	ldi ZH, HIGH(note_table << 1)
001c6a 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
001c6b 0fea                      	add ZL, r26 //add offset
001c6c 1df2                      	adc ZH, zero
001c6d 91a5                      	lpm r26, Z+ //load bytes
001c6e 91b4                      	lpm r27, Z
001c6f 93a0 0a8c                 	sts TCB0_CCMPL, r26 //load the LOW bits for timer
001c71 93b0 0a8d                 	sts TCB0_CCMPH, r27 //load the HIGH bits for timer
001c73 93a0 2848                 	sts pulse1_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
001c75 93b0 2849                 	sts pulse1_fx_3xx_target+1, r27
001c77 c000                      	rjmp sound_driver_instrument_routine_channel0_pitch
                                 
                                 
                                 
                                 //NOTE: There is a limitation with the pitch routines in that the total pitch can not be offset by 127 in both,
                                 //the positive and negative direction, from the original note pitch. This shouldn't be too much of a problem as
                                 //most songs that use instruments with the pitch macro, do not stray that far from the original note pitch.
                                 //In the case of hi pitch, the total pitch can not be offset by 127*16 from the original pitch. This is also
                                 //not a big deal as you can easily reach the entire note range with an offset of up to 127*16.
                                 sound_driver_instrument_routine_channel0_pitch:
001c78 91e0 282c                 	lds ZL, pulse1_pitch_macro
001c7a 91f0 282d                 	lds ZH, pulse1_pitch_macro+1
001c7c 9630                      	adiw Z, 0
001c7d f409                      	brne sound_driver_instrument_routine_channel0_pitch_continue
001c7e c023                      	rjmp sound_driver_instrument_routine_channel0_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel0_pitch_continue:
001c7f 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
001c80 1fff                      	rol ZH
001c81 91a0 282e                 	lds r26, pulse1_pitch_macro_offset
001c83 0fea                      	add ZL, r26
001c84 1df2                      	adc ZH, zero
                                 
001c85 91b0 2830                 	lds r27, pulse1_pitch_macro_release
001c87 17ba                      	cp r27, r26
001c88 f429                      	brne sound_driver_instrument_routine_channel0_pitch_increment //if the current offset is not equal to the release index, increment the offset
001c89 91a0 282f                 	lds r26, pulse1_pitch_macro_loop
001c8b 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
001c8c f010                      	brlo sound_driver_instrument_routine_channel0_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
001c8d c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_pitch_increment:
001c8e 95a3                      	inc r26 //increment the macro offset
001c8f 93a0 282e                 	sts pulse1_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_pitch_read:
001c91 91b4                      	lpm r27, Z //load pitch data into r27
001c92 38b0                      	cpi r27, 0x80 //check for macro end flag
001c93 f489                      	brne sound_driver_instrument_routine_channel0_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_release:
001c94 50a1                      	subi r26, 1 //keep the macro offset at the end flag
001c95 93a0 282e                 	sts pulse1_pitch_macro_offset, r26
001c97 91b0 2830                 	lds r27, pulse1_pitch_macro_release
001c99 3fbf                      	cpi r27, 0xFF
001c9a f439                      	brne sound_driver_instrument_routine_channel0_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_loop:
001c9b 91b0 282f                 	lds r27, pulse1_pitch_macro_loop //load the loop index
001c9d 3fbf                      	cpi r27, 0xFF //check if there is a loop index
001c9e f019                      	breq sound_driver_instrument_routine_channel0_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
001c9f 93b0 282e                 	sts pulse1_pitch_macro_offset, r27 //store the loop index into the offset
001ca1 cfd6                      	rjmp sound_driver_instrument_routine_channel0_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_default:
001ca2 91b0 282b                 	lds r27, pulse1_total_pitch_offset
001ca4 c005                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate:
001ca5 91a0 282b                 	lds r26, pulse1_total_pitch_offset //load the total pitch offset to change
001ca7 0fba                      	add r27, r26
001ca8 93b0 282b                 	sts pulse1_total_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_multiply:
                                 	//NOTE: The Pxx effect is processed with the pitch instrument macro because the calculations are the same
001caa 91a0 2858                 	lds r26, pulse1_fx_Pxx
001cac 0fba                      	add r27, r26
                                 
001cad 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001cae 937f                      	push r23
001caf 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
001cb0 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001cb1 0367                      	mulsu r22, r23
001cb2 917f                      	pop r23
001cb3 916f                      	pop r22
                                 
001cb4 9416                      	lsr r1 //shift out the fractional bits
001cb5 9407                      	ror r0
001cb6 9416                      	lsr r1
001cb7 9407                      	ror r0
001cb8 9416                      	lsr r1
001cb9 9407                      	ror r0
001cba 9416                      	lsr r1
001cbb 9407                      	ror r0
001cbc fe13                      	sbrs r1, 3 //check if result was a negative number
001cbd c002                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_negative:
001cbe efb0                      	ldi r27, 0xF0
001cbf 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_offset:
001cc0 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
001cc2 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
001cc4 0da0                      	add r26, r0 //offset the timer values
001cc5 1db1                      	adc r27, r1
                                 	
001cc6 91c0 2840                 	lds r28, pulse1_fx_1xx_total
001cc8 91d0 2841                 	lds r29, pulse1_fx_1xx_total+1
001cca 1bac                      	sub r26, r28
001ccb 0bbd                      	sbc r27, r29
001ccc 91c0 2844                 	lds r28, pulse1_fx_2xx_total
001cce 91d0 2845                 	lds r29, pulse1_fx_2xx_total+1
001cd0 0fac                      	add r26, r28
001cd1 1fbd                      	adc r27, r29
001cd2 91c0 285d                 	lds r28, pulse1_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
001cd4 91d0 285e                 	lds r29, pulse1_fx_Qxy_total_offset+1
001cd6 1bac                      	sub r26, r28
001cd7 0bbd                      	sbc r27, r29
001cd8 91c0 2863                 	lds r28, pulse1_fx_Rxy_total_offset
001cda 91d0 2864                 	lds r29, pulse1_fx_Rxy_total_offset+1
001cdc 0fac                      	add r26, r28
001cdd 1fbd                      	adc r27, r29
                                 
001cde 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
001ce0 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel0_hi_pitch:
001ce2 91e0 2832                 	lds ZL, pulse1_hi_pitch_macro
001ce4 91f0 2833                 	lds ZH, pulse1_hi_pitch_macro+1
001ce6 9630                      	adiw Z, 0
001ce7 f409                      	brne sound_driver_instrument_routine_channel0_hi_pitch_continue
001ce8 c03c                      	rjmp sound_driver_instrument_routine_channel0_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel0_hi_pitch_continue:
001ce9 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
001cea 1fff                      	rol ZH
001ceb 91a0 2834                 	lds r26, pulse1_hi_pitch_macro_offset
001ced 0fea                      	add ZL, r26
001cee 1df2                      	adc ZH, zero
                                 
001cef 91b0 2836                 	lds r27, pulse1_hi_pitch_macro_release
001cf1 17ba                      	cp r27, r26
001cf2 f429                      	brne sound_driver_instrument_routine_channel0_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
001cf3 91a0 2835                 	lds r26, pulse1_hi_pitch_macro_loop
001cf5 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
001cf6 f010                      	brlo sound_driver_instrument_routine_channel0_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
001cf7 c003                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_increment:
001cf8 95a3                      	inc r26 //increment the macro offset
001cf9 93a0 2834                 	sts pulse1_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_hi_pitch_read:
001cfb 91b4                      	lpm r27, Z //load hi pitch data into r27
001cfc 38b0                      	cpi r27, 0x80 //check for macro end flag
001cfd f489                      	brne sound_driver_instrument_routine_channel0_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_release:
001cfe 50a1                      	subi r26, 1 //keep the macro offset at the end flag
001cff 93a0 2834                 	sts pulse1_hi_pitch_macro_offset, r26
001d01 91b0 2836                 	lds r27, pulse1_hi_pitch_macro_release
001d03 3fbf                      	cpi r27, 0xFF
001d04 f439                      	brne sound_driver_instrument_routine_channel0_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_loop:
001d05 91b0 2835                 	lds r27, pulse1_hi_pitch_macro_loop //load the loop index
001d07 3fbf                      	cpi r27, 0xFF //check if there is a loop index
001d08 f019                      	breq sound_driver_instrument_routine_channel0_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
001d09 93b0 2834                 	sts pulse1_hi_pitch_macro_offset, r27 //store the loop index into the offset
001d0b cfd6                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_default:
001d0c 91b0 2831                 	lds r27, pulse1_total_hi_pitch_offset
001d0e c005                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate:
001d0f 91a0 2831                 	lds r26, pulse1_total_hi_pitch_offset //load the total hi pitch offset to change
001d11 0fba                      	add r27, r26
001d12 93b0 2831                 	sts pulse1_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply:
001d14 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001d15 937f                      	push r23
001d16 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
001d17 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001d18 0367                      	mulsu r22, r23
001d19 917f                      	pop r23
001d1a 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_offset:
001d1b 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
001d1d 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
001d1f 0da0                      	add r26, r0 //offset the timer values
001d20 1db1                      	adc r27, r1
001d21 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
001d23 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel0_duty:
001d25 91e0 2837                 	lds ZL, pulse1_duty_macro
001d27 91f0 2838                 	lds ZH, pulse1_duty_macro+1
001d29 9630                      	adiw Z, 0
001d2a f1b1                      	breq sound_driver_channel0_fx_routines //if no duty macro is in use, go to the next routine
001d2b 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
001d2c 1fff                      	rol ZH
001d2d 91a0 2839                 	lds r26, pulse1_duty_macro_offset
001d2f 0fea                      	add ZL, r26
001d30 1df2                      	adc ZH, zero
                                 
001d31 91b0 283b                 	lds r27, pulse1_duty_macro_release
001d33 17ba                      	cp r27, r26
001d34 f429                      	brne sound_driver_instrument_routine_channel0_duty_increment //if the current offset is not equal to the release index, increment the offset
001d35 91a0 283a                 	lds r26, pulse1_duty_macro_loop
001d37 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
001d38 f010                      	brlo sound_driver_instrument_routine_channel0_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
001d39 c027                      	rjmp sound_driver_channel0_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel0_duty_increment:
001d3a 95a3                      	inc r26 //increment the macro offset
001d3b 93a0 2839                 	sts pulse1_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_duty_read:
001d3d 91b4                      	lpm r27, Z //load pitch data into r27
001d3e 3fbf                      	cpi r27, 0xFF //check for macro end flag
001d3f f471                      	brne sound_driver_instrument_routine_channel0_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_release:
001d40 50a1                      	subi r26, 1 //keep the macro offset at the end flag
001d41 93a0 2839                 	sts pulse1_duty_macro_offset, r26
001d43 91b0 283b                 	lds r27, pulse1_duty_macro_release
001d45 3fbf                      	cpi r27, 0xFF
001d46 f4d1                      	brne sound_driver_channel0_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_loop:
001d47 91b0 283a                 	lds r27, pulse1_duty_macro_loop //load the loop index
001d49 3fbf                      	cpi r27, 0xFF //check if there is a loop index
001d4a f0b1                      	breq sound_driver_channel0_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
001d4b 93b0 2839                 	sts pulse1_duty_macro_offset, r27 //store the loop index into the offset
001d4d cfd7                      	rjmp sound_driver_instrument_routine_channel0_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_load:
001d4e ebe8                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
001d4f e4f4                      	ldi ZH, HIGH(sequences << 1)
001d50 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
001d51 1df2                      	adc ZH, zero
                                 
001d52 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
001d53 95b7                      	ror r27
001d54 95b7                      	ror r27
001d55 91a0 2800                 	lds r26, pulse1_param //load r26 with pulse1_param (register $4000)
001d57 2fca                      	mov r28, r26 //store a copy of pulse1_param into r28
001d58 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
001d59 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
001d5a c001                      	rjmp sound_driver_instrument_routine_channel0_duty_load_store
001d5b c005                      	rjmp sound_driver_channel0_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel0_duty_load_store:
001d5c 90a4                      	lpm pulse1_sequence, Z //store the sequence
                                 
001d5d 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
001d5e 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
001d5f 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_routines:
                                 sound_driver_channel0_fx_1xx_routine:
001d61 91e0 283e                 	lds ZL, pulse1_fx_1xx
001d63 91f0 283f                 	lds ZH, pulse1_fx_1xx+1
001d65 9630                      	adiw Z, 0
001d66 f051                      	breq sound_driver_channel0_fx_2xx_routine
                                 
001d67 91a0 2840                 	lds r26, pulse1_fx_1xx_total //load the rate to change the pitch by
001d69 91b0 2841                 	lds r27, pulse1_fx_1xx_total+1
001d6b 0fae                      	add r26, ZL //increase the total offset by the rate
001d6c 1fbf                      	adc r27, ZH
001d6d 93a0 2840                 	sts pulse1_fx_1xx_total, r26
001d6f 93b0 2841                 	sts pulse1_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_2xx_routine:
001d71 91e0 2842                 	lds ZL, pulse1_fx_2xx
001d73 91f0 2843                 	lds ZH, pulse1_fx_2xx+1
001d75 9630                      	adiw Z, 0
001d76 f051                      	breq sound_driver_channel0_fx_3xx_routine
                                 
001d77 91a0 2844                 	lds r26, pulse1_fx_2xx_total //load the rate to change the pitch by
001d79 91b0 2845                 	lds r27, pulse1_fx_2xx_total+1
001d7b 0fae                      	add r26, ZL //increase the total offset by the rate
001d7c 1fbf                      	adc r27, ZH
001d7d 93a0 2844                 	sts pulse1_fx_2xx_total, r26
001d7f 93b0 2845                 	sts pulse1_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_3xx_routine:
001d81 91e0 284a                 	lds ZL, pulse1_fx_3xx_speed
001d83 91f0 284b                 	lds ZH, pulse1_fx_3xx_speed+1
001d85 9630                      	adiw Z, 0
001d86 f409                      	brne sound_driver_channel0_fx_3xx_routine_check_start
001d87 c048                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_check_start:
001d88 91a0 2846                 	lds r26, pulse1_fx_3xx_start
001d8a 91b0 2847                 	lds r27, pulse1_fx_3xx_start+1
001d8c 9610                      	adiw r26:r27, 0
001d8d f409                      	brne sound_driver_channel0_fx_3xx_routine_main
001d8e c041                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_main:
001d8f 91c0 2848                 	lds r28, pulse1_fx_3xx_target
001d91 91d0 2849                 	lds r29, pulse1_fx_3xx_target+1
                                 
001d93 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
001d94 07bd                      	cpc r27, r29
001d95 f011                      	breq sound_driver_channel0_fx_3xx_routine_disable
001d96 f030                      	brlo sound_driver_channel0_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
001d97 c01f                      	rjmp sound_driver_channel0_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel0_fx_3xx_routine_disable:
001d98 9220 2846                 	sts pulse1_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
001d9a 9220 2847                 	sts pulse1_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
001d9c c033                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_subtract:
001d9d 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
001d9e 0bdb                      	sbc r29, r27
001d9f 91a0 284c                 	lds r26, pulse1_fx_3xx_total_offset
001da1 91b0 284d                 	lds r27, pulse1_fx_3xx_total_offset+1
                                 
001da3 0fae                      	add r26, ZL //add the speed to the total offset
001da4 1fbf                      	adc r27, ZH
001da5 1bca                      	sub r28, r26 //invert the total difference with the total offset
001da6 0bdb                      	sbc r29, r27
001da7 f380                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
001da8 93a0 284c                 	sts pulse1_fx_3xx_total_offset, r26 //store the new total offset
001daa 93b0 284d                 	sts pulse1_fx_3xx_total_offset+1, r27
                                 
001dac 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the current timer period
001dae 91b0 0a8d                 	lds r27, TCB0_CCMPH
001db0 1bac                      	sub r26, r28 //offset the current timer period with the total offset
001db1 0bbd                      	sbc r27, r29
001db2 93a0 0a8c                 	sts TCB0_CCMPL, r26
001db4 93b0 0a8d                 	sts TCB0_CCMPH, r27
001db6 c019                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_add:
001db7 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
001db8 0bbd                      	sbc r27, r29
001db9 91c0 284c                 	lds r28, pulse1_fx_3xx_total_offset
001dbb 91d0 284d                 	lds r29, pulse1_fx_3xx_total_offset+1
                                 
001dbd 0fce                      	add r28, ZL //add the speed to the total offset
001dbe 1fdf                      	adc r29, ZH
001dbf 1bac                      	sub r26, r28 //invert the total difference with the total offset
001dc0 0bbd                      	sbc r27, r29
001dc1 f2b0                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
001dc2 93c0 284c                 	sts pulse1_fx_3xx_total_offset, r28 //store the new total offset
001dc4 93d0 284d                 	sts pulse1_fx_3xx_total_offset+1, r29
                                 
001dc6 91c0 0a8c                 	lds r28, TCB0_CCMPL //load the current timer period
001dc8 91d0 0a8d                 	lds r29, TCB0_CCMPH
001dca 0fca                      	add r28, r26 //offset the current timer period with the total offset
001dcb 1fdb                      	adc r29, r27
001dcc 93c0 0a8c                 	sts TCB0_CCMPL, r28
001dce 93d0 0a8d                 	sts TCB0_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel0_fx_4xy_routine:
001dd0 91a0 284e                 	lds r26, pulse1_fx_4xy_speed
001dd2 15a2                      	cp r26, zero
001dd3 f409                      	brne sound_driver_channel0_fx_4xy_routine_continue
001dd4 c05c                      	rjmp sound_driver_channel0_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel0_fx_4xy_routine_continue:
001dd5 91b0 284f                 	lds r27, pulse1_fx_4xy_depth
001dd7 91c0 2850                 	lds r28, pulse1_fx_4xy_phase
001dd9 0fca                      	add r28, r26 //increase the phase by the speed
001dda 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
001ddb f008                      	brlo sound_driver_channel0_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
001ddc 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase:
001ddd 93c0 2850                 	sts pulse1_fx_4xy_phase, r28 //store the new phase
001ddf 31c0                      	cpi r28, 16
001de0 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_0
001de1 32c0                      	cpi r28, 32
001de2 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_1
001de3 33c0                      	cpi r28, 48
001de4 f030                      	brlo sound_driver_channel0_fx_4xy_routine_phase_2
001de5 c007                      	rjmp sound_driver_channel0_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_0:
001de6 70cf                      	andi r28, 0x0F //mask for values 0-15
001de7 c029                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_1:
001de8 6fc0                      	ori r28, 0xF0
001de9 95c0                      	com r28 //invert values 0-15
001dea c026                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_2:
001deb 70cf                      	andi r28, 0x0F //mask for values 0-15
001dec c003                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_3:
001ded 6fc0                      	ori r28, 0xF0
001dee 95c0                      	com r28 //invert values 0-15
001def c000                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_add:
001df0 95b2                      	swap r27 //multiply depth by 16
001df1 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
001df2 eee6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
001df3 e0f0                      	ldi ZH, HIGH(vibrato_table << 1)
001df4 0fec                      	add ZL, r28 //offset the table by the depth+phase
001df5 1df2                      	adc ZH, zero
001df6 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
001df7 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001df8 937f                      	push r23
001df9 2f6c                      	mov r22, r28 //store the vibrato value into r22
001dfa eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001dfb 9f67                      	mul r22, r23
001dfc 917f                      	pop r23
001dfd 916f                      	pop r22
                                 
001dfe 9416                      	lsr r1 //shift out the fractional bits
001dff 9407                      	ror r0
001e00 9416                      	lsr r1
001e01 9407                      	ror r0
001e02 9416                      	lsr r1
001e03 9407                      	ror r0
001e04 9416                      	lsr r1
001e05 9407                      	ror r0
                                 	
001e06 91a0 0a8c                 	lds r26, TCB0_CCMPL
001e08 91b0 0a8d                 	lds r27, TCB0_CCMPH
001e0a 0da0                      	add r26, r0
001e0b 1db1                      	adc r27, r1
001e0c 93a0 0a8c                 	sts TCB0_CCMPL, r26
001e0e 93b0 0a8d                 	sts TCB0_CCMPH, r27
001e10 c020                      	rjmp sound_driver_channel0_fx_7xy_routine
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_subtract:
001e11 95b2                      	swap r27 //multiply depth by 16
001e12 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
001e13 eee6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
001e14 e0f0                      	ldi ZH, HIGH(vibrato_table << 1)
001e15 0fec                      	add ZL, r28 //offset the table by the depth+phase
001e16 1df2                      	adc ZH, zero
001e17 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
001e18 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001e19 937f                      	push r23
001e1a 2f6c                      	mov r22, r28 //store the vibrato value into r22
001e1b eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001e1c 9f67                      	mul r22, r23
001e1d 917f                      	pop r23
001e1e 916f                      	pop r22
                                 
001e1f 9416                      	lsr r1 //shift out the fractional bits
001e20 9407                      	ror r0
001e21 9416                      	lsr r1
001e22 9407                      	ror r0
001e23 9416                      	lsr r1
001e24 9407                      	ror r0
001e25 9416                      	lsr r1
001e26 9407                      	ror r0
                                 
001e27 91a0 0a8c                 	lds r26, TCB0_CCMPL
001e29 91b0 0a8d                 	lds r27, TCB0_CCMPH
001e2b 19a0                      	sub r26, r0
001e2c 09b1                      	sbc r27, r1
001e2d 93a0 0a8c                 	sts TCB0_CCMPL, r26
001e2f 93b0 0a8d                 	sts TCB0_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_7xy_routine:
001e31 91a0 2851                 	lds r26, pulse1_fx_7xy_speed
001e33 15a2                      	cp r26, zero
001e34 f0f1                      	breq sound_driver_channel0_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
001e35 91b0 2852                 	lds r27, pulse1_fx_7xy_depth
001e37 91c0 2853                 	lds r28, pulse1_fx_7xy_phase
001e39 0fca                      	add r28, r26 //increase the phase by the speed
001e3a 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
001e3b f010                      	brlo sound_driver_channel0_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
001e3c e0c0                      	ldi r28, 0x00
001e3d 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase:
001e3e 93c0 2853                 	sts pulse1_fx_7xy_phase, r28 //store the new phase
001e40 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
001e41 ffc4                      	sbrs r28, 4
001e42 c001                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_0
001e43 c002                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel0_fx_7xy_routine_phase_0:
001e44 70cf                      	andi r28, 0x0F //mask for values 0-15
001e45 c003                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase_1:
001e46 6fc0                      	ori r28, 0xF0
001e47 95c0                      	com r28 //invert values 0-15
001e48 c000                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_load:
001e49 95b2                      	swap r27 //multiply depth by 16
001e4a 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
001e4b eee6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
001e4c e0f0                      	ldi ZH, HIGH(vibrato_table << 1)
001e4d 0fec                      	add ZL, r28 //offset the table by the depth+phase
001e4e 1df2                      	adc ZH, zero
001e4f 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
001e50 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
001e51 93c0 2854                 	sts pulse1_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Axy_routine:
001e53 91b0 2855                 	lds r27, pulse1_fx_Axy
001e55 15b2                      	cp r27, zero
001e56 f0e9                      	breq sound_driver_channel0_fx_Qxy_routine //0 means that the effect is not in use
                                 	
001e57 91a0 2805                 	lds r26, pulse1_fractional_volume //load fractional volume representation of the channel
001e59 91c0 2800                 	lds r28, pulse1_param //load the integer volume representation of the channel
001e5b 2fda                      	mov r29, r26 //copy fractional volume into r29
001e5c 2fec                      	mov r30, r28 //copy the pulse1_param into r30
001e5d 95e2                      	swap r30
001e5e 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
001e5f 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
001e60 17ed                      	cp r30, r29 //compare the fractional and integer volumes
001e61 f009                      	breq sound_driver_channel0_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel0_fx_Axy_routine_reload:
001e62 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate:
001e63 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
001e64 c004                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_addition:
001e65 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
001e66 f428                      	brcc sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
001e67 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
001e68 c003                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_subtraction:
001e69 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
001e6a f008                      	brcs sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
001e6b e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_store:
001e6c 93a0 2805                 	sts pulse1_fractional_volume, r26 //store the new fractional volume
001e6e 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
001e6f 95a2                      	swap r26
001e70 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
001e71 2bca                      	or r28, r26 //store the new volume back into pulse1_param
001e72 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel0_fx_Qxy_routine:
001e74 91e0 2859                 	lds ZL, pulse1_fx_Qxy_target
001e76 91f0 285a                 	lds ZH, pulse1_fx_Qxy_target+1
001e78 9630                      	adiw Z, 0
001e79 f199                      	breq sound_driver_channel0_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
001e7a 91a0 285d                 	lds r26, pulse1_fx_Qxy_total_offset
001e7c 91b0 285e                 	lds r27, pulse1_fx_Qxy_total_offset+1
001e7e 91c0 0a8c                 	lds r28, TCB0_CCMPL
001e80 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
001e82 1bec                      	sub ZL, r28 //calculate the difference to the target
001e83 0bfd                      	sbc ZH, r29
001e84 f408                      	brsh sound_driver_channel0_fx_Qxy_routine_end //if the target has been reached (or passed)
001e85 f0e8                      	brlo sound_driver_channel0_fx_Qxy_routine_add
                                 
                                 sound_driver_channel0_fx_Qxy_routine_end:
001e86 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
001e87 0bbf                      	sbc r27, ZH
                                 
001e88 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001e89 937f                      	push r23
001e8a 9160 2858                 	lds r22, pulse1_fx_Pxx
001e8c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001e8d 9f67                      	mul r22, r23
001e8e 917f                      	pop r23
001e8f 916f                      	pop r22
001e90 9416                      	lsr r1 //shift out the fractional bits
001e91 9407                      	ror r0
001e92 9416                      	lsr r1
001e93 9407                      	ror r0
001e94 9416                      	lsr r1
001e95 9407                      	ror r0
001e96 9416                      	lsr r1
001e97 9407                      	ror r0
                                 
001e98 0da0                      	add r26, r0
001e99 1db2                      	adc r27, zero
                                 
001e9a 93a0 285d                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
001e9c 93b0 285e                 	sts pulse1_fx_Qxy_total_offset+1, r27
001e9e 9220 2859                 	sts pulse1_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
001ea0 9220 285a                 	sts pulse1_fx_Qxy_target+1, zero
001ea2 c00a                      	rjmp sound_driver_channel0_fx_Rxy_routine
                                 
                                 sound_driver_channel0_fx_Qxy_routine_add:
001ea3 91c0 285b                 	lds r28, pulse1_fx_Qxy_speed
001ea5 91d0 285c                 	lds r29, pulse1_fx_Qxy_speed+1
001ea7 0fac                      	add r26, r28 //increase the total offset by the speed
001ea8 1fbd                      	adc r27, r29
001ea9 93a0 285d                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
001eab 93b0 285e                 	sts pulse1_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Rxy_routine:
001ead 91e0 285f                 	lds ZL, pulse1_fx_Rxy_target
001eaf 91f0 2860                 	lds ZH, pulse1_fx_Rxy_target+1
001eb1 9630                      	adiw Z, 0
001eb2 f199                      	breq sound_driver_instrument_routine_channel1_volume //if the effect is not enabled, skip the routine
                                 
001eb3 91a0 2863                 	lds r26, pulse1_fx_Rxy_total_offset
001eb5 91b0 2864                 	lds r27, pulse1_fx_Rxy_total_offset+1
001eb7 91c0 0a8c                 	lds r28, TCB0_CCMPL
001eb9 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
001ebb 1bce                      	sub r28, ZL //calculate the difference to the target
001ebc 0bdf                      	sbc r29, ZH
001ebd f408                      	brsh sound_driver_channel0_fx_Rxy_routine_end //if the target has been reached (or passed)
001ebe f0e8                      	brlo sound_driver_channel0_fx_Rxy_routine_add
                                 
                                 sound_driver_channel0_fx_Rxy_routine_end:
001ebf 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
001ec0 0bbd                      	sbc r27, r29
                                 
001ec1 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001ec2 937f                      	push r23
001ec3 9160 2858                 	lds r22, pulse1_fx_Pxx
001ec5 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001ec6 9f67                      	mul r22, r23
001ec7 917f                      	pop r23
001ec8 916f                      	pop r22
001ec9 9416                      	lsr r1 //shift out the fractional bits
001eca 9407                      	ror r0
001ecb 9416                      	lsr r1
001ecc 9407                      	ror r0
001ecd 9416                      	lsr r1
001ece 9407                      	ror r0
001ecf 9416                      	lsr r1
001ed0 9407                      	ror r0
                                 
001ed1 0da0                      	add r26, r0
001ed2 1db2                      	adc r27, zero
                                 
001ed3 93a0 2863                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
001ed5 93b0 2864                 	sts pulse1_fx_Rxy_total_offset+1, r27
001ed7 9220 285f                 	sts pulse1_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
001ed9 9220 2860                 	sts pulse1_fx_Rxy_target+1, zero
001edb c00a                      	rjmp sound_driver_instrument_routine_channel1_volume
                                 
                                 sound_driver_channel0_fx_Rxy_routine_add:
001edc 91c0 2861                 	lds r28, pulse1_fx_Rxy_speed
001ede 91d0 2862                 	lds r29, pulse1_fx_Rxy_speed+1
001ee0 0fac                      	add r26, r28 //increase the total offset by the speed
001ee1 1fbd                      	adc r27, r29
001ee2 93a0 2863                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
001ee4 93b0 2864                 	sts pulse1_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume:
001ee6 91e0 286d                 	lds ZL, pulse2_volume_macro
001ee8 91f0 286e                 	lds ZH, pulse2_volume_macro+1
001eea 9630                      	adiw Z, 0
001eeb f1a1                      	breq sound_driver_instrument_routine_channel1_volume_default //if no volume macro is in use, use default multiplier of F
001eec 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
001eed 1fff                      	rol ZH
001eee 91a0 286f                 	lds r26, pulse2_volume_macro_offset
001ef0 0fea                      	add ZL, r26
001ef1 1df2                      	adc ZH, zero
                                 
001ef2 91b0 2871                 	lds r27, pulse2_volume_macro_release
001ef4 17ba                      	cp r27, r26
001ef5 f429                      	brne sound_driver_instrument_routine_channel1_volume_increment //if the current offset is not equal to the release index, increment the offset
001ef6 91a0 2870                 	lds r26, pulse2_volume_macro_loop
001ef8 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
001ef9 f010                      	brlo sound_driver_instrument_routine_channel1_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
001efa c003                      	rjmp sound_driver_instrument_routine_channel1_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_volume_increment:
001efb 95a3                      	inc r26 //increment the macro offset
001efc 93a0 286f                 	sts pulse2_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_volume_read:
001efe 91b4                      	lpm r27, Z //load volume data into r27
001eff 3fbf                      	cpi r27, 0xFF //check for macro end flag
001f00 f469                      	brne sound_driver_instrument_routine_channel1_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_release:
001f01 91b0 2871                 	lds r27, pulse2_volume_macro_release
001f03 3fbf                      	cpi r27, 0xFF
001f04 f429                      	brne sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_loop:
001f05 91b0 2870                 	lds r27, pulse2_volume_macro_loop //load the loop index
001f07 93b0 286f                 	sts pulse2_volume_macro_offset, r27 //store the loop index into the offset
001f09 cfdc                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index:
001f0a 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
001f0b 93a0 286f                 	sts pulse2_volume_macro_offset, r26
001f0d cfd8                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_calculate:
001f0e e2e4                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
001f0f e4f5                      	ldi ZH, HIGH(volumes << 1)
001f10 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
001f11 0feb                      	add ZL, r27 //add offset to the table
001f12 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel1_volume_load:
001f13 91b0 2808                 	lds r27, pulse2_param //load main volume
001f15 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
001f16 91a0 28a1                 	lds r26, pulse2_fx_7xy_value
001f18 30a0                      	cpi r26, 0x00
001f19 f481                      	brne sound_driver_instrument_routine_channel1_volume_load_7xy
                                 
001f1a 0feb                      	add ZL, r27 //offset the volume table by the main volume
001f1b 1df2                      	adc ZH, zero
001f1c 91b4                      	lpm r27, Z
001f1d 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
001f1f c024                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default:
001f20 91b0 2808                 	lds r27, pulse2_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
001f22 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
001f23 91a0 28a1                 	lds r26, pulse2_fx_7xy_value
001f25 30a0                      	cpi r26, 0x00
001f26 f4a1                      	brne sound_driver_instrument_routine_channel1_volume_default_7xy
001f27 93b0 280e                 	sts pulse2_output_volume, r27
001f29 c01a                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy:
001f2a 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
001f2b f040                      	brcs sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
001f2c f039                      	breq sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
001f2d e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
                                 
001f2e 0feb                      	add ZL, r27 //offset the volume table by the main volume
001f2f 1df2                      	adc ZH, zero
001f30 91b4                      	lpm r27, Z
001f31 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
001f33 c010                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy_overflow:
001f34 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
001f35 0feb                      	add ZL, r27 //offset the volume table by the main volume
001f36 1df2                      	adc ZH, zero
001f37 91b4                      	lpm r27, Z
001f38 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
001f3a c009                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default_7xy:
001f3b 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
001f3c f020                      	brcs sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
001f3d f019                      	breq sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
001f3e 93b0 280e                 	sts pulse2_output_volume, r27
001f40 c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel1_volume_default_7xy_overflow:
001f41 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
001f42 93b0 280e                 	sts pulse2_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
001f44 91e0 2872                 	lds ZL, pulse2_arpeggio_macro
001f46 91f0 2873                 	lds ZH, pulse2_arpeggio_macro+1
001f48 9630                      	adiw Z, 0
001f49 f1d9                      	breq sound_driver_instrument_routine_channel1_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
001f4a 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
001f4b 1fff                      	rol ZH
001f4c 91a0 2874                 	lds r26, pulse2_arpeggio_macro_offset
001f4e 0fea                      	add ZL, r26
001f4f 1df2                      	adc ZH, zero
                                 
001f50 91b0 2876                 	lds r27, pulse2_arpeggio_macro_release
001f52 17ba                      	cp r27, r26
001f53 f429                      	brne sound_driver_instrument_routine_channel1_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
001f54 91a0 2875                 	lds r26, pulse2_arpeggio_macro_loop
001f56 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
001f57 f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
001f58 c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_increment:
001f59 95a3                      	inc r26 //increment the macro offset
001f5a 93a0 2874                 	sts pulse2_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_read:
001f5c 91b4                      	lpm r27, Z //load arpeggio data into r27
001f5d 38b0                      	cpi r27, 0x80 //check for macro end flag
001f5e f009                      	breq sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag
001f5f c041                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_check_mode:
001f60 50a1                      	subi r26, 1 //keep the offset at the end flag
001f61 93a0 2874                 	sts pulse2_arpeggio_macro_offset, r26
001f63 91b0 2877                 	lds r27, pulse2_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
001f65 30b1                      	cpi r27, 0x01
001f66 f048                      	brlo sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_release:
001f67 91b0 2876                 	lds r27, pulse2_arpeggio_macro_release
001f69 3fbf                      	cpi r27, 0xFF
001f6a f4d1                      	brne sound_driver_instrument_routine_channel1_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_loop:
001f6b 91b0 2875                 	lds r27, pulse2_arpeggio_macro_loop
001f6d 3fbf                      	cpi r27, 0xFF
001f6e f499                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
001f6f c015                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute:
001f70 91b0 2876                 	lds r27, pulse2_arpeggio_macro_release
001f72 3fbf                      	cpi r27, 0xFF
001f73 f421                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_check_loop:
001f74 91b0 2875                 	lds r27, pulse2_arpeggio_macro_loop //load the loop index
001f76 3fbf                      	cpi r27, 0xFF //check if loop flag exists
001f77 f451                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop:
001f78 91c0 2889                 	lds r28, pulse2_fx_0xy_sequence //check for 0xy effect
001f7a 91d0 288a                 	lds r29, pulse2_fx_0xy_sequence+1
001f7c 9620                      	adiw r29:r28, 0
001f7d f469                      	brne sound_driver_instrument_routine_channel1_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
001f7e 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
001f7f 93a0 2874                 	sts pulse2_arpeggio_macro_offset, r26 //store the last valid index into the offset
001f81 cfc2                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload:
001f82 93b0 2874                 	sts pulse2_arpeggio_macro_offset, r27 //store the loop index into the offset
001f84 cfbf                      	rjmp sound_driver_instrument_routine_channel1_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_default:
001f85 91c0 2889                 	lds r28, pulse2_fx_0xy_sequence //load 0xy effect
001f87 91d0 288a                 	lds r29, pulse2_fx_0xy_sequence+1
001f89 9620                      	adiw r29:r28, 0 //check for 0xy effect
001f8a f099                      	breq sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel1_arpeggio_default_xy:
001f8b 95d6                      	lsr r29
001f8c 95c7                      	ror r28
001f8d 95d7                      	ror r29
001f8e 95c7                      	ror r28
001f8f 95d7                      	ror r29
001f90 95c7                      	ror r28
001f91 95d7                      	ror r29
001f92 95c7                      	ror r28
001f93 95d7                      	ror r29
001f94 95d2                      	swap r29
                                 
001f95 93c0 2889                 	sts pulse2_fx_0xy_sequence, r28 //store the rolled sequence
001f97 93d0 288a                 	sts pulse2_fx_0xy_sequence+1, r29
001f99 70cf                      	andi r28, 0x0F //mask out the 4 LSB
001f9a 91a0 280f                 	lds r26, pulse2_note //load the current note index
001f9c 0fac                      	add r26, r28 //add the note offset
001f9d c02c                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
001f9e 91a0 280f                 	lds r26, pulse2_note //load the current note index
001fa0 c029                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process:
001fa1 9220 2878                 	sts pulse2_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
001fa3 9220 287e                 	sts pulse2_total_hi_pitch_offset, zero
001fa5 91a0 2877                 	lds r26, pulse2_arpeggio_macro_mode
001fa7 30a1                      	cpi r26, 0x01 //absolute mode
001fa8 f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_absolute
001fa9 f069                      	breq sound_driver_instrument_routine_channel1_arpeggio_process_fixed
001faa c00e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute:
001fab 91a0 280f                 	lds r26, pulse2_note //load the current note index
001fad 0fab                      	add r26, r27 //offset the note with the arpeggio data
001fae fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
001faf c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_add:
001fb0 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
001fb1 f0c0                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
001fb2 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
001fb3 c016                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract:
001fb4 fda7                      	sbrc r26, 7 //check if result is negative
001fb5 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
001fb6 c013                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_fixed:
001fb7 2fab                      	mov r26, r27 //move the arpeggio data into r26
001fb8 c011                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative:
001fb9 91a0 280f                 	lds r26, pulse2_note //load the current note index
001fbb 0fab                      	add r26, r27 //offset the note with the arpeggio data
001fbc fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
001fbd c008                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_add:
001fbe 93a0 280f                 	sts pulse2_note, r26 //NOTE: relative mode modifies the original note index
001fc0 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
001fc1 f040                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
001fc2 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
001fc3 93a0 280f                 	sts pulse2_note, r26
001fc5 c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract:
001fc6 fda7                      	sbrc r26, 7 //check if result is negative
001fc7 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
001fc8 93a0 280f                 	sts pulse2_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_load:
001fca e3e8                      	ldi ZL, LOW(note_table << 1) //load in note table
001fcb e0f0                      	ldi ZH, HIGH(note_table << 1)
001fcc 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
001fcd 0fea                      	add ZL, r26 //add offset
001fce 1df2                      	adc ZH, zero
001fcf 91a5                      	lpm r26, Z+ //load bytes
001fd0 91b4                      	lpm r27, Z
001fd1 93a0 0a9c                 	sts TCB1_CCMPL, r26 //load the LOW bits for timer
001fd3 93b0 0a9d                 	sts TCB1_CCMPH, r27 //load the HIGH bits for timer
001fd5 93a0 2895                 	sts pulse2_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
001fd7 93b0 2896                 	sts pulse2_fx_3xx_target+1, r27
001fd9 c000                      	rjmp sound_driver_instrument_routine_channel1_pitch
                                 
                                 
                                 
                                 //NOTE: There is a limitation with the pitch routines in that the total pitch can not be offset by 127 in both,
                                 //the positive and negative direction, from the original note pitch. This shouldn't be too much of a problem as
                                 //most songs that use instruments with the pitch macro, do not stray that far from the original note pitch.
                                 //In the case of hi pitch, the total pitch can not be offset by 127*16 from the original pitch. This is also
                                 //not a big deal as you can easily reach the entire note range with an offset of up to 127*16.
                                 sound_driver_instrument_routine_channel1_pitch:
001fda 91e0 2879                 	lds ZL, pulse2_pitch_macro
001fdc 91f0 287a                 	lds ZH, pulse2_pitch_macro+1
001fde 9630                      	adiw Z, 0
001fdf f409                      	brne sound_driver_instrument_routine_channel1_pitch_continue
001fe0 c023                      	rjmp sound_driver_instrument_routine_channel1_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel1_pitch_continue:
001fe1 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
001fe2 1fff                      	rol ZH
001fe3 91a0 287b                 	lds r26, pulse2_pitch_macro_offset
001fe5 0fea                      	add ZL, r26
001fe6 1df2                      	adc ZH, zero
                                 
001fe7 91b0 287d                 	lds r27, pulse2_pitch_macro_release
001fe9 17ba                      	cp r27, r26
001fea f429                      	brne sound_driver_instrument_routine_channel1_pitch_increment //if the current offset is not equal to the release index, increment the offset
001feb 91a0 287c                 	lds r26, pulse2_pitch_macro_loop
001fed 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
001fee f010                      	brlo sound_driver_instrument_routine_channel1_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
001fef c003                      	rjmp sound_driver_instrument_routine_channel1_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_pitch_increment:
001ff0 95a3                      	inc r26 //increment the macro offset
001ff1 93a0 287b                 	sts pulse2_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_pitch_read:
001ff3 91b4                      	lpm r27, Z //load pitch data into r27
001ff4 38b0                      	cpi r27, 0x80 //check for macro end flag
001ff5 f489                      	brne sound_driver_instrument_routine_channel1_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_release:
001ff6 50a1                      	subi r26, 1 //keep the macro offset at the end flag
001ff7 93a0 287b                 	sts pulse2_pitch_macro_offset, r26
001ff9 91b0 287d                 	lds r27, pulse2_pitch_macro_release
001ffb 3fbf                      	cpi r27, 0xFF
001ffc f439                      	brne sound_driver_instrument_routine_channel1_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_loop:
001ffd 91b0 287c                 	lds r27, pulse2_pitch_macro_loop //load the loop index
001fff 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002000 f019                      	breq sound_driver_instrument_routine_channel1_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002001 93b0 287b                 	sts pulse2_pitch_macro_offset, r27 //store the loop index into the offset
002003 cfd6                      	rjmp sound_driver_instrument_routine_channel1_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_default:
002004 91b0 2878                 	lds r27, pulse2_total_pitch_offset
002006 c005                      	rjmp sound_driver_instrument_routine_channel1_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate:
002007 91a0 2878                 	lds r26, pulse2_total_pitch_offset //load the total pitch offset to change
002009 0fba                      	add r27, r26
00200a 93b0 2878                 	sts pulse2_total_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_multiply:
                                 	//NOTE: The Pxx effect is processed with the pitch instrument macro because the calculations are the same
00200c 91a0 28a5                 	lds r26, pulse2_fx_Pxx
00200e 0fba                      	add r27, r26
                                 
00200f 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002010 937f                      	push r23
002011 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
002012 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002013 0367                      	mulsu r22, r23
002014 917f                      	pop r23
002015 916f                      	pop r22
                                 
002016 9416                      	lsr r1 //shift out the fractional bits
002017 9407                      	ror r0
002018 9416                      	lsr r1
002019 9407                      	ror r0
00201a 9416                      	lsr r1
00201b 9407                      	ror r0
00201c 9416                      	lsr r1
00201d 9407                      	ror r0
00201e fe13                      	sbrs r1, 3 //check if result was a negative number
00201f c002                      	rjmp sound_driver_instrument_routine_channel1_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_negative:
002020 efb0                      	ldi r27, 0xF0
002021 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_offset:
002022 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
002024 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
002026 0da0                      	add r26, r0 //offset the timer values
002027 1db1                      	adc r27, r1
                                 	
002028 91c0 288d                 	lds r28, pulse2_fx_1xx_total
00202a 91d0 288e                 	lds r29, pulse2_fx_1xx_total+1
00202c 1bac                      	sub r26, r28
00202d 0bbd                      	sbc r27, r29
00202e 91c0 2891                 	lds r28, pulse2_fx_2xx_total
002030 91d0 2892                 	lds r29, pulse2_fx_2xx_total+1
002032 0fac                      	add r26, r28
002033 1fbd                      	adc r27, r29
002034 91c0 28aa                 	lds r28, pulse2_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
002036 91d0 28ab                 	lds r29, pulse2_fx_Qxy_total_offset+1
002038 1bac                      	sub r26, r28
002039 0bbd                      	sbc r27, r29
00203a 91c0 28b0                 	lds r28, pulse2_fx_Rxy_total_offset
00203c 91d0 28b1                 	lds r29, pulse2_fx_Rxy_total_offset+1
00203e 0fac                      	add r26, r28
00203f 1fbd                      	adc r27, r29
                                 
002040 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
002042 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel1_hi_pitch:
002044 91e0 287f                 	lds ZL, pulse2_hi_pitch_macro
002046 91f0 2880                 	lds ZH, pulse2_hi_pitch_macro+1
002048 9630                      	adiw Z, 0
002049 f409                      	brne sound_driver_instrument_routine_channel1_hi_pitch_continue
00204a c03c                      	rjmp sound_driver_instrument_routine_channel1_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel1_hi_pitch_continue:
00204b 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00204c 1fff                      	rol ZH
00204d 91a0 2881                 	lds r26, pulse2_hi_pitch_macro_offset
00204f 0fea                      	add ZL, r26
002050 1df2                      	adc ZH, zero
                                 
002051 91b0 2883                 	lds r27, pulse2_hi_pitch_macro_release
002053 17ba                      	cp r27, r26
002054 f429                      	brne sound_driver_instrument_routine_channel1_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002055 91a0 2882                 	lds r26, pulse2_hi_pitch_macro_loop
002057 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002058 f010                      	brlo sound_driver_instrument_routine_channel1_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002059 c003                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_increment:
00205a 95a3                      	inc r26 //increment the macro offset
00205b 93a0 2881                 	sts pulse2_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_hi_pitch_read:
00205d 91b4                      	lpm r27, Z //load hi pitch data into r27
00205e 38b0                      	cpi r27, 0x80 //check for macro end flag
00205f f489                      	brne sound_driver_instrument_routine_channel1_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_release:
002060 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002061 93a0 2881                 	sts pulse2_hi_pitch_macro_offset, r26
002063 91b0 2883                 	lds r27, pulse2_hi_pitch_macro_release
002065 3fbf                      	cpi r27, 0xFF
002066 f439                      	brne sound_driver_instrument_routine_channel1_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_loop:
002067 91b0 2882                 	lds r27, pulse2_hi_pitch_macro_loop //load the loop index
002069 3fbf                      	cpi r27, 0xFF //check if there is a loop index
00206a f019                      	breq sound_driver_instrument_routine_channel1_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
00206b 93b0 2881                 	sts pulse2_hi_pitch_macro_offset, r27 //store the loop index into the offset
00206d cfd6                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_default:
00206e 91b0 287e                 	lds r27, pulse2_total_hi_pitch_offset
002070 c005                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate:
002071 91a0 287e                 	lds r26, pulse2_total_hi_pitch_offset //load the total hi pitch offset to change
002073 0fba                      	add r27, r26
002074 93b0 287e                 	sts pulse2_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply:
002076 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002077 937f                      	push r23
002078 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002079 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00207a 0367                      	mulsu r22, r23
00207b 917f                      	pop r23
00207c 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_offset:
00207d 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
00207f 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
002081 0da0                      	add r26, r0 //offset the timer values
002082 1db1                      	adc r27, r1
002083 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
002085 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel1_duty:
002087 91e0 2884                 	lds ZL, pulse2_duty_macro
002089 91f0 2885                 	lds ZH, pulse2_duty_macro+1
00208b 9630                      	adiw Z, 0
00208c f1b1                      	breq sound_driver_channel1_fx_routines //if no duty macro is in use, go to the next routine
00208d 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00208e 1fff                      	rol ZH
00208f 91a0 2886                 	lds r26, pulse2_duty_macro_offset
002091 0fea                      	add ZL, r26
002092 1df2                      	adc ZH, zero
                                 
002093 91b0 2888                 	lds r27, pulse2_duty_macro_release
002095 17ba                      	cp r27, r26
002096 f429                      	brne sound_driver_instrument_routine_channel1_duty_increment //if the current offset is not equal to the release index, increment the offset
002097 91a0 2887                 	lds r26, pulse2_duty_macro_loop
002099 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00209a f010                      	brlo sound_driver_instrument_routine_channel1_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00209b c027                      	rjmp sound_driver_channel1_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel1_duty_increment:
00209c 95a3                      	inc r26 //increment the macro offset
00209d 93a0 2886                 	sts pulse2_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_duty_read:
00209f 91b4                      	lpm r27, Z //load pitch data into r27
0020a0 3fbf                      	cpi r27, 0xFF //check for macro end flag
0020a1 f471                      	brne sound_driver_instrument_routine_channel1_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_release:
0020a2 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0020a3 93a0 2886                 	sts pulse2_duty_macro_offset, r26
0020a5 91b0 2888                 	lds r27, pulse2_duty_macro_release
0020a7 3fbf                      	cpi r27, 0xFF
0020a8 f4d1                      	brne sound_driver_channel1_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_loop:
0020a9 91b0 2887                 	lds r27, pulse2_duty_macro_loop //load the loop index
0020ab 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0020ac f0b1                      	breq sound_driver_channel1_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
0020ad 93b0 2886                 	sts pulse2_duty_macro_offset, r27 //store the loop index into the offset
0020af cfd7                      	rjmp sound_driver_instrument_routine_channel1_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_load:
0020b0 ebe8                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
0020b1 e4f4                      	ldi ZH, HIGH(sequences << 1)
0020b2 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
0020b3 1df2                      	adc ZH, zero
                                 
0020b4 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
0020b5 95b7                      	ror r27
0020b6 95b7                      	ror r27
0020b7 91a0 2808                 	lds r26, pulse2_param //load r26 with pulse2_param (register $4000)
0020b9 2fca                      	mov r28, r26 //store a copy of pulse2_param into r28
0020ba 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
0020bb 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
0020bc c001                      	rjmp sound_driver_instrument_routine_channel1_duty_load_store
0020bd c005                      	rjmp sound_driver_channel1_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel1_duty_load_store:
0020be 90d4                      	lpm pulse2_sequence, Z //store the sequence
                                 
0020bf 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
0020c0 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
0020c1 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_routines:
                                 sound_driver_channel1_fx_1xx_routine:
0020c3 91e0 288b                 	lds ZL, pulse2_fx_1xx
0020c5 91f0 288c                 	lds ZH, pulse2_fx_1xx+1
0020c7 9630                      	adiw Z, 0
0020c8 f051                      	breq sound_driver_channel1_fx_2xx_routine
                                 
0020c9 91a0 288d                 	lds r26, pulse2_fx_1xx_total //load the rate to change the pitch by
0020cb 91b0 288e                 	lds r27, pulse2_fx_1xx_total+1
0020cd 0fae                      	add r26, ZL //increase the total offset by the rate
0020ce 1fbf                      	adc r27, ZH
0020cf 93a0 288d                 	sts pulse2_fx_1xx_total, r26
0020d1 93b0 288e                 	sts pulse2_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_2xx_routine:
0020d3 91e0 288f                 	lds ZL, pulse2_fx_2xx
0020d5 91f0 2890                 	lds ZH, pulse2_fx_2xx+1
0020d7 9630                      	adiw Z, 0
0020d8 f051                      	breq sound_driver_channel1_fx_3xx_routine
                                 
0020d9 91a0 2891                 	lds r26, pulse2_fx_2xx_total //load the rate to change the pitch by
0020db 91b0 2892                 	lds r27, pulse2_fx_2xx_total+1
0020dd 0fae                      	add r26, ZL //increase the total offset by the rate
0020de 1fbf                      	adc r27, ZH
0020df 93a0 2891                 	sts pulse2_fx_2xx_total, r26
0020e1 93b0 2892                 	sts pulse2_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_3xx_routine:
0020e3 91e0 2897                 	lds ZL, pulse2_fx_3xx_speed
0020e5 91f0 2898                 	lds ZH, pulse2_fx_3xx_speed+1
0020e7 9630                      	adiw Z, 0
0020e8 f409                      	brne sound_driver_channel1_fx_3xx_routine_check_start
0020e9 c048                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_check_start:
0020ea 91a0 2893                 	lds r26, pulse2_fx_3xx_start
0020ec 91b0 2894                 	lds r27, pulse2_fx_3xx_start+1
0020ee 9610                      	adiw r26:r27, 0
0020ef f409                      	brne sound_driver_channel1_fx_3xx_routine_main
0020f0 c041                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_main:
0020f1 91c0 2895                 	lds r28, pulse2_fx_3xx_target
0020f3 91d0 2896                 	lds r29, pulse2_fx_3xx_target+1
                                 
0020f5 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
0020f6 07bd                      	cpc r27, r29
0020f7 f011                      	breq sound_driver_channel1_fx_3xx_routine_disable
0020f8 f030                      	brlo sound_driver_channel1_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
0020f9 c01f                      	rjmp sound_driver_channel1_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel1_fx_3xx_routine_disable:
0020fa 9220 2893                 	sts pulse2_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
0020fc 9220 2894                 	sts pulse2_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
0020fe c033                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_subtract:
0020ff 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002100 0bdb                      	sbc r29, r27
002101 91a0 2899                 	lds r26, pulse2_fx_3xx_total_offset
002103 91b0 289a                 	lds r27, pulse2_fx_3xx_total_offset+1
                                 
002105 0fae                      	add r26, ZL //add the speed to the total offset
002106 1fbf                      	adc r27, ZH
002107 1bca                      	sub r28, r26 //invert the total difference with the total offset
002108 0bdb                      	sbc r29, r27
002109 f380                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
00210a 93a0 2899                 	sts pulse2_fx_3xx_total_offset, r26 //store the new total offset
00210c 93b0 289a                 	sts pulse2_fx_3xx_total_offset+1, r27
                                 
00210e 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the current timer period
002110 91b0 0a9d                 	lds r27, TCB1_CCMPH
002112 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002113 0bbd                      	sbc r27, r29
002114 93a0 0a9c                 	sts TCB1_CCMPL, r26
002116 93b0 0a9d                 	sts TCB1_CCMPH, r27
002118 c019                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_add:
002119 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
00211a 0bbd                      	sbc r27, r29
00211b 91c0 2899                 	lds r28, pulse2_fx_3xx_total_offset
00211d 91d0 289a                 	lds r29, pulse2_fx_3xx_total_offset+1
                                 
00211f 0fce                      	add r28, ZL //add the speed to the total offset
002120 1fdf                      	adc r29, ZH
002121 1bac                      	sub r26, r28 //invert the total difference with the total offset
002122 0bbd                      	sbc r27, r29
002123 f2b0                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002124 93c0 2899                 	sts pulse2_fx_3xx_total_offset, r28 //store the new total offset
002126 93d0 289a                 	sts pulse2_fx_3xx_total_offset+1, r29
                                 
002128 91c0 0a9c                 	lds r28, TCB1_CCMPL //load the current timer period
00212a 91d0 0a9d                 	lds r29, TCB1_CCMPH
00212c 0fca                      	add r28, r26 //offset the current timer period with the total offset
00212d 1fdb                      	adc r29, r27
00212e 93c0 0a9c                 	sts TCB1_CCMPL, r28
002130 93d0 0a9d                 	sts TCB1_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel1_fx_4xy_routine:
002132 91a0 289b                 	lds r26, pulse2_fx_4xy_speed
002134 15a2                      	cp r26, zero
002135 f409                      	brne sound_driver_channel1_fx_4xy_routine_continue
002136 c05c                      	rjmp sound_driver_channel1_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel1_fx_4xy_routine_continue:
002137 91b0 289c                 	lds r27, pulse2_fx_4xy_depth
002139 91c0 289d                 	lds r28, pulse2_fx_4xy_phase
00213b 0fca                      	add r28, r26 //increase the phase by the speed
00213c 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
00213d f008                      	brlo sound_driver_channel1_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
00213e 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase:
00213f 93c0 289d                 	sts pulse2_fx_4xy_phase, r28 //store the new phase
002141 31c0                      	cpi r28, 16
002142 f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_0
002143 32c0                      	cpi r28, 32
002144 f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_1
002145 33c0                      	cpi r28, 48
002146 f030                      	brlo sound_driver_channel1_fx_4xy_routine_phase_2
002147 c007                      	rjmp sound_driver_channel1_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_0:
002148 70cf                      	andi r28, 0x0F //mask for values 0-15
002149 c029                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_1:
00214a 6fc0                      	ori r28, 0xF0
00214b 95c0                      	com r28 //invert values 0-15
00214c c026                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_2:
00214d 70cf                      	andi r28, 0x0F //mask for values 0-15
00214e c003                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_3:
00214f 6fc0                      	ori r28, 0xF0
002150 95c0                      	com r28 //invert values 0-15
002151 c000                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_add:
002152 95b2                      	swap r27 //multiply depth by 16
002153 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002154 eee6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002155 e0f0                      	ldi ZH, HIGH(vibrato_table << 1)
002156 0fec                      	add ZL, r28 //offset the table by the depth+phase
002157 1df2                      	adc ZH, zero
002158 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002159 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00215a 937f                      	push r23
00215b 2f6c                      	mov r22, r28 //store the vibrato value into r22
00215c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00215d 9f67                      	mul r22, r23
00215e 917f                      	pop r23
00215f 916f                      	pop r22
                                 
002160 9416                      	lsr r1 //shift out the fractional bits
002161 9407                      	ror r0
002162 9416                      	lsr r1
002163 9407                      	ror r0
002164 9416                      	lsr r1
002165 9407                      	ror r0
002166 9416                      	lsr r1
002167 9407                      	ror r0
                                 	
002168 91a0 0a9c                 	lds r26, TCB1_CCMPL
00216a 91b0 0a9d                 	lds r27, TCB1_CCMPH
00216c 0da0                      	add r26, r0
00216d 1db1                      	adc r27, r1
00216e 93a0 0a9c                 	sts TCB1_CCMPL, r26
002170 93b0 0a9d                 	sts TCB1_CCMPH, r27
002172 c020                      	rjmp sound_driver_channel1_fx_7xy_routine
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_subtract:
002173 95b2                      	swap r27 //multiply depth by 16
002174 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002175 eee6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002176 e0f0                      	ldi ZH, HIGH(vibrato_table << 1)
002177 0fec                      	add ZL, r28 //offset the table by the depth+phase
002178 1df2                      	adc ZH, zero
002179 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
00217a 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00217b 937f                      	push r23
00217c 2f6c                      	mov r22, r28 //store the vibrato value into r22
00217d eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00217e 9f67                      	mul r22, r23
00217f 917f                      	pop r23
002180 916f                      	pop r22
                                 
002181 9416                      	lsr r1 //shift out the fractional bits
002182 9407                      	ror r0
002183 9416                      	lsr r1
002184 9407                      	ror r0
002185 9416                      	lsr r1
002186 9407                      	ror r0
002187 9416                      	lsr r1
002188 9407                      	ror r0
                                 
002189 91a0 0a9c                 	lds r26, TCB1_CCMPL
00218b 91b0 0a9d                 	lds r27, TCB1_CCMPH
00218d 19a0                      	sub r26, r0
00218e 09b1                      	sbc r27, r1
00218f 93a0 0a9c                 	sts TCB1_CCMPL, r26
002191 93b0 0a9d                 	sts TCB1_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_7xy_routine:
002193 91a0 289e                 	lds r26, pulse2_fx_7xy_speed
002195 15a2                      	cp r26, zero
002196 f0f1                      	breq sound_driver_channel1_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
002197 91b0 289f                 	lds r27, pulse2_fx_7xy_depth
002199 91c0 28a0                 	lds r28, pulse2_fx_7xy_phase
00219b 0fca                      	add r28, r26 //increase the phase by the speed
00219c 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
00219d f010                      	brlo sound_driver_channel1_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
00219e e0c0                      	ldi r28, 0x00
00219f 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase:
0021a0 93c0 28a0                 	sts pulse2_fx_7xy_phase, r28 //store the new phase
0021a2 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
0021a3 ffc4                      	sbrs r28, 4
0021a4 c001                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_0
0021a5 c002                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel1_fx_7xy_routine_phase_0:
0021a6 70cf                      	andi r28, 0x0F //mask for values 0-15
0021a7 c003                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase_1:
0021a8 6fc0                      	ori r28, 0xF0
0021a9 95c0                      	com r28 //invert values 0-15
0021aa c000                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_load:
0021ab 95b2                      	swap r27 //multiply depth by 16
0021ac 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0021ad eee6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0021ae e0f0                      	ldi ZH, HIGH(vibrato_table << 1)
0021af 0fec                      	add ZL, r28 //offset the table by the depth+phase
0021b0 1df2                      	adc ZH, zero
0021b1 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
0021b2 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
0021b3 93c0 28a1                 	sts pulse2_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Axy_routine:
0021b5 91b0 28a2                 	lds r27, pulse2_fx_Axy
0021b7 15b2                      	cp r27, zero
0021b8 f0e9                      	breq sound_driver_channel1_fx_Qxy_routine //0 means that the effect is not in use
                                 	
0021b9 91a0 280d                 	lds r26, pulse2_fractional_volume //load fractional volume representation of the channel
0021bb 91c0 2808                 	lds r28, pulse2_param //load the integer volume representation of the channel
0021bd 2fda                      	mov r29, r26 //copy fractional volume into r29
0021be 2fec                      	mov r30, r28 //copy the pulse2_param into r30
0021bf 95e2                      	swap r30
0021c0 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
0021c1 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
0021c2 17ed                      	cp r30, r29 //compare the fractional and integer volumes
0021c3 f009                      	breq sound_driver_channel1_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel1_fx_Axy_routine_reload:
0021c4 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate:
0021c5 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
0021c6 c004                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_addition:
0021c7 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0021c8 f428                      	brcc sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0021c9 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
0021ca c003                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_subtraction:
0021cb 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0021cc f008                      	brcs sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0021cd e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_store:
0021ce 93a0 280d                 	sts pulse2_fractional_volume, r26 //store the new fractional volume
0021d0 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
0021d1 95a2                      	swap r26
0021d2 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
0021d3 2bca                      	or r28, r26 //store the new volume back into pulse2_param
0021d4 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel1_fx_Qxy_routine:
0021d6 91e0 28a6                 	lds ZL, pulse2_fx_Qxy_target
0021d8 91f0 28a7                 	lds ZH, pulse2_fx_Qxy_target+1
0021da 9630                      	adiw Z, 0
0021db f199                      	breq sound_driver_channel1_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
0021dc 91a0 28aa                 	lds r26, pulse2_fx_Qxy_total_offset
0021de 91b0 28ab                 	lds r27, pulse2_fx_Qxy_total_offset+1
0021e0 91c0 0a9c                 	lds r28, TCB1_CCMPL
0021e2 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
0021e4 1bec                      	sub ZL, r28 //calculate the difference to the target
0021e5 0bfd                      	sbc ZH, r29
0021e6 f408                      	brsh sound_driver_channel1_fx_Qxy_routine_end //if the target has been reached (or passed)
0021e7 f0e8                      	brlo sound_driver_channel1_fx_Qxy_routine_add
                                 
                                 sound_driver_channel1_fx_Qxy_routine_end:
0021e8 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
0021e9 0bbf                      	sbc r27, ZH
                                 
0021ea 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0021eb 937f                      	push r23
0021ec 9160 28a5                 	lds r22, pulse2_fx_Pxx
0021ee eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0021ef 9f67                      	mul r22, r23
0021f0 917f                      	pop r23
0021f1 916f                      	pop r22
0021f2 9416                      	lsr r1 //shift out the fractional bits
0021f3 9407                      	ror r0
0021f4 9416                      	lsr r1
0021f5 9407                      	ror r0
0021f6 9416                      	lsr r1
0021f7 9407                      	ror r0
0021f8 9416                      	lsr r1
0021f9 9407                      	ror r0
                                 
0021fa 0da0                      	add r26, r0
0021fb 1db2                      	adc r27, zero
                                 
0021fc 93a0 28aa                 	sts pulse2_fx_Qxy_total_offset, r26 //store the total offset
0021fe 93b0 28ab                 	sts pulse2_fx_Qxy_total_offset+1, r27
002200 9220 28a6                 	sts pulse2_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
002202 9220 28a7                 	sts pulse2_fx_Qxy_target+1, zero
002204 c00a                      	rjmp sound_driver_channel1_fx_Rxy_routine
                                 
                                 sound_driver_channel1_fx_Qxy_routine_add:
002205 91c0 28a8                 	lds r28, pulse2_fx_Qxy_speed
002207 91d0 28a9                 	lds r29, pulse2_fx_Qxy_speed+1
002209 0fac                      	add r26, r28 //increase the total offset by the speed
00220a 1fbd                      	adc r27, r29
00220b 93a0 28aa                 	sts pulse2_fx_Qxy_total_offset, r26 //store the total offset
00220d 93b0 28ab                 	sts pulse2_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Rxy_routine:
00220f 91e0 28ac                 	lds ZL, pulse2_fx_Rxy_target
002211 91f0 28ad                 	lds ZH, pulse2_fx_Rxy_target+1
002213 9630                      	adiw Z, 0
002214 f199                      	breq sound_driver_instrument_routine_channel2_volume //if the effect is not enabled, skip the routine
                                 
002215 91a0 28b0                 	lds r26, pulse2_fx_Rxy_total_offset
002217 91b0 28b1                 	lds r27, pulse2_fx_Rxy_total_offset+1
002219 91c0 0a9c                 	lds r28, TCB1_CCMPL
00221b 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
00221d 1bce                      	sub r28, ZL //calculate the difference to the target
00221e 0bdf                      	sbc r29, ZH
00221f f408                      	brsh sound_driver_channel1_fx_Rxy_routine_end //if the target has been reached (or passed)
002220 f0e8                      	brlo sound_driver_channel1_fx_Rxy_routine_add
                                 
                                 sound_driver_channel1_fx_Rxy_routine_end:
002221 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
002222 0bbd                      	sbc r27, r29
                                 
002223 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002224 937f                      	push r23
002225 9160 28a5                 	lds r22, pulse2_fx_Pxx
002227 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002228 9f67                      	mul r22, r23
002229 917f                      	pop r23
00222a 916f                      	pop r22
00222b 9416                      	lsr r1 //shift out the fractional bits
00222c 9407                      	ror r0
00222d 9416                      	lsr r1
00222e 9407                      	ror r0
00222f 9416                      	lsr r1
002230 9407                      	ror r0
002231 9416                      	lsr r1
002232 9407                      	ror r0
                                 
002233 0da0                      	add r26, r0
002234 1db2                      	adc r27, zero
                                 
002235 93a0 28b0                 	sts pulse2_fx_Rxy_total_offset, r26 //store the total offset
002237 93b0 28b1                 	sts pulse2_fx_Rxy_total_offset+1, r27
002239 9220 28ac                 	sts pulse2_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
00223b 9220 28ad                 	sts pulse2_fx_Rxy_target+1, zero
00223d c00a                      	rjmp sound_driver_instrument_routine_channel2_volume
                                 
                                 sound_driver_channel1_fx_Rxy_routine_add:
00223e 91c0 28ae                 	lds r28, pulse2_fx_Rxy_speed
002240 91d0 28af                 	lds r29, pulse2_fx_Rxy_speed+1
002242 0fac                      	add r26, r28 //increase the total offset by the speed
002243 1fbd                      	adc r27, r29
002244 93a0 28b0                 	sts pulse2_fx_Rxy_total_offset, r26 //store the total offset
002246 93b0 28b1                 	sts pulse2_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume:
                                 
                                 sound_driver_exit:
002248 91df                      	pop r29
002249 91cf                      	pop r28
00224a 940c 13ee                 	jmp sequence_1_3 + 3 //+3 is to skip the stack instructions since we already pushed them
                                 
                                 
                                 
                                 //TABLES
00224c 7f05
00224d 010a
00224e 0214
00224f 0328
002250 0450
002251 051e
002252 0607
002253 070d
002254 0806
002255 090c
002256 0a18
002257 0b30
002258 0c60
002259 0d24
00225a 0e08
00225b 0f10                      length: .db $05, $7F, $0A, $01, $14, $02, $28, $03, $50, $04, $1E, $05, $07, $06, $0D, $07, $06, $08, $0C, $09, $18, $0A, $30, $0B, $60, $0C, $24, $0D, $08, $0E, $10, $0F
                                 
                                 //pulse sequences: 12.5%, 25%, 50%, 75%
00225c 0301
00225d fc0f                      sequences: .db 0b00000001, 0b00000011, 0b00001111, 0b11111100
                                 
                                 //list of famitracker fx: http://famitracker.com/wiki/index.php?title=Effect_list
                                 channel0_fx:
00225e 1577
00225f 157c
002260 1598
002261 15b4
002262 15d7                      	.dw sound_driver_channel0_fx_0xy, sound_driver_channel0_fx_1xx, sound_driver_channel0_fx_2xx, sound_driver_channel0_fx_3xx, sound_driver_channel0_fx_4xy
002263 15e2
002264 15ef
002265 15f2
002266 15f5
002267 15f8                      	.dw sound_driver_channel0_fx_7xy, sound_driver_channel0_fx_Axy, sound_driver_channel0_fx_Bxx, sound_driver_channel0_fx_Cxx, sound_driver_channel0_fx_Dxx
002268 15fb
002269 1603
00226a 1606
00226b 1613
00226c 161a                      	.dw sound_driver_channel0_fx_Exx, sound_driver_channel0_fx_Fxx, sound_driver_channel0_fx_Gxx, sound_driver_channel0_fx_Hxy, sound_driver_channel0_fx_Ixy
00226d 1622
00226e 1623
00226f 1624
002270 1627
002271 166b                      	.dw sound_driver_channel0_fx_Hxx, sound_driver_channel0_fx_Ixx, sound_driver_channel0_fx_Pxx, sound_driver_channel0_fx_Qxy, sound_driver_channel0_fx_Rxy
002272 16ae
002273 16bb
002274 16cf
002275 16d0
002276 16d1                      	.dw sound_driver_channel0_fx_Sxx, sound_driver_channel0_fx_Vxx, sound_driver_channel0_fx_Wxx, sound_driver_channel0_fx_Xxx, sound_driver_channel0_fx_Yxx
002277 16d2                      	.dw sound_driver_channel0_fx_Zxx
                                 
                                 channel1_fx:
002278 1850
002279 1855
00227a 1871
00227b 188d
00227c 18b0                      	.dw sound_driver_channel1_fx_0xy, sound_driver_channel1_fx_1xx, sound_driver_channel1_fx_2xx, sound_driver_channel1_fx_3xx, sound_driver_channel1_fx_4xy
00227d 18bb
00227e 18c8
00227f 18cb
002280 18ce
002281 18d1                      	.dw sound_driver_channel1_fx_7xy, sound_driver_channel1_fx_Axy, sound_driver_channel1_fx_Bxx, sound_driver_channel1_fx_Cxx, sound_driver_channel1_fx_Dxx
002282 18d4
002283 18dc
002284 18df
002285 18ec
002286 18f3                      	.dw sound_driver_channel1_fx_Exx, sound_driver_channel1_fx_Fxx, sound_driver_channel1_fx_Gxx, sound_driver_channel1_fx_Hxy, sound_driver_channel1_fx_Ixy
002287 18fb
002288 18fc
002289 18fd
00228a 1900
00228b 1944                      	.dw sound_driver_channel1_fx_Hxx, sound_driver_channel1_fx_Ixx, sound_driver_channel1_fx_Pxx, sound_driver_channel1_fx_Qxy, sound_driver_channel1_fx_Rxy
00228c 1987
00228d 1994
00228e 19a8
00228f 19a9
002290 19aa                      	.dw sound_driver_channel1_fx_Sxx, sound_driver_channel1_fx_Vxx, sound_driver_channel1_fx_Wxx, sound_driver_channel1_fx_Xxx, sound_driver_channel1_fx_Yxx
002291 19ab                      	.dw sound_driver_channel1_fx_Zxx
                                 
                                 //famitracker volumes table: http://famitracker.com/wiki/index.php?title=Volume
                                 volumes:
002292 0000
002293 0000
002294 0000
002295 0000
002296 0000
002297 0000
002298 0000
002299 0000                      	.db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
00229a 0100
00229b 0101
00229c 0101
00229d 0101
00229e 0101
00229f 0101
0022a0 0101
0022a1 0101                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
0022a2 0100
0022a3 0101
0022a4 0101
0022a5 0101
0022a6 0101
0022a7 0101
0022a8 0101
0022a9 0201                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02
0022aa 0100
0022ab 0101
0022ac 0101
0022ad 0101
0022ae 0101
0022af 0202
0022b0 0202
0022b1 0302                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03
0022b2 0100
0022b3 0101
0022b4 0101
0022b5 0101
0022b6 0202
0022b7 0202
0022b8 0303
0022b9 0403                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04
0022ba 0100
0022bb 0101
0022bc 0101
0022bd 0202
0022be 0302
0022bf 0303
0022c0 0404
0022c1 0504                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05
0022c2 0100
0022c3 0101
0022c4 0201
0022c5 0202
0022c6 0303
0022c7 0404
0022c8 0504
0022c9 0605                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x06
0022ca 0100
0022cb 0101
0022cc 0201
0022cd 0302
0022ce 0403
0022cf 0504
0022d0 0605
0022d1 0706                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07
0022d2 0100
0022d3 0101
0022d4 0202
0022d5 0303
0022d6 0404
0022d7 0505
0022d8 0606
0022d9 0807                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07, 0x08
0022da 0100
0022db 0101
0022dc 0302
0022dd 0403
0022de 0504
0022df 0606
0022e0 0707
0022e1 0908                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09
0022e2 0100
0022e3 0201
0022e4 0302
0022e5 0404
0022e6 0605
0022e7 0706
0022e8 0808
0022e9 0a09                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A
0022ea 0100
0022eb 0201
0022ec 0302
0022ed 0504
0022ee 0605
0022ef 0807
0022f0 0908
0022f1 0b0a                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B
0022f2 0100
0022f3 0201
0022f4 0403
0022f5 0504
0022f6 0706
0022f7 0808
0022f8 0a09
0022f9 0c0b                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B, 0x0C
0022fa 0100
0022fb 0201
0022fc 0403
0022fd 0605
0022fe 0706
0022ff 0908
002300 0b0a
002301 0d0c                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D
002302 0100
002303 0201
002304 0403
002305 0605
002306 0807
002307 0a09
002308 0c0b
002309 0e0d                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E
00230a 0100
00230b 0302
00230c 0504
00230d 0706
00230e 0908
00230f 0b0a
002310 0d0c


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega4809" register use summary:
x  :   0 y  :   0 z  : 130 r0 : 102 r1 : 102 r2 : 360 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   6 r11:   4 r12:  13 
r13:   5 r14:   3 r15:  13 r16:   7 r17:   6 r18:   7 r19:   6 r20:   0 
r21:   0 r22:  88 r23:  88 r24:   0 r25:  28 r26: 526 r27: 631 r28: 390 
r29: 201 r30: 192 r31: 172 
Registers used: 23 out of 35 (65.7%)

"ATmega4809" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  78 add   : 104 adiw  :  55 and   :   0 
andi  :  62 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   4 brcs  :   8 break :   0 breq  :  88 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  41 brlt  :   0 brmi  :   0 
brne  :  67 brpl  :   0 brsh  :  16 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :   0 cbr   :   4 
clc   :   0 clh   :   0 cli   :   6 cln   :   0 clr   :   3 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :  10 cp    :  52 cpc   :   5 
cpi   :  89 cpse  :  14 dec   :  23 des   :   0 eor   :   0 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   2 in    :   5 inc   :  25 
jmp   :   8 ld    :   0 ldd   :   0 ldi   : 165 lds   : 383 lpm   : 140 
lsl   :  40 lsr   :  94 mov   :  77 movw  :   0 mul   :  18 muls  :   0 
mulsu :   4 neg   :   0 nop   :   0 or    :  13 ori   :  10 out   :   8 
pop   :  65 push  :  61 rcall :  28 ret   :  24 reti  :   5 rjmp  : 274 
rol   :  26 ror   : 106 sbc   :  24 sbci  :   0 sbi   :   0 sbic  :   0 
sbis  :   0 sbiw  :   0 sbr   :  14 sbrc  :  16 sbrs  :  11 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   : 710 sub   :  34 subi  :  27 swap  :  33 tst   :   0 wdr   :   0 

Instructions used: 51 out of 114 (44.7%)

"ATmega4809" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x004624   8458   9470  17928   49152  36.5%
[.dseg] 0x002800 0x0028b7      0    183    183    6144   3.0%
[.eseg] 0x000000 0x000000      0      0      0     256   0.0%

Assembly complete, 0 errors, 105 warnings
