
AVRASM ver. 2.2.8  C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm Wed Jan 13 20:07:54 2021

C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
                                 
                                 
                                 ; NES_APU_2a03.asm
                                 ;
                                 ; Created: 11/29/2020 1:44:10 AM
                                 ; Author : Tennyson Cheng
                                 ;
                                 
                                 .list
                                 
                                 .dseg
002800                           pulse1_param: .byte 1 //$4000 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002801                           pulse1_sweep_param: .byte 1 //$4001 EPPP.NSSS = Enable, Period, Negate, Shift
                                 //NOTE: In order to account for multiplier, we use 16 instead of 11 bits for the timer
002802                           pulse1_timerL: .byte 1 //$4002 LLLL.LLLL = Low 8 bits for timer
002803                           pulse1_timerH: .byte 1 //$4002 HHHH.HHHH = High 8 bits for timer
002804                           pulse1_length: .byte 1 //$4002 000l.llll = Length counter load
002805                           pulse1_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002806                           pulse1_output_volume: .byte 1 //this is the final output volume of pulse 1
002807                           pulse1_note: .byte 1 //the current note index in the note table
                                 
002808                           song_frames: .byte 2
00280a                           song_frame_offset: .byte 2
00280c                           song_speed: .byte 1
00280d                           song_fx_Bxx: .byte 1
00280e                           song_fx_Cxx: .byte 1
00280f                           song_fx_Dxx: .byte 1
                                 
                                 
002810                           pulse1_pattern: .byte 2
002812                           pulse1_pattern_delay: .byte 2
002814                           pulse1_pattern_offset: .byte 2
                                 
002816                           pulse1_volume_macro: .byte 2
002818                           pulse1_volume_macro_offset: .byte 1
002819                           pulse1_volume_macro_loop: .byte 1
00281a                           pulse1_volume_macro_release: .byte 1
                                 
00281b                           pulse1_arpeggio_macro: .byte 2
00281d                           pulse1_arpeggio_macro_offset: .byte 1
00281e                           pulse1_arpeggio_macro_loop: .byte 1
00281f                           pulse1_arpeggio_macro_release: .byte 1
002820                           pulse1_arpeggio_macro_mode: .byte 1
                                 
002821                           pulse1_total_pitch_offset: .byte 1 //used to reference the overall change in pitch for the pitch macro
002822                           pulse1_pitch_macro: .byte 2
002824                           pulse1_pitch_macro_offset: .byte 1
002825                           pulse1_pitch_macro_loop: .byte 1
002826                           pulse1_pitch_macro_release: .byte 1
                                 
002827                           pulse1_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
002828                           pulse1_hi_pitch_macro: .byte 2
00282a                           pulse1_hi_pitch_macro_offset: .byte 1
00282b                           pulse1_hi_pitch_macro_loop: .byte 1
00282c                           pulse1_hi_pitch_macro_release: .byte 1
                                 
00282d                           pulse1_duty_macro: .byte 2
00282f                           pulse1_duty_macro_offset: .byte 1
002830                           pulse1_duty_macro_loop: .byte 1
002831                           pulse1_duty_macro_release: .byte 1
                                 
002832                           pulse1_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002834                           pulse1_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002836                           pulse1_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
002838                           pulse1_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
00283a                           pulse1_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
00283c                           pulse1_fx_3xx_start: .byte 2 //the starting note period
00283e                           pulse1_fx_3xx_target: .byte 2 //target note period
002840                           pulse1_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
002842                           pulse1_fx_3xx_total_offset: .byte 2
002844                           pulse1_fx_4xy_speed: .byte 1
002845                           pulse1_fx_4xy_depth: .byte 1
002846                           pulse1_fx_4xy_phase: .byte 1
002847                           pulse1_fx_7xy_speed: .byte 1
002848                           pulse1_fx_7xy_depth: .byte 1
002849                           pulse1_fx_7xy_phase: .byte 1
00284a                           pulse1_fx_7xy_value: .byte 1 //value to offset the volume
00284b                           pulse1_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
00284c                           pulse1_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
00284d                           pulse1_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
00284e                           pulse1_fx_Pxx: .byte 1 //refers to the fine pitch offset set by the Pxx effect
00284f                           pulse1_fx_Qxy_target: .byte 2 //target note period
002851                           pulse1_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002853                           pulse1_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002855                           pulse1_fx_Rxy_target: .byte 2 //target note period
002857                           pulse1_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
002859                           pulse1_fx_Rxy_total_offset: .byte 2
00285b                           pulse1_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
00285c                           pulse1_fx_Sxx_post: .byte 1
                                 
00285d                           pulse2_pattern_delay: .byte 1
00285e                           triangle_pattern_delay: .byte 1
00285f                           noise_pattern_delay: .byte 1
002860                           dcpm_pattern_delay: .byte 1
                                 
                                 .cseg
                                 
                                 //NOTE: zero is defined in order to use the cp instruction without the need to load 0x00 into a register beforehand
                                 .def zero = r2
                                 .def channel_flags = r25 //[pulse1.pulse2] RSlc.0000 = Reload, Start, Length halt/Loop, Constant volume
                                 .def pulse1_sequence = r13
                                 .def pulse1_length_counter = r14
                                 .def pulse1_sweep = r15 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse1_volume_divider = r16 //0000.PPPP = Period divider
                                 .def pulse1_volume_decay = r17 //0000.dddd = Decay
                                 
                                 reset:
000000 940c 11d2                 	jmp init
                                 
                                 .org TCA0_OVF_vect
00000e 940c 132a                 	jmp sound_driver
                                 
                                 .org TCA0_CMP0_vect
000012 940c 1310                 	jmp sequence_0_2
                                 
                                 .org TCA0_CMP1_vect
000014 940c 131a                 	jmp sequence_1_3
                                 
                                 .org TCA0_CMP2_vect
000016 940c 1310                 	jmp sequence_0_2
                                 
                                 .org TCB0_INT_vect
000018 940c 19f0                 	jmp pulse1_sequence_routine
                                 
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(65): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(66): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(67): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(68): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(69): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(70): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(71): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(72): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(73): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(74): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(75): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(76): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(77): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(78): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(79): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(80): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(82): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(83): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(85): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(86): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(87): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(89): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(90): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(91): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(93): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(94): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(95): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(96): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(99): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(100): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(101): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(104): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(106): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(107): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(108): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(115): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(116): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(117): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(122): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(125): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(127): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(128): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(129): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(130): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(131): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(132): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(133): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(134): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(135): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(138): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(139): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(140): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(144): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(145): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(146): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(147): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(149): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(150): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(151): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(152): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(154): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(155): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(156): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(157): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(158): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(159): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(162): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(163): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(164): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(275): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(276): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(277): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(279): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(284): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(285): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(286): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(287): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(288): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(289): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(290): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(291): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(292): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(294): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(298): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(299): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(300): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(301): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(303): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(304): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(306): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(310): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(314): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(315): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(316): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(317): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(319): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(320): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(321): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(324): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(325): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(328): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(329): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(331): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(338): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(339): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(127): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
                                 .list
                                 
                                 init:
                                 	//MAIN CLOCK
0011d2 edb8                      	ldi r27, CPU_CCP_IOREG_gc //protected write
0011d3 93b0 0034                 	sts CPU_CCP, r27
0011d5 e0b0                      	ldi r27, 0 << CLKCTRL_PEN_bp //disable prescaler for 20 MHz on main clock
0011d6 93b0 0061                 	sts CLKCTRL_MCLKCTRLB, r27
                                 
                                 /*	//TEST FOR C4, 1 SECOND, 50% DD
                                 	ldi r26, 0x97
                                 	ldi r27, 0x12
                                 	ldi r26, 0x15
                                 	ldi r27, 0x09
                                 	sts pulse1_timerL, r26
                                 	sts pulse1_timerH, r27
                                 	ldi r27, 0b10111111
                                 	sts pulse1_param, r27
                                 	ldi r27, 0x01
                                 	sts pulse1_length, r27
                                 	//TEST FOR SWEEP UP
                                 	ldi r27, 0b11111111
                                 	sts pulse1_sweep_param, r27*/
                                 
                                 	//ZERO
0011d8 2422                      	clr zero
                                 
                                 	//MEMORY
0011d9 e3b0                      	ldi r27, 0b00110000
0011da 93b0 2800                 	sts pulse1_param, r27
0011dc e8b0                      	ldi r27, 0b10000000
0011dd 93b0 2801                 	sts pulse1_sweep_param, r27
0011df efbf                      	ldi r27, 0xFF
0011e0 93b0 2802                 	sts pulse1_timerL, r27
0011e2 93b0 2803                 	sts pulse1_timerH, r27
0011e4 93b0 2804                 	sts pulse1_length, r27
                                 
0011e6 e0b0                      	ldi r27, 0x00
0011e7 93b0 280a                 	sts song_frame_offset, r27
0011e9 93b0 280b                 	sts song_frame_offset+1, r27
0011eb eee2                      	ldi ZL, LOW(song0_frames << 1)
0011ec e0f1                      	ldi ZH, HIGH(song0_frames << 1)
0011ed 93e0 2808                 	sts song_frames, ZL
0011ef 93f0 2809                 	sts song_frames+1, ZH
0011f1 9220 280c                 	sts song_speed, zero
                                 
                                 	//CHANNEL 0 TEST
0011f3 e0b0                      	ldi r27, 0x00
0011f4 0feb                      	add ZL, r27
0011f5 1df2                      	adc ZH, zero
0011f6 91a5                      	lpm r26, Z+
0011f7 91b4                      	lpm r27, Z
0011f8 0faa                      	lsl r26
0011f9 1fbb                      	rol r27
0011fa 93a0 2810                 	sts pulse1_pattern, r26
0011fc 93b0 2811                 	sts pulse1_pattern+1, r27
0011fe e0b0                      	ldi r27, 0x00
0011ff 9220 2812                 	sts pulse1_pattern_delay, zero
001201 9220 2813                 	sts pulse1_pattern_delay+1, zero
001203 9220 2814                 	sts pulse1_pattern_offset, zero
001205 9220 2815                 	sts pulse1_pattern_offset+1, zero
                                 
                                 	//channel 0 instrument macros
001207 efbf                      	ldi r27, 0xFF
001208 9220 2818                 	sts pulse1_volume_macro_offset, zero
00120a 93b0 2819                 	sts pulse1_volume_macro_loop, r27
00120c 93b0 281a                 	sts pulse1_volume_macro_release, r27
00120e 9220 281d                 	sts pulse1_arpeggio_macro_offset, zero
001210 93b0 281e                 	sts pulse1_arpeggio_macro_loop, r27
001212 93b0 281f                 	sts pulse1_arpeggio_macro_release, r27
001214 93b0 2820                 	sts pulse1_arpeggio_macro_mode, r27
001216 9220 2824                 	sts pulse1_pitch_macro_offset, zero
001218 93b0 2825                 	sts pulse1_pitch_macro_loop, r27
00121a 93b0 2826                 	sts pulse1_pitch_macro_release, r27
00121c 9220 282a                 	sts pulse1_hi_pitch_macro_offset, zero
00121e 93b0 282b                 	sts pulse1_hi_pitch_macro_loop, r27
001220 93b0 282c                 	sts pulse1_hi_pitch_macro_release, r27
001222 9220 282f                 	sts pulse1_duty_macro_offset, zero
001224 93b0 2830                 	sts pulse1_duty_macro_loop, r27
001226 93b0 2831                 	sts pulse1_duty_macro_release, r27
                                 
001228 9220 2816                 	sts pulse1_volume_macro, zero
00122a 9220 2817                 	sts pulse1_volume_macro+1, zero
00122c 9220 281b                 	sts pulse1_arpeggio_macro, zero
00122e 9220 281c                 	sts pulse1_arpeggio_macro+1, zero
001230 9220 2821                 	sts pulse1_total_pitch_offset, zero
001232 9220 2822                 	sts pulse1_pitch_macro, zero
001234 9220 2823                 	sts pulse1_pitch_macro+1, zero
001236 9220 2827                 	sts pulse1_total_hi_pitch_offset, zero
001238 9220 2828                 	sts pulse1_hi_pitch_macro, zero
00123a 9220 2829                 	sts pulse1_hi_pitch_macro+1, zero
00123c 9220 282d                 	sts pulse1_duty_macro, zero
00123e 9220 282e                 	sts pulse1_duty_macro+1, zero
                                 
001240 9220 285d                 	sts pulse2_pattern_delay, zero
001242 9220 285e                 	sts triangle_pattern_delay, zero
001244 9220 285f                 	sts noise_pattern_delay, zero
001246 9220 2860                 	sts dcpm_pattern_delay, zero
                                 
                                 	//PINS
001248 efbf                      	ldi r27, 0xFF //set all pins in VPORTD to output
001249 b9b0                      	out VPORTA_DIR, r27
                                 
                                 	//ENVELOPE
00124a e00f                      	ldi pulse1_volume_divider, 0x0F
00124b 9110 2800                 	lds pulse1_volume_decay, pulse1_param
00124d 701f                      	andi pulse1_volume_decay, 0x0F //mask for VVVV bits
00124e 9190 2800                 	lds channel_flags, pulse1_param
001250 7390                      	andi channel_flags, 0b00110000
001251 6490                      	sbr channel_flags, 0b01000000 //set start flag
001252 9220 2806                 	sts pulse1_output_volume, zero
001254 93b0 2805                 	sts pulse1_fractional_volume, r27 //initialize fractional volume to max value
                                 	
                                 	//LENGTH
001256 91d0 2804                 	lds r29, pulse1_length
001258 d7e4                      	rcall length_converter
001259 2eed                      	mov pulse1_length_counter, r29
                                 
                                 	//SEQUENCE
00125a 91d0 2800                 	lds r29, pulse1_param //load param for sequence table
00125c 0fdd                      	lsl r29 //shift duty cycle bits to LSB
00125d 1fdd                      	rol r29
00125e 1fdd                      	rol r29
00125f 70d3                      	andi r29, 0b00000011 //mask duty cycle bits
001260 d7f2                      	rcall duty_cycle_sequences
001261 2edd                      	mov pulse1_sequence, r29
                                 
                                 	//SWEEP
001262 90f0 2801                 	lds pulse1_sweep, pulse1_sweep_param
001264 94f2                      	swap pulse1_sweep //swap data from high byte and low byte
001265 6890                      	sbr channel_flags, 0b10000000 //set reload flag
                                 
                                 	//FX
001266 efdf                      	ldi r29, 0xFF
001267 93d0 280d                 	sts song_fx_Bxx, r29
001269 9220 280e                 	sts song_fx_Cxx, zero
00126b 9220 280f                 	sts song_fx_Dxx, zero
00126d 9220 2832                 	sts pulse1_fx_0xy_sequence, zero
00126f 9220 2833                 	sts pulse1_fx_0xy_sequence+1, zero
001271 9220 2834                 	sts pulse1_fx_1xx, zero
001273 9220 2835                 	sts pulse1_fx_1xx+1, zero
001275 9220 2836                 	sts pulse1_fx_1xx_total, zero
001277 9220 2837                 	sts pulse1_fx_1xx_total+1, zero
001279 9220 2838                 	sts pulse1_fx_2xx, zero
00127b 9220 2839                 	sts pulse1_fx_2xx+1, zero
00127d 9220 283a                 	sts pulse1_fx_2xx_total, zero
00127f 9220 283b                 	sts pulse1_fx_2xx_total+1, zero
001281 9220 283c                 	sts pulse1_fx_3xx_start, zero
001283 9220 283d                 	sts pulse1_fx_3xx_start+1, zero
001285 9220 283e                 	sts pulse1_fx_3xx_target, zero
001287 9220 283f                 	sts pulse1_fx_3xx_target+1, zero
001289 9220 2840                 	sts pulse1_fx_3xx_speed, zero
00128b 9220 2841                 	sts pulse1_fx_3xx_speed+1, zero
00128d 9220 2842                 	sts pulse1_fx_3xx_total_offset, zero
00128f 9220 2843                 	sts pulse1_fx_3xx_total_offset+1, zero
001291 9220 2844                 	sts pulse1_fx_4xy_speed, zero
001293 9220 2845                 	sts pulse1_fx_4xy_depth, zero
001295 9220 2846                 	sts pulse1_fx_4xy_phase, zero
001297 9220 2847                 	sts pulse1_fx_7xy_speed, zero
001299 9220 2848                 	sts pulse1_fx_7xy_depth, zero
00129b 9220 2849                 	sts pulse1_fx_7xy_phase, zero
00129d 9220 284a                 	sts pulse1_fx_7xy_value, zero
00129f 9220 284b                 	sts pulse1_fx_Axy, zero
0012a1 9220 284c                 	sts pulse1_fx_Gxx_pre, zero
0012a3 9220 284d                 	sts pulse1_fx_Gxx_post, zero
0012a5 9220 284e                 	sts pulse1_fx_Pxx, zero
0012a7 9220 284f                 	sts pulse1_fx_Qxy_target, zero
0012a9 9220 2850                 	sts pulse1_fx_Qxy_target+1, zero
0012ab 9220 2851                 	sts pulse1_fx_Qxy_speed, zero
0012ad 9220 2852                 	sts pulse1_fx_Qxy_speed+1, zero
0012af 9220 2853                 	sts pulse1_fx_Qxy_total_offset, zero
0012b1 9220 2854                 	sts pulse1_fx_Qxy_total_offset+1, zero
0012b3 9220 2855                 	sts pulse1_fx_Rxy_target, zero
0012b5 9220 2856                 	sts pulse1_fx_Rxy_target+1, zero
0012b7 9220 2857                 	sts pulse1_fx_Rxy_speed, zero
0012b9 9220 2858                 	sts pulse1_fx_Rxy_speed+1, zero
0012bb 9220 2859                 	sts pulse1_fx_Rxy_total_offset, zero
0012bd 9220 285a                 	sts pulse1_fx_Rxy_total_offset+1, zero
0012bf 9220 285b                 	sts pulse1_fx_Sxx_pre, zero
0012c1 9220 285c                 	sts pulse1_fx_Sxx_post, zero
                                 
                                 	//TIMERS
                                 	//Frame Counter
                                 	//NOTE:The frame counter will be defaulted to NTSC mode (60 Hz, 120 Hz, 240 Hz)
                                 	//Each interrupt will be setup to interrupt every 240 Hz clock
                                 	//CMP0 = sequence 0, CMP1 = sequence 1, CMP2 = sequence 2, OVF = sequence 3/sound driver
                                 	//Sequence 3 will clock the sound driver every 60Hz, in which new audio data is read and written to the registers
                                 	//Timer period Calculation: (0.00416666666 * 20000000/64)-1 = 1301.08333125 = 0x0515
                                 	//The ATmega4809 is cofigured to run at 20000000 Hz
                                 	//0.00416666666 seconds is the period for 240 Hz
                                 	//The /64 comes from the prescaler divider used
0012c3 e7b0                      	ldi r27, TCA_SINGLE_CMP0EN_bm | TCA_SINGLE_CMP1EN_bm | TCA_SINGLE_CMP2EN_bm | TCA_SINGLE_WGMODE_NORMAL_gc //interrupt mode
0012c4 93b0 0a01                 	sts TCA0_SINGLE_CTRLB, r27
0012c6 e7b1                      	ldi r27, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP1_bm | TCA_SINGLE_CMP2_bm | TCA_SINGLE_OVF_bm //enable overflow and compare interrupts
0012c7 93b0 0a0a                 	sts TCA0_SINGLE_INTCTRL, r27
0012c9 e1b5                      	ldi r27, 0x15 //set the period for CMP0
0012ca 93b0 0a28                 	sts TCA0_SINGLE_CMP0, r27
0012cc e0b5                      	ldi r27, 0x05
0012cd 93b0 0a29                 	sts TCA0_SINGLE_CMP0 + 1, r27
0012cf e2bb                      	ldi r27, 0x2B //set the period for CMP1
0012d0 93b0 0a2a                 	sts TCA0_SINGLE_CMP1, r27
0012d2 e0ba                      	ldi r27, 0x0A
0012d3 93b0 0a2b                 	sts TCA0_SINGLE_CMP1 + 1, r27
0012d5 e4b1                      	ldi r27, 0x41 //set the period for CMP2
0012d6 93b0 0a2c                 	sts TCA0_SINGLE_CMP2, r27
0012d8 e0bf                      	ldi r27, 0x0F
0012d9 93b0 0a2d                 	sts TCA0_SINGLE_CMP2 + 1, r27
0012db e5b7                      	ldi r27, 0x57 //set the period for OVF
0012dc 93b0 0a26                 	sts TCA0_SINGLE_PER, r27
0012de e1b4                      	ldi r27, 0x14
0012df 93b0 0a27                 	sts TCA0_SINGLE_PER + 1, r27
0012e1 e0bb                      	ldi r27, TCA_SINGLE_CLKSEL_DIV64_gc | TCA_SINGLE_ENABLE_bm //use prescale divider of 64 and enable timer
0012e2 93b0 0a00                 	sts TCA0_SINGLE_CTRLA, r27
                                 
                                 	//NOTE: Channel Timers are clocked (20/2)/(0.8948865) = 11.1746014718 times faster than the NES APU
                                 	//Because of this, we multiply all the NES timer values by 11.1746014718 beforehand
                                 	//Since we rotate the sequence when the timer goes from t-(t-1) to 0, instead of 0 to t like the NES, we add 1 to the NES timers before multiplying
                                 	//The ATmega4809 is configured to run at 20 MHz
                                 	//The /2 comes from the prescaler divider used
                                 	//0.8948865 MHz is the speed of the NTSC NES APU
                                 	//NOTE: This means that any offset to the pitch for the NES timers would be multiplied by 11.1746014718 aswell.
                                 	//Pulse 1
0012e4 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
0012e5 93b0 0a81                 	sts TCB0_CTRLB, r27
0012e7 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
0012e8 93b0 0a85                 	sts TCB0_INTCTRL, r27
0012ea 91b0 2802                 	lds r27, pulse1_timerL //load the LOW bits for timer
0012ec 93b0 0a8c                 	sts TCB0_CCMPL, r27
0012ee 91b0 2803                 	lds r27, pulse1_timerH //load the HIGH bits for timer
0012f0 93b0 0a8d                 	sts TCB0_CCMPH, r27
0012f2 e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
0012f3 93b0 0a80                 	sts TCB0_CTRLA, r27
0012f5 9478                      	sei //global interrupt enable
                                 
                                 pulse1:
0012f6 fed0                      	sbrs pulse1_sequence, 0 //if the sequence output is zero, return
0012f7 c012                      	rjmp pulse1_off
                                 
0012f8 14e2                      	cp pulse1_length_counter, zero //if length is zero, return
0012f9 f081                      	breq pulse1_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
                                 pulse1_check_timer_08:
0012fa 91c0 0a8c                 	lds r28, TCB0_CCMPL
0012fc 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 pulse1_check_timer_08_HIGH:
0012fe 30d1                      	cpi r29, 0x01 //check timer HIGH period
0012ff f008                      	brlo pulse1_check_timer_08_LOW //if the timer HIGH period is $00, check the LOW period
001300 c002                      	rjmp pulse1_check_timer_7FF_HIGH //if the timer HIGH period is > $01, check > $07FF condition
                                 pulse1_check_timer_08_LOW:
001301 35c9                      	cpi r28, 0x59 //check timer LOW period
001302 f038                      	brlo pulse1_off //if the HIGH period == $00 && LOW period <= $59, pulse off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $5965
                                 pulse1_check_timer_7FF_HIGH:
001303 35d9                      	cpi r29, 0x59 //check timer HIGH period
001304 f038                      	brlo pulse1_on //if the HIGH period is < $59, then all conditions have passed and pulse is not muted
001305 f009                      	breq pulse1_check_timer_7FF_LOW //if the HIGH period is == $59, we go check if the LOW period is < $65
001306 c003                      	rjmp pulse1_off //pulse off if HIGH period is > $59
                                 pulse1_check_timer_7FF_LOW:
001307 36c5                      	cpi r28, 0x65 //check timer LOW period
001308 f408                      	brsh pulse1_off //if the HIGH period == $59 && LOW period >= $65, pulse off
001309 c002                      	rjmp pulse1_on //if the HIGH period == $59 && LOW period < $65, pulse on
                                 
                                 pulse1_off:
00130a b821                      	out VPORTA_OUT, zero
00130b cfea                      	rjmp pulse1
                                 
                                 pulse1_on:
00130c 91d0 2806                 	lds r29, pulse1_output_volume
                                 /*	cpse r29, zero
                                 	rjmp pulse1_off //if VVVV bits are 0, then there is no volume (channel off)*/
                                 
00130e b9d1                      	out VPORTA_OUT, r29
00130f cfe6                      	rjmp pulse1
                                 
                                 //FRAME COUNTER/AUDIO SAMPLE ISR
                                 sequence_0_2:
001310 b7bf                      	in r27, CPU_SREG
001311 93bf                      	push r27
001312 94f8                      	cli
                                 
                                 	//ENVELOPE
001313 d711                      	rcall pulse1_envelope_routine
                                 
001314 e5b0                      	ldi r27, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP2_bm //clear OVF flag
001315 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
001317 91bf                      	pop r27
001318 bfbf                      	out CPU_SREG, r27
001319 9518                      	reti
                                 
                                 sequence_1_3:
00131a b7bf                      	in r27, CPU_SREG
00131b 93bf                      	push r27
00131c 94f8                      	cli
                                 
                                 	//ENVELOPE
00131d d707                      	rcall pulse1_envelope_routine
                                 
                                 	//SWEEP
00131e fcf3                      	sbrc pulse1_sweep, 3 //check if the sweep enable bit is cleared
00131f d6db                      	rcall pulse1_sweep_routine
                                 
                                 	//LENGTH
                                 	//NOTE: The length routine is relatively simple, so we will not be using clocks to rjmp and ret to a seperate lable
001320 fd95                      	sbrc channel_flags, 5 //check if the length counter halt bit is cleared
001321 c002                      	rjmp sequence_1_3_exit
001322 10e2                      	cpse pulse1_length_counter, zero //if length counter is already 0, don't decrement
001323 94ea                      	dec pulse1_length_counter
                                 
                                 sequence_1_3_exit:
001324 e2b1                      	ldi r27, TCA_SINGLE_CMP1_bm | TCA_SINGLE_OVF_bm //clear OVF flag
001325 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
001327 91bf                      	pop r27
001328 bfbf                      	out CPU_SREG, r27
001329 9518                      	reti
                                 
                                 sound_driver:
00132a b7bf                      	in r27, CPU_SREG
00132b 93bf                      	push r27
00132c 94f8                      	cli
00132d 93cf                      	push r28
00132e 93df                      	push r29
                                 
                                 	//SOUND DRIVER
00132f 91a0 280d                 	lds r26, song_fx_Bxx
001331 3faf                      	cpi r26, 0xFF //0xFF means that the flag is disabled
001332 f449                      	brne sound_driver_fx_Bxx_routine
001333 91a0 280e                 	lds r26, song_fx_Cxx
001335 11a2                      	cpse r26, zero
001336 c02e                      	rjmp sound_driver_fx_Cxx_routine
001337 91a0 280f                 	lds r26, song_fx_Dxx
001339 11a2                      	cpse r26, zero
00133a c039                      	rjmp sound_driver_fx_Dxx_routine
00133b c05f                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_fx_Bxx_routine:
00133c 91e0 2808                 	lds ZL, song_frames
00133e 91f0 2809                 	lds ZH, song_frames+1
001340 27cc                      	clr r28 //initialize r29:r28 to 0
001341 27dd                      	clr r29
001342 95a3                      	inc r26 //increment xx parameter by 1
                                 sound_driver_fx_Bxx_routine_loop:
001343 95aa                      	dec r26
001344 f011                      	breq sound_driver_fx_Bxx_routine_loop_exit //once r26 == 0, r29:r28 will hold Bxx*(5*2).
001345 962a                      	adiw r29:r28, 10 //increment the offset by 10 because 5 channels, and each address takes 2 bytes (5*2 = 10)
001346 cffc                      	rjmp sound_driver_fx_Bxx_routine_loop
                                 
                                 sound_driver_fx_Bxx_routine_loop_exit:
001347 93c0 280a                 	sts song_frame_offset, r28
001349 93d0 280b                 	sts song_frame_offset+1, r29
00134b 0fec                      	add ZL, r28
00134c 1ffd                      	adc ZH, r29
                                 
00134d 91a5                      	lpm r26, Z+ //load the address of the frame(pattern)
00134e 91b4                      	lpm r27, Z
00134f 0faa                      	lsl r26
001350 1fbb                      	rol r27
001351 93a0 2810                 	sts pulse1_pattern, r26
001353 93b0 2811                 	sts pulse1_pattern+1, r27
                                 
001355 9220 2814                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001357 9220 2815                 	sts pulse1_pattern_offset+1, zero
001359 9220 2812                 	sts pulse1_pattern_delay, zero //reset the delay to 0 as well
00135b 9220 2813                 	sts pulse1_pattern_delay+1, zero
                                 
00135d efaf                      	ldi r26, 0xFF
00135e 93a0 280d                 	sts song_fx_Bxx, r26 //reset all song effects
001360 9220 280e                 	sts song_fx_Cxx, zero
001362 9220 280f                 	sts song_fx_Dxx, zero
001364 c036                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_fx_Cxx_routine:
001365 91df                      	pop r29
001366 91cf                      	pop r28
001367 91bf                      	pop r27
001368 bfbf                      	out CPU_SREG, r27
001369 94f8                      	cli //disable global interrupts
                                 		
00136a efaf                      	ldi r26, 0xFF
00136b 93a0 280d                 	sts song_fx_Bxx, r26 //reset all song effects
00136d 9220 280e                 	sts song_fx_Cxx, zero
00136f 9220 280f                 	sts song_fx_Dxx, zero
                                 
001371 9220 2806                 	sts pulse1_output_volume, zero //mute all channels
001373 9518                      	reti
                                 
                                 sound_driver_fx_Dxx_routine:
001374 91e0 2808                 	lds ZL, song_frames
001376 91f0 2809                 	lds ZH, song_frames+1
001378 91a0 280a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
00137a 91b0 280b                 	lds r27, song_frame_offset+1
00137c 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
00137d 93a0 280a                 	sts song_frame_offset, r26
00137f 93b0 280b                 	sts song_frame_offset+1, r27
001381 0fea                      	add ZL, r26
001382 1ffb                      	adc ZH, r27
                                 
001383 91a5                      	lpm r26, Z+ //load the address of the next pattern
001384 91b4                      	lpm r27, Z
001385 0faa                      	lsl r26
001386 1fbb                      	rol r27
001387 93a0 2810                 	sts pulse1_pattern, r26
001389 93b0 2811                 	sts pulse1_pattern+1, r27
                                 
00138b 9220 2814                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
00138d 9220 2815                 	sts pulse1_pattern_offset+1, zero
00138f 9220 2812                 	sts pulse1_pattern_delay, zero //reset the delay to 0 as well
001391 9220 2813                 	sts pulse1_pattern_delay+1, zero
                                 
001393 efaf                      	ldi r26, 0xFF
001394 93a0 280d                 	sts song_fx_Bxx, r26 //reset all song effects
001396 9220 280e                 	sts song_fx_Cxx, zero
001398 9220 280f                 	sts song_fx_Dxx, zero
00139a c000                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0:
00139b 91a0 2812                 	lds r26, pulse1_pattern_delay
00139d 91b0 2813                 	lds r27, pulse1_pattern_delay+1
00139f 9610                      	adiw r27:r26, 0
0013a0 f009                      	breq sound_driver_channel0_main //if the pattern delay is 0, proceed with sound driver procedures
0013a1 c2fd                      	rjmp sound_driver_channel0_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel0_main:
0013a2 91e0 2810                 	lds ZL, pulse1_pattern //current pattern for pulse 1
0013a4 91f0 2811                 	lds ZH, pulse1_pattern+1
0013a6 91a0 2814                 	lds r26, pulse1_pattern_offset //current offset in the pattern for pulse 1
0013a8 91b0 2815                 	lds r27, pulse1_pattern_offset+1
0013aa 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
0013ab 1ffb                      	adc ZH, r27
0013ac 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel0_check_if_note: //check if data is a note (0x00 - 0x56)
0013ad 35b7                      	cpi r27, 0x57
0013ae f408                      	brsh sound_driver_channel0_check_if_volume
0013af c164                      	rjmp sound_driver_channel0_note
                                 sound_driver_channel0_check_if_volume: //check if data is volume (0x57-0x66)
0013b0 36b7                      	cpi r27, 0x67
0013b1 f408                      	brsh sound_driver_channel0_check_if_delay
0013b2 c19c                      	rjmp sound_driver_channel0_volume
                                 sound_driver_channel0_check_if_delay: //check if data is a delay (0x67 - 0xE2)
0013b3 3eb3                      	cpi r27, 0xE3
0013b4 f408                      	brsh sound_driver_channel0_check_if_instrument
0013b5 c1a3                      	rjmp sound_driver_channel0_delay
                                 sound_driver_channel0_check_if_instrument: //check for instrument flag (0xE3)
0013b6 f409                      	brne sound_driver_channel0_check_if_release
0013b7 c1a6                      	rjmp sound_driver_channel0_instrument_change 
                                 sound_driver_channel0_check_if_release: //check for note release flag (0xE4)
0013b8 3eb4                      	cpi r27, 0xE4
0013b9 f409                      	brne sound_driver_channel0_check_if_end
0013ba c24d                      	rjmp sound_driver_channel0_release
                                 sound_driver_channel0_check_if_end:
0013bb 3fbf                      	cpi r27, 0xFF
0013bc f409                      	brne sound_driver_channel0_check_if_fx
0013bd c26f                      	rjmp sound_driver_channel0_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel0_check_if_fx: //fx flags (0xE5 - 0xFE)
0013be 9631                      	adiw Z, 1 //point Z to the byte next to the flag
0013bf 91a4                      	lpm r26, Z //load the fx data into r26
0013c0 d292                      	rcall sound_driver_channel0_increment_offset_twice
                                 
0013c1 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
0013c2 ebe6                      	ldi ZL, LOW(fx << 1) //load in note table
0013c3 e3f4                      	ldi ZH, HIGH(fx << 1)
0013c4 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
0013c5 0feb                      	add ZL, r27 //add offset
0013c6 1df2                      	adc ZH, zero
0013c7 91c5                      	lpm r28, Z+ //load address bytes
0013c8 91d4                      	lpm r29, Z
0013c9 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
0013ca 2ffd                      	mov ZH, r29
0013cb 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel0_fx_0xy:
0013cc 93a0 2832                 	sts pulse1_fx_0xy_sequence, r26
0013ce 9220 2833                 	sts pulse1_fx_0xy_sequence+1, zero
0013d0 cfd1                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel0_fx_1xx:
0013d1 9220 2838                 	sts pulse1_fx_2xx, zero //turn off any 2xx pitch slide down
0013d3 9220 2839                 	sts pulse1_fx_2xx+1, zero
0013d5 9220 2832                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
0013d7 9220 2833                 	sts pulse1_fx_0xy_sequence+1, zero
0013d9 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0013da 937f                      	push r23
0013db 2f6a                      	mov r22, r26 //store the rate into r22
0013dc eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0013dd 9f67                      	mul r22, r23
0013de 917f                      	pop r23
0013df 916f                      	pop r22
                                 
0013e0 9416                      	lsr r1 //shift out the fractional bits
0013e1 9407                      	ror r0
0013e2 9416                      	lsr r1
0013e3 9407                      	ror r0
0013e4 9416                      	lsr r1
0013e5 9407                      	ror r0
0013e6 9416                      	lsr r1
0013e7 9407                      	ror r0
0013e8 9200 2834                 	sts pulse1_fx_1xx, r0
0013ea 9210 2835                 	sts pulse1_fx_1xx+1, r1
0013ec cfb5                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel0_fx_2xx:
0013ed 9220 2834                 	sts pulse1_fx_1xx, zero //turn off any 1xx pitch slide down
0013ef 9220 2835                 	sts pulse1_fx_1xx+1, zero
0013f1 9220 2832                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
0013f3 9220 2833                 	sts pulse1_fx_0xy_sequence+1, zero
0013f5 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0013f6 937f                      	push r23
0013f7 2f6a                      	mov r22, r26 //store the rate into r22
0013f8 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0013f9 9f67                      	mul r22, r23
0013fa 917f                      	pop r23
0013fb 916f                      	pop r22
                                 
0013fc 9416                      	lsr r1 //shift out the fractional bits
0013fd 9407                      	ror r0
0013fe 9416                      	lsr r1
0013ff 9407                      	ror r0
001400 9416                      	lsr r1
001401 9407                      	ror r0
001402 9416                      	lsr r1
001403 9407                      	ror r0
001404 9200 2838                 	sts pulse1_fx_2xx, r0
001406 9210 2839                 	sts pulse1_fx_2xx+1, r1
001408 cf99                      	rjmp sound_driver_channel0_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel0_fx_3xx:
001409 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00140a 937f                      	push r23
00140b 2f6a                      	mov r22, r26 //store the rate into r22
00140c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00140d 9f67                      	mul r22, r23
00140e 917f                      	pop r23
00140f 916f                      	pop r22
                                 
001410 9416                      	lsr r1 //shift out the fractional bits
001411 9407                      	ror r0
001412 9416                      	lsr r1
001413 9407                      	ror r0
001414 9416                      	lsr r1
001415 9407                      	ror r0
001416 9416                      	lsr r1
001417 9407                      	ror r0
001418 9200 2840                 	sts pulse1_fx_3xx_speed, r0
00141a 9210 2841                 	sts pulse1_fx_3xx_speed+1, r1
                                 
00141c 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
00141d c001                      	rjmp sound_driver_channel0_fx_3xx_enabled
00141e cf83                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_3xx_enabled:
00141f 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001421 91b0 0a8d                 	lds r27, TCB0_CCMPH
001423 93a0 283c                 	sts pulse1_fx_3xx_start, r26
001425 93b0 283d                 	sts pulse1_fx_3xx_start+1, r27
                                 
001427 9220 2842                 	sts pulse1_fx_3xx_total_offset, zero
001429 9220 2843                 	sts pulse1_fx_3xx_total_offset+1, zero
00142b cf76                      	rjmp sound_driver_channel0_main
                                 
                                 //VIBRATO
                                 sound_driver_channel0_fx_4xy:
00142c 2fba                      	mov r27, r26
00142d 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
00142e 95a2                      	swap r26
00142f 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001430 93a0 2844                 	sts pulse1_fx_4xy_speed, r26
001432 93b0 2845                 	sts pulse1_fx_4xy_depth, r27
001434 9220 2846                 	sts pulse1_fx_4xy_phase, zero //reset the phase to 0
001436 cf6b                      	rjmp sound_driver_channel0_main
                                 
                                 //TREMELO
                                 sound_driver_channel0_fx_7xy:
001437 2fba                      	mov r27, r26
001438 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001439 95a2                      	swap r26
00143a 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
00143b 93a0 2847                 	sts pulse1_fx_7xy_speed, r26
00143d 93b0 2848                 	sts pulse1_fx_7xy_depth, r27
00143f 9220 2849                 	sts pulse1_fx_7xy_phase, zero //reset the phase to 0
001441 9220 284a                 	sts pulse1_fx_7xy_value, zero //reset the tremelo value
001443 cf5e                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel0_fx_Axy:
001444 93a0 284b                 	sts pulse1_fx_Axy, r26
001446 cf5b                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel0_fx_Bxx:
001447 93a0 280d                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001449 cf58                      	rjmp sound_driver_channel0_main
                                 
                                 //HALT
                                 sound_driver_channel0_fx_Cxx:
00144a 93b0 280e                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
00144c cf55                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel0_fx_Dxx:
00144d 93b0 280f                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
00144f cf52                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME
                                 sound_driver_channel0_fx_Exx:
001450 91b0 2800                 	lds r27, pulse1_param
001452 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
001453 2bba                      	or r27, r26 //move new VVVV bits into pulse1_param
001454 93b0 2800                 	sts pulse1_param, r27
001456 6096                      	sbr channel_flags, 6
001457 cf4a                      	rjmp sound_driver_channel0_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel0_fx_Fxx:
001458 93a0 280c                 	sts song_speed, r26 //NOTE: only changes to speed are supported
00145a cf47                      	rjmp sound_driver_channel0_main
                                 
                                 //DELAY
                                 sound_driver_channel0_fx_Gxx:
00145b 93a0 284c                 	sts pulse1_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
00145d cf44                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_Hxy: //hardware sweep up
00145e 95a2                      	swap r26
00145f 68a8                      	ori r26, 0b10001000 //enable negate and enable sweep flag
001460 2efa                      	mov pulse1_sweep, r26
001461 92f0 2801                 	sts pulse1_sweep_param, pulse1_sweep
001463 6097                      	sbr channel_flags, 7 //set reload flag
001464 cf3d                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_Ixy: //hardware sweep down
001465 95a2                      	swap r26
001466 77af                      	andi r26, 0b01111111 //disable negate flag
001467 60a8                      	ori r26, 0b00001000 //enable sweep flag
001468 2efa                      	mov pulse1_sweep, r26
001469 92f0 2801                 	sts pulse1_sweep_param, pulse1_sweep
00146b 6097                      	sbr channel_flags, 7 //set reload flag
00146c cf35                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_Hxx: //FDS modulation depth
00146d cf34                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixx: //FDS modulation speed
00146e cf33                      	rjmp sound_driver_channel0_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel0_fx_Pxx:
00146f 93a0 284e                 	sts pulse1_fx_Pxx, r26
001471 cf30                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel0_fx_Qxy:
                                 sound_driver_channel0_fx_Qxy_check_arpeggio_macro:
001472 91e0 281b                 	lds ZL, pulse1_arpeggio_macro
001474 91f0 281c                 	lds ZH, pulse1_arpeggio_macro+1
001476 9630                      	adiw Z, 0
001477 f009                      	breq sound_driver_channel0_fx_Qxy_check_pitch_macro
001478 cf29                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_pitch_macro:
001479 91e0 2822                 	lds ZL, pulse1_pitch_macro
00147b 91f0 2823                 	lds ZH, pulse1_pitch_macro+1
00147d 9630                      	adiw Z, 0
00147e f009                      	breq sound_driver_channel0_fx_Qxy_check_hi_pitch_macro
00147f cf22                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_hi_pitch_macro:
001480 91e0 2828                 	lds ZL, pulse1_hi_pitch_macro
001482 91f0 2829                 	lds ZH, pulse1_hi_pitch_macro+1
001484 9630                      	adiw Z, 0
001485 f009                      	breq sound_driver_channel0_fx_Qxy_process
001486 cf1b                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_process:
001487 2fba                      	mov r27, r26 //copy fx parameters into r27
001488 70bf                      	andi r27, 0x0F //mask note index offset
001489 91c0 2807                 	lds r28, pulse1_note //load current note index
00148b 0fbc                      	add r27, r28
00148c 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
00148d f008                      	brlo sound_driver_channel0_fx_Qxy_process_continue
00148e e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel0_fx_Qxy_process_continue:
00148f e3e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001490 e0f0                      	ldi ZH, HIGH(note_table << 1)
001491 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001492 0feb                      	add ZL, r27 //add offset
001493 1df2                      	adc ZH, zero
001494 91c5                      	lpm r28, Z+ //load bytes
001495 91d4                      	lpm r29, Z
001496 93c0 284f                 	sts pulse1_fx_Qxy_target, r28 //load the LOW bits for the target period
001498 93d0 2850                 	sts pulse1_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
00149a 95a2                      	swap r26
00149b 70af                      	andi r26, 0x0F //mask effect speed
00149c 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
00149d 95a3                      	inc r26 //increment the speed by 1
                                 
00149e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00149f 937f                      	push r23
0014a0 2f6a                      	mov r22, r26 //store the speed data into r27
0014a1 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0014a2 9f67                      	mul r22, r23
0014a3 917f                      	pop r23
0014a4 916f                      	pop r22
                                 
0014a5 9416                      	lsr r1 //shift out the fractional bits
0014a6 9407                      	ror r0
0014a7 9416                      	lsr r1
0014a8 9407                      	ror r0
0014a9 9416                      	lsr r1
0014aa 9407                      	ror r0
0014ab 9416                      	lsr r1
0014ac 9407                      	ror r0
                                 
0014ad 9200 2851                 	sts pulse1_fx_Qxy_speed, r0 //store the effect speed
0014af 9210 2852                 	sts pulse1_fx_Qxy_speed+1, r1
0014b1 9220 2853                 	sts pulse1_fx_Qxy_total_offset, zero
0014b3 9220 2854                 	sts pulse1_fx_Qxy_total_offset+1, zero
0014b5 ceec                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel0_fx_Rxy:
                                 sound_driver_channel0_fx_Rxy_check_arpeggio_macro:
0014b6 91e0 281b                 	lds ZL, pulse1_arpeggio_macro
0014b8 91f0 281c                 	lds ZH, pulse1_arpeggio_macro+1
0014ba 9630                      	adiw Z, 0
0014bb f009                      	breq sound_driver_channel0_fx_Rxy_check_pitch_macro
0014bc cee5                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_pitch_macro:
0014bd 91e0 2822                 	lds ZL, pulse1_pitch_macro
0014bf 91f0 2823                 	lds ZH, pulse1_pitch_macro+1
0014c1 9630                      	adiw Z, 0
0014c2 f009                      	breq sound_driver_channel0_fx_Rxy_check_hi_pitch_macro
0014c3 cede                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_hi_pitch_macro:
0014c4 91e0 2828                 	lds ZL, pulse1_hi_pitch_macro
0014c6 91f0 2829                 	lds ZH, pulse1_hi_pitch_macro+1
0014c8 9630                      	adiw Z, 0
0014c9 f009                      	breq sound_driver_channel0_fx_Rxy_process
0014ca ced7                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_process:
0014cb 2fba                      	mov r27, r26 //copy fx parameters into r27
0014cc 70bf                      	andi r27, 0x0F //mask note index offset
0014cd 91c0 2807                 	lds r28, pulse1_note //load current note index
0014cf 1bcb                      	sub r28, r27
0014d0 f408                      	brcc sound_driver_channel0_fx_Rxy_process_continue
0014d1 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel0_fx_Rxy_process_continue:
0014d2 e3e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0014d3 e0f0                      	ldi ZH, HIGH(note_table << 1)
0014d4 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
0014d5 0fec                      	add ZL, r28 //add offset
0014d6 1df2                      	adc ZH, zero
0014d7 91c5                      	lpm r28, Z+ //load bytes
0014d8 91d4                      	lpm r29, Z
0014d9 93c0 2855                 	sts pulse1_fx_Rxy_target, r28 //load the LOW bits for the target period
0014db 93d0 2856                 	sts pulse1_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
0014dd 95a2                      	swap r26
0014de 70af                      	andi r26, 0x0F //mask effect speed
0014df 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0014e0 95a3                      	inc r26 //increment the speed by 1
                                 
0014e1 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0014e2 937f                      	push r23
0014e3 2f6a                      	mov r22, r26 //store the speed data into r27
0014e4 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0014e5 9f67                      	mul r22, r23
0014e6 917f                      	pop r23
0014e7 916f                      	pop r22
                                 
0014e8 9416                      	lsr r1 //shift out the fractional bits
0014e9 9407                      	ror r0
0014ea 9416                      	lsr r1
0014eb 9407                      	ror r0
0014ec 9416                      	lsr r1
0014ed 9407                      	ror r0
0014ee 9416                      	lsr r1
0014ef 9407                      	ror r0
                                 
0014f0 9200 2857                 	sts pulse1_fx_Rxy_speed, r0 //store the effect speed
0014f2 9210 2858                 	sts pulse1_fx_Rxy_speed+1, r1
0014f4 9220 2859                 	sts pulse1_fx_Rxy_total_offset, zero
0014f6 9220 285a                 	sts pulse1_fx_Rxy_total_offset+1, zero
0014f8 cea9                      	rjmp sound_driver_channel0_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel0_fx_Sxx:
0014f9 93a0 285b                 	sts pulse1_fx_Sxx_pre, r26
0014fb cea6                      	rjmp sound_driver_channel0_main
                                 
                                 //DUTY
                                 sound_driver_channel0_fx_Vxx:
0014fc ebe2                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
0014fd e3f4                      	ldi ZH, HIGH(sequences << 1)
0014fe 0fea                      	add ZL, r26 //offset the pointer
0014ff 1df2                      	adc ZH, zero
                                 
001500 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
001501 95a7                      	ror r26
001502 95a7                      	ror r26
001503 91b0 2800                 	lds r27, pulse1_param //load r27 with pulse1_param (register $4000)
001505 2fcb                      	mov r28, r27 //store a copy of pulse1_param into r28
001506 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
001507 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
001508 c001                      	rjmp sound_driver_channel0_fx_Vxx_store
001509 ce98                      	rjmp sound_driver_channel0_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel0_fx_Vxx_store:
00150a 90d4                      	lpm pulse1_sequence, Z //store the sequence
                                 
00150b 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
00150c 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
00150d 93c0 2800                 	sts pulse1_param, r28
00150f ce92                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_Wxx: //DPCM sample speed
001510 ce91                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Xxx: //DPCM sample retrigger
001511 ce90                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Yxx: //DPCM sample offset
001512 ce8f                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Zxx: //DPCM sample delta counter
001513 ce8e                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 sound_driver_channel0_note:
001514 93b0 2807                 	sts pulse1_note, r27 //store the note index
001516 e0a3                      	ldi r26, 0x03
001517 e0b2                      	ldi r27, 0x02
001518 93b0 2818                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
00151a 93a0 281d                 	sts pulse1_arpeggio_macro_offset, r26
00151c 93b0 2824                 	sts pulse1_pitch_macro_offset, r27
00151e 93b0 282a                 	sts pulse1_hi_pitch_macro_offset, r27
001520 93b0 282f                 	sts pulse1_duty_macro_offset, r27
001522 9220 2821                 	sts pulse1_total_pitch_offset, zero //reset the pitch and hi pitch offset
001524 9220 2827                 	sts pulse1_total_hi_pitch_offset, zero
001526 9220 2836                 	sts pulse1_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001528 9220 2837                 	sts pulse1_fx_1xx_total+1, zero
00152a 9220 283a                 	sts pulse1_fx_2xx_total, zero
00152c 9220 283b                 	sts pulse1_fx_2xx_total+1, zero
00152e 9220 2842                 	sts pulse1_fx_3xx_total_offset, zero //reset 3xx offset
001530 9220 2843                 	sts pulse1_fx_3xx_total_offset+1, zero
001532 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001534 91b0 0a8d                 	lds r27, TCB0_CCMPH
001536 93a0 283c                 	sts pulse1_fx_3xx_start, r26
001538 93b0 283d                 	sts pulse1_fx_3xx_start+1, r27
00153a 9220 2801                 	sts pulse1_sweep_param, zero //reset any sweep effect
00153c 6097                      	sbr channel_flags, 7 //set reload flag
00153d 9220 284f                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00153f 9220 2850                 	sts pulse1_fx_Qxy_target+1, zero
001541 9220 2853                 	sts pulse1_fx_Qxy_total_offset, zero
001543 9220 2854                 	sts pulse1_fx_Qxy_total_offset+1, zero
001545 9220 2855                 	sts pulse1_fx_Rxy_target, zero
001547 9220 2856                 	sts pulse1_fx_Rxy_target+1, zero
001549 9220 2859                 	sts pulse1_fx_Rxy_total_offset, zero
00154b 9220 285a                 	sts pulse1_fx_Rxy_total_offset+1, zero
00154d d0fb                      	rcall sound_driver_channel0_increment_offset
00154e ce53                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_volume:
00154f 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001550 91a0 2800                 	lds r26, pulse1_param
001552 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001553 2bab                      	or r26, r27 //move new VVVV bits into pulse1_param
001554 93a0 2800                 	sts pulse1_param, r26
001556 6096                      	sbr channel_flags, 6
001557 d0f1                      	rcall sound_driver_channel0_increment_offset
001558 ce49                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_delay:
001559 56b7                      	subi r27, 0x67 //NOTE: the delay values are offset by the highest volume value, which is 0x66
00155a 93b0 2812                 	sts pulse1_pattern_delay, r27
00155c d0ec                      	rcall sound_driver_channel0_increment_offset
00155d c0ff                      	rjmp sound_driver_calculate_delays
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change:
00155e 9220 2816                 	sts pulse1_volume_macro, zero //reset all macro addresses
001560 9220 2817                 	sts pulse1_volume_macro+1, zero
001562 9220 281b                 	sts pulse1_arpeggio_macro, zero
001564 9220 281c                 	sts pulse1_arpeggio_macro+1, zero
001566 9220 2822                 	sts pulse1_pitch_macro, zero
001568 9220 2823                 	sts pulse1_pitch_macro+1, zero
00156a 9220 2828                 	sts pulse1_hi_pitch_macro, zero
00156c 9220 2829                 	sts pulse1_hi_pitch_macro+1, zero
00156e 9220 282d                 	sts pulse1_duty_macro, zero
001570 9220 282e                 	sts pulse1_duty_macro+1, zero
001572 9220 2821                 	sts pulse1_total_pitch_offset, zero //reset the pitch offset
001574 9220 2827                 	sts pulse1_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001576 9631                      	adiw Z, 1 //point to the byte next to the flag
001577 91b4                      	lpm r27, Z //store the instrument offset into r27
001578 ebe2                      	ldi ZL, LOW(instruments) //point Z to instruments table
001579 e0ff                      	ldi ZH, HIGH(instruments)
00157a 0feb                      	add ZL, r27 //point Z to offsetted instrument
00157b 1df2                      	adc ZH, zero
00157c 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
00157d 1fff                      	rol ZH
00157e 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
00157f 91b4                      	lpm r27, Z
                                 
001580 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001581 1fbb                      	rol r27
001582 2fea                      	mov ZL, r26
001583 2ffb                      	mov ZH, r27
001584 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001585 9632                      	adiw Z, 2 //point Z to the address of the macro
001586 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel0_instrument_change_macro_loop:
001587 95aa                      	dec r26
001588 f019                      	breq sound_driver_channel0_instrument_change_exit
001589 95b6                      	lsr r27
00158a f078                      	brcs sound_driver_channel0_instrument_change_load_macro
00158b cffb                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_exit:
00158c e0a3                      	ldi r26, 0x03
00158d e0b2                      	ldi r27, 0x02
00158e 93b0 2818                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
001590 93a0 281d                 	sts pulse1_arpeggio_macro_offset, r26
001592 93b0 2824                 	sts pulse1_pitch_macro_offset, r27
001594 93b0 282a                 	sts pulse1_hi_pitch_macro_offset, r27
001596 93b0 282f                 	sts pulse1_duty_macro_offset, r27
001598 d0ba                      	rcall sound_driver_channel0_increment_offset_twice
001599 ce08                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_load_macro:
00159a 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
00159b 91d5                      	lpm r29, Z+
                                 
00159c 30a5                      	cpi r26, 5
00159d f039                      	breq sound_driver_channel0_instrument_change_load_macro_volume
00159e 30a4                      	cpi r26, 4
00159f f079                      	breq sound_driver_channel0_instrument_change_load_macro_arpeggio
0015a0 30a3                      	cpi r26, 3
0015a1 f0d9                      	breq sound_driver_channel0_instrument_change_load_macro_pitch
0015a2 30a2                      	cpi r26, 2
0015a3 f159                      	breq sound_driver_channel0_instrument_change_load_macro_hi_pitch
0015a4 c03c                      	rjmp sound_driver_channel0_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel0_instrument_change_load_macro_volume:
0015a5 93c0 2816                 	sts pulse1_volume_macro, r28
0015a7 93d0 2817                 	sts pulse1_volume_macro+1, r29
0015a9 d041                      	rcall sound_driver_channel0_instrument_change_read_header
0015aa 93c0 281a                 	sts pulse1_volume_macro_release, r28
0015ac 93d0 2819                 	sts pulse1_volume_macro_loop, r29
0015ae cfd8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 	
                                 sound_driver_channel0_instrument_change_load_macro_arpeggio:
0015af 93c0 281b                 	sts pulse1_arpeggio_macro, r28
0015b1 93d0 281c                 	sts pulse1_arpeggio_macro+1, r29
0015b3 9220 284f                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0015b5 9220 2850                 	sts pulse1_fx_Qxy_target+1, zero
0015b7 9220 2855                 	sts pulse1_fx_Rxy_target, zero
0015b9 9220 2856                 	sts pulse1_fx_Rxy_target+1, zero
0015bb d03a                      	rcall sound_driver_channel0_instrument_change_read_header_arpeggio
0015bc cfca                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_pitch:
0015bd 93c0 2822                 	sts pulse1_pitch_macro, r28
0015bf 93d0 2823                 	sts pulse1_pitch_macro+1, r29
0015c1 9220 284f                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0015c3 9220 2850                 	sts pulse1_fx_Qxy_target+1, zero
0015c5 9220 2855                 	sts pulse1_fx_Rxy_target, zero
0015c7 9220 2856                 	sts pulse1_fx_Rxy_target+1, zero
0015c9 d021                      	rcall sound_driver_channel0_instrument_change_read_header
0015ca 93c0 2826                 	sts pulse1_pitch_macro_release, r28
0015cc 93d0 2825                 	sts pulse1_pitch_macro_loop, r29
0015ce cfb8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_hi_pitch:
0015cf 93c0 2828                 	sts pulse1_hi_pitch_macro, r28
0015d1 93d0 2829                 	sts pulse1_hi_pitch_macro+1, r29
0015d3 9220 284f                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0015d5 9220 2850                 	sts pulse1_fx_Qxy_target+1, zero
0015d7 9220 2855                 	sts pulse1_fx_Rxy_target, zero
0015d9 9220 2856                 	sts pulse1_fx_Rxy_target+1, zero
0015db d00f                      	rcall sound_driver_channel0_instrument_change_read_header
0015dc 93c0 282c                 	sts pulse1_hi_pitch_macro_release, r28
0015de 93d0 282b                 	sts pulse1_hi_pitch_macro_loop, r29
0015e0 cfa6                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_duty:
0015e1 93c0 282d                 	sts pulse1_duty_macro, r28
0015e3 93d0 282e                 	sts pulse1_duty_macro+1, r29
0015e5 d005                      	rcall sound_driver_channel0_instrument_change_read_header
0015e6 93c0 2831                 	sts pulse1_duty_macro_release, r28
0015e8 93d0 2830                 	sts pulse1_duty_macro_loop, r29
0015ea cf9c                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_read_header:
0015eb 93ef                      	push ZL
0015ec 93ff                      	push ZH
0015ed 2fec                      	mov ZL, r28
0015ee 2ffd                      	mov ZH, r29
0015ef 0fee                      	lsl ZL
0015f0 1fff                      	rol ZH
0015f1 91c5                      	lpm r28, Z+
0015f2 91d4                      	lpm r29, Z
0015f3 91ff                      	pop ZH
0015f4 91ef                      	pop ZL
0015f5 9508                      	ret
                                 
                                 sound_driver_channel0_instrument_change_read_header_arpeggio:
0015f6 93ef                      	push ZL
0015f7 93ff                      	push ZH
0015f8 2fec                      	mov ZL, r28
0015f9 2ffd                      	mov ZH, r29
0015fa 0fee                      	lsl ZL
0015fb 1fff                      	rol ZH
0015fc 91c5                      	lpm r28, Z+
0015fd 91d5                      	lpm r29, Z+
0015fe 93c0 281f                 	sts pulse1_arpeggio_macro_release, r28
001600 93d0 281e                 	sts pulse1_arpeggio_macro_loop, r29
001602 91c4                      	lpm r28, Z
001603 93c0 2820                 	sts pulse1_arpeggio_macro_mode, r28
001605 91ff                      	pop ZH
001606 91ef                      	pop ZL
001607 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel0_release:
                                 sound_driver_channel0_release_volume:
001608 91b0 281a                 	lds r27, pulse1_volume_macro_release
00160a 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
00160b f019                      	breq sound_driver_channel0_release_arpeggio //if the macro has no release flag, check the next macro
00160c 95b3                      	inc r27
00160d 93b0 2818                 	sts pulse1_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel0_release_arpeggio:
00160f 91b0 281f                 	lds r27, pulse1_arpeggio_macro_release
001611 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001612 f019                      	breq sound_driver_channel0_release_pitch
001613 95b3                      	inc r27
001614 93b0 281d                 	sts pulse1_arpeggio_macro_offset, r27
                                 sound_driver_channel0_release_pitch:
001616 91b0 2826                 	lds r27, pulse1_pitch_macro_release
001618 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001619 f019                      	breq sound_driver_channel0_release_hi_pitch
00161a 95b3                      	inc r27
00161b 93b0 2824                 	sts pulse1_pitch_macro_offset, r27
                                 sound_driver_channel0_release_hi_pitch:
00161d 91b0 282c                 	lds r27, pulse1_hi_pitch_macro_release
00161f 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001620 f019                      	breq sound_driver_channel0_release_duty
001621 95b3                      	inc r27
001622 93b0 282a                 	sts pulse1_hi_pitch_macro_offset, r27
                                 sound_driver_channel0_release_duty:
001624 91b0 2831                 	lds r27, pulse1_duty_macro_release
001626 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001627 f019                      	breq sound_driver_channel0_release_exit
001628 95b3                      	inc r27
001629 93b0 282f                 	sts pulse1_duty_macro_offset, r27
                                 sound_driver_channel0_release_exit:
00162b d01d                      	rcall sound_driver_channel0_increment_offset
00162c cd75                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_next_pattern:
00162d 91e0 2808                 	lds ZL, song_frames
00162f 91f0 2809                 	lds ZH, song_frames+1
001631 91a0 280a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001633 91b0 280b                 	lds r27, song_frame_offset+1
001635 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
001636 93a0 280a                 	sts song_frame_offset, r26
001638 93b0 280b                 	sts song_frame_offset+1, r27
                                 	//adiw r27:r26, 2 //offset for channel 1 (test)
00163a 0fea                      	add ZL, r26
00163b 1ffb                      	adc ZH, r27
                                 
00163c 91a5                      	lpm r26, Z+ //load the address of the next pattern
00163d 91b4                      	lpm r27, Z
00163e 0faa                      	lsl r26
00163f 1fbb                      	rol r27
001640 93a0 2810                 	sts pulse1_pattern, r26
001642 93b0 2811                 	sts pulse1_pattern+1, r27
                                 
001644 9220 2814                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001646 9220 2815                 	sts pulse1_pattern_offset+1, zero
001648 cd59                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_increment_offset:
001649 91e0 2814                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
00164b 91f0 2815                 	lds ZH, pulse1_pattern_offset+1
00164d 9631                      	adiw Z, 1
00164e 93e0 2814                 	sts pulse1_pattern_offset, ZL
001650 93f0 2815                 	sts pulse1_pattern_offset+1, ZH
001652 9508                      	ret
                                 
                                 sound_driver_channel0_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001653 91e0 2814                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
001655 91f0 2815                 	lds ZH, pulse1_pattern_offset+1
001657 9632                      	adiw Z, 2 //increment the pointer twice
001658 93e0 2814                 	sts pulse1_pattern_offset, ZL
00165a 93f0 2815                 	sts pulse1_pattern_offset+1, ZH
00165c 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_calculate_delays:
00165d 936f                      	push r22
00165e 937f                      	push r23
00165f 9160 280c                 	lds r22, song_speed
001661 2fa6                      	mov r26, r22
001662 50a1                      	subi r26, 1
001663 2fda                      	mov r29, r26
                                 
                                 sound_driver_calculate_delays_pulse1:
                                 sound_driver_calculate_delays_pulse1_Sxx:
001664 91b0 285b                 	lds r27, pulse1_fx_Sxx_pre
001666 91c0 285c                 	lds r28, pulse1_fx_Sxx_post
001668 9220 285b                  	sts pulse1_fx_Sxx_pre, zero
00166a 15b2                      	cp r27, zero
00166b f051                      	breq sound_driver_calculate_delays_pulse1_Sxx_post
00166c 17b6                      	cp r27, r22 //compare the Gxx fx to the song speed
00166d f440                      	brsh sound_driver_calculate_delays_pulse1_Sxx_post
00166e 93b0 2812                 	sts pulse1_pattern_delay, r27
001670 9220 2813                 	sts pulse1_pattern_delay+1, zero
001672 1bdb                      	sub r29, r27 //(song speed)-1-Sxx
001673 93d0 285c                 	sts pulse1_fx_Sxx_post, r29
001675 c026                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_post:
001676 15c2                      	cp r28, zero
001677 f021                      	breq sound_driver_calculate_delays_pulse1_Gxx
001678 9220 285c                 	sts pulse1_fx_Sxx_post, zero
00167a 2fac                      	mov r26, r28
00167b c00c                      	rjmp sound_driver_calculate_delays_pulse1_main
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx:
00167c 91b0 284c                 	lds r27, pulse1_fx_Gxx_pre
00167e 91c0 284d                 	lds r28, pulse1_fx_Gxx_post
001680 17b6                      	cp r27, r22 //compare the Gxx fx to the song speed
001681 f018                      	brlo sound_driver_calculate_delays_pulse1_Gxx_post
001682 e0b0                      	ldi r27, 0 //if the Gxx effect exceeds one row (the song speed), then reset the effect to 0
001683 9220 284c                 	sts pulse1_fx_Gxx_pre, zero
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx_post:
001685 15c2                      	cp r28, zero
001686 f009                      	breq sound_driver_calculate_delays_pulse1_main
001687 2fac                      	mov r26, r28 //if there was a Gxx, use its post instead of the (song speed)-1
                                 	
                                 sound_driver_calculate_delays_pulse1_main:
001688 9170 2812                 	lds r23, pulse1_pattern_delay
00168a 9f67                      	mul r22, r23
00168b 0e0a                      	add r0, r26
00168c 1c12                      	adc r1, zero
00168d 0e0b                      	add r0, r27
00168e 1c12                      	adc r1, zero
00168f 9200 2812                 	sts pulse1_pattern_delay, r0
001691 9210 2813                 	sts pulse1_pattern_delay+1, r1
001693 9220 284d                 	sts pulse1_fx_Gxx_post, zero
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx_pre:
001695 15b2                      	cp r27, zero //check if the Gxx effect was enabled
001696 f029                      	breq sound_driver_calculate_delays_pulse2
001697 1bdb                      	sub r29, r27 //(song speed)-1-Gxx
001698 93a0 284d                 	sts pulse1_fx_Gxx_post, r26
00169a 9220 284c                 	sts pulse1_fx_Gxx_pre, zero
                                 
                                 sound_driver_calculate_delays_pulse2:
                                 sound_driver_calculate_delays_pulse2_Gxx:
00169c 917f                      	pop r23
00169d 916f                      	pop r22
00169e c006                      	rjmp sound_driver_instrument_routine
                                 
                                 
                                 
                                 sound_driver_channel0_decrement_frame_delay:
00169f 50a1                      	subi r26, 1
0016a0 09b2                      	sbc r27, zero
0016a1 93a0 2812                 	sts pulse1_pattern_delay, r26
0016a3 93b0 2813                 	sts pulse1_pattern_delay+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine:
                                 sound_driver_instrument_routine_channel0_volume:
0016a5 91e0 2816                 	lds ZL, pulse1_volume_macro
0016a7 91f0 2817                 	lds ZH, pulse1_volume_macro+1
0016a9 9630                      	adiw Z, 0
0016aa f1a1                      	breq sound_driver_instrument_routine_channel0_volume_default //if no volume macro is in use, use default multiplier of F
0016ab 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0016ac 1fff                      	rol ZH
0016ad 91a0 2818                 	lds r26, pulse1_volume_macro_offset
0016af 0fea                      	add ZL, r26
0016b0 1df2                      	adc ZH, zero
                                 
0016b1 91b0 281a                 	lds r27, pulse1_volume_macro_release
0016b3 17ba                      	cp r27, r26
0016b4 f429                      	brne sound_driver_instrument_routine_channel0_volume_increment //if the current offset is not equal to the release index, increment the offset
0016b5 91a0 2819                 	lds r26, pulse1_volume_macro_loop
0016b7 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0016b8 f010                      	brlo sound_driver_instrument_routine_channel0_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0016b9 c003                      	rjmp sound_driver_instrument_routine_channel0_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_volume_increment:
0016ba 95a3                      	inc r26 //increment the macro offset
0016bb 93a0 2818                 	sts pulse1_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_volume_read:
0016bd 91b4                      	lpm r27, Z //load volume data into r27
0016be 3fbf                      	cpi r27, 0xFF //check for macro end flag
0016bf f469                      	brne sound_driver_instrument_routine_channel0_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_release:
0016c0 91b0 281a                 	lds r27, pulse1_volume_macro_release
0016c2 3fbf                      	cpi r27, 0xFF
0016c3 f429                      	brne sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_loop:
0016c4 91b0 2819                 	lds r27, pulse1_volume_macro_loop //load the loop index
0016c6 93b0 2818                 	sts pulse1_volume_macro_offset, r27 //store the loop index into the offset
0016c8 cfdc                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index:
0016c9 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
0016ca 93a0 2818                 	sts pulse1_volume_macro_offset, r26
0016cc cfd8                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_calculate:
0016cd eeea                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
0016ce e3f4                      	ldi ZH, HIGH(volumes << 1)
0016cf 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
0016d0 0feb                      	add ZL, r27 //add offset to the table
0016d1 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel0_volume_load:
0016d2 91b0 2800                 	lds r27, pulse1_param //load main volume
0016d4 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
0016d5 91a0 284a                 	lds r26, pulse1_fx_7xy_value
0016d7 30a0                      	cpi r26, 0x00
0016d8 f481                      	brne sound_driver_instrument_routine_channel0_volume_load_7xy
                                 
0016d9 0feb                      	add ZL, r27 //offset the volume table by the main volume
0016da 1df2                      	adc ZH, zero
0016db 91b4                      	lpm r27, Z
0016dc 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
0016de c024                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default:
0016df 91b0 2800                 	lds r27, pulse1_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
0016e1 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
0016e2 91a0 284a                 	lds r26, pulse1_fx_7xy_value
0016e4 30a0                      	cpi r26, 0x00
0016e5 f4a1                      	brne sound_driver_instrument_routine_channel0_volume_default_7xy
0016e6 93b0 2806                 	sts pulse1_output_volume, r27
0016e8 c01a                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy:
0016e9 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
0016ea f040                      	brcs sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
0016eb f039                      	breq sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
0016ec e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
                                 
0016ed 0feb                      	add ZL, r27 //offset the volume table by the main volume
0016ee 1df2                      	adc ZH, zero
0016ef 91b4                      	lpm r27, Z
0016f0 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
0016f2 c010                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy_overflow:
0016f3 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
0016f4 0feb                      	add ZL, r27 //offset the volume table by the main volume
0016f5 1df2                      	adc ZH, zero
0016f6 91b4                      	lpm r27, Z
0016f7 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
0016f9 c009                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default_7xy:
0016fa 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
0016fb f020                      	brcs sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
0016fc f019                      	breq sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
0016fd 93b0 2806                 	sts pulse1_output_volume, r27
0016ff c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel0_volume_default_7xy_overflow:
001700 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
001701 93b0 2806                 	sts pulse1_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
001703 91e0 281b                 	lds ZL, pulse1_arpeggio_macro
001705 91f0 281c                 	lds ZH, pulse1_arpeggio_macro+1
001707 9630                      	adiw Z, 0
001708 f1d9                      	breq sound_driver_instrument_routine_channel0_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
001709 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
00170a 1fff                      	rol ZH
00170b 91a0 281d                 	lds r26, pulse1_arpeggio_macro_offset
00170d 0fea                      	add ZL, r26
00170e 1df2                      	adc ZH, zero
                                 
00170f 91b0 281f                 	lds r27, pulse1_arpeggio_macro_release
001711 17ba                      	cp r27, r26
001712 f429                      	brne sound_driver_instrument_routine_channel0_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
001713 91a0 281e                 	lds r26, pulse1_arpeggio_macro_loop
001715 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
001716 f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
001717 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_increment:
001718 95a3                      	inc r26 //increment the macro offset
001719 93a0 281d                 	sts pulse1_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_read:
00171b 91b4                      	lpm r27, Z //load arpeggio data into r27
00171c 38b0                      	cpi r27, 0x80 //check for macro end flag
00171d f009                      	breq sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag
00171e c041                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_check_mode:
00171f 50a1                      	subi r26, 1 //keep the offset at the end flag
001720 93a0 281d                 	sts pulse1_arpeggio_macro_offset, r26
001722 91b0 2820                 	lds r27, pulse1_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
001724 30b1                      	cpi r27, 0x01
001725 f048                      	brlo sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_release:
001726 91b0 281f                 	lds r27, pulse1_arpeggio_macro_release
001728 3fbf                      	cpi r27, 0xFF
001729 f4d1                      	brne sound_driver_instrument_routine_channel0_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_loop:
00172a 91b0 281e                 	lds r27, pulse1_arpeggio_macro_loop
00172c 3fbf                      	cpi r27, 0xFF
00172d f499                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
00172e c015                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute:
00172f 91b0 281f                 	lds r27, pulse1_arpeggio_macro_release
001731 3fbf                      	cpi r27, 0xFF
001732 f421                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_check_loop:
001733 91b0 281e                 	lds r27, pulse1_arpeggio_macro_loop //load the loop index
001735 3fbf                      	cpi r27, 0xFF //check if loop flag exists
001736 f451                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop:
001737 91c0 2832                 	lds r28, pulse1_fx_0xy_sequence //check for 0xy effect
001739 91d0 2833                 	lds r29, pulse1_fx_0xy_sequence+1
00173b 9620                      	adiw r29:r28, 0
00173c f469                      	brne sound_driver_instrument_routine_channel0_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
00173d 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
00173e 93a0 281d                 	sts pulse1_arpeggio_macro_offset, r26 //store the last valid index into the offset
001740 cfc2                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload:
001741 93b0 281d                 	sts pulse1_arpeggio_macro_offset, r27 //store the loop index into the offset
001743 cfbf                      	rjmp sound_driver_instrument_routine_channel0_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_default:
001744 91c0 2832                 	lds r28, pulse1_fx_0xy_sequence //load 0xy effect
001746 91d0 2833                 	lds r29, pulse1_fx_0xy_sequence+1
001748 9620                      	adiw r29:r28, 0 //check for 0xy effect
001749 f099                      	breq sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel0_arpeggio_default_xy:
00174a 95d6                      	lsr r29
00174b 95c7                      	ror r28
00174c 95d7                      	ror r29
00174d 95c7                      	ror r28
00174e 95d7                      	ror r29
00174f 95c7                      	ror r28
001750 95d7                      	ror r29
001751 95c7                      	ror r28
001752 95d7                      	ror r29
001753 95d2                      	swap r29
                                 
001754 93c0 2832                 	sts pulse1_fx_0xy_sequence, r28 //store the rolled sequence
001756 93d0 2833                 	sts pulse1_fx_0xy_sequence+1, r29
001758 70cf                      	andi r28, 0x0F //mask out the 4 LSB
001759 91a0 2807                 	lds r26, pulse1_note //load the current note index
00175b 0fac                      	add r26, r28 //add the note offset
00175c c02c                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
00175d 91a0 2807                 	lds r26, pulse1_note //load the current note index
00175f c029                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process:
001760 9220 2821                 	sts pulse1_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
001762 9220 2827                 	sts pulse1_total_hi_pitch_offset, zero
001764 91a0 2820                 	lds r26, pulse1_arpeggio_macro_mode
001766 30a1                      	cpi r26, 0x01 //absolute mode
001767 f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_absolute
001768 f069                      	breq sound_driver_instrument_routine_channel0_arpeggio_process_fixed
001769 c00e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute:
00176a 91a0 2807                 	lds r26, pulse1_note //load the current note index
00176c 0fab                      	add r26, r27 //offset the note with the arpeggio data
00176d fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
00176e c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_add:
00176f 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
001770 f0c0                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
001771 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
001772 c016                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract:
001773 fda7                      	sbrc r26, 7 //check if result is negative
001774 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
001775 c013                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_fixed:
001776 2fab                      	mov r26, r27 //move the arpeggio data into r26
001777 c011                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative:
001778 91a0 2807                 	lds r26, pulse1_note //load the current note index
00177a 0fab                      	add r26, r27 //offset the note with the arpeggio data
00177b fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
00177c c008                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_add:
00177d 93a0 2807                 	sts pulse1_note, r26 //NOTE: relative mode modifies the original note index
00177f 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
001780 f040                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
001781 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
001782 93a0 2807                 	sts pulse1_note, r26
001784 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract:
001785 fda7                      	sbrc r26, 7 //check if result is negative
001786 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
001787 93a0 2807                 	sts pulse1_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_load:
001789 e3e4                      	ldi ZL, LOW(note_table << 1) //load in note table
00178a e0f0                      	ldi ZH, HIGH(note_table << 1)
00178b 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
00178c 0fea                      	add ZL, r26 //add offset
00178d 1df2                      	adc ZH, zero
00178e 91a5                      	lpm r26, Z+ //load bytes
00178f 91b4                      	lpm r27, Z
001790 93a0 0a8c                 	sts TCB0_CCMPL, r26 //load the LOW bits for timer
001792 93b0 0a8d                 	sts TCB0_CCMPH, r27 //load the HIGH bits for timer
001794 93a0 283e                 	sts pulse1_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
001796 93b0 283f                 	sts pulse1_fx_3xx_target+1, r27
001798 c000                      	rjmp sound_driver_instrument_routine_channel0_pitch
                                 
                                 
                                 
                                 //NOTE: There is a limitation with the pitch routines in that the total pitch can not be offset by 127 in both,
                                 //the positive and negative direction, from the original note pitch. This shouldn't be too much of a problem as
                                 //most songs that use instruments with the pitch macro, do not stray that far from the original note pitch.
                                 //In the case of hi pitch, the total pitch can not be offset by 127*16 from the original pitch. This is also
                                 //not a big deal as you can easily reach the entire note range with an offset of up to 127*16.
                                 sound_driver_instrument_routine_channel0_pitch:
001799 91e0 2822                 	lds ZL, pulse1_pitch_macro
00179b 91f0 2823                 	lds ZH, pulse1_pitch_macro+1
00179d 9630                      	adiw Z, 0
00179e f409                      	brne sound_driver_instrument_routine_channel0_pitch_continue
00179f c023                      	rjmp sound_driver_instrument_routine_channel0_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel0_pitch_continue:
0017a0 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0017a1 1fff                      	rol ZH
0017a2 91a0 2824                 	lds r26, pulse1_pitch_macro_offset
0017a4 0fea                      	add ZL, r26
0017a5 1df2                      	adc ZH, zero
                                 
0017a6 91b0 2826                 	lds r27, pulse1_pitch_macro_release
0017a8 17ba                      	cp r27, r26
0017a9 f429                      	brne sound_driver_instrument_routine_channel0_pitch_increment //if the current offset is not equal to the release index, increment the offset
0017aa 91a0 2825                 	lds r26, pulse1_pitch_macro_loop
0017ac 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0017ad f010                      	brlo sound_driver_instrument_routine_channel0_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0017ae c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_pitch_increment:
0017af 95a3                      	inc r26 //increment the macro offset
0017b0 93a0 2824                 	sts pulse1_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_pitch_read:
0017b2 91b4                      	lpm r27, Z //load pitch data into r27
0017b3 38b0                      	cpi r27, 0x80 //check for macro end flag
0017b4 f489                      	brne sound_driver_instrument_routine_channel0_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_release:
0017b5 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0017b6 93a0 2824                 	sts pulse1_pitch_macro_offset, r26
0017b8 91b0 2826                 	lds r27, pulse1_pitch_macro_release
0017ba 3fbf                      	cpi r27, 0xFF
0017bb f439                      	brne sound_driver_instrument_routine_channel0_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_loop:
0017bc 91b0 2825                 	lds r27, pulse1_pitch_macro_loop //load the loop index
0017be 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0017bf f019                      	breq sound_driver_instrument_routine_channel0_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
0017c0 93b0 2824                 	sts pulse1_pitch_macro_offset, r27 //store the loop index into the offset
0017c2 cfd6                      	rjmp sound_driver_instrument_routine_channel0_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_default:
0017c3 91b0 2821                 	lds r27, pulse1_total_pitch_offset
0017c5 c005                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate:
0017c6 91a0 2821                 	lds r26, pulse1_total_pitch_offset //load the total pitch offset to change
0017c8 0fba                      	add r27, r26
0017c9 93b0 2821                 	sts pulse1_total_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_multiply:
                                 	//NOTE: The Pxx effect is processed with the pitch instrument macro because the calculations are the same
0017cb 91a0 284e                 	lds r26, pulse1_fx_Pxx
0017cd 0fba                      	add r27, r26
                                 
0017ce 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0017cf 937f                      	push r23
0017d0 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
0017d1 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0017d2 0367                      	mulsu r22, r23
0017d3 917f                      	pop r23
0017d4 916f                      	pop r22
                                 
0017d5 9416                      	lsr r1 //shift out the fractional bits
0017d6 9407                      	ror r0
0017d7 9416                      	lsr r1
0017d8 9407                      	ror r0
0017d9 9416                      	lsr r1
0017da 9407                      	ror r0
0017db 9416                      	lsr r1
0017dc 9407                      	ror r0
0017dd fe13                      	sbrs r1, 3 //check if result was a negative number
0017de c002                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_negative:
0017df efb0                      	ldi r27, 0xF0
0017e0 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_offset:
0017e1 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
0017e3 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
0017e5 0da0                      	add r26, r0 //offset the timer values
0017e6 1db1                      	adc r27, r1
                                 	
0017e7 91c0 2836                 	lds r28, pulse1_fx_1xx_total
0017e9 91d0 2837                 	lds r29, pulse1_fx_1xx_total+1
0017eb 1bac                      	sub r26, r28
0017ec 0bbd                      	sbc r27, r29
0017ed 91c0 283a                 	lds r28, pulse1_fx_2xx_total
0017ef 91d0 283b                 	lds r29, pulse1_fx_2xx_total+1
0017f1 0fac                      	add r26, r28
0017f2 1fbd                      	adc r27, r29
0017f3 91c0 2853                 	lds r28, pulse1_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
0017f5 91d0 2854                 	lds r29, pulse1_fx_Qxy_total_offset+1
0017f7 1bac                      	sub r26, r28
0017f8 0bbd                      	sbc r27, r29
0017f9 91c0 2859                 	lds r28, pulse1_fx_Rxy_total_offset
0017fb 91d0 285a                 	lds r29, pulse1_fx_Rxy_total_offset+1
0017fd 0fac                      	add r26, r28
0017fe 1fbd                      	adc r27, r29
                                 
0017ff 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
001801 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel0_hi_pitch:
001803 91e0 2828                 	lds ZL, pulse1_hi_pitch_macro
001805 91f0 2829                 	lds ZH, pulse1_hi_pitch_macro+1
001807 9630                      	adiw Z, 0
001808 f409                      	brne sound_driver_instrument_routine_channel0_hi_pitch_continue
001809 c03c                      	rjmp sound_driver_instrument_routine_channel0_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel0_hi_pitch_continue:
00180a 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00180b 1fff                      	rol ZH
00180c 91a0 282a                 	lds r26, pulse1_hi_pitch_macro_offset
00180e 0fea                      	add ZL, r26
00180f 1df2                      	adc ZH, zero
                                 
001810 91b0 282c                 	lds r27, pulse1_hi_pitch_macro_release
001812 17ba                      	cp r27, r26
001813 f429                      	brne sound_driver_instrument_routine_channel0_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
001814 91a0 282b                 	lds r26, pulse1_hi_pitch_macro_loop
001816 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
001817 f010                      	brlo sound_driver_instrument_routine_channel0_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
001818 c003                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_increment:
001819 95a3                      	inc r26 //increment the macro offset
00181a 93a0 282a                 	sts pulse1_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_hi_pitch_read:
00181c 91b4                      	lpm r27, Z //load hi pitch data into r27
00181d 38b0                      	cpi r27, 0x80 //check for macro end flag
00181e f489                      	brne sound_driver_instrument_routine_channel0_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_release:
00181f 50a1                      	subi r26, 1 //keep the macro offset at the end flag
001820 93a0 282a                 	sts pulse1_hi_pitch_macro_offset, r26
001822 91b0 282c                 	lds r27, pulse1_hi_pitch_macro_release
001824 3fbf                      	cpi r27, 0xFF
001825 f439                      	brne sound_driver_instrument_routine_channel0_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_loop:
001826 91b0 282b                 	lds r27, pulse1_hi_pitch_macro_loop //load the loop index
001828 3fbf                      	cpi r27, 0xFF //check if there is a loop index
001829 f019                      	breq sound_driver_instrument_routine_channel0_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
00182a 93b0 282a                 	sts pulse1_hi_pitch_macro_offset, r27 //store the loop index into the offset
00182c cfd6                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_default:
00182d 91b0 2827                 	lds r27, pulse1_total_hi_pitch_offset
00182f c005                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate:
001830 91a0 2827                 	lds r26, pulse1_total_hi_pitch_offset //load the total hi pitch offset to change
001832 0fba                      	add r27, r26
001833 93b0 2827                 	sts pulse1_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply:
001835 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001836 937f                      	push r23
001837 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
001838 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001839 0367                      	mulsu r22, r23
00183a 917f                      	pop r23
00183b 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_offset:
00183c 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
00183e 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
001840 0da0                      	add r26, r0 //offset the timer values
001841 1db1                      	adc r27, r1
001842 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
001844 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel0_duty:
001846 91e0 282d                 	lds ZL, pulse1_duty_macro
001848 91f0 282e                 	lds ZH, pulse1_duty_macro+1
00184a 9630                      	adiw Z, 0
00184b f1b1                      	breq sound_driver_channel0_fx_routines //if no duty macro is in use, go to the next routine
00184c 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00184d 1fff                      	rol ZH
00184e 91a0 282f                 	lds r26, pulse1_duty_macro_offset
001850 0fea                      	add ZL, r26
001851 1df2                      	adc ZH, zero
                                 
001852 91b0 2831                 	lds r27, pulse1_duty_macro_release
001854 17ba                      	cp r27, r26
001855 f429                      	brne sound_driver_instrument_routine_channel0_duty_increment //if the current offset is not equal to the release index, increment the offset
001856 91a0 2830                 	lds r26, pulse1_duty_macro_loop
001858 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
001859 f010                      	brlo sound_driver_instrument_routine_channel0_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00185a c027                      	rjmp sound_driver_channel0_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel0_duty_increment:
00185b 95a3                      	inc r26 //increment the macro offset
00185c 93a0 282f                 	sts pulse1_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_duty_read:
00185e 91b4                      	lpm r27, Z //load pitch data into r27
00185f 3fbf                      	cpi r27, 0xFF //check for macro end flag
001860 f471                      	brne sound_driver_instrument_routine_channel0_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_release:
001861 50a1                      	subi r26, 1 //keep the macro offset at the end flag
001862 93a0 282f                 	sts pulse1_duty_macro_offset, r26
001864 91b0 2831                 	lds r27, pulse1_duty_macro_release
001866 3fbf                      	cpi r27, 0xFF
001867 f4d1                      	brne sound_driver_channel0_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_loop:
001868 91b0 2830                 	lds r27, pulse1_duty_macro_loop //load the loop index
00186a 3fbf                      	cpi r27, 0xFF //check if there is a loop index
00186b f0b1                      	breq sound_driver_channel0_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
00186c 93b0 282f                 	sts pulse1_duty_macro_offset, r27 //store the loop index into the offset
00186e cfd7                      	rjmp sound_driver_instrument_routine_channel0_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_load:
00186f ebe2                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
001870 e3f4                      	ldi ZH, HIGH(sequences << 1)
001871 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
001872 1df2                      	adc ZH, zero
                                 
001873 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
001874 95b7                      	ror r27
001875 95b7                      	ror r27
001876 91a0 2800                 	lds r26, pulse1_param //load r26 with pulse1_param (register $4000)
001878 2fca                      	mov r28, r26 //store a copy of pulse1_param into r28
001879 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
00187a 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
00187b c001                      	rjmp sound_driver_instrument_routine_channel0_duty_load_store
00187c c005                      	rjmp sound_driver_channel0_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel0_duty_load_store:
00187d 90d4                      	lpm pulse1_sequence, Z //store the sequence
                                 
00187e 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
00187f 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
001880 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_routines:
                                 sound_driver_channel0_fx_1xx_routine:
001882 91e0 2834                 	lds ZL, pulse1_fx_1xx
001884 91f0 2835                 	lds ZH, pulse1_fx_1xx+1
001886 9630                      	adiw Z, 0
001887 f051                      	breq sound_driver_channel0_fx_2xx_routine
                                 
001888 91a0 2836                 	lds r26, pulse1_fx_1xx_total //load the rate to change the pitch by
00188a 91b0 2837                 	lds r27, pulse1_fx_1xx_total+1
00188c 0fae                      	add r26, ZL //increase the total offset by the rate
00188d 1fbf                      	adc r27, ZH
00188e 93a0 2836                 	sts pulse1_fx_1xx_total, r26
001890 93b0 2837                 	sts pulse1_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_2xx_routine:
001892 91e0 2838                 	lds ZL, pulse1_fx_2xx
001894 91f0 2839                 	lds ZH, pulse1_fx_2xx+1
001896 9630                      	adiw Z, 0
001897 f051                      	breq sound_driver_channel0_fx_3xx_routine
                                 
001898 91a0 283a                 	lds r26, pulse1_fx_2xx_total //load the rate to change the pitch by
00189a 91b0 283b                 	lds r27, pulse1_fx_2xx_total+1
00189c 0fae                      	add r26, ZL //increase the total offset by the rate
00189d 1fbf                      	adc r27, ZH
00189e 93a0 283a                 	sts pulse1_fx_2xx_total, r26
0018a0 93b0 283b                 	sts pulse1_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_3xx_routine:
0018a2 91e0 2840                 	lds ZL, pulse1_fx_3xx_speed
0018a4 91f0 2841                 	lds ZH, pulse1_fx_3xx_speed+1
0018a6 9630                      	adiw Z, 0
0018a7 f409                      	brne sound_driver_channel0_fx_3xx_routine_check_start
0018a8 c048                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_check_start:
0018a9 91a0 283c                 	lds r26, pulse1_fx_3xx_start
0018ab 91b0 283d                 	lds r27, pulse1_fx_3xx_start+1
0018ad 9610                      	adiw r26:r27, 0
0018ae f409                      	brne sound_driver_channel0_fx_3xx_routine_main
0018af c041                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_main:
0018b0 91c0 283e                 	lds r28, pulse1_fx_3xx_target
0018b2 91d0 283f                 	lds r29, pulse1_fx_3xx_target+1
                                 
0018b4 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
0018b5 07bd                      	cpc r27, r29
0018b6 f011                      	breq sound_driver_channel0_fx_3xx_routine_disable
0018b7 f030                      	brlo sound_driver_channel0_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
0018b8 c01f                      	rjmp sound_driver_channel0_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel0_fx_3xx_routine_disable:
0018b9 9220 283c                 	sts pulse1_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
0018bb 9220 283d                 	sts pulse1_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
0018bd c033                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_subtract:
0018be 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
0018bf 0bdb                      	sbc r29, r27
0018c0 91a0 2842                 	lds r26, pulse1_fx_3xx_total_offset
0018c2 91b0 2843                 	lds r27, pulse1_fx_3xx_total_offset+1
                                 
0018c4 0fae                      	add r26, ZL //add the speed to the total offset
0018c5 1fbf                      	adc r27, ZH
0018c6 1bca                      	sub r28, r26 //invert the total difference with the total offset
0018c7 0bdb                      	sbc r29, r27
0018c8 f380                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0018c9 93a0 2842                 	sts pulse1_fx_3xx_total_offset, r26 //store the new total offset
0018cb 93b0 2843                 	sts pulse1_fx_3xx_total_offset+1, r27
                                 
0018cd 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the current timer period
0018cf 91b0 0a8d                 	lds r27, TCB0_CCMPH
0018d1 1bac                      	sub r26, r28 //offset the current timer period with the total offset
0018d2 0bbd                      	sbc r27, r29
0018d3 93a0 0a8c                 	sts TCB0_CCMPL, r26
0018d5 93b0 0a8d                 	sts TCB0_CCMPH, r27
0018d7 c019                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_add:
0018d8 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
0018d9 0bbd                      	sbc r27, r29
0018da 91c0 2842                 	lds r28, pulse1_fx_3xx_total_offset
0018dc 91d0 2843                 	lds r29, pulse1_fx_3xx_total_offset+1
                                 
0018de 0fce                      	add r28, ZL //add the speed to the total offset
0018df 1fdf                      	adc r29, ZH
0018e0 1bac                      	sub r26, r28 //invert the total difference with the total offset
0018e1 0bbd                      	sbc r27, r29
0018e2 f2b0                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0018e3 93c0 2842                 	sts pulse1_fx_3xx_total_offset, r28 //store the new total offset
0018e5 93d0 2843                 	sts pulse1_fx_3xx_total_offset+1, r29
                                 
0018e7 91c0 0a8c                 	lds r28, TCB0_CCMPL //load the current timer period
0018e9 91d0 0a8d                 	lds r29, TCB0_CCMPH
0018eb 0fca                      	add r28, r26 //offset the current timer period with the total offset
0018ec 1fdb                      	adc r29, r27
0018ed 93c0 0a8c                 	sts TCB0_CCMPL, r28
0018ef 93d0 0a8d                 	sts TCB0_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel0_fx_4xy_routine:
0018f1 91a0 2844                 	lds r26, pulse1_fx_4xy_speed
0018f3 15a2                      	cp r26, zero
0018f4 f409                      	brne sound_driver_channel0_fx_4xy_routine_continue
0018f5 c05c                      	rjmp sound_driver_channel0_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel0_fx_4xy_routine_continue:
0018f6 91b0 2845                 	lds r27, pulse1_fx_4xy_depth
0018f8 91c0 2846                 	lds r28, pulse1_fx_4xy_phase
0018fa 0fca                      	add r28, r26 //increase the phase by the speed
0018fb 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
0018fc f008                      	brlo sound_driver_channel0_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
0018fd 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase:
0018fe 93c0 2846                 	sts pulse1_fx_4xy_phase, r28 //store the new phase
001900 31c0                      	cpi r28, 16
001901 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_0
001902 32c0                      	cpi r28, 32
001903 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_1
001904 33c0                      	cpi r28, 48
001905 f030                      	brlo sound_driver_channel0_fx_4xy_routine_phase_2
001906 c007                      	rjmp sound_driver_channel0_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_0:
001907 70cf                      	andi r28, 0x0F //mask for values 0-15
001908 c029                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_1:
001909 6fc0                      	ori r28, 0xF0
00190a 95c0                      	com r28 //invert values 0-15
00190b c026                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_2:
00190c 70cf                      	andi r28, 0x0F //mask for values 0-15
00190d c003                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_3:
00190e 6fc0                      	ori r28, 0xF0
00190f 95c0                      	com r28 //invert values 0-15
001910 c000                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_add:
001911 95b2                      	swap r27 //multiply depth by 16
001912 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
001913 eee2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
001914 e0f0                      	ldi ZH, HIGH(vibrato_table << 1)
001915 0fec                      	add ZL, r28 //offset the table by the depth+phase
001916 1df2                      	adc ZH, zero
001917 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
001918 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001919 937f                      	push r23
00191a 2f6c                      	mov r22, r28 //store the vibrato value into r22
00191b eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00191c 9f67                      	mul r22, r23
00191d 917f                      	pop r23
00191e 916f                      	pop r22
                                 
00191f 9416                      	lsr r1 //shift out the fractional bits
001920 9407                      	ror r0
001921 9416                      	lsr r1
001922 9407                      	ror r0
001923 9416                      	lsr r1
001924 9407                      	ror r0
001925 9416                      	lsr r1
001926 9407                      	ror r0
                                 	
001927 91a0 0a8c                 	lds r26, TCB0_CCMPL
001929 91b0 0a8d                 	lds r27, TCB0_CCMPH
00192b 0da0                      	add r26, r0
00192c 1db1                      	adc r27, r1
00192d 93a0 0a8c                 	sts TCB0_CCMPL, r26
00192f 93b0 0a8d                 	sts TCB0_CCMPH, r27
001931 c020                      	rjmp sound_driver_channel0_fx_7xy_routine
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_subtract:
001932 95b2                      	swap r27 //multiply depth by 16
001933 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
001934 eee2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
001935 e0f0                      	ldi ZH, HIGH(vibrato_table << 1)
001936 0fec                      	add ZL, r28 //offset the table by the depth+phase
001937 1df2                      	adc ZH, zero
001938 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
001939 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00193a 937f                      	push r23
00193b 2f6c                      	mov r22, r28 //store the vibrato value into r22
00193c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00193d 9f67                      	mul r22, r23
00193e 917f                      	pop r23
00193f 916f                      	pop r22
                                 
001940 9416                      	lsr r1 //shift out the fractional bits
001941 9407                      	ror r0
001942 9416                      	lsr r1
001943 9407                      	ror r0
001944 9416                      	lsr r1
001945 9407                      	ror r0
001946 9416                      	lsr r1
001947 9407                      	ror r0
                                 
001948 91a0 0a8c                 	lds r26, TCB0_CCMPL
00194a 91b0 0a8d                 	lds r27, TCB0_CCMPH
00194c 19a0                      	sub r26, r0
00194d 09b1                      	sbc r27, r1
00194e 93a0 0a8c                 	sts TCB0_CCMPL, r26
001950 93b0 0a8d                 	sts TCB0_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_7xy_routine:
001952 91a0 2847                 	lds r26, pulse1_fx_7xy_speed
001954 15a2                      	cp r26, zero
001955 f0f1                      	breq sound_driver_channel0_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
001956 91b0 2848                 	lds r27, pulse1_fx_7xy_depth
001958 91c0 2849                 	lds r28, pulse1_fx_7xy_phase
00195a 0fca                      	add r28, r26 //increase the phase by the speed
00195b 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
00195c f010                      	brlo sound_driver_channel0_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
00195d e0c0                      	ldi r28, 0x00
00195e 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase:
00195f 93c0 2849                 	sts pulse1_fx_7xy_phase, r28 //store the new phase
001961 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
001962 ffc4                      	sbrs r28, 4
001963 c001                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_0
001964 c002                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel0_fx_7xy_routine_phase_0:
001965 70cf                      	andi r28, 0x0F //mask for values 0-15
001966 c003                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase_1:
001967 6fc0                      	ori r28, 0xF0
001968 95c0                      	com r28 //invert values 0-15
001969 c000                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_load:
00196a 95b2                      	swap r27 //multiply depth by 16
00196b 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
00196c eee2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00196d e0f0                      	ldi ZH, HIGH(vibrato_table << 1)
00196e 0fec                      	add ZL, r28 //offset the table by the depth+phase
00196f 1df2                      	adc ZH, zero
001970 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
001971 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
001972 93c0 284a                 	sts pulse1_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Axy_routine:
001974 91b0 284b                 	lds r27, pulse1_fx_Axy
001976 15b2                      	cp r27, zero
001977 f0e9                      	breq sound_driver_channel0_fx_Qxy_routine //0 means that the effect is not in use
                                 	
001978 91a0 2805                 	lds r26, pulse1_fractional_volume //load fractional volume representation of the channel
00197a 91c0 2800                 	lds r28, pulse1_param //load the integer volume representation of the channel
00197c 2fda                      	mov r29, r26 //copy fractional volume into r29
00197d 2fec                      	mov r30, r28 //copy the pulse1_param into r30
00197e 95e2                      	swap r30
00197f 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
001980 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
001981 17ed                      	cp r30, r29 //compare the fractional and integer volumes
001982 f009                      	breq sound_driver_channel0_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel0_fx_Axy_routine_reload:
001983 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate:
001984 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
001985 c004                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_addition:
001986 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
001987 f428                      	brcc sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
001988 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
001989 c003                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_subtraction:
00198a 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
00198b f008                      	brcs sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
00198c e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_store:
00198d 93a0 2805                 	sts pulse1_fractional_volume, r26 //store the new fractional volume
00198f 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
001990 95a2                      	swap r26
001991 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
001992 2bca                      	or r28, r26 //store the new volume back into pulse1_param
001993 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel0_fx_Qxy_routine:
001995 91e0 284f                 	lds ZL, pulse1_fx_Qxy_target
001997 91f0 2850                 	lds ZH, pulse1_fx_Qxy_target+1
001999 9630                      	adiw Z, 0
00199a f131                      	breq sound_driver_channel0_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
00199b 91a0 2853                 	lds r26, pulse1_fx_Qxy_total_offset
00199d 91b0 2854                 	lds r27, pulse1_fx_Qxy_total_offset+1
00199f 91c0 0a8c                 	lds r28, TCB0_CCMPL
0019a1 91d0 0a8d                 	lds r29, TCB0_CCMPH
0019a3 1bca                      	sub r28, r26 //subtract the timer period by the total offset
0019a4 0bdb                      	sbc r29, r27
                                 
0019a5 17ce                      	cp r28, ZL //compare the new timer period with the target
0019a6 07df                      	cpc r29, ZH
0019a7 f010                      	brlo sound_driver_channel0_fx_Qxy_routine_end //if the target has been reached (or passed)
0019a8 f009                      	breq sound_driver_channel0_fx_Qxy_routine_end
0019a9 f468                      	brsh sound_driver_channel0_fx_Qxy_routine_add
                                 
                                 sound_driver_channel0_fx_Qxy_routine_end:
0019aa 1bec                      	sub ZL, r28 //calculate the difference to the target
0019ab 0bfd                      	sbc ZH, r29
0019ac 0fae                      	add r26, ZL //increase the total offset to the exact amount needed to reach the target
0019ad 1fbf                      	adc r27, ZH
0019ae 93a0 2853                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
0019b0 93b0 2854                 	sts pulse1_fx_Qxy_total_offset+1, r27
0019b2 9220 284f                 	sts pulse1_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
0019b4 9220 2850                 	sts pulse1_fx_Qxy_target+1, zero
0019b6 c00a                      	rjmp sound_driver_channel0_fx_Rxy_routine
                                 
                                 sound_driver_channel0_fx_Qxy_routine_add:
0019b7 91c0 2851                 	lds r28, pulse1_fx_Qxy_speed
0019b9 91d0 2852                 	lds r29, pulse1_fx_Qxy_speed+1
0019bb 0fac                      	add r26, r28 //increase the total offset by the speed
0019bc 1fbd                      	adc r27, r29
0019bd 93a0 2853                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
0019bf 93b0 2854                 	sts pulse1_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Rxy_routine:
0019c1 91e0 2855                 	lds ZL, pulse1_fx_Rxy_target
0019c3 91f0 2856                 	lds ZH, pulse1_fx_Rxy_target+1
0019c5 9630                      	adiw Z, 0
0019c6 f131                      	breq sound_driver_channel0_fx_xy_routine //if the effect is not enabled, skip the routine
                                 
0019c7 91a0 2859                 	lds r26, pulse1_fx_Rxy_total_offset
0019c9 91b0 285a                 	lds r27, pulse1_fx_Rxy_total_offset+1
0019cb 91c0 0a8c                 	lds r28, TCB0_CCMPL
0019cd 91d0 0a8d                 	lds r29, TCB0_CCMPH
0019cf 0fca                      	add r28, r26 //add the total offset to the timer period
0019d0 0fdb                      	add r29, r27
                                 
0019d1 17ce                      	cp r28, ZL //compare the new timer period with the target
0019d2 07df                      	cpc r29, ZH
0019d3 f010                      	brlo sound_driver_channel0_fx_Rxy_routine_end //if the target has been reached (or passed)
0019d4 f009                      	breq sound_driver_channel0_fx_Rxy_routine_end
0019d5 f468                      	brsh sound_driver_channel0_fx_Rxy_routine_add
                                 
                                 sound_driver_channel0_fx_Rxy_routine_end:
0019d6 1bec                      	sub ZL, r28 //calculate the difference to the target
0019d7 0bfd                      	sbc ZH, r29
0019d8 0fae                      	add r26, ZL //increase the total offset to the exact amount needed to reach the target
0019d9 1fbf                      	adc r27, ZH
0019da 93a0 2859                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
0019dc 93b0 285a                 	sts pulse1_fx_Rxy_total_offset+1, r27
0019de 9220 2855                 	sts pulse1_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
0019e0 9220 2856                 	sts pulse1_fx_Rxy_target+1, zero
0019e2 c00a                      	rjmp sound_driver_channel0_fx_xy_routine
                                 
                                 sound_driver_channel0_fx_Rxy_routine_add:
0019e3 91c0 2857                 	lds r28, pulse1_fx_Rxy_speed
0019e5 91d0 2858                 	lds r29, pulse1_fx_Rxy_speed+1
0019e7 0fac                      	add r26, r28 //increase the total offset by the speed
0019e8 1fbd                      	adc r27, r29
0019e9 93a0 2859                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
0019eb 93b0 285a                 	sts pulse1_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 sound_driver_channel0_fx_xy_routine:
                                 
                                 sound_driver_exit:
0019ed 91df                      	pop r29
0019ee 91cf                      	pop r28
0019ef c92d                      	rjmp sequence_1_3 + 3 //+3 is to skip the stack instructions since we already pushed them
                                 
                                 //PULSE 1 ROUTINES
                                 pulse1_sequence_routine:
0019f0 b7bf                      	in r27, CPU_SREG
0019f1 93bf                      	push r27
0019f2 94f8                      	cli
                                 
0019f3 0cdd                      	lsl pulse1_sequence //shifts sequence to the left
0019f4 1cd2                      	adc pulse1_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
0019f5 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
0019f6 93b0 0a86                 	sts TCB0_INTFLAGS, r27
0019f8 91bf                      	pop r27
0019f9 bfbf                      	out CPU_SREG, r27
0019fa 9518                      	reti
                                 
                                 pulse1_sweep_routine:
0019fb 2dbf                      	mov r27, pulse1_sweep
0019fc 70b7                      	andi r27, 0x07 //mask for period divider bits
0019fd f4f9                      	brne pulse1_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse1_sweep_routine_action: //if the divider is == 0, update the pulse timer period
0019fe 93df                      	push r29
0019ff 2ddf                      	mov r29, pulse1_sweep
001a00 95d2                      	swap r29
001a01 70d7                      	andi r29, 0x07 //mask for shift bits
001a02 f411                      	brne pulse1_sweep_routine_action_main //shift != 0
001a03 91df                      	pop r29
001a04 c019                      	rjmp pulse1_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse1_sweep_routine_action_main:
001a05 91a0 0a8c                 	lds r26, TCB0_CCMPL
001a07 91b0 0a8d                 	lds r27, TCB0_CCMPH
                                 pulse1_sweep_routine_action_main_loop:
001a09 95b6                      	lsr r27
001a0a 95a7                      	ror r26
001a0b 95da                      	dec r29
001a0c f7e1                      	brne pulse1_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
001a0d fef7                      	sbrs pulse1_sweep, 7 //check the negate flag
001a0e c002                      	rjmp pulse1_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
001a0f 95a0                      	com r26 //pulse1 uses one's complement if the negate flag is set
001a10 95b0                      	com r27
                                 
                                 pulse1_sweep_routine_action_main_add:
001a11 91d0 0a8c                 	lds r29, TCB0_CCMPL //perform addition to get new timer period
001a13 0fad                      	add r26, r29
001a14 91d0 0a8d                 	lds r29, TCB0_CCMPH
001a16 1fbd                      	adc r27, r29
                                 
001a17 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new LOW bits for timer
001a19 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new HIGH bits for timer
                                 
                                 	//sts pulse1_timerL, r26
                                 	//sts pulse1_timerH, r27
                                 
                                 /*	//Sweep Test
                                 	mov r29, pulse1_sweep //invert the negate bit
                                 	ldi r27, 0b10000000
                                 	eor r29, r27
                                 	ori r29, 0b01111111
                                 
                                 	lds r27, pulse1_sweep_param //reload the pulse sweep divider params
                                 	swap r27
                                 	ori r27, 0b10000000
                                 	and r27, r29
                                 	mov pulse1_sweep, r27
                                 	sbr channel_flags, 0b10000000*/
                                 	
001a1b 91df                      	pop r29
001a1c c001                      	rjmp pulse1_sweep_routine_check_reload
                                 
                                 pulse1_sweep_routine_decrement_divider:
001a1d 94fa                      	dec pulse1_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse1_sweep_routine_check_reload:
001a1e ff97                      	sbrs channel_flags, 7 //if the reload flag is set, reload the sweep divider
001a1f 9508                      	ret
                                 
                                 pulse1_sweep_reload:
001a20 90f0 2801                 	lds pulse1_sweep, pulse1_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
001a22 94f2                      	swap pulse1_sweep //bring data from high byte to low byte
001a23 779f                      	cbr channel_flags, 0b10000000 //clear reload flag
001a24 9508                      	ret
                                 
                                 pulse1_envelope_routine:
001a25 fd96                      	sbrc channel_flags, 6 //check if start flag is cleared
001a26 c010                      	rjmp pulse1_envelope_routine_clear_start
                                 
001a27 3000                      	cpi pulse1_volume_divider, 0x00 //check if the divider is 0
001a28 f011                      	breq PC+3 //if the divider == 0, check loop flag
001a29 950a                      	dec pulse1_volume_divider //if the divider != 0, decrement and return
001a2a 9508                      	ret
                                 
001a2b 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the divider == 0, reset the divider period
001a2d 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
001a2e ff95                      	sbrs channel_flags, 5 //check if the loop flag is set
001a2f c002                      	rjmp pulse1_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
001a30 e01f                      	ldi pulse1_volume_decay, 0x0F //if the loop flag is set, reset decay and return
001a31 9508                      	ret
                                 
                                 pulse1_envelope_routine_decrement_decay:
001a32 3010                      	cpi pulse1_volume_decay, 0x00 //check if the decay is 0
001a33 f409                      	brne PC+2 //if decay != 0, go decrement
001a34 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
001a35 951a                      	dec pulse1_volume_decay
001a36 9508                      	ret
                                 
                                 pulse1_envelope_routine_clear_start:
001a37 7b9f                      	cbr channel_flags, 0b01000000 //if the start flag is set, clear it
001a38 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the start flag is set, reset the divider period
001a3a 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
001a3b e01f                      	ldi pulse1_volume_decay, 0x0F //if the start flag is set, reset decay
001a3c 9508                      	ret
                                 
                                 //CONVERTERS (TABLES)
                                 //converts and loads 5 bit length to corresponding 8 bit length value into r29
                                 length_converter:
001a3d e8e6                      	ldi ZL, LOW(length << 1)
001a3e e3f4                      	ldi ZH, HIGH(length << 1)
001a3f 0fed                      	add ZL, r29
001a40 1df2                      	adc ZH, zero
001a41 91d4                      	lpm r29, Z
001a42 9508                      	ret
                                 
001a43 7f05
001a44 010a
001a45 0214
001a46 0328
001a47 0450
001a48 051e
001a49 0607
001a4a 070d
001a4b 0806
001a4c 090c
001a4d 0a18
001a4e 0b30
001a4f 0c60
001a50 0d24
001a51 0e08
001a52 0f10                      length: .db $05, $7F, $0A, $01, $14, $02, $28, $03, $50, $04, $1E, $05, $07, $06, $0D, $07, $06, $08, $0C, $09, $18, $0A, $30, $0B, $60, $0C, $24, $0D, $08, $0E, $10, $0F
                                 
                                 //loads pulse sequence into r29
                                 duty_cycle_sequences:
001a53 ebe2                      	ldi ZL, LOW(sequences << 1)
001a54 e3f4                      	ldi ZH, HIGH(sequences << 1)
001a55 0fed                      	add ZL, r29
001a56 1df2                      	adc ZH, zero
001a57 91d4                      	lpm r29, Z
001a58 9508                      	ret
                                 
                                 //pulse sequences: 12.5%, 25%, 50%, 75%
001a59 0301
001a5a fc0f                      sequences: .db 0b00000001, 0b00000011, 0b00001111, 0b11111100
                                 
                                 //list of famitracker fx: http://famitracker.com/wiki/index.php?title=Effect_list
                                 fx:
001a5b 13cc
001a5c 13d1
001a5d 13ed
001a5e 1409
001a5f 142c                      	.dw sound_driver_channel0_fx_0xy, sound_driver_channel0_fx_1xx, sound_driver_channel0_fx_2xx, sound_driver_channel0_fx_3xx, sound_driver_channel0_fx_4xy
001a60 1437
001a61 1444
001a62 1447
001a63 144a
001a64 144d                      	.dw sound_driver_channel0_fx_7xy, sound_driver_channel0_fx_Axy, sound_driver_channel0_fx_Bxx, sound_driver_channel0_fx_Cxx, sound_driver_channel0_fx_Dxx
001a65 1450
001a66 1458
001a67 145b
001a68 145e
001a69 1465                      	.dw sound_driver_channel0_fx_Exx, sound_driver_channel0_fx_Fxx, sound_driver_channel0_fx_Gxx, sound_driver_channel0_fx_Hxy, sound_driver_channel0_fx_Ixy
001a6a 146d
001a6b 146e
001a6c 146f
001a6d 1472
001a6e 14b6                      	.dw sound_driver_channel0_fx_Hxx, sound_driver_channel0_fx_Ixx, sound_driver_channel0_fx_Pxx, sound_driver_channel0_fx_Qxy, sound_driver_channel0_fx_Rxy
001a6f 14f9
001a70 14fc
001a71 1510
001a72 1511
001a73 1512                      	.dw sound_driver_channel0_fx_Sxx, sound_driver_channel0_fx_Vxx, sound_driver_channel0_fx_Wxx, sound_driver_channel0_fx_Xxx, sound_driver_channel0_fx_Yxx
001a74 1513                      	.dw sound_driver_channel0_fx_Zxx
                                 
                                 //famitracker volumes table: http://famitracker.com/wiki/index.php?title=Volume
                                 volumes:
001a75 0000
001a76 0000
001a77 0000
001a78 0000
001a79 0000
001a7a 0000
001a7b 0000
001a7c 0000                      	.db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
001a7d 0100
001a7e 0101
001a7f 0101
001a80 0101
001a81 0101
001a82 0101
001a83 0101
001a84 0101                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
001a85 0100
001a86 0101
001a87 0101
001a88 0101
001a89 0101
001a8a 0101
001a8b 0101
001a8c 0201                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02
001a8d 0100
001a8e 0101
001a8f 0101
001a90 0101
001a91 0101
001a92 0202
001a93 0202
001a94 0302                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03
001a95 0100
001a96 0101
001a97 0101
001a98 0101
001a99 0202
001a9a 0202
001a9b 0303
001a9c 0403                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04
001a9d 0100
001a9e 0101
001a9f 0101
001aa0 0202
001aa1 0302
001aa2 0303
001aa3 0404
001aa4 0504                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05
001aa5 0100
001aa6 0101
001aa7 0201
001aa8 0202
001aa9 0303
001aaa 0404
001aab 0504
001aac 0605                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x06
001aad 0100
001aae 0101
001aaf 0201
001ab0 0302
001ab1 0403
001ab2 0504
001ab3 0605
001ab4 0706                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07
001ab5 0100
001ab6 0101
001ab7 0202
001ab8 0303
001ab9 0404
001aba 0505
001abb 0606
001abc 0807                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07, 0x08
001abd 0100
001abe 0101
001abf 0302
001ac0 0403
001ac1 0504
001ac2 0606
001ac3 0707
001ac4 0908                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09
001ac5 0100
001ac6 0201
001ac7 0302
001ac8 0404
001ac9 0605
001aca 0706
001acb 0808
001acc 0a09                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A
001acd 0100
001ace 0201
001acf 0302
001ad0 0504
001ad1 0605
001ad2 0807
001ad3 0908
001ad4 0b0a                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B
001ad5 0100
001ad6 0201
001ad7 0403
001ad8 0504
001ad9 0706
001ada 0808
001adb 0a09
001adc 0c0b                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B, 0x0C
001add 0100
001ade 0201
001adf 0403
001ae0 0605
001ae1 0706
001ae2 0908
001ae3 0b0a
001ae4 0d0c                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D
001ae5 0100
001ae6 0201
001ae7 0403
001ae8 0605
001ae9 0807
001aea 0a09
001aeb 0c0b
001aec 0e0d                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E
001aed 0100
001aee 0302
001aef 0504
001af0 0706
001af1 0908
001af2 0b0a
001af3 0d0c


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega4809" register use summary:
x  :   0 y  :   0 z  :  65 r0 :  44 r1 :  46 r2 : 202 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 
r13:   6 r14:   4 r15:  13 r16:   7 r17:   6 r18:   0 r19:   0 r20:   0 
r21:   0 r22:  43 r23:  40 r24:   0 r25:  15 r26: 272 r27: 377 r28: 141 
r29: 109 r30:  96 r31:  91 
Registers used: 18 out of 35 (51.4%)

"ATmega4809" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  44 add   :  59 adiw  :  28 and   :   0 
andi  :  32 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   2 brcs  :   4 break :   0 breq  :  46 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  24 brlt  :   0 brmi  :   0 
brne  :  33 brpl  :   0 brsh  :   7 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :   0 cbr   :   2 
clc   :   0 clh   :   0 cli   :   5 cln   :   0 clr   :   3 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :   5 cp    :  24 cpc   :   3 
cpi   :  49 cpse  :   6 dec   :   7 des   :   0 eor   :   0 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   1 in    :   4 inc   :  13 
jmp   :   6 ld    :   0 ldd   :   0 ldi   :  90 lds   : 192 lpm   :  74 
lsl   :  21 lsr   :  39 mov   :  37 movw  :   0 mul   :   8 muls  :   0 
mulsu :   2 neg   :   0 nop   :   0 or    :   6 ori   :   5 out   :   7 
pop   :  34 push  :  31 rcall :  16 ret   :  13 reti  :   4 rjmp  : 134 
rol   :  15 ror   :  45 sbc   :  12 sbci  :   0 sbi   :   0 sbic  :   0 
sbis  :   0 sbiw  :   0 sbr   :   7 sbrc  :   8 sbrs  :   6 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   : 376 sub   :  16 subi  :  13 swap  :  16 tst   :   0 wdr   :   0 

Instructions used: 51 out of 114 (44.7%)

"ATmega4809" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x0035ea   4358   9416  13774   49152  28.0%
[.dseg] 0x002800 0x002861      0     97     97    6144   1.6%
[.eseg] 0x000000 0x000000      0      0      0     256   0.0%

Assembly complete, 0 errors, 105 warnings
