
AVRASM ver. 2.2.8  C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm Wed Jan 13 21:43:53 2021

C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
                                 
                                 
                                 ; NES_APU_2a03.asm
                                 ;
                                 ; Created: 11/29/2020 1:44:10 AM
                                 ; Author : Tennyson Cheng
                                 ;
                                 
                                 .list
                                 
                                 .dseg
002800                           pulse1_param: .byte 1 //$4000 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002801                           pulse1_sweep_param: .byte 1 //$4001 EPPP.NSSS = Enable, Period, Negate, Shift
                                 //NOTE: In order to account for multiplier, we use 16 instead of 11 bits for the timer
002802                           pulse1_timerL: .byte 1 //$4002 LLLL.LLLL = Low 8 bits for timer
002803                           pulse1_timerH: .byte 1 //$4002 HHHH.HHHH = High 8 bits for timer
002804                           pulse1_length: .byte 1 //$4002 000l.llll = Length counter load
002805                           pulse1_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002806                           pulse1_output_volume: .byte 1 //this is the final output volume of pulse 1
002807                           pulse1_note: .byte 1 //the current note index in the note table
                                 
002808                           song_frames: .byte 2
00280a                           song_frame_offset: .byte 2
00280c                           song_size: .byte 2
00280e                           song_speed: .byte 1
00280f                           song_fx_Bxx: .byte 1
002810                           song_fx_Cxx: .byte 1
002811                           song_fx_Dxx: .byte 1
                                 
                                 
002812                           pulse1_pattern: .byte 2
002814                           pulse1_pattern_delay: .byte 2
002816                           pulse1_pattern_offset: .byte 2
                                 
002818                           pulse1_volume_macro: .byte 2
00281a                           pulse1_volume_macro_offset: .byte 1
00281b                           pulse1_volume_macro_loop: .byte 1
00281c                           pulse1_volume_macro_release: .byte 1
                                 
00281d                           pulse1_arpeggio_macro: .byte 2
00281f                           pulse1_arpeggio_macro_offset: .byte 1
002820                           pulse1_arpeggio_macro_loop: .byte 1
002821                           pulse1_arpeggio_macro_release: .byte 1
002822                           pulse1_arpeggio_macro_mode: .byte 1
                                 
002823                           pulse1_total_pitch_offset: .byte 1 //used to reference the overall change in pitch for the pitch macro
002824                           pulse1_pitch_macro: .byte 2
002826                           pulse1_pitch_macro_offset: .byte 1
002827                           pulse1_pitch_macro_loop: .byte 1
002828                           pulse1_pitch_macro_release: .byte 1
                                 
002829                           pulse1_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00282a                           pulse1_hi_pitch_macro: .byte 2
00282c                           pulse1_hi_pitch_macro_offset: .byte 1
00282d                           pulse1_hi_pitch_macro_loop: .byte 1
00282e                           pulse1_hi_pitch_macro_release: .byte 1
                                 
00282f                           pulse1_duty_macro: .byte 2
002831                           pulse1_duty_macro_offset: .byte 1
002832                           pulse1_duty_macro_loop: .byte 1
002833                           pulse1_duty_macro_release: .byte 1
                                 
002834                           pulse1_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002836                           pulse1_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002838                           pulse1_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00283a                           pulse1_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
00283c                           pulse1_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
00283e                           pulse1_fx_3xx_start: .byte 2 //the starting note period
002840                           pulse1_fx_3xx_target: .byte 2 //target note period
002842                           pulse1_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
002844                           pulse1_fx_3xx_total_offset: .byte 2
002846                           pulse1_fx_4xy_speed: .byte 1
002847                           pulse1_fx_4xy_depth: .byte 1
002848                           pulse1_fx_4xy_phase: .byte 1
002849                           pulse1_fx_7xy_speed: .byte 1
00284a                           pulse1_fx_7xy_depth: .byte 1
00284b                           pulse1_fx_7xy_phase: .byte 1
00284c                           pulse1_fx_7xy_value: .byte 1 //value to offset the volume
00284d                           pulse1_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
00284e                           pulse1_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
00284f                           pulse1_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002850                           pulse1_fx_Pxx: .byte 1 //refers to the fine pitch offset set by the Pxx effect
002851                           pulse1_fx_Qxy_target: .byte 2 //target note period
002853                           pulse1_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002855                           pulse1_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002857                           pulse1_fx_Rxy_target: .byte 2 //target note period
002859                           pulse1_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
00285b                           pulse1_fx_Rxy_total_offset: .byte 2
00285d                           pulse1_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
00285e                           pulse1_fx_Sxx_post: .byte 1
                                 
00285f                           pulse2_pattern_delay: .byte 1
002860                           triangle_pattern_delay: .byte 1
002861                           noise_pattern_delay: .byte 1
002862                           dcpm_pattern_delay: .byte 1
                                 
                                 .cseg
                                 
                                 //NOTE: zero is defined in order to use the cp instruction without the need to load 0x00 into a register beforehand
                                 .def zero = r2
                                 .def channel_flags = r25 //[pulse1.pulse2] RSlc.0000 = Reload, Start, Length halt/Loop, Constant volume
                                 .def pulse1_sequence = r13
                                 .def pulse1_length_counter = r14
                                 .def pulse1_sweep = r15 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse1_volume_divider = r16 //0000.PPPP = Period divider
                                 .def pulse1_volume_decay = r17 //0000.dddd = Decay
                                 
                                 reset:
000000 940c 11d3                 	jmp init
                                 
                                 .org TCA0_OVF_vect
00000e 940c 1331                 	jmp sound_driver
                                 
                                 .org TCA0_CMP0_vect
000012 940c 1317                 	jmp sequence_0_2
                                 
                                 .org TCA0_CMP1_vect
000014 940c 1321                 	jmp sequence_1_3
                                 
                                 .org TCA0_CMP2_vect
000016 940c 1317                 	jmp sequence_0_2
                                 
                                 .org TCB0_INT_vect
000018 940c 1a04                 	jmp pulse1_sequence_routine
                                 
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(66): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(67): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(68): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(69): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(70): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(71): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(72): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(73): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(74): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(75): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(76): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(77): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(78): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(79): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(80): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(81): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(83): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(84): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(86): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(87): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(88): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(90): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(91): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(92): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(94): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(95): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(96): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(97): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(100): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(101): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(102): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(105): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(107): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(108): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(109): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(116): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(117): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(118): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(123): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(126): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(128): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(129): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(130): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(131): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(132): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(133): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(134): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(135): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(136): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(139): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(140): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(141): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(145): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(146): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(147): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(148): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(150): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(151): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(152): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(153): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(155): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(156): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(157): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(158): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(159): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(160): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(163): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(164): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(165): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(276): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(277): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(278): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(280): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(285): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(286): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(287): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(288): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(289): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(290): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(291): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(292): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(293): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(295): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(299): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(300): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(301): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(302): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(304): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(305): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(307): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(311): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(315): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(316): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(317): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(318): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(320): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(321): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(322): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(325): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(326): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(329): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(330): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(332): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(339): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(340): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
                                 .list
                                 
                                 init:
                                 	//MAIN CLOCK
0011d3 edb8                      	ldi r27, CPU_CCP_IOREG_gc //protected write
0011d4 93b0 0034                 	sts CPU_CCP, r27
0011d6 e0b0                      	ldi r27, 0 << CLKCTRL_PEN_bp //disable prescaler for 20 MHz on main clock
0011d7 93b0 0061                 	sts CLKCTRL_MCLKCTRLB, r27
                                 
                                 /*	//TEST FOR C4, 1 SECOND, 50% DD
                                 	ldi r26, 0x97
                                 	ldi r27, 0x12
                                 	ldi r26, 0x15
                                 	ldi r27, 0x09
                                 	sts pulse1_timerL, r26
                                 	sts pulse1_timerH, r27
                                 	ldi r27, 0b10111111
                                 	sts pulse1_param, r27
                                 	ldi r27, 0x01
                                 	sts pulse1_length, r27
                                 	//TEST FOR SWEEP UP
                                 	ldi r27, 0b11111111
                                 	sts pulse1_sweep_param, r27*/
                                 
                                 	//ZERO
0011d9 2422                      	clr zero
                                 
                                 	//MEMORY
0011da e3b0                      	ldi r27, 0b00110000
0011db 93b0 2800                 	sts pulse1_param, r27
0011dd e8b0                      	ldi r27, 0b10000000
0011de 93b0 2801                 	sts pulse1_sweep_param, r27
0011e0 efbf                      	ldi r27, 0xFF
0011e1 93b0 2802                 	sts pulse1_timerL, r27
0011e3 93b0 2803                 	sts pulse1_timerH, r27
0011e5 93b0 2804                 	sts pulse1_length, r27
                                 
0011e7 e0b2                      	ldi r27, 0x02
0011e8 93b0 280a                 	sts song_frame_offset, r27
0011ea 93b0 280b                 	sts song_frame_offset+1, r27
0011ec eee2                      	ldi ZL, LOW(song0_frames << 1)
0011ed e0f1                      	ldi ZH, HIGH(song0_frames << 1)
0011ee 93e0 2808                 	sts song_frames, ZL
0011f0 93f0 2809                 	sts song_frames+1, ZH
0011f2 91c5                      	lpm r28, Z+ //load the song size
0011f3 91d4                      	lpm r29, Z
0011f4 93c0 280c                 	sts song_size, r28
0011f6 93d0 280c                 	sts song_size, r29
0011f8 9220 280e                 	sts song_speed, zero
                                 
                                 	//CHANNEL 0 TEST
0011fa e0b0                      	ldi r27, 0x00
0011fb 0feb                      	add ZL, r27
0011fc 1df2                      	adc ZH, zero
0011fd 91a5                      	lpm r26, Z+
0011fe 91b4                      	lpm r27, Z
0011ff 0faa                      	lsl r26
001200 1fbb                      	rol r27
001201 93a0 2812                 	sts pulse1_pattern, r26
001203 93b0 2813                 	sts pulse1_pattern+1, r27
001205 e0b0                      	ldi r27, 0x00
001206 9220 2814                 	sts pulse1_pattern_delay, zero
001208 9220 2815                 	sts pulse1_pattern_delay+1, zero
00120a 9220 2816                 	sts pulse1_pattern_offset, zero
00120c 9220 2817                 	sts pulse1_pattern_offset+1, zero
                                 
                                 	//channel 0 instrument macros
00120e efbf                      	ldi r27, 0xFF
00120f 9220 281a                 	sts pulse1_volume_macro_offset, zero
001211 93b0 281b                 	sts pulse1_volume_macro_loop, r27
001213 93b0 281c                 	sts pulse1_volume_macro_release, r27
001215 9220 281f                 	sts pulse1_arpeggio_macro_offset, zero
001217 93b0 2820                 	sts pulse1_arpeggio_macro_loop, r27
001219 93b0 2821                 	sts pulse1_arpeggio_macro_release, r27
00121b 93b0 2822                 	sts pulse1_arpeggio_macro_mode, r27
00121d 9220 2826                 	sts pulse1_pitch_macro_offset, zero
00121f 93b0 2827                 	sts pulse1_pitch_macro_loop, r27
001221 93b0 2828                 	sts pulse1_pitch_macro_release, r27
001223 9220 282c                 	sts pulse1_hi_pitch_macro_offset, zero
001225 93b0 282d                 	sts pulse1_hi_pitch_macro_loop, r27
001227 93b0 282e                 	sts pulse1_hi_pitch_macro_release, r27
001229 9220 2831                 	sts pulse1_duty_macro_offset, zero
00122b 93b0 2832                 	sts pulse1_duty_macro_loop, r27
00122d 93b0 2833                 	sts pulse1_duty_macro_release, r27
                                 
00122f 9220 2818                 	sts pulse1_volume_macro, zero
001231 9220 2819                 	sts pulse1_volume_macro+1, zero
001233 9220 281d                 	sts pulse1_arpeggio_macro, zero
001235 9220 281e                 	sts pulse1_arpeggio_macro+1, zero
001237 9220 2823                 	sts pulse1_total_pitch_offset, zero
001239 9220 2824                 	sts pulse1_pitch_macro, zero
00123b 9220 2825                 	sts pulse1_pitch_macro+1, zero
00123d 9220 2829                 	sts pulse1_total_hi_pitch_offset, zero
00123f 9220 282a                 	sts pulse1_hi_pitch_macro, zero
001241 9220 282b                 	sts pulse1_hi_pitch_macro+1, zero
001243 9220 282f                 	sts pulse1_duty_macro, zero
001245 9220 2830                 	sts pulse1_duty_macro+1, zero
                                 
001247 9220 285f                 	sts pulse2_pattern_delay, zero
001249 9220 2860                 	sts triangle_pattern_delay, zero
00124b 9220 2861                 	sts noise_pattern_delay, zero
00124d 9220 2862                 	sts dcpm_pattern_delay, zero
                                 
                                 	//PINS
00124f efbf                      	ldi r27, 0xFF //set all pins in VPORTD to output
001250 b9b0                      	out VPORTA_DIR, r27
                                 
                                 	//ENVELOPE
001251 e00f                      	ldi pulse1_volume_divider, 0x0F
001252 9110 2800                 	lds pulse1_volume_decay, pulse1_param
001254 701f                      	andi pulse1_volume_decay, 0x0F //mask for VVVV bits
001255 9190 2800                 	lds channel_flags, pulse1_param
001257 7390                      	andi channel_flags, 0b00110000
001258 6490                      	sbr channel_flags, 0b01000000 //set start flag
001259 9220 2806                 	sts pulse1_output_volume, zero
00125b 93b0 2805                 	sts pulse1_fractional_volume, r27 //initialize fractional volume to max value
                                 	
                                 	//LENGTH
00125d 91d0 2804                 	lds r29, pulse1_length
00125f d7f1                      	rcall length_converter
001260 2eed                      	mov pulse1_length_counter, r29
                                 
                                 	//SEQUENCE
001261 91d0 2800                 	lds r29, pulse1_param //load param for sequence table
001263 0fdd                      	lsl r29 //shift duty cycle bits to LSB
001264 1fdd                      	rol r29
001265 1fdd                      	rol r29
001266 70d3                      	andi r29, 0b00000011 //mask duty cycle bits
001267 d7ff                      	rcall duty_cycle_sequences
001268 2edd                      	mov pulse1_sequence, r29
                                 
                                 	//SWEEP
001269 90f0 2801                 	lds pulse1_sweep, pulse1_sweep_param
00126b 94f2                      	swap pulse1_sweep //swap data from high byte and low byte
00126c 6890                      	sbr channel_flags, 0b10000000 //set reload flag
                                 
                                 	//FX
00126d efdf                      	ldi r29, 0xFF
00126e 93d0 280f                 	sts song_fx_Bxx, r29
001270 9220 2810                 	sts song_fx_Cxx, zero
001272 9220 2811                 	sts song_fx_Dxx, zero
001274 9220 2834                 	sts pulse1_fx_0xy_sequence, zero
001276 9220 2835                 	sts pulse1_fx_0xy_sequence+1, zero
001278 9220 2836                 	sts pulse1_fx_1xx, zero
00127a 9220 2837                 	sts pulse1_fx_1xx+1, zero
00127c 9220 2838                 	sts pulse1_fx_1xx_total, zero
00127e 9220 2839                 	sts pulse1_fx_1xx_total+1, zero
001280 9220 283a                 	sts pulse1_fx_2xx, zero
001282 9220 283b                 	sts pulse1_fx_2xx+1, zero
001284 9220 283c                 	sts pulse1_fx_2xx_total, zero
001286 9220 283d                 	sts pulse1_fx_2xx_total+1, zero
001288 9220 283e                 	sts pulse1_fx_3xx_start, zero
00128a 9220 283f                 	sts pulse1_fx_3xx_start+1, zero
00128c 9220 2840                 	sts pulse1_fx_3xx_target, zero
00128e 9220 2841                 	sts pulse1_fx_3xx_target+1, zero
001290 9220 2842                 	sts pulse1_fx_3xx_speed, zero
001292 9220 2843                 	sts pulse1_fx_3xx_speed+1, zero
001294 9220 2844                 	sts pulse1_fx_3xx_total_offset, zero
001296 9220 2845                 	sts pulse1_fx_3xx_total_offset+1, zero
001298 9220 2846                 	sts pulse1_fx_4xy_speed, zero
00129a 9220 2847                 	sts pulse1_fx_4xy_depth, zero
00129c 9220 2848                 	sts pulse1_fx_4xy_phase, zero
00129e 9220 2849                 	sts pulse1_fx_7xy_speed, zero
0012a0 9220 284a                 	sts pulse1_fx_7xy_depth, zero
0012a2 9220 284b                 	sts pulse1_fx_7xy_phase, zero
0012a4 9220 284c                 	sts pulse1_fx_7xy_value, zero
0012a6 9220 284d                 	sts pulse1_fx_Axy, zero
0012a8 9220 284e                 	sts pulse1_fx_Gxx_pre, zero
0012aa 9220 284f                 	sts pulse1_fx_Gxx_post, zero
0012ac 9220 2850                 	sts pulse1_fx_Pxx, zero
0012ae 9220 2851                 	sts pulse1_fx_Qxy_target, zero
0012b0 9220 2852                 	sts pulse1_fx_Qxy_target+1, zero
0012b2 9220 2853                 	sts pulse1_fx_Qxy_speed, zero
0012b4 9220 2854                 	sts pulse1_fx_Qxy_speed+1, zero
0012b6 9220 2855                 	sts pulse1_fx_Qxy_total_offset, zero
0012b8 9220 2856                 	sts pulse1_fx_Qxy_total_offset+1, zero
0012ba 9220 2857                 	sts pulse1_fx_Rxy_target, zero
0012bc 9220 2858                 	sts pulse1_fx_Rxy_target+1, zero
0012be 9220 2859                 	sts pulse1_fx_Rxy_speed, zero
0012c0 9220 285a                 	sts pulse1_fx_Rxy_speed+1, zero
0012c2 9220 285b                 	sts pulse1_fx_Rxy_total_offset, zero
0012c4 9220 285c                 	sts pulse1_fx_Rxy_total_offset+1, zero
0012c6 9220 285d                 	sts pulse1_fx_Sxx_pre, zero
0012c8 9220 285e                 	sts pulse1_fx_Sxx_post, zero
                                 
                                 	//TIMERS
                                 	//Frame Counter
                                 	//NOTE:The frame counter will be defaulted to NTSC mode (60 Hz, 120 Hz, 240 Hz)
                                 	//Each interrupt will be setup to interrupt every 240 Hz clock
                                 	//CMP0 = sequence 0, CMP1 = sequence 1, CMP2 = sequence 2, OVF = sequence 3/sound driver
                                 	//Sequence 3 will clock the sound driver every 60Hz, in which new audio data is read and written to the registers
                                 	//Timer period Calculation: (0.00416666666 * 20000000/64)-1 = 1301.08333125 = 0x0515
                                 	//The ATmega4809 is cofigured to run at 20000000 Hz
                                 	//0.00416666666 seconds is the period for 240 Hz
                                 	//The /64 comes from the prescaler divider used
0012ca e7b0                      	ldi r27, TCA_SINGLE_CMP0EN_bm | TCA_SINGLE_CMP1EN_bm | TCA_SINGLE_CMP2EN_bm | TCA_SINGLE_WGMODE_NORMAL_gc //interrupt mode
0012cb 93b0 0a01                 	sts TCA0_SINGLE_CTRLB, r27
0012cd e7b1                      	ldi r27, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP1_bm | TCA_SINGLE_CMP2_bm | TCA_SINGLE_OVF_bm //enable overflow and compare interrupts
0012ce 93b0 0a0a                 	sts TCA0_SINGLE_INTCTRL, r27
0012d0 e1b5                      	ldi r27, 0x15 //set the period for CMP0
0012d1 93b0 0a28                 	sts TCA0_SINGLE_CMP0, r27
0012d3 e0b5                      	ldi r27, 0x05
0012d4 93b0 0a29                 	sts TCA0_SINGLE_CMP0 + 1, r27
0012d6 e2bb                      	ldi r27, 0x2B //set the period for CMP1
0012d7 93b0 0a2a                 	sts TCA0_SINGLE_CMP1, r27
0012d9 e0ba                      	ldi r27, 0x0A
0012da 93b0 0a2b                 	sts TCA0_SINGLE_CMP1 + 1, r27
0012dc e4b1                      	ldi r27, 0x41 //set the period for CMP2
0012dd 93b0 0a2c                 	sts TCA0_SINGLE_CMP2, r27
0012df e0bf                      	ldi r27, 0x0F
0012e0 93b0 0a2d                 	sts TCA0_SINGLE_CMP2 + 1, r27
0012e2 e5b7                      	ldi r27, 0x57 //set the period for OVF
0012e3 93b0 0a26                 	sts TCA0_SINGLE_PER, r27
0012e5 e1b4                      	ldi r27, 0x14
0012e6 93b0 0a27                 	sts TCA0_SINGLE_PER + 1, r27
0012e8 e0bb                      	ldi r27, TCA_SINGLE_CLKSEL_DIV64_gc | TCA_SINGLE_ENABLE_bm //use prescale divider of 64 and enable timer
0012e9 93b0 0a00                 	sts TCA0_SINGLE_CTRLA, r27
                                 
                                 	//NOTE: Channel Timers are clocked (20/2)/(0.8948865) = 11.1746014718 times faster than the NES APU
                                 	//Because of this, we multiply all the NES timer values by 11.1746014718 beforehand
                                 	//Since we rotate the sequence when the timer goes from t-(t-1) to 0, instead of 0 to t like the NES, we add 1 to the NES timers before multiplying
                                 	//The ATmega4809 is configured to run at 20 MHz
                                 	//The /2 comes from the prescaler divider used
                                 	//0.8948865 MHz is the speed of the NTSC NES APU
                                 	//NOTE: This means that any offset to the pitch for the NES timers would be multiplied by 11.1746014718 aswell.
                                 	//Pulse 1
0012eb e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
0012ec 93b0 0a81                 	sts TCB0_CTRLB, r27
0012ee e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
0012ef 93b0 0a85                 	sts TCB0_INTCTRL, r27
0012f1 91b0 2802                 	lds r27, pulse1_timerL //load the LOW bits for timer
0012f3 93b0 0a8c                 	sts TCB0_CCMPL, r27
0012f5 91b0 2803                 	lds r27, pulse1_timerH //load the HIGH bits for timer
0012f7 93b0 0a8d                 	sts TCB0_CCMPH, r27
0012f9 e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
0012fa 93b0 0a80                 	sts TCB0_CTRLA, r27
0012fc 9478                      	sei //global interrupt enable
                                 
                                 pulse1:
0012fd fed0                      	sbrs pulse1_sequence, 0 //if the sequence output is zero, return
0012fe c012                      	rjmp pulse1_off
                                 
0012ff 14e2                      	cp pulse1_length_counter, zero //if length is zero, return
001300 f081                      	breq pulse1_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
                                 pulse1_check_timer_08:
001301 91c0 0a8c                 	lds r28, TCB0_CCMPL
001303 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 pulse1_check_timer_08_HIGH:
001305 30d1                      	cpi r29, 0x01 //check timer HIGH period
001306 f008                      	brlo pulse1_check_timer_08_LOW //if the timer HIGH period is $00, check the LOW period
001307 c002                      	rjmp pulse1_check_timer_7FF_HIGH //if the timer HIGH period is > $01, check > $07FF condition
                                 pulse1_check_timer_08_LOW:
001308 35c9                      	cpi r28, 0x59 //check timer LOW period
001309 f038                      	brlo pulse1_off //if the HIGH period == $00 && LOW period <= $59, pulse off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $5965
                                 pulse1_check_timer_7FF_HIGH:
00130a 35d9                      	cpi r29, 0x59 //check timer HIGH period
00130b f038                      	brlo pulse1_on //if the HIGH period is < $59, then all conditions have passed and pulse is not muted
00130c f009                      	breq pulse1_check_timer_7FF_LOW //if the HIGH period is == $59, we go check if the LOW period is < $65
00130d c003                      	rjmp pulse1_off //pulse off if HIGH period is > $59
                                 pulse1_check_timer_7FF_LOW:
00130e 36c5                      	cpi r28, 0x65 //check timer LOW period
00130f f408                      	brsh pulse1_off //if the HIGH period == $59 && LOW period >= $65, pulse off
001310 c002                      	rjmp pulse1_on //if the HIGH period == $59 && LOW period < $65, pulse on
                                 
                                 pulse1_off:
001311 b821                      	out VPORTA_OUT, zero
001312 cfea                      	rjmp pulse1
                                 
                                 pulse1_on:
001313 91d0 2806                 	lds r29, pulse1_output_volume
                                 /*	cpse r29, zero
                                 	rjmp pulse1_off //if VVVV bits are 0, then there is no volume (channel off)*/
                                 
001315 b9d1                      	out VPORTA_OUT, r29
001316 cfe6                      	rjmp pulse1
                                 
                                 //FRAME COUNTER/AUDIO SAMPLE ISR
                                 sequence_0_2:
001317 b7bf                      	in r27, CPU_SREG
001318 93bf                      	push r27
001319 94f8                      	cli
                                 
                                 	//ENVELOPE
00131a d71e                      	rcall pulse1_envelope_routine
                                 
00131b e5b0                      	ldi r27, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP2_bm //clear OVF flag
00131c 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
00131e 91bf                      	pop r27
00131f bfbf                      	out CPU_SREG, r27
001320 9518                      	reti
                                 
                                 sequence_1_3:
001321 b7bf                      	in r27, CPU_SREG
001322 93bf                      	push r27
001323 94f8                      	cli
                                 
                                 	//ENVELOPE
001324 d714                      	rcall pulse1_envelope_routine
                                 
                                 	//SWEEP
001325 fcf3                      	sbrc pulse1_sweep, 3 //check if the sweep enable bit is cleared
001326 d6e8                      	rcall pulse1_sweep_routine
                                 
                                 	//LENGTH
                                 	//NOTE: The length routine is relatively simple, so we will not be using clocks to rjmp and ret to a seperate lable
001327 fd95                      	sbrc channel_flags, 5 //check if the length counter halt bit is cleared
001328 c002                      	rjmp sequence_1_3_exit
001329 10e2                      	cpse pulse1_length_counter, zero //if length counter is already 0, don't decrement
00132a 94ea                      	dec pulse1_length_counter
                                 
                                 sequence_1_3_exit:
00132b e2b1                      	ldi r27, TCA_SINGLE_CMP1_bm | TCA_SINGLE_OVF_bm //clear OVF flag
00132c 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
00132e 91bf                      	pop r27
00132f bfbf                      	out CPU_SREG, r27
001330 9518                      	reti
                                 
                                 sound_driver:
001331 b7bf                      	in r27, CPU_SREG
001332 93bf                      	push r27
001333 94f8                      	cli
001334 93cf                      	push r28
001335 93df                      	push r29
                                 
                                 	//SOUND DRIVER
001336 91a0 280a                 	lds r26, song_frame_offset
001338 91b0 280b                 	lds r27, song_frame_offset+1
00133a 91c0 280c                 	lds r28, song_size
00133c 91d0 280d                 	lds r29, song_size+1
00133e 17ac                      	cp r26, r28
00133f 07bd                      	cpc r27, r29
001340 f468                      	brsh sound_driver_fx_song_loop
                                 
001341 91a0 280f                 	lds r26, song_fx_Bxx
001343 3faf                      	cpi r26, 0xFF //0xFF means that the flag is disabled
001344 f451                      	brne sound_driver_fx_Bxx_routine
001345 91a0 2810                 	lds r26, song_fx_Cxx
001347 11a2                      	cpse r26, zero
001348 c030                      	rjmp sound_driver_fx_Cxx_routine
001349 91a0 2811                 	lds r26, song_fx_Dxx
00134b 11a2                      	cpse r26, zero
00134c c03b                      	rjmp sound_driver_fx_Dxx_routine
00134d c061                      	rjmp sound_driver_channel0
                                 
                                 
                                 sound_driver_fx_song_loop:
00134e e0a0                      	ldi r26, 0x00
                                 sound_driver_fx_Bxx_routine:
00134f 91e0 2808                 	lds ZL, song_frames
001351 91f0 2809                 	lds ZH, song_frames+1
001353 27cc                      	clr r28 //initialize r29:r28 to 0
001354 27dd                      	clr r29
001355 95a3                      	inc r26 //increment xx parameter by 1
                                 sound_driver_fx_Bxx_routine_loop:
001356 95aa                      	dec r26
001357 f011                      	breq sound_driver_fx_Bxx_routine_loop_exit //once r26 == 0, r29:r28 will hold Bxx*(5*2).
001358 962a                      	adiw r29:r28, 10 //increment the offset by 10 because 5 channels, and each address takes 2 bytes (5*2 = 10)
001359 cffc                      	rjmp sound_driver_fx_Bxx_routine_loop
                                 
                                 sound_driver_fx_Bxx_routine_loop_exit:
00135a 9622                      	adiw r29:r28, 2 //add 2 to skip the first 2 bytes (first 2 bytes is the song size)
00135b 93c0 280a                 	sts song_frame_offset, r28
00135d 93d0 280b                 	sts song_frame_offset+1, r29
00135f 0fec                      	add ZL, r28
001360 1ffd                      	adc ZH, r29
                                 
001361 91a5                      	lpm r26, Z+ //load the address of the frame(pattern)
001362 91b4                      	lpm r27, Z
001363 0faa                      	lsl r26
001364 1fbb                      	rol r27
001365 93a0 2812                 	sts pulse1_pattern, r26
001367 93b0 2813                 	sts pulse1_pattern+1, r27
                                 
001369 9220 2816                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
00136b 9220 2817                 	sts pulse1_pattern_offset+1, zero
00136d 9220 2814                 	sts pulse1_pattern_delay, zero //reset the delay to 0 as well
00136f 9220 2815                 	sts pulse1_pattern_delay+1, zero
                                 
001371 efaf                      	ldi r26, 0xFF
001372 93a0 280f                 	sts song_fx_Bxx, r26 //reset all song effects
001374 9220 2810                 	sts song_fx_Cxx, zero
001376 9220 2811                 	sts song_fx_Dxx, zero
001378 c036                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_fx_Cxx_routine:
001379 91df                      	pop r29
00137a 91cf                      	pop r28
00137b 91bf                      	pop r27
00137c bfbf                      	out CPU_SREG, r27
00137d 94f8                      	cli //disable global interrupts
                                 		
00137e efaf                      	ldi r26, 0xFF
00137f 93a0 280f                 	sts song_fx_Bxx, r26 //reset all song effects
001381 9220 2810                 	sts song_fx_Cxx, zero
001383 9220 2811                 	sts song_fx_Dxx, zero
                                 
001385 9220 2806                 	sts pulse1_output_volume, zero //mute all channels
001387 9518                      	reti
                                 
                                 sound_driver_fx_Dxx_routine:
001388 91e0 2808                 	lds ZL, song_frames
00138a 91f0 2809                 	lds ZH, song_frames+1
00138c 91a0 280a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
00138e 91b0 280b                 	lds r27, song_frame_offset+1
001390 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
001391 93a0 280a                 	sts song_frame_offset, r26
001393 93b0 280b                 	sts song_frame_offset+1, r27
001395 0fea                      	add ZL, r26
001396 1ffb                      	adc ZH, r27
                                 
001397 91a5                      	lpm r26, Z+ //load the address of the next pattern
001398 91b4                      	lpm r27, Z
001399 0faa                      	lsl r26
00139a 1fbb                      	rol r27
00139b 93a0 2812                 	sts pulse1_pattern, r26
00139d 93b0 2813                 	sts pulse1_pattern+1, r27
                                 
00139f 9220 2816                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
0013a1 9220 2817                 	sts pulse1_pattern_offset+1, zero
0013a3 9220 2814                 	sts pulse1_pattern_delay, zero //reset the delay to 0 as well
0013a5 9220 2815                 	sts pulse1_pattern_delay+1, zero
                                 
0013a7 efaf                      	ldi r26, 0xFF
0013a8 93a0 280f                 	sts song_fx_Bxx, r26 //reset all song effects
0013aa 9220 2810                 	sts song_fx_Cxx, zero
0013ac 9220 2811                 	sts song_fx_Dxx, zero
0013ae c000                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0:
0013af 91a0 2814                 	lds r26, pulse1_pattern_delay
0013b1 91b0 2815                 	lds r27, pulse1_pattern_delay+1
0013b3 9610                      	adiw r27:r26, 0
0013b4 f009                      	breq sound_driver_channel0_main //if the pattern delay is 0, proceed with sound driver procedures
0013b5 c2fd                      	rjmp sound_driver_channel0_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel0_main:
0013b6 91e0 2812                 	lds ZL, pulse1_pattern //current pattern for pulse 1
0013b8 91f0 2813                 	lds ZH, pulse1_pattern+1
0013ba 91a0 2816                 	lds r26, pulse1_pattern_offset //current offset in the pattern for pulse 1
0013bc 91b0 2817                 	lds r27, pulse1_pattern_offset+1
0013be 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
0013bf 1ffb                      	adc ZH, r27
0013c0 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel0_check_if_note: //check if data is a note (0x00 - 0x56)
0013c1 35b7                      	cpi r27, 0x57
0013c2 f408                      	brsh sound_driver_channel0_check_if_volume
0013c3 c164                      	rjmp sound_driver_channel0_note
                                 sound_driver_channel0_check_if_volume: //check if data is volume (0x57-0x66)
0013c4 36b7                      	cpi r27, 0x67
0013c5 f408                      	brsh sound_driver_channel0_check_if_delay
0013c6 c19c                      	rjmp sound_driver_channel0_volume
                                 sound_driver_channel0_check_if_delay: //check if data is a delay (0x67 - 0xE2)
0013c7 3eb3                      	cpi r27, 0xE3
0013c8 f408                      	brsh sound_driver_channel0_check_if_instrument
0013c9 c1a3                      	rjmp sound_driver_channel0_delay
                                 sound_driver_channel0_check_if_instrument: //check for instrument flag (0xE3)
0013ca f409                      	brne sound_driver_channel0_check_if_release
0013cb c1a6                      	rjmp sound_driver_channel0_instrument_change 
                                 sound_driver_channel0_check_if_release: //check for note release flag (0xE4)
0013cc 3eb4                      	cpi r27, 0xE4
0013cd f409                      	brne sound_driver_channel0_check_if_end
0013ce c24d                      	rjmp sound_driver_channel0_release
                                 sound_driver_channel0_check_if_end:
0013cf 3fbf                      	cpi r27, 0xFF
0013d0 f409                      	brne sound_driver_channel0_check_if_fx
0013d1 c26f                      	rjmp sound_driver_channel0_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel0_check_if_fx: //fx flags (0xE5 - 0xFE)
0013d2 9631                      	adiw Z, 1 //point Z to the byte next to the flag
0013d3 91a4                      	lpm r26, Z //load the fx data into r26
0013d4 d292                      	rcall sound_driver_channel0_increment_offset_twice
                                 
0013d5 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
0013d6 edee                      	ldi ZL, LOW(fx << 1) //load in note table
0013d7 e3f4                      	ldi ZH, HIGH(fx << 1)
0013d8 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
0013d9 0feb                      	add ZL, r27 //add offset
0013da 1df2                      	adc ZH, zero
0013db 91c5                      	lpm r28, Z+ //load address bytes
0013dc 91d4                      	lpm r29, Z
0013dd 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
0013de 2ffd                      	mov ZH, r29
0013df 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel0_fx_0xy:
0013e0 93a0 2834                 	sts pulse1_fx_0xy_sequence, r26
0013e2 9220 2835                 	sts pulse1_fx_0xy_sequence+1, zero
0013e4 cfd1                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel0_fx_1xx:
0013e5 9220 283a                 	sts pulse1_fx_2xx, zero //turn off any 2xx pitch slide down
0013e7 9220 283b                 	sts pulse1_fx_2xx+1, zero
0013e9 9220 2834                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
0013eb 9220 2835                 	sts pulse1_fx_0xy_sequence+1, zero
0013ed 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0013ee 937f                      	push r23
0013ef 2f6a                      	mov r22, r26 //store the rate into r22
0013f0 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0013f1 9f67                      	mul r22, r23
0013f2 917f                      	pop r23
0013f3 916f                      	pop r22
                                 
0013f4 9416                      	lsr r1 //shift out the fractional bits
0013f5 9407                      	ror r0
0013f6 9416                      	lsr r1
0013f7 9407                      	ror r0
0013f8 9416                      	lsr r1
0013f9 9407                      	ror r0
0013fa 9416                      	lsr r1
0013fb 9407                      	ror r0
0013fc 9200 2836                 	sts pulse1_fx_1xx, r0
0013fe 9210 2837                 	sts pulse1_fx_1xx+1, r1
001400 cfb5                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel0_fx_2xx:
001401 9220 2836                 	sts pulse1_fx_1xx, zero //turn off any 1xx pitch slide down
001403 9220 2837                 	sts pulse1_fx_1xx+1, zero
001405 9220 2834                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
001407 9220 2835                 	sts pulse1_fx_0xy_sequence+1, zero
001409 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00140a 937f                      	push r23
00140b 2f6a                      	mov r22, r26 //store the rate into r22
00140c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00140d 9f67                      	mul r22, r23
00140e 917f                      	pop r23
00140f 916f                      	pop r22
                                 
001410 9416                      	lsr r1 //shift out the fractional bits
001411 9407                      	ror r0
001412 9416                      	lsr r1
001413 9407                      	ror r0
001414 9416                      	lsr r1
001415 9407                      	ror r0
001416 9416                      	lsr r1
001417 9407                      	ror r0
001418 9200 283a                 	sts pulse1_fx_2xx, r0
00141a 9210 283b                 	sts pulse1_fx_2xx+1, r1
00141c cf99                      	rjmp sound_driver_channel0_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel0_fx_3xx:
00141d 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00141e 937f                      	push r23
00141f 2f6a                      	mov r22, r26 //store the rate into r22
001420 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001421 9f67                      	mul r22, r23
001422 917f                      	pop r23
001423 916f                      	pop r22
                                 
001424 9416                      	lsr r1 //shift out the fractional bits
001425 9407                      	ror r0
001426 9416                      	lsr r1
001427 9407                      	ror r0
001428 9416                      	lsr r1
001429 9407                      	ror r0
00142a 9416                      	lsr r1
00142b 9407                      	ror r0
00142c 9200 2842                 	sts pulse1_fx_3xx_speed, r0
00142e 9210 2843                 	sts pulse1_fx_3xx_speed+1, r1
                                 
001430 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001431 c001                      	rjmp sound_driver_channel0_fx_3xx_enabled
001432 cf83                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_3xx_enabled:
001433 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001435 91b0 0a8d                 	lds r27, TCB0_CCMPH
001437 93a0 283e                 	sts pulse1_fx_3xx_start, r26
001439 93b0 283f                 	sts pulse1_fx_3xx_start+1, r27
                                 
00143b 9220 2844                 	sts pulse1_fx_3xx_total_offset, zero
00143d 9220 2845                 	sts pulse1_fx_3xx_total_offset+1, zero
00143f cf76                      	rjmp sound_driver_channel0_main
                                 
                                 //VIBRATO
                                 sound_driver_channel0_fx_4xy:
001440 2fba                      	mov r27, r26
001441 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001442 95a2                      	swap r26
001443 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001444 93a0 2846                 	sts pulse1_fx_4xy_speed, r26
001446 93b0 2847                 	sts pulse1_fx_4xy_depth, r27
001448 9220 2848                 	sts pulse1_fx_4xy_phase, zero //reset the phase to 0
00144a cf6b                      	rjmp sound_driver_channel0_main
                                 
                                 //TREMELO
                                 sound_driver_channel0_fx_7xy:
00144b 2fba                      	mov r27, r26
00144c 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
00144d 95a2                      	swap r26
00144e 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
00144f 93a0 2849                 	sts pulse1_fx_7xy_speed, r26
001451 93b0 284a                 	sts pulse1_fx_7xy_depth, r27
001453 9220 284b                 	sts pulse1_fx_7xy_phase, zero //reset the phase to 0
001455 9220 284c                 	sts pulse1_fx_7xy_value, zero //reset the tremelo value
001457 cf5e                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel0_fx_Axy:
001458 93a0 284d                 	sts pulse1_fx_Axy, r26
00145a cf5b                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel0_fx_Bxx:
00145b 93a0 280f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
00145d cf58                      	rjmp sound_driver_channel0_main
                                 
                                 //HALT
                                 sound_driver_channel0_fx_Cxx:
00145e 93b0 2810                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001460 cf55                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel0_fx_Dxx:
001461 93b0 2811                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001463 cf52                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME
                                 sound_driver_channel0_fx_Exx:
001464 91b0 2800                 	lds r27, pulse1_param
001466 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
001467 2bba                      	or r27, r26 //move new VVVV bits into pulse1_param
001468 93b0 2800                 	sts pulse1_param, r27
00146a 6096                      	sbr channel_flags, 6
00146b cf4a                      	rjmp sound_driver_channel0_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel0_fx_Fxx:
00146c 93a0 280e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
00146e cf47                      	rjmp sound_driver_channel0_main
                                 
                                 //DELAY
                                 sound_driver_channel0_fx_Gxx:
00146f 93a0 284e                 	sts pulse1_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001471 cf44                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_Hxy: //hardware sweep up
001472 95a2                      	swap r26
001473 68a8                      	ori r26, 0b10001000 //enable negate and enable sweep flag
001474 2efa                      	mov pulse1_sweep, r26
001475 92f0 2801                 	sts pulse1_sweep_param, pulse1_sweep
001477 6097                      	sbr channel_flags, 7 //set reload flag
001478 cf3d                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_Ixy: //hardware sweep down
001479 95a2                      	swap r26
00147a 77af                      	andi r26, 0b01111111 //disable negate flag
00147b 60a8                      	ori r26, 0b00001000 //enable sweep flag
00147c 2efa                      	mov pulse1_sweep, r26
00147d 92f0 2801                 	sts pulse1_sweep_param, pulse1_sweep
00147f 6097                      	sbr channel_flags, 7 //set reload flag
001480 cf35                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_Hxx: //FDS modulation depth
001481 cf34                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixx: //FDS modulation speed
001482 cf33                      	rjmp sound_driver_channel0_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel0_fx_Pxx:
001483 93a0 2850                 	sts pulse1_fx_Pxx, r26
001485 cf30                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel0_fx_Qxy:
                                 sound_driver_channel0_fx_Qxy_check_arpeggio_macro:
001486 91e0 281d                 	lds ZL, pulse1_arpeggio_macro
001488 91f0 281e                 	lds ZH, pulse1_arpeggio_macro+1
00148a 9630                      	adiw Z, 0
00148b f009                      	breq sound_driver_channel0_fx_Qxy_check_pitch_macro
00148c cf29                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_pitch_macro:
00148d 91e0 2824                 	lds ZL, pulse1_pitch_macro
00148f 91f0 2825                 	lds ZH, pulse1_pitch_macro+1
001491 9630                      	adiw Z, 0
001492 f009                      	breq sound_driver_channel0_fx_Qxy_check_hi_pitch_macro
001493 cf22                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_hi_pitch_macro:
001494 91e0 282a                 	lds ZL, pulse1_hi_pitch_macro
001496 91f0 282b                 	lds ZH, pulse1_hi_pitch_macro+1
001498 9630                      	adiw Z, 0
001499 f009                      	breq sound_driver_channel0_fx_Qxy_process
00149a cf1b                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_process:
00149b 2fba                      	mov r27, r26 //copy fx parameters into r27
00149c 70bf                      	andi r27, 0x0F //mask note index offset
00149d 91c0 2807                 	lds r28, pulse1_note //load current note index
00149f 0fbc                      	add r27, r28
0014a0 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
0014a1 f008                      	brlo sound_driver_channel0_fx_Qxy_process_continue
0014a2 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel0_fx_Qxy_process_continue:
0014a3 e3e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0014a4 e0f0                      	ldi ZH, HIGH(note_table << 1)
0014a5 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
0014a6 0feb                      	add ZL, r27 //add offset
0014a7 1df2                      	adc ZH, zero
0014a8 91c5                      	lpm r28, Z+ //load bytes
0014a9 91d4                      	lpm r29, Z
0014aa 93c0 2851                 	sts pulse1_fx_Qxy_target, r28 //load the LOW bits for the target period
0014ac 93d0 2852                 	sts pulse1_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
0014ae 95a2                      	swap r26
0014af 70af                      	andi r26, 0x0F //mask effect speed
0014b0 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0014b1 95a3                      	inc r26 //increment the speed by 1
                                 
0014b2 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0014b3 937f                      	push r23
0014b4 2f6a                      	mov r22, r26 //store the speed data into r27
0014b5 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0014b6 9f67                      	mul r22, r23
0014b7 917f                      	pop r23
0014b8 916f                      	pop r22
                                 
0014b9 9416                      	lsr r1 //shift out the fractional bits
0014ba 9407                      	ror r0
0014bb 9416                      	lsr r1
0014bc 9407                      	ror r0
0014bd 9416                      	lsr r1
0014be 9407                      	ror r0
0014bf 9416                      	lsr r1
0014c0 9407                      	ror r0
                                 
0014c1 9200 2853                 	sts pulse1_fx_Qxy_speed, r0 //store the effect speed
0014c3 9210 2854                 	sts pulse1_fx_Qxy_speed+1, r1
0014c5 9220 2855                 	sts pulse1_fx_Qxy_total_offset, zero
0014c7 9220 2856                 	sts pulse1_fx_Qxy_total_offset+1, zero
0014c9 ceec                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel0_fx_Rxy:
                                 sound_driver_channel0_fx_Rxy_check_arpeggio_macro:
0014ca 91e0 281d                 	lds ZL, pulse1_arpeggio_macro
0014cc 91f0 281e                 	lds ZH, pulse1_arpeggio_macro+1
0014ce 9630                      	adiw Z, 0
0014cf f009                      	breq sound_driver_channel0_fx_Rxy_check_pitch_macro
0014d0 cee5                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_pitch_macro:
0014d1 91e0 2824                 	lds ZL, pulse1_pitch_macro
0014d3 91f0 2825                 	lds ZH, pulse1_pitch_macro+1
0014d5 9630                      	adiw Z, 0
0014d6 f009                      	breq sound_driver_channel0_fx_Rxy_check_hi_pitch_macro
0014d7 cede                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_hi_pitch_macro:
0014d8 91e0 282a                 	lds ZL, pulse1_hi_pitch_macro
0014da 91f0 282b                 	lds ZH, pulse1_hi_pitch_macro+1
0014dc 9630                      	adiw Z, 0
0014dd f009                      	breq sound_driver_channel0_fx_Rxy_process
0014de ced7                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_process:
0014df 2fba                      	mov r27, r26 //copy fx parameters into r27
0014e0 70bf                      	andi r27, 0x0F //mask note index offset
0014e1 91c0 2807                 	lds r28, pulse1_note //load current note index
0014e3 1bcb                      	sub r28, r27
0014e4 f408                      	brcc sound_driver_channel0_fx_Rxy_process_continue
0014e5 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel0_fx_Rxy_process_continue:
0014e6 e3e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0014e7 e0f0                      	ldi ZH, HIGH(note_table << 1)
0014e8 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
0014e9 0fec                      	add ZL, r28 //add offset
0014ea 1df2                      	adc ZH, zero
0014eb 91c5                      	lpm r28, Z+ //load bytes
0014ec 91d4                      	lpm r29, Z
0014ed 93c0 2857                 	sts pulse1_fx_Rxy_target, r28 //load the LOW bits for the target period
0014ef 93d0 2858                 	sts pulse1_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
0014f1 95a2                      	swap r26
0014f2 70af                      	andi r26, 0x0F //mask effect speed
0014f3 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0014f4 95a3                      	inc r26 //increment the speed by 1
                                 
0014f5 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0014f6 937f                      	push r23
0014f7 2f6a                      	mov r22, r26 //store the speed data into r27
0014f8 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0014f9 9f67                      	mul r22, r23
0014fa 917f                      	pop r23
0014fb 916f                      	pop r22
                                 
0014fc 9416                      	lsr r1 //shift out the fractional bits
0014fd 9407                      	ror r0
0014fe 9416                      	lsr r1
0014ff 9407                      	ror r0
001500 9416                      	lsr r1
001501 9407                      	ror r0
001502 9416                      	lsr r1
001503 9407                      	ror r0
                                 
001504 9200 2859                 	sts pulse1_fx_Rxy_speed, r0 //store the effect speed
001506 9210 285a                 	sts pulse1_fx_Rxy_speed+1, r1
001508 9220 285b                 	sts pulse1_fx_Rxy_total_offset, zero
00150a 9220 285c                 	sts pulse1_fx_Rxy_total_offset+1, zero
00150c cea9                      	rjmp sound_driver_channel0_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel0_fx_Sxx:
00150d 93a0 285d                 	sts pulse1_fx_Sxx_pre, r26
00150f cea6                      	rjmp sound_driver_channel0_main
                                 
                                 //DUTY
                                 sound_driver_channel0_fx_Vxx:
001510 edea                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
001511 e3f4                      	ldi ZH, HIGH(sequences << 1)
001512 0fea                      	add ZL, r26 //offset the pointer
001513 1df2                      	adc ZH, zero
                                 
001514 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
001515 95a7                      	ror r26
001516 95a7                      	ror r26
001517 91b0 2800                 	lds r27, pulse1_param //load r27 with pulse1_param (register $4000)
001519 2fcb                      	mov r28, r27 //store a copy of pulse1_param into r28
00151a 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
00151b 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
00151c c001                      	rjmp sound_driver_channel0_fx_Vxx_store
00151d ce98                      	rjmp sound_driver_channel0_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel0_fx_Vxx_store:
00151e 90d4                      	lpm pulse1_sequence, Z //store the sequence
                                 
00151f 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
001520 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
001521 93c0 2800                 	sts pulse1_param, r28
001523 ce92                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_Wxx: //DPCM sample speed
001524 ce91                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Xxx: //DPCM sample retrigger
001525 ce90                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Yxx: //DPCM sample offset
001526 ce8f                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Zxx: //DPCM sample delta counter
001527 ce8e                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 sound_driver_channel0_note:
001528 93b0 2807                 	sts pulse1_note, r27 //store the note index
00152a e0a3                      	ldi r26, 0x03
00152b e0b2                      	ldi r27, 0x02
00152c 93b0 281a                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
00152e 93a0 281f                 	sts pulse1_arpeggio_macro_offset, r26
001530 93b0 2826                 	sts pulse1_pitch_macro_offset, r27
001532 93b0 282c                 	sts pulse1_hi_pitch_macro_offset, r27
001534 93b0 2831                 	sts pulse1_duty_macro_offset, r27
001536 9220 2823                 	sts pulse1_total_pitch_offset, zero //reset the pitch and hi pitch offset
001538 9220 2829                 	sts pulse1_total_hi_pitch_offset, zero
00153a 9220 2838                 	sts pulse1_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
00153c 9220 2839                 	sts pulse1_fx_1xx_total+1, zero
00153e 9220 283c                 	sts pulse1_fx_2xx_total, zero
001540 9220 283d                 	sts pulse1_fx_2xx_total+1, zero
001542 9220 2844                 	sts pulse1_fx_3xx_total_offset, zero //reset 3xx offset
001544 9220 2845                 	sts pulse1_fx_3xx_total_offset+1, zero
001546 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001548 91b0 0a8d                 	lds r27, TCB0_CCMPH
00154a 93a0 283e                 	sts pulse1_fx_3xx_start, r26
00154c 93b0 283f                 	sts pulse1_fx_3xx_start+1, r27
00154e 9220 2801                 	sts pulse1_sweep_param, zero //reset any sweep effect
001550 6097                      	sbr channel_flags, 7 //set reload flag
001551 9220 2851                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001553 9220 2852                 	sts pulse1_fx_Qxy_target+1, zero
001555 9220 2855                 	sts pulse1_fx_Qxy_total_offset, zero
001557 9220 2856                 	sts pulse1_fx_Qxy_total_offset+1, zero
001559 9220 2857                 	sts pulse1_fx_Rxy_target, zero
00155b 9220 2858                 	sts pulse1_fx_Rxy_target+1, zero
00155d 9220 285b                 	sts pulse1_fx_Rxy_total_offset, zero
00155f 9220 285c                 	sts pulse1_fx_Rxy_total_offset+1, zero
001561 d0fb                      	rcall sound_driver_channel0_increment_offset
001562 ce53                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_volume:
001563 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001564 91a0 2800                 	lds r26, pulse1_param
001566 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001567 2bab                      	or r26, r27 //move new VVVV bits into pulse1_param
001568 93a0 2800                 	sts pulse1_param, r26
00156a 6096                      	sbr channel_flags, 6
00156b d0f1                      	rcall sound_driver_channel0_increment_offset
00156c ce49                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_delay:
00156d 56b7                      	subi r27, 0x67 //NOTE: the delay values are offset by the highest volume value, which is 0x66
00156e 93b0 2814                 	sts pulse1_pattern_delay, r27
001570 d0ec                      	rcall sound_driver_channel0_increment_offset
001571 c0ff                      	rjmp sound_driver_calculate_delays
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change:
001572 9220 2818                 	sts pulse1_volume_macro, zero //reset all macro addresses
001574 9220 2819                 	sts pulse1_volume_macro+1, zero
001576 9220 281d                 	sts pulse1_arpeggio_macro, zero
001578 9220 281e                 	sts pulse1_arpeggio_macro+1, zero
00157a 9220 2824                 	sts pulse1_pitch_macro, zero
00157c 9220 2825                 	sts pulse1_pitch_macro+1, zero
00157e 9220 282a                 	sts pulse1_hi_pitch_macro, zero
001580 9220 282b                 	sts pulse1_hi_pitch_macro+1, zero
001582 9220 282f                 	sts pulse1_duty_macro, zero
001584 9220 2830                 	sts pulse1_duty_macro+1, zero
001586 9220 2823                 	sts pulse1_total_pitch_offset, zero //reset the pitch offset
001588 9220 2829                 	sts pulse1_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
00158a 9631                      	adiw Z, 1 //point to the byte next to the flag
00158b 91b4                      	lpm r27, Z //store the instrument offset into r27
00158c ebe3                      	ldi ZL, LOW(instruments) //point Z to instruments table
00158d e0ff                      	ldi ZH, HIGH(instruments)
00158e 0feb                      	add ZL, r27 //point Z to offsetted instrument
00158f 1df2                      	adc ZH, zero
001590 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001591 1fff                      	rol ZH
001592 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001593 91b4                      	lpm r27, Z
                                 
001594 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001595 1fbb                      	rol r27
001596 2fea                      	mov ZL, r26
001597 2ffb                      	mov ZH, r27
001598 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001599 9632                      	adiw Z, 2 //point Z to the address of the macro
00159a e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel0_instrument_change_macro_loop:
00159b 95aa                      	dec r26
00159c f019                      	breq sound_driver_channel0_instrument_change_exit
00159d 95b6                      	lsr r27
00159e f078                      	brcs sound_driver_channel0_instrument_change_load_macro
00159f cffb                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_exit:
0015a0 e0a3                      	ldi r26, 0x03
0015a1 e0b2                      	ldi r27, 0x02
0015a2 93b0 281a                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
0015a4 93a0 281f                 	sts pulse1_arpeggio_macro_offset, r26
0015a6 93b0 2826                 	sts pulse1_pitch_macro_offset, r27
0015a8 93b0 282c                 	sts pulse1_hi_pitch_macro_offset, r27
0015aa 93b0 2831                 	sts pulse1_duty_macro_offset, r27
0015ac d0ba                      	rcall sound_driver_channel0_increment_offset_twice
0015ad ce08                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_load_macro:
0015ae 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
0015af 91d5                      	lpm r29, Z+
                                 
0015b0 30a5                      	cpi r26, 5
0015b1 f039                      	breq sound_driver_channel0_instrument_change_load_macro_volume
0015b2 30a4                      	cpi r26, 4
0015b3 f079                      	breq sound_driver_channel0_instrument_change_load_macro_arpeggio
0015b4 30a3                      	cpi r26, 3
0015b5 f0d9                      	breq sound_driver_channel0_instrument_change_load_macro_pitch
0015b6 30a2                      	cpi r26, 2
0015b7 f159                      	breq sound_driver_channel0_instrument_change_load_macro_hi_pitch
0015b8 c03c                      	rjmp sound_driver_channel0_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel0_instrument_change_load_macro_volume:
0015b9 93c0 2818                 	sts pulse1_volume_macro, r28
0015bb 93d0 2819                 	sts pulse1_volume_macro+1, r29
0015bd d041                      	rcall sound_driver_channel0_instrument_change_read_header
0015be 93c0 281c                 	sts pulse1_volume_macro_release, r28
0015c0 93d0 281b                 	sts pulse1_volume_macro_loop, r29
0015c2 cfd8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 	
                                 sound_driver_channel0_instrument_change_load_macro_arpeggio:
0015c3 93c0 281d                 	sts pulse1_arpeggio_macro, r28
0015c5 93d0 281e                 	sts pulse1_arpeggio_macro+1, r29
0015c7 9220 2851                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0015c9 9220 2852                 	sts pulse1_fx_Qxy_target+1, zero
0015cb 9220 2857                 	sts pulse1_fx_Rxy_target, zero
0015cd 9220 2858                 	sts pulse1_fx_Rxy_target+1, zero
0015cf d03a                      	rcall sound_driver_channel0_instrument_change_read_header_arpeggio
0015d0 cfca                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_pitch:
0015d1 93c0 2824                 	sts pulse1_pitch_macro, r28
0015d3 93d0 2825                 	sts pulse1_pitch_macro+1, r29
0015d5 9220 2851                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0015d7 9220 2852                 	sts pulse1_fx_Qxy_target+1, zero
0015d9 9220 2857                 	sts pulse1_fx_Rxy_target, zero
0015db 9220 2858                 	sts pulse1_fx_Rxy_target+1, zero
0015dd d021                      	rcall sound_driver_channel0_instrument_change_read_header
0015de 93c0 2828                 	sts pulse1_pitch_macro_release, r28
0015e0 93d0 2827                 	sts pulse1_pitch_macro_loop, r29
0015e2 cfb8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_hi_pitch:
0015e3 93c0 282a                 	sts pulse1_hi_pitch_macro, r28
0015e5 93d0 282b                 	sts pulse1_hi_pitch_macro+1, r29
0015e7 9220 2851                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0015e9 9220 2852                 	sts pulse1_fx_Qxy_target+1, zero
0015eb 9220 2857                 	sts pulse1_fx_Rxy_target, zero
0015ed 9220 2858                 	sts pulse1_fx_Rxy_target+1, zero
0015ef d00f                      	rcall sound_driver_channel0_instrument_change_read_header
0015f0 93c0 282e                 	sts pulse1_hi_pitch_macro_release, r28
0015f2 93d0 282d                 	sts pulse1_hi_pitch_macro_loop, r29
0015f4 cfa6                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_duty:
0015f5 93c0 282f                 	sts pulse1_duty_macro, r28
0015f7 93d0 2830                 	sts pulse1_duty_macro+1, r29
0015f9 d005                      	rcall sound_driver_channel0_instrument_change_read_header
0015fa 93c0 2833                 	sts pulse1_duty_macro_release, r28
0015fc 93d0 2832                 	sts pulse1_duty_macro_loop, r29
0015fe cf9c                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_read_header:
0015ff 93ef                      	push ZL
001600 93ff                      	push ZH
001601 2fec                      	mov ZL, r28
001602 2ffd                      	mov ZH, r29
001603 0fee                      	lsl ZL
001604 1fff                      	rol ZH
001605 91c5                      	lpm r28, Z+
001606 91d4                      	lpm r29, Z
001607 91ff                      	pop ZH
001608 91ef                      	pop ZL
001609 9508                      	ret
                                 
                                 sound_driver_channel0_instrument_change_read_header_arpeggio:
00160a 93ef                      	push ZL
00160b 93ff                      	push ZH
00160c 2fec                      	mov ZL, r28
00160d 2ffd                      	mov ZH, r29
00160e 0fee                      	lsl ZL
00160f 1fff                      	rol ZH
001610 91c5                      	lpm r28, Z+
001611 91d5                      	lpm r29, Z+
001612 93c0 2821                 	sts pulse1_arpeggio_macro_release, r28
001614 93d0 2820                 	sts pulse1_arpeggio_macro_loop, r29
001616 91c4                      	lpm r28, Z
001617 93c0 2822                 	sts pulse1_arpeggio_macro_mode, r28
001619 91ff                      	pop ZH
00161a 91ef                      	pop ZL
00161b 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel0_release:
                                 sound_driver_channel0_release_volume:
00161c 91b0 281c                 	lds r27, pulse1_volume_macro_release
00161e 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
00161f f019                      	breq sound_driver_channel0_release_arpeggio //if the macro has no release flag, check the next macro
001620 95b3                      	inc r27
001621 93b0 281a                 	sts pulse1_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel0_release_arpeggio:
001623 91b0 2821                 	lds r27, pulse1_arpeggio_macro_release
001625 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001626 f019                      	breq sound_driver_channel0_release_pitch
001627 95b3                      	inc r27
001628 93b0 281f                 	sts pulse1_arpeggio_macro_offset, r27
                                 sound_driver_channel0_release_pitch:
00162a 91b0 2828                 	lds r27, pulse1_pitch_macro_release
00162c 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
00162d f019                      	breq sound_driver_channel0_release_hi_pitch
00162e 95b3                      	inc r27
00162f 93b0 2826                 	sts pulse1_pitch_macro_offset, r27
                                 sound_driver_channel0_release_hi_pitch:
001631 91b0 282e                 	lds r27, pulse1_hi_pitch_macro_release
001633 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001634 f019                      	breq sound_driver_channel0_release_duty
001635 95b3                      	inc r27
001636 93b0 282c                 	sts pulse1_hi_pitch_macro_offset, r27
                                 sound_driver_channel0_release_duty:
001638 91b0 2833                 	lds r27, pulse1_duty_macro_release
00163a 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
00163b f019                      	breq sound_driver_channel0_release_exit
00163c 95b3                      	inc r27
00163d 93b0 2831                 	sts pulse1_duty_macro_offset, r27
                                 sound_driver_channel0_release_exit:
00163f d01d                      	rcall sound_driver_channel0_increment_offset
001640 cd75                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_next_pattern:
001641 91e0 2808                 	lds ZL, song_frames
001643 91f0 2809                 	lds ZH, song_frames+1
001645 91a0 280a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001647 91b0 280b                 	lds r27, song_frame_offset+1
001649 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
00164a 93a0 280a                 	sts song_frame_offset, r26
00164c 93b0 280b                 	sts song_frame_offset+1, r27
                                 	//adiw r27:r26, 2 //offset for channel 1 (test)
00164e 0fea                      	add ZL, r26
00164f 1ffb                      	adc ZH, r27
                                 
001650 91a5                      	lpm r26, Z+ //load the address of the next pattern
001651 91b4                      	lpm r27, Z
001652 0faa                      	lsl r26
001653 1fbb                      	rol r27
001654 93a0 2812                 	sts pulse1_pattern, r26
001656 93b0 2813                 	sts pulse1_pattern+1, r27
                                 
001658 9220 2816                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
00165a 9220 2817                 	sts pulse1_pattern_offset+1, zero
00165c cd59                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_increment_offset:
00165d 91e0 2816                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
00165f 91f0 2817                 	lds ZH, pulse1_pattern_offset+1
001661 9631                      	adiw Z, 1
001662 93e0 2816                 	sts pulse1_pattern_offset, ZL
001664 93f0 2817                 	sts pulse1_pattern_offset+1, ZH
001666 9508                      	ret
                                 
                                 sound_driver_channel0_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001667 91e0 2816                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
001669 91f0 2817                 	lds ZH, pulse1_pattern_offset+1
00166b 9632                      	adiw Z, 2 //increment the pointer twice
00166c 93e0 2816                 	sts pulse1_pattern_offset, ZL
00166e 93f0 2817                 	sts pulse1_pattern_offset+1, ZH
001670 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_calculate_delays:
001671 936f                      	push r22
001672 937f                      	push r23
001673 9160 280e                 	lds r22, song_speed
001675 2fa6                      	mov r26, r22
001676 50a1                      	subi r26, 1
001677 2fda                      	mov r29, r26
                                 
                                 sound_driver_calculate_delays_pulse1:
                                 sound_driver_calculate_delays_pulse1_Sxx:
001678 91b0 285d                 	lds r27, pulse1_fx_Sxx_pre
00167a 91c0 285e                 	lds r28, pulse1_fx_Sxx_post
00167c 9220 285d                  	sts pulse1_fx_Sxx_pre, zero
00167e 15b2                      	cp r27, zero
00167f f051                      	breq sound_driver_calculate_delays_pulse1_Sxx_post
001680 17b6                      	cp r27, r22 //compare the Gxx fx to the song speed
001681 f440                      	brsh sound_driver_calculate_delays_pulse1_Sxx_post
001682 93b0 2814                 	sts pulse1_pattern_delay, r27
001684 9220 2815                 	sts pulse1_pattern_delay+1, zero
001686 1bdb                      	sub r29, r27 //(song speed)-1-Sxx
001687 93d0 285e                 	sts pulse1_fx_Sxx_post, r29
001689 c026                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_post:
00168a 15c2                      	cp r28, zero
00168b f021                      	breq sound_driver_calculate_delays_pulse1_Gxx
00168c 9220 285e                 	sts pulse1_fx_Sxx_post, zero
00168e 2fac                      	mov r26, r28
00168f c00c                      	rjmp sound_driver_calculate_delays_pulse1_main
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx:
001690 91b0 284e                 	lds r27, pulse1_fx_Gxx_pre
001692 91c0 284f                 	lds r28, pulse1_fx_Gxx_post
001694 17b6                      	cp r27, r22 //compare the Gxx fx to the song speed
001695 f018                      	brlo sound_driver_calculate_delays_pulse1_Gxx_post
001696 e0b0                      	ldi r27, 0 //if the Gxx effect exceeds one row (the song speed), then reset the effect to 0
001697 9220 284e                 	sts pulse1_fx_Gxx_pre, zero
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx_post:
001699 15c2                      	cp r28, zero
00169a f009                      	breq sound_driver_calculate_delays_pulse1_main
00169b 2fac                      	mov r26, r28 //if there was a Gxx, use its post instead of the (song speed)-1
                                 	
                                 sound_driver_calculate_delays_pulse1_main:
00169c 9170 2814                 	lds r23, pulse1_pattern_delay
00169e 9f67                      	mul r22, r23
00169f 0e0a                      	add r0, r26
0016a0 1c12                      	adc r1, zero
0016a1 0e0b                      	add r0, r27
0016a2 1c12                      	adc r1, zero
0016a3 9200 2814                 	sts pulse1_pattern_delay, r0
0016a5 9210 2815                 	sts pulse1_pattern_delay+1, r1
0016a7 9220 284f                 	sts pulse1_fx_Gxx_post, zero
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx_pre:
0016a9 15b2                      	cp r27, zero //check if the Gxx effect was enabled
0016aa f029                      	breq sound_driver_calculate_delays_pulse2
0016ab 1bdb                      	sub r29, r27 //(song speed)-1-Gxx
0016ac 93a0 284f                 	sts pulse1_fx_Gxx_post, r26
0016ae 9220 284e                 	sts pulse1_fx_Gxx_pre, zero
                                 
                                 sound_driver_calculate_delays_pulse2:
                                 sound_driver_calculate_delays_pulse2_Gxx:
0016b0 917f                      	pop r23
0016b1 916f                      	pop r22
0016b2 c006                      	rjmp sound_driver_instrument_routine
                                 
                                 
                                 
                                 sound_driver_channel0_decrement_frame_delay:
0016b3 50a1                      	subi r26, 1
0016b4 09b2                      	sbc r27, zero
0016b5 93a0 2814                 	sts pulse1_pattern_delay, r26
0016b7 93b0 2815                 	sts pulse1_pattern_delay+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine:
                                 sound_driver_instrument_routine_channel0_volume:
0016b9 91e0 2818                 	lds ZL, pulse1_volume_macro
0016bb 91f0 2819                 	lds ZH, pulse1_volume_macro+1
0016bd 9630                      	adiw Z, 0
0016be f1a1                      	breq sound_driver_instrument_routine_channel0_volume_default //if no volume macro is in use, use default multiplier of F
0016bf 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0016c0 1fff                      	rol ZH
0016c1 91a0 281a                 	lds r26, pulse1_volume_macro_offset
0016c3 0fea                      	add ZL, r26
0016c4 1df2                      	adc ZH, zero
                                 
0016c5 91b0 281c                 	lds r27, pulse1_volume_macro_release
0016c7 17ba                      	cp r27, r26
0016c8 f429                      	brne sound_driver_instrument_routine_channel0_volume_increment //if the current offset is not equal to the release index, increment the offset
0016c9 91a0 281b                 	lds r26, pulse1_volume_macro_loop
0016cb 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0016cc f010                      	brlo sound_driver_instrument_routine_channel0_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0016cd c003                      	rjmp sound_driver_instrument_routine_channel0_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_volume_increment:
0016ce 95a3                      	inc r26 //increment the macro offset
0016cf 93a0 281a                 	sts pulse1_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_volume_read:
0016d1 91b4                      	lpm r27, Z //load volume data into r27
0016d2 3fbf                      	cpi r27, 0xFF //check for macro end flag
0016d3 f469                      	brne sound_driver_instrument_routine_channel0_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_release:
0016d4 91b0 281c                 	lds r27, pulse1_volume_macro_release
0016d6 3fbf                      	cpi r27, 0xFF
0016d7 f429                      	brne sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_loop:
0016d8 91b0 281b                 	lds r27, pulse1_volume_macro_loop //load the loop index
0016da 93b0 281a                 	sts pulse1_volume_macro_offset, r27 //store the loop index into the offset
0016dc cfdc                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index:
0016dd 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
0016de 93a0 281a                 	sts pulse1_volume_macro_offset, r26
0016e0 cfd8                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_calculate:
0016e1 e1e2                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
0016e2 e3f5                      	ldi ZH, HIGH(volumes << 1)
0016e3 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
0016e4 0feb                      	add ZL, r27 //add offset to the table
0016e5 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel0_volume_load:
0016e6 91b0 2800                 	lds r27, pulse1_param //load main volume
0016e8 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
0016e9 91a0 284c                 	lds r26, pulse1_fx_7xy_value
0016eb 30a0                      	cpi r26, 0x00
0016ec f481                      	brne sound_driver_instrument_routine_channel0_volume_load_7xy
                                 
0016ed 0feb                      	add ZL, r27 //offset the volume table by the main volume
0016ee 1df2                      	adc ZH, zero
0016ef 91b4                      	lpm r27, Z
0016f0 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
0016f2 c024                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default:
0016f3 91b0 2800                 	lds r27, pulse1_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
0016f5 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
0016f6 91a0 284c                 	lds r26, pulse1_fx_7xy_value
0016f8 30a0                      	cpi r26, 0x00
0016f9 f4a1                      	brne sound_driver_instrument_routine_channel0_volume_default_7xy
0016fa 93b0 2806                 	sts pulse1_output_volume, r27
0016fc c01a                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy:
0016fd 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
0016fe f040                      	brcs sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
0016ff f039                      	breq sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
001700 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
                                 
001701 0feb                      	add ZL, r27 //offset the volume table by the main volume
001702 1df2                      	adc ZH, zero
001703 91b4                      	lpm r27, Z
001704 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
001706 c010                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy_overflow:
001707 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
001708 0feb                      	add ZL, r27 //offset the volume table by the main volume
001709 1df2                      	adc ZH, zero
00170a 91b4                      	lpm r27, Z
00170b 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
00170d c009                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default_7xy:
00170e 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
00170f f020                      	brcs sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
001710 f019                      	breq sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
001711 93b0 2806                 	sts pulse1_output_volume, r27
001713 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel0_volume_default_7xy_overflow:
001714 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
001715 93b0 2806                 	sts pulse1_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
001717 91e0 281d                 	lds ZL, pulse1_arpeggio_macro
001719 91f0 281e                 	lds ZH, pulse1_arpeggio_macro+1
00171b 9630                      	adiw Z, 0
00171c f1d9                      	breq sound_driver_instrument_routine_channel0_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
00171d 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
00171e 1fff                      	rol ZH
00171f 91a0 281f                 	lds r26, pulse1_arpeggio_macro_offset
001721 0fea                      	add ZL, r26
001722 1df2                      	adc ZH, zero
                                 
001723 91b0 2821                 	lds r27, pulse1_arpeggio_macro_release
001725 17ba                      	cp r27, r26
001726 f429                      	brne sound_driver_instrument_routine_channel0_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
001727 91a0 2820                 	lds r26, pulse1_arpeggio_macro_loop
001729 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00172a f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
00172b c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_increment:
00172c 95a3                      	inc r26 //increment the macro offset
00172d 93a0 281f                 	sts pulse1_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_read:
00172f 91b4                      	lpm r27, Z //load arpeggio data into r27
001730 38b0                      	cpi r27, 0x80 //check for macro end flag
001731 f009                      	breq sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag
001732 c041                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_check_mode:
001733 50a1                      	subi r26, 1 //keep the offset at the end flag
001734 93a0 281f                 	sts pulse1_arpeggio_macro_offset, r26
001736 91b0 2822                 	lds r27, pulse1_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
001738 30b1                      	cpi r27, 0x01
001739 f048                      	brlo sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_release:
00173a 91b0 2821                 	lds r27, pulse1_arpeggio_macro_release
00173c 3fbf                      	cpi r27, 0xFF
00173d f4d1                      	brne sound_driver_instrument_routine_channel0_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_loop:
00173e 91b0 2820                 	lds r27, pulse1_arpeggio_macro_loop
001740 3fbf                      	cpi r27, 0xFF
001741 f499                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
001742 c015                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute:
001743 91b0 2821                 	lds r27, pulse1_arpeggio_macro_release
001745 3fbf                      	cpi r27, 0xFF
001746 f421                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_check_loop:
001747 91b0 2820                 	lds r27, pulse1_arpeggio_macro_loop //load the loop index
001749 3fbf                      	cpi r27, 0xFF //check if loop flag exists
00174a f451                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop:
00174b 91c0 2834                 	lds r28, pulse1_fx_0xy_sequence //check for 0xy effect
00174d 91d0 2835                 	lds r29, pulse1_fx_0xy_sequence+1
00174f 9620                      	adiw r29:r28, 0
001750 f469                      	brne sound_driver_instrument_routine_channel0_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
001751 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
001752 93a0 281f                 	sts pulse1_arpeggio_macro_offset, r26 //store the last valid index into the offset
001754 cfc2                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload:
001755 93b0 281f                 	sts pulse1_arpeggio_macro_offset, r27 //store the loop index into the offset
001757 cfbf                      	rjmp sound_driver_instrument_routine_channel0_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_default:
001758 91c0 2834                 	lds r28, pulse1_fx_0xy_sequence //load 0xy effect
00175a 91d0 2835                 	lds r29, pulse1_fx_0xy_sequence+1
00175c 9620                      	adiw r29:r28, 0 //check for 0xy effect
00175d f099                      	breq sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel0_arpeggio_default_xy:
00175e 95d6                      	lsr r29
00175f 95c7                      	ror r28
001760 95d7                      	ror r29
001761 95c7                      	ror r28
001762 95d7                      	ror r29
001763 95c7                      	ror r28
001764 95d7                      	ror r29
001765 95c7                      	ror r28
001766 95d7                      	ror r29
001767 95d2                      	swap r29
                                 
001768 93c0 2834                 	sts pulse1_fx_0xy_sequence, r28 //store the rolled sequence
00176a 93d0 2835                 	sts pulse1_fx_0xy_sequence+1, r29
00176c 70cf                      	andi r28, 0x0F //mask out the 4 LSB
00176d 91a0 2807                 	lds r26, pulse1_note //load the current note index
00176f 0fac                      	add r26, r28 //add the note offset
001770 c02c                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
001771 91a0 2807                 	lds r26, pulse1_note //load the current note index
001773 c029                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process:
001774 9220 2823                 	sts pulse1_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
001776 9220 2829                 	sts pulse1_total_hi_pitch_offset, zero
001778 91a0 2822                 	lds r26, pulse1_arpeggio_macro_mode
00177a 30a1                      	cpi r26, 0x01 //absolute mode
00177b f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_absolute
00177c f069                      	breq sound_driver_instrument_routine_channel0_arpeggio_process_fixed
00177d c00e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute:
00177e 91a0 2807                 	lds r26, pulse1_note //load the current note index
001780 0fab                      	add r26, r27 //offset the note with the arpeggio data
001781 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
001782 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_add:
001783 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
001784 f0c0                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
001785 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
001786 c016                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract:
001787 fda7                      	sbrc r26, 7 //check if result is negative
001788 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
001789 c013                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_fixed:
00178a 2fab                      	mov r26, r27 //move the arpeggio data into r26
00178b c011                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative:
00178c 91a0 2807                 	lds r26, pulse1_note //load the current note index
00178e 0fab                      	add r26, r27 //offset the note with the arpeggio data
00178f fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
001790 c008                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_add:
001791 93a0 2807                 	sts pulse1_note, r26 //NOTE: relative mode modifies the original note index
001793 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
001794 f040                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
001795 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
001796 93a0 2807                 	sts pulse1_note, r26
001798 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract:
001799 fda7                      	sbrc r26, 7 //check if result is negative
00179a e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
00179b 93a0 2807                 	sts pulse1_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_load:
00179d e3e4                      	ldi ZL, LOW(note_table << 1) //load in note table
00179e e0f0                      	ldi ZH, HIGH(note_table << 1)
00179f 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
0017a0 0fea                      	add ZL, r26 //add offset
0017a1 1df2                      	adc ZH, zero
0017a2 91a5                      	lpm r26, Z+ //load bytes
0017a3 91b4                      	lpm r27, Z
0017a4 93a0 0a8c                 	sts TCB0_CCMPL, r26 //load the LOW bits for timer
0017a6 93b0 0a8d                 	sts TCB0_CCMPH, r27 //load the HIGH bits for timer
0017a8 93a0 2840                 	sts pulse1_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
0017aa 93b0 2841                 	sts pulse1_fx_3xx_target+1, r27
0017ac c000                      	rjmp sound_driver_instrument_routine_channel0_pitch
                                 
                                 
                                 
                                 //NOTE: There is a limitation with the pitch routines in that the total pitch can not be offset by 127 in both,
                                 //the positive and negative direction, from the original note pitch. This shouldn't be too much of a problem as
                                 //most songs that use instruments with the pitch macro, do not stray that far from the original note pitch.
                                 //In the case of hi pitch, the total pitch can not be offset by 127*16 from the original pitch. This is also
                                 //not a big deal as you can easily reach the entire note range with an offset of up to 127*16.
                                 sound_driver_instrument_routine_channel0_pitch:
0017ad 91e0 2824                 	lds ZL, pulse1_pitch_macro
0017af 91f0 2825                 	lds ZH, pulse1_pitch_macro+1
0017b1 9630                      	adiw Z, 0
0017b2 f409                      	brne sound_driver_instrument_routine_channel0_pitch_continue
0017b3 c023                      	rjmp sound_driver_instrument_routine_channel0_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel0_pitch_continue:
0017b4 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0017b5 1fff                      	rol ZH
0017b6 91a0 2826                 	lds r26, pulse1_pitch_macro_offset
0017b8 0fea                      	add ZL, r26
0017b9 1df2                      	adc ZH, zero
                                 
0017ba 91b0 2828                 	lds r27, pulse1_pitch_macro_release
0017bc 17ba                      	cp r27, r26
0017bd f429                      	brne sound_driver_instrument_routine_channel0_pitch_increment //if the current offset is not equal to the release index, increment the offset
0017be 91a0 2827                 	lds r26, pulse1_pitch_macro_loop
0017c0 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0017c1 f010                      	brlo sound_driver_instrument_routine_channel0_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0017c2 c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_pitch_increment:
0017c3 95a3                      	inc r26 //increment the macro offset
0017c4 93a0 2826                 	sts pulse1_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_pitch_read:
0017c6 91b4                      	lpm r27, Z //load pitch data into r27
0017c7 38b0                      	cpi r27, 0x80 //check for macro end flag
0017c8 f489                      	brne sound_driver_instrument_routine_channel0_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_release:
0017c9 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0017ca 93a0 2826                 	sts pulse1_pitch_macro_offset, r26
0017cc 91b0 2828                 	lds r27, pulse1_pitch_macro_release
0017ce 3fbf                      	cpi r27, 0xFF
0017cf f439                      	brne sound_driver_instrument_routine_channel0_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_loop:
0017d0 91b0 2827                 	lds r27, pulse1_pitch_macro_loop //load the loop index
0017d2 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0017d3 f019                      	breq sound_driver_instrument_routine_channel0_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
0017d4 93b0 2826                 	sts pulse1_pitch_macro_offset, r27 //store the loop index into the offset
0017d6 cfd6                      	rjmp sound_driver_instrument_routine_channel0_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_default:
0017d7 91b0 2823                 	lds r27, pulse1_total_pitch_offset
0017d9 c005                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate:
0017da 91a0 2823                 	lds r26, pulse1_total_pitch_offset //load the total pitch offset to change
0017dc 0fba                      	add r27, r26
0017dd 93b0 2823                 	sts pulse1_total_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_multiply:
                                 	//NOTE: The Pxx effect is processed with the pitch instrument macro because the calculations are the same
0017df 91a0 2850                 	lds r26, pulse1_fx_Pxx
0017e1 0fba                      	add r27, r26
                                 
0017e2 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0017e3 937f                      	push r23
0017e4 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
0017e5 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0017e6 0367                      	mulsu r22, r23
0017e7 917f                      	pop r23
0017e8 916f                      	pop r22
                                 
0017e9 9416                      	lsr r1 //shift out the fractional bits
0017ea 9407                      	ror r0
0017eb 9416                      	lsr r1
0017ec 9407                      	ror r0
0017ed 9416                      	lsr r1
0017ee 9407                      	ror r0
0017ef 9416                      	lsr r1
0017f0 9407                      	ror r0
0017f1 fe13                      	sbrs r1, 3 //check if result was a negative number
0017f2 c002                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_negative:
0017f3 efb0                      	ldi r27, 0xF0
0017f4 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_offset:
0017f5 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
0017f7 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
0017f9 0da0                      	add r26, r0 //offset the timer values
0017fa 1db1                      	adc r27, r1
                                 	
0017fb 91c0 2838                 	lds r28, pulse1_fx_1xx_total
0017fd 91d0 2839                 	lds r29, pulse1_fx_1xx_total+1
0017ff 1bac                      	sub r26, r28
001800 0bbd                      	sbc r27, r29
001801 91c0 283c                 	lds r28, pulse1_fx_2xx_total
001803 91d0 283d                 	lds r29, pulse1_fx_2xx_total+1
001805 0fac                      	add r26, r28
001806 1fbd                      	adc r27, r29
001807 91c0 2855                 	lds r28, pulse1_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
001809 91d0 2856                 	lds r29, pulse1_fx_Qxy_total_offset+1
00180b 1bac                      	sub r26, r28
00180c 0bbd                      	sbc r27, r29
00180d 91c0 285b                 	lds r28, pulse1_fx_Rxy_total_offset
00180f 91d0 285c                 	lds r29, pulse1_fx_Rxy_total_offset+1
001811 0fac                      	add r26, r28
001812 1fbd                      	adc r27, r29
                                 
001813 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
001815 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel0_hi_pitch:
001817 91e0 282a                 	lds ZL, pulse1_hi_pitch_macro
001819 91f0 282b                 	lds ZH, pulse1_hi_pitch_macro+1
00181b 9630                      	adiw Z, 0
00181c f409                      	brne sound_driver_instrument_routine_channel0_hi_pitch_continue
00181d c03c                      	rjmp sound_driver_instrument_routine_channel0_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel0_hi_pitch_continue:
00181e 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00181f 1fff                      	rol ZH
001820 91a0 282c                 	lds r26, pulse1_hi_pitch_macro_offset
001822 0fea                      	add ZL, r26
001823 1df2                      	adc ZH, zero
                                 
001824 91b0 282e                 	lds r27, pulse1_hi_pitch_macro_release
001826 17ba                      	cp r27, r26
001827 f429                      	brne sound_driver_instrument_routine_channel0_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
001828 91a0 282d                 	lds r26, pulse1_hi_pitch_macro_loop
00182a 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00182b f010                      	brlo sound_driver_instrument_routine_channel0_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00182c c003                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_increment:
00182d 95a3                      	inc r26 //increment the macro offset
00182e 93a0 282c                 	sts pulse1_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_hi_pitch_read:
001830 91b4                      	lpm r27, Z //load hi pitch data into r27
001831 38b0                      	cpi r27, 0x80 //check for macro end flag
001832 f489                      	brne sound_driver_instrument_routine_channel0_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_release:
001833 50a1                      	subi r26, 1 //keep the macro offset at the end flag
001834 93a0 282c                 	sts pulse1_hi_pitch_macro_offset, r26
001836 91b0 282e                 	lds r27, pulse1_hi_pitch_macro_release
001838 3fbf                      	cpi r27, 0xFF
001839 f439                      	brne sound_driver_instrument_routine_channel0_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_loop:
00183a 91b0 282d                 	lds r27, pulse1_hi_pitch_macro_loop //load the loop index
00183c 3fbf                      	cpi r27, 0xFF //check if there is a loop index
00183d f019                      	breq sound_driver_instrument_routine_channel0_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
00183e 93b0 282c                 	sts pulse1_hi_pitch_macro_offset, r27 //store the loop index into the offset
001840 cfd6                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_default:
001841 91b0 2829                 	lds r27, pulse1_total_hi_pitch_offset
001843 c005                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate:
001844 91a0 2829                 	lds r26, pulse1_total_hi_pitch_offset //load the total hi pitch offset to change
001846 0fba                      	add r27, r26
001847 93b0 2829                 	sts pulse1_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply:
001849 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00184a 937f                      	push r23
00184b 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
00184c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00184d 0367                      	mulsu r22, r23
00184e 917f                      	pop r23
00184f 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_offset:
001850 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
001852 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
001854 0da0                      	add r26, r0 //offset the timer values
001855 1db1                      	adc r27, r1
001856 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
001858 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel0_duty:
00185a 91e0 282f                 	lds ZL, pulse1_duty_macro
00185c 91f0 2830                 	lds ZH, pulse1_duty_macro+1
00185e 9630                      	adiw Z, 0
00185f f1b1                      	breq sound_driver_channel0_fx_routines //if no duty macro is in use, go to the next routine
001860 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
001861 1fff                      	rol ZH
001862 91a0 2831                 	lds r26, pulse1_duty_macro_offset
001864 0fea                      	add ZL, r26
001865 1df2                      	adc ZH, zero
                                 
001866 91b0 2833                 	lds r27, pulse1_duty_macro_release
001868 17ba                      	cp r27, r26
001869 f429                      	brne sound_driver_instrument_routine_channel0_duty_increment //if the current offset is not equal to the release index, increment the offset
00186a 91a0 2832                 	lds r26, pulse1_duty_macro_loop
00186c 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00186d f010                      	brlo sound_driver_instrument_routine_channel0_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00186e c027                      	rjmp sound_driver_channel0_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel0_duty_increment:
00186f 95a3                      	inc r26 //increment the macro offset
001870 93a0 2831                 	sts pulse1_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_duty_read:
001872 91b4                      	lpm r27, Z //load pitch data into r27
001873 3fbf                      	cpi r27, 0xFF //check for macro end flag
001874 f471                      	brne sound_driver_instrument_routine_channel0_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_release:
001875 50a1                      	subi r26, 1 //keep the macro offset at the end flag
001876 93a0 2831                 	sts pulse1_duty_macro_offset, r26
001878 91b0 2833                 	lds r27, pulse1_duty_macro_release
00187a 3fbf                      	cpi r27, 0xFF
00187b f4d1                      	brne sound_driver_channel0_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_loop:
00187c 91b0 2832                 	lds r27, pulse1_duty_macro_loop //load the loop index
00187e 3fbf                      	cpi r27, 0xFF //check if there is a loop index
00187f f0b1                      	breq sound_driver_channel0_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
001880 93b0 2831                 	sts pulse1_duty_macro_offset, r27 //store the loop index into the offset
001882 cfd7                      	rjmp sound_driver_instrument_routine_channel0_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_load:
001883 edea                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
001884 e3f4                      	ldi ZH, HIGH(sequences << 1)
001885 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
001886 1df2                      	adc ZH, zero
                                 
001887 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
001888 95b7                      	ror r27
001889 95b7                      	ror r27
00188a 91a0 2800                 	lds r26, pulse1_param //load r26 with pulse1_param (register $4000)
00188c 2fca                      	mov r28, r26 //store a copy of pulse1_param into r28
00188d 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
00188e 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
00188f c001                      	rjmp sound_driver_instrument_routine_channel0_duty_load_store
001890 c005                      	rjmp sound_driver_channel0_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel0_duty_load_store:
001891 90d4                      	lpm pulse1_sequence, Z //store the sequence
                                 
001892 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
001893 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
001894 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_routines:
                                 sound_driver_channel0_fx_1xx_routine:
001896 91e0 2836                 	lds ZL, pulse1_fx_1xx
001898 91f0 2837                 	lds ZH, pulse1_fx_1xx+1
00189a 9630                      	adiw Z, 0
00189b f051                      	breq sound_driver_channel0_fx_2xx_routine
                                 
00189c 91a0 2838                 	lds r26, pulse1_fx_1xx_total //load the rate to change the pitch by
00189e 91b0 2839                 	lds r27, pulse1_fx_1xx_total+1
0018a0 0fae                      	add r26, ZL //increase the total offset by the rate
0018a1 1fbf                      	adc r27, ZH
0018a2 93a0 2838                 	sts pulse1_fx_1xx_total, r26
0018a4 93b0 2839                 	sts pulse1_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_2xx_routine:
0018a6 91e0 283a                 	lds ZL, pulse1_fx_2xx
0018a8 91f0 283b                 	lds ZH, pulse1_fx_2xx+1
0018aa 9630                      	adiw Z, 0
0018ab f051                      	breq sound_driver_channel0_fx_3xx_routine
                                 
0018ac 91a0 283c                 	lds r26, pulse1_fx_2xx_total //load the rate to change the pitch by
0018ae 91b0 283d                 	lds r27, pulse1_fx_2xx_total+1
0018b0 0fae                      	add r26, ZL //increase the total offset by the rate
0018b1 1fbf                      	adc r27, ZH
0018b2 93a0 283c                 	sts pulse1_fx_2xx_total, r26
0018b4 93b0 283d                 	sts pulse1_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_3xx_routine:
0018b6 91e0 2842                 	lds ZL, pulse1_fx_3xx_speed
0018b8 91f0 2843                 	lds ZH, pulse1_fx_3xx_speed+1
0018ba 9630                      	adiw Z, 0
0018bb f409                      	brne sound_driver_channel0_fx_3xx_routine_check_start
0018bc c048                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_check_start:
0018bd 91a0 283e                 	lds r26, pulse1_fx_3xx_start
0018bf 91b0 283f                 	lds r27, pulse1_fx_3xx_start+1
0018c1 9610                      	adiw r26:r27, 0
0018c2 f409                      	brne sound_driver_channel0_fx_3xx_routine_main
0018c3 c041                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_main:
0018c4 91c0 2840                 	lds r28, pulse1_fx_3xx_target
0018c6 91d0 2841                 	lds r29, pulse1_fx_3xx_target+1
                                 
0018c8 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
0018c9 07bd                      	cpc r27, r29
0018ca f011                      	breq sound_driver_channel0_fx_3xx_routine_disable
0018cb f030                      	brlo sound_driver_channel0_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
0018cc c01f                      	rjmp sound_driver_channel0_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel0_fx_3xx_routine_disable:
0018cd 9220 283e                 	sts pulse1_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
0018cf 9220 283f                 	sts pulse1_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
0018d1 c033                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_subtract:
0018d2 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
0018d3 0bdb                      	sbc r29, r27
0018d4 91a0 2844                 	lds r26, pulse1_fx_3xx_total_offset
0018d6 91b0 2845                 	lds r27, pulse1_fx_3xx_total_offset+1
                                 
0018d8 0fae                      	add r26, ZL //add the speed to the total offset
0018d9 1fbf                      	adc r27, ZH
0018da 1bca                      	sub r28, r26 //invert the total difference with the total offset
0018db 0bdb                      	sbc r29, r27
0018dc f380                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0018dd 93a0 2844                 	sts pulse1_fx_3xx_total_offset, r26 //store the new total offset
0018df 93b0 2845                 	sts pulse1_fx_3xx_total_offset+1, r27
                                 
0018e1 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the current timer period
0018e3 91b0 0a8d                 	lds r27, TCB0_CCMPH
0018e5 1bac                      	sub r26, r28 //offset the current timer period with the total offset
0018e6 0bbd                      	sbc r27, r29
0018e7 93a0 0a8c                 	sts TCB0_CCMPL, r26
0018e9 93b0 0a8d                 	sts TCB0_CCMPH, r27
0018eb c019                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_add:
0018ec 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
0018ed 0bbd                      	sbc r27, r29
0018ee 91c0 2844                 	lds r28, pulse1_fx_3xx_total_offset
0018f0 91d0 2845                 	lds r29, pulse1_fx_3xx_total_offset+1
                                 
0018f2 0fce                      	add r28, ZL //add the speed to the total offset
0018f3 1fdf                      	adc r29, ZH
0018f4 1bac                      	sub r26, r28 //invert the total difference with the total offset
0018f5 0bbd                      	sbc r27, r29
0018f6 f2b0                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0018f7 93c0 2844                 	sts pulse1_fx_3xx_total_offset, r28 //store the new total offset
0018f9 93d0 2845                 	sts pulse1_fx_3xx_total_offset+1, r29
                                 
0018fb 91c0 0a8c                 	lds r28, TCB0_CCMPL //load the current timer period
0018fd 91d0 0a8d                 	lds r29, TCB0_CCMPH
0018ff 0fca                      	add r28, r26 //offset the current timer period with the total offset
001900 1fdb                      	adc r29, r27
001901 93c0 0a8c                 	sts TCB0_CCMPL, r28
001903 93d0 0a8d                 	sts TCB0_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel0_fx_4xy_routine:
001905 91a0 2846                 	lds r26, pulse1_fx_4xy_speed
001907 15a2                      	cp r26, zero
001908 f409                      	brne sound_driver_channel0_fx_4xy_routine_continue
001909 c05c                      	rjmp sound_driver_channel0_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel0_fx_4xy_routine_continue:
00190a 91b0 2847                 	lds r27, pulse1_fx_4xy_depth
00190c 91c0 2848                 	lds r28, pulse1_fx_4xy_phase
00190e 0fca                      	add r28, r26 //increase the phase by the speed
00190f 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
001910 f008                      	brlo sound_driver_channel0_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
001911 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase:
001912 93c0 2848                 	sts pulse1_fx_4xy_phase, r28 //store the new phase
001914 31c0                      	cpi r28, 16
001915 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_0
001916 32c0                      	cpi r28, 32
001917 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_1
001918 33c0                      	cpi r28, 48
001919 f030                      	brlo sound_driver_channel0_fx_4xy_routine_phase_2
00191a c007                      	rjmp sound_driver_channel0_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_0:
00191b 70cf                      	andi r28, 0x0F //mask for values 0-15
00191c c029                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_1:
00191d 6fc0                      	ori r28, 0xF0
00191e 95c0                      	com r28 //invert values 0-15
00191f c026                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_2:
001920 70cf                      	andi r28, 0x0F //mask for values 0-15
001921 c003                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_3:
001922 6fc0                      	ori r28, 0xF0
001923 95c0                      	com r28 //invert values 0-15
001924 c000                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_add:
001925 95b2                      	swap r27 //multiply depth by 16
001926 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
001927 eee2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
001928 e0f0                      	ldi ZH, HIGH(vibrato_table << 1)
001929 0fec                      	add ZL, r28 //offset the table by the depth+phase
00192a 1df2                      	adc ZH, zero
00192b 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
00192c 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00192d 937f                      	push r23
00192e 2f6c                      	mov r22, r28 //store the vibrato value into r22
00192f eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001930 9f67                      	mul r22, r23
001931 917f                      	pop r23
001932 916f                      	pop r22
                                 
001933 9416                      	lsr r1 //shift out the fractional bits
001934 9407                      	ror r0
001935 9416                      	lsr r1
001936 9407                      	ror r0
001937 9416                      	lsr r1
001938 9407                      	ror r0
001939 9416                      	lsr r1
00193a 9407                      	ror r0
                                 	
00193b 91a0 0a8c                 	lds r26, TCB0_CCMPL
00193d 91b0 0a8d                 	lds r27, TCB0_CCMPH
00193f 0da0                      	add r26, r0
001940 1db1                      	adc r27, r1
001941 93a0 0a8c                 	sts TCB0_CCMPL, r26
001943 93b0 0a8d                 	sts TCB0_CCMPH, r27
001945 c020                      	rjmp sound_driver_channel0_fx_7xy_routine
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_subtract:
001946 95b2                      	swap r27 //multiply depth by 16
001947 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
001948 eee2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
001949 e0f0                      	ldi ZH, HIGH(vibrato_table << 1)
00194a 0fec                      	add ZL, r28 //offset the table by the depth+phase
00194b 1df2                      	adc ZH, zero
00194c 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
00194d 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00194e 937f                      	push r23
00194f 2f6c                      	mov r22, r28 //store the vibrato value into r22
001950 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001951 9f67                      	mul r22, r23
001952 917f                      	pop r23
001953 916f                      	pop r22
                                 
001954 9416                      	lsr r1 //shift out the fractional bits
001955 9407                      	ror r0
001956 9416                      	lsr r1
001957 9407                      	ror r0
001958 9416                      	lsr r1
001959 9407                      	ror r0
00195a 9416                      	lsr r1
00195b 9407                      	ror r0
                                 
00195c 91a0 0a8c                 	lds r26, TCB0_CCMPL
00195e 91b0 0a8d                 	lds r27, TCB0_CCMPH
001960 19a0                      	sub r26, r0
001961 09b1                      	sbc r27, r1
001962 93a0 0a8c                 	sts TCB0_CCMPL, r26
001964 93b0 0a8d                 	sts TCB0_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_7xy_routine:
001966 91a0 2849                 	lds r26, pulse1_fx_7xy_speed
001968 15a2                      	cp r26, zero
001969 f0f1                      	breq sound_driver_channel0_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
00196a 91b0 284a                 	lds r27, pulse1_fx_7xy_depth
00196c 91c0 284b                 	lds r28, pulse1_fx_7xy_phase
00196e 0fca                      	add r28, r26 //increase the phase by the speed
00196f 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
001970 f010                      	brlo sound_driver_channel0_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
001971 e0c0                      	ldi r28, 0x00
001972 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase:
001973 93c0 284b                 	sts pulse1_fx_7xy_phase, r28 //store the new phase
001975 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
001976 ffc4                      	sbrs r28, 4
001977 c001                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_0
001978 c002                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel0_fx_7xy_routine_phase_0:
001979 70cf                      	andi r28, 0x0F //mask for values 0-15
00197a c003                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase_1:
00197b 6fc0                      	ori r28, 0xF0
00197c 95c0                      	com r28 //invert values 0-15
00197d c000                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_load:
00197e 95b2                      	swap r27 //multiply depth by 16
00197f 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
001980 eee2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
001981 e0f0                      	ldi ZH, HIGH(vibrato_table << 1)
001982 0fec                      	add ZL, r28 //offset the table by the depth+phase
001983 1df2                      	adc ZH, zero
001984 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
001985 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
001986 93c0 284c                 	sts pulse1_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Axy_routine:
001988 91b0 284d                 	lds r27, pulse1_fx_Axy
00198a 15b2                      	cp r27, zero
00198b f0e9                      	breq sound_driver_channel0_fx_Qxy_routine //0 means that the effect is not in use
                                 	
00198c 91a0 2805                 	lds r26, pulse1_fractional_volume //load fractional volume representation of the channel
00198e 91c0 2800                 	lds r28, pulse1_param //load the integer volume representation of the channel
001990 2fda                      	mov r29, r26 //copy fractional volume into r29
001991 2fec                      	mov r30, r28 //copy the pulse1_param into r30
001992 95e2                      	swap r30
001993 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
001994 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
001995 17ed                      	cp r30, r29 //compare the fractional and integer volumes
001996 f009                      	breq sound_driver_channel0_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel0_fx_Axy_routine_reload:
001997 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate:
001998 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
001999 c004                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_addition:
00199a 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
00199b f428                      	brcc sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
00199c efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
00199d c003                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_subtraction:
00199e 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
00199f f008                      	brcs sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0019a0 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_store:
0019a1 93a0 2805                 	sts pulse1_fractional_volume, r26 //store the new fractional volume
0019a3 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
0019a4 95a2                      	swap r26
0019a5 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
0019a6 2bca                      	or r28, r26 //store the new volume back into pulse1_param
0019a7 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel0_fx_Qxy_routine:
0019a9 91e0 2851                 	lds ZL, pulse1_fx_Qxy_target
0019ab 91f0 2852                 	lds ZH, pulse1_fx_Qxy_target+1
0019ad 9630                      	adiw Z, 0
0019ae f131                      	breq sound_driver_channel0_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
0019af 91a0 2855                 	lds r26, pulse1_fx_Qxy_total_offset
0019b1 91b0 2856                 	lds r27, pulse1_fx_Qxy_total_offset+1
0019b3 91c0 0a8c                 	lds r28, TCB0_CCMPL
0019b5 91d0 0a8d                 	lds r29, TCB0_CCMPH
0019b7 1bca                      	sub r28, r26 //subtract the timer period by the total offset
0019b8 0bdb                      	sbc r29, r27
                                 
0019b9 17ce                      	cp r28, ZL //compare the new timer period with the target
0019ba 07df                      	cpc r29, ZH
0019bb f010                      	brlo sound_driver_channel0_fx_Qxy_routine_end //if the target has been reached (or passed)
0019bc f009                      	breq sound_driver_channel0_fx_Qxy_routine_end
0019bd f468                      	brsh sound_driver_channel0_fx_Qxy_routine_add
                                 
                                 sound_driver_channel0_fx_Qxy_routine_end:
0019be 1bec                      	sub ZL, r28 //calculate the difference to the target
0019bf 0bfd                      	sbc ZH, r29
0019c0 0fae                      	add r26, ZL //increase the total offset to the exact amount needed to reach the target
0019c1 1fbf                      	adc r27, ZH
0019c2 93a0 2855                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
0019c4 93b0 2856                 	sts pulse1_fx_Qxy_total_offset+1, r27
0019c6 9220 2851                 	sts pulse1_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
0019c8 9220 2852                 	sts pulse1_fx_Qxy_target+1, zero
0019ca c00a                      	rjmp sound_driver_channel0_fx_Rxy_routine
                                 
                                 sound_driver_channel0_fx_Qxy_routine_add:
0019cb 91c0 2853                 	lds r28, pulse1_fx_Qxy_speed
0019cd 91d0 2854                 	lds r29, pulse1_fx_Qxy_speed+1
0019cf 0fac                      	add r26, r28 //increase the total offset by the speed
0019d0 1fbd                      	adc r27, r29
0019d1 93a0 2855                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
0019d3 93b0 2856                 	sts pulse1_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Rxy_routine:
0019d5 91e0 2857                 	lds ZL, pulse1_fx_Rxy_target
0019d7 91f0 2858                 	lds ZH, pulse1_fx_Rxy_target+1
0019d9 9630                      	adiw Z, 0
0019da f131                      	breq sound_driver_channel0_fx_xy_routine //if the effect is not enabled, skip the routine
                                 
0019db 91a0 285b                 	lds r26, pulse1_fx_Rxy_total_offset
0019dd 91b0 285c                 	lds r27, pulse1_fx_Rxy_total_offset+1
0019df 91c0 0a8c                 	lds r28, TCB0_CCMPL
0019e1 91d0 0a8d                 	lds r29, TCB0_CCMPH
0019e3 0fca                      	add r28, r26 //add the total offset to the timer period
0019e4 0fdb                      	add r29, r27
                                 
0019e5 17ce                      	cp r28, ZL //compare the new timer period with the target
0019e6 07df                      	cpc r29, ZH
0019e7 f010                      	brlo sound_driver_channel0_fx_Rxy_routine_end //if the target has been reached (or passed)
0019e8 f009                      	breq sound_driver_channel0_fx_Rxy_routine_end
0019e9 f468                      	brsh sound_driver_channel0_fx_Rxy_routine_add
                                 
                                 sound_driver_channel0_fx_Rxy_routine_end:
0019ea 1bec                      	sub ZL, r28 //calculate the difference to the target
0019eb 0bfd                      	sbc ZH, r29
0019ec 0fae                      	add r26, ZL //increase the total offset to the exact amount needed to reach the target
0019ed 1fbf                      	adc r27, ZH
0019ee 93a0 285b                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
0019f0 93b0 285c                 	sts pulse1_fx_Rxy_total_offset+1, r27
0019f2 9220 2857                 	sts pulse1_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
0019f4 9220 2858                 	sts pulse1_fx_Rxy_target+1, zero
0019f6 c00a                      	rjmp sound_driver_channel0_fx_xy_routine
                                 
                                 sound_driver_channel0_fx_Rxy_routine_add:
0019f7 91c0 2859                 	lds r28, pulse1_fx_Rxy_speed
0019f9 91d0 285a                 	lds r29, pulse1_fx_Rxy_speed+1
0019fb 0fac                      	add r26, r28 //increase the total offset by the speed
0019fc 1fbd                      	adc r27, r29
0019fd 93a0 285b                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
0019ff 93b0 285c                 	sts pulse1_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 sound_driver_channel0_fx_xy_routine:
                                 
                                 sound_driver_exit:
001a01 91df                      	pop r29
001a02 91cf                      	pop r28
001a03 c920                      	rjmp sequence_1_3 + 3 //+3 is to skip the stack instructions since we already pushed them
                                 
                                 //PULSE 1 ROUTINES
                                 pulse1_sequence_routine:
001a04 b7bf                      	in r27, CPU_SREG
001a05 93bf                      	push r27
001a06 94f8                      	cli
                                 
001a07 0cdd                      	lsl pulse1_sequence //shifts sequence to the left
001a08 1cd2                      	adc pulse1_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
001a09 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
001a0a 93b0 0a86                 	sts TCB0_INTFLAGS, r27
001a0c 91bf                      	pop r27
001a0d bfbf                      	out CPU_SREG, r27
001a0e 9518                      	reti
                                 
                                 pulse1_sweep_routine:
001a0f 2dbf                      	mov r27, pulse1_sweep
001a10 70b7                      	andi r27, 0x07 //mask for period divider bits
001a11 f4f9                      	brne pulse1_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse1_sweep_routine_action: //if the divider is == 0, update the pulse timer period
001a12 93df                      	push r29
001a13 2ddf                      	mov r29, pulse1_sweep
001a14 95d2                      	swap r29
001a15 70d7                      	andi r29, 0x07 //mask for shift bits
001a16 f411                      	brne pulse1_sweep_routine_action_main //shift != 0
001a17 91df                      	pop r29
001a18 c019                      	rjmp pulse1_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse1_sweep_routine_action_main:
001a19 91a0 0a8c                 	lds r26, TCB0_CCMPL
001a1b 91b0 0a8d                 	lds r27, TCB0_CCMPH
                                 pulse1_sweep_routine_action_main_loop:
001a1d 95b6                      	lsr r27
001a1e 95a7                      	ror r26
001a1f 95da                      	dec r29
001a20 f7e1                      	brne pulse1_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
001a21 fef7                      	sbrs pulse1_sweep, 7 //check the negate flag
001a22 c002                      	rjmp pulse1_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
001a23 95a0                      	com r26 //pulse1 uses one's complement if the negate flag is set
001a24 95b0                      	com r27
                                 
                                 pulse1_sweep_routine_action_main_add:
001a25 91d0 0a8c                 	lds r29, TCB0_CCMPL //perform addition to get new timer period
001a27 0fad                      	add r26, r29
001a28 91d0 0a8d                 	lds r29, TCB0_CCMPH
001a2a 1fbd                      	adc r27, r29
                                 
001a2b 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new LOW bits for timer
001a2d 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new HIGH bits for timer
                                 
                                 	//sts pulse1_timerL, r26
                                 	//sts pulse1_timerH, r27
                                 
                                 /*	//Sweep Test
                                 	mov r29, pulse1_sweep //invert the negate bit
                                 	ldi r27, 0b10000000
                                 	eor r29, r27
                                 	ori r29, 0b01111111
                                 
                                 	lds r27, pulse1_sweep_param //reload the pulse sweep divider params
                                 	swap r27
                                 	ori r27, 0b10000000
                                 	and r27, r29
                                 	mov pulse1_sweep, r27
                                 	sbr channel_flags, 0b10000000*/
                                 	
001a2f 91df                      	pop r29
001a30 c001                      	rjmp pulse1_sweep_routine_check_reload
                                 
                                 pulse1_sweep_routine_decrement_divider:
001a31 94fa                      	dec pulse1_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse1_sweep_routine_check_reload:
001a32 ff97                      	sbrs channel_flags, 7 //if the reload flag is set, reload the sweep divider
001a33 9508                      	ret
                                 
                                 pulse1_sweep_reload:
001a34 90f0 2801                 	lds pulse1_sweep, pulse1_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
001a36 94f2                      	swap pulse1_sweep //bring data from high byte to low byte
001a37 779f                      	cbr channel_flags, 0b10000000 //clear reload flag
001a38 9508                      	ret
                                 
                                 pulse1_envelope_routine:
001a39 fd96                      	sbrc channel_flags, 6 //check if start flag is cleared
001a3a c010                      	rjmp pulse1_envelope_routine_clear_start
                                 
001a3b 3000                      	cpi pulse1_volume_divider, 0x00 //check if the divider is 0
001a3c f011                      	breq PC+3 //if the divider == 0, check loop flag
001a3d 950a                      	dec pulse1_volume_divider //if the divider != 0, decrement and return
001a3e 9508                      	ret
                                 
001a3f 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the divider == 0, reset the divider period
001a41 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
001a42 ff95                      	sbrs channel_flags, 5 //check if the loop flag is set
001a43 c002                      	rjmp pulse1_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
001a44 e01f                      	ldi pulse1_volume_decay, 0x0F //if the loop flag is set, reset decay and return
001a45 9508                      	ret
                                 
                                 pulse1_envelope_routine_decrement_decay:
001a46 3010                      	cpi pulse1_volume_decay, 0x00 //check if the decay is 0
001a47 f409                      	brne PC+2 //if decay != 0, go decrement
001a48 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
001a49 951a                      	dec pulse1_volume_decay
001a4a 9508                      	ret
                                 
                                 pulse1_envelope_routine_clear_start:
001a4b 7b9f                      	cbr channel_flags, 0b01000000 //if the start flag is set, clear it
001a4c 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the start flag is set, reset the divider period
001a4e 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
001a4f e01f                      	ldi pulse1_volume_decay, 0x0F //if the start flag is set, reset decay
001a50 9508                      	ret
                                 
                                 //CONVERTERS (TABLES)
                                 //converts and loads 5 bit length to corresponding 8 bit length value into r29
                                 length_converter:
001a51 eaee                      	ldi ZL, LOW(length << 1)
001a52 e3f4                      	ldi ZH, HIGH(length << 1)
001a53 0fed                      	add ZL, r29
001a54 1df2                      	adc ZH, zero
001a55 91d4                      	lpm r29, Z
001a56 9508                      	ret
                                 
001a57 7f05
001a58 010a
001a59 0214
001a5a 0328
001a5b 0450
001a5c 051e
001a5d 0607
001a5e 070d
001a5f 0806
001a60 090c
001a61 0a18
001a62 0b30
001a63 0c60
001a64 0d24
001a65 0e08
001a66 0f10                      length: .db $05, $7F, $0A, $01, $14, $02, $28, $03, $50, $04, $1E, $05, $07, $06, $0D, $07, $06, $08, $0C, $09, $18, $0A, $30, $0B, $60, $0C, $24, $0D, $08, $0E, $10, $0F
                                 
                                 //loads pulse sequence into r29
                                 duty_cycle_sequences:
001a67 edea                      	ldi ZL, LOW(sequences << 1)
001a68 e3f4                      	ldi ZH, HIGH(sequences << 1)
001a69 0fed                      	add ZL, r29
001a6a 1df2                      	adc ZH, zero
001a6b 91d4                      	lpm r29, Z
001a6c 9508                      	ret
                                 
                                 //pulse sequences: 12.5%, 25%, 50%, 75%
001a6d 0301
001a6e fc0f                      sequences: .db 0b00000001, 0b00000011, 0b00001111, 0b11111100
                                 
                                 //list of famitracker fx: http://famitracker.com/wiki/index.php?title=Effect_list
                                 fx:
001a6f 13e0
001a70 13e5
001a71 1401
001a72 141d
001a73 1440                      	.dw sound_driver_channel0_fx_0xy, sound_driver_channel0_fx_1xx, sound_driver_channel0_fx_2xx, sound_driver_channel0_fx_3xx, sound_driver_channel0_fx_4xy
001a74 144b
001a75 1458
001a76 145b
001a77 145e
001a78 1461                      	.dw sound_driver_channel0_fx_7xy, sound_driver_channel0_fx_Axy, sound_driver_channel0_fx_Bxx, sound_driver_channel0_fx_Cxx, sound_driver_channel0_fx_Dxx
001a79 1464
001a7a 146c
001a7b 146f
001a7c 1472
001a7d 1479                      	.dw sound_driver_channel0_fx_Exx, sound_driver_channel0_fx_Fxx, sound_driver_channel0_fx_Gxx, sound_driver_channel0_fx_Hxy, sound_driver_channel0_fx_Ixy
001a7e 1481
001a7f 1482
001a80 1483
001a81 1486
001a82 14ca                      	.dw sound_driver_channel0_fx_Hxx, sound_driver_channel0_fx_Ixx, sound_driver_channel0_fx_Pxx, sound_driver_channel0_fx_Qxy, sound_driver_channel0_fx_Rxy
001a83 150d
001a84 1510
001a85 1524
001a86 1525
001a87 1526                      	.dw sound_driver_channel0_fx_Sxx, sound_driver_channel0_fx_Vxx, sound_driver_channel0_fx_Wxx, sound_driver_channel0_fx_Xxx, sound_driver_channel0_fx_Yxx
001a88 1527                      	.dw sound_driver_channel0_fx_Zxx
                                 
                                 //famitracker volumes table: http://famitracker.com/wiki/index.php?title=Volume
                                 volumes:
001a89 0000
001a8a 0000
001a8b 0000
001a8c 0000
001a8d 0000
001a8e 0000
001a8f 0000
001a90 0000                      	.db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
001a91 0100
001a92 0101
001a93 0101
001a94 0101
001a95 0101
001a96 0101
001a97 0101
001a98 0101                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
001a99 0100
001a9a 0101
001a9b 0101
001a9c 0101
001a9d 0101
001a9e 0101
001a9f 0101
001aa0 0201                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02
001aa1 0100
001aa2 0101
001aa3 0101
001aa4 0101
001aa5 0101
001aa6 0202
001aa7 0202
001aa8 0302                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03
001aa9 0100
001aaa 0101
001aab 0101
001aac 0101
001aad 0202
001aae 0202
001aaf 0303
001ab0 0403                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04
001ab1 0100
001ab2 0101
001ab3 0101
001ab4 0202
001ab5 0302
001ab6 0303
001ab7 0404
001ab8 0504                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05
001ab9 0100
001aba 0101
001abb 0201
001abc 0202
001abd 0303
001abe 0404
001abf 0504
001ac0 0605                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x06
001ac1 0100
001ac2 0101
001ac3 0201
001ac4 0302
001ac5 0403
001ac6 0504
001ac7 0605
001ac8 0706                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07
001ac9 0100
001aca 0101
001acb 0202
001acc 0303
001acd 0404
001ace 0505
001acf 0606
001ad0 0807                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07, 0x08
001ad1 0100
001ad2 0101
001ad3 0302
001ad4 0403
001ad5 0504
001ad6 0606
001ad7 0707
001ad8 0908                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09
001ad9 0100
001ada 0201
001adb 0302
001adc 0404
001add 0605
001ade 0706
001adf 0808
001ae0 0a09                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A
001ae1 0100
001ae2 0201
001ae3 0302
001ae4 0504
001ae5 0605
001ae6 0807
001ae7 0908
001ae8 0b0a                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B
001ae9 0100
001aea 0201
001aeb 0403
001aec 0504
001aed 0706
001aee 0808
001aef 0a09
001af0 0c0b                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B, 0x0C
001af1 0100
001af2 0201
001af3 0403
001af4 0605
001af5 0706
001af6 0908
001af7 0b0a
001af8 0d0c                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D
001af9 0100
001afa 0201
001afb 0403
001afc 0605
001afd 0807
001afe 0a09
001aff 0c0b
001b00 0e0d                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E
001b01 0100
001b02 0302
001b03 0504
001b04 0706
001b05 0908
001b06 0b0a
001b07 0d0c


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega4809" register use summary:
x  :   0 y  :   0 z  :  67 r0 :  44 r1 :  46 r2 : 202 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 
r13:   6 r14:   4 r15:  13 r16:   7 r17:   6 r18:   0 r19:   0 r20:   0 
r21:   0 r22:  43 r23:  40 r24:   0 r25:  15 r26: 275 r27: 379 r28: 146 
r29: 114 r30:  96 r31:  91 
Registers used: 18 out of 35 (51.4%)

"ATmega4809" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  44 add   :  59 adiw  :  29 and   :   0 
andi  :  32 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   2 brcs  :   4 break :   0 breq  :  46 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  24 brlt  :   0 brmi  :   0 
brne  :  33 brpl  :   0 brsh  :   8 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :   0 cbr   :   2 
clc   :   0 clh   :   0 cli   :   5 cln   :   0 clr   :   3 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :   5 cp    :  25 cpc   :   4 
cpi   :  49 cpse  :   6 dec   :   7 des   :   0 eor   :   0 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   1 in    :   4 inc   :  13 
jmp   :   6 ld    :   0 ldd   :   0 ldi   :  91 lds   : 196 lpm   :  77 
lsl   :  21 lsr   :  39 mov   :  37 movw  :   0 mul   :   8 muls  :   0 
mulsu :   2 neg   :   0 nop   :   0 or    :   6 ori   :   5 out   :   7 
pop   :  34 push  :  31 rcall :  16 ret   :  13 reti  :   4 rjmp  : 134 
rol   :  15 ror   :  45 sbc   :  12 sbci  :   0 sbi   :   0 sbic  :   0 
sbis  :   0 sbiw  :   0 sbr   :   7 sbrc  :   8 sbrs  :   6 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   : 378 sub   :  16 subi  :  13 swap  :  16 tst   :   0 wdr   :   0 

Instructions used: 51 out of 114 (44.7%)

"ATmega4809" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x003612   4396   9418  13814   49152  28.1%
[.dseg] 0x002800 0x002863      0     99     99    6144   1.6%
[.eseg] 0x000000 0x000000      0      0      0     256   0.0%

Assembly complete, 0 errors, 105 warnings
