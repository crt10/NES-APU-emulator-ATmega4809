
AVRASM ver. 2.2.8  C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm Wed Jan 13 00:16:38 2021

C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(124): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(124): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
                                 
                                 
                                 ; NES_APU_2a03.asm
                                 ;
                                 ; Created: 11/29/2020 1:44:10 AM
                                 ; Author : Tennyson Cheng
                                 ;
                                 
                                 .list
                                 
                                 .dseg
002800                           pulse1_param: .byte 1 //$4000 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002801                           pulse1_sweep_param: .byte 1 //$4001 EPPP.NSSS = Enable, Period, Negate, Shift
                                 //NOTE: In order to account for multiplier, we use 16 instead of 11 bits for the timer
002802                           pulse1_timerL: .byte 1 //$4002 LLLL.LLLL = Low 8 bits for timer
002803                           pulse1_timerH: .byte 1 //$4002 HHHH.HHHH = High 8 bits for timer
002804                           pulse1_length: .byte 1 //$4002 000l.llll = Length counter load
002805                           pulse1_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002806                           pulse1_output_volume: .byte 1 //this is the final output volume of pulse 1
002807                           pulse1_note: .byte 1 //the current note index in the note table
                                 
002808                           song_frames: .byte 2
00280a                           song_frame_offset: .byte 2
00280c                           song_speed: .byte 1
                                 
                                 
00280d                           pulse1_pattern: .byte 2
00280f                           pulse1_pattern_delay: .byte 2
002811                           pulse1_pattern_offset: .byte 2
                                 
002813                           pulse1_volume_macro: .byte 2
002815                           pulse1_volume_macro_offset: .byte 1
002816                           pulse1_volume_macro_loop: .byte 1
002817                           pulse1_volume_macro_release: .byte 1
                                 
002818                           pulse1_arpeggio_macro: .byte 2
00281a                           pulse1_arpeggio_macro_offset: .byte 1
00281b                           pulse1_arpeggio_macro_loop: .byte 1
00281c                           pulse1_arpeggio_macro_release: .byte 1
00281d                           pulse1_arpeggio_macro_mode: .byte 1
                                 
00281e                           pulse1_total_pitch_offset: .byte 1 //used to reference the overall change in pitch for the pitch macro
00281f                           pulse1_pitch_macro: .byte 2
002821                           pulse1_pitch_macro_offset: .byte 1
002822                           pulse1_pitch_macro_loop: .byte 1
002823                           pulse1_pitch_macro_release: .byte 1
                                 
002824                           pulse1_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
002825                           pulse1_hi_pitch_macro: .byte 2
002827                           pulse1_hi_pitch_macro_offset: .byte 1
002828                           pulse1_hi_pitch_macro_loop: .byte 1
002829                           pulse1_hi_pitch_macro_release: .byte 1
                                 
00282a                           pulse1_duty_macro: .byte 2
00282c                           pulse1_duty_macro_offset: .byte 1
00282d                           pulse1_duty_macro_loop: .byte 1
00282e                           pulse1_duty_macro_release: .byte 1
                                 
00282f                           pulse1_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002831                           pulse1_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002833                           pulse1_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
002835                           pulse1_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
002837                           pulse1_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
002839                           pulse1_fx_3xx_start: .byte 2 //the starting note period
00283b                           pulse1_fx_3xx_target: .byte 2 //target note period
00283d                           pulse1_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
00283f                           pulse1_fx_3xx_total_offset: .byte 2
002841                           pulse1_fx_4xy_speed: .byte 1
002842                           pulse1_fx_4xy_depth: .byte 1
002843                           pulse1_fx_4xy_phase: .byte 1
002844                           pulse1_fx_7xy_speed: .byte 1
002845                           pulse1_fx_7xy_depth: .byte 1
002846                           pulse1_fx_7xy_phase: .byte 1
002847                           pulse1_fx_7xy_value: .byte 1 //value to offset the volume
002848                           pulse1_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
002849                           pulse1_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
00284a                           pulse1_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
00284b                           pulse1_fx_Pxx: .byte 1 //refers to the fine pitch offset set by the Pxx effect
00284c                           pulse1_fx_Qxy_target: .byte 2 //target note period
00284e                           pulse1_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002850                           pulse1_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002852                           pulse1_fx_Rxy_target: .byte 2 //target note period
002854                           pulse1_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
002856                           pulse1_fx_Rxy_total_offset: .byte 2
002858                           pulse1_fx_Sxx_pre: .byte 1
002859                           pulse1_fx_Sxx_post: .byte 1
                                 
00285a                           pulse2_pattern_delay: .byte 1
00285b                           triangle_pattern_delay: .byte 1
00285c                           noise_pattern_delay: .byte 1
00285d                           dcpm_pattern_delay: .byte 1
                                 
                                 .cseg
                                 
                                 //NOTE: zero is defined in order to use the cp instruction without the need to load 0x00 into a register beforehand
                                 .def zero = r2
                                 .def channel_flags = r25 //[pulse1.pulse2] RSlc.0000 = Reload, Start, Length halt/Loop, Constant volume
                                 .def pulse1_sequence = r13
                                 .def pulse1_length_counter = r14
                                 .def pulse1_sweep = r15 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse1_volume_divider = r16 //0000.PPPP = Period divider
                                 .def pulse1_volume_decay = r17 //0000.dddd = Decay
                                 
                                 reset:
000000 940c 020d                 	jmp init
                                 
                                 .org TCA0_OVF_vect
00000e 940c 035e                 	jmp sound_driver
                                 
                                 .org TCA0_CMP0_vect
000012 940c 0344                 	jmp sequence_0_2
                                 
                                 .org TCA0_CMP1_vect
000014 940c 034e                 	jmp sequence_1_3
                                 
                                 .org TCA0_CMP2_vect
000016 940c 0344                 	jmp sequence_0_2
                                 
                                 .org TCB0_INT_vect
000018 940c 09b2                 	jmp pulse1_sequence_routine
                                 
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(44): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(124): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(45): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(124): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(46): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(124): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(47): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(124): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(50): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(124): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(55): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(124): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(60): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(124): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(65): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(124): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
                                 .list
                                 
                                 init:
                                 	//MAIN CLOCK
00020d edb8                      	ldi r27, CPU_CCP_IOREG_gc //protected write
00020e 93b0 0034                 	sts CPU_CCP, r27
000210 e0b0                      	ldi r27, 0 << CLKCTRL_PEN_bp //disable prescaler for 20 MHz on main clock
000211 93b0 0061                 	sts CLKCTRL_MCLKCTRLB, r27
                                 
                                 /*	//TEST FOR C4, 1 SECOND, 50% DD
                                 	ldi r26, 0x97
                                 	ldi r27, 0x12
                                 	ldi r26, 0x15
                                 	ldi r27, 0x09
                                 	sts pulse1_timerL, r26
                                 	sts pulse1_timerH, r27
                                 	ldi r27, 0b10111111
                                 	sts pulse1_param, r27
                                 	ldi r27, 0x01
                                 	sts pulse1_length, r27
                                 	//TEST FOR SWEEP UP
                                 	ldi r27, 0b11111111
                                 	sts pulse1_sweep_param, r27*/
                                 
                                 	//ZERO
000213 2422                      	clr zero
                                 
                                 	//MEMORY
000214 e3b0                      	ldi r27, 0b00110000
000215 93b0 2800                 	sts pulse1_param, r27
000217 e8b0                      	ldi r27, 0b10000000
000218 93b0 2801                 	sts pulse1_sweep_param, r27
00021a efbf                      	ldi r27, 0xFF
00021b 93b0 2802                 	sts pulse1_timerL, r27
00021d 93b0 2803                 	sts pulse1_timerH, r27
00021f 93b0 2804                 	sts pulse1_length, r27
                                 
000221 e0b0                      	ldi r27, 0x00
000222 93b0 280a                 	sts song_frame_offset, r27
000224 93b0 280b                 	sts song_frame_offset+1, r27
000226 eee2                      	ldi ZL, LOW(song0_frames << 1)
000227 e0f1                      	ldi ZH, HIGH(song0_frames << 1)
000228 93e0 2808                 	sts song_frames, ZL
00022a 93f0 2809                 	sts song_frames+1, ZH
00022c 9220 280c                 	sts song_speed, zero
                                 
                                 	//CHANNEL 0 TEST
00022e e0b0                      	ldi r27, 0x00
00022f 0feb                      	add ZL, r27
000230 1df2                      	adc ZH, zero
000231 91a5                      	lpm r26, Z+
000232 91b4                      	lpm r27, Z
000233 0faa                      	lsl r26
000234 1fbb                      	rol r27
000235 93a0 280d                 	sts pulse1_pattern, r26
000237 93b0 280e                 	sts pulse1_pattern+1, r27
000239 e0b0                      	ldi r27, 0x00
00023a 9220 280f                 	sts pulse1_pattern_delay, zero
00023c 9220 2810                 	sts pulse1_pattern_delay+1, zero
00023e 9220 2811                 	sts pulse1_pattern_offset, zero
000240 9220 2812                 	sts pulse1_pattern_offset+1, zero
                                 
                                 	//channel 0 instrument macros
000242 efbf                      	ldi r27, 0xFF
000243 9220 2815                 	sts pulse1_volume_macro_offset, zero
000245 93b0 2816                 	sts pulse1_volume_macro_loop, r27
000247 93b0 2817                 	sts pulse1_volume_macro_release, r27
000249 9220 281a                 	sts pulse1_arpeggio_macro_offset, zero
00024b 93b0 281b                 	sts pulse1_arpeggio_macro_loop, r27
00024d 93b0 281c                 	sts pulse1_arpeggio_macro_release, r27
00024f 93b0 281d                 	sts pulse1_arpeggio_macro_mode, r27
000251 9220 2821                 	sts pulse1_pitch_macro_offset, zero
000253 93b0 2822                 	sts pulse1_pitch_macro_loop, r27
000255 93b0 2823                 	sts pulse1_pitch_macro_release, r27
000257 9220 2827                 	sts pulse1_hi_pitch_macro_offset, zero
000259 93b0 2828                 	sts pulse1_hi_pitch_macro_loop, r27
00025b 93b0 2829                 	sts pulse1_hi_pitch_macro_release, r27
00025d 9220 282c                 	sts pulse1_duty_macro_offset, zero
00025f 93b0 282d                 	sts pulse1_duty_macro_loop, r27
000261 93b0 282e                 	sts pulse1_duty_macro_release, r27
                                 
000263 9220 2813                 	sts pulse1_volume_macro, zero
000265 9220 2814                 	sts pulse1_volume_macro+1, zero
000267 9220 2818                 	sts pulse1_arpeggio_macro, zero
000269 9220 2819                 	sts pulse1_arpeggio_macro+1, zero
00026b 9220 281e                 	sts pulse1_total_pitch_offset, zero
00026d 9220 281f                 	sts pulse1_pitch_macro, zero
00026f 9220 2820                 	sts pulse1_pitch_macro+1, zero
000271 9220 2824                 	sts pulse1_total_hi_pitch_offset, zero
000273 9220 2825                 	sts pulse1_hi_pitch_macro, zero
000275 9220 2826                 	sts pulse1_hi_pitch_macro+1, zero
000277 9220 282a                 	sts pulse1_duty_macro, zero
000279 9220 282b                 	sts pulse1_duty_macro+1, zero
                                 
00027b 9220 285a                 	sts pulse2_pattern_delay, zero
00027d 9220 285b                 	sts triangle_pattern_delay, zero
00027f 9220 285c                 	sts noise_pattern_delay, zero
000281 9220 285d                 	sts dcpm_pattern_delay, zero
                                 
                                 	//PINS
000283 efbf                      	ldi r27, 0xFF //set all pins in VPORTD to output
000284 b9b0                      	out VPORTA_DIR, r27
                                 
                                 	//ENVELOPE
000285 e00f                      	ldi pulse1_volume_divider, 0x0F
000286 9110 2800                 	lds pulse1_volume_decay, pulse1_param
000288 701f                      	andi pulse1_volume_decay, 0x0F //mask for VVVV bits
000289 9190 2800                 	lds channel_flags, pulse1_param
00028b 7390                      	andi channel_flags, 0b00110000
00028c 6490                      	sbr channel_flags, 0b01000000 //set start flag
00028d 9220 2806                 	sts pulse1_output_volume, zero
00028f 93b0 2805                 	sts pulse1_fractional_volume, r27 //initialize fractional volume to max value
                                 	
                                 	//LENGTH
000291 91d0 2804                 	lds r29, pulse1_length
000293 d76b                      	rcall length_converter
000294 2eed                      	mov pulse1_length_counter, r29
                                 
                                 	//SEQUENCE
000295 91d0 2800                 	lds r29, pulse1_param //load param for sequence table
000297 0fdd                      	lsl r29 //shift duty cycle bits to LSB
000298 1fdd                      	rol r29
000299 1fdd                      	rol r29
00029a 70d3                      	andi r29, 0b00000011 //mask duty cycle bits
00029b d779                      	rcall duty_cycle_sequences
00029c 2edd                      	mov pulse1_sequence, r29
                                 
                                 	//SWEEP
00029d 90f0 2801                 	lds pulse1_sweep, pulse1_sweep_param
00029f 94f2                      	swap pulse1_sweep //swap data from high byte and low byte
0002a0 6890                      	sbr channel_flags, 0b10000000 //set reload flag
                                 
                                 	//FX
0002a1 9220 282f                 	sts pulse1_fx_0xy_sequence, zero
0002a3 9220 2830                 	sts pulse1_fx_0xy_sequence+1, zero
0002a5 9220 2831                 	sts pulse1_fx_1xx, zero
0002a7 9220 2832                 	sts pulse1_fx_1xx+1, zero
0002a9 9220 2833                 	sts pulse1_fx_1xx_total, zero
0002ab 9220 2834                 	sts pulse1_fx_1xx_total+1, zero
0002ad 9220 2835                 	sts pulse1_fx_2xx, zero
0002af 9220 2836                 	sts pulse1_fx_2xx+1, zero
0002b1 9220 2837                 	sts pulse1_fx_2xx_total, zero
0002b3 9220 2838                 	sts pulse1_fx_2xx_total+1, zero
0002b5 9220 2839                 	sts pulse1_fx_3xx_start, zero
0002b7 9220 283a                 	sts pulse1_fx_3xx_start+1, zero
0002b9 9220 283b                 	sts pulse1_fx_3xx_target, zero
0002bb 9220 283c                 	sts pulse1_fx_3xx_target+1, zero
0002bd 9220 283d                 	sts pulse1_fx_3xx_speed, zero
0002bf 9220 283e                 	sts pulse1_fx_3xx_speed+1, zero
0002c1 9220 283f                 	sts pulse1_fx_3xx_total_offset, zero
0002c3 9220 2840                 	sts pulse1_fx_3xx_total_offset+1, zero
0002c5 9220 2841                 	sts pulse1_fx_4xy_speed, zero
0002c7 9220 2842                 	sts pulse1_fx_4xy_depth, zero
0002c9 9220 2843                 	sts pulse1_fx_4xy_phase, zero
0002cb 9220 2844                 	sts pulse1_fx_7xy_speed, zero
0002cd 9220 2845                 	sts pulse1_fx_7xy_depth, zero
0002cf 9220 2846                 	sts pulse1_fx_7xy_phase, zero
0002d1 9220 2847                 	sts pulse1_fx_7xy_value, zero
0002d3 9220 2848                 	sts pulse1_fx_Axy, zero
0002d5 9220 2849                 	sts pulse1_fx_Gxx_pre, zero
0002d7 9220 284a                 	sts pulse1_fx_Gxx_post, zero
0002d9 9220 284b                 	sts pulse1_fx_Pxx, zero
0002db 9220 284c                 	sts pulse1_fx_Qxy_target, zero
0002dd 9220 284d                 	sts pulse1_fx_Qxy_target+1, zero
0002df 9220 284e                 	sts pulse1_fx_Qxy_speed, zero
0002e1 9220 284f                 	sts pulse1_fx_Qxy_speed+1, zero
0002e3 9220 2850                 	sts pulse1_fx_Qxy_total_offset, zero
0002e5 9220 2851                 	sts pulse1_fx_Qxy_total_offset+1, zero
0002e7 9220 2852                 	sts pulse1_fx_Rxy_target, zero
0002e9 9220 2853                 	sts pulse1_fx_Rxy_target+1, zero
0002eb 9220 2854                 	sts pulse1_fx_Rxy_speed, zero
0002ed 9220 2855                 	sts pulse1_fx_Rxy_speed+1, zero
0002ef 9220 2856                 	sts pulse1_fx_Rxy_total_offset, zero
0002f1 9220 2857                 	sts pulse1_fx_Rxy_total_offset+1, zero
0002f3 9220 2858                 	sts pulse1_fx_Sxx_pre, zero
0002f5 9220 2859                 	sts pulse1_fx_Sxx_post, zero
                                 
                                 	//TIMERS
                                 	//Frame Counter
                                 	//NOTE:The frame counter will be defaulted to NTSC mode (60 Hz, 120 Hz, 240 Hz)
                                 	//Each interrupt will be setup to interrupt every 240 Hz clock
                                 	//CMP0 = sequence 0, CMP1 = sequence 1, CMP2 = sequence 2, OVF = sequence 3/sound driver
                                 	//Sequence 3 will clock the sound driver every 60Hz, in which new audio data is read and written to the registers
                                 	//Timer period Calculation: (0.00416666666 * 20000000/64)-1 = 1301.08333125 = 0x0515
                                 	//The ATmega4809 is cofigured to run at 20000000 Hz
                                 	//0.00416666666 seconds is the period for 240 Hz
                                 	//The /64 comes from the prescaler divider used
0002f7 e7b0                      	ldi r27, TCA_SINGLE_CMP0EN_bm | TCA_SINGLE_CMP1EN_bm | TCA_SINGLE_CMP2EN_bm | TCA_SINGLE_WGMODE_NORMAL_gc //interrupt mode
0002f8 93b0 0a01                 	sts TCA0_SINGLE_CTRLB, r27
0002fa e7b1                      	ldi r27, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP1_bm | TCA_SINGLE_CMP2_bm | TCA_SINGLE_OVF_bm //enable overflow and compare interrupts
0002fb 93b0 0a0a                 	sts TCA0_SINGLE_INTCTRL, r27
0002fd e1b5                      	ldi r27, 0x15 //set the period for CMP0
0002fe 93b0 0a28                 	sts TCA0_SINGLE_CMP0, r27
000300 e0b5                      	ldi r27, 0x05
000301 93b0 0a29                 	sts TCA0_SINGLE_CMP0 + 1, r27
000303 e2bb                      	ldi r27, 0x2B //set the period for CMP1
000304 93b0 0a2a                 	sts TCA0_SINGLE_CMP1, r27
000306 e0ba                      	ldi r27, 0x0A
000307 93b0 0a2b                 	sts TCA0_SINGLE_CMP1 + 1, r27
000309 e4b1                      	ldi r27, 0x41 //set the period for CMP2
00030a 93b0 0a2c                 	sts TCA0_SINGLE_CMP2, r27
00030c e0bf                      	ldi r27, 0x0F
00030d 93b0 0a2d                 	sts TCA0_SINGLE_CMP2 + 1, r27
00030f e5b7                      	ldi r27, 0x57 //set the period for OVF
000310 93b0 0a26                 	sts TCA0_SINGLE_PER, r27
000312 e1b4                      	ldi r27, 0x14
000313 93b0 0a27                 	sts TCA0_SINGLE_PER + 1, r27
000315 e0bb                      	ldi r27, TCA_SINGLE_CLKSEL_DIV64_gc | TCA_SINGLE_ENABLE_bm //use prescale divider of 64 and enable timer
000316 93b0 0a00                 	sts TCA0_SINGLE_CTRLA, r27
                                 
                                 	//NOTE: Channel Timers are clocked (20/2)/(0.8948865) = 11.1746014718 times faster than the NES APU
                                 	//Because of this, we multiply all the NES timer values by 11.1746014718 beforehand
                                 	//Since we rotate the sequence when the timer goes from t-(t-1) to 0, instead of 0 to t like the NES, we add 1 to the NES timers before multiplying
                                 	//The ATmega4809 is configured to run at 20 MHz
                                 	//The /2 comes from the prescaler divider used
                                 	//0.8948865 MHz is the speed of the NTSC NES APU
                                 	//NOTE: This means that any offset to the pitch for the NES timers would be multiplied by 11.1746014718 aswell.
                                 	//Pulse 1
000318 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
000319 93b0 0a81                 	sts TCB0_CTRLB, r27
00031b e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
00031c 93b0 0a85                 	sts TCB0_INTCTRL, r27
00031e 91b0 2802                 	lds r27, pulse1_timerL //load the LOW bits for timer
000320 93b0 0a8c                 	sts TCB0_CCMPL, r27
000322 91b0 2803                 	lds r27, pulse1_timerH //load the HIGH bits for timer
000324 93b0 0a8d                 	sts TCB0_CCMPH, r27
000326 e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
000327 93b0 0a80                 	sts TCB0_CTRLA, r27
000329 9478                      	sei //global interrupt enable
                                 
                                 pulse1:
00032a fed0                      	sbrs pulse1_sequence, 0 //if the sequence output is zero, return
00032b c012                      	rjmp pulse1_off
                                 
00032c 14e2                      	cp pulse1_length_counter, zero //if length is zero, return
00032d f081                      	breq pulse1_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
                                 pulse1_check_timer_08:
00032e 91c0 0a8c                 	lds r28, TCB0_CCMPL
000330 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 pulse1_check_timer_08_HIGH:
000332 30d1                      	cpi r29, 0x01 //check timer HIGH period
000333 f008                      	brlo pulse1_check_timer_08_LOW //if the timer HIGH period is $00, check the LOW period
000334 c002                      	rjmp pulse1_check_timer_7FF_HIGH //if the timer HIGH period is > $01, check > $07FF condition
                                 pulse1_check_timer_08_LOW:
000335 35c9                      	cpi r28, 0x59 //check timer LOW period
000336 f038                      	brlo pulse1_off //if the HIGH period == $00 && LOW period <= $59, pulse off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $5965
                                 pulse1_check_timer_7FF_HIGH:
000337 35d9                      	cpi r29, 0x59 //check timer HIGH period
000338 f038                      	brlo pulse1_on //if the HIGH period is < $59, then all conditions have passed and pulse is not muted
000339 f009                      	breq pulse1_check_timer_7FF_LOW //if the HIGH period is == $59, we go check if the LOW period is < $65
00033a c003                      	rjmp pulse1_off //pulse off if HIGH period is > $59
                                 pulse1_check_timer_7FF_LOW:
00033b 36c5                      	cpi r28, 0x65 //check timer LOW period
00033c f408                      	brsh pulse1_off //if the HIGH period == $59 && LOW period >= $65, pulse off
00033d c002                      	rjmp pulse1_on //if the HIGH period == $59 && LOW period < $65, pulse on
                                 
                                 pulse1_off:
00033e b821                      	out VPORTA_OUT, zero
00033f cfea                      	rjmp pulse1
                                 
                                 pulse1_on:
000340 91d0 2806                 	lds r29, pulse1_output_volume
                                 /*	cpse r29, zero
                                 	rjmp pulse1_off //if VVVV bits are 0, then there is no volume (channel off)*/
                                 
000342 b9d1                      	out VPORTA_OUT, r29
000343 cfe6                      	rjmp pulse1
                                 
                                 //FRAME COUNTER/AUDIO SAMPLE ISR
                                 sequence_0_2:
000344 b7bf                      	in r27, CPU_SREG
000345 93bf                      	push r27
000346 94f8                      	cli
                                 
                                 	//ENVELOPE
000347 d69f                      	rcall pulse1_envelope_routine
                                 
000348 e5b0                      	ldi r27, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP2_bm //clear OVF flag
000349 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
00034b 91bf                      	pop r27
00034c bfbf                      	out CPU_SREG, r27
00034d 9518                      	reti
                                 
                                 sequence_1_3:
00034e b7bf                      	in r27, CPU_SREG
00034f 93bf                      	push r27
000350 94f8                      	cli
                                 
                                 	//ENVELOPE
000351 d695                      	rcall pulse1_envelope_routine
                                 
                                 	//SWEEP
000352 fcf3                      	sbrc pulse1_sweep, 3 //check if the sweep enable bit is cleared
000353 d669                      	rcall pulse1_sweep_routine
                                 
                                 	//LENGTH
                                 	//NOTE: The length routine is relatively simple, so we will not be using clocks to rjmp and ret to a seperate lable
000354 fd95                      	sbrc channel_flags, 5 //check if the length counter halt bit is cleared
000355 c002                      	rjmp sequence_1_3_exit
000356 10e2                      	cpse pulse1_length_counter, zero //if length counter is already 0, don't decrement
000357 94ea                      	dec pulse1_length_counter
                                 
                                 sequence_1_3_exit:
000358 e2b1                      	ldi r27, TCA_SINGLE_CMP1_bm | TCA_SINGLE_OVF_bm //clear OVF flag
000359 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
00035b 91bf                      	pop r27
00035c bfbf                      	out CPU_SREG, r27
00035d 9518                      	reti
                                 
                                 sound_driver:
00035e b7bf                      	in r27, CPU_SREG
00035f 93bf                      	push r27
000360 94f8                      	cli
000361 93cf                      	push r28
000362 93df                      	push r29
                                 
                                 	//SOUND DRIVER
000363 91a0 280f                 	lds r26, pulse1_pattern_delay
000365 91b0 2810                 	lds r27, pulse1_pattern_delay+1
000367 9610                      	adiw r27:r26, 0
000368 f009                      	breq sound_driver_channel0 //if the pattern delay is 0, proceed with sound driver procedures
000369 c2f7                      	rjmp sound_driver_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 
                                 
                                 sound_driver_channel0:
00036a 91e0 280d                 	lds ZL, pulse1_pattern //current pattern for pulse 1
00036c 91f0 280e                 	lds ZH, pulse1_pattern+1
00036e 91a0 2811                 	lds r26, pulse1_pattern_offset //current offset in the pattern for pulse 1
000370 91b0 2812                 	lds r27, pulse1_pattern_offset+1
000372 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
000373 1ffb                      	adc ZH, r27
000374 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel0_check_if_note: //check if data is a note (0x00 - 0x56)
000375 35b7                      	cpi r27, 0x57
000376 f408                      	brsh sound_driver_channel0_check_if_volume
000377 c15e                      	rjmp sound_driver_channel0_note
                                 sound_driver_channel0_check_if_volume: //check if data is volume (0x57-0x66)
000378 36b7                      	cpi r27, 0x67
000379 f408                      	brsh sound_driver_channel0_check_if_delay
00037a c196                      	rjmp sound_driver_channel0_volume
                                 sound_driver_channel0_check_if_delay: //check if data is a delay (0x67 - 0xE2)
00037b 3eb3                      	cpi r27, 0xE3
00037c f408                      	brsh sound_driver_channel0_check_if_instrument
00037d c19d                      	rjmp sound_driver_channel0_delay
                                 sound_driver_channel0_check_if_instrument: //check for instrument flag (0xE3)
00037e f409                      	brne sound_driver_channel0_check_if_release
00037f c1a0                      	rjmp sound_driver_channel0_instrument_change 
                                 sound_driver_channel0_check_if_release: //check for note release flag (0xE4)
000380 3eb4                      	cpi r27, 0xE4
000381 f409                      	brne sound_driver_channel0_check_if_end
000382 c247                      	rjmp sound_driver_channel0_release
                                 sound_driver_channel0_check_if_end:
000383 3fbf                      	cpi r27, 0xFF
000384 f409                      	brne sound_driver_channel0_check_if_fx
000385 c269                      	rjmp sound_driver_channel0_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel0_check_if_fx: //fx flags (0xE5 - 0xFE)
000386 9631                      	adiw Z, 1 //point Z to the byte next to the flag
000387 91a4                      	lpm r26, Z //load the fx data into r26
000388 d28c                      	rcall sound_driver_channel0_increment_offset_twice
                                 
000389 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
00038a e3ea                      	ldi ZL, LOW(fx << 1) //load in note table
00038b e1f4                      	ldi ZH, HIGH(fx << 1)
00038c 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
00038d 0feb                      	add ZL, r27 //add offset
00038e 1df2                      	adc ZH, zero
00038f 91c5                      	lpm r28, Z+ //load address bytes
000390 91d4                      	lpm r29, Z
000391 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
000392 2ffd                      	mov ZH, r29
000393 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel0_fx_0xy:
000394 93a0 282f                 	sts pulse1_fx_0xy_sequence, r26
000396 9220 2830                 	sts pulse1_fx_0xy_sequence+1, zero
000398 cfd1                      	rjmp sound_driver_channel0
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel0_fx_1xx:
000399 9220 2835                 	sts pulse1_fx_2xx, zero //turn off any 2xx pitch slide down
00039b 9220 2836                 	sts pulse1_fx_2xx+1, zero
00039d 9220 282f                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
00039f 9220 2830                 	sts pulse1_fx_0xy_sequence+1, zero
0003a1 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0003a2 937f                      	push r23
0003a3 2f6a                      	mov r22, r26 //store the rate into r22
0003a4 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0003a5 9f67                      	mul r22, r23
0003a6 917f                      	pop r23
0003a7 916f                      	pop r22
                                 
0003a8 9416                      	lsr r1 //shift out the fractional bits
0003a9 9407                      	ror r0
0003aa 9416                      	lsr r1
0003ab 9407                      	ror r0
0003ac 9416                      	lsr r1
0003ad 9407                      	ror r0
0003ae 9416                      	lsr r1
0003af 9407                      	ror r0
0003b0 9200 2831                 	sts pulse1_fx_1xx, r0
0003b2 9210 2832                 	sts pulse1_fx_1xx+1, r1
0003b4 cfb5                      	rjmp sound_driver_channel0
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel0_fx_2xx:
0003b5 9220 2831                 	sts pulse1_fx_1xx, zero //turn off any 1xx pitch slide down
0003b7 9220 2832                 	sts pulse1_fx_1xx+1, zero
0003b9 9220 282f                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
0003bb 9220 2830                 	sts pulse1_fx_0xy_sequence+1, zero
0003bd 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0003be 937f                      	push r23
0003bf 2f6a                      	mov r22, r26 //store the rate into r22
0003c0 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0003c1 9f67                      	mul r22, r23
0003c2 917f                      	pop r23
0003c3 916f                      	pop r22
                                 
0003c4 9416                      	lsr r1 //shift out the fractional bits
0003c5 9407                      	ror r0
0003c6 9416                      	lsr r1
0003c7 9407                      	ror r0
0003c8 9416                      	lsr r1
0003c9 9407                      	ror r0
0003ca 9416                      	lsr r1
0003cb 9407                      	ror r0
0003cc 9200 2835                 	sts pulse1_fx_2xx, r0
0003ce 9210 2836                 	sts pulse1_fx_2xx+1, r1
0003d0 cf99                      	rjmp sound_driver_channel0
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel0_fx_3xx:
0003d1 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0003d2 937f                      	push r23
0003d3 2f6a                      	mov r22, r26 //store the rate into r22
0003d4 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0003d5 9f67                      	mul r22, r23
0003d6 917f                      	pop r23
0003d7 916f                      	pop r22
                                 
0003d8 9416                      	lsr r1 //shift out the fractional bits
0003d9 9407                      	ror r0
0003da 9416                      	lsr r1
0003db 9407                      	ror r0
0003dc 9416                      	lsr r1
0003dd 9407                      	ror r0
0003de 9416                      	lsr r1
0003df 9407                      	ror r0
0003e0 9200 283d                 	sts pulse1_fx_3xx_speed, r0
0003e2 9210 283e                 	sts pulse1_fx_3xx_speed+1, r1
                                 
0003e4 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
0003e5 c001                      	rjmp sound_driver_channel0_fx_3xx_enabled
0003e6 cf83                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_channel0_fx_3xx_enabled:
0003e7 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
0003e9 91b0 0a8d                 	lds r27, TCB0_CCMPH
0003eb 93a0 2839                 	sts pulse1_fx_3xx_start, r26
0003ed 93b0 283a                 	sts pulse1_fx_3xx_start+1, r27
                                 
0003ef 9220 283f                 	sts pulse1_fx_3xx_total_offset, zero
0003f1 9220 2840                 	sts pulse1_fx_3xx_total_offset+1, zero
0003f3 cf76                      	rjmp sound_driver_channel0
                                 
                                 //VIBRATO
                                 sound_driver_channel0_fx_4xy:
0003f4 2fba                      	mov r27, r26
0003f5 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
0003f6 95a2                      	swap r26
0003f7 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0003f8 93a0 2841                 	sts pulse1_fx_4xy_speed, r26
0003fa 93b0 2842                 	sts pulse1_fx_4xy_depth, r27
0003fc 9220 2843                 	sts pulse1_fx_4xy_phase, zero //reset the phase to 0
0003fe cf6b                      	rjmp sound_driver_channel0
                                 
                                 //TREMELO
                                 sound_driver_channel0_fx_7xy:
0003ff 2fba                      	mov r27, r26
000400 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
000401 95a2                      	swap r26
000402 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
000403 93a0 2844                 	sts pulse1_fx_7xy_speed, r26
000405 93b0 2845                 	sts pulse1_fx_7xy_depth, r27
000407 9220 2846                 	sts pulse1_fx_7xy_phase, zero //reset the phase to 0
000409 9220 2847                 	sts pulse1_fx_7xy_value, zero //reset the tremelo value
00040b cf5e                      	rjmp sound_driver_channel0
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel0_fx_Axy:
00040c 93a0 2848                 	sts pulse1_fx_Axy, r26
00040e cf5b                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_channel0_fx_Bxx: //pattern jump
00040f cf5a                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Cxx: //halt
000410 cf59                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Dxx: //frame skip
000411 cf58                      	rjmp sound_driver_channel0
                                 
                                 //VOLUME
                                 sound_driver_channel0_fx_Exx:
000412 91b0 2800                 	lds r27, pulse1_param
000414 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
000415 2bba                      	or r27, r26 //move new VVVV bits into pulse1_param
000416 93b0 2800                 	sts pulse1_param, r27
000418 6096                      	sbr channel_flags, 6
000419 cf50                      	rjmp sound_driver_channel0
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel0_fx_Fxx:
00041a 93a0 280c                 	sts song_speed, r26 //NOTE: only changes to speed are supported
00041c cf4d                      	rjmp sound_driver_channel0
                                 
                                 //DELAY
                                 sound_driver_channel0_fx_Gxx:
00041d 93a0 2849                 	sts pulse1_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
00041f cf4a                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_channel0_fx_Hxy: //hardware sweep up
000420 95a2                      	swap r26
000421 68a8                      	ori r26, 0b10001000 //enable negate and enable sweep flag
000422 2efa                      	mov pulse1_sweep, r26
000423 92f0 2801                 	sts pulse1_sweep_param, pulse1_sweep
000425 6097                      	sbr channel_flags, 7 //set reload flag
000426 cf43                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_channel0_fx_Ixy: //hardware sweep down
000427 95a2                      	swap r26
000428 77af                      	andi r26, 0b01111111 //disable negate flag
000429 60a8                      	ori r26, 0b00001000 //enable sweep flag
00042a 2efa                      	mov pulse1_sweep, r26
00042b 92f0 2801                 	sts pulse1_sweep_param, pulse1_sweep
00042d 6097                      	sbr channel_flags, 7 //set reload flag
00042e cf3b                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_channel0_fx_Hxx: //FDS modulation depth
00042f cf3a                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Ixx: //FDS modulation speed
000430 cf39                      	rjmp sound_driver_channel0
                                 
                                 //FINE PITCH
                                 sound_driver_channel0_fx_Pxx:
000431 93a0 284b                 	sts pulse1_fx_Pxx, r26
000433 cf36                      	rjmp sound_driver_channel0
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel0_fx_Qxy:
                                 sound_driver_channel0_fx_Qxy_check_arpeggio_macro:
000434 91e0 2818                 	lds ZL, pulse1_arpeggio_macro
000436 91f0 2819                 	lds ZH, pulse1_arpeggio_macro+1
000438 9630                      	adiw Z, 0
000439 f009                      	breq sound_driver_channel0_fx_Qxy_check_pitch_macro
00043a cf2f                      	rjmp sound_driver_channel0 //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_pitch_macro:
00043b 91e0 281f                 	lds ZL, pulse1_pitch_macro
00043d 91f0 2820                 	lds ZH, pulse1_pitch_macro+1
00043f 9630                      	adiw Z, 0
000440 f009                      	breq sound_driver_channel0_fx_Qxy_check_hi_pitch_macro
000441 cf28                      	rjmp sound_driver_channel0 //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_hi_pitch_macro:
000442 91e0 2825                 	lds ZL, pulse1_hi_pitch_macro
000444 91f0 2826                 	lds ZH, pulse1_hi_pitch_macro+1
000446 9630                      	adiw Z, 0
000447 f009                      	breq sound_driver_channel0_fx_Qxy_process
000448 cf21                      	rjmp sound_driver_channel0 //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_process:
000449 2fba                      	mov r27, r26 //copy fx parameters into r27
00044a 70bf                      	andi r27, 0x0F //mask note index offset
00044b 91c0 2807                 	lds r28, pulse1_note //load current note index
00044d 0fbc                      	add r27, r28
00044e 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
00044f f008                      	brlo sound_driver_channel0_fx_Qxy_process_continue
000450 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel0_fx_Qxy_process_continue:
000451 e3e4                      	ldi ZL, LOW(note_table << 1) //load in note table
000452 e0f0                      	ldi ZH, HIGH(note_table << 1)
000453 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
000454 0feb                      	add ZL, r27 //add offset
000455 1df2                      	adc ZH, zero
000456 91c5                      	lpm r28, Z+ //load bytes
000457 91d4                      	lpm r29, Z
000458 93c0 284c                 	sts pulse1_fx_Qxy_target, r28 //load the LOW bits for the target period
00045a 93d0 284d                 	sts pulse1_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
00045c 95a2                      	swap r26
00045d 70af                      	andi r26, 0x0F //mask effect speed
00045e 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
00045f 95a3                      	inc r26 //increment the speed by 1
                                 
000460 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
000461 937f                      	push r23
000462 2f6a                      	mov r22, r26 //store the speed data into r27
000463 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
000464 9f67                      	mul r22, r23
000465 917f                      	pop r23
000466 916f                      	pop r22
                                 
000467 9416                      	lsr r1 //shift out the fractional bits
000468 9407                      	ror r0
000469 9416                      	lsr r1
00046a 9407                      	ror r0
00046b 9416                      	lsr r1
00046c 9407                      	ror r0
00046d 9416                      	lsr r1
00046e 9407                      	ror r0
                                 
00046f 9200 284e                 	sts pulse1_fx_Qxy_speed, r0 //store the effect speed
000471 9210 284f                 	sts pulse1_fx_Qxy_speed+1, r1
000473 9220 2850                 	sts pulse1_fx_Qxy_total_offset, zero
000475 9220 2851                 	sts pulse1_fx_Qxy_total_offset+1, zero
000477 cef2                      	rjmp sound_driver_channel0
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel0_fx_Rxy:
                                 sound_driver_channel0_fx_Rxy_check_arpeggio_macro:
000478 91e0 2818                 	lds ZL, pulse1_arpeggio_macro
00047a 91f0 2819                 	lds ZH, pulse1_arpeggio_macro+1
00047c 9630                      	adiw Z, 0
00047d f009                      	breq sound_driver_channel0_fx_Rxy_check_pitch_macro
00047e ceeb                      	rjmp sound_driver_channel0 //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_pitch_macro:
00047f 91e0 281f                 	lds ZL, pulse1_pitch_macro
000481 91f0 2820                 	lds ZH, pulse1_pitch_macro+1
000483 9630                      	adiw Z, 0
000484 f009                      	breq sound_driver_channel0_fx_Rxy_check_hi_pitch_macro
000485 cee4                      	rjmp sound_driver_channel0 //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_hi_pitch_macro:
000486 91e0 2825                 	lds ZL, pulse1_hi_pitch_macro
000488 91f0 2826                 	lds ZH, pulse1_hi_pitch_macro+1
00048a 9630                      	adiw Z, 0
00048b f009                      	breq sound_driver_channel0_fx_Rxy_process
00048c cedd                      	rjmp sound_driver_channel0 //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_process:
00048d 2fba                      	mov r27, r26 //copy fx parameters into r27
00048e 70bf                      	andi r27, 0x0F //mask note index offset
00048f 91c0 2807                 	lds r28, pulse1_note //load current note index
000491 1bcb                      	sub r28, r27
000492 f408                      	brcc sound_driver_channel0_fx_Rxy_process_continue
000493 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel0_fx_Rxy_process_continue:
000494 e3e4                      	ldi ZL, LOW(note_table << 1) //load in note table
000495 e0f0                      	ldi ZH, HIGH(note_table << 1)
000496 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
000497 0fec                      	add ZL, r28 //add offset
000498 1df2                      	adc ZH, zero
000499 91c5                      	lpm r28, Z+ //load bytes
00049a 91d4                      	lpm r29, Z
00049b 93c0 2852                 	sts pulse1_fx_Rxy_target, r28 //load the LOW bits for the target period
00049d 93d0 2853                 	sts pulse1_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
00049f 95a2                      	swap r26
0004a0 70af                      	andi r26, 0x0F //mask effect speed
0004a1 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0004a2 95a3                      	inc r26 //increment the speed by 1
                                 
0004a3 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0004a4 937f                      	push r23
0004a5 2f6a                      	mov r22, r26 //store the speed data into r27
0004a6 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0004a7 9f67                      	mul r22, r23
0004a8 917f                      	pop r23
0004a9 916f                      	pop r22
                                 
0004aa 9416                      	lsr r1 //shift out the fractional bits
0004ab 9407                      	ror r0
0004ac 9416                      	lsr r1
0004ad 9407                      	ror r0
0004ae 9416                      	lsr r1
0004af 9407                      	ror r0
0004b0 9416                      	lsr r1
0004b1 9407                      	ror r0
                                 
0004b2 9200 2854                 	sts pulse1_fx_Rxy_speed, r0 //store the effect speed
0004b4 9210 2855                 	sts pulse1_fx_Rxy_speed+1, r1
0004b6 9220 2856                 	sts pulse1_fx_Rxy_total_offset, zero
0004b8 9220 2857                 	sts pulse1_fx_Rxy_total_offset+1, zero
0004ba ceaf                      	rjmp sound_driver_channel0
                                 
                                 //MUTE DELAY
                                 sound_driver_channel0_fx_Sxx:
0004bb 93a0 2858                 	sts pulse1_fx_Sxx_pre, r26
0004bd ceac                      	rjmp sound_driver_channel0
                                 
                                 //DUTY
                                 sound_driver_channel0_fx_Vxx:
0004be e3e6                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
0004bf e1f4                      	ldi ZH, HIGH(sequences << 1)
0004c0 0fea                      	add ZL, r26 //offset the pointer
0004c1 1df2                      	adc ZH, zero
                                 
0004c2 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
0004c3 95a7                      	ror r26
0004c4 95a7                      	ror r26
0004c5 91b0 2800                 	lds r27, pulse1_param //load r27 with pulse1_param (register $4000)
0004c7 2fcb                      	mov r28, r27 //store a copy of pulse1_param into r28
0004c8 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
0004c9 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
0004ca c001                      	rjmp sound_driver_channel0_fx_Vxx_store
0004cb ce9e                      	rjmp sound_driver_channel0 //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel0_fx_Vxx_store:
0004cc 90d4                      	lpm pulse1_sequence, Z //store the sequence
                                 
0004cd 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
0004ce 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
0004cf 93c0 2800                 	sts pulse1_param, r28
0004d1 ce98                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_channel0_fx_Wxx: //DPCM sample speed
0004d2 ce97                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Xxx: //DPCM sample retrigger
0004d3 ce96                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Yxx: //DPCM sample offset
0004d4 ce95                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Zxx: //DPCM sample delta counter
0004d5 ce94                      	rjmp sound_driver_channel0
                                 
                                 
                                 sound_driver_channel0_note:
0004d6 93b0 2807                 	sts pulse1_note, r27 //store the note index
0004d8 e0a3                      	ldi r26, 0x03
0004d9 e0b2                      	ldi r27, 0x02
0004da 93b0 2815                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
0004dc 93a0 281a                 	sts pulse1_arpeggio_macro_offset, r26
0004de 93b0 2821                 	sts pulse1_pitch_macro_offset, r27
0004e0 93b0 2827                 	sts pulse1_hi_pitch_macro_offset, r27
0004e2 93b0 282c                 	sts pulse1_duty_macro_offset, r27
0004e4 9220 281e                 	sts pulse1_total_pitch_offset, zero //reset the pitch and hi pitch offset
0004e6 9220 2824                 	sts pulse1_total_hi_pitch_offset, zero
0004e8 9220 2833                 	sts pulse1_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
0004ea 9220 2834                 	sts pulse1_fx_1xx_total+1, zero
0004ec 9220 2837                 	sts pulse1_fx_2xx_total, zero
0004ee 9220 2838                 	sts pulse1_fx_2xx_total+1, zero
0004f0 9220 283f                 	sts pulse1_fx_3xx_total_offset, zero //reset 3xx offset
0004f2 9220 2840                 	sts pulse1_fx_3xx_total_offset+1, zero
0004f4 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
0004f6 91b0 0a8d                 	lds r27, TCB0_CCMPH
0004f8 93a0 2839                 	sts pulse1_fx_3xx_start, r26
0004fa 93b0 283a                 	sts pulse1_fx_3xx_start+1, r27
0004fc 9220 2801                 	sts pulse1_sweep_param, zero //reset any sweep effect
0004fe 6097                      	sbr channel_flags, 7 //set reload flag
0004ff 9220 284c                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
000501 9220 284d                 	sts pulse1_fx_Qxy_target+1, zero
000503 9220 2850                 	sts pulse1_fx_Qxy_total_offset, zero
000505 9220 2851                 	sts pulse1_fx_Qxy_total_offset+1, zero
000507 9220 2852                 	sts pulse1_fx_Rxy_target, zero
000509 9220 2853                 	sts pulse1_fx_Rxy_target+1, zero
00050b 9220 2856                 	sts pulse1_fx_Rxy_total_offset, zero
00050d 9220 2857                 	sts pulse1_fx_Rxy_total_offset+1, zero
00050f d0fb                      	rcall sound_driver_channel0_increment_offset
000510 ce59                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0_volume:
000511 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
000512 91a0 2800                 	lds r26, pulse1_param
000514 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
000515 2bab                      	or r26, r27 //move new VVVV bits into pulse1_param
000516 93a0 2800                 	sts pulse1_param, r26
000518 6096                      	sbr channel_flags, 6
000519 d0f1                      	rcall sound_driver_channel0_increment_offset
00051a ce4f                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0_delay:
00051b 56b7                      	subi r27, 0x67 //NOTE: the delay values are offset by the highest volume value, which is 0x66
00051c 93b0 280f                 	sts pulse1_pattern_delay, r27
00051e d0ec                      	rcall sound_driver_channel0_increment_offset
00051f c0ff                      	rjmp sound_driver_calculate_delays
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change:
000520 9220 2813                 	sts pulse1_volume_macro, zero //reset all macro addresses
000522 9220 2814                 	sts pulse1_volume_macro+1, zero
000524 9220 2818                 	sts pulse1_arpeggio_macro, zero
000526 9220 2819                 	sts pulse1_arpeggio_macro+1, zero
000528 9220 281f                 	sts pulse1_pitch_macro, zero
00052a 9220 2820                 	sts pulse1_pitch_macro+1, zero
00052c 9220 2825                 	sts pulse1_hi_pitch_macro, zero
00052e 9220 2826                 	sts pulse1_hi_pitch_macro+1, zero
000530 9220 282a                 	sts pulse1_duty_macro, zero
000532 9220 282b                 	sts pulse1_duty_macro+1, zero
000534 9220 281e                 	sts pulse1_total_pitch_offset, zero //reset the pitch offset
000536 9220 2824                 	sts pulse1_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
000538 9631                      	adiw Z, 1 //point to the byte next to the flag
000539 91b4                      	lpm r27, Z //store the instrument offset into r27
00053a e0eb                      	ldi ZL, LOW(instruments) //point Z to instruments table
00053b e0f2                      	ldi ZH, HIGH(instruments)
00053c 0feb                      	add ZL, r27 //point Z to offsetted instrument
00053d 1df2                      	adc ZH, zero
00053e 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
00053f 1fff                      	rol ZH
000540 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
000541 91b4                      	lpm r27, Z
                                 
000542 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
000543 1fbb                      	rol r27
000544 2fea                      	mov ZL, r26
000545 2ffb                      	mov ZH, r27
000546 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
000547 9632                      	adiw Z, 2 //point Z to the address of the macro
000548 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel0_instrument_change_macro_loop:
000549 95aa                      	dec r26
00054a f019                      	breq sound_driver_channel0_instrument_change_exit
00054b 95b6                      	lsr r27
00054c f078                      	brcs sound_driver_channel0_instrument_change_load_macro
00054d cffb                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_exit:
00054e e0a3                      	ldi r26, 0x03
00054f e0b2                      	ldi r27, 0x02
000550 93b0 2815                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
000552 93a0 281a                 	sts pulse1_arpeggio_macro_offset, r26
000554 93b0 2821                 	sts pulse1_pitch_macro_offset, r27
000556 93b0 2827                 	sts pulse1_hi_pitch_macro_offset, r27
000558 93b0 282c                 	sts pulse1_duty_macro_offset, r27
00055a d0ba                      	rcall sound_driver_channel0_increment_offset_twice
00055b ce0e                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_load_macro:
00055c 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
00055d 91d5                      	lpm r29, Z+
                                 
00055e 30a5                      	cpi r26, 5
00055f f039                      	breq sound_driver_channel0_instrument_change_load_macro_volume
000560 30a4                      	cpi r26, 4
000561 f079                      	breq sound_driver_channel0_instrument_change_load_macro_arpeggio
000562 30a3                      	cpi r26, 3
000563 f0d9                      	breq sound_driver_channel0_instrument_change_load_macro_pitch
000564 30a2                      	cpi r26, 2
000565 f159                      	breq sound_driver_channel0_instrument_change_load_macro_hi_pitch
000566 c03c                      	rjmp sound_driver_channel0_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel0_instrument_change_load_macro_volume:
000567 93c0 2813                 	sts pulse1_volume_macro, r28
000569 93d0 2814                 	sts pulse1_volume_macro+1, r29
00056b d041                      	rcall sound_driver_channel0_instrument_change_read_header
00056c 93c0 2817                 	sts pulse1_volume_macro_release, r28
00056e 93d0 2816                 	sts pulse1_volume_macro_loop, r29
000570 cfd8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 	
                                 sound_driver_channel0_instrument_change_load_macro_arpeggio:
000571 93c0 2818                 	sts pulse1_arpeggio_macro, r28
000573 93d0 2819                 	sts pulse1_arpeggio_macro+1, r29
000575 9220 284c                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
000577 9220 284d                 	sts pulse1_fx_Qxy_target+1, zero
000579 9220 2852                 	sts pulse1_fx_Rxy_target, zero
00057b 9220 2853                 	sts pulse1_fx_Rxy_target+1, zero
00057d d03a                      	rcall sound_driver_channel0_instrument_change_read_header_arpeggio
00057e cfca                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_pitch:
00057f 93c0 281f                 	sts pulse1_pitch_macro, r28
000581 93d0 2820                 	sts pulse1_pitch_macro+1, r29
000583 9220 284c                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
000585 9220 284d                 	sts pulse1_fx_Qxy_target+1, zero
000587 9220 2852                 	sts pulse1_fx_Rxy_target, zero
000589 9220 2853                 	sts pulse1_fx_Rxy_target+1, zero
00058b d021                      	rcall sound_driver_channel0_instrument_change_read_header
00058c 93c0 2823                 	sts pulse1_pitch_macro_release, r28
00058e 93d0 2822                 	sts pulse1_pitch_macro_loop, r29
000590 cfb8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_hi_pitch:
000591 93c0 2825                 	sts pulse1_hi_pitch_macro, r28
000593 93d0 2826                 	sts pulse1_hi_pitch_macro+1, r29
000595 9220 284c                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
000597 9220 284d                 	sts pulse1_fx_Qxy_target+1, zero
000599 9220 2852                 	sts pulse1_fx_Rxy_target, zero
00059b 9220 2853                 	sts pulse1_fx_Rxy_target+1, zero
00059d d00f                      	rcall sound_driver_channel0_instrument_change_read_header
00059e 93c0 2829                 	sts pulse1_hi_pitch_macro_release, r28
0005a0 93d0 2828                 	sts pulse1_hi_pitch_macro_loop, r29
0005a2 cfa6                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_duty:
0005a3 93c0 282a                 	sts pulse1_duty_macro, r28
0005a5 93d0 282b                 	sts pulse1_duty_macro+1, r29
0005a7 d005                      	rcall sound_driver_channel0_instrument_change_read_header
0005a8 93c0 282e                 	sts pulse1_duty_macro_release, r28
0005aa 93d0 282d                 	sts pulse1_duty_macro_loop, r29
0005ac cf9c                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_read_header:
0005ad 93ef                      	push ZL
0005ae 93ff                      	push ZH
0005af 2fec                      	mov ZL, r28
0005b0 2ffd                      	mov ZH, r29
0005b1 0fee                      	lsl ZL
0005b2 1fff                      	rol ZH
0005b3 91c5                      	lpm r28, Z+
0005b4 91d4                      	lpm r29, Z
0005b5 91ff                      	pop ZH
0005b6 91ef                      	pop ZL
0005b7 9508                      	ret
                                 
                                 sound_driver_channel0_instrument_change_read_header_arpeggio:
0005b8 93ef                      	push ZL
0005b9 93ff                      	push ZH
0005ba 2fec                      	mov ZL, r28
0005bb 2ffd                      	mov ZH, r29
0005bc 0fee                      	lsl ZL
0005bd 1fff                      	rol ZH
0005be 91c5                      	lpm r28, Z+
0005bf 91d5                      	lpm r29, Z+
0005c0 93c0 281c                 	sts pulse1_arpeggio_macro_release, r28
0005c2 93d0 281b                 	sts pulse1_arpeggio_macro_loop, r29
0005c4 91c4                      	lpm r28, Z
0005c5 93c0 281d                 	sts pulse1_arpeggio_macro_mode, r28
0005c7 91ff                      	pop ZH
0005c8 91ef                      	pop ZL
0005c9 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel0_release:
                                 sound_driver_channel0_release_volume:
0005ca 91b0 2817                 	lds r27, pulse1_volume_macro_release
0005cc 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
0005cd f019                      	breq sound_driver_channel0_release_arpeggio //if the macro has no release flag, check the next macro
0005ce 95b3                      	inc r27
0005cf 93b0 2815                 	sts pulse1_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel0_release_arpeggio:
0005d1 91b0 281c                 	lds r27, pulse1_arpeggio_macro_release
0005d3 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
0005d4 f019                      	breq sound_driver_channel0_release_pitch
0005d5 95b3                      	inc r27
0005d6 93b0 281a                 	sts pulse1_arpeggio_macro_offset, r27
                                 sound_driver_channel0_release_pitch:
0005d8 91b0 2823                 	lds r27, pulse1_pitch_macro_release
0005da 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
0005db f019                      	breq sound_driver_channel0_release_hi_pitch
0005dc 95b3                      	inc r27
0005dd 93b0 2821                 	sts pulse1_pitch_macro_offset, r27
                                 sound_driver_channel0_release_hi_pitch:
0005df 91b0 2829                 	lds r27, pulse1_hi_pitch_macro_release
0005e1 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
0005e2 f019                      	breq sound_driver_channel0_release_duty
0005e3 95b3                      	inc r27
0005e4 93b0 2827                 	sts pulse1_hi_pitch_macro_offset, r27
                                 sound_driver_channel0_release_duty:
0005e6 91b0 282e                 	lds r27, pulse1_duty_macro_release
0005e8 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
0005e9 f019                      	breq sound_driver_channel0_release_exit
0005ea 95b3                      	inc r27
0005eb 93b0 282c                 	sts pulse1_duty_macro_offset, r27
                                 sound_driver_channel0_release_exit:
0005ed d01d                      	rcall sound_driver_channel0_increment_offset
0005ee cd7b                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0_next_pattern:
0005ef 91e0 2808                 	lds ZL, song_frames
0005f1 91f0 2809                 	lds ZH, song_frames+1
0005f3 91a0 280a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
0005f5 91b0 280b                 	lds r27, song_frame_offset+1
0005f7 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
0005f8 93a0 280a                 	sts song_frame_offset, r26
0005fa 93b0 280b                 	sts song_frame_offset+1, r27
                                 	//adiw r27:r26, 2 //offset for channel 1 (test)
0005fc 0fea                      	add ZL, r26
0005fd 1ffb                      	adc ZH, r27
                                 
0005fe 91a5                      	lpm r26, Z+ //load the address of the next pattern
0005ff 91b4                      	lpm r27, Z
000600 0faa                      	lsl r26
000601 1fbb                      	rol r27
000602 93a0 280d                 	sts pulse1_pattern, r26
000604 93b0 280e                 	sts pulse1_pattern+1, r27
                                 
000606 9220 2811                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
000608 9220 2812                 	sts pulse1_pattern_offset+1, zero
00060a cd5f                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0_increment_offset:
00060b 91e0 2811                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
00060d 91f0 2812                 	lds ZH, pulse1_pattern_offset+1
00060f 9631                      	adiw Z, 1
000610 93e0 2811                 	sts pulse1_pattern_offset, ZL
000612 93f0 2812                 	sts pulse1_pattern_offset+1, ZH
000614 9508                      	ret
                                 
                                 sound_driver_channel0_increment_offset_twice: //used for data that takes up 2 bytes worth of space
000615 91e0 2811                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
000617 91f0 2812                 	lds ZH, pulse1_pattern_offset+1
000619 9632                      	adiw Z, 2 //increment the pointer twice
00061a 93e0 2811                 	sts pulse1_pattern_offset, ZL
00061c 93f0 2812                 	sts pulse1_pattern_offset+1, ZH
00061e 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_calculate_delays:
00061f 936f                      	push r22
000620 937f                      	push r23
000621 9160 280c                 	lds r22, song_speed
000623 2fa6                      	mov r26, r22
000624 50a1                      	subi r26, 1
000625 2fda                      	mov r29, r26
                                 
                                 sound_driver_calculate_delays_pulse1:
                                 sound_driver_calculate_delays_pulse1_Sxx:
000626 91b0 2858                 	lds r27, pulse1_fx_Sxx_pre
000628 91c0 2859                 	lds r28, pulse1_fx_Sxx_post
00062a 9220 2858                  	sts pulse1_fx_Sxx_pre, zero
00062c 15b2                      	cp r27, zero
00062d f051                      	breq sound_driver_calculate_delays_pulse1_Sxx_post
00062e 17b6                      	cp r27, r22 //compare the Gxx fx to the song speed
00062f f440                      	brsh sound_driver_calculate_delays_pulse1_Sxx_post
000630 93b0 280f                 	sts pulse1_pattern_delay, r27
000632 9220 2810                 	sts pulse1_pattern_delay+1, zero
000634 1bdb                      	sub r29, r27 //(song speed)-1-Sxx
000635 93d0 2859                 	sts pulse1_fx_Sxx_post, r29
000637 c026                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_post:
000638 15c2                      	cp r28, zero
000639 f021                      	breq sound_driver_calculate_delays_pulse1_Gxx
00063a 9220 2859                 	sts pulse1_fx_Sxx_post, zero
00063c 2fac                      	mov r26, r28
00063d c00c                      	rjmp sound_driver_calculate_delays_pulse1_main
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx:
00063e 91b0 2849                 	lds r27, pulse1_fx_Gxx_pre
000640 91c0 284a                 	lds r28, pulse1_fx_Gxx_post
000642 17b6                      	cp r27, r22 //compare the Gxx fx to the song speed
000643 f018                      	brlo sound_driver_calculate_delays_pulse1_Gxx_post
000644 e0b0                      	ldi r27, 0 //if the Gxx effect exceeds one row (the song speed), then reset the effect to 0
000645 9220 2849                 	sts pulse1_fx_Gxx_pre, zero
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx_post:
000647 15c2                      	cp r28, zero
000648 f009                      	breq sound_driver_calculate_delays_pulse1_main
000649 2fac                      	mov r26, r28 //if there was a Gxx, use its post instead of the (song speed)-1
                                 	
                                 sound_driver_calculate_delays_pulse1_main:
00064a 9170 280f                 	lds r23, pulse1_pattern_delay
00064c 9f67                      	mul r22, r23
00064d 0e0a                      	add r0, r26
00064e 1c12                      	adc r1, zero
00064f 0e0b                      	add r0, r27
000650 1c12                      	adc r1, zero
000651 9200 280f                 	sts pulse1_pattern_delay, r0
000653 9210 2810                 	sts pulse1_pattern_delay+1, r1
000655 9220 284a                 	sts pulse1_fx_Gxx_post, zero
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx_pre:
000657 15b2                      	cp r27, zero //check if the Gxx effect was enabled
000658 f029                      	breq sound_driver_calculate_delays_pulse2
000659 1bdb                      	sub r29, r27 //(song speed)-1-Gxx
00065a 93a0 284a                 	sts pulse1_fx_Gxx_post, r26
00065c 9220 2849                 	sts pulse1_fx_Gxx_pre, zero
                                 
                                 sound_driver_calculate_delays_pulse2:
                                 sound_driver_calculate_delays_pulse2_Gxx:
00065e 917f                      	pop r23
00065f 916f                      	pop r22
000660 c006                      	rjmp sound_driver_instrument_routine
                                 
                                 
                                 
                                 sound_driver_decrement_frame_delay:
000661 50a1                      	subi r26, 1
000662 09b2                      	sbc r27, zero
000663 93a0 280f                 	sts pulse1_pattern_delay, r26
000665 93b0 2810                 	sts pulse1_pattern_delay+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine:
                                 sound_driver_instrument_routine_channel0_volume:
000667 91e0 2813                 	lds ZL, pulse1_volume_macro
000669 91f0 2814                 	lds ZH, pulse1_volume_macro+1
00066b 9630                      	adiw Z, 0
00066c f1a1                      	breq sound_driver_instrument_routine_channel0_volume_default //if no volume macro is in use, use default multiplier of F
00066d 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
00066e 1fff                      	rol ZH
00066f 91a0 2815                 	lds r26, pulse1_volume_macro_offset
000671 0fea                      	add ZL, r26
000672 1df2                      	adc ZH, zero
                                 
000673 91b0 2817                 	lds r27, pulse1_volume_macro_release
000675 17ba                      	cp r27, r26
000676 f429                      	brne sound_driver_instrument_routine_channel0_volume_increment //if the current offset is not equal to the release index, increment the offset
000677 91a0 2816                 	lds r26, pulse1_volume_macro_loop
000679 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00067a f010                      	brlo sound_driver_instrument_routine_channel0_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00067b c003                      	rjmp sound_driver_instrument_routine_channel0_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_volume_increment:
00067c 95a3                      	inc r26 //increment the macro offset
00067d 93a0 2815                 	sts pulse1_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_volume_read:
00067f 91b4                      	lpm r27, Z //load volume data into r27
000680 3fbf                      	cpi r27, 0xFF //check for macro end flag
000681 f469                      	brne sound_driver_instrument_routine_channel0_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_release:
000682 91b0 2817                 	lds r27, pulse1_volume_macro_release
000684 3fbf                      	cpi r27, 0xFF
000685 f429                      	brne sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_loop:
000686 91b0 2816                 	lds r27, pulse1_volume_macro_loop //load the loop index
000688 93b0 2815                 	sts pulse1_volume_macro_offset, r27 //store the loop index into the offset
00068a cfdc                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index:
00068b 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
00068c 93a0 2815                 	sts pulse1_volume_macro_offset, r26
00068e cfd8                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_calculate:
00068f e6ee                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
000690 e1f4                      	ldi ZH, HIGH(volumes << 1)
000691 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
000692 0feb                      	add ZL, r27 //add offset to the table
000693 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel0_volume_load:
000694 91b0 2800                 	lds r27, pulse1_param //load main volume
000696 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
000697 91a0 2847                 	lds r26, pulse1_fx_7xy_value
000699 30a0                      	cpi r26, 0x00
00069a f481                      	brne sound_driver_instrument_routine_channel0_volume_load_7xy
                                 
00069b 0feb                      	add ZL, r27 //offset the volume table by the main volume
00069c 1df2                      	adc ZH, zero
00069d 91b4                      	lpm r27, Z
00069e 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
0006a0 c024                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default:
0006a1 91b0 2800                 	lds r27, pulse1_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
0006a3 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
0006a4 91a0 2847                 	lds r26, pulse1_fx_7xy_value
0006a6 30a0                      	cpi r26, 0x00
0006a7 f4a1                      	brne sound_driver_instrument_routine_channel0_volume_default_7xy
0006a8 93b0 2806                 	sts pulse1_output_volume, r27
0006aa c01a                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy:
0006ab 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
0006ac f040                      	brcs sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
0006ad f039                      	breq sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
0006ae e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
                                 
0006af 0feb                      	add ZL, r27 //offset the volume table by the main volume
0006b0 1df2                      	adc ZH, zero
0006b1 91b4                      	lpm r27, Z
0006b2 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
0006b4 c010                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy_overflow:
0006b5 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
0006b6 0feb                      	add ZL, r27 //offset the volume table by the main volume
0006b7 1df2                      	adc ZH, zero
0006b8 91b4                      	lpm r27, Z
0006b9 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
0006bb c009                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default_7xy:
0006bc 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
0006bd f020                      	brcs sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
0006be f019                      	breq sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
0006bf 93b0 2806                 	sts pulse1_output_volume, r27
0006c1 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel0_volume_default_7xy_overflow:
0006c2 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
0006c3 93b0 2806                 	sts pulse1_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
0006c5 91e0 2818                 	lds ZL, pulse1_arpeggio_macro
0006c7 91f0 2819                 	lds ZH, pulse1_arpeggio_macro+1
0006c9 9630                      	adiw Z, 0
0006ca f1d9                      	breq sound_driver_instrument_routine_channel0_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
0006cb 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0006cc 1fff                      	rol ZH
0006cd 91a0 281a                 	lds r26, pulse1_arpeggio_macro_offset
0006cf 0fea                      	add ZL, r26
0006d0 1df2                      	adc ZH, zero
                                 
0006d1 91b0 281c                 	lds r27, pulse1_arpeggio_macro_release
0006d3 17ba                      	cp r27, r26
0006d4 f429                      	brne sound_driver_instrument_routine_channel0_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
0006d5 91a0 281b                 	lds r26, pulse1_arpeggio_macro_loop
0006d7 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0006d8 f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
0006d9 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_increment:
0006da 95a3                      	inc r26 //increment the macro offset
0006db 93a0 281a                 	sts pulse1_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_read:
0006dd 91b4                      	lpm r27, Z //load arpeggio data into r27
0006de 38b0                      	cpi r27, 0x80 //check for macro end flag
0006df f009                      	breq sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag
0006e0 c041                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_check_mode:
0006e1 50a1                      	subi r26, 1 //keep the offset at the end flag
0006e2 93a0 281a                 	sts pulse1_arpeggio_macro_offset, r26
0006e4 91b0 281d                 	lds r27, pulse1_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
0006e6 30b1                      	cpi r27, 0x01
0006e7 f048                      	brlo sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_release:
0006e8 91b0 281c                 	lds r27, pulse1_arpeggio_macro_release
0006ea 3fbf                      	cpi r27, 0xFF
0006eb f4d1                      	brne sound_driver_instrument_routine_channel0_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_loop:
0006ec 91b0 281b                 	lds r27, pulse1_arpeggio_macro_loop
0006ee 3fbf                      	cpi r27, 0xFF
0006ef f499                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
0006f0 c015                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute:
0006f1 91b0 281c                 	lds r27, pulse1_arpeggio_macro_release
0006f3 3fbf                      	cpi r27, 0xFF
0006f4 f421                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_check_loop:
0006f5 91b0 281b                 	lds r27, pulse1_arpeggio_macro_loop //load the loop index
0006f7 3fbf                      	cpi r27, 0xFF //check if loop flag exists
0006f8 f451                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop:
0006f9 91c0 282f                 	lds r28, pulse1_fx_0xy_sequence //check for 0xy effect
0006fb 91d0 2830                 	lds r29, pulse1_fx_0xy_sequence+1
0006fd 9620                      	adiw r29:r28, 0
0006fe f469                      	brne sound_driver_instrument_routine_channel0_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
0006ff 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
000700 93a0 281a                 	sts pulse1_arpeggio_macro_offset, r26 //store the last valid index into the offset
000702 cfc2                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload:
000703 93b0 281a                 	sts pulse1_arpeggio_macro_offset, r27 //store the loop index into the offset
000705 cfbf                      	rjmp sound_driver_instrument_routine_channel0_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_default:
000706 91c0 282f                 	lds r28, pulse1_fx_0xy_sequence //load 0xy effect
000708 91d0 2830                 	lds r29, pulse1_fx_0xy_sequence+1
00070a 9620                      	adiw r29:r28, 0 //check for 0xy effect
00070b f099                      	breq sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel0_arpeggio_default_xy:
00070c 95d6                      	lsr r29
00070d 95c7                      	ror r28
00070e 95d7                      	ror r29
00070f 95c7                      	ror r28
000710 95d7                      	ror r29
000711 95c7                      	ror r28
000712 95d7                      	ror r29
000713 95c7                      	ror r28
000714 95d7                      	ror r29
000715 95d2                      	swap r29
                                 
000716 93c0 282f                 	sts pulse1_fx_0xy_sequence, r28 //store the rolled sequence
000718 93d0 2830                 	sts pulse1_fx_0xy_sequence+1, r29
00071a 70cf                      	andi r28, 0x0F //mask out the 4 LSB
00071b 91a0 2807                 	lds r26, pulse1_note //load the current note index
00071d 0fac                      	add r26, r28 //add the note offset
00071e c02c                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
00071f 91a0 2807                 	lds r26, pulse1_note //load the current note index
000721 c029                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process:
000722 9220 281e                 	sts pulse1_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
000724 9220 2824                 	sts pulse1_total_hi_pitch_offset, zero
000726 91a0 281d                 	lds r26, pulse1_arpeggio_macro_mode
000728 30a1                      	cpi r26, 0x01 //absolute mode
000729 f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_absolute
00072a f069                      	breq sound_driver_instrument_routine_channel0_arpeggio_process_fixed
00072b c00e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute:
00072c 91a0 2807                 	lds r26, pulse1_note //load the current note index
00072e 0fab                      	add r26, r27 //offset the note with the arpeggio data
00072f fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
000730 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_add:
000731 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
000732 f0c0                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
000733 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
000734 c016                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract:
000735 fda7                      	sbrc r26, 7 //check if result is negative
000736 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
000737 c013                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_fixed:
000738 2fab                      	mov r26, r27 //move the arpeggio data into r26
000739 c011                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative:
00073a 91a0 2807                 	lds r26, pulse1_note //load the current note index
00073c 0fab                      	add r26, r27 //offset the note with the arpeggio data
00073d fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
00073e c008                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_add:
00073f 93a0 2807                 	sts pulse1_note, r26 //NOTE: relative mode modifies the original note index
000741 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
000742 f040                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
000743 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
000744 93a0 2807                 	sts pulse1_note, r26
000746 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract:
000747 fda7                      	sbrc r26, 7 //check if result is negative
000748 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
000749 93a0 2807                 	sts pulse1_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_load:
00074b e3e4                      	ldi ZL, LOW(note_table << 1) //load in note table
00074c e0f0                      	ldi ZH, HIGH(note_table << 1)
00074d 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
00074e 0fea                      	add ZL, r26 //add offset
00074f 1df2                      	adc ZH, zero
000750 91a5                      	lpm r26, Z+ //load bytes
000751 91b4                      	lpm r27, Z
000752 93a0 0a8c                 	sts TCB0_CCMPL, r26 //load the LOW bits for timer
000754 93b0 0a8d                 	sts TCB0_CCMPH, r27 //load the HIGH bits for timer
000756 93a0 283b                 	sts pulse1_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
000758 93b0 283c                 	sts pulse1_fx_3xx_target+1, r27
00075a c000                      	rjmp sound_driver_instrument_routine_channel0_pitch
                                 
                                 
                                 
                                 //NOTE: There is a limitation with the pitch routines in that the total pitch can not be offset by 127 in both,
                                 //the positive and negative direction, from the original note pitch. This shouldn't be too much of a problem as
                                 //most songs that use instruments with the pitch macro, do not stray that far from the original note pitch.
                                 //In the case of hi pitch, the total pitch can not be offset by 127*16 from the original pitch. This is also
                                 //not a big deal as you can easily reach the entire note range with an offset of up to 127*16.
                                 sound_driver_instrument_routine_channel0_pitch:
00075b 91e0 281f                 	lds ZL, pulse1_pitch_macro
00075d 91f0 2820                 	lds ZH, pulse1_pitch_macro+1
00075f 9630                      	adiw Z, 0
000760 f409                      	brne sound_driver_instrument_routine_channel0_pitch_continue
000761 c023                      	rjmp sound_driver_instrument_routine_channel0_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel0_pitch_continue:
000762 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
000763 1fff                      	rol ZH
000764 91a0 2821                 	lds r26, pulse1_pitch_macro_offset
000766 0fea                      	add ZL, r26
000767 1df2                      	adc ZH, zero
                                 
000768 91b0 2823                 	lds r27, pulse1_pitch_macro_release
00076a 17ba                      	cp r27, r26
00076b f429                      	brne sound_driver_instrument_routine_channel0_pitch_increment //if the current offset is not equal to the release index, increment the offset
00076c 91a0 2822                 	lds r26, pulse1_pitch_macro_loop
00076e 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00076f f010                      	brlo sound_driver_instrument_routine_channel0_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
000770 c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_pitch_increment:
000771 95a3                      	inc r26 //increment the macro offset
000772 93a0 2821                 	sts pulse1_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_pitch_read:
000774 91b4                      	lpm r27, Z //load pitch data into r27
000775 38b0                      	cpi r27, 0x80 //check for macro end flag
000776 f489                      	brne sound_driver_instrument_routine_channel0_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_release:
000777 50a1                      	subi r26, 1 //keep the macro offset at the end flag
000778 93a0 2821                 	sts pulse1_pitch_macro_offset, r26
00077a 91b0 2823                 	lds r27, pulse1_pitch_macro_release
00077c 3fbf                      	cpi r27, 0xFF
00077d f439                      	brne sound_driver_instrument_routine_channel0_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_loop:
00077e 91b0 2822                 	lds r27, pulse1_pitch_macro_loop //load the loop index
000780 3fbf                      	cpi r27, 0xFF //check if there is a loop index
000781 f019                      	breq sound_driver_instrument_routine_channel0_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
000782 93b0 2821                 	sts pulse1_pitch_macro_offset, r27 //store the loop index into the offset
000784 cfd6                      	rjmp sound_driver_instrument_routine_channel0_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_default:
000785 91b0 281e                 	lds r27, pulse1_total_pitch_offset
000787 c005                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate:
000788 91a0 281e                 	lds r26, pulse1_total_pitch_offset //load the total pitch offset to change
00078a 0fba                      	add r27, r26
00078b 93b0 281e                 	sts pulse1_total_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_multiply:
                                 	//NOTE: The Pxx effect is processed with the pitch instrument macro because the calculations are the same
00078d 91a0 284b                 	lds r26, pulse1_fx_Pxx
00078f 0fba                      	add r27, r26
                                 
000790 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
000791 937f                      	push r23
000792 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
000793 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
000794 0367                      	mulsu r22, r23
000795 917f                      	pop r23
000796 916f                      	pop r22
                                 
000797 9416                      	lsr r1 //shift out the fractional bits
000798 9407                      	ror r0
000799 9416                      	lsr r1
00079a 9407                      	ror r0
00079b 9416                      	lsr r1
00079c 9407                      	ror r0
00079d 9416                      	lsr r1
00079e 9407                      	ror r0
00079f fe13                      	sbrs r1, 3 //check if result was a negative number
0007a0 c002                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_negative:
0007a1 efb0                      	ldi r27, 0xF0
0007a2 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_offset:
0007a3 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
0007a5 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
0007a7 0da0                      	add r26, r0 //offset the timer values
0007a8 1db1                      	adc r27, r1
                                 	
0007a9 91c0 2833                 	lds r28, pulse1_fx_1xx_total
0007ab 91d0 2834                 	lds r29, pulse1_fx_1xx_total+1
0007ad 1bac                      	sub r26, r28
0007ae 0bbd                      	sbc r27, r29
0007af 91c0 2837                 	lds r28, pulse1_fx_2xx_total
0007b1 91d0 2838                 	lds r29, pulse1_fx_2xx_total+1
0007b3 0fac                      	add r26, r28
0007b4 1fbd                      	adc r27, r29
0007b5 91c0 2850                 	lds r28, pulse1_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
0007b7 91d0 2851                 	lds r29, pulse1_fx_Qxy_total_offset+1
0007b9 1bac                      	sub r26, r28
0007ba 0bbd                      	sbc r27, r29
0007bb 91c0 2856                 	lds r28, pulse1_fx_Rxy_total_offset
0007bd 91d0 2857                 	lds r29, pulse1_fx_Rxy_total_offset+1
0007bf 0fac                      	add r26, r28
0007c0 1fbd                      	adc r27, r29
                                 
0007c1 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
0007c3 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel0_hi_pitch:
0007c5 91e0 2825                 	lds ZL, pulse1_hi_pitch_macro
0007c7 91f0 2826                 	lds ZH, pulse1_hi_pitch_macro+1
0007c9 9630                      	adiw Z, 0
0007ca f409                      	brne sound_driver_instrument_routine_channel0_hi_pitch_continue
0007cb c03c                      	rjmp sound_driver_instrument_routine_channel0_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel0_hi_pitch_continue:
0007cc 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0007cd 1fff                      	rol ZH
0007ce 91a0 2827                 	lds r26, pulse1_hi_pitch_macro_offset
0007d0 0fea                      	add ZL, r26
0007d1 1df2                      	adc ZH, zero
                                 
0007d2 91b0 2829                 	lds r27, pulse1_hi_pitch_macro_release
0007d4 17ba                      	cp r27, r26
0007d5 f429                      	brne sound_driver_instrument_routine_channel0_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
0007d6 91a0 2828                 	lds r26, pulse1_hi_pitch_macro_loop
0007d8 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0007d9 f010                      	brlo sound_driver_instrument_routine_channel0_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0007da c003                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_increment:
0007db 95a3                      	inc r26 //increment the macro offset
0007dc 93a0 2827                 	sts pulse1_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_hi_pitch_read:
0007de 91b4                      	lpm r27, Z //load hi pitch data into r27
0007df 38b0                      	cpi r27, 0x80 //check for macro end flag
0007e0 f489                      	brne sound_driver_instrument_routine_channel0_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_release:
0007e1 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0007e2 93a0 2827                 	sts pulse1_hi_pitch_macro_offset, r26
0007e4 91b0 2829                 	lds r27, pulse1_hi_pitch_macro_release
0007e6 3fbf                      	cpi r27, 0xFF
0007e7 f439                      	brne sound_driver_instrument_routine_channel0_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_loop:
0007e8 91b0 2828                 	lds r27, pulse1_hi_pitch_macro_loop //load the loop index
0007ea 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0007eb f019                      	breq sound_driver_instrument_routine_channel0_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
0007ec 93b0 2827                 	sts pulse1_hi_pitch_macro_offset, r27 //store the loop index into the offset
0007ee cfd6                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_default:
0007ef 91b0 2824                 	lds r27, pulse1_total_hi_pitch_offset
0007f1 c005                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate:
0007f2 91a0 2824                 	lds r26, pulse1_total_hi_pitch_offset //load the total hi pitch offset to change
0007f4 0fba                      	add r27, r26
0007f5 93b0 2824                 	sts pulse1_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply:
0007f7 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0007f8 937f                      	push r23
0007f9 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
0007fa eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0007fb 0367                      	mulsu r22, r23
0007fc 917f                      	pop r23
0007fd 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_offset:
0007fe 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
000800 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
000802 0da0                      	add r26, r0 //offset the timer values
000803 1db1                      	adc r27, r1
000804 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
000806 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel0_duty:
000808 91e0 282a                 	lds ZL, pulse1_duty_macro
00080a 91f0 282b                 	lds ZH, pulse1_duty_macro+1
00080c 9630                      	adiw Z, 0
00080d f1b1                      	breq sound_driver_channel0_fx_routines //if no duty macro is in use, go to the next routine
00080e 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00080f 1fff                      	rol ZH
000810 91a0 282c                 	lds r26, pulse1_duty_macro_offset
000812 0fea                      	add ZL, r26
000813 1df2                      	adc ZH, zero
                                 
000814 91b0 282e                 	lds r27, pulse1_duty_macro_release
000816 17ba                      	cp r27, r26
000817 f429                      	brne sound_driver_instrument_routine_channel0_duty_increment //if the current offset is not equal to the release index, increment the offset
000818 91a0 282d                 	lds r26, pulse1_duty_macro_loop
00081a 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00081b f010                      	brlo sound_driver_instrument_routine_channel0_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00081c c027                      	rjmp sound_driver_channel0_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel0_duty_increment:
00081d 95a3                      	inc r26 //increment the macro offset
00081e 93a0 282c                 	sts pulse1_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_duty_read:
000820 91b4                      	lpm r27, Z //load pitch data into r27
000821 3fbf                      	cpi r27, 0xFF //check for macro end flag
000822 f471                      	brne sound_driver_instrument_routine_channel0_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_release:
000823 50a1                      	subi r26, 1 //keep the macro offset at the end flag
000824 93a0 282c                 	sts pulse1_duty_macro_offset, r26
000826 91b0 282e                 	lds r27, pulse1_duty_macro_release
000828 3fbf                      	cpi r27, 0xFF
000829 f4d1                      	brne sound_driver_channel0_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_loop:
00082a 91b0 282d                 	lds r27, pulse1_duty_macro_loop //load the loop index
00082c 3fbf                      	cpi r27, 0xFF //check if there is a loop index
00082d f0b1                      	breq sound_driver_channel0_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
00082e 93b0 282c                 	sts pulse1_duty_macro_offset, r27 //store the loop index into the offset
000830 cfd7                      	rjmp sound_driver_instrument_routine_channel0_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_load:
000831 e3e6                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
000832 e1f4                      	ldi ZH, HIGH(sequences << 1)
000833 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
000834 1df2                      	adc ZH, zero
                                 
000835 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
000836 95b7                      	ror r27
000837 95b7                      	ror r27
000838 91a0 2800                 	lds r26, pulse1_param //load r26 with pulse1_param (register $4000)
00083a 2fca                      	mov r28, r26 //store a copy of pulse1_param into r28
00083b 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
00083c 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
00083d c001                      	rjmp sound_driver_instrument_routine_channel0_duty_load_store
00083e c005                      	rjmp sound_driver_channel0_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel0_duty_load_store:
00083f 90d4                      	lpm pulse1_sequence, Z //store the sequence
                                 
000840 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
000841 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
000842 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_routines:
                                 sound_driver_channel0_fx_1xx_routine:
000844 91e0 2831                 	lds ZL, pulse1_fx_1xx
000846 91f0 2832                 	lds ZH, pulse1_fx_1xx+1
000848 9630                      	adiw Z, 0
000849 f051                      	breq sound_driver_channel0_fx_2xx_routine
                                 
00084a 91a0 2833                 	lds r26, pulse1_fx_1xx_total //load the rate to change the pitch by
00084c 91b0 2834                 	lds r27, pulse1_fx_1xx_total+1
00084e 0fae                      	add r26, ZL //increase the total offset by the rate
00084f 1fbf                      	adc r27, ZH
000850 93a0 2833                 	sts pulse1_fx_1xx_total, r26
000852 93b0 2834                 	sts pulse1_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_2xx_routine:
000854 91e0 2835                 	lds ZL, pulse1_fx_2xx
000856 91f0 2836                 	lds ZH, pulse1_fx_2xx+1
000858 9630                      	adiw Z, 0
000859 f051                      	breq sound_driver_channel0_fx_3xx_routine
                                 
00085a 91a0 2837                 	lds r26, pulse1_fx_2xx_total //load the rate to change the pitch by
00085c 91b0 2838                 	lds r27, pulse1_fx_2xx_total+1
00085e 0fae                      	add r26, ZL //increase the total offset by the rate
00085f 1fbf                      	adc r27, ZH
000860 93a0 2837                 	sts pulse1_fx_2xx_total, r26
000862 93b0 2838                 	sts pulse1_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_3xx_routine:
000864 91e0 283d                 	lds ZL, pulse1_fx_3xx_speed
000866 91f0 283e                 	lds ZH, pulse1_fx_3xx_speed+1
000868 9630                      	adiw Z, 0
000869 f409                      	brne sound_driver_channel0_fx_3xx_routine_check_start
00086a c048                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_check_start:
00086b 91a0 2839                 	lds r26, pulse1_fx_3xx_start
00086d 91b0 283a                 	lds r27, pulse1_fx_3xx_start+1
00086f 9610                      	adiw r26:r27, 0
000870 f409                      	brne sound_driver_channel0_fx_3xx_routine_main
000871 c041                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_main:
000872 91c0 283b                 	lds r28, pulse1_fx_3xx_target
000874 91d0 283c                 	lds r29, pulse1_fx_3xx_target+1
                                 
000876 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
000877 07bd                      	cpc r27, r29
000878 f011                      	breq sound_driver_channel0_fx_3xx_routine_disable
000879 f030                      	brlo sound_driver_channel0_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
00087a c01f                      	rjmp sound_driver_channel0_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel0_fx_3xx_routine_disable:
00087b 9220 2839                 	sts pulse1_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
00087d 9220 283a                 	sts pulse1_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
00087f c033                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_subtract:
000880 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
000881 0bdb                      	sbc r29, r27
000882 91a0 283f                 	lds r26, pulse1_fx_3xx_total_offset
000884 91b0 2840                 	lds r27, pulse1_fx_3xx_total_offset+1
                                 
000886 0fae                      	add r26, ZL //add the speed to the total offset
000887 1fbf                      	adc r27, ZH
000888 1bca                      	sub r28, r26 //invert the total difference with the total offset
000889 0bdb                      	sbc r29, r27
00088a f380                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
00088b 93a0 283f                 	sts pulse1_fx_3xx_total_offset, r26 //store the new total offset
00088d 93b0 2840                 	sts pulse1_fx_3xx_total_offset+1, r27
                                 
00088f 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the current timer period
000891 91b0 0a8d                 	lds r27, TCB0_CCMPH
000893 1bac                      	sub r26, r28 //offset the current timer period with the total offset
000894 0bbd                      	sbc r27, r29
000895 93a0 0a8c                 	sts TCB0_CCMPL, r26
000897 93b0 0a8d                 	sts TCB0_CCMPH, r27
000899 c019                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_add:
00089a 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
00089b 0bbd                      	sbc r27, r29
00089c 91c0 283f                 	lds r28, pulse1_fx_3xx_total_offset
00089e 91d0 2840                 	lds r29, pulse1_fx_3xx_total_offset+1
                                 
0008a0 0fce                      	add r28, ZL //add the speed to the total offset
0008a1 1fdf                      	adc r29, ZH
0008a2 1bac                      	sub r26, r28 //invert the total difference with the total offset
0008a3 0bbd                      	sbc r27, r29
0008a4 f2b0                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0008a5 93c0 283f                 	sts pulse1_fx_3xx_total_offset, r28 //store the new total offset
0008a7 93d0 2840                 	sts pulse1_fx_3xx_total_offset+1, r29
                                 
0008a9 91c0 0a8c                 	lds r28, TCB0_CCMPL //load the current timer period
0008ab 91d0 0a8d                 	lds r29, TCB0_CCMPH
0008ad 0fca                      	add r28, r26 //offset the current timer period with the total offset
0008ae 1fdb                      	adc r29, r27
0008af 93c0 0a8c                 	sts TCB0_CCMPL, r28
0008b1 93d0 0a8d                 	sts TCB0_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel0_fx_4xy_routine:
0008b3 91a0 2841                 	lds r26, pulse1_fx_4xy_speed
0008b5 15a2                      	cp r26, zero
0008b6 f409                      	brne sound_driver_channel0_fx_4xy_routine_continue
0008b7 c05c                      	rjmp sound_driver_channel0_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel0_fx_4xy_routine_continue:
0008b8 91b0 2842                 	lds r27, pulse1_fx_4xy_depth
0008ba 91c0 2843                 	lds r28, pulse1_fx_4xy_phase
0008bc 0fca                      	add r28, r26 //increase the phase by the speed
0008bd 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
0008be f008                      	brlo sound_driver_channel0_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
0008bf 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase:
0008c0 93c0 2843                 	sts pulse1_fx_4xy_phase, r28 //store the new phase
0008c2 31c0                      	cpi r28, 16
0008c3 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_0
0008c4 32c0                      	cpi r28, 32
0008c5 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_1
0008c6 33c0                      	cpi r28, 48
0008c7 f030                      	brlo sound_driver_channel0_fx_4xy_routine_phase_2
0008c8 c007                      	rjmp sound_driver_channel0_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_0:
0008c9 70cf                      	andi r28, 0x0F //mask for values 0-15
0008ca c029                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_1:
0008cb 6fc0                      	ori r28, 0xF0
0008cc 95c0                      	com r28 //invert values 0-15
0008cd c026                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_2:
0008ce 70cf                      	andi r28, 0x0F //mask for values 0-15
0008cf c003                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_3:
0008d0 6fc0                      	ori r28, 0xF0
0008d1 95c0                      	com r28 //invert values 0-15
0008d2 c000                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_add:
0008d3 95b2                      	swap r27 //multiply depth by 16
0008d4 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0008d5 eee2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0008d6 e0f0                      	ldi ZH, HIGH(vibrato_table << 1)
0008d7 0fec                      	add ZL, r28 //offset the table by the depth+phase
0008d8 1df2                      	adc ZH, zero
0008d9 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
0008da 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0008db 937f                      	push r23
0008dc 2f6c                      	mov r22, r28 //store the vibrato value into r22
0008dd eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0008de 9f67                      	mul r22, r23
0008df 917f                      	pop r23
0008e0 916f                      	pop r22
                                 
0008e1 9416                      	lsr r1 //shift out the fractional bits
0008e2 9407                      	ror r0
0008e3 9416                      	lsr r1
0008e4 9407                      	ror r0
0008e5 9416                      	lsr r1
0008e6 9407                      	ror r0
0008e7 9416                      	lsr r1
0008e8 9407                      	ror r0
                                 	
0008e9 91a0 0a8c                 	lds r26, TCB0_CCMPL
0008eb 91b0 0a8d                 	lds r27, TCB0_CCMPH
0008ed 0da0                      	add r26, r0
0008ee 1db1                      	adc r27, r1
0008ef 93a0 0a8c                 	sts TCB0_CCMPL, r26
0008f1 93b0 0a8d                 	sts TCB0_CCMPH, r27
0008f3 c020                      	rjmp sound_driver_channel0_fx_7xy_routine
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_subtract:
0008f4 95b2                      	swap r27 //multiply depth by 16
0008f5 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
0008f6 eee2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0008f7 e0f0                      	ldi ZH, HIGH(vibrato_table << 1)
0008f8 0fec                      	add ZL, r28 //offset the table by the depth+phase
0008f9 1df2                      	adc ZH, zero
0008fa 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
0008fb 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0008fc 937f                      	push r23
0008fd 2f6c                      	mov r22, r28 //store the vibrato value into r22
0008fe eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0008ff 9f67                      	mul r22, r23
000900 917f                      	pop r23
000901 916f                      	pop r22
                                 
000902 9416                      	lsr r1 //shift out the fractional bits
000903 9407                      	ror r0
000904 9416                      	lsr r1
000905 9407                      	ror r0
000906 9416                      	lsr r1
000907 9407                      	ror r0
000908 9416                      	lsr r1
000909 9407                      	ror r0
                                 
00090a 91a0 0a8c                 	lds r26, TCB0_CCMPL
00090c 91b0 0a8d                 	lds r27, TCB0_CCMPH
00090e 19a0                      	sub r26, r0
00090f 09b1                      	sbc r27, r1
000910 93a0 0a8c                 	sts TCB0_CCMPL, r26
000912 93b0 0a8d                 	sts TCB0_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_7xy_routine:
000914 91a0 2844                 	lds r26, pulse1_fx_7xy_speed
000916 15a2                      	cp r26, zero
000917 f0f1                      	breq sound_driver_channel0_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
000918 91b0 2845                 	lds r27, pulse1_fx_7xy_depth
00091a 91c0 2846                 	lds r28, pulse1_fx_7xy_phase
00091c 0fca                      	add r28, r26 //increase the phase by the speed
00091d 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
00091e f010                      	brlo sound_driver_channel0_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
00091f e0c0                      	ldi r28, 0x00
000920 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase:
000921 93c0 2846                 	sts pulse1_fx_7xy_phase, r28 //store the new phase
000923 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
000924 ffc4                      	sbrs r28, 4
000925 c001                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_0
000926 c002                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel0_fx_7xy_routine_phase_0:
000927 70cf                      	andi r28, 0x0F //mask for values 0-15
000928 c003                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase_1:
000929 6fc0                      	ori r28, 0xF0
00092a 95c0                      	com r28 //invert values 0-15
00092b c000                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_load:
00092c 95b2                      	swap r27 //multiply depth by 16
00092d 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
00092e eee2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00092f e0f0                      	ldi ZH, HIGH(vibrato_table << 1)
000930 0fec                      	add ZL, r28 //offset the table by the depth+phase
000931 1df2                      	adc ZH, zero
000932 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
000933 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
000934 93c0 2847                 	sts pulse1_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Axy_routine:
000936 91b0 2848                 	lds r27, pulse1_fx_Axy
000938 15b2                      	cp r27, zero
000939 f0e9                      	breq sound_driver_channel0_fx_Qxy_routine //0 means that the effect is not in use
                                 	
00093a 91a0 2805                 	lds r26, pulse1_fractional_volume //load fractional volume representation of the channel
00093c 91c0 2800                 	lds r28, pulse1_param //load the integer volume representation of the channel
00093e 2fda                      	mov r29, r26 //copy fractional volume into r29
00093f 2fec                      	mov r30, r28 //copy the pulse1_param into r30
000940 95e2                      	swap r30
000941 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
000942 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
000943 17ed                      	cp r30, r29 //compare the fractional and integer volumes
000944 f009                      	breq sound_driver_channel0_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel0_fx_Axy_routine_reload:
000945 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate:
000946 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
000947 c004                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_addition:
000948 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
000949 f428                      	brcc sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
00094a efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
00094b c003                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_subtraction:
00094c 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
00094d f008                      	brcs sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
00094e e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_store:
00094f 93a0 2805                 	sts pulse1_fractional_volume, r26 //store the new fractional volume
000951 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
000952 95a2                      	swap r26
000953 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
000954 2bca                      	or r28, r26 //store the new volume back into pulse1_param
000955 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel0_fx_Qxy_routine:
000957 91e0 284c                 	lds ZL, pulse1_fx_Qxy_target
000959 91f0 284d                 	lds ZH, pulse1_fx_Qxy_target+1
00095b 9630                      	adiw Z, 0
00095c f131                      	breq sound_driver_channel0_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
00095d 91a0 2850                 	lds r26, pulse1_fx_Qxy_total_offset
00095f 91b0 2851                 	lds r27, pulse1_fx_Qxy_total_offset+1
000961 91c0 0a8c                 	lds r28, TCB0_CCMPL
000963 91d0 0a8d                 	lds r29, TCB0_CCMPH
000965 1bca                      	sub r28, r26 //subtract the timer period by the total offset
000966 0bdb                      	sbc r29, r27
                                 
000967 17ce                      	cp r28, ZL //compare the new timer period with the target
000968 07df                      	cpc r29, ZH
000969 f010                      	brlo sound_driver_channel0_fx_Qxy_routine_end //if the target has been reached (or passed)
00096a f009                      	breq sound_driver_channel0_fx_Qxy_routine_end
00096b f468                      	brsh sound_driver_channel0_fx_Qxy_routine_add
                                 
                                 sound_driver_channel0_fx_Qxy_routine_end:
00096c 1bec                      	sub ZL, r28 //calculate the difference to the target
00096d 0bfd                      	sbc ZH, r29
00096e 0fae                      	add r26, ZL //increase the total offset to the exact amount needed to reach the target
00096f 1fbf                      	adc r27, ZH
000970 93a0 2850                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
000972 93b0 2851                 	sts pulse1_fx_Qxy_total_offset+1, r27
000974 9220 284c                 	sts pulse1_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
000976 9220 284d                 	sts pulse1_fx_Qxy_target+1, zero
000978 c00a                      	rjmp sound_driver_channel0_fx_Rxy_routine
                                 
                                 sound_driver_channel0_fx_Qxy_routine_add:
000979 91c0 284e                 	lds r28, pulse1_fx_Qxy_speed
00097b 91d0 284f                 	lds r29, pulse1_fx_Qxy_speed+1
00097d 0fac                      	add r26, r28 //increase the total offset by the speed
00097e 1fbd                      	adc r27, r29
00097f 93a0 2850                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
000981 93b0 2851                 	sts pulse1_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Rxy_routine:
000983 91e0 2852                 	lds ZL, pulse1_fx_Rxy_target
000985 91f0 2853                 	lds ZH, pulse1_fx_Rxy_target+1
000987 9630                      	adiw Z, 0
000988 f131                      	breq sound_driver_channel0_fx_xy_routine //if the effect is not enabled, skip the routine
                                 
000989 91a0 2856                 	lds r26, pulse1_fx_Rxy_total_offset
00098b 91b0 2857                 	lds r27, pulse1_fx_Rxy_total_offset+1
00098d 91c0 0a8c                 	lds r28, TCB0_CCMPL
00098f 91d0 0a8d                 	lds r29, TCB0_CCMPH
000991 0fca                      	add r28, r26 //add the total offset to the timer period
000992 0fdb                      	add r29, r27
                                 
000993 17ce                      	cp r28, ZL //compare the new timer period with the target
000994 07df                      	cpc r29, ZH
000995 f010                      	brlo sound_driver_channel0_fx_Rxy_routine_end //if the target has been reached (or passed)
000996 f009                      	breq sound_driver_channel0_fx_Rxy_routine_end
000997 f468                      	brsh sound_driver_channel0_fx_Rxy_routine_add
                                 
                                 sound_driver_channel0_fx_Rxy_routine_end:
000998 1bec                      	sub ZL, r28 //calculate the difference to the target
000999 0bfd                      	sbc ZH, r29
00099a 0fae                      	add r26, ZL //increase the total offset to the exact amount needed to reach the target
00099b 1fbf                      	adc r27, ZH
00099c 93a0 2856                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
00099e 93b0 2857                 	sts pulse1_fx_Rxy_total_offset+1, r27
0009a0 9220 2852                 	sts pulse1_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
0009a2 9220 2853                 	sts pulse1_fx_Rxy_target+1, zero
0009a4 c00a                      	rjmp sound_driver_channel0_fx_xy_routine
                                 
                                 sound_driver_channel0_fx_Rxy_routine_add:
0009a5 91c0 2854                 	lds r28, pulse1_fx_Rxy_speed
0009a7 91d0 2855                 	lds r29, pulse1_fx_Rxy_speed+1
0009a9 0fac                      	add r26, r28 //increase the total offset by the speed
0009aa 1fbd                      	adc r27, r29
0009ab 93a0 2856                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
0009ad 93b0 2857                 	sts pulse1_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 sound_driver_channel0_fx_xy_routine:
                                 
                                 sound_driver_exit:
0009af 91df                      	pop r29
0009b0 91cf                      	pop r28
0009b1 c99f                      	rjmp sequence_1_3 + 3 //+3 is to skip the stack instructions since we already pushed them
                                 
                                 //PULSE 1 ROUTINES
                                 pulse1_sequence_routine:
0009b2 b7bf                      	in r27, CPU_SREG
0009b3 93bf                      	push r27
0009b4 94f8                      	cli
                                 
0009b5 0cdd                      	lsl pulse1_sequence //shifts sequence to the left
0009b6 1cd2                      	adc pulse1_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
0009b7 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
0009b8 93b0 0a86                 	sts TCB0_INTFLAGS, r27
0009ba 91bf                      	pop r27
0009bb bfbf                      	out CPU_SREG, r27
0009bc 9518                      	reti
                                 
                                 pulse1_sweep_routine:
0009bd 2dbf                      	mov r27, pulse1_sweep
0009be 70b7                      	andi r27, 0x07 //mask for period divider bits
0009bf f4f9                      	brne pulse1_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse1_sweep_routine_action: //if the divider is == 0, update the pulse timer period
0009c0 93df                      	push r29
0009c1 2ddf                      	mov r29, pulse1_sweep
0009c2 95d2                      	swap r29
0009c3 70d7                      	andi r29, 0x07 //mask for shift bits
0009c4 f411                      	brne pulse1_sweep_routine_action_main //shift != 0
0009c5 91df                      	pop r29
0009c6 c019                      	rjmp pulse1_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse1_sweep_routine_action_main:
0009c7 91a0 0a8c                 	lds r26, TCB0_CCMPL
0009c9 91b0 0a8d                 	lds r27, TCB0_CCMPH
                                 pulse1_sweep_routine_action_main_loop:
0009cb 95b6                      	lsr r27
0009cc 95a7                      	ror r26
0009cd 95da                      	dec r29
0009ce f7e1                      	brne pulse1_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
0009cf fef7                      	sbrs pulse1_sweep, 7 //check the negate flag
0009d0 c002                      	rjmp pulse1_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
0009d1 95a0                      	com r26 //pulse1 uses one's complement if the negate flag is set
0009d2 95b0                      	com r27
                                 
                                 pulse1_sweep_routine_action_main_add:
0009d3 91d0 0a8c                 	lds r29, TCB0_CCMPL //perform addition to get new timer period
0009d5 0fad                      	add r26, r29
0009d6 91d0 0a8d                 	lds r29, TCB0_CCMPH
0009d8 1fbd                      	adc r27, r29
                                 
0009d9 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new LOW bits for timer
0009db 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new HIGH bits for timer
                                 
                                 	//sts pulse1_timerL, r26
                                 	//sts pulse1_timerH, r27
                                 
                                 /*	//Sweep Test
                                 	mov r29, pulse1_sweep //invert the negate bit
                                 	ldi r27, 0b10000000
                                 	eor r29, r27
                                 	ori r29, 0b01111111
                                 
                                 	lds r27, pulse1_sweep_param //reload the pulse sweep divider params
                                 	swap r27
                                 	ori r27, 0b10000000
                                 	and r27, r29
                                 	mov pulse1_sweep, r27
                                 	sbr channel_flags, 0b10000000*/
                                 	
0009dd 91df                      	pop r29
0009de c001                      	rjmp pulse1_sweep_routine_check_reload
                                 
                                 pulse1_sweep_routine_decrement_divider:
0009df 94fa                      	dec pulse1_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse1_sweep_routine_check_reload:
0009e0 ff97                      	sbrs channel_flags, 7 //if the reload flag is set, reload the sweep divider
0009e1 9508                      	ret
                                 
                                 pulse1_sweep_reload:
0009e2 90f0 2801                 	lds pulse1_sweep, pulse1_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
0009e4 94f2                      	swap pulse1_sweep //bring data from high byte to low byte
0009e5 779f                      	cbr channel_flags, 0b10000000 //clear reload flag
0009e6 9508                      	ret
                                 
                                 pulse1_envelope_routine:
0009e7 fd96                      	sbrc channel_flags, 6 //check if start flag is cleared
0009e8 c010                      	rjmp pulse1_envelope_routine_clear_start
                                 
0009e9 3000                      	cpi pulse1_volume_divider, 0x00 //check if the divider is 0
0009ea f011                      	breq PC+3 //if the divider == 0, check loop flag
0009eb 950a                      	dec pulse1_volume_divider //if the divider != 0, decrement and return
0009ec 9508                      	ret
                                 
0009ed 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the divider == 0, reset the divider period
0009ef 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
0009f0 ff95                      	sbrs channel_flags, 5 //check if the loop flag is set
0009f1 c002                      	rjmp pulse1_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
0009f2 e01f                      	ldi pulse1_volume_decay, 0x0F //if the loop flag is set, reset decay and return
0009f3 9508                      	ret
                                 
                                 pulse1_envelope_routine_decrement_decay:
0009f4 3010                      	cpi pulse1_volume_decay, 0x00 //check if the decay is 0
0009f5 f409                      	brne PC+2 //if decay != 0, go decrement
0009f6 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
0009f7 951a                      	dec pulse1_volume_decay
0009f8 9508                      	ret
                                 
                                 pulse1_envelope_routine_clear_start:
0009f9 7b9f                      	cbr channel_flags, 0b01000000 //if the start flag is set, clear it
0009fa 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the start flag is set, reset the divider period
0009fc 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
0009fd e01f                      	ldi pulse1_volume_decay, 0x0F //if the start flag is set, reset decay
0009fe 9508                      	ret
                                 
                                 //CONVERTERS (TABLES)
                                 //converts and loads 5 bit length to corresponding 8 bit length value into r29
                                 length_converter:
0009ff e0ea                      	ldi ZL, LOW(length << 1)
000a00 e1f4                      	ldi ZH, HIGH(length << 1)
000a01 0fed                      	add ZL, r29
000a02 1df2                      	adc ZH, zero
000a03 91d4                      	lpm r29, Z
000a04 9508                      	ret
                                 
000a05 7f05
000a06 010a
000a07 0214
000a08 0328
000a09 0450
000a0a 051e
000a0b 0607
000a0c 070d
000a0d 0806
000a0e 090c
000a0f 0a18
000a10 0b30
000a11 0c60
000a12 0d24
000a13 0e08
000a14 0f10                      length: .db $05, $7F, $0A, $01, $14, $02, $28, $03, $50, $04, $1E, $05, $07, $06, $0D, $07, $06, $08, $0C, $09, $18, $0A, $30, $0B, $60, $0C, $24, $0D, $08, $0E, $10, $0F
                                 
                                 //loads pulse sequence into r29
                                 duty_cycle_sequences:
000a15 e3e6                      	ldi ZL, LOW(sequences << 1)
000a16 e1f4                      	ldi ZH, HIGH(sequences << 1)
000a17 0fed                      	add ZL, r29
000a18 1df2                      	adc ZH, zero
000a19 91d4                      	lpm r29, Z
000a1a 9508                      	ret
                                 
                                 //pulse sequences: 12.5%, 25%, 50%, 75%
000a1b 0301
000a1c fc0f                      sequences: .db 0b00000001, 0b00000011, 0b00001111, 0b11111100
                                 
                                 //list of famitracker fx: http://famitracker.com/wiki/index.php?title=Effect_list
                                 fx:
000a1d 0394
000a1e 0399
000a1f 03b5
000a20 03d1
000a21 03f4                      	.dw sound_driver_channel0_fx_0xy, sound_driver_channel0_fx_1xx, sound_driver_channel0_fx_2xx, sound_driver_channel0_fx_3xx, sound_driver_channel0_fx_4xy
000a22 03ff
000a23 040c
000a24 040f
000a25 0410
000a26 0411                      	.dw sound_driver_channel0_fx_7xy, sound_driver_channel0_fx_Axy, sound_driver_channel0_fx_Bxx, sound_driver_channel0_fx_Cxx, sound_driver_channel0_fx_Dxx
000a27 0412
000a28 041a
000a29 041d
000a2a 0420
000a2b 0427                      	.dw sound_driver_channel0_fx_Exx, sound_driver_channel0_fx_Fxx, sound_driver_channel0_fx_Gxx, sound_driver_channel0_fx_Hxy, sound_driver_channel0_fx_Ixy
000a2c 042f
000a2d 0430
000a2e 0431
000a2f 0434
000a30 0478                      	.dw sound_driver_channel0_fx_Hxx, sound_driver_channel0_fx_Ixx, sound_driver_channel0_fx_Pxx, sound_driver_channel0_fx_Qxy, sound_driver_channel0_fx_Rxy
000a31 04bb
000a32 04be
000a33 04d2
000a34 04d3
000a35 04d4                      	.dw sound_driver_channel0_fx_Sxx, sound_driver_channel0_fx_Vxx, sound_driver_channel0_fx_Wxx, sound_driver_channel0_fx_Xxx, sound_driver_channel0_fx_Yxx
000a36 04d5                      	.dw sound_driver_channel0_fx_Zxx
                                 
                                 //famitracker volumes table: http://famitracker.com/wiki/index.php?title=Volume
                                 volumes:
000a37 0000
000a38 0000
000a39 0000
000a3a 0000
000a3b 0000
000a3c 0000
000a3d 0000
000a3e 0000                      	.db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
000a3f 0100
000a40 0101
000a41 0101
000a42 0101
000a43 0101
000a44 0101
000a45 0101
000a46 0101                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
000a47 0100
000a48 0101
000a49 0101
000a4a 0101
000a4b 0101
000a4c 0101
000a4d 0101
000a4e 0201                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02
000a4f 0100
000a50 0101
000a51 0101
000a52 0101
000a53 0101
000a54 0202
000a55 0202
000a56 0302                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03
000a57 0100
000a58 0101
000a59 0101
000a5a 0101
000a5b 0202
000a5c 0202
000a5d 0303
000a5e 0403                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04
000a5f 0100
000a60 0101
000a61 0101
000a62 0202
000a63 0302
000a64 0303
000a65 0404
000a66 0504                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05
000a67 0100
000a68 0101
000a69 0201
000a6a 0202
000a6b 0303
000a6c 0404
000a6d 0504
000a6e 0605                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x06
000a6f 0100
000a70 0101
000a71 0201
000a72 0302
000a73 0403
000a74 0504
000a75 0605
000a76 0706                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07
000a77 0100
000a78 0101
000a79 0202
000a7a 0303
000a7b 0404
000a7c 0505
000a7d 0606
000a7e 0807                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07, 0x08
000a7f 0100
000a80 0101
000a81 0302
000a82 0403
000a83 0504
000a84 0606
000a85 0707
000a86 0908                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09
000a87 0100
000a88 0201
000a89 0302
000a8a 0404
000a8b 0605
000a8c 0706
000a8d 0808
000a8e 0a09                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A
000a8f 0100
000a90 0201
000a91 0302
000a92 0504
000a93 0605
000a94 0807
000a95 0908
000a96 0b0a                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B
000a97 0100
000a98 0201
000a99 0403
000a9a 0504
000a9b 0706
000a9c 0808
000a9d 0a09
000a9e 0c0b                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B, 0x0C
000a9f 0100
000aa0 0201
000aa1 0403
000aa2 0605
000aa3 0706
000aa4 0908
000aa5 0b0a
000aa6 0d0c                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D
000aa7 0100
000aa8 0201
000aa9 0403
000aaa 0605
000aab 0807
000aac 0a09
000aad 0c0b
000aae 0e0d                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E
000aaf 0100
000ab0 0302
000ab1 0504
000ab2 0706
000ab3 0908
000ab4 0b0a
000ab5 0d0c


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega4809" register use summary:
x  :   0 y  :   0 z  :  61 r0 :  44 r1 :  46 r2 : 183 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 
r13:   6 r14:   4 r15:  13 r16:   7 r17:   6 r18:   0 r19:   0 r20:   0 
r21:   0 r22:  43 r23:  40 r24:   0 r25:  15 r26: 247 r27: 363 r28: 136 
r29: 102 r30:  92 r31:  87 
Registers used: 18 out of 35 (51.4%)

"ATmega4809" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  42 add   :  57 adiw  :  26 and   :   0 
andi  :  32 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   2 brcs  :   4 break :   0 breq  :  45 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  24 brlt  :   0 brmi  :   0 
brne  :  32 brpl  :   0 brsh  :   7 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :   0 cbr   :   2 
clc   :   0 clh   :   0 cli   :   4 cln   :   0 clr   :   1 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :   5 cp    :  24 cpc   :   3 
cpi   :  48 cpse  :   4 dec   :   6 des   :   0 eor   :   0 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   1 in    :   4 inc   :  12 
jmp   :   6 ld    :   0 ldd   :   0 ldi   :  86 lds   : 183 lpm   :  68 
lsl   :  19 lsr   :  39 mov   :  37 movw  :   0 mul   :   8 muls  :   0 
mulsu :   2 neg   :   0 nop   :   0 or    :   6 ori   :   5 out   :   6 
pop   :  31 push  :  31 rcall :  16 ret   :  13 reti  :   3 rjmp  : 128 
rol   :  13 ror   :  45 sbc   :  12 sbci  :   0 sbi   :   0 sbic  :   0 
sbis  :   0 sbiw  :   0 sbr   :   7 sbrc  :   8 sbrs  :   6 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   : 344 sub   :  16 subi  :  13 swap  :  16 tst   :   0 wdr   :   0 

Instructions used: 51 out of 114 (44.7%)

"ATmega4809" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x00156e   4116   1342   5458   49152  11.1%
[.dseg] 0x002800 0x00285e      0     94     94    6144   1.5%
[.eseg] 0x000000 0x000000      0      0      0     256   0.0%

Assembly complete, 0 errors, 8 warnings
