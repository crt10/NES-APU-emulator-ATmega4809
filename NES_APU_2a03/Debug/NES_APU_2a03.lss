
AVRASM ver. 2.2.8  C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm Sat Jan 23 23:03:39 2021

C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
                                 
                                 
                                 ; NES_APU_2a03.asm
                                 ;
                                 ; Created: 11/29/2020 1:44:10 AM
                                 ; Author : Tennyson Cheng
                                 ;
                                 
                                 .list
                                 
                                 .dseg
002800                           pulse1_param: .byte 1 //$4000 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002801                           pulse1_sweep_param: .byte 1 //$4001 EPPP.NSSS = Enable, Period, Negate, Shift
                                 //NOTE: In order to account for multiplier, we use 16 instead of 11 bits for the timer
002802                           pulse1_timerL: .byte 1 //$4002 LLLL.LLLL = Low 8 bits for timer
002803                           pulse1_timerH: .byte 1 //$4002 HHHH.HHHH = High 8 bits for timer
002804                           pulse1_length: .byte 1 //$4003 000l.llll = Length counter load
002805                           pulse1_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002806                           pulse1_output_volume: .byte 1 //this is the final output volume of pulse 1
002807                           pulse1_note: .byte 1 //the current note index in the note table
                                 
002808                           pulse2_param: .byte 1 //$4004 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002809                           pulse2_sweep_param: .byte 1 //$4005 EPPP.NSSS = Enable, Period, Negate, Shift
00280a                           pulse2_timerL: .byte 1 //$4006 LLLL.LLLL = Low 8 bits for timer
00280b                           pulse2_timerH: .byte 1 //$4006 HHHH.HHHH = High 8 bits for timer
00280c                           pulse2_length: .byte 1 //$4007 000l.llll = Length counter load
00280d                           pulse2_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
00280e                           pulse2_output_volume: .byte 1 //this is the final output volume of pulse 2
00280f                           pulse2_note: .byte 1 //the current note index in the note table
                                 
002810                           triangle_timerL: .byte 1 //$400A LLLL.LLLL = Low 8 bits for timer
002811                           triangle_timerH: .byte 1 //$400A HHHH.HHHH = High 8 bits for time
002812                           triangle_note: .byte 1 //the current note index in the note table
                                 
002813                           noise_param: .byte 1 //$400C 00lc.vvvv = Length counter halt/Loop flag, Constant volume flag, Volume
002814                           noise_period: .byte 1 //$400E M000.PPPP = Mode, Period
002815                           noise_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002816                           noise_output_volume: .byte 1 //this is the final output volume of pulse 2
002817                           noise_note: .byte 1 //the current note index in the period table
                                 
002818                           song_frames: .byte 2
00281a                           song_frame_offset: .byte 2
00281c                           song_size: .byte 2
00281e                           song_speed: .byte 1
                                 //song_channel_delay_reload: .byte 1 //bit 0-4 represents channels 0-4. a set bit means that there is a delay that needs to be calculated for that channel.
00281f                           song_fx_Bxx: .byte 1
002820                           song_fx_Cxx: .byte 1
002821                           song_fx_Dxx: .byte 1
                                 
                                 //PULSE 1
002822                           pulse1_pattern: .byte 2
002824                           pulse1_pattern_delay_rows: .byte 1
002825                           pulse1_pattern_delay_frames: .byte 1
002826                           pulse1_pattern_offset: .byte 2
                                 
002828                           pulse1_volume_macro: .byte 2
00282a                           pulse1_volume_macro_offset: .byte 1
00282b                           pulse1_volume_macro_loop: .byte 1
00282c                           pulse1_volume_macro_release: .byte 1
                                 
00282d                           pulse1_arpeggio_macro: .byte 2
00282f                           pulse1_arpeggio_macro_offset: .byte 1
002830                           pulse1_arpeggio_macro_loop: .byte 1
002831                           pulse1_arpeggio_macro_release: .byte 1
002832                           pulse1_arpeggio_macro_mode: .byte 1
                                 
002833                           pulse1_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002835                           pulse1_pitch_macro: .byte 2
002837                           pulse1_pitch_macro_offset: .byte 1
002838                           pulse1_pitch_macro_loop: .byte 1
002839                           pulse1_pitch_macro_release: .byte 1
                                 
00283a                           pulse1_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00283b                           pulse1_hi_pitch_macro: .byte 2
00283d                           pulse1_hi_pitch_macro_offset: .byte 1
00283e                           pulse1_hi_pitch_macro_loop: .byte 1
00283f                           pulse1_hi_pitch_macro_release: .byte 1
                                 
002840                           pulse1_duty_macro: .byte 2
002842                           pulse1_duty_macro_offset: .byte 1
002843                           pulse1_duty_macro_loop: .byte 1
002844                           pulse1_duty_macro_release: .byte 1
                                 
002845                           pulse1_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002847                           pulse1_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002849                           pulse1_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00284b                           pulse1_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
00284d                           pulse1_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
00284f                           pulse1_fx_3xx_start: .byte 2 //the starting note period
002851                           pulse1_fx_3xx_target: .byte 2 //target note period
002853                           pulse1_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
002855                           pulse1_fx_3xx_total_offset: .byte 2
002857                           pulse1_fx_4xy_speed: .byte 1
002858                           pulse1_fx_4xy_depth: .byte 1
002859                           pulse1_fx_4xy_phase: .byte 1
00285a                           pulse1_fx_7xy_speed: .byte 1
00285b                           pulse1_fx_7xy_depth: .byte 1
00285c                           pulse1_fx_7xy_phase: .byte 1
00285d                           pulse1_fx_7xy_value: .byte 1 //value to offset the volume
00285e                           pulse1_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
00285f                           pulse1_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002860                           pulse1_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002861                           pulse1_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
002863                           pulse1_fx_Qxy_target_note: .byte 1 //target note index
002864                           pulse1_fx_Qxy_target: .byte 2 //target note period
002866                           pulse1_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002868                           pulse1_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
00286a                           pulse1_fx_Rxy_target_note: .byte 1 //target note index
00286b                           pulse1_fx_Rxy_target: .byte 2 //target note period
00286d                           pulse1_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
00286f                           pulse1_fx_Rxy_total_offset: .byte 2
002871                           pulse1_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002872                           pulse1_fx_Sxx_post: .byte 1
                                 
                                 //PULSE 2
002873                           pulse2_pattern: .byte 2
002875                           pulse2_pattern_delay_rows: .byte 1
002876                           pulse2_pattern_delay_frames: .byte 1
002877                           pulse2_pattern_offset: .byte 2
                                 
002879                           pulse2_volume_macro: .byte 2
00287b                           pulse2_volume_macro_offset: .byte 1
00287c                           pulse2_volume_macro_loop: .byte 1
00287d                           pulse2_volume_macro_release: .byte 1
                                 
00287e                           pulse2_arpeggio_macro: .byte 2
002880                           pulse2_arpeggio_macro_offset: .byte 1
002881                           pulse2_arpeggio_macro_loop: .byte 1
002882                           pulse2_arpeggio_macro_release: .byte 1
002883                           pulse2_arpeggio_macro_mode: .byte 1
                                 
002884                           pulse2_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002886                           pulse2_pitch_macro: .byte 2
002888                           pulse2_pitch_macro_offset: .byte 1
002889                           pulse2_pitch_macro_loop: .byte 1
00288a                           pulse2_pitch_macro_release: .byte 1
                                 
00288b                           pulse2_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00288c                           pulse2_hi_pitch_macro: .byte 2
00288e                           pulse2_hi_pitch_macro_offset: .byte 1
00288f                           pulse2_hi_pitch_macro_loop: .byte 1
002890                           pulse2_hi_pitch_macro_release: .byte 1
                                 
002891                           pulse2_duty_macro: .byte 2
002893                           pulse2_duty_macro_offset: .byte 1
002894                           pulse2_duty_macro_loop: .byte 1
002895                           pulse2_duty_macro_release: .byte 1
                                 
002896                           pulse2_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002898                           pulse2_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
00289a                           pulse2_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00289c                           pulse2_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
00289e                           pulse2_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
0028a0                           pulse2_fx_3xx_start: .byte 2 //the starting note period
0028a2                           pulse2_fx_3xx_target: .byte 2 //target note period
0028a4                           pulse2_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028a6                           pulse2_fx_3xx_total_offset: .byte 2
0028a8                           pulse2_fx_4xy_speed: .byte 1
0028a9                           pulse2_fx_4xy_depth: .byte 1
0028aa                           pulse2_fx_4xy_phase: .byte 1
0028ab                           pulse2_fx_7xy_speed: .byte 1
0028ac                           pulse2_fx_7xy_depth: .byte 1
0028ad                           pulse2_fx_7xy_phase: .byte 1
0028ae                           pulse2_fx_7xy_value: .byte 1 //value to offset the volume
0028af                           pulse2_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
0028b0                           pulse2_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028b1                           pulse2_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028b2                           pulse2_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
0028b4                           pulse2_fx_Qxy_target_note: .byte 1 //target note index
0028b5                           pulse2_fx_Qxy_target: .byte 2 //target note period
0028b7                           pulse2_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
0028b9                           pulse2_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
0028bb                           pulse2_fx_Rxy_target_note: .byte 1 //target note index
0028bc                           pulse2_fx_Rxy_target: .byte 2 //target note period
0028be                           pulse2_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
0028c0                           pulse2_fx_Rxy_total_offset: .byte 2
0028c2                           pulse2_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
0028c3                           pulse2_fx_Sxx_post: .byte 1
                                 
                                 //TRIANGLE
0028c4                           triangle_pattern: .byte 2
0028c6                           triangle_pattern_delay_rows: .byte 1
0028c7                           triangle_pattern_delay_frames: .byte 1
0028c8                           triangle_pattern_offset: .byte 2
                                 
0028ca                           triangle_volume_macro: .byte 2
0028cc                           triangle_volume_macro_offset: .byte 1
0028cd                           triangle_volume_macro_loop: .byte 1
0028ce                           triangle_volume_macro_release: .byte 1
                                 
0028cf                           triangle_arpeggio_macro: .byte 2
0028d1                           triangle_arpeggio_macro_offset: .byte 1
0028d2                           triangle_arpeggio_macro_loop: .byte 1
0028d3                           triangle_arpeggio_macro_release: .byte 1
0028d4                           triangle_arpeggio_macro_mode: .byte 1
                                 
0028d5                           triangle_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
0028d7                           triangle_pitch_macro: .byte 2
0028d9                           triangle_pitch_macro_offset: .byte 1
0028da                           triangle_pitch_macro_loop: .byte 1
0028db                           triangle_pitch_macro_release: .byte 1
                                 
0028dc                           triangle_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
0028dd                           triangle_hi_pitch_macro: .byte 2
0028df                           triangle_hi_pitch_macro_offset: .byte 1
0028e0                           triangle_hi_pitch_macro_loop: .byte 1
0028e1                           triangle_hi_pitch_macro_release: .byte 1
                                 
0028e2                           triangle_duty_macro: .byte 2
0028e4                           triangle_duty_macro_offset: .byte 1
0028e5                           triangle_duty_macro_loop: .byte 1
0028e6                           triangle_duty_macro_release: .byte 1
                                 
0028e7                           triangle_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
0028e9                           triangle_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
0028eb                           triangle_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
0028ed                           triangle_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
0028ef                           triangle_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
0028f1                           triangle_fx_3xx_start: .byte 2 //the starting note period
0028f3                           triangle_fx_3xx_target: .byte 2 //target note period
0028f5                           triangle_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028f7                           triangle_fx_3xx_total_offset: .byte 2
0028f9                           triangle_fx_4xy_speed: .byte 1
0028fa                           triangle_fx_4xy_depth: .byte 1
0028fb                           triangle_fx_4xy_phase: .byte 1
0028fc                           triangle_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028fd                           triangle_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028fe                           triangle_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
002900                           triangle_fx_Qxy_target_note: .byte 1 //target note index
002901                           triangle_fx_Qxy_target: .byte 2 //target note period
002903                           triangle_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002905                           triangle_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002907                           triangle_fx_Rxy_target_note: .byte 1 //target note index
002908                           triangle_fx_Rxy_target: .byte 2 //target note period
00290a                           triangle_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
00290c                           triangle_fx_Rxy_total_offset: .byte 2
00290e                           triangle_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
00290f                           triangle_fx_Sxx_post: .byte 1
                                 
                                 //NOISE
002910                           noise_pattern: .byte 2
002912                           noise_pattern_delay_rows: .byte 1
002913                           noise_pattern_delay_frames: .byte 1
002914                           noise_pattern_offset: .byte 2
                                 
002916                           noise_volume_macro: .byte 2
002918                           noise_volume_macro_offset: .byte 1
002919                           noise_volume_macro_loop: .byte 1
00291a                           noise_volume_macro_release: .byte 1
                                 
00291b                           noise_arpeggio_macro: .byte 2
00291d                           noise_arpeggio_macro_offset: .byte 1
00291e                           noise_arpeggio_macro_loop: .byte 1
00291f                           noise_arpeggio_macro_release: .byte 1
002920                           noise_arpeggio_macro_mode: .byte 1
                                 
002921                           noise_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002923                           noise_pitch_macro: .byte 2
002925                           noise_pitch_macro_offset: .byte 1
002926                           noise_pitch_macro_loop: .byte 1
002927                           noise_pitch_macro_release: .byte 1
                                 
002928                           noise_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
002929                           noise_hi_pitch_macro: .byte 2
00292b                           noise_hi_pitch_macro_offset: .byte 1
00292c                           noise_hi_pitch_macro_loop: .byte 1
00292d                           noise_hi_pitch_macro_release: .byte 1
                                 
00292e                           noise_duty_macro: .byte 2
002930                           noise_duty_macro_offset: .byte 1
002931                           noise_duty_macro_loop: .byte 1
002932                           noise_duty_macro_release: .byte 1
                                 
002933                           noise_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002935                           noise_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002937                           noise_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
002939                           noise_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
00293b                           noise_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
00293d                           noise_fx_3xx_start: .byte 2 //the starting note period
00293f                           noise_fx_3xx_target: .byte 2 //target note period
002941                           noise_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
002943                           noise_fx_3xx_total_offset: .byte 2
002945                           noise_fx_4xy_speed: .byte 1
002946                           noise_fx_4xy_depth: .byte 1
002947                           noise_fx_4xy_phase: .byte 1
002948                           noise_fx_7xy_speed: .byte 1
002949                           noise_fx_7xy_depth: .byte 1
00294a                           noise_fx_7xy_phase: .byte 1
00294b                           noise_fx_7xy_value: .byte 1 //value to offset the volume
00294c                           noise_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
00294d                           noise_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
00294e                           noise_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
00294f                           noise_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
002951                           noise_fx_Qxy_target_note: .byte 1 //target note index
002952                           noise_fx_Qxy_target: .byte 2 //target note period
002954                           noise_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002956                           noise_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002958                           noise_fx_Rxy_target_note: .byte 1 //target note index
002959                           noise_fx_Rxy_target: .byte 2 //target note period
00295b                           noise_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
00295d                           noise_fx_Rxy_total_offset: .byte 2
00295f                           noise_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002960                           noise_fx_Sxx_post: .byte 1
                                 
                                 //DPCM
002961                           dcpm_pattern_delay: .byte 1
                                 
                                 .cseg
                                 
                                 //NOTE: zero is defined in order to use the cp instruction without the need to load 0x00 into a register beforehand
                                 .def zero = r2
                                 .def pulse_channel_flags = r25 //[pulse1.pulse2] RSlc.RSlc = Reload, Start, Length halt/Loop, Constant volume
                                 .def pulse1_sequence = r10
                                 .def pulse1_length_counter = r11
                                 .def pulse1_sweep = r12 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse1_volume_divider = r16 //0000.PPPP = Period divider
                                 .def pulse1_volume_decay = r17 //0000.dddd = Decay
                                 .def pulse2_sequence = r13
                                 .def pulse2_length_counter = r14
                                 .def pulse2_sweep = r15 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse2_volume_divider = r18 //0000.PPPP = Period divider
                                 .def pulse2_volume_decay = r19 //0000.dddd = Decay
                                 .def triangle_sequence = r20
                                 .def noise_sequence_LOW = r21
                                 .def noise_sequence_HIGH = r22
                                 
                                 reset:
000000 940c 0ec3                 	jmp init
                                 
                                 .org TCA0_OVF_vect
00000e 940c 137e                 	jmp sound_driver
                                 
                                 .org TCA0_CMP0_vect
000012 940c 1285                 	jmp sequence_0_2
                                 
                                 .org TCA0_CMP1_vect
000014 940c 1290                 	jmp sequence_1_3
                                 
                                 .org TCA0_CMP2_vect
000016 940c 1285                 	jmp sequence_0_2
                                 
                                 .org TCB0_INT_vect
000018 940c 12a7                 	jmp pulse1_sequence_routine
                                 
                                 .org TCB1_INT_vect
00001a 940c 12f4                 	jmp pulse2_sequence_routine
                                 
                                 .org TCB2_INT_vect
000032 940c 1341                 	jmp triangle_sequence_routine
                                 
                                 .org TCB3_INT_vect
000048 940c 134c                 	jmp noise_sequence_routine
                                 
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(33): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(48): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(74): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(77): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(79): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(80): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(81): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(84): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(85): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(88): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(89): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(93): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(95): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(96): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(97): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(101): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(102): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(104): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(106): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(108): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(109): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(110): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(113): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(116): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(119): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(124): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(125): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(127): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(128): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(131): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(138): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(216): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(218): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(219): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(220): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(221): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(223): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(225): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(226): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(227): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(231): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(233): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(234): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(235): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(237): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(240): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(246): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(247): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(249): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(250): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(251): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(258): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(259): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(269): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(270): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
                                 .list
                                 
                                 init:
                                 	//MAIN CLOCK
000ec3 edc8                      	ldi r28, CPU_CCP_IOREG_gc //protected write
000ec4 93c0 0034                 	sts CPU_CCP, r28
000ec6 e0c0                      	ldi r28, 0 << CLKCTRL_PEN_bp //disable prescaler for 20 MHz on main clock
000ec7 93c0 0061                 	sts CLKCTRL_MCLKCTRLB, r28
                                 
                                 	//ZERO
000ec9 2422                      	clr zero
                                 
                                 	//MEMORY
000eca e3c0                      	ldi r28, 0b00110000
000ecb 93c0 2800                 	sts pulse1_param, r28
000ecd e8c0                      	ldi r28, 0b10000000
000ece 93c0 2801                 	sts pulse1_sweep_param, r28
000ed0 efcf                      	ldi r28, 0xFF
000ed1 93c0 2802                 	sts pulse1_timerL, r28
000ed3 93c0 2803                 	sts pulse1_timerH, r28
000ed5 93c0 2804                 	sts pulse1_length, r28
                                 
000ed7 e3c0                      	ldi r28, 0b00110000
000ed8 93c0 2808                 	sts pulse2_param, r28
000eda e8c0                      	ldi r28, 0b10000000
000edb 93c0 2809                 	sts pulse2_sweep_param, r28
000edd efcf                      	ldi r28, 0xFF
000ede 93c0 280a                 	sts pulse2_timerL, r28
000ee0 93c0 280b                 	sts pulse2_timerH, r28
000ee2 93c0 280c                 	sts pulse2_length, r28
                                 
000ee4 efcf                      	ldi r28, 0xFF
000ee5 93c0 2810                 	sts triangle_timerL, r28
000ee7 93c0 2811                 	sts triangle_timerH, r28
                                 
000ee9 e3c0                      	ldi r28, 0b00110000
000eea 93c0 2813                 	sts noise_param, r28
000eec e0cf                      	ldi r28, 0b00001111
000eed 93c0 2814                 	sts noise_period, r28
                                 
000eef e0c2                      	ldi r28, 0x02
000ef0 93c0 281a                 	sts song_frame_offset, r28
000ef2 9220 281b                 	sts song_frame_offset+1, zero
000ef4 efcf                      	ldi r28, 0xFF
000ef5 93c0 281f                 	sts song_fx_Bxx, r28
000ef7 9220 2820                 	sts song_fx_Cxx, zero
000ef9 9220 2821                 	sts song_fx_Dxx, zero
000efb e4ee                      	ldi ZL, LOW(song0_frames << 1)
000efc e0f3                      	ldi ZH, HIGH(song0_frames << 1)
000efd 93e0 2818                 	sts song_frames, ZL
000eff 93f0 2819                 	sts song_frames+1, ZH
000f01 91c5                      	lpm r28, Z+ //load the song size
000f02 91d5                      	lpm r29, Z+
000f03 93c0 281c                 	sts song_size, r28
000f05 93d0 281d                 	sts song_size+1, r29
000f07 9220 281e                 	sts song_speed, zero
                                 
                                 	//CHANNEL 0
000f09 91c5                      	lpm r28, Z+
000f0a 91d5                      	lpm r29, Z+
000f0b 0fcc                      	lsl r28
000f0c 1fdd                      	rol r29
000f0d 93c0 2822                 	sts pulse1_pattern, r28
000f0f 93d0 2823                 	sts pulse1_pattern+1, r29
000f11 9220 2824                 	sts pulse1_pattern_delay_rows, zero
000f13 9220 2825                 	sts pulse1_pattern_delay_frames, zero
000f15 9220 2826                 	sts pulse1_pattern_offset, zero
000f17 9220 2827                 	sts pulse1_pattern_offset+1, zero
                                 
                                 	//CHANNEL 1
000f19 91c5                      	lpm r28, Z+
000f1a 91d5                      	lpm r29, Z+
000f1b 0fcc                      	lsl r28
000f1c 1fdd                      	rol r29
000f1d 93c0 2873                 	sts pulse2_pattern, r28
000f1f 93d0 2874                 	sts pulse2_pattern+1, r29
000f21 9220 2875                 	sts pulse2_pattern_delay_rows, zero
000f23 9220 2876                 	sts pulse2_pattern_delay_frames, zero
000f25 9220 2877                 	sts pulse2_pattern_offset, zero
000f27 9220 2878                 	sts pulse2_pattern_offset+1, zero
                                 
                                 	//CHANNEL 2
000f29 91c5                      	lpm r28, Z+
000f2a 91d5                      	lpm r29, Z+
000f2b 0fcc                      	lsl r28
000f2c 1fdd                      	rol r29
000f2d 93c0 28c4                 	sts triangle_pattern, r28
000f2f 93d0 28c5                 	sts triangle_pattern+1, r29
000f31 9220 28c6                 	sts triangle_pattern_delay_rows, zero
000f33 9220 28c7                 	sts triangle_pattern_delay_frames, zero
000f35 9220 28c8                 	sts triangle_pattern_offset, zero
000f37 9220 28c9                 	sts triangle_pattern_offset+1, zero
                                 
                                 	//CHANNEL 3
000f39 91c5                      	lpm r28, Z+
000f3a 91d5                      	lpm r29, Z+
000f3b 0fcc                      	lsl r28
000f3c 1fdd                      	rol r29
000f3d 93c0 2910                 	sts noise_pattern, r28
000f3f 93d0 2911                 	sts noise_pattern+1, r29
000f41 9220 2912                 	sts noise_pattern_delay_rows, zero
000f43 9220 2913                 	sts noise_pattern_delay_frames, zero
000f45 9220 2914                 	sts noise_pattern_offset, zero
000f47 9220 2915                 	sts noise_pattern_offset+1, zero
                                 
                                 	//CHANNEL 0 instrument macros
000f49 efcf                      	ldi r28, 0xFF
000f4a 9220 282a                 	sts pulse1_volume_macro_offset, zero
000f4c 93c0 282b                 	sts pulse1_volume_macro_loop, r28
000f4e 93c0 282c                 	sts pulse1_volume_macro_release, r28
000f50 9220 282f                 	sts pulse1_arpeggio_macro_offset, zero
000f52 93c0 2830                 	sts pulse1_arpeggio_macro_loop, r28
000f54 93c0 2831                 	sts pulse1_arpeggio_macro_release, r28
000f56 93c0 2832                 	sts pulse1_arpeggio_macro_mode, r28
000f58 9220 2837                 	sts pulse1_pitch_macro_offset, zero
000f5a 93c0 2838                 	sts pulse1_pitch_macro_loop, r28
000f5c 93c0 2839                 	sts pulse1_pitch_macro_release, r28
000f5e 9220 283d                 	sts pulse1_hi_pitch_macro_offset, zero
000f60 93c0 283e                 	sts pulse1_hi_pitch_macro_loop, r28
000f62 93c0 283f                 	sts pulse1_hi_pitch_macro_release, r28
000f64 9220 2842                 	sts pulse1_duty_macro_offset, zero
000f66 93c0 2843                 	sts pulse1_duty_macro_loop, r28
000f68 93c0 2844                 	sts pulse1_duty_macro_release, r28
                                 
000f6a 9220 2828                 	sts pulse1_volume_macro, zero
000f6c 9220 2829                 	sts pulse1_volume_macro+1, zero
000f6e 9220 282d                 	sts pulse1_arpeggio_macro, zero
000f70 9220 282e                 	sts pulse1_arpeggio_macro+1, zero
000f72 9220 2833                 	sts pulse1_total_pitch_offset, zero
000f74 9220 2834                 	sts pulse1_total_pitch_offset+1, zero
000f76 9220 2835                 	sts pulse1_pitch_macro, zero
000f78 9220 2836                 	sts pulse1_pitch_macro+1, zero
000f7a 9220 283a                 	sts pulse1_total_hi_pitch_offset, zero
000f7c 9220 283b                 	sts pulse1_hi_pitch_macro, zero
000f7e 9220 283c                 	sts pulse1_hi_pitch_macro+1, zero
000f80 9220 2840                 	sts pulse1_duty_macro, zero
000f82 9220 2841                 	sts pulse1_duty_macro+1, zero
                                 
                                 	//CHANNEL 0 ENVELOPE
000f84 e00f                      	ldi pulse1_volume_divider, 0x0F
000f85 9110 2800                 	lds pulse1_volume_decay, pulse1_param
000f87 701f                      	andi pulse1_volume_decay, 0x0F //mask for VVVV bits
000f88 9190 2800                 	lds pulse_channel_flags, pulse1_param
000f8a 7390                      	andi pulse_channel_flags, 0b00110000
000f8b 6490                      	sbr pulse_channel_flags, 0b01000000 //set start flag
000f8c 9220 2806                 	sts pulse1_output_volume, zero
000f8e 93c0 2805                 	sts pulse1_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 0 LENGTH
000f90 2ebc                      	mov pulse1_length_counter, r28
                                 
                                 	//CHANNEL 0 SEQUENCE
000f91 e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
000f92 2eac                      	mov pulse1_sequence, r28
                                 
                                 	//CHANNEL 0 SWEEP
000f93 90c0 2801                 	lds pulse1_sweep, pulse1_sweep_param
000f95 94c2                      	swap pulse1_sweep //swap data from high byte and low byte
000f96 6890                      	sbr pulse_channel_flags, 0b10000000 //set reload flag
                                 
                                 	//CHANNEL 0 FX
000f97 efcf                      	ldi r28, 0xFF
000f98 9220 2845                 	sts pulse1_fx_0xy_sequence, zero
000f9a 9220 2846                 	sts pulse1_fx_0xy_sequence+1, zero
000f9c 9220 2847                 	sts pulse1_fx_1xx, zero
000f9e 9220 2848                 	sts pulse1_fx_1xx+1, zero
000fa0 9220 2849                 	sts pulse1_fx_1xx_total, zero
000fa2 9220 284a                 	sts pulse1_fx_1xx_total+1, zero
000fa4 9220 284b                 	sts pulse1_fx_2xx, zero
000fa6 9220 284c                 	sts pulse1_fx_2xx+1, zero
000fa8 9220 284d                 	sts pulse1_fx_2xx_total, zero
000faa 9220 284e                 	sts pulse1_fx_2xx_total+1, zero
000fac 9220 284f                 	sts pulse1_fx_3xx_start, zero
000fae 9220 2850                 	sts pulse1_fx_3xx_start+1, zero
000fb0 9220 2851                 	sts pulse1_fx_3xx_target, zero
000fb2 9220 2852                 	sts pulse1_fx_3xx_target+1, zero
000fb4 9220 2853                 	sts pulse1_fx_3xx_speed, zero
000fb6 9220 2854                 	sts pulse1_fx_3xx_speed+1, zero
000fb8 9220 2855                 	sts pulse1_fx_3xx_total_offset, zero
000fba 9220 2856                 	sts pulse1_fx_3xx_total_offset+1, zero
000fbc 9220 2857                 	sts pulse1_fx_4xy_speed, zero
000fbe 9220 2858                 	sts pulse1_fx_4xy_depth, zero
000fc0 9220 2859                 	sts pulse1_fx_4xy_phase, zero
000fc2 9220 285a                 	sts pulse1_fx_7xy_speed, zero
000fc4 9220 285b                 	sts pulse1_fx_7xy_depth, zero
000fc6 9220 285c                 	sts pulse1_fx_7xy_phase, zero
000fc8 9220 285d                 	sts pulse1_fx_7xy_value, zero
000fca 9220 285e                 	sts pulse1_fx_Axy, zero
000fcc 93c0 285f                 	sts pulse1_fx_Gxx_pre, r28
000fce 93c0 2860                 	sts pulse1_fx_Gxx_post, r28
000fd0 9220 2861                 	sts pulse1_fx_Pxx_total, zero
000fd2 9220 2862                 	sts pulse1_fx_Pxx_total+1, zero
000fd4 9220 2863                 	sts pulse1_fx_Qxy_target_note, zero
000fd6 9220 2864                 	sts pulse1_fx_Qxy_target, zero
000fd8 9220 2865                 	sts pulse1_fx_Qxy_target+1, zero
000fda 9220 2866                 	sts pulse1_fx_Qxy_speed, zero
000fdc 9220 2867                 	sts pulse1_fx_Qxy_speed+1, zero
000fde 9220 2868                 	sts pulse1_fx_Qxy_total_offset, zero
000fe0 9220 2869                 	sts pulse1_fx_Qxy_total_offset+1, zero
000fe2 9220 286a                 	sts pulse1_fx_Rxy_target_note, zero
000fe4 9220 286b                 	sts pulse1_fx_Rxy_target, zero
000fe6 9220 286c                 	sts pulse1_fx_Rxy_target+1, zero
000fe8 9220 286d                 	sts pulse1_fx_Rxy_speed, zero
000fea 9220 286e                 	sts pulse1_fx_Rxy_speed+1, zero
000fec 9220 286f                 	sts pulse1_fx_Rxy_total_offset, zero
000fee 9220 2870                 	sts pulse1_fx_Rxy_total_offset+1, zero
000ff0 93c0 2871                 	sts pulse1_fx_Sxx_pre, r28
000ff2 93c0 2872                 	sts pulse1_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 1 instrument macros
000ff4 efcf                      	ldi r28, 0xFF
000ff5 9220 287b                 	sts pulse2_volume_macro_offset, zero
000ff7 93c0 287c                 	sts pulse2_volume_macro_loop, r28
000ff9 93c0 287d                 	sts pulse2_volume_macro_release, r28
000ffb 9220 2880                 	sts pulse2_arpeggio_macro_offset, zero
000ffd 93c0 2881                 	sts pulse2_arpeggio_macro_loop, r28
000fff 93c0 2882                 	sts pulse2_arpeggio_macro_release, r28
001001 93c0 2883                 	sts pulse2_arpeggio_macro_mode, r28
001003 9220 2888                 	sts pulse2_pitch_macro_offset, zero
001005 93c0 2889                 	sts pulse2_pitch_macro_loop, r28
001007 93c0 288a                 	sts pulse2_pitch_macro_release, r28
001009 9220 288e                 	sts pulse2_hi_pitch_macro_offset, zero
00100b 93c0 288f                 	sts pulse2_hi_pitch_macro_loop, r28
00100d 93c0 2890                 	sts pulse2_hi_pitch_macro_release, r28
00100f 9220 2893                 	sts pulse2_duty_macro_offset, zero
001011 93c0 2894                 	sts pulse2_duty_macro_loop, r28
001013 93c0 2895                 	sts pulse2_duty_macro_release, r28
                                 
001015 9220 2879                 	sts pulse2_volume_macro, zero
001017 9220 287a                 	sts pulse2_volume_macro+1, zero
001019 9220 287e                 	sts pulse2_arpeggio_macro, zero
00101b 9220 287f                 	sts pulse2_arpeggio_macro+1, zero
00101d 9220 2884                 	sts pulse2_total_pitch_offset, zero
00101f 9220 2885                 	sts pulse2_total_pitch_offset+1, zero
001021 9220 2886                 	sts pulse2_pitch_macro, zero
001023 9220 2887                 	sts pulse2_pitch_macro+1, zero
001025 9220 288b                 	sts pulse2_total_hi_pitch_offset, zero
001027 9220 288c                 	sts pulse2_hi_pitch_macro, zero
001029 9220 288d                 	sts pulse2_hi_pitch_macro+1, zero
00102b 9220 2891                 	sts pulse2_duty_macro, zero
00102d 9220 2892                 	sts pulse2_duty_macro+1, zero
                                 
                                 	//CHANNEL 1 ENVELOPE
00102f e02f                      	ldi pulse2_volume_divider, 0x0F
001030 9130 2808                 	lds pulse2_volume_decay, pulse2_param
001032 703f                      	andi pulse2_volume_decay, 0x0F //mask for VVVV bits
001033 91d0 2808                 	lds r29, pulse2_param
001035 73d0                      	andi r29, 0b00110000
001036 62d0                      	sbr r29, 0b0100000 //set start flag
001037 95d2                      	swap r29
001038 2b9d                      	or pulse_channel_flags, r29
001039 9220 280e                 	sts pulse2_output_volume, zero
00103b 93c0 280d                 	sts pulse2_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 1 LENGTH
00103d 2eec                      	mov pulse2_length_counter, r28
                                 
                                 	//CHANNEL 1 SEQUENCE
00103e e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
00103f 2edc                      	mov pulse2_sequence, r28
                                 
                                 	//CHANNEL 1 SWEEP
001040 90f0 2809                 	lds pulse2_sweep, pulse2_sweep_param
001042 94f2                      	swap pulse2_sweep //swap data from high byte and low byte
001043 6098                      	sbr pulse_channel_flags, 0b00001000 //set reload flag
                                 
                                 	//CHANNEL 1 FX
001044 efcf                      	ldi r28, 0xFF
001045 9220 2896                 	sts pulse2_fx_0xy_sequence, zero
001047 9220 2897                 	sts pulse2_fx_0xy_sequence+1, zero
001049 9220 2898                 	sts pulse2_fx_1xx, zero
00104b 9220 2899                 	sts pulse2_fx_1xx+1, zero
00104d 9220 289a                 	sts pulse2_fx_1xx_total, zero
00104f 9220 289b                 	sts pulse2_fx_1xx_total+1, zero
001051 9220 289c                 	sts pulse2_fx_2xx, zero
001053 9220 289d                 	sts pulse2_fx_2xx+1, zero
001055 9220 289e                 	sts pulse2_fx_2xx_total, zero
001057 9220 289f                 	sts pulse2_fx_2xx_total+1, zero
001059 9220 28a0                 	sts pulse2_fx_3xx_start, zero
00105b 9220 28a1                 	sts pulse2_fx_3xx_start+1, zero
00105d 9220 28a2                 	sts pulse2_fx_3xx_target, zero
00105f 9220 28a3                 	sts pulse2_fx_3xx_target+1, zero
001061 9220 28a4                 	sts pulse2_fx_3xx_speed, zero
001063 9220 28a5                 	sts pulse2_fx_3xx_speed+1, zero
001065 9220 28a6                 	sts pulse2_fx_3xx_total_offset, zero
001067 9220 28a7                 	sts pulse2_fx_3xx_total_offset+1, zero
001069 9220 28a8                 	sts pulse2_fx_4xy_speed, zero
00106b 9220 28a9                 	sts pulse2_fx_4xy_depth, zero
00106d 9220 28aa                 	sts pulse2_fx_4xy_phase, zero
00106f 9220 28ab                 	sts pulse2_fx_7xy_speed, zero
001071 9220 28ac                 	sts pulse2_fx_7xy_depth, zero
001073 9220 28ad                 	sts pulse2_fx_7xy_phase, zero
001075 9220 28ae                 	sts pulse2_fx_7xy_value, zero
001077 9220 28af                 	sts pulse2_fx_Axy, zero
001079 93c0 28b0                 	sts pulse2_fx_Gxx_pre, r28
00107b 93c0 28b1                 	sts pulse2_fx_Gxx_post, r28
00107d 9220 28b2                 	sts pulse2_fx_Pxx_total, zero
00107f 9220 28b3                 	sts pulse2_fx_Pxx_total+1, zero
001081 9220 28b4                 	sts pulse2_fx_Qxy_target_note, zero
001083 9220 28b5                 	sts pulse2_fx_Qxy_target, zero
001085 9220 28b6                 	sts pulse2_fx_Qxy_target+1, zero
001087 9220 28b7                 	sts pulse2_fx_Qxy_speed, zero
001089 9220 28b8                 	sts pulse2_fx_Qxy_speed+1, zero
00108b 9220 28b9                 	sts pulse2_fx_Qxy_total_offset, zero
00108d 9220 28ba                 	sts pulse2_fx_Qxy_total_offset+1, zero
00108f 9220 28bb                 	sts pulse2_fx_Rxy_target_note, zero
001091 9220 28bc                 	sts pulse2_fx_Rxy_target, zero
001093 9220 28bd                 	sts pulse2_fx_Rxy_target+1, zero
001095 9220 28be                 	sts pulse2_fx_Rxy_speed, zero
001097 9220 28bf                 	sts pulse2_fx_Rxy_speed+1, zero
001099 9220 28c0                 	sts pulse2_fx_Rxy_total_offset, zero
00109b 9220 28c1                 	sts pulse2_fx_Rxy_total_offset+1, zero
00109d 93c0 28c2                 	sts pulse2_fx_Sxx_pre, r28
00109f 93c0 28c3                 	sts pulse2_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 2 instrument macros
0010a1 efcf                      	ldi r28, 0xFF
0010a2 9220 28cc                 	sts triangle_volume_macro_offset, zero
0010a4 93c0 28cd                 	sts triangle_volume_macro_loop, r28
0010a6 93c0 28ce                 	sts triangle_volume_macro_release, r28
0010a8 9220 28d1                 	sts triangle_arpeggio_macro_offset, zero
0010aa 93c0 28d2                 	sts triangle_arpeggio_macro_loop, r28
0010ac 93c0 28d3                 	sts triangle_arpeggio_macro_release, r28
0010ae 93c0 28d4                 	sts triangle_arpeggio_macro_mode, r28
0010b0 9220 28d9                 	sts triangle_pitch_macro_offset, zero
0010b2 93c0 28da                 	sts triangle_pitch_macro_loop, r28
0010b4 93c0 28db                 	sts triangle_pitch_macro_release, r28
0010b6 9220 28df                 	sts triangle_hi_pitch_macro_offset, zero
0010b8 93c0 28e0                 	sts triangle_hi_pitch_macro_loop, r28
0010ba 93c0 28e1                 	sts triangle_hi_pitch_macro_release, r28
0010bc 9220 28e4                 	sts triangle_duty_macro_offset, zero
0010be 93c0 28e5                 	sts triangle_duty_macro_loop, r28
0010c0 93c0 28e6                 	sts triangle_duty_macro_release, r28
                                 
0010c2 9220 28ca                 	sts triangle_volume_macro, zero
0010c4 9220 28cb                 	sts triangle_volume_macro+1, zero
0010c6 9220 28cf                 	sts triangle_arpeggio_macro, zero
0010c8 9220 28d0                 	sts triangle_arpeggio_macro+1, zero
0010ca 9220 28d5                 	sts triangle_total_pitch_offset, zero
0010cc 9220 28d6                 	sts triangle_total_pitch_offset+1, zero
0010ce 9220 28d7                 	sts triangle_pitch_macro, zero
0010d0 9220 28d8                 	sts triangle_pitch_macro+1, zero
0010d2 9220 28dc                 	sts triangle_total_hi_pitch_offset, zero
0010d4 9220 28dd                 	sts triangle_hi_pitch_macro, zero
0010d6 9220 28de                 	sts triangle_hi_pitch_macro+1, zero
0010d8 9220 28e2                 	sts triangle_duty_macro, zero
0010da 9220 28e3                 	sts triangle_duty_macro+1, zero
                                 
                                 	//CHANNEL 2 SEQUENCE
0010dc e0c0                      	ldi r28, 0b00000000 //reset sequence to 0
0010dd 2f4c                      	mov triangle_sequence, r28
                                 
                                 	//CHANNEL 2 FX
0010de efcf                      	ldi r28, 0xFF
0010df 9220 28e7                 	sts triangle_fx_0xy_sequence, zero
0010e1 9220 28e8                 	sts triangle_fx_0xy_sequence+1, zero
0010e3 9220 28e9                 	sts triangle_fx_1xx, zero
0010e5 9220 28ea                 	sts triangle_fx_1xx+1, zero
0010e7 9220 28eb                 	sts triangle_fx_1xx_total, zero
0010e9 9220 28ec                 	sts triangle_fx_1xx_total+1, zero
0010eb 9220 28ed                 	sts triangle_fx_2xx, zero
0010ed 9220 28ee                 	sts triangle_fx_2xx+1, zero
0010ef 9220 28ef                 	sts triangle_fx_2xx_total, zero
0010f1 9220 28f0                 	sts triangle_fx_2xx_total+1, zero
0010f3 9220 28f1                 	sts triangle_fx_3xx_start, zero
0010f5 9220 28f2                 	sts triangle_fx_3xx_start+1, zero
0010f7 9220 28f3                 	sts triangle_fx_3xx_target, zero
0010f9 9220 28f4                 	sts triangle_fx_3xx_target+1, zero
0010fb 9220 28f5                 	sts triangle_fx_3xx_speed, zero
0010fd 9220 28f6                 	sts triangle_fx_3xx_speed+1, zero
0010ff 9220 28f7                 	sts triangle_fx_3xx_total_offset, zero
001101 9220 28f8                 	sts triangle_fx_3xx_total_offset+1, zero
001103 9220 28f9                 	sts triangle_fx_4xy_speed, zero
001105 9220 28fa                 	sts triangle_fx_4xy_depth, zero
001107 9220 28fb                 	sts triangle_fx_4xy_phase, zero
001109 93c0 28fc                 	sts triangle_fx_Gxx_pre, r28
00110b 93c0 28fd                 	sts triangle_fx_Gxx_post, r28
00110d 9220 28fe                 	sts triangle_fx_Pxx_total, zero
00110f 9220 28ff                 	sts triangle_fx_Pxx_total+1, zero
001111 9220 2900                 	sts triangle_fx_Qxy_target_note, zero
001113 9220 2901                 	sts triangle_fx_Qxy_target, zero
001115 9220 2902                 	sts triangle_fx_Qxy_target+1, zero
001117 9220 2903                 	sts triangle_fx_Qxy_speed, zero
001119 9220 2904                 	sts triangle_fx_Qxy_speed+1, zero
00111b 9220 2905                 	sts triangle_fx_Qxy_total_offset, zero
00111d 9220 2906                 	sts triangle_fx_Qxy_total_offset+1, zero
00111f 9220 2907                 	sts triangle_fx_Rxy_target_note, zero
001121 9220 2908                 	sts triangle_fx_Rxy_target, zero
001123 9220 2909                 	sts triangle_fx_Rxy_target+1, zero
001125 9220 290a                 	sts triangle_fx_Rxy_speed, zero
001127 9220 290b                 	sts triangle_fx_Rxy_speed+1, zero
001129 9220 290c                 	sts triangle_fx_Rxy_total_offset, zero
00112b 9220 290d                 	sts triangle_fx_Rxy_total_offset+1, zero
00112d 93c0 290e                 	sts triangle_fx_Sxx_pre, r28
00112f 93c0 290f                 	sts triangle_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 3 instrument macros
001131 efcf                      	ldi r28, 0xFF
001132 9220 2918                 	sts noise_volume_macro_offset, zero
001134 93c0 2919                 	sts noise_volume_macro_loop, r28
001136 93c0 291a                 	sts noise_volume_macro_release, r28
001138 9220 291d                 	sts noise_arpeggio_macro_offset, zero
00113a 93c0 291e                 	sts noise_arpeggio_macro_loop, r28
00113c 93c0 291f                 	sts noise_arpeggio_macro_release, r28
00113e 93c0 2920                 	sts noise_arpeggio_macro_mode, r28
001140 9220 2925                 	sts noise_pitch_macro_offset, zero
001142 93c0 2926                 	sts noise_pitch_macro_loop, r28
001144 93c0 2927                 	sts noise_pitch_macro_release, r28
001146 9220 292b                 	sts noise_hi_pitch_macro_offset, zero
001148 93c0 292c                 	sts noise_hi_pitch_macro_loop, r28
00114a 93c0 292d                 	sts noise_hi_pitch_macro_release, r28
00114c 9220 2930                 	sts noise_duty_macro_offset, zero
00114e 93c0 2931                 	sts noise_duty_macro_loop, r28
001150 93c0 2932                 	sts noise_duty_macro_release, r28
                                 
001152 9220 2916                 	sts noise_volume_macro, zero
001154 9220 2917                 	sts noise_volume_macro+1, zero
001156 9220 291b                 	sts noise_arpeggio_macro, zero
001158 9220 291c                 	sts noise_arpeggio_macro+1, zero
00115a 9220 2921                 	sts noise_total_pitch_offset, zero
00115c 9220 2922                 	sts noise_total_pitch_offset+1, zero
00115e 9220 2923                 	sts noise_pitch_macro, zero
001160 9220 2924                 	sts noise_pitch_macro+1, zero
001162 9220 2928                 	sts noise_total_hi_pitch_offset, zero
001164 9220 2929                 	sts noise_hi_pitch_macro, zero
001166 9220 292a                 	sts noise_hi_pitch_macro+1, zero
001168 9220 292e                 	sts noise_duty_macro, zero
00116a 9220 292f                 	sts noise_duty_macro+1, zero
                                 
                                 	//CHANNEL 3 VOLUME
00116c 9220 2816                 	sts noise_output_volume, zero
00116e 93c0 2815                 	sts noise_fractional_volume, r28 //initialize fractional volume to max value
                                 
                                 	//CHANNEL 3 SEQUENCE
001170 e0c1                      	ldi r28, 0b00000001 //noise sequence is reset to 0x0001
001171 2f5c                      	mov noise_sequence_LOW, r28
001172 2d62                      	mov noise_sequence_HIGH, zero
                                 
                                 	//CHANNEL 3 FX
001173 efcf                      	ldi r28, 0xFF
001174 9220 2933                 	sts noise_fx_0xy_sequence, zero
001176 9220 2934                 	sts noise_fx_0xy_sequence+1, zero
001178 9220 2935                 	sts noise_fx_1xx, zero
00117a 9220 2936                 	sts noise_fx_1xx+1, zero
00117c 9220 2937                 	sts noise_fx_1xx_total, zero
00117e 9220 2938                 	sts noise_fx_1xx_total+1, zero
001180 9220 2939                 	sts noise_fx_2xx, zero
001182 9220 293a                 	sts noise_fx_2xx+1, zero
001184 9220 293b                 	sts noise_fx_2xx_total, zero
001186 9220 293c                 	sts noise_fx_2xx_total+1, zero
001188 9220 293d                 	sts noise_fx_3xx_start, zero
00118a 9220 293e                 	sts noise_fx_3xx_start+1, zero
00118c 9220 293f                 	sts noise_fx_3xx_target, zero
00118e 9220 2940                 	sts noise_fx_3xx_target+1, zero
001190 9220 2941                 	sts noise_fx_3xx_speed, zero
001192 9220 2942                 	sts noise_fx_3xx_speed+1, zero
001194 9220 2943                 	sts noise_fx_3xx_total_offset, zero
001196 9220 2944                 	sts noise_fx_3xx_total_offset+1, zero
001198 9220 2945                 	sts noise_fx_4xy_speed, zero
00119a 9220 2946                 	sts noise_fx_4xy_depth, zero
00119c 9220 2947                 	sts noise_fx_4xy_phase, zero
00119e 9220 2948                 	sts noise_fx_7xy_speed, zero
0011a0 9220 2949                 	sts noise_fx_7xy_depth, zero
0011a2 9220 294a                 	sts noise_fx_7xy_phase, zero
0011a4 9220 294b                 	sts noise_fx_7xy_value, zero
0011a6 9220 294c                 	sts noise_fx_Axy, zero
0011a8 93c0 294d                 	sts noise_fx_Gxx_pre, r28
0011aa 93c0 294e                 	sts noise_fx_Gxx_post, r28
0011ac 9220 294f                 	sts noise_fx_Pxx_total, zero
0011ae 9220 2950                 	sts noise_fx_Pxx_total+1, zero
0011b0 9220 2951                 	sts noise_fx_Qxy_target_note, zero
0011b2 9220 2952                 	sts noise_fx_Qxy_target, zero
0011b4 9220 2953                 	sts noise_fx_Qxy_target+1, zero
0011b6 9220 2954                 	sts noise_fx_Qxy_speed, zero
0011b8 9220 2955                 	sts noise_fx_Qxy_speed+1, zero
0011ba 9220 2956                 	sts noise_fx_Qxy_total_offset, zero
0011bc 9220 2957                 	sts noise_fx_Qxy_total_offset+1, zero
0011be 9220 2958                 	sts noise_fx_Rxy_target_note, zero
0011c0 9220 2959                 	sts noise_fx_Rxy_target, zero
0011c2 9220 295a                 	sts noise_fx_Rxy_target+1, zero
0011c4 9220 295b                 	sts noise_fx_Rxy_speed, zero
0011c6 9220 295c                 	sts noise_fx_Rxy_speed+1, zero
0011c8 9220 295d                 	sts noise_fx_Rxy_total_offset, zero
0011ca 9220 295e                 	sts noise_fx_Rxy_total_offset+1, zero
0011cc 93c0 295f                 	sts noise_fx_Sxx_pre, r28
0011ce 93c0 2960                 	sts noise_fx_Sxx_post, r28
                                 
                                 	//PINS
0011d0 efcf                      	ldi r28, 0xFF
0011d1 b9c0                      	out VPORTA_DIR, r28 //set all pins in VPORTA to output
                                 
                                 	//TIMERS
                                 	//Frame Counter
                                 	//NOTE:The frame counter will be defaulted to NTSC mode (60 Hz, 120 Hz, 240 Hz)
                                 	//Each interrupt will be setup to interrupt every 240 Hz clock
                                 	//CMP0 = sequence 0, CMP1 = sequence 1, CMP2 = sequence 2, OVF = sequence 3/sound driver
                                 	//Sequence 3 will clock the sound driver every 60Hz, in which new audio data is read and written to the registers
                                 	//Timer period Calculation: (0.00416666666 * 20000000/64)-1 = 1301.08333125 = 0x0515
                                 	//The ATmega4809 is cofigured to run at 20000000 Hz
                                 	//0.00416666666 seconds is the period for 240 Hz
                                 	//The /64 comes from the prescaler divider used
0011d2 e7c0                      	ldi r28, TCA_SINGLE_CMP0EN_bm | TCA_SINGLE_CMP1EN_bm | TCA_SINGLE_CMP2EN_bm | TCA_SINGLE_WGMODE_NORMAL_gc //interrupt mode
0011d3 93c0 0a01                 	sts TCA0_SINGLE_CTRLB, r28
0011d5 e7c1                      	ldi r28, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP1_bm | TCA_SINGLE_CMP2_bm | TCA_SINGLE_OVF_bm //enable overflow and compare interrupts
0011d6 93c0 0a0a                 	sts TCA0_SINGLE_INTCTRL, r28
0011d8 e1c5                      	ldi r28, 0x15 //set the period for CMP0
0011d9 93c0 0a28                 	sts TCA0_SINGLE_CMP0, r28
0011db e0c5                      	ldi r28, 0x05
0011dc 93c0 0a29                 	sts TCA0_SINGLE_CMP0 + 1, r28
0011de e2cb                      	ldi r28, 0x2B //set the period for CMP1
0011df 93c0 0a2a                 	sts TCA0_SINGLE_CMP1, r28
0011e1 e0ca                      	ldi r28, 0x0A
0011e2 93c0 0a2b                 	sts TCA0_SINGLE_CMP1 + 1, r28
0011e4 e4c1                      	ldi r28, 0x41 //set the period for CMP2
0011e5 93c0 0a2c                 	sts TCA0_SINGLE_CMP2, r28
0011e7 e0cf                      	ldi r28, 0x0F
0011e8 93c0 0a2d                 	sts TCA0_SINGLE_CMP2 + 1, r28
0011ea e5c7                      	ldi r28, 0x57 //set the period for OVF
0011eb 93c0 0a26                 	sts TCA0_SINGLE_PER, r28
0011ed e1c4                      	ldi r28, 0x14
0011ee 93c0 0a27                 	sts TCA0_SINGLE_PER + 1, r28
0011f0 e0cb                      	ldi r28, TCA_SINGLE_CLKSEL_DIV64_gc | TCA_SINGLE_ENABLE_bm //use prescale divider of 64 and enable timer
0011f1 93c0 0a00                 	sts TCA0_SINGLE_CTRLA, r28
                                 
                                 	//NOTE: Channel Timers are clocked (20/2)/(0.8948865) = 11.1746014718 times faster than the NES APU
                                 	//Because of this, we multiply all the NES timer values by 11.1746014718 beforehand
                                 	//Since we rotate the sequence when the timer goes from t-(t-1) to 0, instead of 0 to t like the NES, we add 1 to the NES timers before multiplying
                                 	//The ATmega4809 is configured to run at 20 MHz
                                 	//The /2 comes from the prescaler divider used
                                 	//0.8948865 MHz is the speed of the NTSC NES APU
                                 	//NOTE: This means that any offset to the pitch for the NES timers would be multiplied by 11.1746014718 aswell.
                                 	//Pulse 1
0011f3 e0c0                      	ldi r28, TCB_CNTMODE_INT_gc //interrupt mode
0011f4 93c0 0a81                 	sts TCB0_CTRLB, r28
0011f6 e0c1                      	ldi r28, TCB_CAPT_bm //enable interrupts
0011f7 93c0 0a85                 	sts TCB0_INTCTRL, r28
0011f9 91c0 2802                 	lds r28, pulse1_timerL //load the LOW bits for timer
0011fb 93c0 0a8c                 	sts TCB0_CCMPL, r28
0011fd 91c0 2803                 	lds r28, pulse1_timerH //load the HIGH bits for timer
0011ff 93c0 0a8d                 	sts TCB0_CCMPH, r28
001201 e0c3                      	ldi r28, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
001202 93c0 0a80                 	sts TCB0_CTRLA, r28
                                 
                                 	//PULSE 2
001204 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
001205 93b0 0a91                 	sts TCB1_CTRLB, r27
001207 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001208 93b0 0a95                 	sts TCB1_INTCTRL, r27
00120a 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
00120c 93b0 0a9c                 	sts TCB1_CCMPL, r27
00120e 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
001210 93b0 0a9d                 	sts TCB1_CCMPH, r27
001212 e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
001213 93b0 0a90                 	sts TCB1_CTRLA, r27
                                 
                                 	//NOTE: The triangle timer is clocked at the same speed as the NES CPU, aka twice the NES APU.
                                 	//Therefore, we won't be using a /2 clock divider like we did with the pulse timers.
                                 	//TRIANGLE
001215 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
001216 93b0 0aa1                 	sts TCB2_CTRLB, r27
001218 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
                                 	//sts TCB2_INTCTRL, r27 //keep interrupts disabled to mute channel since triangle doesn't have volume bits
001219 91b0 2810                 	lds r27, triangle_timerL //load the LOW bits for timer
00121b 93b0 0aac                 	sts TCB2_CCMPL, r27
00121d 91b0 2811                 	lds r27, triangle_timerH //load the HIGH bits for timer
00121f 93b0 0aad                 	sts TCB2_CCMPH, r27
001221 e0b1                      	ldi r27, TCB_CLKSEL_CLKDIV1_gc | TCB_ENABLE_bm //use prescaler divider of 1 and enable timer
001222 93b0 0aa0                 	sts TCB2_CTRLA, r27
001224 9478                      	sei //global interrupt enable
                                 
                                 	//NOISE
001225 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
001226 93b0 0ab1                 	sts TCB3_CTRLB, r27
001228 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001229 93b0 0ab5                 	sts TCB3_INTCTRL, r27
00122b 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
00122d 93b0 0abc                 	sts TCB3_CCMPL, r27
00122f 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
001231 93b0 0abd                 	sts TCB3_CCMPH, r27
001233 e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
001234 93b0 0ab0                 	sts TCB3_CTRLA, r27
                                 
                                 
                                 
                                 //https://wiki.nesdev.com/w/index.php/APU_Mixer
                                 volume_mixer:
001236 91c0 2806                 	lds r28, pulse1_output_volume
001238 91d0 280e                 	lds r29, pulse2_output_volume
                                 
                                 volume_mixer_pulse1:
00123a fea0                      	sbrs pulse1_sequence, 0 //if the sequence output is zero, return
00123b c015                      	rjmp volume_mixer_pulse1_off
                                 
00123c 14b2                      	cp pulse1_length_counter, zero //if length is zero, return
00123d f099                      	breq volume_mixer_pulse1_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
00123e 91e0 0a8c                 	lds r30, TCB0_CCMPL
001240 e5f9                      	ldi r31, 0x59
001241 17ef                      	cp r30, r31
001242 91e0 0a8d                 	lds r30, TCB0_CCMPH
001244 e0f0                      	ldi r31, 0x00
001245 07ef                      	cpc r30, r31
001246 f050                      	brlo volume_mixer_pulse1_off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $595A
001247 91e0 0a8c                 	lds r30, TCB0_CCMPL
001249 e5fa                      	ldi r31, 0x5A
00124a 17ef                      	cp r30, r31
00124b 91e0 0a8d                 	lds r30, TCB0_CCMPH
00124d e5f9                      	ldi r31, 0x59
00124e 07ef                      	cpc r30, r31
00124f f408                      	brsh volume_mixer_pulse1_off
001250 c001                      	rjmp volume_mixer_pulse2 //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse1_off:
001251 27cc                      	clr r28
                                 
                                 volume_mixer_pulse2:
001252 fed0                      	sbrs pulse2_sequence, 0 //if the sequence output is zero, return
001253 c015                      	rjmp volume_mixer_pulse2_off
                                 
001254 14e2                      	cp pulse2_length_counter, zero //if length is zero, return
001255 f099                      	breq volume_mixer_pulse2_off
                                 
001256 91e0 0a9c                 	lds r30, TCB1_CCMPL
001258 e5f9                      	ldi r31, 0x59
001259 17ef                      	cp r30, r31
00125a 91e0 0a9d                 	lds r30, TCB1_CCMPH
00125c e0f0                      	ldi r31, 0x00
00125d 07ef                      	cpc r30, r31
00125e f050                      	brlo volume_mixer_pulse2_off
                                 
00125f 91e0 0a9c                 	lds r30, TCB1_CCMPL
001261 e5fa                      	ldi r31, 0x5A
001262 17ef                      	cp r30, r31
001263 91e0 0a9d                 	lds r30, TCB1_CCMPH
001265 e5f9                      	ldi r31, 0x59
001266 07ef                      	cpc r30, r31
001267 f408                      	brsh volume_mixer_pulse2_off
001268 c001                      	rjmp volume_mixer_pulse_out //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse2_off:
001269 27dd                      	clr r29
                                 
                                 volume_mixer_pulse_out:
00126a 0fcd                      	add r28, r29
00126b e6e2                      	ldi ZL, LOW(pulse_volume_table << 1)
00126c e0f2                      	ldi ZH, HIGH(pulse_volume_table << 1)
00126d 0fec                      	add ZL, r28
00126e 1df2                      	adc ZH, zero
00126f 91c4                      	lpm r28, Z
                                 
                                 volume_mixer_tnd_triangle:
001270 2fd4                      	mov r29, triangle_sequence
001271 fdd4                      	sbrc r29, 4 //check 5th bit
001272 95d0                      	com r29
001273 70df                      	andi r29, 0x0F
001274 2fed                      	mov r30, r29
001275 0fde                      	add r29, r30 //multiply the triangle volume by 3
001276 0fde                      	add r29, r30
                                 
                                 volume_mixer_tnd_noise:
001277 ff50                      	sbrs noise_sequence_LOW, 0 //check 0th bit, skip if set
001278 c004                      	rjmp volume_mixer_tnd_out
001279 91e0 2816                 	lds r30, noise_output_volume
00127b 0fee                      	lsl r30 //multiply noise volume by 2
00127c 0fde                      	add r29, r30
                                 
                                 volume_mixer_tnd_out:
00127d e8e2                      	ldi ZL, LOW(tnd_volume_table << 1)
00127e e0f2                      	ldi ZH, HIGH(tnd_volume_table << 1)
00127f 0fed                      	add ZL, r29
001280 1df2                      	adc ZH, zero
001281 91d4                      	lpm r29, Z
                                 
                                 volume_mixer_output:
001282 0fcd                      	add r28, r29
001283 b9c1                      	out VPORTA_OUT, r28
001284 cfb1                      	rjmp volume_mixer
                                 
                                 
                                 
                                 //FRAME COUNTER/AUDIO SAMPLE ISR
                                 sequence_0_2:
001285 b7bf                      	in r27, CPU_SREG
001286 93bf                      	push r27
001287 94f8                      	cli
                                 
                                 	//ENVELOPE
001288 d053                      	rcall pulse1_envelope_routine
001289 d09f                      	rcall pulse2_envelope_routine
                                 
00128a e5b0                      	ldi r27, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP2_bm //clear OVF flag
00128b 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
00128d 91bf                      	pop r27
00128e bfbf                      	out CPU_SREG, r27
00128f 9518                      	reti
                                 
                                 sequence_1_3:
001290 b7bf                      	in r27, CPU_SREG
001291 93bf                      	push r27
001292 94f8                      	cli
                                 
                                 	//ENVELOPE
001293 d048                      	rcall pulse1_envelope_routine
001294 d094                      	rcall pulse2_envelope_routine
                                 
                                 	//SWEEP
001295 fcc3                      	sbrc pulse1_sweep, 3 //check if the sweep enable bit is cleared
001296 d01b                      	rcall pulse1_sweep_routine
001297 fcf3                      	sbrc pulse2_sweep, 3
001298 d066                      	rcall pulse2_sweep_routine
                                 
                                 	//LENGTH
                                 	//NOTE: The length routine is relatively simple, so we will not be using clocks to rjmp and ret to a seperate lable
                                 sequence_1_3_pulse1_length:
001299 fd95                      	sbrc pulse_channel_flags, 5 //check if the length counter halt bit is cleared
00129a c002                      	rjmp sequence_1_3_pulse2_length
00129b 10b2                      	cpse pulse1_length_counter, zero //if length counter is already 0, don't decrement
00129c 94ba                      	dec pulse1_length_counter
                                 sequence_1_3_pulse2_length:
00129d fd91                      	sbrc pulse_channel_flags, 1 //check if the length counter halt bit is cleared
00129e c002                      	rjmp sequence_1_3_exit
00129f 10e2                      	cpse pulse2_length_counter, zero //if length counter is already 0, don't decrement
0012a0 94ea                      	dec pulse2_length_counter
                                 
                                 sequence_1_3_exit:
0012a1 e2b1                      	ldi r27, TCA_SINGLE_CMP1_bm | TCA_SINGLE_OVF_bm //clear OVF flag
0012a2 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
0012a4 91bf                      	pop r27
0012a5 bfbf                      	out CPU_SREG, r27
0012a6 9518                      	reti
                                 
                                 //PULSE 1 ROUTINES
                                 pulse1_sequence_routine:
0012a7 b7bf                      	in r27, CPU_SREG
0012a8 93bf                      	push r27
0012a9 94f8                      	cli
                                 
0012aa 0caa                      	lsl pulse1_sequence //shifts sequence to the left
0012ab 1ca2                      	adc pulse1_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
0012ac e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
0012ad 93b0 0a86                 	sts TCB0_INTFLAGS, r27
0012af 91bf                      	pop r27
0012b0 bfbf                      	out CPU_SREG, r27
0012b1 9518                      	reti
                                 
                                 pulse1_sweep_routine:
0012b2 2dbc                      	mov r27, pulse1_sweep
0012b3 70b7                      	andi r27, 0x07 //mask for period divider bits
0012b4 f4f9                      	brne pulse1_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse1_sweep_routine_action: //if the divider is == 0, update the pulse timer period
0012b5 93df                      	push r29
0012b6 2ddc                      	mov r29, pulse1_sweep
0012b7 95d2                      	swap r29
0012b8 70d7                      	andi r29, 0x07 //mask for shift bits
0012b9 f411                      	brne pulse1_sweep_routine_action_main //shift != 0
0012ba 91df                      	pop r29
0012bb c019                      	rjmp pulse1_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse1_sweep_routine_action_main:
0012bc 91a0 0a8c                 	lds r26, TCB0_CCMPL
0012be 91b0 0a8d                 	lds r27, TCB0_CCMPH
                                 pulse1_sweep_routine_action_main_loop:
0012c0 95b6                      	lsr r27
0012c1 95a7                      	ror r26
0012c2 95da                      	dec r29
0012c3 f7e1                      	brne pulse1_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
0012c4 fec7                      	sbrs pulse1_sweep, 7 //check the negate flag
0012c5 c002                      	rjmp pulse1_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
0012c6 95a0                      	com r26 //pulse1 uses one's complement if the negate flag is set
0012c7 95b0                      	com r27
                                 
                                 pulse1_sweep_routine_action_main_add:
0012c8 91d0 0a8c                 	lds r29, TCB0_CCMPL //perform addition to get new timer period
0012ca 0fad                      	add r26, r29
0012cb 91d0 0a8d                 	lds r29, TCB0_CCMPH
0012cd 1fbd                      	adc r27, r29
                                 
0012ce 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new LOW bits for timer
0012d0 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new HIGH bits for timer
                                 	
0012d2 91df                      	pop r29
0012d3 c001                      	rjmp pulse1_sweep_routine_check_reload
                                 
                                 pulse1_sweep_routine_decrement_divider:
0012d4 94ca                      	dec pulse1_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse1_sweep_routine_check_reload:
0012d5 ff97                      	sbrs pulse_channel_flags, 7 //if the reload flag is set, reload the sweep divider
0012d6 9508                      	ret
                                 
                                 pulse1_sweep_reload:
0012d7 90c0 2801                 	lds pulse1_sweep, pulse1_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
0012d9 94c2                      	swap pulse1_sweep //bring data from high byte to low byte
0012da 779f                      	cbr pulse_channel_flags, 0b10000000 //clear reload flag
0012db 9508                      	ret
                                 
                                 
                                 
                                 pulse1_envelope_routine:
0012dc fd96                      	sbrc pulse_channel_flags, 6 //check if start flag is cleared
0012dd c010                      	rjmp pulse1_envelope_routine_clear_start
                                 
0012de 3000                      	cpi pulse1_volume_divider, 0x00 //check if the divider is 0
0012df f011                      	breq PC+3 //if the divider == 0, check loop flag
0012e0 950a                      	dec pulse1_volume_divider //if the divider != 0, decrement and return
0012e1 9508                      	ret
                                 
0012e2 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the divider == 0, reset the divider period
0012e4 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
0012e5 ff95                      	sbrs pulse_channel_flags, 5 //check if the loop flag is set
0012e6 c002                      	rjmp pulse1_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
0012e7 e01f                      	ldi pulse1_volume_decay, 0x0F //if the loop flag is set, reset decay and return
0012e8 9508                      	ret
                                 
                                 pulse1_envelope_routine_decrement_decay:
0012e9 3010                      	cpi pulse1_volume_decay, 0x00 //check if the decay is 0
0012ea f409                      	brne PC+2 //if decay != 0, go decrement
0012eb 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
0012ec 951a                      	dec pulse1_volume_decay
0012ed 9508                      	ret
                                 
                                 pulse1_envelope_routine_clear_start:
0012ee 7b9f                      	cbr pulse_channel_flags, 0b01000000 //if the start flag is set, clear it
0012ef 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the start flag is set, reset the divider period
0012f1 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
0012f2 e01f                      	ldi pulse1_volume_decay, 0x0F //if the start flag is set, reset decay
0012f3 9508                      	ret
                                 
                                 //PULSE 2 ROUTINES
                                 pulse2_sequence_routine:
0012f4 b7bf                      	in r27, CPU_SREG
0012f5 93bf                      	push r27
0012f6 94f8                      	cli
                                 
0012f7 0cdd                      	lsl pulse2_sequence //shifts sequence to the left
0012f8 1cd2                      	adc pulse2_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
0012f9 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
0012fa 93b0 0a96                 	sts TCB1_INTFLAGS, r27
0012fc 91bf                      	pop r27
0012fd bfbf                      	out CPU_SREG, r27
0012fe 9518                      	reti
                                 
                                 pulse2_sweep_routine:
0012ff 2dbf                      	mov r27, pulse2_sweep
001300 70b7                      	andi r27, 0x07 //mask for period divider bits
001301 f4f9                      	brne pulse2_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse2_sweep_routine_action: //if the divider is == 0, update the pulse timer period
001302 93df                      	push r29
001303 2ddf                      	mov r29, pulse2_sweep
001304 95d2                      	swap r29
001305 70d7                      	andi r29, 0x07 //mask for shift bits
001306 f411                      	brne pulse2_sweep_routine_action_main //shift != 0
001307 91df                      	pop r29
001308 c019                      	rjmp pulse2_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse2_sweep_routine_action_main:
001309 91a0 0a9c                 	lds r26, TCB1_CCMPL
00130b 91b0 0a9d                 	lds r27, TCB1_CCMPH
                                 pulse2_sweep_routine_action_main_loop:
00130d 95b6                      	lsr r27
00130e 95a7                      	ror r26
00130f 95da                      	dec r29
001310 f7e1                      	brne pulse2_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
001311 fef7                      	sbrs pulse2_sweep, 7 //check the negate flag
001312 c002                      	rjmp pulse2_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
001313 95a0                      	com r26 //pulse2 uses one's complement if the negate flag is set
001314 95b0                      	com r27
                                 
                                 pulse2_sweep_routine_action_main_add:
001315 91d0 0a9c                 	lds r29, TCB1_CCMPL //perform addition to get new timer period
001317 0fad                      	add r26, r29
001318 91d0 0a9d                 	lds r29, TCB1_CCMPH
00131a 1fbd                      	adc r27, r29
                                 
00131b 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new LOW bits for timer
00131d 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new HIGH bits for timer
                                 	
00131f 91df                      	pop r29
001320 c001                      	rjmp pulse2_sweep_routine_check_reload
                                 
                                 pulse2_sweep_routine_decrement_divider:
001321 94fa                      	dec pulse2_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse2_sweep_routine_check_reload:
001322 ff93                      	sbrs pulse_channel_flags, 3 //if the reload flag is set, reload the sweep divider
001323 9508                      	ret
                                 
                                 pulse2_sweep_reload:
001324 90f0 2809                 	lds pulse2_sweep, pulse2_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
001326 94f2                      	swap pulse2_sweep //bring data from high byte to low byte
001327 7f97                      	cbr pulse_channel_flags, 0b00001000 //clear reload flag
001328 9508                      	ret
                                 
                                 
                                 
                                 pulse2_envelope_routine:
001329 fd92                      	sbrc pulse_channel_flags, 2 //check if start flag is cleared
00132a c010                      	rjmp pulse2_envelope_routine_clear_start
                                 
00132b 3020                      	cpi pulse2_volume_divider, 0x00 //check if the divider is 0
00132c f011                      	breq PC+3 //if the divider == 0, check loop flag
00132d 952a                      	dec pulse2_volume_divider //if the divider != 0, decrement and return
00132e 9508                      	ret
                                 
00132f 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the divider == 0, reset the divider period
001331 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
001332 ff91                      	sbrs pulse_channel_flags, 1 //check if the loop flag is set
001333 c002                      	rjmp pulse2_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
001334 e03f                      	ldi pulse2_volume_decay, 0x0F //if the loop flag is set, reset decay and return
001335 9508                      	ret
                                 
                                 pulse2_envelope_routine_decrement_decay:
001336 3030                      	cpi pulse2_volume_decay, 0x00 //check if the decay is 0
001337 f409                      	brne PC+2 //if decay != 0, go decrement
001338 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
001339 953a                      	dec pulse2_volume_decay
00133a 9508                      	ret
                                 
                                 pulse2_envelope_routine_clear_start:
00133b 7f9b                      	cbr pulse_channel_flags, 0b00000100 //if the start flag is set, clear it
00133c 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the start flag is set, reset the divider period
00133e 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
00133f e03f                      	ldi pulse2_volume_decay, 0x0F //if the start flag is set, reset decay
001340 9508                      	ret
                                 
                                 //TRIANGLE ROUTINES
                                 triangle_sequence_routine:
001341 b7bf                      	in r27, CPU_SREG
001342 93bf                      	push r27
001343 94f8                      	cli
                                 
001344 5f4f                      	subi triangle_sequence, -1 //increment sequence by 1
001345 714f                      	andi triangle_sequence, 0b00011111 //mask out bits 5, 6 and 7 NOTE: the sequence only needs bits 0-4.
                                 
001346 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
001347 93b0 0aa6                 	sts TCB2_INTFLAGS, r27
001349 91bf                      	pop r27
00134a bfbf                      	out CPU_SREG, r27
00134b 9518                      	reti
                                 
                                 //NOISE ROUTINES
                                 noise_sequence_routine:
00134c b7bf                      	in r27, CPU_SREG
00134d 93bf                      	push r27
00134e 94f8                      	cli
                                 
00134f 2fa5                      	mov r26, noise_sequence_LOW
001350 fd67                      	sbrc noise_sequence_HIGH, 7 //skip if MODE bit is clear
001351 c00b                      	rjmp noise_sequence_routine_mode_set
                                 
                                 noise_sequence_routine_mode_clear:
001352 95a6                      	lsr r26 //move the 1th bit to the 0th bit place
001353 27a5                      	eor r26, noise_sequence_LOW
001354 fda0                      	sbrc r26, 0 //skip if the EOR of bit 0 and 1 is clear
001355 c003                      	rjmp noise_sequence_routine_mode_clear_EOR_set
                                 
                                 noise_sequence_routine_mode_clear_EOR_clear:
001356 9566                      	lsr noise_sequence_HIGH
001357 9557                      	ror noise_sequence_LOW
001358 c013                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_clear_EOR_set:
001359 9566                      	lsr noise_sequence_HIGH
00135a 9557                      	ror noise_sequence_LOW
00135b 6460                      	ori noise_sequence_HIGH, 0b01000000 //set the 14th bit
00135c c00f                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_set:
00135d 0faa                      	lsl r26
00135e 1faa                      	rol r26
00135f 1faa                      	rol r26 //move the 6th bit to the 0th bit place
001360 27a5                      	eor r26, noise_sequence_LOW
001361 fda0                      	sbrc r26, 0 //skip if the EOR of bit 0 and 1 is clear
001362 c005                      	rjmp noise_sequence_routine_mode_set_EOR_set
                                 
                                 noise_sequence_routine_mode_set_EOR_clear:
001363 776f                      	cbr noise_sequence_HIGH, 0b10000000 //clear the MODE flag
001364 9566                      	lsr noise_sequence_HIGH
001365 9557                      	ror noise_sequence_LOW
001366 6860                      	sbr noise_sequence_HIGH, 0b10000000 //set the MODE flag
001367 c004                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_set_EOR_set:
001368 9566                      	lsr noise_sequence_HIGH
001369 9557                      	ror noise_sequence_LOW
00136a 6860                      	sbr noise_sequence_HIGH, 0b10000000 //set the MODE flag
00136b c000                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_exit:
00136c e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
00136d 93b0 0ab6                 	sts TCB3_INTFLAGS, r27
00136f 91bf                      	pop r27
001370 bfbf                      	out CPU_SREG, r27
001371 9518                      	reti
                                 
                                 //CONVERTERS
                                 //converts and loads 5 bit length to corresponding 8 bit length value into r29
                                 length_converter:
001372 ede6                      	ldi ZL, LOW(length << 1)
001373 e5fb                      	ldi ZH, HIGH(length << 1)
001374 0fed                      	add ZL, r29
001375 1df2                      	adc ZH, zero
001376 91d4                      	lpm r29, Z
001377 9508                      	ret
                                 
                                 //loads pulse sequence into r29
                                 duty_cycle_sequences:
001378 efe6                      	ldi ZL, LOW(sequences << 1)
001379 e5fb                      	ldi ZH, HIGH(sequences << 1)
00137a 0fed                      	add ZL, r29
00137b 1df2                      	adc ZH, zero
00137c 91d4                      	lpm r29, Z
00137d 9508                      	ret
                                 
                                 
                                 
                                 //SOUND DRIVER
                                 sound_driver:
00137e b7bf                      	in r27, CPU_SREG
00137f 93bf                      	push r27
001380 94f8                      	cli
001381 93cf                      	push r28
001382 93df                      	push r29
001383 93ef                      	push r30
001384 93ff                      	push r31
                                 
                                 	//SOUND DRIVER
001385 91a0 281f                 	lds r26, song_fx_Bxx
001387 3faf                      	cpi r26, 0xFF //0xFF means that the flag is disabled
001388 f4a9                      	brne sound_driver_fx_Bxx_routine
001389 91a0 2820                 	lds r26, song_fx_Cxx
00138b 11a2                      	cpse r26, zero
00138c c08b                      	rjmp sound_driver_fx_Cxx_routine
00138d 91a0 2821                 	lds r26, song_fx_Dxx
00138f 11a2                      	cpse r26, zero
001390 c096                      	rjmp sound_driver_fx_Dxx_routine
                                 
001391 91a0 281a                 	lds r26, song_frame_offset
001393 91b0 281b                 	lds r27, song_frame_offset+1
001395 91c0 281c                 	lds r28, song_size
001397 91d0 281d                 	lds r29, song_size+1
001399 17ac                      	cp r26, r28
00139a 07bd                      	cpc r27, r29
00139b f408                      	brsh sound_driver_fx_song_loop
00139c c101                      	rjmp sound_driver_channel0
                                 
                                 
                                 sound_driver_fx_song_loop:
00139d e0a0                      	ldi r26, 0x00
                                 sound_driver_fx_Bxx_routine:
00139e 91e0 2818                 	lds ZL, song_frames
0013a0 91f0 2819                 	lds ZH, song_frames+1
0013a2 27cc                      	clr r28 //initialize r29:r28 to 0
0013a3 27dd                      	clr r29
0013a4 95a3                      	inc r26 //increment xx parameter by 1
                                 sound_driver_fx_Bxx_routine_loop:
0013a5 95aa                      	dec r26
0013a6 f011                      	breq sound_driver_fx_Bxx_routine_loop_exit //once r26 == 0, r29:r28 will hold Bxx*(5*2).
0013a7 962a                      	adiw r29:r28, 10 //increment the offset by 10 because 5 channels, and each address takes 2 bytes (5*2 = 10)
0013a8 cffc                      	rjmp sound_driver_fx_Bxx_routine_loop
                                 
                                 sound_driver_fx_Bxx_routine_loop_exit:
0013a9 9622                      	adiw r29:r28, 2 //add 2 to skip the first 2 bytes (first 2 bytes is the song size)
0013aa 93c0 281a                 	sts song_frame_offset, r28
0013ac 93d0 281b                 	sts song_frame_offset+1, r29
0013ae 0fec                      	add ZL, r28
0013af 1ffd                      	adc ZH, r29
                                 
0013b0 91a5                      	lpm r26, Z+ //load the address of the frame(pattern)
0013b1 91b5                      	lpm r27, Z+
0013b2 0faa                      	lsl r26
0013b3 1fbb                      	rol r27
0013b4 93a0 2822                 	sts pulse1_pattern, r26
0013b6 93b0 2823                 	sts pulse1_pattern+1, r27
0013b8 91a5                      	lpm r26, Z+
0013b9 91b5                      	lpm r27, Z+
0013ba 0faa                      	lsl r26
0013bb 1fbb                      	rol r27
0013bc 93a0 2873                 	sts pulse2_pattern, r26
0013be 93b0 2874                 	sts pulse2_pattern+1, r27
0013c0 91a5                      	lpm r26, Z+
0013c1 91b5                      	lpm r27, Z+
0013c2 0faa                      	lsl r26
0013c3 1fbb                      	rol r27
0013c4 93a0 28c4                 	sts triangle_pattern, r26
0013c6 93b0 28c5                 	sts triangle_pattern+1, r27
0013c8 91a5                      	lpm r26, Z+
0013c9 91b5                      	lpm r27, Z+
0013ca 0faa                      	lsl r26
0013cb 1fbb                      	rol r27
0013cc 93a0 2910                 	sts noise_pattern, r26
0013ce 93b0 2911                 	sts noise_pattern+1, r27
                                 
0013d0 9220 2826                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
0013d2 9220 2827                 	sts pulse1_pattern_offset+1, zero
0013d4 9220 2824                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
0013d6 9220 2825                 	sts pulse1_pattern_delay_frames, zero
0013d8 9220 2877                 	sts pulse2_pattern_offset, zero
0013da 9220 2878                 	sts pulse2_pattern_offset+1, zero
0013dc 9220 2875                 	sts pulse2_pattern_delay_rows, zero
0013de 9220 2876                 	sts pulse2_pattern_delay_frames, zero
0013e0 9220 28c8                 	sts triangle_pattern_offset, zero
0013e2 9220 28c9                 	sts triangle_pattern_offset+1, zero
0013e4 9220 28c6                 	sts triangle_pattern_delay_rows, zero
0013e6 9220 28c7                 	sts triangle_pattern_delay_frames, zero
0013e8 9220 2914                 	sts noise_pattern_offset, zero
0013ea 9220 2915                 	sts noise_pattern_offset+1, zero
0013ec 9220 2912                 	sts noise_pattern_delay_rows, zero
0013ee 9220 2913                 	sts noise_pattern_delay_frames, zero
                                 
0013f0 efaf                      	ldi r26, 0xFF
0013f1 93a0 285f                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
0013f3 93a0 2860                 	sts pulse1_fx_Gxx_post, r26
0013f5 93a0 2871                 	sts pulse1_fx_Sxx_pre, r26
0013f7 93a0 2872                 	sts pulse1_fx_Sxx_post, r26
0013f9 93a0 28b0                 	sts pulse2_fx_Gxx_pre, r26
0013fb 93a0 28b1                 	sts pulse2_fx_Gxx_post, r26
0013fd 93a0 28c2                 	sts pulse2_fx_Sxx_pre, r26
0013ff 93a0 28c3                 	sts pulse2_fx_Sxx_post, r26
001401 93a0 28fc                 	sts triangle_fx_Gxx_pre, r26
001403 93a0 28fd                 	sts triangle_fx_Gxx_post, r26
001405 93a0 290e                 	sts triangle_fx_Sxx_pre, r26
001407 93a0 290f                 	sts triangle_fx_Sxx_post, r26
001409 93a0 294d                 	sts noise_fx_Gxx_pre, r26
00140b 93a0 294e                 	sts noise_fx_Gxx_post, r26
00140d 93a0 295f                 	sts noise_fx_Sxx_pre, r26
00140f 93a0 2960                 	sts noise_fx_Sxx_post, r26
                                 
001411 93a0 281f                 	sts song_fx_Bxx, r26 //reset all song effects
001413 9220 2820                 	sts song_fx_Cxx, zero
001415 9220 2821                 	sts song_fx_Dxx, zero
001417 c086                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_fx_Cxx_routine:
001418 91ff                      	pop r31
001419 91ef                      	pop r30
00141a 91df                      	pop r29
00141b 91cf                      	pop r28
00141c 91bf                      	pop r27
00141d bfbf                      	out CPU_SREG, r27
00141e 94f8                      	cli //disable global interrupts
                                 		
00141f efaf                      	ldi r26, 0xFF
001420 93a0 281f                 	sts song_fx_Bxx, r26 //reset all song effects
001422 9220 2820                 	sts song_fx_Cxx, zero
001424 9220 2821                 	sts song_fx_Dxx, zero
001426 9518                      	reti
                                 
                                 sound_driver_fx_Dxx_routine:
001427 91e0 2818                 	lds ZL, song_frames
001429 91f0 2819                 	lds ZH, song_frames+1
00142b 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
00142d 91b0 281b                 	lds r27, song_frame_offset+1
00142f 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
001430 93a0 281a                 	sts song_frame_offset, r26
001432 93b0 281b                 	sts song_frame_offset+1, r27
001434 0fea                      	add ZL, r26
001435 1ffb                      	adc ZH, r27
                                 
001436 91a5                      	lpm r26, Z+ //load the address of the next pattern
001437 91b5                      	lpm r27, Z+
001438 0faa                      	lsl r26
001439 1fbb                      	rol r27
00143a 93a0 2822                 	sts pulse1_pattern, r26
00143c 93b0 2823                 	sts pulse1_pattern+1, r27
00143e 91a5                      	lpm r26, Z+
00143f 91b5                      	lpm r27, Z+
001440 0faa                      	lsl r26
001441 1fbb                      	rol r27
001442 93a0 2873                 	sts pulse2_pattern, r26
001444 93b0 2874                 	sts pulse2_pattern+1, r27
001446 91a5                      	lpm r26, Z+
001447 91b5                      	lpm r27, Z+
001448 0faa                      	lsl r26
001449 1fbb                      	rol r27
00144a 93a0 28c4                 	sts triangle_pattern, r26
00144c 93b0 28c5                 	sts triangle_pattern+1, r27
00144e 91a5                      	lpm r26, Z+
00144f 91b5                      	lpm r27, Z+
001450 0faa                      	lsl r26
001451 1fbb                      	rol r27
001452 93a0 2910                 	sts noise_pattern, r26
001454 93b0 2911                 	sts noise_pattern+1, r27
                                 
001456 9220 2826                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001458 9220 2827                 	sts pulse1_pattern_offset+1, zero
00145a 9220 2824                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
00145c 9220 2825                 	sts pulse1_pattern_delay_frames, zero
00145e 9220 2877                 	sts pulse2_pattern_offset, zero
001460 9220 2878                 	sts pulse2_pattern_offset+1, zero
001462 9220 2875                 	sts pulse2_pattern_delay_rows, zero
001464 9220 2876                 	sts pulse2_pattern_delay_frames, zero
001466 9220 28c8                 	sts triangle_pattern_offset, zero
001468 9220 28c9                 	sts triangle_pattern_offset+1, zero
00146a 9220 28c6                 	sts triangle_pattern_delay_rows, zero
00146c 9220 28c7                 	sts triangle_pattern_delay_frames, zero
00146e 9220 2914                 	sts noise_pattern_offset, zero
001470 9220 2915                 	sts noise_pattern_offset+1, zero
001472 9220 2912                 	sts noise_pattern_delay_rows, zero
001474 9220 2913                 	sts noise_pattern_delay_frames, zero
                                 
001476 efaf                      	ldi r26, 0xFF
001477 93a0 285f                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
001479 93a0 2860                 	sts pulse1_fx_Gxx_post, r26
00147b 93a0 2871                 	sts pulse1_fx_Sxx_pre, r26
00147d 93a0 2872                 	sts pulse1_fx_Sxx_post, r26
00147f 93a0 28b0                 	sts pulse2_fx_Gxx_pre, r26
001481 93a0 28b1                 	sts pulse2_fx_Gxx_post, r26
001483 93a0 28c2                 	sts pulse2_fx_Sxx_pre, r26
001485 93a0 28c3                 	sts pulse2_fx_Sxx_post, r26
001487 93a0 28fc                 	sts triangle_fx_Gxx_pre, r26
001489 93a0 28fd                 	sts triangle_fx_Gxx_post, r26
00148b 93a0 290e                 	sts triangle_fx_Sxx_pre, r26
00148d 93a0 290f                 	sts triangle_fx_Sxx_post, r26
00148f 93a0 294d                 	sts noise_fx_Gxx_pre, r26
001491 93a0 294e                 	sts noise_fx_Gxx_post, r26
001493 93a0 295f                 	sts noise_fx_Sxx_pre, r26
001495 93a0 2960                 	sts noise_fx_Sxx_post, r26
                                 
001497 93a0 281f                 	sts song_fx_Bxx, r26 //reset all song effects
001499 9220 2820                 	sts song_fx_Cxx, zero
00149b 9220 2821                 	sts song_fx_Dxx, zero
00149d c000                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0:
00149e 91a0 2824                 	lds r26, pulse1_pattern_delay_rows
0014a0 91b0 2825                 	lds r27, pulse1_pattern_delay_frames
0014a2 9610                      	adiw r27:r26, 0
0014a3 f009                      	breq sound_driver_channel0_main //if the pattern delay is 0, proceed with sound driver procedures
0014a4 c2e4                      	rjmp sound_driver_channel0_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel0_main:
0014a5 91e0 2822                 	lds ZL, pulse1_pattern //current pattern for pulse 1
0014a7 91f0 2823                 	lds ZH, pulse1_pattern+1
0014a9 91a0 2826                 	lds r26, pulse1_pattern_offset //current offset in the pattern for pulse 1
0014ab 91b0 2827                 	lds r27, pulse1_pattern_offset+1
0014ad 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
0014ae 1ffb                      	adc ZH, r27
0014af 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel0_check_if_note: //check if data is a note (0x00 - 0x56)
0014b0 35b7                      	cpi r27, 0x57
0014b1 f408                      	brsh sound_driver_channel0_check_if_volume
0014b2 c17c                      	rjmp sound_driver_channel0_note
                                 sound_driver_channel0_check_if_volume: //check if data is volume (0x57-0x66)
0014b3 36b7                      	cpi r27, 0x67
0014b4 f408                      	brsh sound_driver_channel0_check_if_delay
0014b5 c1ba                      	rjmp sound_driver_channel0_volume
                                 sound_driver_channel0_check_if_delay: //check if data is a delay (0x67 - 0xE2)
0014b6 3eb3                      	cpi r27, 0xE3
0014b7 f408                      	brsh sound_driver_channel0_check_if_instrument
0014b8 c1c1                      	rjmp sound_driver_channel0_delay
                                 sound_driver_channel0_check_if_instrument: //check for instrument flag (0xE3)
0014b9 f409                      	brne sound_driver_channel0_check_if_release
0014ba c1c4                      	rjmp sound_driver_channel0_instrument_change 
                                 sound_driver_channel0_check_if_release: //check for note release flag (0xE4)
0014bb 3eb4                      	cpi r27, 0xE4
0014bc f409                      	brne sound_driver_channel0_check_if_end
0014bd c26d                      	rjmp sound_driver_channel0_release
                                 sound_driver_channel0_check_if_end:
0014be 3fbf                      	cpi r27, 0xFF
0014bf f409                      	brne sound_driver_channel0_check_if_fx
0014c0 c28f                      	rjmp sound_driver_channel0_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel0_check_if_fx: //fx flags (0xE5 - 0xFE)
0014c1 9631                      	adiw Z, 1 //point Z to the byte next to the flag
0014c2 91a4                      	lpm r26, Z //load the fx data into r26
0014c3 d2bb                      	rcall sound_driver_channel0_increment_offset_twice
                                 
0014c4 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
0014c5 efea                      	ldi ZL, LOW(channel0_fx << 1) //load in note table
0014c6 e5fb                      	ldi ZH, HIGH(channel0_fx << 1)
0014c7 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
0014c8 0feb                      	add ZL, r27 //add offset
0014c9 1df2                      	adc ZH, zero
0014ca 91c5                      	lpm r28, Z+ //load address bytes
0014cb 91d4                      	lpm r29, Z
0014cc 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
0014cd 2ffd                      	mov ZH, r29
0014ce 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel0_fx_0xy:
0014cf 93a0 2845                 	sts pulse1_fx_0xy_sequence, r26
0014d1 9220 2846                 	sts pulse1_fx_0xy_sequence+1, zero
0014d3 cfd1                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel0_fx_1xx:
0014d4 9220 284b                 	sts pulse1_fx_2xx, zero //turn off any 2xx pitch slide down
0014d6 9220 284c                 	sts pulse1_fx_2xx+1, zero
0014d8 9220 2845                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
0014da 9220 2846                 	sts pulse1_fx_0xy_sequence+1, zero
0014dc 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0014dd 937f                      	push r23
0014de 2f6a                      	mov r22, r26 //store the rate into r22
0014df eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0014e0 9f67                      	mul r22, r23
0014e1 917f                      	pop r23
0014e2 916f                      	pop r22
                                 
0014e3 9416                      	lsr r1 //shift out the fractional bits
0014e4 9407                      	ror r0
0014e5 9416                      	lsr r1
0014e6 9407                      	ror r0
0014e7 9416                      	lsr r1
0014e8 9407                      	ror r0
0014e9 9416                      	lsr r1
0014ea 9407                      	ror r0
0014eb 9200 2847                 	sts pulse1_fx_1xx, r0
0014ed 9210 2848                 	sts pulse1_fx_1xx+1, r1
0014ef cfb5                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel0_fx_2xx:
0014f0 9220 2847                 	sts pulse1_fx_1xx, zero //turn off any 1xx pitch slide down
0014f2 9220 2848                 	sts pulse1_fx_1xx+1, zero
0014f4 9220 2845                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
0014f6 9220 2846                 	sts pulse1_fx_0xy_sequence+1, zero
0014f8 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0014f9 937f                      	push r23
0014fa 2f6a                      	mov r22, r26 //store the rate into r22
0014fb eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0014fc 9f67                      	mul r22, r23
0014fd 917f                      	pop r23
0014fe 916f                      	pop r22
                                 
0014ff 9416                      	lsr r1 //shift out the fractional bits
001500 9407                      	ror r0
001501 9416                      	lsr r1
001502 9407                      	ror r0
001503 9416                      	lsr r1
001504 9407                      	ror r0
001505 9416                      	lsr r1
001506 9407                      	ror r0
001507 9200 284b                 	sts pulse1_fx_2xx, r0
001509 9210 284c                 	sts pulse1_fx_2xx+1, r1
00150b cf99                      	rjmp sound_driver_channel0_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel0_fx_3xx:
00150c 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00150d 937f                      	push r23
00150e 2f6a                      	mov r22, r26 //store the rate into r22
00150f eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001510 9f67                      	mul r22, r23
001511 917f                      	pop r23
001512 916f                      	pop r22
                                 
001513 9416                      	lsr r1 //shift out the fractional bits
001514 9407                      	ror r0
001515 9416                      	lsr r1
001516 9407                      	ror r0
001517 9416                      	lsr r1
001518 9407                      	ror r0
001519 9416                      	lsr r1
00151a 9407                      	ror r0
00151b 9200 2853                 	sts pulse1_fx_3xx_speed, r0
00151d 9210 2854                 	sts pulse1_fx_3xx_speed+1, r1
                                 
00151f 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001520 c001                      	rjmp sound_driver_channel0_fx_3xx_enabled
001521 cf83                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_3xx_enabled:
001522 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001524 91b0 0a8d                 	lds r27, TCB0_CCMPH
001526 93a0 284f                 	sts pulse1_fx_3xx_start, r26
001528 93b0 2850                 	sts pulse1_fx_3xx_start+1, r27
                                 
00152a 9220 2855                 	sts pulse1_fx_3xx_total_offset, zero
00152c 9220 2856                 	sts pulse1_fx_3xx_total_offset+1, zero
00152e cf76                      	rjmp sound_driver_channel0_main
                                 
                                 //VIBRATO
                                 sound_driver_channel0_fx_4xy:
00152f 2fba                      	mov r27, r26
001530 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001531 95a2                      	swap r26
001532 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001533 93a0 2857                 	sts pulse1_fx_4xy_speed, r26
001535 93b0 2858                 	sts pulse1_fx_4xy_depth, r27
001537 9220 2859                 	sts pulse1_fx_4xy_phase, zero //reset the phase to 0
001539 cf6b                      	rjmp sound_driver_channel0_main
                                 
                                 //TREMELO
                                 sound_driver_channel0_fx_7xy:
00153a 2fba                      	mov r27, r26
00153b 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
00153c 95a2                      	swap r26
00153d 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
00153e 93a0 285a                 	sts pulse1_fx_7xy_speed, r26
001540 93b0 285b                 	sts pulse1_fx_7xy_depth, r27
001542 9220 285c                 	sts pulse1_fx_7xy_phase, zero //reset the phase to 0
001544 9220 285d                 	sts pulse1_fx_7xy_value, zero //reset the tremelo value
001546 cf5e                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel0_fx_Axy:
001547 93a0 285e                 	sts pulse1_fx_Axy, r26
001549 cf5b                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel0_fx_Bxx:
00154a 93a0 281f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
00154c cf58                      	rjmp sound_driver_channel0_main
                                 
                                 //HALT
                                 sound_driver_channel0_fx_Cxx:
00154d 93b0 2820                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
00154f cf55                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel0_fx_Dxx:
001550 93b0 2821                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001552 cf52                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME
                                 sound_driver_channel0_fx_Exx:
001553 91b0 2800                 	lds r27, pulse1_param
001555 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
001556 2bba                      	or r27, r26 //move new VVVV bits into pulse1_param
001557 93b0 2800                 	sts pulse1_param, r27
001559 6096                      	sbr pulse_channel_flags, 6
00155a cf4a                      	rjmp sound_driver_channel0_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel0_fx_Fxx:
00155b 93a0 281e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
00155d cf47                      	rjmp sound_driver_channel0_main
                                 
                                 //DELAY
                                 sound_driver_channel0_fx_Gxx:
00155e 15a2                      	cp r26, zero
00155f f051                      	breq sound_driver_channel0_fx_Gxx_invalid
001560 91b0 281e                 	lds r27, song_speed
001562 17ab                      	cp r26, r27
001563 f430                      	brsh sound_driver_channel0_fx_Gxx_invalid
001564 93a0 285f                 	sts pulse1_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001566 e0b1                      	ldi r27, 0x01
001567 93b0 2824                 	sts pulse1_pattern_delay_rows, r27
001569 c222                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Gxx_invalid:
00156a cf3a                      	rjmp sound_driver_channel0_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel0_fx_Hxy: //hardware sweep up
00156b cf39                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixy: //hardware sweep down
00156c cf38                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Hxx: //FDS modulation depth
00156d cf37                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixx: //FDS modulation speed
00156e cf36                      	rjmp sound_driver_channel0_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel0_fx_Pxx:
00156f 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001570 937f                      	push r23
001571 2f6a                      	mov r22, r26
001572 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001573 0367                      	mulsu r22, r23
001574 917f                      	pop r23
001575 916f                      	pop r22
001576 9416                      	lsr r1 //shift out the fractional bits
001577 9407                      	ror r0
001578 9416                      	lsr r1
001579 9407                      	ror r0
00157a 9416                      	lsr r1
00157b 9407                      	ror r0
00157c 9416                      	lsr r1
00157d 9407                      	ror r0
00157e fe13                      	sbrs r1, 3 //check if result was a negative number
00157f c002                      	rjmp sound_driver_channel0_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel0_fx_Pxx_negative:
001580 efb0                      	ldi r27, 0xF0
001581 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel0_fx_Pxx_store:
001582 9200 2861                 	sts pulse1_fx_Pxx_total, r0
001584 9210 2862                 	sts pulse1_fx_Pxx_total+1, r1
001586 cf1e                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel0_fx_Qxy:
                                 sound_driver_channel0_fx_Qxy_check_arpeggio_macro:
001587 91e0 282d                 	lds ZL, pulse1_arpeggio_macro
001589 91f0 282e                 	lds ZH, pulse1_arpeggio_macro+1
00158b 9630                      	adiw Z, 0
00158c f009                      	breq sound_driver_channel0_fx_Qxy_check_pitch_macro
00158d cf17                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_pitch_macro:
00158e 91e0 2835                 	lds ZL, pulse1_pitch_macro
001590 91f0 2836                 	lds ZH, pulse1_pitch_macro+1
001592 9630                      	adiw Z, 0
001593 f009                      	breq sound_driver_channel0_fx_Qxy_check_hi_pitch_macro
001594 cf10                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_hi_pitch_macro:
001595 91e0 283b                 	lds ZL, pulse1_hi_pitch_macro
001597 91f0 283c                 	lds ZH, pulse1_hi_pitch_macro+1
001599 9630                      	adiw Z, 0
00159a f009                      	breq sound_driver_channel0_fx_Qxy_process
00159b cf09                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_process:
00159c 2fba                      	mov r27, r26 //copy fx parameters into r27
00159d 70bf                      	andi r27, 0x0F //mask note index offset
00159e 91c0 2863                 	lds r28, pulse1_fx_Qxy_target_note //load current note index
0015a0 0fbc                      	add r27, r28
0015a1 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
0015a2 f008                      	brlo sound_driver_channel0_fx_Qxy_process_continue
0015a3 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel0_fx_Qxy_process_continue:
0015a4 93b0 2863                 	sts pulse1_fx_Qxy_target_note, r27
0015a6 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0015a7 e0f0                      	ldi ZH, HIGH(note_table << 1)
0015a8 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
0015a9 0feb                      	add ZL, r27 //add offset
0015aa 1df2                      	adc ZH, zero
0015ab 91c5                      	lpm r28, Z+ //load bytes
0015ac 91d4                      	lpm r29, Z
0015ad 93c0 2864                 	sts pulse1_fx_Qxy_target, r28 //load the LOW bits for the target period
0015af 93d0 2865                 	sts pulse1_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel0_fx_Qxy_process_speed:
0015b1 95a2                      	swap r26
0015b2 70af                      	andi r26, 0x0F //mask effect speed
0015b3 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0015b4 95a3                      	inc r26 //increment the speed by 1
                                 
0015b5 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0015b6 937f                      	push r23
0015b7 2f6a                      	mov r22, r26 //store the speed data into r27
0015b8 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0015b9 9f67                      	mul r22, r23
0015ba 917f                      	pop r23
0015bb 916f                      	pop r22
                                 
0015bc 9416                      	lsr r1 //shift out the fractional bits
0015bd 9407                      	ror r0
0015be 9416                      	lsr r1
0015bf 9407                      	ror r0
0015c0 9416                      	lsr r1
0015c1 9407                      	ror r0
0015c2 9416                      	lsr r1
0015c3 9407                      	ror r0
                                 
0015c4 9200 2866                 	sts pulse1_fx_Qxy_speed, r0 //store the effect speed
0015c6 9210 2867                 	sts pulse1_fx_Qxy_speed+1, r1
0015c8 cedc                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel0_fx_Rxy:
                                 sound_driver_channel0_fx_Rxy_check_arpeggio_macro:
0015c9 91e0 282d                 	lds ZL, pulse1_arpeggio_macro
0015cb 91f0 282e                 	lds ZH, pulse1_arpeggio_macro+1
0015cd 9630                      	adiw Z, 0
0015ce f009                      	breq sound_driver_channel0_fx_Rxy_check_pitch_macro
0015cf ced5                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_pitch_macro:
0015d0 91e0 2835                 	lds ZL, pulse1_pitch_macro
0015d2 91f0 2836                 	lds ZH, pulse1_pitch_macro+1
0015d4 9630                      	adiw Z, 0
0015d5 f009                      	breq sound_driver_channel0_fx_Rxy_check_hi_pitch_macro
0015d6 cece                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_hi_pitch_macro:
0015d7 91e0 283b                 	lds ZL, pulse1_hi_pitch_macro
0015d9 91f0 283c                 	lds ZH, pulse1_hi_pitch_macro+1
0015db 9630                      	adiw Z, 0
0015dc f009                      	breq sound_driver_channel0_fx_Rxy_process
0015dd cec7                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_process:
0015de 2fba                      	mov r27, r26 //copy fx parameters into r27
0015df 70bf                      	andi r27, 0x0F //mask note index offset
0015e0 91c0 286a                 	lds r28, pulse1_fx_Rxy_target_note //load current note index
0015e2 1bcb                      	sub r28, r27
0015e3 f408                      	brcc sound_driver_channel0_fx_Rxy_process_continue
0015e4 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel0_fx_Rxy_process_continue:
0015e5 93c0 286a                 	sts pulse1_fx_Rxy_target_note, r28
0015e7 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0015e8 e0f0                      	ldi ZH, HIGH(note_table << 1)
0015e9 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
0015ea 0fec                      	add ZL, r28 //add offset
0015eb 1df2                      	adc ZH, zero
0015ec 91c5                      	lpm r28, Z+ //load bytes
0015ed 91d4                      	lpm r29, Z
0015ee 93c0 286b                 	sts pulse1_fx_Rxy_target, r28 //load the LOW bits for the target period
0015f0 93d0 286c                 	sts pulse1_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel0_fx_Rxy_process_speed:
0015f2 95a2                      	swap r26
0015f3 70af                      	andi r26, 0x0F //mask effect speed
0015f4 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0015f5 95a3                      	inc r26 //increment the speed by 1
                                 
0015f6 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0015f7 937f                      	push r23
0015f8 2f6a                      	mov r22, r26 //store the speed data into r27
0015f9 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0015fa 9f67                      	mul r22, r23
0015fb 917f                      	pop r23
0015fc 916f                      	pop r22
                                 
0015fd 9416                      	lsr r1 //shift out the fractional bits
0015fe 9407                      	ror r0
0015ff 9416                      	lsr r1
001600 9407                      	ror r0
001601 9416                      	lsr r1
001602 9407                      	ror r0
001603 9416                      	lsr r1
001604 9407                      	ror r0
                                 
001605 9200 286d                 	sts pulse1_fx_Rxy_speed, r0 //store the effect speed
001607 9210 286e                 	sts pulse1_fx_Rxy_speed+1, r1
001609 ce9b                      	rjmp sound_driver_channel0_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel0_fx_Sxx:
00160a 15a2                      	cp r26, zero
00160b f051                      	breq sound_driver_channel0_fx_Sxx_invalid
00160c 91b0 281e                 	lds r27, song_speed
00160e 17ab                      	cp r26, r27
00160f f430                      	brsh sound_driver_channel0_fx_Sxx_invalid
001610 93a0 2871                 	sts pulse1_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001612 e0b1                      	ldi r27, 0x01
001613 93b0 2824                 	sts pulse1_pattern_delay_rows, r27
001615 c176                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Sxx_invalid:
001616 ce8e                      	rjmp sound_driver_channel0_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel0_fx_Vxx:
001617 efe6                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
001618 e5fb                      	ldi ZH, HIGH(sequences << 1)
001619 0fea                      	add ZL, r26 //offset the pointer
00161a 1df2                      	adc ZH, zero
                                 
00161b 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
00161c 95a7                      	ror r26
00161d 95a7                      	ror r26
00161e 91b0 2800                 	lds r27, pulse1_param //load r27 with pulse1_param (register $4000)
001620 2fcb                      	mov r28, r27 //store a copy of pulse1_param into r28
001621 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
001622 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
001623 c001                      	rjmp sound_driver_channel0_fx_Vxx_store
001624 ce80                      	rjmp sound_driver_channel0_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel0_fx_Vxx_store:
001625 90a4                      	lpm pulse1_sequence, Z //store the sequence
                                 
001626 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
001627 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
001628 93c0 2800                 	sts pulse1_param, r28
00162a ce7a                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_Wxx: //DPCM sample speed
00162b ce79                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Xxx: //DPCM sample retrigger
00162c ce78                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Yxx: //DPCM sample offset
00162d ce77                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Zxx: //DPCM sample delta counter
00162e ce76                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 sound_driver_channel0_note:
00162f 93b0 2807                 	sts pulse1_note, r27 //store the note index
001631 93b0 2863                 	sts pulse1_fx_Qxy_target_note, r27
001633 93b0 286a                 	sts pulse1_fx_Rxy_target_note, r27
001635 e0a3                      	ldi r26, 0x03
001636 e0b2                      	ldi r27, 0x02
001637 93b0 282a                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
001639 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26
00163b 93b0 2837                 	sts pulse1_pitch_macro_offset, r27
00163d 93b0 283d                 	sts pulse1_hi_pitch_macro_offset, r27
00163f 93b0 2842                 	sts pulse1_duty_macro_offset, r27
001641 9220 2833                 	sts pulse1_total_pitch_offset, zero //reset the pitch and hi pitch offset
001643 9220 2834                 	sts pulse1_total_pitch_offset+1, zero
001645 9220 283a                 	sts pulse1_total_hi_pitch_offset, zero
001647 9220 2849                 	sts pulse1_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001649 9220 284a                 	sts pulse1_fx_1xx_total+1, zero
00164b 9220 284d                 	sts pulse1_fx_2xx_total, zero
00164d 9220 284e                 	sts pulse1_fx_2xx_total+1, zero
00164f 9220 2855                 	sts pulse1_fx_3xx_total_offset, zero //reset 3xx offset
001651 9220 2856                 	sts pulse1_fx_3xx_total_offset+1, zero
001653 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001655 91b0 0a8d                 	lds r27, TCB0_CCMPH
001657 93a0 284f                 	sts pulse1_fx_3xx_start, r26
001659 93b0 2850                 	sts pulse1_fx_3xx_start+1, r27
00165b 9220 2801                 	sts pulse1_sweep_param, zero //reset any sweep effect
00165d 6097                      	sbr pulse_channel_flags, 7 //set reload flag
00165e 9220 2864                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001660 9220 2865                 	sts pulse1_fx_Qxy_target+1, zero
001662 9220 2868                 	sts pulse1_fx_Qxy_total_offset, zero
001664 9220 2869                 	sts pulse1_fx_Qxy_total_offset+1, zero
001666 9220 286b                 	sts pulse1_fx_Rxy_target, zero
001668 9220 286c                 	sts pulse1_fx_Rxy_target+1, zero
00166a 9220 286f                 	sts pulse1_fx_Rxy_total_offset, zero
00166c 9220 2870                 	sts pulse1_fx_Rxy_total_offset+1, zero
00166e d106                      	rcall sound_driver_channel0_increment_offset
00166f ce35                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_volume:
001670 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001671 91a0 2800                 	lds r26, pulse1_param
001673 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001674 2bab                      	or r26, r27 //move new VVVV bits into pulse1_param
001675 93a0 2800                 	sts pulse1_param, r26
001677 6096                      	sbr pulse_channel_flags, 6
001678 d0fc                      	rcall sound_driver_channel0_increment_offset
001679 ce2b                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_delay:
00167a 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
00167b 93b0 2824                 	sts pulse1_pattern_delay_rows, r27
00167d d0f7                      	rcall sound_driver_channel0_increment_offset
00167e c10d                      	rjmp sound_driver_channel1
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change:
00167f 9220 2828                 	sts pulse1_volume_macro, zero //reset all macro addresses
001681 9220 2829                 	sts pulse1_volume_macro+1, zero
001683 9220 282d                 	sts pulse1_arpeggio_macro, zero
001685 9220 282e                 	sts pulse1_arpeggio_macro+1, zero
001687 9220 2835                 	sts pulse1_pitch_macro, zero
001689 9220 2836                 	sts pulse1_pitch_macro+1, zero
00168b 9220 283b                 	sts pulse1_hi_pitch_macro, zero
00168d 9220 283c                 	sts pulse1_hi_pitch_macro+1, zero
00168f 9220 2840                 	sts pulse1_duty_macro, zero
001691 9220 2841                 	sts pulse1_duty_macro+1, zero
001693 9220 2833                 	sts pulse1_total_pitch_offset, zero //reset the pitch offset
001695 9220 2834                 	sts pulse1_total_pitch_offset+1, zero
001697 9220 283a                 	sts pulse1_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001699 9631                      	adiw Z, 1 //point to the byte next to the flag
00169a 91b4                      	lpm r27, Z //store the instrument offset into r27
00169b e2ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
00169c e0fd                      	ldi ZH, HIGH(instruments)
00169d 0feb                      	add ZL, r27 //point Z to offsetted instrument
00169e 1df2                      	adc ZH, zero
00169f 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
0016a0 1fff                      	rol ZH
0016a1 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
0016a2 91b4                      	lpm r27, Z
                                 
0016a3 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
0016a4 1fbb                      	rol r27
0016a5 2fea                      	mov ZL, r26
0016a6 2ffb                      	mov ZH, r27
0016a7 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
0016a8 9632                      	adiw Z, 2 //point Z to the address of the macro
0016a9 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel0_instrument_change_macro_loop:
0016aa 95aa                      	dec r26
0016ab f019                      	breq sound_driver_channel0_instrument_change_exit
0016ac 95b6                      	lsr r27
0016ad f078                      	brcs sound_driver_channel0_instrument_change_load_macro
0016ae cffb                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_exit:
0016af e0a3                      	ldi r26, 0x03
0016b0 e0b2                      	ldi r27, 0x02
0016b1 93b0 282a                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
0016b3 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26
0016b5 93b0 2837                 	sts pulse1_pitch_macro_offset, r27
0016b7 93b0 283d                 	sts pulse1_hi_pitch_macro_offset, r27
0016b9 93b0 2842                 	sts pulse1_duty_macro_offset, r27
0016bb d0c3                      	rcall sound_driver_channel0_increment_offset_twice
0016bc cde8                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_load_macro:
0016bd 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
0016be 91d5                      	lpm r29, Z+
                                 
0016bf 30a5                      	cpi r26, 5
0016c0 f039                      	breq sound_driver_channel0_instrument_change_load_macro_volume
0016c1 30a4                      	cpi r26, 4
0016c2 f079                      	breq sound_driver_channel0_instrument_change_load_macro_arpeggio
0016c3 30a3                      	cpi r26, 3
0016c4 f0d9                      	breq sound_driver_channel0_instrument_change_load_macro_pitch
0016c5 30a2                      	cpi r26, 2
0016c6 f159                      	breq sound_driver_channel0_instrument_change_load_macro_hi_pitch
0016c7 c03c                      	rjmp sound_driver_channel0_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel0_instrument_change_load_macro_volume:
0016c8 93c0 2828                 	sts pulse1_volume_macro, r28
0016ca 93d0 2829                 	sts pulse1_volume_macro+1, r29
0016cc d041                      	rcall sound_driver_channel0_instrument_change_read_header
0016cd 93c0 282c                 	sts pulse1_volume_macro_release, r28
0016cf 93d0 282b                 	sts pulse1_volume_macro_loop, r29
0016d1 cfd8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 	
                                 sound_driver_channel0_instrument_change_load_macro_arpeggio:
0016d2 93c0 282d                 	sts pulse1_arpeggio_macro, r28
0016d4 93d0 282e                 	sts pulse1_arpeggio_macro+1, r29
0016d6 9220 2864                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0016d8 9220 2865                 	sts pulse1_fx_Qxy_target+1, zero
0016da 9220 286b                 	sts pulse1_fx_Rxy_target, zero
0016dc 9220 286c                 	sts pulse1_fx_Rxy_target+1, zero
0016de d03a                      	rcall sound_driver_channel0_instrument_change_read_header_arpeggio
0016df cfca                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_pitch:
0016e0 93c0 2835                 	sts pulse1_pitch_macro, r28
0016e2 93d0 2836                 	sts pulse1_pitch_macro+1, r29
0016e4 9220 2864                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0016e6 9220 2865                 	sts pulse1_fx_Qxy_target+1, zero
0016e8 9220 286b                 	sts pulse1_fx_Rxy_target, zero
0016ea 9220 286c                 	sts pulse1_fx_Rxy_target+1, zero
0016ec d021                      	rcall sound_driver_channel0_instrument_change_read_header
0016ed 93c0 2839                 	sts pulse1_pitch_macro_release, r28
0016ef 93d0 2838                 	sts pulse1_pitch_macro_loop, r29
0016f1 cfb8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_hi_pitch:
0016f2 93c0 283b                 	sts pulse1_hi_pitch_macro, r28
0016f4 93d0 283c                 	sts pulse1_hi_pitch_macro+1, r29
0016f6 9220 2864                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0016f8 9220 2865                 	sts pulse1_fx_Qxy_target+1, zero
0016fa 9220 286b                 	sts pulse1_fx_Rxy_target, zero
0016fc 9220 286c                 	sts pulse1_fx_Rxy_target+1, zero
0016fe d00f                      	rcall sound_driver_channel0_instrument_change_read_header
0016ff 93c0 283f                 	sts pulse1_hi_pitch_macro_release, r28
001701 93d0 283e                 	sts pulse1_hi_pitch_macro_loop, r29
001703 cfa6                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_duty:
001704 93c0 2840                 	sts pulse1_duty_macro, r28
001706 93d0 2841                 	sts pulse1_duty_macro+1, r29
001708 d005                      	rcall sound_driver_channel0_instrument_change_read_header
001709 93c0 2844                 	sts pulse1_duty_macro_release, r28
00170b 93d0 2843                 	sts pulse1_duty_macro_loop, r29
00170d cf9c                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_read_header:
00170e 93ef                      	push ZL
00170f 93ff                      	push ZH
001710 2fec                      	mov ZL, r28
001711 2ffd                      	mov ZH, r29
001712 0fee                      	lsl ZL
001713 1fff                      	rol ZH
001714 91c5                      	lpm r28, Z+
001715 91d4                      	lpm r29, Z
001716 91ff                      	pop ZH
001717 91ef                      	pop ZL
001718 9508                      	ret
                                 
                                 sound_driver_channel0_instrument_change_read_header_arpeggio:
001719 93ef                      	push ZL
00171a 93ff                      	push ZH
00171b 2fec                      	mov ZL, r28
00171c 2ffd                      	mov ZH, r29
00171d 0fee                      	lsl ZL
00171e 1fff                      	rol ZH
00171f 91c5                      	lpm r28, Z+
001720 91d5                      	lpm r29, Z+
001721 93c0 2831                 	sts pulse1_arpeggio_macro_release, r28
001723 93d0 2830                 	sts pulse1_arpeggio_macro_loop, r29
001725 91c4                      	lpm r28, Z
001726 93c0 2832                 	sts pulse1_arpeggio_macro_mode, r28
001728 91ff                      	pop ZH
001729 91ef                      	pop ZL
00172a 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel0_release:
                                 sound_driver_channel0_release_volume:
00172b 91b0 282c                 	lds r27, pulse1_volume_macro_release
00172d 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
00172e f019                      	breq sound_driver_channel0_release_arpeggio //if the macro has no release flag, check the next macro
00172f 95b3                      	inc r27
001730 93b0 282a                 	sts pulse1_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel0_release_arpeggio:
001732 91b0 2831                 	lds r27, pulse1_arpeggio_macro_release
001734 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001735 f019                      	breq sound_driver_channel0_release_pitch
001736 95b3                      	inc r27
001737 93b0 282f                 	sts pulse1_arpeggio_macro_offset, r27
                                 sound_driver_channel0_release_pitch:
001739 91b0 2839                 	lds r27, pulse1_pitch_macro_release
00173b 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
00173c f019                      	breq sound_driver_channel0_release_hi_pitch
00173d 95b3                      	inc r27
00173e 93b0 2837                 	sts pulse1_pitch_macro_offset, r27
                                 sound_driver_channel0_release_hi_pitch:
001740 91b0 283f                 	lds r27, pulse1_hi_pitch_macro_release
001742 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001743 f019                      	breq sound_driver_channel0_release_duty
001744 95b3                      	inc r27
001745 93b0 283d                 	sts pulse1_hi_pitch_macro_offset, r27
                                 sound_driver_channel0_release_duty:
001747 91b0 2844                 	lds r27, pulse1_duty_macro_release
001749 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
00174a f019                      	breq sound_driver_channel0_release_exit
00174b 95b3                      	inc r27
00174c 93b0 2842                 	sts pulse1_duty_macro_offset, r27
                                 sound_driver_channel0_release_exit:
00174e d026                      	rcall sound_driver_channel0_increment_offset
00174f cd55                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_next_pattern:
001750 91e0 2818                 	lds ZL, song_frames
001752 91f0 2819                 	lds ZH, song_frames+1
001754 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001756 91b0 281b                 	lds r27, song_frame_offset+1
001758 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
001759 93a0 281a                 	sts song_frame_offset, r26
00175b 93b0 281b                 	sts song_frame_offset+1, r27
                                 
00175d 91c0 281c                 	lds r28, song_size
00175f 91d0 281d                 	lds r29, song_size+1
001761 17ac                      	cp r26, r28
001762 07bd                      	cpc r27, r29
001763 f010                      	brlo sound_driver_channel0_next_pattern_exists
001764 940c 2de5                 	jmp sound_driver_exit
                                 
                                 sound_driver_channel0_next_pattern_exists:
001766 0fea                      	add ZL, r26
001767 1ffb                      	adc ZH, r27
                                 
001768 91a5                      	lpm r26, Z+ //load the address of the next pattern
001769 91b4                      	lpm r27, Z
00176a 0faa                      	lsl r26
00176b 1fbb                      	rol r27
00176c 93a0 2822                 	sts pulse1_pattern, r26
00176e 93b0 2823                 	sts pulse1_pattern+1, r27
                                 
001770 9220 2826                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001772 9220 2827                 	sts pulse1_pattern_offset+1, zero
001774 cd30                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_increment_offset:
001775 91e0 2826                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
001777 91f0 2827                 	lds ZH, pulse1_pattern_offset+1
001779 9631                      	adiw Z, 1
00177a 93e0 2826                 	sts pulse1_pattern_offset, ZL
00177c 93f0 2827                 	sts pulse1_pattern_offset+1, ZH
00177e 9508                      	ret
                                 
                                 sound_driver_channel0_increment_offset_twice: //used for data that takes up 2 bytes worth of space
00177f 91e0 2826                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
001781 91f0 2827                 	lds ZH, pulse1_pattern_offset+1
001783 9632                      	adiw Z, 2 //increment the pointer twice
001784 93e0 2826                 	sts pulse1_pattern_offset, ZL
001786 93f0 2827                 	sts pulse1_pattern_offset+1, ZH
001788 9508                      	ret
                                 
                                 sound_driver_channel0_decrement_frame_delay:
001789 95ba                      	dec r27
00178a 93b0 2825                 	sts pulse1_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel1:
00178c 91a0 2875                 	lds r26, pulse2_pattern_delay_rows
00178e 91b0 2876                 	lds r27, pulse2_pattern_delay_frames
001790 9610                      	adiw r27:r26, 0
001791 f009                      	breq sound_driver_channel1_main //if the pattern delay is 0, proceed with sound driver procedures
001792 c2d7                      	rjmp sound_driver_channel1_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel1_main:
001793 91e0 2873                 	lds ZL, pulse2_pattern //current pattern for pulse 2
001795 91f0 2874                 	lds ZH, pulse2_pattern+1
001797 91a0 2877                 	lds r26, pulse2_pattern_offset //current offset in the pattern for pulse 2
001799 91b0 2878                 	lds r27, pulse2_pattern_offset+1
00179b 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
00179c 1ffb                      	adc ZH, r27
00179d 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel1_check_if_note: //check if data is a note (0x00 - 0x56)
00179e 35b7                      	cpi r27, 0x57
00179f f408                      	brsh sound_driver_channel1_check_if_volume
0017a0 c17c                      	rjmp sound_driver_channel1_note
                                 sound_driver_channel1_check_if_volume: //check if data is volume (0x57-0x66)
0017a1 36b7                      	cpi r27, 0x67
0017a2 f408                      	brsh sound_driver_channel1_check_if_delay
0017a3 c1ba                      	rjmp sound_driver_channel1_volume
                                 sound_driver_channel1_check_if_delay: //check if data is a delay (0x67 - 0xE2)
0017a4 3eb3                      	cpi r27, 0xE3
0017a5 f408                      	brsh sound_driver_channel1_check_if_instrument
0017a6 c1c1                      	rjmp sound_driver_channel1_delay
                                 sound_driver_channel1_check_if_instrument: //check for instrument flag (0xE3)
0017a7 f409                      	brne sound_driver_channel1_check_if_release
0017a8 c1c4                      	rjmp sound_driver_channel1_instrument_change 
                                 sound_driver_channel1_check_if_release: //check for note release flag (0xE4)
0017a9 3eb4                      	cpi r27, 0xE4
0017aa f409                      	brne sound_driver_channel1_check_if_end
0017ab c26d                      	rjmp sound_driver_channel1_release
                                 sound_driver_channel1_check_if_end:
0017ac 3fbf                      	cpi r27, 0xFF
0017ad f409                      	brne sound_driver_channel1_check_if_fx
0017ae c28f                      	rjmp sound_driver_channel1_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel1_check_if_fx: //fx flags (0xE5 - 0xFE)
0017af 9631                      	adiw Z, 1 //point Z to the byte next to the flag
0017b0 91a4                      	lpm r26, Z //load the fx data into r26
0017b1 d2ae                      	rcall sound_driver_channel1_increment_offset_twice
                                 
0017b2 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
0017b3 e2ee                      	ldi ZL, LOW(channel1_fx << 1) //load in note table
0017b4 e5fc                      	ldi ZH, HIGH(channel1_fx << 1)
0017b5 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
0017b6 0feb                      	add ZL, r27 //add offset
0017b7 1df2                      	adc ZH, zero
0017b8 91c5                      	lpm r28, Z+ //load address bytes
0017b9 91d4                      	lpm r29, Z
0017ba 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
0017bb 2ffd                      	mov ZH, r29
0017bc 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel1_fx_0xy:
0017bd 93a0 2896                 	sts pulse2_fx_0xy_sequence, r26
0017bf 9220 2897                 	sts pulse2_fx_0xy_sequence+1, zero
0017c1 cfd1                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel1_fx_1xx:
0017c2 9220 289c                 	sts pulse2_fx_2xx, zero //turn off any 2xx pitch slide down
0017c4 9220 289d                 	sts pulse2_fx_2xx+1, zero
0017c6 9220 2896                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
0017c8 9220 2897                 	sts pulse2_fx_0xy_sequence+1, zero
0017ca 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0017cb 937f                      	push r23
0017cc 2f6a                      	mov r22, r26 //store the rate into r22
0017cd eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0017ce 9f67                      	mul r22, r23
0017cf 917f                      	pop r23
0017d0 916f                      	pop r22
                                 
0017d1 9416                      	lsr r1 //shift out the fractional bits
0017d2 9407                      	ror r0
0017d3 9416                      	lsr r1
0017d4 9407                      	ror r0
0017d5 9416                      	lsr r1
0017d6 9407                      	ror r0
0017d7 9416                      	lsr r1
0017d8 9407                      	ror r0
0017d9 9200 2898                 	sts pulse2_fx_1xx, r0
0017db 9210 2899                 	sts pulse2_fx_1xx+1, r1
0017dd cfb5                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel1_fx_2xx:
0017de 9220 2898                 	sts pulse2_fx_1xx, zero //turn off any 1xx pitch slide down
0017e0 9220 2899                 	sts pulse2_fx_1xx+1, zero
0017e2 9220 2896                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
0017e4 9220 2897                 	sts pulse2_fx_0xy_sequence+1, zero
0017e6 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0017e7 937f                      	push r23
0017e8 2f6a                      	mov r22, r26 //store the rate into r22
0017e9 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0017ea 9f67                      	mul r22, r23
0017eb 917f                      	pop r23
0017ec 916f                      	pop r22
                                 
0017ed 9416                      	lsr r1 //shift out the fractional bits
0017ee 9407                      	ror r0
0017ef 9416                      	lsr r1
0017f0 9407                      	ror r0
0017f1 9416                      	lsr r1
0017f2 9407                      	ror r0
0017f3 9416                      	lsr r1
0017f4 9407                      	ror r0
0017f5 9200 289c                 	sts pulse2_fx_2xx, r0
0017f7 9210 289d                 	sts pulse2_fx_2xx+1, r1
0017f9 cf99                      	rjmp sound_driver_channel1_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel1_fx_3xx:
0017fa 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0017fb 937f                      	push r23
0017fc 2f6a                      	mov r22, r26 //store the rate into r22
0017fd eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0017fe 9f67                      	mul r22, r23
0017ff 917f                      	pop r23
001800 916f                      	pop r22
                                 
001801 9416                      	lsr r1 //shift out the fractional bits
001802 9407                      	ror r0
001803 9416                      	lsr r1
001804 9407                      	ror r0
001805 9416                      	lsr r1
001806 9407                      	ror r0
001807 9416                      	lsr r1
001808 9407                      	ror r0
001809 9200 28a4                 	sts pulse2_fx_3xx_speed, r0
00180b 9210 28a5                 	sts pulse2_fx_3xx_speed+1, r1
                                 
00180d 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
00180e c001                      	rjmp sound_driver_channel1_fx_3xx_enabled
00180f cf83                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_3xx_enabled:
001810 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001812 91b0 0a9d                 	lds r27, TCB1_CCMPH
001814 93a0 28a0                 	sts pulse2_fx_3xx_start, r26
001816 93b0 28a1                 	sts pulse2_fx_3xx_start+1, r27
                                 
001818 9220 28a6                 	sts pulse2_fx_3xx_total_offset, zero
00181a 9220 28a7                 	sts pulse2_fx_3xx_total_offset+1, zero
00181c cf76                      	rjmp sound_driver_channel1_main
                                 
                                 //VIBRATO
                                 sound_driver_channel1_fx_4xy:
00181d 2fba                      	mov r27, r26
00181e 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
00181f 95a2                      	swap r26
001820 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001821 93a0 28a8                 	sts pulse2_fx_4xy_speed, r26
001823 93b0 28a9                 	sts pulse2_fx_4xy_depth, r27
001825 9220 28aa                 	sts pulse2_fx_4xy_phase, zero //reset the phase to 0
001827 cf6b                      	rjmp sound_driver_channel1_main
                                 
                                 //TREMELO
                                 sound_driver_channel1_fx_7xy:
001828 2fba                      	mov r27, r26
001829 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
00182a 95a2                      	swap r26
00182b 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
00182c 93a0 28ab                 	sts pulse2_fx_7xy_speed, r26
00182e 93b0 28ac                 	sts pulse2_fx_7xy_depth, r27
001830 9220 28ad                 	sts pulse2_fx_7xy_phase, zero //reset the phase to 0
001832 9220 28ae                 	sts pulse2_fx_7xy_value, zero //reset the tremelo value
001834 cf5e                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel1_fx_Axy:
001835 93a0 28af                 	sts pulse2_fx_Axy, r26
001837 cf5b                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel1_fx_Bxx:
001838 93a0 281f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
00183a cf58                      	rjmp sound_driver_channel1_main
                                 
                                 //HALT
                                 sound_driver_channel1_fx_Cxx:
00183b 93b0 2820                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
00183d cf55                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel1_fx_Dxx:
00183e 93b0 2821                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001840 cf52                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME
                                 sound_driver_channel1_fx_Exx:
001841 91b0 2808                 	lds r27, pulse2_param
001843 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
001844 2bba                      	or r27, r26 //move new VVVV bits into pulse2_param
001845 93b0 2808                 	sts pulse2_param, r27
001847 6092                      	sbr pulse_channel_flags, 2
001848 cf4a                      	rjmp sound_driver_channel1_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel1_fx_Fxx:
001849 93a0 281e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
00184b cf47                      	rjmp sound_driver_channel1_main
                                 
                                 //DELAY
                                 sound_driver_channel1_fx_Gxx:
00184c 15a2                      	cp r26, zero
00184d f051                      	breq sound_driver_channel1_fx_Gxx_invalid
00184e 91b0 281e                 	lds r27, song_speed
001850 17ab                      	cp r26, r27
001851 f430                      	brsh sound_driver_channel1_fx_Gxx_invalid
001852 93a0 28b0                 	sts pulse2_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001854 e0b1                      	ldi r27, 0x01
001855 93b0 2875                 	sts pulse2_pattern_delay_rows, r27
001857 c215                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Gxx_invalid:
001858 cf3a                      	rjmp sound_driver_channel1_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel1_fx_Hxy: //hardware sweep up
001859 cf39                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixy: //hardware sweep down
00185a cf38                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Hxx: //FDS modulation depth
00185b cf37                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixx: //FDS modulation speed
00185c cf36                      	rjmp sound_driver_channel1_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel1_fx_Pxx:
00185d 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00185e 937f                      	push r23
00185f 2f6a                      	mov r22, r26
001860 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001861 0367                      	mulsu r22, r23
001862 917f                      	pop r23
001863 916f                      	pop r22
001864 9416                      	lsr r1 //shift out the fractional bits
001865 9407                      	ror r0
001866 9416                      	lsr r1
001867 9407                      	ror r0
001868 9416                      	lsr r1
001869 9407                      	ror r0
00186a 9416                      	lsr r1
00186b 9407                      	ror r0
00186c fe13                      	sbrs r1, 3 //check if result was a negative number
00186d c002                      	rjmp sound_driver_channel1_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel1_fx_Pxx_negative:
00186e efb0                      	ldi r27, 0xF0
00186f 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel1_fx_Pxx_store:
001870 9200 28b2                 	sts pulse2_fx_Pxx_total, r0
001872 9210 28b3                 	sts pulse2_fx_Pxx_total+1, r1
001874 cf1e                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel1_fx_Qxy:
                                 sound_driver_channel1_fx_Qxy_check_arpeggio_macro:
001875 91e0 287e                 	lds ZL, pulse2_arpeggio_macro
001877 91f0 287f                 	lds ZH, pulse2_arpeggio_macro+1
001879 9630                      	adiw Z, 0
00187a f009                      	breq sound_driver_channel1_fx_Qxy_check_pitch_macro
00187b cf17                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_pitch_macro:
00187c 91e0 2886                 	lds ZL, pulse2_pitch_macro
00187e 91f0 2887                 	lds ZH, pulse2_pitch_macro+1
001880 9630                      	adiw Z, 0
001881 f009                      	breq sound_driver_channel1_fx_Qxy_check_hi_pitch_macro
001882 cf10                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_hi_pitch_macro:
001883 91e0 288c                 	lds ZL, pulse2_hi_pitch_macro
001885 91f0 288d                 	lds ZH, pulse2_hi_pitch_macro+1
001887 9630                      	adiw Z, 0
001888 f009                      	breq sound_driver_channel1_fx_Qxy_process
001889 cf09                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_process:
00188a 2fba                      	mov r27, r26 //copy fx parameters into r27
00188b 70bf                      	andi r27, 0x0F //mask note index offset
00188c 91c0 28b4                 	lds r28, pulse2_fx_Qxy_target_note //load current note index
00188e 0fbc                      	add r27, r28
00188f 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001890 f008                      	brlo sound_driver_channel1_fx_Qxy_process_continue
001891 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel1_fx_Qxy_process_continue:
001892 93b0 28b4                 	sts pulse2_fx_Qxy_target_note, r27
001894 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001895 e0f0                      	ldi ZH, HIGH(note_table << 1)
001896 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001897 0feb                      	add ZL, r27 //add offset
001898 1df2                      	adc ZH, zero
001899 91c5                      	lpm r28, Z+ //load bytes
00189a 91d4                      	lpm r29, Z
00189b 93c0 28b5                 	sts pulse2_fx_Qxy_target, r28 //load the LOW bits for the target period
00189d 93d0 28b6                 	sts pulse2_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel1_fx_Qxy_process_speed:
00189f 95a2                      	swap r26
0018a0 70af                      	andi r26, 0x0F //mask effect speed
0018a1 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0018a2 95a3                      	inc r26 //increment the speed by 1
                                 
0018a3 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0018a4 937f                      	push r23
0018a5 2f6a                      	mov r22, r26 //store the speed data into r27
0018a6 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0018a7 9f67                      	mul r22, r23
0018a8 917f                      	pop r23
0018a9 916f                      	pop r22
                                 
0018aa 9416                      	lsr r1 //shift out the fractional bits
0018ab 9407                      	ror r0
0018ac 9416                      	lsr r1
0018ad 9407                      	ror r0
0018ae 9416                      	lsr r1
0018af 9407                      	ror r0
0018b0 9416                      	lsr r1
0018b1 9407                      	ror r0
                                 
0018b2 9200 28b7                 	sts pulse2_fx_Qxy_speed, r0 //store the effect speed
0018b4 9210 28b8                 	sts pulse2_fx_Qxy_speed+1, r1
0018b6 cedc                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel1_fx_Rxy:
                                 sound_driver_channel1_fx_Rxy_check_arpeggio_macro:
0018b7 91e0 287e                 	lds ZL, pulse2_arpeggio_macro
0018b9 91f0 287f                 	lds ZH, pulse2_arpeggio_macro+1
0018bb 9630                      	adiw Z, 0
0018bc f009                      	breq sound_driver_channel1_fx_Rxy_check_pitch_macro
0018bd ced5                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_pitch_macro:
0018be 91e0 2886                 	lds ZL, pulse2_pitch_macro
0018c0 91f0 2887                 	lds ZH, pulse2_pitch_macro+1
0018c2 9630                      	adiw Z, 0
0018c3 f009                      	breq sound_driver_channel1_fx_Rxy_check_hi_pitch_macro
0018c4 cece                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_hi_pitch_macro:
0018c5 91e0 288c                 	lds ZL, pulse2_hi_pitch_macro
0018c7 91f0 288d                 	lds ZH, pulse2_hi_pitch_macro+1
0018c9 9630                      	adiw Z, 0
0018ca f009                      	breq sound_driver_channel1_fx_Rxy_process
0018cb cec7                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_process:
0018cc 2fba                      	mov r27, r26 //copy fx parameters into r27
0018cd 70bf                      	andi r27, 0x0F //mask note index offset
0018ce 91c0 28bb                 	lds r28, pulse2_fx_Rxy_target_note //load current note index
0018d0 1bcb                      	sub r28, r27
0018d1 f408                      	brcc sound_driver_channel1_fx_Rxy_process_continue
0018d2 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel1_fx_Rxy_process_continue:
0018d3 93c0 28bb                 	sts pulse2_fx_Rxy_target_note, r28
0018d5 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0018d6 e0f0                      	ldi ZH, HIGH(note_table << 1)
0018d7 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
0018d8 0fec                      	add ZL, r28 //add offset
0018d9 1df2                      	adc ZH, zero
0018da 91c5                      	lpm r28, Z+ //load bytes
0018db 91d4                      	lpm r29, Z
0018dc 93c0 28bc                 	sts pulse2_fx_Rxy_target, r28 //load the LOW bits for the target period
0018de 93d0 28bd                 	sts pulse2_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel1_fx_Rxy_process_speed:
0018e0 95a2                      	swap r26
0018e1 70af                      	andi r26, 0x0F //mask effect speed
0018e2 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0018e3 95a3                      	inc r26 //increment the speed by 1
                                 
0018e4 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0018e5 937f                      	push r23
0018e6 2f6a                      	mov r22, r26 //store the speed data into r27
0018e7 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0018e8 9f67                      	mul r22, r23
0018e9 917f                      	pop r23
0018ea 916f                      	pop r22
                                 
0018eb 9416                      	lsr r1 //shift out the fractional bits
0018ec 9407                      	ror r0
0018ed 9416                      	lsr r1
0018ee 9407                      	ror r0
0018ef 9416                      	lsr r1
0018f0 9407                      	ror r0
0018f1 9416                      	lsr r1
0018f2 9407                      	ror r0
                                 
0018f3 9200 28be                 	sts pulse2_fx_Rxy_speed, r0 //store the effect speed
0018f5 9210 28bf                 	sts pulse2_fx_Rxy_speed+1, r1
0018f7 ce9b                      	rjmp sound_driver_channel1_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel1_fx_Sxx:
0018f8 15a2                      	cp r26, zero
0018f9 f051                      	breq sound_driver_channel1_fx_Sxx_invalid
0018fa 91b0 281e                 	lds r27, song_speed
0018fc 17ab                      	cp r26, r27
0018fd f430                      	brsh sound_driver_channel1_fx_Sxx_invalid
0018fe 93a0 28c2                 	sts pulse2_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001900 e0b1                      	ldi r27, 0x01
001901 93b0 2875                 	sts pulse2_pattern_delay_rows, r27
001903 c169                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Sxx_invalid:
001904 ce8e                      	rjmp sound_driver_channel1_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel1_fx_Vxx:
001905 efe6                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
001906 e5fb                      	ldi ZH, HIGH(sequences << 1)
001907 0fea                      	add ZL, r26 //offset the pointer
001908 1df2                      	adc ZH, zero
                                 
001909 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
00190a 95a7                      	ror r26
00190b 95a7                      	ror r26
00190c 91b0 2808                 	lds r27, pulse2_param //load r27 with pulse2_param (register $4000)
00190e 2fcb                      	mov r28, r27 //store a copy of pulse2_param into r28
00190f 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
001910 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
001911 c001                      	rjmp sound_driver_channel1_fx_Vxx_store
001912 ce80                      	rjmp sound_driver_channel1_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel1_fx_Vxx_store:
001913 90d4                      	lpm pulse2_sequence, Z //store the sequence
                                 
001914 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
001915 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
001916 93c0 2808                 	sts pulse2_param, r28
001918 ce7a                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_Wxx: //DPCM sample speed
001919 ce79                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Xxx: //DPCM sample retrigger
00191a ce78                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Yxx: //DPCM sample offset
00191b ce77                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Zxx: //DPCM sample delta counter
00191c ce76                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 sound_driver_channel1_note:
00191d 93b0 280f                 	sts pulse2_note, r27 //store the note index
00191f 93b0 28b4                 	sts pulse2_fx_Qxy_target_note, r27
001921 93b0 28bb                 	sts pulse2_fx_Rxy_target_note, r27
001923 e0a3                      	ldi r26, 0x03
001924 e0b2                      	ldi r27, 0x02
001925 93b0 287b                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
001927 93a0 2880                 	sts pulse2_arpeggio_macro_offset, r26
001929 93b0 2888                 	sts pulse2_pitch_macro_offset, r27
00192b 93b0 288e                 	sts pulse2_hi_pitch_macro_offset, r27
00192d 93b0 2893                 	sts pulse2_duty_macro_offset, r27
00192f 9220 2884                 	sts pulse2_total_pitch_offset, zero //reset the pitch and hi pitch offset
001931 9220 2885                 	sts pulse2_total_pitch_offset+1, zero
001933 9220 288b                 	sts pulse2_total_hi_pitch_offset, zero
001935 9220 289a                 	sts pulse2_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001937 9220 289b                 	sts pulse2_fx_1xx_total+1, zero
001939 9220 289e                 	sts pulse2_fx_2xx_total, zero
00193b 9220 289f                 	sts pulse2_fx_2xx_total+1, zero
00193d 9220 28a6                 	sts pulse2_fx_3xx_total_offset, zero //reset 3xx offset
00193f 9220 28a7                 	sts pulse2_fx_3xx_total_offset+1, zero
001941 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001943 91b0 0a9d                 	lds r27, TCB1_CCMPH
001945 93a0 28a0                 	sts pulse2_fx_3xx_start, r26
001947 93b0 28a1                 	sts pulse2_fx_3xx_start+1, r27
001949 9220 2809                 	sts pulse2_sweep_param, zero //reset any sweep effect
00194b 6093                      	sbr pulse_channel_flags, 3 //set reload flag
00194c 9220 28b5                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00194e 9220 28b6                 	sts pulse2_fx_Qxy_target+1, zero
001950 9220 28b9                 	sts pulse2_fx_Qxy_total_offset, zero
001952 9220 28ba                 	sts pulse2_fx_Qxy_total_offset+1, zero
001954 9220 28bc                 	sts pulse2_fx_Rxy_target, zero
001956 9220 28bd                 	sts pulse2_fx_Rxy_target+1, zero
001958 9220 28c0                 	sts pulse2_fx_Rxy_total_offset, zero
00195a 9220 28c1                 	sts pulse2_fx_Rxy_total_offset+1, zero
00195c d0f9                      	rcall sound_driver_channel1_increment_offset
00195d ce35                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_volume:
00195e 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
00195f 91a0 2808                 	lds r26, pulse2_param
001961 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001962 2bab                      	or r26, r27 //move new VVVV bits into pulse2_param
001963 93a0 2808                 	sts pulse2_param, r26
001965 6092                      	sbr pulse_channel_flags, 2
001966 d0ef                      	rcall sound_driver_channel1_increment_offset
001967 ce2b                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_delay:
001968 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001969 93b0 2875                 	sts pulse2_pattern_delay_rows, r27
00196b d0ea                      	rcall sound_driver_channel1_increment_offset
00196c c100                      	rjmp sound_driver_channel2
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change:
00196d 9220 2879                 	sts pulse2_volume_macro, zero //reset all macro addresses
00196f 9220 287a                 	sts pulse2_volume_macro+1, zero
001971 9220 287e                 	sts pulse2_arpeggio_macro, zero
001973 9220 287f                 	sts pulse2_arpeggio_macro+1, zero
001975 9220 2886                 	sts pulse2_pitch_macro, zero
001977 9220 2887                 	sts pulse2_pitch_macro+1, zero
001979 9220 288c                 	sts pulse2_hi_pitch_macro, zero
00197b 9220 288d                 	sts pulse2_hi_pitch_macro+1, zero
00197d 9220 2891                 	sts pulse2_duty_macro, zero
00197f 9220 2892                 	sts pulse2_duty_macro+1, zero
001981 9220 2884                 	sts pulse2_total_pitch_offset, zero //reset the pitch offset
001983 9220 2885                 	sts pulse2_total_pitch_offset+1, zero
001985 9220 288b                 	sts pulse2_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001987 9631                      	adiw Z, 1 //point to the byte next to the flag
001988 91b4                      	lpm r27, Z //store the instrument offset into r27
001989 e2ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
00198a e0fd                      	ldi ZH, HIGH(instruments)
00198b 0feb                      	add ZL, r27 //point Z to offsetted instrument
00198c 1df2                      	adc ZH, zero
00198d 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
00198e 1fff                      	rol ZH
00198f 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001990 91b4                      	lpm r27, Z
                                 
001991 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001992 1fbb                      	rol r27
001993 2fea                      	mov ZL, r26
001994 2ffb                      	mov ZH, r27
001995 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001996 9632                      	adiw Z, 2 //point Z to the address of the macro
001997 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel1_instrument_change_macro_loop:
001998 95aa                      	dec r26
001999 f019                      	breq sound_driver_channel1_instrument_change_exit
00199a 95b6                      	lsr r27
00199b f078                      	brcs sound_driver_channel1_instrument_change_load_macro
00199c cffb                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_exit:
00199d e0a3                      	ldi r26, 0x03
00199e e0b2                      	ldi r27, 0x02
00199f 93b0 287b                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
0019a1 93a0 2880                 	sts pulse2_arpeggio_macro_offset, r26
0019a3 93b0 2888                 	sts pulse2_pitch_macro_offset, r27
0019a5 93b0 288e                 	sts pulse2_hi_pitch_macro_offset, r27
0019a7 93b0 2893                 	sts pulse2_duty_macro_offset, r27
0019a9 d0b6                      	rcall sound_driver_channel1_increment_offset_twice
0019aa cde8                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_load_macro:
0019ab 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
0019ac 91d5                      	lpm r29, Z+
                                 
0019ad 30a5                      	cpi r26, 5
0019ae f039                      	breq sound_driver_channel1_instrument_change_load_macro_volume
0019af 30a4                      	cpi r26, 4
0019b0 f079                      	breq sound_driver_channel1_instrument_change_load_macro_arpeggio
0019b1 30a3                      	cpi r26, 3
0019b2 f0d9                      	breq sound_driver_channel1_instrument_change_load_macro_pitch
0019b3 30a2                      	cpi r26, 2
0019b4 f159                      	breq sound_driver_channel1_instrument_change_load_macro_hi_pitch
0019b5 c03c                      	rjmp sound_driver_channel1_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel1_instrument_change_load_macro_volume:
0019b6 93c0 2879                 	sts pulse2_volume_macro, r28
0019b8 93d0 287a                 	sts pulse2_volume_macro+1, r29
0019ba d041                      	rcall sound_driver_channel1_instrument_change_read_header
0019bb 93c0 287d                 	sts pulse2_volume_macro_release, r28
0019bd 93d0 287c                 	sts pulse2_volume_macro_loop, r29
0019bf cfd8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 	
                                 sound_driver_channel1_instrument_change_load_macro_arpeggio:
0019c0 93c0 287e                 	sts pulse2_arpeggio_macro, r28
0019c2 93d0 287f                 	sts pulse2_arpeggio_macro+1, r29
0019c4 9220 28b5                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0019c6 9220 28b6                 	sts pulse2_fx_Qxy_target+1, zero
0019c8 9220 28bc                 	sts pulse2_fx_Rxy_target, zero
0019ca 9220 28bd                 	sts pulse2_fx_Rxy_target+1, zero
0019cc d03a                      	rcall sound_driver_channel1_instrument_change_read_header_arpeggio
0019cd cfca                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_pitch:
0019ce 93c0 2886                 	sts pulse2_pitch_macro, r28
0019d0 93d0 2887                 	sts pulse2_pitch_macro+1, r29
0019d2 9220 28b5                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0019d4 9220 28b6                 	sts pulse2_fx_Qxy_target+1, zero
0019d6 9220 28bc                 	sts pulse2_fx_Rxy_target, zero
0019d8 9220 28bd                 	sts pulse2_fx_Rxy_target+1, zero
0019da d021                      	rcall sound_driver_channel1_instrument_change_read_header
0019db 93c0 288a                 	sts pulse2_pitch_macro_release, r28
0019dd 93d0 2889                 	sts pulse2_pitch_macro_loop, r29
0019df cfb8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_hi_pitch:
0019e0 93c0 288c                 	sts pulse2_hi_pitch_macro, r28
0019e2 93d0 288d                 	sts pulse2_hi_pitch_macro+1, r29
0019e4 9220 28b5                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0019e6 9220 28b6                 	sts pulse2_fx_Qxy_target+1, zero
0019e8 9220 28bc                 	sts pulse2_fx_Rxy_target, zero
0019ea 9220 28bd                 	sts pulse2_fx_Rxy_target+1, zero
0019ec d00f                      	rcall sound_driver_channel1_instrument_change_read_header
0019ed 93c0 2890                 	sts pulse2_hi_pitch_macro_release, r28
0019ef 93d0 288f                 	sts pulse2_hi_pitch_macro_loop, r29
0019f1 cfa6                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_duty:
0019f2 93c0 2891                 	sts pulse2_duty_macro, r28
0019f4 93d0 2892                 	sts pulse2_duty_macro+1, r29
0019f6 d005                      	rcall sound_driver_channel1_instrument_change_read_header
0019f7 93c0 2895                 	sts pulse2_duty_macro_release, r28
0019f9 93d0 2894                 	sts pulse2_duty_macro_loop, r29
0019fb cf9c                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_read_header:
0019fc 93ef                      	push ZL
0019fd 93ff                      	push ZH
0019fe 2fec                      	mov ZL, r28
0019ff 2ffd                      	mov ZH, r29
001a00 0fee                      	lsl ZL
001a01 1fff                      	rol ZH
001a02 91c5                      	lpm r28, Z+
001a03 91d4                      	lpm r29, Z
001a04 91ff                      	pop ZH
001a05 91ef                      	pop ZL
001a06 9508                      	ret
                                 
                                 sound_driver_channel1_instrument_change_read_header_arpeggio:
001a07 93ef                      	push ZL
001a08 93ff                      	push ZH
001a09 2fec                      	mov ZL, r28
001a0a 2ffd                      	mov ZH, r29
001a0b 0fee                      	lsl ZL
001a0c 1fff                      	rol ZH
001a0d 91c5                      	lpm r28, Z+
001a0e 91d5                      	lpm r29, Z+
001a0f 93c0 2882                 	sts pulse2_arpeggio_macro_release, r28
001a11 93d0 2881                 	sts pulse2_arpeggio_macro_loop, r29
001a13 91c4                      	lpm r28, Z
001a14 93c0 2883                 	sts pulse2_arpeggio_macro_mode, r28
001a16 91ff                      	pop ZH
001a17 91ef                      	pop ZL
001a18 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel1_release:
                                 sound_driver_channel1_release_volume:
001a19 91b0 287d                 	lds r27, pulse2_volume_macro_release
001a1b 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001a1c f019                      	breq sound_driver_channel1_release_arpeggio //if the macro has no release flag, check the next macro
001a1d 95b3                      	inc r27
001a1e 93b0 287b                 	sts pulse2_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel1_release_arpeggio:
001a20 91b0 2882                 	lds r27, pulse2_arpeggio_macro_release
001a22 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001a23 f019                      	breq sound_driver_channel1_release_pitch
001a24 95b3                      	inc r27
001a25 93b0 2880                 	sts pulse2_arpeggio_macro_offset, r27
                                 sound_driver_channel1_release_pitch:
001a27 91b0 288a                 	lds r27, pulse2_pitch_macro_release
001a29 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001a2a f019                      	breq sound_driver_channel1_release_hi_pitch
001a2b 95b3                      	inc r27
001a2c 93b0 2888                 	sts pulse2_pitch_macro_offset, r27
                                 sound_driver_channel1_release_hi_pitch:
001a2e 91b0 2890                 	lds r27, pulse2_hi_pitch_macro_release
001a30 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001a31 f019                      	breq sound_driver_channel1_release_duty
001a32 95b3                      	inc r27
001a33 93b0 288e                 	sts pulse2_hi_pitch_macro_offset, r27
                                 sound_driver_channel1_release_duty:
001a35 91b0 2895                 	lds r27, pulse2_duty_macro_release
001a37 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001a38 f019                      	breq sound_driver_channel1_release_exit
001a39 95b3                      	inc r27
001a3a 93b0 2893                 	sts pulse2_duty_macro_offset, r27
                                 sound_driver_channel1_release_exit:
001a3c d019                      	rcall sound_driver_channel1_increment_offset
001a3d cd55                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_next_pattern:
001a3e 91e0 2818                 	lds ZL, song_frames
001a40 91f0 2819                 	lds ZH, song_frames+1
001a42 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001a44 91b0 281b                 	lds r27, song_frame_offset+1
001a46 9612                      	adiw r27:r26, 2 //offset for channel 1
001a47 0fea                      	add ZL, r26
001a48 1ffb                      	adc ZH, r27
                                 
001a49 91a5                      	lpm r26, Z+ //load the address of the next pattern
001a4a 91b4                      	lpm r27, Z
001a4b 0faa                      	lsl r26
001a4c 1fbb                      	rol r27
001a4d 93a0 2873                 	sts pulse2_pattern, r26
001a4f 93b0 2874                 	sts pulse2_pattern+1, r27
                                 
001a51 9220 2877                 	sts pulse2_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001a53 9220 2878                 	sts pulse2_pattern_offset+1, zero
001a55 cd3d                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_increment_offset:
001a56 91e0 2877                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001a58 91f0 2878                 	lds ZH, pulse2_pattern_offset+1
001a5a 9631                      	adiw Z, 1
001a5b 93e0 2877                 	sts pulse2_pattern_offset, ZL
001a5d 93f0 2878                 	sts pulse2_pattern_offset+1, ZH
001a5f 9508                      	ret
                                 
                                 sound_driver_channel1_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001a60 91e0 2877                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001a62 91f0 2878                 	lds ZH, pulse2_pattern_offset+1
001a64 9632                      	adiw Z, 2 //increment the pointer twice
001a65 93e0 2877                 	sts pulse2_pattern_offset, ZL
001a67 93f0 2878                 	sts pulse2_pattern_offset+1, ZH
001a69 9508                      	ret
                                 
                                 sound_driver_channel1_decrement_frame_delay:
001a6a 95ba                      	dec r27
001a6b 93b0 2876                 	sts pulse2_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel2:
001a6d 91a0 28c6                 	lds r26, triangle_pattern_delay_rows
001a6f 91b0 28c7                 	lds r27, triangle_pattern_delay_frames
001a71 9610                      	adiw r27:r26, 0
001a72 f009                      	breq sound_driver_channel2_main //if the pattern delay is 0, proceed with sound driver procedures
001a73 c2bf                      	rjmp sound_driver_channel2_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel2_main:
001a74 91e0 28c4                 	lds ZL, triangle_pattern //current pattern for triangle
001a76 91f0 28c5                 	lds ZH, triangle_pattern+1
001a78 91a0 28c8                 	lds r26, triangle_pattern_offset //current offset in the pattern for triangle
001a7a 91b0 28c9                 	lds r27, triangle_pattern_offset+1
001a7c 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001a7d 1ffb                      	adc ZH, r27
001a7e 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel2_check_if_note: //check if data is a note (0x00 - 0x56)
001a7f 35b7                      	cpi r27, 0x57
001a80 f408                      	brsh sound_driver_channel2_check_if_volume
001a81 c160                      	rjmp sound_driver_channel2_note
                                 sound_driver_channel2_check_if_volume: //check if data is volume (0x57-0x66)
001a82 36b7                      	cpi r27, 0x67
001a83 f408                      	brsh sound_driver_channel2_check_if_delay
001a84 c19e                      	rjmp sound_driver_channel2_volume
                                 sound_driver_channel2_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001a85 3eb3                      	cpi r27, 0xE3
001a86 f408                      	brsh sound_driver_channel2_check_if_instrument
001a87 c1a9                      	rjmp sound_driver_channel2_delay
                                 sound_driver_channel2_check_if_instrument: //check for instrument flag (0xE3)
001a88 f409                      	brne sound_driver_channel2_check_if_release
001a89 c1ac                      	rjmp sound_driver_channel2_instrument_change 
                                 sound_driver_channel2_check_if_release: //check for note release flag (0xE4)
001a8a 3eb4                      	cpi r27, 0xE4
001a8b f409                      	brne sound_driver_channel2_check_if_end
001a8c c255                      	rjmp sound_driver_channel2_release
                                 sound_driver_channel2_check_if_end:
001a8d 3fbf                      	cpi r27, 0xFF
001a8e f409                      	brne sound_driver_channel2_check_if_fx
001a8f c277                      	rjmp sound_driver_channel2_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel2_check_if_fx: //fx flags (0xE5 - 0xFE)
001a90 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001a91 91a4                      	lpm r26, Z //load the fx data into r26
001a92 d296                      	rcall sound_driver_channel2_increment_offset_twice
                                 
001a93 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001a94 e6e2                      	ldi ZL, LOW(channel2_fx << 1) //load in note table
001a95 e5fc                      	ldi ZH, HIGH(channel2_fx << 1)
001a96 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001a97 0feb                      	add ZL, r27 //add offset
001a98 1df2                      	adc ZH, zero
001a99 91c5                      	lpm r28, Z+ //load address bytes
001a9a 91d4                      	lpm r29, Z
001a9b 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001a9c 2ffd                      	mov ZH, r29
001a9d 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel2_fx_0xy:
001a9e 93a0 28e7                 	sts triangle_fx_0xy_sequence, r26
001aa0 9220 28e8                 	sts triangle_fx_0xy_sequence+1, zero
001aa2 cfd1                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel2_fx_1xx:
001aa3 9220 28ed                 	sts triangle_fx_2xx, zero //turn off any 2xx pitch slide down
001aa5 9220 28ee                 	sts triangle_fx_2xx+1, zero
001aa7 9220 28e7                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001aa9 9220 28e8                 	sts triangle_fx_0xy_sequence+1, zero
001aab 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001aac 937f                      	push r23
001aad 2f6a                      	mov r22, r26 //store the rate into r22
001aae eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001aaf 9f67                      	mul r22, r23
001ab0 917f                      	pop r23
001ab1 916f                      	pop r22
                                 
001ab2 9416                      	lsr r1 //shift out the fractional bits
001ab3 9407                      	ror r0
001ab4 9416                      	lsr r1
001ab5 9407                      	ror r0
001ab6 9416                      	lsr r1
001ab7 9407                      	ror r0
001ab8 9416                      	lsr r1
001ab9 9407                      	ror r0
001aba 9200 28e9                 	sts triangle_fx_1xx, r0
001abc 9210 28ea                 	sts triangle_fx_1xx+1, r1
001abe cfb5                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel2_fx_2xx:
001abf 9220 28e9                 	sts triangle_fx_1xx, zero //turn off any 1xx pitch slide down
001ac1 9220 28ea                 	sts triangle_fx_1xx+1, zero
001ac3 9220 28e7                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001ac5 9220 28e8                 	sts triangle_fx_0xy_sequence+1, zero
001ac7 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001ac8 937f                      	push r23
001ac9 2f6a                      	mov r22, r26 //store the rate into r22
001aca eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001acb 9f67                      	mul r22, r23
001acc 917f                      	pop r23
001acd 916f                      	pop r22
                                 
001ace 9416                      	lsr r1 //shift out the fractional bits
001acf 9407                      	ror r0
001ad0 9416                      	lsr r1
001ad1 9407                      	ror r0
001ad2 9416                      	lsr r1
001ad3 9407                      	ror r0
001ad4 9416                      	lsr r1
001ad5 9407                      	ror r0
001ad6 9200 28ed                 	sts triangle_fx_2xx, r0
001ad8 9210 28ee                 	sts triangle_fx_2xx+1, r1
001ada cf99                      	rjmp sound_driver_channel2_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel2_fx_3xx:
001adb 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001adc 937f                      	push r23
001add 2f6a                      	mov r22, r26 //store the rate into r22
001ade eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001adf 9f67                      	mul r22, r23
001ae0 917f                      	pop r23
001ae1 916f                      	pop r22
                                 
001ae2 9416                      	lsr r1 //shift out the fractional bits
001ae3 9407                      	ror r0
001ae4 9416                      	lsr r1
001ae5 9407                      	ror r0
001ae6 9416                      	lsr r1
001ae7 9407                      	ror r0
001ae8 9416                      	lsr r1
001ae9 9407                      	ror r0
001aea 9200 28f5                 	sts triangle_fx_3xx_speed, r0
001aec 9210 28f6                 	sts triangle_fx_3xx_speed+1, r1
                                 
001aee 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001aef c001                      	rjmp sound_driver_channel2_fx_3xx_enabled
001af0 cf83                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_3xx_enabled:
001af1 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001af3 91b0 0aad                 	lds r27, TCB2_CCMPH
001af5 93a0 28f1                 	sts triangle_fx_3xx_start, r26
001af7 93b0 28f2                 	sts triangle_fx_3xx_start+1, r27
                                 
001af9 9220 28f7                 	sts triangle_fx_3xx_total_offset, zero
001afb 9220 28f8                 	sts triangle_fx_3xx_total_offset+1, zero
001afd cf76                      	rjmp sound_driver_channel2_main
                                 
                                 //VIBRATO
                                 sound_driver_channel2_fx_4xy:
001afe 2fba                      	mov r27, r26
001aff 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001b00 95a2                      	swap r26
001b01 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001b02 93a0 28f9                 	sts triangle_fx_4xy_speed, r26
001b04 93b0 28fa                 	sts triangle_fx_4xy_depth, r27
001b06 9220 28fb                 	sts triangle_fx_4xy_phase, zero //reset the phase to 0
001b08 cf6b                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_7xy: //tremelo
001b09 cf6a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Axy: //volume slide
001b0a cf69                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel2_fx_Bxx:
001b0b 93a0 281f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001b0d cf66                      	rjmp sound_driver_channel2_main
                                 
                                 //HALT
                                 sound_driver_channel2_fx_Cxx:
001b0e 93b0 2820                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001b10 cf63                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel2_fx_Dxx:
001b11 93b0 2821                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001b13 cf60                      	rjmp sound_driver_channel2_main
                                 
                                 //VOLUME
                                 sound_driver_channel2_fx_Exx:
001b14 15a2                      	cp r26, zero
001b15 f021                      	breq sound_driver_channel2_fx_Exx_disable
                                 sound_driver_channel2_fx_Exx_enable:
001b16 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001b17 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001b19 cf5a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Exx_disable:
001b1a 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
001b1c 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
001b1e 9220 0aad                 	sts TCB2_CCMPH, zero
001b20 cf53                      	rjmp sound_driver_channel2_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel2_fx_Fxx:
001b21 93a0 281e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001b23 cf50                      	rjmp sound_driver_channel2_main
                                 
                                 //DELAY
                                 sound_driver_channel2_fx_Gxx:
001b24 15a2                      	cp r26, zero
001b25 f051                      	breq sound_driver_channel2_fx_Gxx_invalid
001b26 91b0 281e                 	lds r27, song_speed
001b28 17ab                      	cp r26, r27
001b29 f430                      	brsh sound_driver_channel2_fx_Gxx_invalid
001b2a 93a0 28fc                 	sts triangle_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001b2c e0b1                      	ldi r27, 0x01
001b2d 93b0 28c6                 	sts triangle_pattern_delay_rows, r27
001b2f c206                      	rjmp sound_driver_channel3
                                 sound_driver_channel2_fx_Gxx_invalid:
001b30 cf43                      	rjmp sound_driver_channel2_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Hxy: //hardware sweep up
001b31 cf42                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixy: //hardware sweep down
001b32 cf41                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Hxx: //FDS modulation depth
001b33 cf40                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixx: //FDS modulation speed
001b34 cf3f                      	rjmp sound_driver_channel2_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel2_fx_Pxx:
001b35 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001b36 937f                      	push r23
001b37 2f6a                      	mov r22, r26
001b38 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001b39 0367                      	mulsu r22, r23
001b3a 917f                      	pop r23
001b3b 916f                      	pop r22
001b3c 9416                      	lsr r1 //shift out the fractional bits
001b3d 9407                      	ror r0
001b3e 9416                      	lsr r1
001b3f 9407                      	ror r0
001b40 9416                      	lsr r1
001b41 9407                      	ror r0
001b42 9416                      	lsr r1
001b43 9407                      	ror r0
001b44 fe13                      	sbrs r1, 3 //check if result was a negative number
001b45 c002                      	rjmp sound_driver_channel2_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel2_fx_Pxx_negative:
001b46 efb0                      	ldi r27, 0xF0
001b47 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel2_fx_Pxx_store:
001b48 9200 28fe                 	sts triangle_fx_Pxx_total, r0
001b4a 9210 28ff                 	sts triangle_fx_Pxx_total+1, r1
001b4c cf27                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel2_fx_Qxy:
                                 sound_driver_channel2_fx_Qxy_check_arpeggio_macro:
001b4d 91e0 28cf                 	lds ZL, triangle_arpeggio_macro
001b4f 91f0 28d0                 	lds ZH, triangle_arpeggio_macro+1
001b51 9630                      	adiw Z, 0
001b52 f009                      	breq sound_driver_channel2_fx_Qxy_check_pitch_macro
001b53 cf20                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_pitch_macro:
001b54 91e0 28d7                 	lds ZL, triangle_pitch_macro
001b56 91f0 28d8                 	lds ZH, triangle_pitch_macro+1
001b58 9630                      	adiw Z, 0
001b59 f009                      	breq sound_driver_channel2_fx_Qxy_check_hi_pitch_macro
001b5a cf19                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_hi_pitch_macro:
001b5b 91e0 28dd                 	lds ZL, triangle_hi_pitch_macro
001b5d 91f0 28de                 	lds ZH, triangle_hi_pitch_macro+1
001b5f 9630                      	adiw Z, 0
001b60 f009                      	breq sound_driver_channel2_fx_Qxy_process
001b61 cf12                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_process:
001b62 2fba                      	mov r27, r26 //copy fx parameters into r27
001b63 70bf                      	andi r27, 0x0F //mask note index offset
001b64 91c0 2900                 	lds r28, triangle_fx_Qxy_target_note //load current note index
001b66 0fbc                      	add r27, r28
001b67 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001b68 f008                      	brlo sound_driver_channel2_fx_Qxy_process_continue
001b69 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel2_fx_Qxy_process_continue:
001b6a 93b0 2900                 	sts triangle_fx_Qxy_target_note, r27
001b6c e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001b6d e0f0                      	ldi ZH, HIGH(note_table << 1)
001b6e 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001b6f 0feb                      	add ZL, r27 //add offset
001b70 1df2                      	adc ZH, zero
001b71 91c5                      	lpm r28, Z+ //load bytes
001b72 91d4                      	lpm r29, Z
001b73 93c0 2901                 	sts triangle_fx_Qxy_target, r28 //load the LOW bits for the target period
001b75 93d0 2902                 	sts triangle_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel2_fx_Qxy_process_speed:
001b77 95a2                      	swap r26
001b78 70af                      	andi r26, 0x0F //mask effect speed
001b79 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001b7a 95a3                      	inc r26 //increment the speed by 1
                                 
001b7b 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001b7c 937f                      	push r23
001b7d 2f6a                      	mov r22, r26 //store the speed data into r27
001b7e eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001b7f 9f67                      	mul r22, r23
001b80 917f                      	pop r23
001b81 916f                      	pop r22
                                 
001b82 9416                      	lsr r1 //shift out the fractional bits
001b83 9407                      	ror r0
001b84 9416                      	lsr r1
001b85 9407                      	ror r0
001b86 9416                      	lsr r1
001b87 9407                      	ror r0
001b88 9416                      	lsr r1
001b89 9407                      	ror r0
                                 
001b8a 9200 2903                 	sts triangle_fx_Qxy_speed, r0 //store the effect speed
001b8c 9210 2904                 	sts triangle_fx_Qxy_speed+1, r1
001b8e cee5                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel2_fx_Rxy:
                                 sound_driver_channel2_fx_Rxy_check_arpeggio_macro:
001b8f 91e0 28cf                 	lds ZL, triangle_arpeggio_macro
001b91 91f0 28d0                 	lds ZH, triangle_arpeggio_macro+1
001b93 9630                      	adiw Z, 0
001b94 f009                      	breq sound_driver_channel2_fx_Rxy_check_pitch_macro
001b95 cede                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_pitch_macro:
001b96 91e0 28d7                 	lds ZL, triangle_pitch_macro
001b98 91f0 28d8                 	lds ZH, triangle_pitch_macro+1
001b9a 9630                      	adiw Z, 0
001b9b f009                      	breq sound_driver_channel2_fx_Rxy_check_hi_pitch_macro
001b9c ced7                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_hi_pitch_macro:
001b9d 91e0 28dd                 	lds ZL, triangle_hi_pitch_macro
001b9f 91f0 28de                 	lds ZH, triangle_hi_pitch_macro+1
001ba1 9630                      	adiw Z, 0
001ba2 f009                      	breq sound_driver_channel2_fx_Rxy_process
001ba3 ced0                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_process:
001ba4 2fba                      	mov r27, r26 //copy fx parameters into r27
001ba5 70bf                      	andi r27, 0x0F //mask note index offset
001ba6 91c0 2907                 	lds r28, triangle_fx_Rxy_target_note //load current note index
001ba8 1bcb                      	sub r28, r27
001ba9 f408                      	brcc sound_driver_channel2_fx_Rxy_process_continue
001baa e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel2_fx_Rxy_process_continue:
001bab 93c0 2907                 	sts triangle_fx_Rxy_target_note, r28
001bad e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001bae e0f0                      	ldi ZH, HIGH(note_table << 1)
001baf 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001bb0 0fec                      	add ZL, r28 //add offset
001bb1 1df2                      	adc ZH, zero
001bb2 91c5                      	lpm r28, Z+ //load bytes
001bb3 91d4                      	lpm r29, Z
001bb4 93c0 2908                 	sts triangle_fx_Rxy_target, r28 //load the LOW bits for the target period
001bb6 93d0 2909                 	sts triangle_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel2_fx_Rxy_process_speed:
001bb8 95a2                      	swap r26
001bb9 70af                      	andi r26, 0x0F //mask effect speed
001bba 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001bbb 95a3                      	inc r26 //increment the speed by 1
                                 
001bbc 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001bbd 937f                      	push r23
001bbe 2f6a                      	mov r22, r26 //store the speed data into r27
001bbf eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001bc0 9f67                      	mul r22, r23
001bc1 917f                      	pop r23
001bc2 916f                      	pop r22
                                 
001bc3 9416                      	lsr r1 //shift out the fractional bits
001bc4 9407                      	ror r0
001bc5 9416                      	lsr r1
001bc6 9407                      	ror r0
001bc7 9416                      	lsr r1
001bc8 9407                      	ror r0
001bc9 9416                      	lsr r1
001bca 9407                      	ror r0
                                 
001bcb 9200 290a                 	sts triangle_fx_Rxy_speed, r0 //store the effect speed
001bcd 9210 290b                 	sts triangle_fx_Rxy_speed+1, r1
001bcf cea4                      	rjmp sound_driver_channel2_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel2_fx_Sxx:
001bd0 15a2                      	cp r26, zero
001bd1 f051                      	breq sound_driver_channel2_fx_Sxx_invalid
001bd2 91b0 281e                 	lds r27, song_speed
001bd4 17ab                      	cp r26, r27
001bd5 f430                      	brsh sound_driver_channel2_fx_Sxx_invalid
001bd6 93a0 290e                 	sts triangle_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001bd8 e0b1                      	ldi r27, 0x01
001bd9 93b0 28c6                 	sts triangle_pattern_delay_rows, r27
001bdb c15a                      	rjmp sound_driver_channel3
                                 sound_driver_channel2_fx_Sxx_invalid:
001bdc ce97                      	rjmp sound_driver_channel2_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Vxx: //duty
001bdd ce96                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Wxx: //DPCM sample speed
001bde ce95                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Xxx: //DPCM sample retrigger
001bdf ce94                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Yxx: //DPCM sample offset
001be0 ce93                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Zxx: //DPCM sample delta counter
001be1 ce92                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 sound_driver_channel2_note:
001be2 93b0 2812                 	sts triangle_note, r27 //store the note index
001be4 93b0 2900                 	sts triangle_fx_Qxy_target_note, r27
001be6 93b0 2907                 	sts triangle_fx_Rxy_target_note, r27
001be8 e0a3                      	ldi r26, 0x03
001be9 e0b2                      	ldi r27, 0x02
001bea 93b0 28cc                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
001bec 93a0 28d1                 	sts triangle_arpeggio_macro_offset, r26
001bee 93b0 28d9                 	sts triangle_pitch_macro_offset, r27
001bf0 93b0 28df                 	sts triangle_hi_pitch_macro_offset, r27
001bf2 93b0 28e4                 	sts triangle_duty_macro_offset, r27
001bf4 9220 28d5                 	sts triangle_total_pitch_offset, zero //reset the pitch and hi pitch offset
001bf6 9220 28d6                 	sts triangle_total_pitch_offset+1, zero
001bf8 9220 28dc                 	sts triangle_total_hi_pitch_offset, zero
001bfa 9220 28eb                 	sts triangle_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001bfc 9220 28ec                 	sts triangle_fx_1xx_total+1, zero
001bfe 9220 28ef                 	sts triangle_fx_2xx_total, zero
001c00 9220 28f0                 	sts triangle_fx_2xx_total+1, zero
001c02 9220 28f7                 	sts triangle_fx_3xx_total_offset, zero //reset 3xx offset
001c04 9220 28f8                 	sts triangle_fx_3xx_total_offset+1, zero
001c06 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001c08 91b0 0aad                 	lds r27, TCB2_CCMPH
001c0a 93a0 28f1                 	sts triangle_fx_3xx_start, r26
001c0c 93b0 28f2                 	sts triangle_fx_3xx_start+1, r27
001c0e 9220 2901                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001c10 9220 2902                 	sts triangle_fx_Qxy_target+1, zero
001c12 9220 2905                 	sts triangle_fx_Qxy_total_offset, zero
001c14 9220 2906                 	sts triangle_fx_Qxy_total_offset+1, zero
001c16 9220 2908                 	sts triangle_fx_Rxy_target, zero
001c18 9220 2909                 	sts triangle_fx_Rxy_target+1, zero
001c1a 9220 290c                 	sts triangle_fx_Rxy_total_offset, zero
001c1c 9220 290d                 	sts triangle_fx_Rxy_total_offset+1, zero
001c1e e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001c1f 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001c21 d0fd                      	rcall sound_driver_channel2_increment_offset
001c22 ce51                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_volume:
001c23 d0fb                      	rcall sound_driver_channel2_increment_offset
001c24 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001c25 f021                      	breq sound_driver_channel2_volume_disable
                                 sound_driver_channel2_volume_enable:
001c26 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001c27 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001c29 ce4a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_volume_disable:
001c2a 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
001c2c 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
001c2e 9220 0aad                 	sts TCB2_CCMPH, zero
001c30 ce43                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_delay:
001c31 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001c32 93b0 28c6                 	sts triangle_pattern_delay_rows, r27
001c34 d0ea                      	rcall sound_driver_channel2_increment_offset
001c35 c100                      	rjmp sound_driver_channel3
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change:
001c36 9220 28ca                 	sts triangle_volume_macro, zero //reset all macro addresses
001c38 9220 28cb                 	sts triangle_volume_macro+1, zero
001c3a 9220 28cf                 	sts triangle_arpeggio_macro, zero
001c3c 9220 28d0                 	sts triangle_arpeggio_macro+1, zero
001c3e 9220 28d7                 	sts triangle_pitch_macro, zero
001c40 9220 28d8                 	sts triangle_pitch_macro+1, zero
001c42 9220 28dd                 	sts triangle_hi_pitch_macro, zero
001c44 9220 28de                 	sts triangle_hi_pitch_macro+1, zero
001c46 9220 28e2                 	sts triangle_duty_macro, zero
001c48 9220 28e3                 	sts triangle_duty_macro+1, zero
001c4a 9220 28d5                 	sts triangle_total_pitch_offset, zero //reset the pitch offset
001c4c 9220 28d6                 	sts triangle_total_pitch_offset+1, zero
001c4e 9220 28dc                 	sts triangle_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001c50 9631                      	adiw Z, 1 //point to the byte next to the flag
001c51 91b4                      	lpm r27, Z //store the instrument offset into r27
001c52 e2ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
001c53 e0fd                      	ldi ZH, HIGH(instruments)
001c54 0feb                      	add ZL, r27 //point Z to offsetted instrument
001c55 1df2                      	adc ZH, zero
001c56 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001c57 1fff                      	rol ZH
001c58 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001c59 91b4                      	lpm r27, Z
                                 
001c5a 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001c5b 1fbb                      	rol r27
001c5c 2fea                      	mov ZL, r26
001c5d 2ffb                      	mov ZH, r27
001c5e 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001c5f 9632                      	adiw Z, 2 //point Z to the address of the macro
001c60 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel2_instrument_change_macro_loop:
001c61 95aa                      	dec r26
001c62 f019                      	breq sound_driver_channel2_instrument_change_exit
001c63 95b6                      	lsr r27
001c64 f078                      	brcs sound_driver_channel2_instrument_change_load_macro
001c65 cffb                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_exit:
001c66 e0a3                      	ldi r26, 0x03
001c67 e0b2                      	ldi r27, 0x02
001c68 93b0 28cc                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
001c6a 93a0 28d1                 	sts triangle_arpeggio_macro_offset, r26
001c6c 93b0 28d9                 	sts triangle_pitch_macro_offset, r27
001c6e 93b0 28df                 	sts triangle_hi_pitch_macro_offset, r27
001c70 93b0 28e4                 	sts triangle_duty_macro_offset, r27
001c72 d0b6                      	rcall sound_driver_channel2_increment_offset_twice
001c73 ce00                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_load_macro:
001c74 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001c75 91d5                      	lpm r29, Z+
                                 
001c76 30a5                      	cpi r26, 5
001c77 f039                      	breq sound_driver_channel2_instrument_change_load_macro_volume
001c78 30a4                      	cpi r26, 4
001c79 f079                      	breq sound_driver_channel2_instrument_change_load_macro_arpeggio
001c7a 30a3                      	cpi r26, 3
001c7b f0d9                      	breq sound_driver_channel2_instrument_change_load_macro_pitch
001c7c 30a2                      	cpi r26, 2
001c7d f159                      	breq sound_driver_channel2_instrument_change_load_macro_hi_pitch
001c7e c03c                      	rjmp sound_driver_channel2_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel2_instrument_change_load_macro_volume:
001c7f 93c0 28ca                 	sts triangle_volume_macro, r28
001c81 93d0 28cb                 	sts triangle_volume_macro+1, r29
001c83 d041                      	rcall sound_driver_channel2_instrument_change_read_header
001c84 93c0 28ce                 	sts triangle_volume_macro_release, r28
001c86 93d0 28cd                 	sts triangle_volume_macro_loop, r29
001c88 cfd8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 	
                                 sound_driver_channel2_instrument_change_load_macro_arpeggio:
001c89 93c0 28cf                 	sts triangle_arpeggio_macro, r28
001c8b 93d0 28d0                 	sts triangle_arpeggio_macro+1, r29
001c8d 9220 2901                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001c8f 9220 2902                 	sts triangle_fx_Qxy_target+1, zero
001c91 9220 2908                 	sts triangle_fx_Rxy_target, zero
001c93 9220 2909                 	sts triangle_fx_Rxy_target+1, zero
001c95 d03a                      	rcall sound_driver_channel2_instrument_change_read_header_arpeggio
001c96 cfca                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_pitch:
001c97 93c0 28d7                 	sts triangle_pitch_macro, r28
001c99 93d0 28d8                 	sts triangle_pitch_macro+1, r29
001c9b 9220 2901                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001c9d 9220 2902                 	sts triangle_fx_Qxy_target+1, zero
001c9f 9220 2908                 	sts triangle_fx_Rxy_target, zero
001ca1 9220 2909                 	sts triangle_fx_Rxy_target+1, zero
001ca3 d021                      	rcall sound_driver_channel2_instrument_change_read_header
001ca4 93c0 28db                 	sts triangle_pitch_macro_release, r28
001ca6 93d0 28da                 	sts triangle_pitch_macro_loop, r29
001ca8 cfb8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_hi_pitch:
001ca9 93c0 28dd                 	sts triangle_hi_pitch_macro, r28
001cab 93d0 28de                 	sts triangle_hi_pitch_macro+1, r29
001cad 9220 2901                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001caf 9220 2902                 	sts triangle_fx_Qxy_target+1, zero
001cb1 9220 2908                 	sts triangle_fx_Rxy_target, zero
001cb3 9220 2909                 	sts triangle_fx_Rxy_target+1, zero
001cb5 d00f                      	rcall sound_driver_channel2_instrument_change_read_header
001cb6 93c0 28e1                 	sts triangle_hi_pitch_macro_release, r28
001cb8 93d0 28e0                 	sts triangle_hi_pitch_macro_loop, r29
001cba cfa6                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_duty:
001cbb 93c0 28e2                 	sts triangle_duty_macro, r28
001cbd 93d0 28e3                 	sts triangle_duty_macro+1, r29
001cbf d005                      	rcall sound_driver_channel2_instrument_change_read_header
001cc0 93c0 28e6                 	sts triangle_duty_macro_release, r28
001cc2 93d0 28e5                 	sts triangle_duty_macro_loop, r29
001cc4 cf9c                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_read_header:
001cc5 93ef                      	push ZL
001cc6 93ff                      	push ZH
001cc7 2fec                      	mov ZL, r28
001cc8 2ffd                      	mov ZH, r29
001cc9 0fee                      	lsl ZL
001cca 1fff                      	rol ZH
001ccb 91c5                      	lpm r28, Z+
001ccc 91d4                      	lpm r29, Z
001ccd 91ff                      	pop ZH
001cce 91ef                      	pop ZL
001ccf 9508                      	ret
                                 
                                 sound_driver_channel2_instrument_change_read_header_arpeggio:
001cd0 93ef                      	push ZL
001cd1 93ff                      	push ZH
001cd2 2fec                      	mov ZL, r28
001cd3 2ffd                      	mov ZH, r29
001cd4 0fee                      	lsl ZL
001cd5 1fff                      	rol ZH
001cd6 91c5                      	lpm r28, Z+
001cd7 91d5                      	lpm r29, Z+
001cd8 93c0 28d3                 	sts triangle_arpeggio_macro_release, r28
001cda 93d0 28d2                 	sts triangle_arpeggio_macro_loop, r29
001cdc 91c4                      	lpm r28, Z
001cdd 93c0 28d4                 	sts triangle_arpeggio_macro_mode, r28
001cdf 91ff                      	pop ZH
001ce0 91ef                      	pop ZL
001ce1 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel2_release:
                                 sound_driver_channel2_release_volume:
001ce2 91b0 28ce                 	lds r27, triangle_volume_macro_release
001ce4 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001ce5 f019                      	breq sound_driver_channel2_release_arpeggio //if the macro has no release flag, check the next macro
001ce6 95b3                      	inc r27
001ce7 93b0 28cc                 	sts triangle_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel2_release_arpeggio:
001ce9 91b0 28d3                 	lds r27, triangle_arpeggio_macro_release
001ceb 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001cec f019                      	breq sound_driver_channel2_release_pitch
001ced 95b3                      	inc r27
001cee 93b0 28d1                 	sts triangle_arpeggio_macro_offset, r27
                                 sound_driver_channel2_release_pitch:
001cf0 91b0 28db                 	lds r27, triangle_pitch_macro_release
001cf2 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001cf3 f019                      	breq sound_driver_channel2_release_hi_pitch
001cf4 95b3                      	inc r27
001cf5 93b0 28d9                 	sts triangle_pitch_macro_offset, r27
                                 sound_driver_channel2_release_hi_pitch:
001cf7 91b0 28e1                 	lds r27, triangle_hi_pitch_macro_release
001cf9 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001cfa f019                      	breq sound_driver_channel2_release_duty
001cfb 95b3                      	inc r27
001cfc 93b0 28df                 	sts triangle_hi_pitch_macro_offset, r27
                                 sound_driver_channel2_release_duty:
001cfe 91b0 28e6                 	lds r27, triangle_duty_macro_release
001d00 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001d01 f019                      	breq sound_driver_channel2_release_exit
001d02 95b3                      	inc r27
001d03 93b0 28e4                 	sts triangle_duty_macro_offset, r27
                                 sound_driver_channel2_release_exit:
001d05 d019                      	rcall sound_driver_channel2_increment_offset
001d06 cd6d                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_next_pattern:
001d07 91e0 2818                 	lds ZL, song_frames
001d09 91f0 2819                 	lds ZH, song_frames+1
001d0b 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001d0d 91b0 281b                 	lds r27, song_frame_offset+1
001d0f 9614                      	adiw r27:r26, 4 //offset for channel 2
001d10 0fea                      	add ZL, r26
001d11 1ffb                      	adc ZH, r27
                                 
001d12 91a5                      	lpm r26, Z+ //load the address of the next pattern
001d13 91b4                      	lpm r27, Z
001d14 0faa                      	lsl r26
001d15 1fbb                      	rol r27
001d16 93a0 28c4                 	sts triangle_pattern, r26
001d18 93b0 28c5                 	sts triangle_pattern+1, r27
                                 
001d1a 9220 28c8                 	sts triangle_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001d1c 9220 28c9                 	sts triangle_pattern_offset+1, zero
001d1e cd55                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_increment_offset:
001d1f 91e0 28c8                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
001d21 91f0 28c9                 	lds ZH, triangle_pattern_offset+1
001d23 9631                      	adiw Z, 1
001d24 93e0 28c8                 	sts triangle_pattern_offset, ZL
001d26 93f0 28c9                 	sts triangle_pattern_offset+1, ZH
001d28 9508                      	ret
                                 
                                 sound_driver_channel2_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001d29 91e0 28c8                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
001d2b 91f0 28c9                 	lds ZH, triangle_pattern_offset+1
001d2d 9632                      	adiw Z, 2 //increment the pointer twice
001d2e 93e0 28c8                 	sts triangle_pattern_offset, ZL
001d30 93f0 28c9                 	sts triangle_pattern_offset+1, ZH
001d32 9508                      	ret
                                 
                                 sound_driver_channel2_decrement_frame_delay:
001d33 95ba                      	dec r27
001d34 93b0 28c7                 	sts triangle_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel3:
001d36 91a0 2912                 	lds r26, noise_pattern_delay_rows
001d38 91b0 2913                 	lds r27, noise_pattern_delay_frames
001d3a 9610                      	adiw r27:r26, 0
001d3b f009                      	breq sound_driver_channel3_main //if the pattern delay is 0, proceed with sound driver procedures
001d3c c2cd                      	rjmp sound_driver_channel3_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel3_main:
001d3d 91e0 2910                 	lds ZL, noise_pattern //current pattern for noise
001d3f 91f0 2911                 	lds ZH, noise_pattern+1
001d41 91a0 2914                 	lds r26, noise_pattern_offset //current offset in the pattern for noise
001d43 91b0 2915                 	lds r27, noise_pattern_offset+1
001d45 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001d46 1ffb                      	adc ZH, r27
001d47 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel3_check_if_note: //check if data is a note (0x00 - 0x56)
001d48 35b7                      	cpi r27, 0x57
001d49 f408                      	brsh sound_driver_channel3_check_if_volume
001d4a c172                      	rjmp sound_driver_channel3_note
                                 sound_driver_channel3_check_if_volume: //check if data is volume (0x57-0x66)
001d4b 36b7                      	cpi r27, 0x67
001d4c f408                      	brsh sound_driver_channel3_check_if_delay
001d4d c1ad                      	rjmp sound_driver_channel3_volume
                                 sound_driver_channel3_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001d4e 3eb3                      	cpi r27, 0xE3
001d4f f408                      	brsh sound_driver_channel3_check_if_instrument
001d50 c1b3                      	rjmp sound_driver_channel3_delay
                                 sound_driver_channel3_check_if_instrument: //check for instrument flag (0xE3)
001d51 f409                      	brne sound_driver_channel3_check_if_release
001d52 c1b6                      	rjmp sound_driver_channel3_instrument_change 
                                 sound_driver_channel3_check_if_release: //check for note release flag (0xE4)
001d53 3eb4                      	cpi r27, 0xE4
001d54 f409                      	brne sound_driver_channel3_check_if_end
001d55 c25f                      	rjmp sound_driver_channel3_release
                                 sound_driver_channel3_check_if_end:
001d56 3fbf                      	cpi r27, 0xFF
001d57 f409                      	brne sound_driver_channel3_check_if_fx
001d58 c281                      	rjmp sound_driver_channel3_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel3_check_if_fx: //fx flags (0xE5 - 0xFE)
001d59 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001d5a 91a4                      	lpm r26, Z //load the fx data into r26
001d5b d2a4                      	rcall sound_driver_channel3_increment_offset_twice
                                 
001d5c 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001d5d e9e6                      	ldi ZL, LOW(channel3_fx << 1) //load in note table
001d5e e5fc                      	ldi ZH, HIGH(channel3_fx << 1)
001d5f 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001d60 0feb                      	add ZL, r27 //add offset
001d61 1df2                      	adc ZH, zero
001d62 91c5                      	lpm r28, Z+ //load address bytes
001d63 91d4                      	lpm r29, Z
001d64 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001d65 2ffd                      	mov ZH, r29
001d66 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel3_fx_0xy:
001d67 93a0 2933                 	sts noise_fx_0xy_sequence, r26
001d69 9220 2934                 	sts noise_fx_0xy_sequence+1, zero
001d6b cfd1                      	rjmp sound_driver_channel3_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel3_fx_1xx:
001d6c 9220 2939                 	sts noise_fx_2xx, zero //turn off any 2xx pitch slide down
001d6e 9220 293a                 	sts noise_fx_2xx+1, zero
001d70 9220 2933                 	sts noise_fx_0xy_sequence, zero //disable any 0xy effect
001d72 9220 2934                 	sts noise_fx_0xy_sequence+1, zero
001d74 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001d75 937f                      	push r23
001d76 2f6a                      	mov r22, r26 //store the rate into r22
001d77 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001d78 9f67                      	mul r22, r23
001d79 917f                      	pop r23
001d7a 916f                      	pop r22
                                 
001d7b 9416                      	lsr r1 //shift out the fractional bits
001d7c 9407                      	ror r0
001d7d 9416                      	lsr r1
001d7e 9407                      	ror r0
001d7f 9416                      	lsr r1
001d80 9407                      	ror r0
001d81 9416                      	lsr r1
001d82 9407                      	ror r0
001d83 9200 2935                 	sts noise_fx_1xx, r0
001d85 9210 2936                 	sts noise_fx_1xx+1, r1
001d87 cfb5                      	rjmp sound_driver_channel3_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel3_fx_2xx:
001d88 9220 2935                 	sts noise_fx_1xx, zero //turn off any 1xx pitch slide down
001d8a 9220 2936                 	sts noise_fx_1xx+1, zero
001d8c 9220 2933                 	sts noise_fx_0xy_sequence, zero //disable any 0xy effect
001d8e 9220 2934                 	sts noise_fx_0xy_sequence+1, zero
001d90 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001d91 937f                      	push r23
001d92 2f6a                      	mov r22, r26 //store the rate into r22
001d93 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001d94 9f67                      	mul r22, r23
001d95 917f                      	pop r23
001d96 916f                      	pop r22
                                 
001d97 9416                      	lsr r1 //shift out the fractional bits
001d98 9407                      	ror r0
001d99 9416                      	lsr r1
001d9a 9407                      	ror r0
001d9b 9416                      	lsr r1
001d9c 9407                      	ror r0
001d9d 9416                      	lsr r1
001d9e 9407                      	ror r0
001d9f 9200 2939                 	sts noise_fx_2xx, r0
001da1 9210 293a                 	sts noise_fx_2xx+1, r1
001da3 cf99                      	rjmp sound_driver_channel3_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel3_fx_3xx:
001da4 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001da5 937f                      	push r23
001da6 2f6a                      	mov r22, r26 //store the rate into r22
001da7 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001da8 9f67                      	mul r22, r23
001da9 917f                      	pop r23
001daa 916f                      	pop r22
                                 
001dab 9416                      	lsr r1 //shift out the fractional bits
001dac 9407                      	ror r0
001dad 9416                      	lsr r1
001dae 9407                      	ror r0
001daf 9416                      	lsr r1
001db0 9407                      	ror r0
001db1 9416                      	lsr r1
001db2 9407                      	ror r0
001db3 9200 2941                 	sts noise_fx_3xx_speed, r0
001db5 9210 2942                 	sts noise_fx_3xx_speed+1, r1
                                 
001db7 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001db8 c001                      	rjmp sound_driver_channel3_fx_3xx_enabled
001db9 cf83                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_3xx_enabled:
001dba 91a0 0abc                 	lds r26, TCB3_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001dbc 91b0 0abd                 	lds r27, TCB3_CCMPH
001dbe 93a0 293d                 	sts noise_fx_3xx_start, r26
001dc0 93b0 293e                 	sts noise_fx_3xx_start+1, r27
                                 
001dc2 9220 2943                 	sts noise_fx_3xx_total_offset, zero
001dc4 9220 2944                 	sts noise_fx_3xx_total_offset+1, zero
001dc6 cf76                      	rjmp sound_driver_channel3_main
                                 
                                 //VIBRATO
                                 sound_driver_channel3_fx_4xy:
001dc7 2fba                      	mov r27, r26
001dc8 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001dc9 95a2                      	swap r26
001dca 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001dcb 93a0 2945                 	sts noise_fx_4xy_speed, r26
001dcd 93b0 2946                 	sts noise_fx_4xy_depth, r27
001dcf 9220 2947                 	sts noise_fx_4xy_phase, zero //reset the phase to 0
001dd1 cf6b                      	rjmp sound_driver_channel3_main
                                 
                                 //TREMELO
                                 sound_driver_channel3_fx_7xy:
001dd2 2fba                      	mov r27, r26
001dd3 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001dd4 95a2                      	swap r26
001dd5 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001dd6 93a0 2948                 	sts noise_fx_7xy_speed, r26
001dd8 93b0 2949                 	sts noise_fx_7xy_depth, r27
001dda 9220 294a                 	sts noise_fx_7xy_phase, zero //reset the phase to 0
001ddc 9220 294b                 	sts noise_fx_7xy_value, zero //reset the tremelo value
001dde cf5e                      	rjmp sound_driver_channel3_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel3_fx_Axy:
001ddf 93a0 294c                 	sts noise_fx_Axy, r26
001de1 cf5b                      	rjmp sound_driver_channel3_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel3_fx_Bxx:
001de2 93a0 281f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001de4 cf58                      	rjmp sound_driver_channel3_main
                                 
                                 //HALT
                                 sound_driver_channel3_fx_Cxx:
001de5 93b0 2820                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001de7 cf55                      	rjmp sound_driver_channel3_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel3_fx_Dxx:
001de8 93b0 2821                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001dea cf52                      	rjmp sound_driver_channel3_main
                                 
                                 //VOLUME
                                 sound_driver_channel3_fx_Exx:
001deb 91b0 2813                 	lds r27, noise_param
001ded 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
001dee 2bba                      	or r27, r26 //move new VVVV bits into noise_param
001def 93b0 2813                 	sts noise_param, r27
001df1 cf4b                      	rjmp sound_driver_channel3_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel3_fx_Fxx:
001df2 93a0 281e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001df4 cf48                      	rjmp sound_driver_channel3_main
                                 
                                 //DELAY
                                 sound_driver_channel3_fx_Gxx:
001df5 15a2                      	cp r26, zero
001df6 f051                      	breq sound_driver_channel3_fx_Gxx_invalid
001df7 91b0 281e                 	lds r27, song_speed
001df9 17ab                      	cp r26, r27
001dfa f430                      	brsh sound_driver_channel3_fx_Gxx_invalid
001dfb 93a0 294d                 	sts noise_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001dfd e0b1                      	ldi r27, 0x01
001dfe 93b0 2912                 	sts noise_pattern_delay_rows, r27
001e00 c20c                      	rjmp sound_driver_channel4
                                 sound_driver_channel3_fx_Gxx_invalid:
001e01 cf3b                      	rjmp sound_driver_channel3_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel3_fx_Hxy: //hardware sweep up
001e02 cf3a                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Ixy: //hardware sweep down
001e03 cf39                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Hxx: //FDS modulation depth
001e04 cf38                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Ixx: //FDS modulation speed
001e05 cf37                      	rjmp sound_driver_channel3_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel3_fx_Pxx:
001e06 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001e07 937f                      	push r23
001e08 2f6a                      	mov r22, r26
001e09 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001e0a 0367                      	mulsu r22, r23
001e0b 917f                      	pop r23
001e0c 916f                      	pop r22
001e0d 9416                      	lsr r1 //shift out the fractional bits
001e0e 9407                      	ror r0
001e0f 9416                      	lsr r1
001e10 9407                      	ror r0
001e11 9416                      	lsr r1
001e12 9407                      	ror r0
001e13 9416                      	lsr r1
001e14 9407                      	ror r0
001e15 fe13                      	sbrs r1, 3 //check if result was a negative number
001e16 c002                      	rjmp sound_driver_channel3_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel3_fx_Pxx_negative:
001e17 efb0                      	ldi r27, 0xF0
001e18 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel3_fx_Pxx_store:
001e19 9200 294f                 	sts noise_fx_Pxx_total, r0
001e1b 9210 2950                 	sts noise_fx_Pxx_total+1, r1
001e1d cf1f                      	rjmp sound_driver_channel3_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel3_fx_Qxy:
                                 sound_driver_channel3_fx_Qxy_check_arpeggio_macro:
001e1e 91e0 291b                 	lds ZL, noise_arpeggio_macro
001e20 91f0 291c                 	lds ZH, noise_arpeggio_macro+1
001e22 9630                      	adiw Z, 0
001e23 f009                      	breq sound_driver_channel3_fx_Qxy_check_pitch_macro
001e24 cf18                      	rjmp sound_driver_channel3_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Qxy_check_pitch_macro:
001e25 91e0 2923                 	lds ZL, noise_pitch_macro
001e27 91f0 2924                 	lds ZH, noise_pitch_macro+1
001e29 9630                      	adiw Z, 0
001e2a f009                      	breq sound_driver_channel3_fx_Qxy_check_hi_pitch_macro
001e2b cf11                      	rjmp sound_driver_channel3_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Qxy_check_hi_pitch_macro:
001e2c 91e0 2929                 	lds ZL, noise_hi_pitch_macro
001e2e 91f0 292a                 	lds ZH, noise_hi_pitch_macro+1
001e30 9630                      	adiw Z, 0
001e31 f009                      	breq sound_driver_channel3_fx_Qxy_process
001e32 cf0a                      	rjmp sound_driver_channel3_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Qxy_process:
001e33 2fba                      	mov r27, r26 //copy fx parameters into r27
001e34 70bf                      	andi r27, 0x0F //mask note index offset
001e35 91c0 2951                 	lds r28, noise_fx_Qxy_target_note //load current note index
001e37 0fbc                      	add r27, r28
001e38 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001e39 f008                      	brlo sound_driver_channel3_fx_Qxy_process_continue
001e3a e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel3_fx_Qxy_process_continue:
001e3b 93b0 2951                 	sts noise_fx_Qxy_target_note, r27
001e3d e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001e3e e0f0                      	ldi ZH, HIGH(note_table << 1)
001e3f 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001e40 0feb                      	add ZL, r27 //add offset
001e41 1df2                      	adc ZH, zero
001e42 91c5                      	lpm r28, Z+ //load bytes
001e43 91d4                      	lpm r29, Z
001e44 93c0 2952                 	sts noise_fx_Qxy_target, r28 //load the LOW bits for the target period
001e46 93d0 2953                 	sts noise_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel3_fx_Qxy_process_speed:
001e48 95a2                      	swap r26
001e49 70af                      	andi r26, 0x0F //mask effect speed
001e4a 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001e4b 95a3                      	inc r26 //increment the speed by 1
                                 
001e4c 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001e4d 937f                      	push r23
001e4e 2f6a                      	mov r22, r26 //store the speed data into r27
001e4f eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001e50 9f67                      	mul r22, r23
001e51 917f                      	pop r23
001e52 916f                      	pop r22
                                 
001e53 9416                      	lsr r1 //shift out the fractional bits
001e54 9407                      	ror r0
001e55 9416                      	lsr r1
001e56 9407                      	ror r0
001e57 9416                      	lsr r1
001e58 9407                      	ror r0
001e59 9416                      	lsr r1
001e5a 9407                      	ror r0
                                 
001e5b 9200 2954                 	sts noise_fx_Qxy_speed, r0 //store the effect speed
001e5d 9210 2955                 	sts noise_fx_Qxy_speed+1, r1
001e5f cedd                      	rjmp sound_driver_channel3_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel3_fx_Rxy:
                                 sound_driver_channel3_fx_Rxy_check_arpeggio_macro:
001e60 91e0 291b                 	lds ZL, noise_arpeggio_macro
001e62 91f0 291c                 	lds ZH, noise_arpeggio_macro+1
001e64 9630                      	adiw Z, 0
001e65 f009                      	breq sound_driver_channel3_fx_Rxy_check_pitch_macro
001e66 ced6                      	rjmp sound_driver_channel3_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Rxy_check_pitch_macro:
001e67 91e0 2923                 	lds ZL, noise_pitch_macro
001e69 91f0 2924                 	lds ZH, noise_pitch_macro+1
001e6b 9630                      	adiw Z, 0
001e6c f009                      	breq sound_driver_channel3_fx_Rxy_check_hi_pitch_macro
001e6d cecf                      	rjmp sound_driver_channel3_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Rxy_check_hi_pitch_macro:
001e6e 91e0 2929                 	lds ZL, noise_hi_pitch_macro
001e70 91f0 292a                 	lds ZH, noise_hi_pitch_macro+1
001e72 9630                      	adiw Z, 0
001e73 f009                      	breq sound_driver_channel3_fx_Rxy_process
001e74 cec8                      	rjmp sound_driver_channel3_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Rxy_process:
001e75 2fba                      	mov r27, r26 //copy fx parameters into r27
001e76 70bf                      	andi r27, 0x0F //mask note index offset
001e77 91c0 2958                 	lds r28, noise_fx_Rxy_target_note //load current note index
001e79 1bcb                      	sub r28, r27
001e7a f408                      	brcc sound_driver_channel3_fx_Rxy_process_continue
001e7b e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel3_fx_Rxy_process_continue:
001e7c 93c0 2958                 	sts noise_fx_Rxy_target_note, r28
001e7e e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001e7f e0f0                      	ldi ZH, HIGH(note_table << 1)
001e80 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001e81 0fec                      	add ZL, r28 //add offset
001e82 1df2                      	adc ZH, zero
001e83 91c5                      	lpm r28, Z+ //load bytes
001e84 91d4                      	lpm r29, Z
001e85 93c0 2959                 	sts noise_fx_Rxy_target, r28 //load the LOW bits for the target period
001e87 93d0 295a                 	sts noise_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel3_fx_Rxy_process_speed:
001e89 95a2                      	swap r26
001e8a 70af                      	andi r26, 0x0F //mask effect speed
001e8b 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001e8c 95a3                      	inc r26 //increment the speed by 1
                                 
001e8d 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001e8e 937f                      	push r23
001e8f 2f6a                      	mov r22, r26 //store the speed data into r27
001e90 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001e91 9f67                      	mul r22, r23
001e92 917f                      	pop r23
001e93 916f                      	pop r22
                                 
001e94 9416                      	lsr r1 //shift out the fractional bits
001e95 9407                      	ror r0
001e96 9416                      	lsr r1
001e97 9407                      	ror r0
001e98 9416                      	lsr r1
001e99 9407                      	ror r0
001e9a 9416                      	lsr r1
001e9b 9407                      	ror r0
                                 
001e9c 9200 295b                 	sts noise_fx_Rxy_speed, r0 //store the effect speed
001e9e 9210 295c                 	sts noise_fx_Rxy_speed+1, r1
001ea0 ce9c                      	rjmp sound_driver_channel3_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel3_fx_Sxx:
001ea1 15a2                      	cp r26, zero
001ea2 f051                      	breq sound_driver_channel3_fx_Sxx_invalid
001ea3 91b0 281e                 	lds r27, song_speed
001ea5 17ab                      	cp r26, r27
001ea6 f430                      	brsh sound_driver_channel3_fx_Sxx_invalid
001ea7 93a0 295f                 	sts noise_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001ea9 e0b1                      	ldi r27, 0x01
001eaa 93b0 2912                 	sts noise_pattern_delay_rows, r27
001eac c160                      	rjmp sound_driver_channel4
                                 sound_driver_channel3_fx_Sxx_invalid:
001ead ce8f                      	rjmp sound_driver_channel3_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel3_fx_Vxx:
001eae 95a6                      	lsr r26
001eaf 95a7                      	ror r26 //move mode bit to bit 7
001eb0 91b0 2814                 	lds r27, noise_period
001eb2 77bf                      	andi r27, 0b01111111
001eb3 2bba                      	or r27, r26 //store the new noise mode
001eb4 93b0 2813                 	sts noise_param, r27
                                 
001eb6 776f                      	andi noise_sequence_HIGH, 0b01111111
001eb7 2b6a                      	or noise_sequence_HIGH, r26
001eb8 ce84                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_Wxx: //DPCM sample speed
001eb9 ce83                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Xxx: //DPCM sample retrigger
001eba ce82                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Yxx: //DPCM sample offset
001ebb ce81                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Zxx: //DPCM sample delta counter
001ebc ce80                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 sound_driver_channel3_note:
001ebd 93b0 2817                 	sts noise_note, r27 //store the note index
001ebf 93b0 2951                 	sts noise_fx_Qxy_target_note, r27
001ec1 93b0 2958                 	sts noise_fx_Rxy_target_note, r27
001ec3 e0a3                      	ldi r26, 0x03
001ec4 e0b2                      	ldi r27, 0x02
001ec5 93b0 2918                 	sts noise_volume_macro_offset, r27 //reset all macro offsets
001ec7 93a0 291d                 	sts noise_arpeggio_macro_offset, r26
001ec9 93b0 2925                 	sts noise_pitch_macro_offset, r27
001ecb 93b0 292b                 	sts noise_hi_pitch_macro_offset, r27
001ecd 93b0 2930                 	sts noise_duty_macro_offset, r27
001ecf 9220 2921                 	sts noise_total_pitch_offset, zero //reset the pitch and hi pitch offset
001ed1 9220 2922                 	sts noise_total_pitch_offset+1, zero
001ed3 9220 2928                 	sts noise_total_hi_pitch_offset, zero
001ed5 9220 2937                 	sts noise_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001ed7 9220 2938                 	sts noise_fx_1xx_total+1, zero
001ed9 9220 293b                 	sts noise_fx_2xx_total, zero
001edb 9220 293c                 	sts noise_fx_2xx_total+1, zero
001edd 9220 2943                 	sts noise_fx_3xx_total_offset, zero //reset 3xx offset
001edf 9220 2944                 	sts noise_fx_3xx_total_offset+1, zero
001ee1 91a0 0abc                 	lds r26, TCB3_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001ee3 91b0 0abd                 	lds r27, TCB3_CCMPH
001ee5 93a0 293d                 	sts noise_fx_3xx_start, r26
001ee7 93b0 293e                 	sts noise_fx_3xx_start+1, r27
001ee9 9220 2952                 	sts noise_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001eeb 9220 2953                 	sts noise_fx_Qxy_target+1, zero
001eed 9220 2956                 	sts noise_fx_Qxy_total_offset, zero
001eef 9220 2957                 	sts noise_fx_Qxy_total_offset+1, zero
001ef1 9220 2959                 	sts noise_fx_Rxy_target, zero
001ef3 9220 295a                 	sts noise_fx_Rxy_target+1, zero
001ef5 9220 295d                 	sts noise_fx_Rxy_total_offset, zero
001ef7 9220 295e                 	sts noise_fx_Rxy_total_offset+1, zero
001ef9 d0fc                      	rcall sound_driver_channel3_increment_offset
001efa ce42                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_volume:
001efb 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001efc 91a0 2813                 	lds r26, noise_param
001efe 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001eff 2bab                      	or r26, r27 //move new VVVV bits into noise_param
001f00 93a0 2813                 	sts noise_param, r26
001f02 d0f3                      	rcall sound_driver_channel3_increment_offset
001f03 ce39                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_delay:
001f04 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001f05 93b0 2912                 	sts noise_pattern_delay_rows, r27
001f07 d0ee                      	rcall sound_driver_channel3_increment_offset
001f08 c104                      	rjmp sound_driver_channel4
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change:
001f09 9220 2916                 	sts noise_volume_macro, zero //reset all macro addresses
001f0b 9220 2917                 	sts noise_volume_macro+1, zero
001f0d 9220 291b                 	sts noise_arpeggio_macro, zero
001f0f 9220 291c                 	sts noise_arpeggio_macro+1, zero
001f11 9220 2923                 	sts noise_pitch_macro, zero
001f13 9220 2924                 	sts noise_pitch_macro+1, zero
001f15 9220 2929                 	sts noise_hi_pitch_macro, zero
001f17 9220 292a                 	sts noise_hi_pitch_macro+1, zero
001f19 9220 292e                 	sts noise_duty_macro, zero
001f1b 9220 292f                 	sts noise_duty_macro+1, zero
001f1d 9220 2921                 	sts noise_total_pitch_offset, zero //reset the pitch offset
001f1f 9220 2922                 	sts noise_total_pitch_offset+1, zero
001f21 9220 2928                 	sts noise_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001f23 9631                      	adiw Z, 1 //point to the byte next to the flag
001f24 91b4                      	lpm r27, Z //store the instrument offset into r27
001f25 e2ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
001f26 e0fd                      	ldi ZH, HIGH(instruments)
001f27 0feb                      	add ZL, r27 //point Z to offsetted instrument
001f28 1df2                      	adc ZH, zero
001f29 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001f2a 1fff                      	rol ZH
001f2b 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001f2c 91b4                      	lpm r27, Z
                                 
001f2d 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001f2e 1fbb                      	rol r27
001f2f 2fea                      	mov ZL, r26
001f30 2ffb                      	mov ZH, r27
001f31 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001f32 9632                      	adiw Z, 2 //point Z to the address of the macro
001f33 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel3_instrument_change_macro_loop:
001f34 95aa                      	dec r26
001f35 f019                      	breq sound_driver_channel3_instrument_change_exit
001f36 95b6                      	lsr r27
001f37 f078                      	brcs sound_driver_channel3_instrument_change_load_macro
001f38 cffb                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_exit:
001f39 e0a3                      	ldi r26, 0x03
001f3a e0b2                      	ldi r27, 0x02
001f3b 93b0 2918                 	sts noise_volume_macro_offset, r27 //reset all macro offsets
001f3d 93a0 291d                 	sts noise_arpeggio_macro_offset, r26
001f3f 93b0 2925                 	sts noise_pitch_macro_offset, r27
001f41 93b0 292b                 	sts noise_hi_pitch_macro_offset, r27
001f43 93b0 2930                 	sts noise_duty_macro_offset, r27
001f45 d0ba                      	rcall sound_driver_channel3_increment_offset_twice
001f46 cdf6                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_load_macro:
001f47 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001f48 91d5                      	lpm r29, Z+
                                 
001f49 30a5                      	cpi r26, 5
001f4a f039                      	breq sound_driver_channel3_instrument_change_load_macro_volume
001f4b 30a4                      	cpi r26, 4
001f4c f079                      	breq sound_driver_channel3_instrument_change_load_macro_arpeggio
001f4d 30a3                      	cpi r26, 3
001f4e f0d9                      	breq sound_driver_channel3_instrument_change_load_macro_pitch
001f4f 30a2                      	cpi r26, 2
001f50 f159                      	breq sound_driver_channel3_instrument_change_load_macro_hi_pitch
001f51 c03c                      	rjmp sound_driver_channel3_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel3_instrument_change_load_macro_volume:
001f52 93c0 2916                 	sts noise_volume_macro, r28
001f54 93d0 2917                 	sts noise_volume_macro+1, r29
001f56 d041                      	rcall sound_driver_channel3_instrument_change_read_header
001f57 93c0 291a                 	sts noise_volume_macro_release, r28
001f59 93d0 2919                 	sts noise_volume_macro_loop, r29
001f5b cfd8                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 	
                                 sound_driver_channel3_instrument_change_load_macro_arpeggio:
001f5c 93c0 291b                 	sts noise_arpeggio_macro, r28
001f5e 93d0 291c                 	sts noise_arpeggio_macro+1, r29
001f60 9220 2952                 	sts noise_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001f62 9220 2953                 	sts noise_fx_Qxy_target+1, zero
001f64 9220 2959                 	sts noise_fx_Rxy_target, zero
001f66 9220 295a                 	sts noise_fx_Rxy_target+1, zero
001f68 d03a                      	rcall sound_driver_channel3_instrument_change_read_header_arpeggio
001f69 cfca                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_pitch:
001f6a 93c0 2923                 	sts noise_pitch_macro, r28
001f6c 93d0 2924                 	sts noise_pitch_macro+1, r29
001f6e 9220 2952                 	sts noise_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001f70 9220 2953                 	sts noise_fx_Qxy_target+1, zero
001f72 9220 2959                 	sts noise_fx_Rxy_target, zero
001f74 9220 295a                 	sts noise_fx_Rxy_target+1, zero
001f76 d021                      	rcall sound_driver_channel3_instrument_change_read_header
001f77 93c0 2927                 	sts noise_pitch_macro_release, r28
001f79 93d0 2926                 	sts noise_pitch_macro_loop, r29
001f7b cfb8                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_hi_pitch:
001f7c 93c0 2929                 	sts noise_hi_pitch_macro, r28
001f7e 93d0 292a                 	sts noise_hi_pitch_macro+1, r29
001f80 9220 2952                 	sts noise_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001f82 9220 2953                 	sts noise_fx_Qxy_target+1, zero
001f84 9220 2959                 	sts noise_fx_Rxy_target, zero
001f86 9220 295a                 	sts noise_fx_Rxy_target+1, zero
001f88 d00f                      	rcall sound_driver_channel3_instrument_change_read_header
001f89 93c0 292d                 	sts noise_hi_pitch_macro_release, r28
001f8b 93d0 292c                 	sts noise_hi_pitch_macro_loop, r29
001f8d cfa6                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_duty:
001f8e 93c0 292e                 	sts noise_duty_macro, r28
001f90 93d0 292f                 	sts noise_duty_macro+1, r29
001f92 d005                      	rcall sound_driver_channel3_instrument_change_read_header
001f93 93c0 2932                 	sts noise_duty_macro_release, r28
001f95 93d0 2931                 	sts noise_duty_macro_loop, r29
001f97 cf9c                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_read_header:
001f98 93ef                      	push ZL
001f99 93ff                      	push ZH
001f9a 2fec                      	mov ZL, r28
001f9b 2ffd                      	mov ZH, r29
001f9c 0fee                      	lsl ZL
001f9d 1fff                      	rol ZH
001f9e 91c5                      	lpm r28, Z+
001f9f 91d4                      	lpm r29, Z
001fa0 91ff                      	pop ZH
001fa1 91ef                      	pop ZL
001fa2 9508                      	ret
                                 
                                 sound_driver_channel3_instrument_change_read_header_arpeggio:
001fa3 93ef                      	push ZL
001fa4 93ff                      	push ZH
001fa5 2fec                      	mov ZL, r28
001fa6 2ffd                      	mov ZH, r29
001fa7 0fee                      	lsl ZL
001fa8 1fff                      	rol ZH
001fa9 91c5                      	lpm r28, Z+
001faa 91d5                      	lpm r29, Z+
001fab 93c0 291f                 	sts noise_arpeggio_macro_release, r28
001fad 93d0 291e                 	sts noise_arpeggio_macro_loop, r29
001faf 91c4                      	lpm r28, Z
001fb0 93c0 2920                 	sts noise_arpeggio_macro_mode, r28
001fb2 91ff                      	pop ZH
001fb3 91ef                      	pop ZL
001fb4 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel3_release:
                                 sound_driver_channel3_release_volume:
001fb5 91b0 291a                 	lds r27, noise_volume_macro_release
001fb7 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001fb8 f019                      	breq sound_driver_channel3_release_arpeggio //if the macro has no release flag, check the next macro
001fb9 95b3                      	inc r27
001fba 93b0 2918                 	sts noise_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel3_release_arpeggio:
001fbc 91b0 291f                 	lds r27, noise_arpeggio_macro_release
001fbe 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001fbf f019                      	breq sound_driver_channel3_release_pitch
001fc0 95b3                      	inc r27
001fc1 93b0 291d                 	sts noise_arpeggio_macro_offset, r27
                                 sound_driver_channel3_release_pitch:
001fc3 91b0 2927                 	lds r27, noise_pitch_macro_release
001fc5 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001fc6 f019                      	breq sound_driver_channel3_release_hi_pitch
001fc7 95b3                      	inc r27
001fc8 93b0 2925                 	sts noise_pitch_macro_offset, r27
                                 sound_driver_channel3_release_hi_pitch:
001fca 91b0 292d                 	lds r27, noise_hi_pitch_macro_release
001fcc 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001fcd f019                      	breq sound_driver_channel3_release_duty
001fce 95b3                      	inc r27
001fcf 93b0 292b                 	sts noise_hi_pitch_macro_offset, r27
                                 sound_driver_channel3_release_duty:
001fd1 91b0 2932                 	lds r27, noise_duty_macro_release
001fd3 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001fd4 f019                      	breq sound_driver_channel3_release_exit
001fd5 95b3                      	inc r27
001fd6 93b0 2930                 	sts noise_duty_macro_offset, r27
                                 sound_driver_channel3_release_exit:
001fd8 d01d                      	rcall sound_driver_channel3_increment_offset
001fd9 cd63                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_next_pattern:
001fda 91e0 2818                 	lds ZL, song_frames
001fdc 91f0 2819                 	lds ZH, song_frames+1
001fde 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001fe0 91b0 281b                 	lds r27, song_frame_offset+1
001fe2 93a0 281a                 	sts song_frame_offset, r26
001fe4 93b0 281b                 	sts song_frame_offset+1, r27
001fe6 9616                      	adiw r27:r26, 6 //offset for channel 3
001fe7 0fea                      	add ZL, r26
001fe8 1ffb                      	adc ZH, r27
                                 
001fe9 91a5                      	lpm r26, Z+ //load the address of the next pattern
001fea 91b4                      	lpm r27, Z
001feb 0faa                      	lsl r26
001fec 1fbb                      	rol r27
001fed 93a0 2910                 	sts noise_pattern, r26
001fef 93b0 2911                 	sts noise_pattern+1, r27
                                 
001ff1 9220 2914                 	sts noise_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001ff3 9220 2915                 	sts noise_pattern_offset+1, zero
001ff5 cd47                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_increment_offset:
001ff6 91e0 2914                 	lds ZL, noise_pattern_offset //current offset in the pattern for noise
001ff8 91f0 2915                 	lds ZH, noise_pattern_offset+1
001ffa 9631                      	adiw Z, 1
001ffb 93e0 2914                 	sts noise_pattern_offset, ZL
001ffd 93f0 2915                 	sts noise_pattern_offset+1, ZH
001fff 9508                      	ret
                                 
                                 sound_driver_channel3_increment_offset_twice: //used for data that takes up 2 bytes worth of space
002000 91e0 2914                 	lds ZL, noise_pattern_offset //current offset in the pattern for noise
002002 91f0 2915                 	lds ZH, noise_pattern_offset+1
002004 9632                      	adiw Z, 2 //increment the pointer twice
002005 93e0 2914                 	sts noise_pattern_offset, ZL
002007 93f0 2915                 	sts noise_pattern_offset+1, ZH
002009 9508                      	ret
                                 
                                 sound_driver_channel3_decrement_frame_delay:
00200a 95ba                      	dec r27
00200b 93b0 2913                 	sts noise_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel4:
                                 
                                 sound_driver_calculate_delays:
00200d 91f0 281e                 	lds r31, song_speed
00200f 2fef                      	mov r30, r31
002010 50e1                      	subi r30, 1
                                 sound_driver_calculate_delays_pulse1:
002011 91a0 2825                 	lds r26, pulse1_pattern_delay_frames
002013 11a2                      	cpse r26, zero
002014 c042                      	rjmp sound_driver_calculate_delays_pulse2
002015 c000                      	rjmp sound_driver_calculate_delays_pulse1_main
                                 
                                 sound_driver_calculate_delays_pulse1_main:
002016 2faf                      	mov r26, r31 //move the speed to r26
002017 91b0 2824                 	lds r27, pulse1_pattern_delay_rows //decrement the delay rows
002019 15b2                      	cp r27, zero
00201a f409                      	brne PC+2
00201b c03b                      	rjmp sound_driver_calculate_delays_pulse2
00201c 95ba                      	dec r27
00201d 93b0 2824                 	sts pulse1_pattern_delay_rows, r27
00201f 11b2                      	cpse r27, zero
002020 c034                      	rjmp sound_driver_calculate_delays_pulse1_store
002021 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx:
002022 efbf                      	ldi r27, 0xFF
002023 91c0 2871                 	lds r28, pulse1_fx_Sxx_pre
002025 91d0 2872                 	lds r29, pulse1_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse1_Sxx_check_pre:
002027 17cb                      	cp r28, r27
002028 f009                      	breq sound_driver_calculate_delays_pulse1_Sxx_check_post
002029 c00d                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_pre
                                 sound_driver_calculate_delays_pulse1_Sxx_check_post:
00202a 17db                      	cp r29, r27
00202b f009                      	breq sound_driver_calculate_delays_pulse1_Gxx
00202c c015                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx:
00202d 91c0 285f                 	lds r28, pulse1_fx_Gxx_pre
00202f 91d0 2860                 	lds r29, pulse1_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse1_Gxx_check_pre:
002031 17cb                      	cp r28, r27
002032 f009                      	breq sound_driver_calculate_delays_pulse1_Gxx_check_post
002033 c012                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_pre
                                 sound_driver_calculate_delays_pulse1_Gxx_check_post:
002034 17db                      	cp r29, r27
002035 f0f9                      	breq sound_driver_calculate_delays_pulse1_store
002036 c01a                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_pre:
002037 93b0 2871                 	sts pulse1_fx_Sxx_pre, r27
002039 1bec                      	sub r30, r28 //(song speed)-1-Sxx
00203a 93e0 2872                 	sts pulse1_fx_Sxx_post, r30
00203c 95ca                      	dec r28
00203d 93c0 2825                 	sts pulse1_pattern_delay_frames, r28
00203f 2fef                      	mov r30, r31
002040 50e1                      	subi r30, 1
002041 c015                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_post:
002042 93b0 2872                 	sts pulse1_fx_Sxx_post, r27
002044 2fad                      	mov r26, r29
002045 c00f                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx_pre:
002046 93b0 285f                 	sts pulse1_fx_Gxx_pre, r27
002048 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002049 93e0 2860                 	sts pulse1_fx_Gxx_post, r30
00204b 95ca                      	dec r28
00204c 93c0 2825                 	sts pulse1_pattern_delay_frames, r28
00204e 2fef                      	mov r30, r31
00204f 50e1                      	subi r30, 1
002050 c006                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse1_Gxx_post:
002051 93b0 2860                 	sts pulse1_fx_Gxx_post, r27
002053 2fad                      	mov r26, r29
002054 c000                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_store:
002055 93a0 2825                 	sts pulse1_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_pulse2:
002057 91a0 2876                 	lds r26, pulse2_pattern_delay_frames
002059 11a2                      	cpse r26, zero
00205a c042                      	rjmp sound_driver_calculate_delays_triangle
00205b c000                      	rjmp sound_driver_calculate_delays_pulse2_main
                                 
                                 sound_driver_calculate_delays_pulse2_main:
00205c 2faf                      	mov r26, r31 //move the speed to r26
00205d 91b0 2875                 	lds r27, pulse2_pattern_delay_rows //decrement the delay rows
00205f 15b2                      	cp r27, zero
002060 f409                      	brne PC+2
002061 c03b                      	rjmp sound_driver_calculate_delays_triangle
002062 95ba                      	dec r27
002063 93b0 2875                 	sts pulse2_pattern_delay_rows, r27
002065 11b2                      	cpse r27, zero
002066 c034                      	rjmp sound_driver_calculate_delays_pulse2_store
002067 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx:
002068 efbf                      	ldi r27, 0xFF
002069 91c0 28c2                 	lds r28, pulse2_fx_Sxx_pre
00206b 91d0 28c3                 	lds r29, pulse2_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse2_Sxx_check_pre:
00206d 17cb                      	cp r28, r27
00206e f009                      	breq sound_driver_calculate_delays_pulse2_Sxx_check_post
00206f c00d                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_pre
                                 sound_driver_calculate_delays_pulse2_Sxx_check_post:
002070 17db                      	cp r29, r27
002071 f009                      	breq sound_driver_calculate_delays_pulse2_Gxx
002072 c015                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx:
002073 91c0 28b0                 	lds r28, pulse2_fx_Gxx_pre
002075 91d0 28b1                 	lds r29, pulse2_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse2_Gxx_check_pre:
002077 17cb                      	cp r28, r27
002078 f009                      	breq sound_driver_calculate_delays_pulse2_Gxx_check_post
002079 c012                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_pre
                                 sound_driver_calculate_delays_pulse2_Gxx_check_post:
00207a 17db                      	cp r29, r27
00207b f0f9                      	breq sound_driver_calculate_delays_pulse2_store
00207c c01a                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_pre:
00207d 93b0 28c2                 	sts pulse2_fx_Sxx_pre, r27
00207f 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002080 93e0 28c3                 	sts pulse2_fx_Sxx_post, r30
002082 95ca                      	dec r28
002083 93c0 2876                 	sts pulse2_pattern_delay_frames, r28
002085 2fef                      	mov r30, r31
002086 50e1                      	subi r30, 1
002087 cfcf                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_post:
002088 93b0 28c3                 	sts pulse2_fx_Sxx_post, r27
00208a 2fad                      	mov r26, r29
00208b c00f                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx_pre:
00208c 93b0 28b0                 	sts pulse2_fx_Gxx_pre, r27
00208e 1bec                      	sub r30, r28 //(song speed)-1-Sxx
00208f 93e0 28b1                 	sts pulse2_fx_Gxx_post, r30
002091 95ca                      	dec r28
002092 93c0 2876                 	sts pulse2_pattern_delay_frames, r28
002094 2fef                      	mov r30, r31
002095 50e1                      	subi r30, 1
002096 cfc0                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse2_Gxx_post:
002097 93b0 28b1                 	sts pulse2_fx_Gxx_post, r27
002099 2fad                      	mov r26, r29
00209a c000                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_store:
00209b 93a0 2876                 	sts pulse2_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_triangle:
00209d 91a0 28c7                 	lds r26, triangle_pattern_delay_frames
00209f 11a2                      	cpse r26, zero
0020a0 c042                      	rjmp sound_driver_calculate_delays_noise
0020a1 c000                      	rjmp sound_driver_calculate_delays_triangle_main
                                 
                                 sound_driver_calculate_delays_triangle_main:
0020a2 2faf                      	mov r26, r31 //move the speed to r26
0020a3 91b0 28c6                 	lds r27, triangle_pattern_delay_rows //decrement the delay rows
0020a5 15b2                      	cp r27, zero
0020a6 f409                      	brne PC+2
0020a7 c03b                      	rjmp sound_driver_calculate_delays_noise
0020a8 95ba                      	dec r27
0020a9 93b0 28c6                 	sts triangle_pattern_delay_rows, r27
0020ab 11b2                      	cpse r27, zero
0020ac c034                      	rjmp sound_driver_calculate_delays_triangle_store
0020ad 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_triangle_Sxx:
0020ae efbf                      	ldi r27, 0xFF
0020af 91c0 290e                 	lds r28, triangle_fx_Sxx_pre
0020b1 91d0 290f                 	lds r29, triangle_fx_Sxx_post
                                 sound_driver_calculate_delays_triangle_Sxx_check_pre:
0020b3 17cb                      	cp r28, r27
0020b4 f009                      	breq sound_driver_calculate_delays_triangle_Sxx_check_post
0020b5 c00d                      	rjmp sound_driver_calculate_delays_triangle_Sxx_pre
                                 sound_driver_calculate_delays_triangle_Sxx_check_post:
0020b6 17db                      	cp r29, r27
0020b7 f009                      	breq sound_driver_calculate_delays_triangle_Gxx
0020b8 c015                      	rjmp sound_driver_calculate_delays_triangle_Sxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Gxx:
0020b9 91c0 28fc                 	lds r28, triangle_fx_Gxx_pre
0020bb 91d0 28fd                 	lds r29, triangle_fx_Gxx_post
                                 sound_driver_calculate_delays_triangle_Gxx_check_pre:
0020bd 17cb                      	cp r28, r27
0020be f009                      	breq sound_driver_calculate_delays_triangle_Gxx_check_post
0020bf c012                      	rjmp sound_driver_calculate_delays_triangle_Gxx_pre
                                 sound_driver_calculate_delays_triangle_Gxx_check_post:
0020c0 17db                      	cp r29, r27
0020c1 f0f9                      	breq sound_driver_calculate_delays_triangle_store
0020c2 c01a                      	rjmp sound_driver_calculate_delays_triangle_Gxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_pre:
0020c3 93b0 290e                 	sts triangle_fx_Sxx_pre, r27
0020c5 1bec                      	sub r30, r28 //(song speed)-1-Sxx
0020c6 93e0 290f                 	sts triangle_fx_Sxx_post, r30
0020c8 95ca                      	dec r28
0020c9 93c0 28c7                 	sts triangle_pattern_delay_frames, r28
0020cb 2fef                      	mov r30, r31
0020cc 50e1                      	subi r30, 1
0020cd c015                      	rjmp sound_driver_calculate_delays_noise
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_post:
0020ce 93b0 290f                 	sts triangle_fx_Sxx_post, r27
0020d0 2fad                      	mov r26, r29
0020d1 c00f                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_Gxx_pre:
0020d2 93b0 28fc                 	sts triangle_fx_Gxx_pre, r27
0020d4 1bec                      	sub r30, r28 //(song speed)-1-Sxx
0020d5 93e0 28fd                 	sts triangle_fx_Gxx_post, r30
0020d7 95ca                      	dec r28
0020d8 93c0 28c7                 	sts triangle_pattern_delay_frames, r28
0020da 2fef                      	mov r30, r31
0020db 50e1                      	subi r30, 1
0020dc c006                      	rjmp sound_driver_calculate_delays_noise
                                 	
                                 sound_driver_calculate_delays_triangle_Gxx_post:
0020dd 93b0 28fd                 	sts triangle_fx_Gxx_post, r27
0020df 2fad                      	mov r26, r29
0020e0 c000                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_store:
0020e1 93a0 28c7                 	sts triangle_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_noise:
0020e3 91a0 2913                 	lds r26, noise_pattern_delay_frames
0020e5 11a2                      	cpse r26, zero
0020e6 c042                      	rjmp sound_driver_calculate_delays_dpcm
0020e7 c000                      	rjmp sound_driver_calculate_delays_noise_main
                                 
                                 sound_driver_calculate_delays_noise_main:
0020e8 2faf                      	mov r26, r31 //move the speed to r26
0020e9 91b0 2912                 	lds r27, noise_pattern_delay_rows //decrement the delay rows
0020eb 15b2                      	cp r27, zero
0020ec f409                      	brne PC+2
0020ed c03b                      	rjmp sound_driver_calculate_delays_dpcm
0020ee 95ba                      	dec r27
0020ef 93b0 2912                 	sts noise_pattern_delay_rows, r27
0020f1 11b2                      	cpse r27, zero
0020f2 c034                      	rjmp sound_driver_calculate_delays_noise_store
0020f3 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_noise_Sxx:
0020f4 efbf                      	ldi r27, 0xFF
0020f5 91c0 295f                 	lds r28, noise_fx_Sxx_pre
0020f7 91d0 2960                 	lds r29, noise_fx_Sxx_post
                                 sound_driver_calculate_delays_noise_Sxx_check_pre:
0020f9 17cb                      	cp r28, r27
0020fa f009                      	breq sound_driver_calculate_delays_noise_Sxx_check_post
0020fb c00d                      	rjmp sound_driver_calculate_delays_noise_Sxx_pre
                                 sound_driver_calculate_delays_noise_Sxx_check_post:
0020fc 17db                      	cp r29, r27
0020fd f009                      	breq sound_driver_calculate_delays_noise_Gxx
0020fe c015                      	rjmp sound_driver_calculate_delays_noise_Sxx_post
                                 
                                 sound_driver_calculate_delays_noise_Gxx:
0020ff 91c0 294d                 	lds r28, noise_fx_Gxx_pre
002101 91d0 294e                 	lds r29, noise_fx_Gxx_post
                                 sound_driver_calculate_delays_noise_Gxx_check_pre:
002103 17cb                      	cp r28, r27
002104 f009                      	breq sound_driver_calculate_delays_noise_Gxx_check_post
002105 c012                      	rjmp sound_driver_calculate_delays_noise_Gxx_pre
                                 sound_driver_calculate_delays_noise_Gxx_check_post:
002106 17db                      	cp r29, r27
002107 f0f9                      	breq sound_driver_calculate_delays_noise_store
002108 c01a                      	rjmp sound_driver_calculate_delays_noise_Gxx_post
                                 
                                 sound_driver_calculate_delays_noise_Sxx_pre:
002109 93b0 295f                 	sts noise_fx_Sxx_pre, r27
00210b 1bec                      	sub r30, r28 //(song speed)-1-Sxx
00210c 93e0 2960                 	sts noise_fx_Sxx_post, r30
00210e 95ca                      	dec r28
00210f 93c0 2913                 	sts noise_pattern_delay_frames, r28
002111 2fef                      	mov r30, r31
002112 50e1                      	subi r30, 1
002113 c015                      	rjmp sound_driver_calculate_delays_dpcm
                                 
                                 sound_driver_calculate_delays_noise_Sxx_post:
002114 93b0 2960                 	sts noise_fx_Sxx_post, r27
002116 2fad                      	mov r26, r29
002117 c00f                      	rjmp sound_driver_calculate_delays_noise_store
                                 
                                 sound_driver_calculate_delays_noise_Gxx_pre:
002118 93b0 294d                 	sts noise_fx_Gxx_pre, r27
00211a 1bec                      	sub r30, r28 //(song speed)-1-Sxx
00211b 93e0 294e                 	sts noise_fx_Gxx_post, r30
00211d 95ca                      	dec r28
00211e 93c0 2913                 	sts noise_pattern_delay_frames, r28
002120 2fef                      	mov r30, r31
002121 50e1                      	subi r30, 1
002122 c006                      	rjmp sound_driver_calculate_delays_dpcm
                                 	
                                 sound_driver_calculate_delays_noise_Gxx_post:
002123 93b0 294e                 	sts noise_fx_Gxx_post, r27
002125 2fad                      	mov r26, r29
002126 c000                      	rjmp sound_driver_calculate_delays_noise_store
                                 
                                 sound_driver_calculate_delays_noise_store:
002127 93a0 2913                 	sts noise_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_dpcm:
                                 
                                 sound_driver_instrument_fx_routine:
                                 sound_driver_instrument_routine_channel0_volume:
002129 91e0 2828                 	lds ZL, pulse1_volume_macro
00212b 91f0 2829                 	lds ZH, pulse1_volume_macro+1
00212d 9630                      	adiw Z, 0
00212e f1a1                      	breq sound_driver_instrument_routine_channel0_volume_default //if no volume macro is in use, use default multiplier of F
00212f 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002130 1fff                      	rol ZH
002131 91a0 282a                 	lds r26, pulse1_volume_macro_offset
002133 0fea                      	add ZL, r26
002134 1df2                      	adc ZH, zero
                                 
002135 91b0 282c                 	lds r27, pulse1_volume_macro_release
002137 17ba                      	cp r27, r26
002138 f429                      	brne sound_driver_instrument_routine_channel0_volume_increment //if the current offset is not equal to the release index, increment the offset
002139 91a0 282b                 	lds r26, pulse1_volume_macro_loop
00213b 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00213c f010                      	brlo sound_driver_instrument_routine_channel0_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00213d c003                      	rjmp sound_driver_instrument_routine_channel0_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_volume_increment:
00213e 95a3                      	inc r26 //increment the macro offset
00213f 93a0 282a                 	sts pulse1_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_volume_read:
002141 91b4                      	lpm r27, Z //load volume data into r27
002142 3fbf                      	cpi r27, 0xFF //check for macro end flag
002143 f469                      	brne sound_driver_instrument_routine_channel0_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_release:
002144 91b0 282c                 	lds r27, pulse1_volume_macro_release
002146 3fbf                      	cpi r27, 0xFF
002147 f429                      	brne sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_loop:
002148 91b0 282b                 	lds r27, pulse1_volume_macro_loop //load the loop index
00214a 93b0 282a                 	sts pulse1_volume_macro_offset, r27 //store the loop index into the offset
00214c cfdc                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index:
00214d 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
00214e 93a0 282a                 	sts pulse1_volume_macro_offset, r26
002150 cfd8                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_calculate:
002151 ecea                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
002152 e5fc                      	ldi ZH, HIGH(volumes << 1)
002153 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
002154 0feb                      	add ZL, r27 //add offset to the table
002155 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel0_volume_load:
002156 91b0 2800                 	lds r27, pulse1_param //load main volume
002158 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002159 91a0 285d                 	lds r26, pulse1_fx_7xy_value
00215b 30a0                      	cpi r26, 0x00
00215c f481                      	brne sound_driver_instrument_routine_channel0_volume_load_7xy
                                 
00215d 0feb                      	add ZL, r27 //offset the volume table by the main volume
00215e 1df2                      	adc ZH, zero
00215f 91b4                      	lpm r27, Z
002160 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
002162 c023                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default:
002163 91b0 2800                 	lds r27, pulse1_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
002165 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002166 91a0 285d                 	lds r26, pulse1_fx_7xy_value
002168 30a0                      	cpi r26, 0x00
002169 f499                      	brne sound_driver_instrument_routine_channel0_volume_default_7xy
00216a 93b0 2806                 	sts pulse1_output_volume, r27
00216c c019                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy:
00216d 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
00216e f038                      	brcs sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
00216f f031                      	breq sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
                                 
002170 0feb                      	add ZL, r27 //offset the volume table by the main volume
002171 1df2                      	adc ZH, zero
002172 91b4                      	lpm r27, Z
002173 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
002175 c010                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy_overflow:
002176 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002177 0feb                      	add ZL, r27 //offset the volume table by the main volume
002178 1df2                      	adc ZH, zero
002179 91b4                      	lpm r27, Z
00217a 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
00217c c009                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default_7xy:
00217d 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
00217e f020                      	brcs sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
00217f f019                      	breq sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
002180 93b0 2806                 	sts pulse1_output_volume, r27
002182 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel0_volume_default_7xy_overflow:
002183 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002184 93b0 2806                 	sts pulse1_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002186 91e0 282d                 	lds ZL, pulse1_arpeggio_macro
002188 91f0 282e                 	lds ZH, pulse1_arpeggio_macro+1
00218a 9630                      	adiw Z, 0
00218b f1d9                      	breq sound_driver_instrument_routine_channel0_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
00218c 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
00218d 1fff                      	rol ZH
00218e 91a0 282f                 	lds r26, pulse1_arpeggio_macro_offset
002190 0fea                      	add ZL, r26
002191 1df2                      	adc ZH, zero
                                 
002192 91b0 2831                 	lds r27, pulse1_arpeggio_macro_release
002194 17ba                      	cp r27, r26
002195 f429                      	brne sound_driver_instrument_routine_channel0_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002196 91a0 2830                 	lds r26, pulse1_arpeggio_macro_loop
002198 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002199 f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
00219a c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_increment:
00219b 95a3                      	inc r26 //increment the macro offset
00219c 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_read:
00219e 91b4                      	lpm r27, Z //load arpeggio data into r27
00219f 38b0                      	cpi r27, 0x80 //check for macro end flag
0021a0 f009                      	breq sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag
0021a1 c041                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_check_mode:
0021a2 50a1                      	subi r26, 1 //keep the offset at the end flag
0021a3 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26
0021a5 91b0 2832                 	lds r27, pulse1_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
0021a7 30b1                      	cpi r27, 0x01
0021a8 f048                      	brlo sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_release:
0021a9 91b0 2831                 	lds r27, pulse1_arpeggio_macro_release
0021ab 3fbf                      	cpi r27, 0xFF
0021ac f4d1                      	brne sound_driver_instrument_routine_channel0_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_loop:
0021ad 91b0 2830                 	lds r27, pulse1_arpeggio_macro_loop
0021af 3fbf                      	cpi r27, 0xFF
0021b0 f499                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
0021b1 c015                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute:
0021b2 91b0 2831                 	lds r27, pulse1_arpeggio_macro_release
0021b4 3fbf                      	cpi r27, 0xFF
0021b5 f421                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_check_loop:
0021b6 91b0 2830                 	lds r27, pulse1_arpeggio_macro_loop //load the loop index
0021b8 3fbf                      	cpi r27, 0xFF //check if loop flag exists
0021b9 f451                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop:
0021ba 91c0 2845                 	lds r28, pulse1_fx_0xy_sequence //check for 0xy effect
0021bc 91d0 2846                 	lds r29, pulse1_fx_0xy_sequence+1
0021be 9620                      	adiw r29:r28, 0
0021bf f469                      	brne sound_driver_instrument_routine_channel0_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
0021c0 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
0021c1 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26 //store the last valid index into the offset
0021c3 cfc2                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload:
0021c4 93b0 282f                 	sts pulse1_arpeggio_macro_offset, r27 //store the loop index into the offset
0021c6 cfbf                      	rjmp sound_driver_instrument_routine_channel0_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_default:
0021c7 91c0 2845                 	lds r28, pulse1_fx_0xy_sequence //load 0xy effect
0021c9 91d0 2846                 	lds r29, pulse1_fx_0xy_sequence+1
0021cb 9620                      	adiw r29:r28, 0 //check for 0xy effect
0021cc f099                      	breq sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel0_arpeggio_default_0xy:
0021cd 95d6                      	lsr r29
0021ce 95c7                      	ror r28
0021cf 95d7                      	ror r29
0021d0 95c7                      	ror r28
0021d1 95d7                      	ror r29
0021d2 95c7                      	ror r28
0021d3 95d7                      	ror r29
0021d4 95c7                      	ror r28
0021d5 95d7                      	ror r29
0021d6 95d2                      	swap r29
                                 
0021d7 93c0 2845                 	sts pulse1_fx_0xy_sequence, r28 //store the rolled sequence
0021d9 93d0 2846                 	sts pulse1_fx_0xy_sequence+1, r29
0021db 70cf                      	andi r28, 0x0F //mask out the 4 LSB
0021dc 91a0 2807                 	lds r26, pulse1_note //load the current note index
0021de 0fac                      	add r26, r28 //add the note offset
0021df c02e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
0021e0 91a0 2807                 	lds r26, pulse1_note //load the current note index
0021e2 c02b                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process:
0021e3 9220 2833                 	sts pulse1_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
0021e5 9220 2834                 	sts pulse1_total_pitch_offset+1, zero
0021e7 9220 283a                 	sts pulse1_total_hi_pitch_offset, zero
0021e9 91a0 2832                 	lds r26, pulse1_arpeggio_macro_mode
0021eb 30a1                      	cpi r26, 0x01 //absolute mode
0021ec f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_absolute
0021ed f069                      	breq sound_driver_instrument_routine_channel0_arpeggio_process_fixed
0021ee c00e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute:
0021ef 91a0 2807                 	lds r26, pulse1_note //load the current note index
0021f1 0fab                      	add r26, r27 //offset the note with the arpeggio data
0021f2 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0021f3 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_add:
0021f4 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0021f5 f0c0                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
0021f6 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0021f7 c016                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract:
0021f8 fda7                      	sbrc r26, 7 //check if result is negative
0021f9 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0021fa c013                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_fixed:
0021fb 2fab                      	mov r26, r27 //move the arpeggio data into r26
0021fc c011                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative:
0021fd 91a0 2807                 	lds r26, pulse1_note //load the current note index
0021ff 0fab                      	add r26, r27 //offset the note with the arpeggio data
002200 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002201 c008                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_add:
002202 93a0 2807                 	sts pulse1_note, r26 //NOTE: relative mode modifies the original note index
002204 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002205 f040                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
002206 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002207 93a0 2807                 	sts pulse1_note, r26
002209 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract:
00220a fda7                      	sbrc r26, 7 //check if result is negative
00220b e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
00220c 93a0 2807                 	sts pulse1_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_load:
00220e e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
00220f e0f0                      	ldi ZH, HIGH(note_table << 1)
002210 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002211 0fea                      	add ZL, r26 //add offset
002212 1df2                      	adc ZH, zero
002213 91a5                      	lpm r26, Z+ //load bytes
002214 91b4                      	lpm r27, Z
002215 93a0 0a8c                 	sts TCB0_CCMPL, r26 //load the LOW bits for timer
002217 93b0 0a8d                 	sts TCB0_CCMPH, r27 //load the HIGH bits for timer
002219 93a0 2851                 	sts pulse1_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
00221b 93b0 2852                 	sts pulse1_fx_3xx_target+1, r27
00221d c000                      	rjmp sound_driver_instrument_routine_channel0_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch:
00221e 91e0 2835                 	lds ZL, pulse1_pitch_macro
002220 91f0 2836                 	lds ZH, pulse1_pitch_macro+1
002222 9630                      	adiw Z, 0
002223 f409                      	brne sound_driver_instrument_routine_channel0_pitch_continue
002224 c023                      	rjmp sound_driver_instrument_routine_channel0_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel0_pitch_continue:
002225 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002226 1fff                      	rol ZH
002227 91a0 2837                 	lds r26, pulse1_pitch_macro_offset
002229 0fea                      	add ZL, r26
00222a 1df2                      	adc ZH, zero
                                 
00222b 91b0 2839                 	lds r27, pulse1_pitch_macro_release
00222d 17ba                      	cp r27, r26
00222e f429                      	brne sound_driver_instrument_routine_channel0_pitch_increment //if the current offset is not equal to the release index, increment the offset
00222f 91a0 2838                 	lds r26, pulse1_pitch_macro_loop
002231 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002232 f010                      	brlo sound_driver_instrument_routine_channel0_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002233 c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_pitch_increment:
002234 95a3                      	inc r26 //increment the macro offset
002235 93a0 2837                 	sts pulse1_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_pitch_read:
002237 91b4                      	lpm r27, Z //load pitch data into r27
002238 38b0                      	cpi r27, 0x80 //check for macro end flag
002239 f479                      	brne sound_driver_instrument_routine_channel0_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_release:
00223a 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00223b 93a0 2837                 	sts pulse1_pitch_macro_offset, r26
00223d 91b0 2839                 	lds r27, pulse1_pitch_macro_release
00223f 3fbf                      	cpi r27, 0xFF
002240 f439                      	brne sound_driver_instrument_routine_channel0_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_loop:
002241 91b0 2838                 	lds r27, pulse1_pitch_macro_loop //load the loop index
002243 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002244 f019                      	breq sound_driver_instrument_routine_channel0_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002245 93b0 2837                 	sts pulse1_pitch_macro_offset, r27 //store the loop index into the offset
002247 cfd6                      	rjmp sound_driver_instrument_routine_channel0_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_default:
002248 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel0_pitch_calculate:
002249 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00224a 937f                      	push r23
00224b 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
00224c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00224d 0367                      	mulsu r22, r23
00224e 917f                      	pop r23
00224f 916f                      	pop r22
                                 
002250 9416                      	lsr r1 //shift out the fractional bits
002251 9407                      	ror r0
002252 9416                      	lsr r1
002253 9407                      	ror r0
002254 9416                      	lsr r1
002255 9407                      	ror r0
002256 9416                      	lsr r1
002257 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_check_negative:
002258 fe13                      	sbrs r1, 3 //check if result was a negative number
002259 c007                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_negative:
00225a efc0                      	ldi r28, 0xF0
00225b 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_check_divisible_8:
00225c 70b7                      	andi r27, 0b00000111
00225d f019                      	breq sound_driver_instrument_routine_channel0_pitch_calculate_offset
                                 
00225e e0b1                      	ldi r27, 0x01
00225f 0e0b                      	add r0, r27
002260 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_offset:
002261 91a0 2833                 	lds r26, pulse1_total_pitch_offset
002263 91b0 2834                 	lds r27, pulse1_total_pitch_offset+1
002265 0e0a                      	add r0, r26
002266 1e1b                      	adc r1, r27
002267 9200 2833                 	sts pulse1_total_pitch_offset, r0
002269 9210 2834                 	sts pulse1_total_pitch_offset+1, r1
00226b 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
00226d 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
00226f 0da0                      	add r26, r0 //offset the timer values
002270 1db1                      	adc r27, r1
                                 	
002271 91c0 2849                 	lds r28, pulse1_fx_1xx_total
002273 91d0 284a                 	lds r29, pulse1_fx_1xx_total+1
002275 1bac                      	sub r26, r28
002276 0bbd                      	sbc r27, r29
002277 91c0 284d                 	lds r28, pulse1_fx_2xx_total
002279 91d0 284e                 	lds r29, pulse1_fx_2xx_total+1
00227b 0fac                      	add r26, r28
00227c 1fbd                      	adc r27, r29
00227d 91c0 2861                 	lds r28, pulse1_fx_Pxx_total
00227f 91d0 2862                 	lds r29, pulse1_fx_Pxx_total+1
002281 0fac                      	add r26, r28
002282 1fbd                      	adc r27, r29
002283 91c0 2868                 	lds r28, pulse1_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
002285 91d0 2869                 	lds r29, pulse1_fx_Qxy_total_offset+1
002287 1bac                      	sub r26, r28
002288 0bbd                      	sbc r27, r29
002289 91c0 286f                 	lds r28, pulse1_fx_Rxy_total_offset
00228b 91d0 2870                 	lds r29, pulse1_fx_Rxy_total_offset+1
00228d 0fac                      	add r26, r28
00228e 1fbd                      	adc r27, r29
                                 
00228f e5c9                      	ldi r28, 0x59
002290 e0d0                      	ldi r29, 0x00
002291 17ac                      	cp r26, r28
002292 07bd                      	cpc r27, r29
002293 f030                      	brlo sound_driver_instrument_routine_channel0_pitch_min
                                 
002294 e5ca                      	ldi r28, 0x5A
002295 e5d9                      	ldi r29, 0x59
002296 17ac                      	cp r26, r28
002297 07bd                      	cpc r27, r29
002298 f420                      	brsh sound_driver_instrument_routine_channel0_pitch_max
002299 c006                      	rjmp sound_driver_instrument_routine_channel0_pitch_store
                                 
                                 sound_driver_instrument_routine_channel0_pitch_min:
00229a e5c9                      	ldi r28, 0x59
00229b e0d0                      	ldi r29, 0x00
00229c c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_store
                                 
                                 sound_driver_instrument_routine_channel0_pitch_max:
00229d e5c9                      	ldi r28, 0x59
00229e e5d9                      	ldi r29, 0x59
00229f c000                      	rjmp sound_driver_instrument_routine_channel0_pitch_store
                                 
                                 sound_driver_instrument_routine_channel0_pitch_store:
0022a0 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
0022a2 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel0_hi_pitch:
0022a4 91e0 283b                 	lds ZL, pulse1_hi_pitch_macro
0022a6 91f0 283c                 	lds ZH, pulse1_hi_pitch_macro+1
0022a8 9630                      	adiw Z, 0
0022a9 f409                      	brne sound_driver_instrument_routine_channel0_hi_pitch_continue
0022aa c03c                      	rjmp sound_driver_instrument_routine_channel0_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel0_hi_pitch_continue:
0022ab 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0022ac 1fff                      	rol ZH
0022ad 91a0 283d                 	lds r26, pulse1_hi_pitch_macro_offset
0022af 0fea                      	add ZL, r26
0022b0 1df2                      	adc ZH, zero
                                 
0022b1 91b0 283f                 	lds r27, pulse1_hi_pitch_macro_release
0022b3 17ba                      	cp r27, r26
0022b4 f429                      	brne sound_driver_instrument_routine_channel0_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
0022b5 91a0 283e                 	lds r26, pulse1_hi_pitch_macro_loop
0022b7 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0022b8 f010                      	brlo sound_driver_instrument_routine_channel0_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0022b9 c003                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_increment:
0022ba 95a3                      	inc r26 //increment the macro offset
0022bb 93a0 283d                 	sts pulse1_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_hi_pitch_read:
0022bd 91b4                      	lpm r27, Z //load hi pitch data into r27
0022be 38b0                      	cpi r27, 0x80 //check for macro end flag
0022bf f489                      	brne sound_driver_instrument_routine_channel0_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_release:
0022c0 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0022c1 93a0 283d                 	sts pulse1_hi_pitch_macro_offset, r26
0022c3 91b0 283f                 	lds r27, pulse1_hi_pitch_macro_release
0022c5 3fbf                      	cpi r27, 0xFF
0022c6 f439                      	brne sound_driver_instrument_routine_channel0_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_loop:
0022c7 91b0 283e                 	lds r27, pulse1_hi_pitch_macro_loop //load the loop index
0022c9 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0022ca f019                      	breq sound_driver_instrument_routine_channel0_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
0022cb 93b0 283d                 	sts pulse1_hi_pitch_macro_offset, r27 //store the loop index into the offset
0022cd cfd6                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_default:
0022ce 91b0 283a                 	lds r27, pulse1_total_hi_pitch_offset
0022d0 c005                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate:
0022d1 91a0 283a                 	lds r26, pulse1_total_hi_pitch_offset //load the total hi pitch offset to change
0022d3 0fba                      	add r27, r26
0022d4 93b0 283a                 	sts pulse1_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply:
0022d6 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0022d7 937f                      	push r23
0022d8 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
0022d9 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0022da 0367                      	mulsu r22, r23
0022db 917f                      	pop r23
0022dc 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_offset:
0022dd 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
0022df 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
0022e1 0da0                      	add r26, r0 //offset the timer values
0022e2 1db1                      	adc r27, r1
0022e3 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
0022e5 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel0_duty:
0022e7 91e0 2840                 	lds ZL, pulse1_duty_macro
0022e9 91f0 2841                 	lds ZH, pulse1_duty_macro+1
0022eb 9630                      	adiw Z, 0
0022ec f1b1                      	breq sound_driver_channel0_fx_routines //if no duty macro is in use, go to the next routine
0022ed 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0022ee 1fff                      	rol ZH
0022ef 91a0 2842                 	lds r26, pulse1_duty_macro_offset
0022f1 0fea                      	add ZL, r26
0022f2 1df2                      	adc ZH, zero
                                 
0022f3 91b0 2844                 	lds r27, pulse1_duty_macro_release
0022f5 17ba                      	cp r27, r26
0022f6 f429                      	brne sound_driver_instrument_routine_channel0_duty_increment //if the current offset is not equal to the release index, increment the offset
0022f7 91a0 2843                 	lds r26, pulse1_duty_macro_loop
0022f9 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0022fa f010                      	brlo sound_driver_instrument_routine_channel0_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0022fb c027                      	rjmp sound_driver_channel0_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel0_duty_increment:
0022fc 95a3                      	inc r26 //increment the macro offset
0022fd 93a0 2842                 	sts pulse1_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_duty_read:
0022ff 91b4                      	lpm r27, Z //load pitch data into r27
002300 3fbf                      	cpi r27, 0xFF //check for macro end flag
002301 f471                      	brne sound_driver_instrument_routine_channel0_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_release:
002302 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002303 93a0 2842                 	sts pulse1_duty_macro_offset, r26
002305 91b0 2844                 	lds r27, pulse1_duty_macro_release
002307 3fbf                      	cpi r27, 0xFF
002308 f4d1                      	brne sound_driver_channel0_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_loop:
002309 91b0 2843                 	lds r27, pulse1_duty_macro_loop //load the loop index
00230b 3fbf                      	cpi r27, 0xFF //check if there is a loop index
00230c f0b1                      	breq sound_driver_channel0_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
00230d 93b0 2842                 	sts pulse1_duty_macro_offset, r27 //store the loop index into the offset
00230f cfd7                      	rjmp sound_driver_instrument_routine_channel0_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_load:
002310 efe6                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
002311 e5fb                      	ldi ZH, HIGH(sequences << 1)
002312 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
002313 1df2                      	adc ZH, zero
                                 
002314 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
002315 95b7                      	ror r27
002316 95b7                      	ror r27
002317 91a0 2800                 	lds r26, pulse1_param //load r26 with pulse1_param (register $4000)
002319 2fca                      	mov r28, r26 //store a copy of pulse1_param into r28
00231a 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
00231b 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
00231c c001                      	rjmp sound_driver_instrument_routine_channel0_duty_load_store
00231d c005                      	rjmp sound_driver_channel0_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel0_duty_load_store:
00231e 90a4                      	lpm pulse1_sequence, Z //store the sequence
                                 
00231f 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
002320 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
002321 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_routines:
                                 sound_driver_channel0_fx_1xx_routine:
002323 91e0 2847                 	lds ZL, pulse1_fx_1xx
002325 91f0 2848                 	lds ZH, pulse1_fx_1xx+1
002327 9630                      	adiw Z, 0
002328 f051                      	breq sound_driver_channel0_fx_2xx_routine
                                 
002329 91a0 2849                 	lds r26, pulse1_fx_1xx_total //load the rate to change the pitch by
00232b 91b0 284a                 	lds r27, pulse1_fx_1xx_total+1
00232d 0fae                      	add r26, ZL //increase the total offset by the rate
00232e 1fbf                      	adc r27, ZH
00232f 93a0 2849                 	sts pulse1_fx_1xx_total, r26
002331 93b0 284a                 	sts pulse1_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_2xx_routine:
002333 91e0 284b                 	lds ZL, pulse1_fx_2xx
002335 91f0 284c                 	lds ZH, pulse1_fx_2xx+1
002337 9630                      	adiw Z, 0
002338 f051                      	breq sound_driver_channel0_fx_3xx_routine
                                 
002339 91a0 284d                 	lds r26, pulse1_fx_2xx_total //load the rate to change the pitch by
00233b 91b0 284e                 	lds r27, pulse1_fx_2xx_total+1
00233d 0fae                      	add r26, ZL //increase the total offset by the rate
00233e 1fbf                      	adc r27, ZH
00233f 93a0 284d                 	sts pulse1_fx_2xx_total, r26
002341 93b0 284e                 	sts pulse1_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_3xx_routine:
002343 91e0 2853                 	lds ZL, pulse1_fx_3xx_speed
002345 91f0 2854                 	lds ZH, pulse1_fx_3xx_speed+1
002347 9630                      	adiw Z, 0
002348 f409                      	brne sound_driver_channel0_fx_3xx_routine_check_start
002349 c048                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_check_start:
00234a 91a0 284f                 	lds r26, pulse1_fx_3xx_start
00234c 91b0 2850                 	lds r27, pulse1_fx_3xx_start+1
00234e 9610                      	adiw r26:r27, 0
00234f f409                      	brne sound_driver_channel0_fx_3xx_routine_main
002350 c041                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_main:
002351 91c0 2851                 	lds r28, pulse1_fx_3xx_target
002353 91d0 2852                 	lds r29, pulse1_fx_3xx_target+1
                                 
002355 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
002356 07bd                      	cpc r27, r29
002357 f011                      	breq sound_driver_channel0_fx_3xx_routine_disable
002358 f030                      	brlo sound_driver_channel0_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002359 c01f                      	rjmp sound_driver_channel0_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel0_fx_3xx_routine_disable:
00235a 9220 284f                 	sts pulse1_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
00235c 9220 2850                 	sts pulse1_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
00235e c033                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_subtract:
00235f 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002360 0bdb                      	sbc r29, r27
002361 91a0 2855                 	lds r26, pulse1_fx_3xx_total_offset
002363 91b0 2856                 	lds r27, pulse1_fx_3xx_total_offset+1
                                 
002365 0fae                      	add r26, ZL //add the speed to the total offset
002366 1fbf                      	adc r27, ZH
002367 1bca                      	sub r28, r26 //invert the total difference with the total offset
002368 0bdb                      	sbc r29, r27
002369 f380                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
00236a 93a0 2855                 	sts pulse1_fx_3xx_total_offset, r26 //store the new total offset
00236c 93b0 2856                 	sts pulse1_fx_3xx_total_offset+1, r27
                                 
00236e 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the current timer period
002370 91b0 0a8d                 	lds r27, TCB0_CCMPH
002372 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002373 0bbd                      	sbc r27, r29
002374 93a0 0a8c                 	sts TCB0_CCMPL, r26
002376 93b0 0a8d                 	sts TCB0_CCMPH, r27
002378 c019                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_add:
002379 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
00237a 0bbd                      	sbc r27, r29
00237b 91c0 2855                 	lds r28, pulse1_fx_3xx_total_offset
00237d 91d0 2856                 	lds r29, pulse1_fx_3xx_total_offset+1
                                 
00237f 0fce                      	add r28, ZL //add the speed to the total offset
002380 1fdf                      	adc r29, ZH
002381 1bac                      	sub r26, r28 //invert the total difference with the total offset
002382 0bbd                      	sbc r27, r29
002383 f2b0                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002384 93c0 2855                 	sts pulse1_fx_3xx_total_offset, r28 //store the new total offset
002386 93d0 2856                 	sts pulse1_fx_3xx_total_offset+1, r29
                                 
002388 91c0 0a8c                 	lds r28, TCB0_CCMPL //load the current timer period
00238a 91d0 0a8d                 	lds r29, TCB0_CCMPH
00238c 0fca                      	add r28, r26 //offset the current timer period with the total offset
00238d 1fdb                      	adc r29, r27
00238e 93c0 0a8c                 	sts TCB0_CCMPL, r28
002390 93d0 0a8d                 	sts TCB0_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel0_fx_4xy_routine:
002392 91a0 2857                 	lds r26, pulse1_fx_4xy_speed
002394 15a2                      	cp r26, zero
002395 f409                      	brne sound_driver_channel0_fx_4xy_routine_continue
002396 c05c                      	rjmp sound_driver_channel0_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel0_fx_4xy_routine_continue:
002397 91b0 2858                 	lds r27, pulse1_fx_4xy_depth
002399 91c0 2859                 	lds r28, pulse1_fx_4xy_phase
00239b 0fca                      	add r28, r26 //increase the phase by the speed
00239c 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
00239d f008                      	brlo sound_driver_channel0_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
00239e e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase:
00239f 93c0 2859                 	sts pulse1_fx_4xy_phase, r28 //store the new phase
0023a1 31c0                      	cpi r28, 16
0023a2 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_0
0023a3 32c0                      	cpi r28, 32
0023a4 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_1
0023a5 33c0                      	cpi r28, 48
0023a6 f030                      	brlo sound_driver_channel0_fx_4xy_routine_phase_2
0023a7 c007                      	rjmp sound_driver_channel0_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_0:
0023a8 70cf                      	andi r28, 0x0F //mask for values 0-15
0023a9 c029                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_1:
0023aa 6fc0                      	ori r28, 0xF0
0023ab 95c0                      	com r28 //invert values 0-15
0023ac c026                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_2:
0023ad 70cf                      	andi r28, 0x0F //mask for values 0-15
0023ae c003                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_3:
0023af 6fc0                      	ori r28, 0xF0
0023b0 95c0                      	com r28 //invert values 0-15
0023b1 c000                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_add:
0023b2 95b2                      	swap r27 //multiply depth by 16
0023b3 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0023b4 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0023b5 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0023b6 0fec                      	add ZL, r28 //offset the table by the depth+phase
0023b7 1df2                      	adc ZH, zero
0023b8 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
0023b9 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0023ba 937f                      	push r23
0023bb 2f6c                      	mov r22, r28 //store the vibrato value into r22
0023bc eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0023bd 9f67                      	mul r22, r23
0023be 917f                      	pop r23
0023bf 916f                      	pop r22
                                 
0023c0 9416                      	lsr r1 //shift out the fractional bits
0023c1 9407                      	ror r0
0023c2 9416                      	lsr r1
0023c3 9407                      	ror r0
0023c4 9416                      	lsr r1
0023c5 9407                      	ror r0
0023c6 9416                      	lsr r1
0023c7 9407                      	ror r0
                                 	
0023c8 91a0 0a8c                 	lds r26, TCB0_CCMPL
0023ca 91b0 0a8d                 	lds r27, TCB0_CCMPH
0023cc 0da0                      	add r26, r0
0023cd 1db1                      	adc r27, r1
0023ce 93a0 0a8c                 	sts TCB0_CCMPL, r26
0023d0 93b0 0a8d                 	sts TCB0_CCMPH, r27
0023d2 c020                      	rjmp sound_driver_channel0_fx_7xy_routine
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_subtract:
0023d3 95b2                      	swap r27 //multiply depth by 16
0023d4 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
0023d5 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0023d6 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0023d7 0fec                      	add ZL, r28 //offset the table by the depth+phase
0023d8 1df2                      	adc ZH, zero
0023d9 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
0023da 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0023db 937f                      	push r23
0023dc 2f6c                      	mov r22, r28 //store the vibrato value into r22
0023dd eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0023de 9f67                      	mul r22, r23
0023df 917f                      	pop r23
0023e0 916f                      	pop r22
                                 
0023e1 9416                      	lsr r1 //shift out the fractional bits
0023e2 9407                      	ror r0
0023e3 9416                      	lsr r1
0023e4 9407                      	ror r0
0023e5 9416                      	lsr r1
0023e6 9407                      	ror r0
0023e7 9416                      	lsr r1
0023e8 9407                      	ror r0
                                 
0023e9 91a0 0a8c                 	lds r26, TCB0_CCMPL
0023eb 91b0 0a8d                 	lds r27, TCB0_CCMPH
0023ed 19a0                      	sub r26, r0
0023ee 09b1                      	sbc r27, r1
0023ef 93a0 0a8c                 	sts TCB0_CCMPL, r26
0023f1 93b0 0a8d                 	sts TCB0_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_7xy_routine:
0023f3 91a0 285a                 	lds r26, pulse1_fx_7xy_speed
0023f5 15a2                      	cp r26, zero
0023f6 f0e9                      	breq sound_driver_channel0_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
0023f7 91b0 285b                 	lds r27, pulse1_fx_7xy_depth
0023f9 91c0 285c                 	lds r28, pulse1_fx_7xy_phase
0023fb 0fca                      	add r28, r26 //increase the phase by the speed
0023fc 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
0023fd f008                      	brlo sound_driver_channel0_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
0023fe e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase:
0023ff 93c0 285c                 	sts pulse1_fx_7xy_phase, r28 //store the new phase
002401 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
002402 ffc4                      	sbrs r28, 4
002403 c001                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_0
002404 c002                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel0_fx_7xy_routine_phase_0:
002405 70cf                      	andi r28, 0x0F //mask for values 0-15
002406 c003                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase_1:
002407 6fc0                      	ori r28, 0xF0
002408 95c0                      	com r28 //invert values 0-15
002409 c000                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_load:
00240a 95b2                      	swap r27 //multiply depth by 16
00240b 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
00240c e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00240d e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00240e 0fec                      	add ZL, r28 //offset the table by the depth+phase
00240f 1df2                      	adc ZH, zero
002410 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002411 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
002412 93c0 285d                 	sts pulse1_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Axy_routine:
002414 91b0 285e                 	lds r27, pulse1_fx_Axy
002416 15b2                      	cp r27, zero
002417 f0e9                      	breq sound_driver_channel0_fx_Qxy_routine //0 means that the effect is not in use
                                 	
002418 91a0 2805                 	lds r26, pulse1_fractional_volume //load fractional volume representation of the channel
00241a 91c0 2800                 	lds r28, pulse1_param //load the integer volume representation of the channel
00241c 2fda                      	mov r29, r26 //copy fractional volume into r29
00241d 2fec                      	mov r30, r28 //copy the pulse1_param into r30
00241e 95e2                      	swap r30
00241f 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
002420 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
002421 17ed                      	cp r30, r29 //compare the fractional and integer volumes
002422 f009                      	breq sound_driver_channel0_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel0_fx_Axy_routine_reload:
002423 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate:
002424 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
002425 c004                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_addition:
002426 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002427 f428                      	brcc sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002428 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
002429 c003                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_subtraction:
00242a 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
00242b f008                      	brcs sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
00242c e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_store:
00242d 93a0 2805                 	sts pulse1_fractional_volume, r26 //store the new fractional volume
00242f 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
002430 95a2                      	swap r26
002431 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
002432 2bca                      	or r28, r26 //store the new volume back into pulse1_param
002433 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel0_fx_Qxy_routine:
002435 91e0 2864                 	lds ZL, pulse1_fx_Qxy_target
002437 91f0 2865                 	lds ZH, pulse1_fx_Qxy_target+1
002439 9630                      	adiw Z, 0
00243a f119                      	breq sound_driver_channel0_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
00243b 91a0 2868                 	lds r26, pulse1_fx_Qxy_total_offset
00243d 91b0 2869                 	lds r27, pulse1_fx_Qxy_total_offset+1
00243f 91c0 0a8c                 	lds r28, TCB0_CCMPL
002441 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
002443 1bec                      	sub ZL, r28 //calculate the difference to the target
002444 0bfd                      	sbc ZH, r29
002445 f408                      	brsh sound_driver_channel0_fx_Qxy_routine_end //if the target has been reached (or passed)
002446 f068                      	brlo sound_driver_channel0_fx_Qxy_routine_add
                                 
                                 sound_driver_channel0_fx_Qxy_routine_end:
002447 9220 2868                 	sts pulse1_fx_Qxy_total_offset, zero //turn off the effect
002449 9220 2869                 	sts pulse1_fx_Qxy_total_offset+1, zero
00244b 9220 2864                 	sts pulse1_fx_Qxy_target, zero
00244d 9220 2865                 	sts pulse1_fx_Qxy_target+1, zero
00244f 91b0 2863                 	lds r27, pulse1_fx_Qxy_target_note
002451 93b0 2807                 	sts pulse1_note, r27 //replace the note with the final target note
002453 c00a                      	rjmp sound_driver_channel0_fx_Rxy_routine
                                 
                                 sound_driver_channel0_fx_Qxy_routine_add:
002454 91c0 2866                 	lds r28, pulse1_fx_Qxy_speed
002456 91d0 2867                 	lds r29, pulse1_fx_Qxy_speed+1
002458 0fac                      	add r26, r28 //increase the total offset by the speed
002459 1fbd                      	adc r27, r29
00245a 93a0 2868                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
00245c 93b0 2869                 	sts pulse1_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Rxy_routine:
00245e 91e0 286b                 	lds ZL, pulse1_fx_Rxy_target
002460 91f0 286c                 	lds ZH, pulse1_fx_Rxy_target+1
002462 9630                      	adiw Z, 0
002463 f119                      	breq sound_driver_instrument_routine_channel1_volume //if the effect is not enabled, skip the routine
                                 
002464 91a0 286f                 	lds r26, pulse1_fx_Rxy_total_offset
002466 91b0 2870                 	lds r27, pulse1_fx_Rxy_total_offset+1
002468 91c0 0a8c                 	lds r28, TCB0_CCMPL
00246a 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
00246c 1bce                      	sub r28, ZL //calculate the difference to the target
00246d 0bdf                      	sbc r29, ZH
00246e f408                      	brsh sound_driver_channel0_fx_Rxy_routine_end //if the target has been reached (or passed)
00246f f068                      	brlo sound_driver_channel0_fx_Rxy_routine_add
                                 
                                 sound_driver_channel0_fx_Rxy_routine_end:
002470 9220 286f                 	sts pulse1_fx_Rxy_total_offset, zero //disable the effect
002472 9220 2870                 	sts pulse1_fx_Rxy_total_offset+1, zero
002474 9220 286b                 	sts pulse1_fx_Rxy_target, zero
002476 9220 286c                 	sts pulse1_fx_Rxy_target+1, zero
002478 91b0 286a                 	lds r27, pulse1_fx_Rxy_target_note
00247a 93b0 2807                 	sts pulse1_note, r27 //replace the note with the final target note
00247c c00a                      	rjmp sound_driver_instrument_routine_channel1_volume
                                 
                                 sound_driver_channel0_fx_Rxy_routine_add:
00247d 91c0 286d                 	lds r28, pulse1_fx_Rxy_speed
00247f 91d0 286e                 	lds r29, pulse1_fx_Rxy_speed+1
002481 0fac                      	add r26, r28 //increase the total offset by the speed
002482 1fbd                      	adc r27, r29
002483 93a0 286f                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
002485 93b0 2870                 	sts pulse1_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume:
002487 91e0 2879                 	lds ZL, pulse2_volume_macro
002489 91f0 287a                 	lds ZH, pulse2_volume_macro+1
00248b 9630                      	adiw Z, 0
00248c f1a1                      	breq sound_driver_instrument_routine_channel1_volume_default //if no volume macro is in use, use default multiplier of F
00248d 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
00248e 1fff                      	rol ZH
00248f 91a0 287b                 	lds r26, pulse2_volume_macro_offset
002491 0fea                      	add ZL, r26
002492 1df2                      	adc ZH, zero
                                 
002493 91b0 287d                 	lds r27, pulse2_volume_macro_release
002495 17ba                      	cp r27, r26
002496 f429                      	brne sound_driver_instrument_routine_channel1_volume_increment //if the current offset is not equal to the release index, increment the offset
002497 91a0 287c                 	lds r26, pulse2_volume_macro_loop
002499 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00249a f010                      	brlo sound_driver_instrument_routine_channel1_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00249b c003                      	rjmp sound_driver_instrument_routine_channel1_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_volume_increment:
00249c 95a3                      	inc r26 //increment the macro offset
00249d 93a0 287b                 	sts pulse2_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_volume_read:
00249f 91b4                      	lpm r27, Z //load volume data into r27
0024a0 3fbf                      	cpi r27, 0xFF //check for macro end flag
0024a1 f469                      	brne sound_driver_instrument_routine_channel1_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_release:
0024a2 91b0 287d                 	lds r27, pulse2_volume_macro_release
0024a4 3fbf                      	cpi r27, 0xFF
0024a5 f429                      	brne sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_loop:
0024a6 91b0 287c                 	lds r27, pulse2_volume_macro_loop //load the loop index
0024a8 93b0 287b                 	sts pulse2_volume_macro_offset, r27 //store the loop index into the offset
0024aa cfdc                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index:
0024ab 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
0024ac 93a0 287b                 	sts pulse2_volume_macro_offset, r26
0024ae cfd8                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_calculate:
0024af ecea                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
0024b0 e5fc                      	ldi ZH, HIGH(volumes << 1)
0024b1 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
0024b2 0feb                      	add ZL, r27 //add offset to the table
0024b3 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel1_volume_load:
0024b4 91b0 2808                 	lds r27, pulse2_param //load main volume
0024b6 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
0024b7 91a0 28ae                 	lds r26, pulse2_fx_7xy_value
0024b9 30a0                      	cpi r26, 0x00
0024ba f481                      	brne sound_driver_instrument_routine_channel1_volume_load_7xy
                                 
0024bb 0feb                      	add ZL, r27 //offset the volume table by the main volume
0024bc 1df2                      	adc ZH, zero
0024bd 91b4                      	lpm r27, Z
0024be 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
0024c0 c023                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default:
0024c1 91b0 2808                 	lds r27, pulse2_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
0024c3 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
0024c4 91a0 28ae                 	lds r26, pulse2_fx_7xy_value
0024c6 30a0                      	cpi r26, 0x00
0024c7 f499                      	brne sound_driver_instrument_routine_channel1_volume_default_7xy
0024c8 93b0 280e                 	sts pulse2_output_volume, r27
0024ca c019                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy:
0024cb 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
0024cc f038                      	brcs sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
0024cd f031                      	breq sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
                                 
0024ce 0feb                      	add ZL, r27 //offset the volume table by the main volume
0024cf 1df2                      	adc ZH, zero
0024d0 91b4                      	lpm r27, Z
0024d1 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
0024d3 c010                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy_overflow:
0024d4 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
0024d5 0feb                      	add ZL, r27 //offset the volume table by the main volume
0024d6 1df2                      	adc ZH, zero
0024d7 91b4                      	lpm r27, Z
0024d8 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
0024da c009                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default_7xy:
0024db 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
0024dc f020                      	brcs sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
0024dd f019                      	breq sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
0024de 93b0 280e                 	sts pulse2_output_volume, r27
0024e0 c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel1_volume_default_7xy_overflow:
0024e1 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
0024e2 93b0 280e                 	sts pulse2_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
0024e4 91e0 287e                 	lds ZL, pulse2_arpeggio_macro
0024e6 91f0 287f                 	lds ZH, pulse2_arpeggio_macro+1
0024e8 9630                      	adiw Z, 0
0024e9 f1d9                      	breq sound_driver_instrument_routine_channel1_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
0024ea 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0024eb 1fff                      	rol ZH
0024ec 91a0 2880                 	lds r26, pulse2_arpeggio_macro_offset
0024ee 0fea                      	add ZL, r26
0024ef 1df2                      	adc ZH, zero
                                 
0024f0 91b0 2882                 	lds r27, pulse2_arpeggio_macro_release
0024f2 17ba                      	cp r27, r26
0024f3 f429                      	brne sound_driver_instrument_routine_channel1_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
0024f4 91a0 2881                 	lds r26, pulse2_arpeggio_macro_loop
0024f6 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0024f7 f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
0024f8 c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_increment:
0024f9 95a3                      	inc r26 //increment the macro offset
0024fa 93a0 2880                 	sts pulse2_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_read:
0024fc 91b4                      	lpm r27, Z //load arpeggio data into r27
0024fd 38b0                      	cpi r27, 0x80 //check for macro end flag
0024fe f009                      	breq sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag
0024ff c041                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_check_mode:
002500 50a1                      	subi r26, 1 //keep the offset at the end flag
002501 93a0 2880                 	sts pulse2_arpeggio_macro_offset, r26
002503 91b0 2883                 	lds r27, pulse2_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002505 30b1                      	cpi r27, 0x01
002506 f048                      	brlo sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_release:
002507 91b0 2882                 	lds r27, pulse2_arpeggio_macro_release
002509 3fbf                      	cpi r27, 0xFF
00250a f4d1                      	brne sound_driver_instrument_routine_channel1_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_loop:
00250b 91b0 2881                 	lds r27, pulse2_arpeggio_macro_loop
00250d 3fbf                      	cpi r27, 0xFF
00250e f499                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
00250f c015                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute:
002510 91b0 2882                 	lds r27, pulse2_arpeggio_macro_release
002512 3fbf                      	cpi r27, 0xFF
002513 f421                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_check_loop:
002514 91b0 2881                 	lds r27, pulse2_arpeggio_macro_loop //load the loop index
002516 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002517 f451                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop:
002518 91c0 2896                 	lds r28, pulse2_fx_0xy_sequence //check for 0xy effect
00251a 91d0 2897                 	lds r29, pulse2_fx_0xy_sequence+1
00251c 9620                      	adiw r29:r28, 0
00251d f469                      	brne sound_driver_instrument_routine_channel1_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
00251e 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
00251f 93a0 2880                 	sts pulse2_arpeggio_macro_offset, r26 //store the last valid index into the offset
002521 cfc2                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload:
002522 93b0 2880                 	sts pulse2_arpeggio_macro_offset, r27 //store the loop index into the offset
002524 cfbf                      	rjmp sound_driver_instrument_routine_channel1_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_default:
002525 91c0 2896                 	lds r28, pulse2_fx_0xy_sequence //load 0xy effect
002527 91d0 2897                 	lds r29, pulse2_fx_0xy_sequence+1
002529 9620                      	adiw r29:r28, 0 //check for 0xy effect
00252a f099                      	breq sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel1_arpeggio_default_0xy:
00252b 95d6                      	lsr r29
00252c 95c7                      	ror r28
00252d 95d7                      	ror r29
00252e 95c7                      	ror r28
00252f 95d7                      	ror r29
002530 95c7                      	ror r28
002531 95d7                      	ror r29
002532 95c7                      	ror r28
002533 95d7                      	ror r29
002534 95d2                      	swap r29
                                 
002535 93c0 2896                 	sts pulse2_fx_0xy_sequence, r28 //store the rolled sequence
002537 93d0 2897                 	sts pulse2_fx_0xy_sequence+1, r29
002539 70cf                      	andi r28, 0x0F //mask out the 4 LSB
00253a 91a0 280f                 	lds r26, pulse2_note //load the current note index
00253c 0fac                      	add r26, r28 //add the note offset
00253d c02e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
00253e 91a0 280f                 	lds r26, pulse2_note //load the current note index
002540 c02b                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process:
002541 9220 2884                 	sts pulse2_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002543 9220 2885                 	sts pulse2_total_pitch_offset+1, zero
002545 9220 288b                 	sts pulse2_total_hi_pitch_offset, zero
002547 91a0 2883                 	lds r26, pulse2_arpeggio_macro_mode
002549 30a1                      	cpi r26, 0x01 //absolute mode
00254a f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_absolute
00254b f069                      	breq sound_driver_instrument_routine_channel1_arpeggio_process_fixed
00254c c00e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute:
00254d 91a0 280f                 	lds r26, pulse2_note //load the current note index
00254f 0fab                      	add r26, r27 //offset the note with the arpeggio data
002550 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002551 c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_add:
002552 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002553 f0c0                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
002554 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002555 c016                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract:
002556 fda7                      	sbrc r26, 7 //check if result is negative
002557 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002558 c013                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_fixed:
002559 2fab                      	mov r26, r27 //move the arpeggio data into r26
00255a c011                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative:
00255b 91a0 280f                 	lds r26, pulse2_note //load the current note index
00255d 0fab                      	add r26, r27 //offset the note with the arpeggio data
00255e fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
00255f c008                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_add:
002560 93a0 280f                 	sts pulse2_note, r26 //NOTE: relative mode modifies the original note index
002562 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002563 f040                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
002564 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002565 93a0 280f                 	sts pulse2_note, r26
002567 c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract:
002568 fda7                      	sbrc r26, 7 //check if result is negative
002569 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
00256a 93a0 280f                 	sts pulse2_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_load:
00256c e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
00256d e0f0                      	ldi ZH, HIGH(note_table << 1)
00256e 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
00256f 0fea                      	add ZL, r26 //add offset
002570 1df2                      	adc ZH, zero
002571 91a5                      	lpm r26, Z+ //load bytes
002572 91b4                      	lpm r27, Z
002573 93a0 0a9c                 	sts TCB1_CCMPL, r26 //load the LOW bits for timer
002575 93b0 0a9d                 	sts TCB1_CCMPH, r27 //load the HIGH bits for timer
002577 93a0 28a2                 	sts pulse2_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002579 93b0 28a3                 	sts pulse2_fx_3xx_target+1, r27
00257b c000                      	rjmp sound_driver_instrument_routine_channel1_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch:
00257c 91e0 2886                 	lds ZL, pulse2_pitch_macro
00257e 91f0 2887                 	lds ZH, pulse2_pitch_macro+1
002580 9630                      	adiw Z, 0
002581 f409                      	brne sound_driver_instrument_routine_channel1_pitch_continue
002582 c023                      	rjmp sound_driver_instrument_routine_channel1_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel1_pitch_continue:
002583 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002584 1fff                      	rol ZH
002585 91a0 2888                 	lds r26, pulse2_pitch_macro_offset
002587 0fea                      	add ZL, r26
002588 1df2                      	adc ZH, zero
                                 
002589 91b0 288a                 	lds r27, pulse2_pitch_macro_release
00258b 17ba                      	cp r27, r26
00258c f429                      	brne sound_driver_instrument_routine_channel1_pitch_increment //if the current offset is not equal to the release index, increment the offset
00258d 91a0 2889                 	lds r26, pulse2_pitch_macro_loop
00258f 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002590 f010                      	brlo sound_driver_instrument_routine_channel1_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002591 c003                      	rjmp sound_driver_instrument_routine_channel1_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_pitch_increment:
002592 95a3                      	inc r26 //increment the macro offset
002593 93a0 2888                 	sts pulse2_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_pitch_read:
002595 91b4                      	lpm r27, Z //load pitch data into r27
002596 38b0                      	cpi r27, 0x80 //check for macro end flag
002597 f479                      	brne sound_driver_instrument_routine_channel1_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_release:
002598 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002599 93a0 2888                 	sts pulse2_pitch_macro_offset, r26
00259b 91b0 288a                 	lds r27, pulse2_pitch_macro_release
00259d 3fbf                      	cpi r27, 0xFF
00259e f439                      	brne sound_driver_instrument_routine_channel1_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_loop:
00259f 91b0 2889                 	lds r27, pulse2_pitch_macro_loop //load the loop index
0025a1 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0025a2 f019                      	breq sound_driver_instrument_routine_channel1_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
0025a3 93b0 2888                 	sts pulse2_pitch_macro_offset, r27 //store the loop index into the offset
0025a5 cfd6                      	rjmp sound_driver_instrument_routine_channel1_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_default:
0025a6 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel1_pitch_calculate:
0025a7 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0025a8 937f                      	push r23
0025a9 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
0025aa eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0025ab 0367                      	mulsu r22, r23
0025ac 917f                      	pop r23
0025ad 916f                      	pop r22
                                 
0025ae 9416                      	lsr r1 //shift out the fractional bits
0025af 9407                      	ror r0
0025b0 9416                      	lsr r1
0025b1 9407                      	ror r0
0025b2 9416                      	lsr r1
0025b3 9407                      	ror r0
0025b4 9416                      	lsr r1
0025b5 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_check_negative:
0025b6 fe13                      	sbrs r1, 3 //check if result was a negative number
0025b7 c007                      	rjmp sound_driver_instrument_routine_channel1_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_negative:
0025b8 efc0                      	ldi r28, 0xF0
0025b9 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_check_divisible_8:
0025ba 70b7                      	andi r27, 0b00000111
0025bb f019                      	breq sound_driver_instrument_routine_channel1_pitch_calculate_offset
                                 
0025bc e0b1                      	ldi r27, 0x01
0025bd 0e0b                      	add r0, r27
0025be 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_offset:
0025bf 91a0 2884                 	lds r26, pulse2_total_pitch_offset
0025c1 91b0 2885                 	lds r27, pulse2_total_pitch_offset+1
0025c3 0e0a                      	add r0, r26
0025c4 1e1b                      	adc r1, r27
0025c5 9200 2884                 	sts pulse2_total_pitch_offset, r0
0025c7 9210 2885                 	sts pulse2_total_pitch_offset+1, r1
0025c9 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
0025cb 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
0025cd 0da0                      	add r26, r0 //offset the timer values
0025ce 1db1                      	adc r27, r1
                                 	
0025cf 91c0 289a                 	lds r28, pulse2_fx_1xx_total
0025d1 91d0 289b                 	lds r29, pulse2_fx_1xx_total+1
0025d3 1bac                      	sub r26, r28
0025d4 0bbd                      	sbc r27, r29
0025d5 91c0 289e                 	lds r28, pulse2_fx_2xx_total
0025d7 91d0 289f                 	lds r29, pulse2_fx_2xx_total+1
0025d9 0fac                      	add r26, r28
0025da 1fbd                      	adc r27, r29
0025db 91c0 28b2                 	lds r28, pulse2_fx_Pxx_total
0025dd 91d0 28b3                 	lds r29, pulse2_fx_Pxx_total+1
0025df 0fac                      	add r26, r28
0025e0 1fbd                      	adc r27, r29
0025e1 91c0 28b9                 	lds r28, pulse2_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
0025e3 91d0 28ba                 	lds r29, pulse2_fx_Qxy_total_offset+1
0025e5 1bac                      	sub r26, r28
0025e6 0bbd                      	sbc r27, r29
0025e7 91c0 28c0                 	lds r28, pulse2_fx_Rxy_total_offset
0025e9 91d0 28c1                 	lds r29, pulse2_fx_Rxy_total_offset+1
0025eb 0fac                      	add r26, r28
0025ec 1fbd                      	adc r27, r29
                                 
0025ed e5c9                      	ldi r28, 0x59
0025ee e0d0                      	ldi r29, 0x00
0025ef 17ac                      	cp r26, r28
0025f0 07bd                      	cpc r27, r29
0025f1 f030                      	brlo sound_driver_instrument_routine_channel1_pitch_min
                                 
0025f2 e5ca                      	ldi r28, 0x5A
0025f3 e5d9                      	ldi r29, 0x59
0025f4 17ac                      	cp r26, r28
0025f5 07bd                      	cpc r27, r29
0025f6 f420                      	brsh sound_driver_instrument_routine_channel1_pitch_max
0025f7 c006                      	rjmp sound_driver_instrument_routine_channel1_pitch_store
                                 
                                 sound_driver_instrument_routine_channel1_pitch_min:
0025f8 e5c9                      	ldi r28, 0x59
0025f9 e0d0                      	ldi r29, 0x00
0025fa c003                      	rjmp sound_driver_instrument_routine_channel1_pitch_store
                                 
                                 sound_driver_instrument_routine_channel1_pitch_max:
0025fb e5c9                      	ldi r28, 0x59
0025fc e5d9                      	ldi r29, 0x59
0025fd c000                      	rjmp sound_driver_instrument_routine_channel1_pitch_store
                                 
                                 sound_driver_instrument_routine_channel1_pitch_store:
0025fe 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
002600 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel1_hi_pitch:
002602 91e0 288c                 	lds ZL, pulse2_hi_pitch_macro
002604 91f0 288d                 	lds ZH, pulse2_hi_pitch_macro+1
002606 9630                      	adiw Z, 0
002607 f409                      	brne sound_driver_instrument_routine_channel1_hi_pitch_continue
002608 c03c                      	rjmp sound_driver_instrument_routine_channel1_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel1_hi_pitch_continue:
002609 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00260a 1fff                      	rol ZH
00260b 91a0 288e                 	lds r26, pulse2_hi_pitch_macro_offset
00260d 0fea                      	add ZL, r26
00260e 1df2                      	adc ZH, zero
                                 
00260f 91b0 2890                 	lds r27, pulse2_hi_pitch_macro_release
002611 17ba                      	cp r27, r26
002612 f429                      	brne sound_driver_instrument_routine_channel1_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002613 91a0 288f                 	lds r26, pulse2_hi_pitch_macro_loop
002615 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002616 f010                      	brlo sound_driver_instrument_routine_channel1_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002617 c003                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_increment:
002618 95a3                      	inc r26 //increment the macro offset
002619 93a0 288e                 	sts pulse2_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_hi_pitch_read:
00261b 91b4                      	lpm r27, Z //load hi pitch data into r27
00261c 38b0                      	cpi r27, 0x80 //check for macro end flag
00261d f489                      	brne sound_driver_instrument_routine_channel1_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_release:
00261e 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00261f 93a0 288e                 	sts pulse2_hi_pitch_macro_offset, r26
002621 91b0 2890                 	lds r27, pulse2_hi_pitch_macro_release
002623 3fbf                      	cpi r27, 0xFF
002624 f439                      	brne sound_driver_instrument_routine_channel1_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_loop:
002625 91b0 288f                 	lds r27, pulse2_hi_pitch_macro_loop //load the loop index
002627 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002628 f019                      	breq sound_driver_instrument_routine_channel1_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002629 93b0 288e                 	sts pulse2_hi_pitch_macro_offset, r27 //store the loop index into the offset
00262b cfd6                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_default:
00262c 91b0 288b                 	lds r27, pulse2_total_hi_pitch_offset
00262e c005                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate:
00262f 91a0 288b                 	lds r26, pulse2_total_hi_pitch_offset //load the total hi pitch offset to change
002631 0fba                      	add r27, r26
002632 93b0 288b                 	sts pulse2_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply:
002634 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002635 937f                      	push r23
002636 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002637 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002638 0367                      	mulsu r22, r23
002639 917f                      	pop r23
00263a 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_offset:
00263b 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
00263d 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
00263f 0da0                      	add r26, r0 //offset the timer values
002640 1db1                      	adc r27, r1
002641 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
002643 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel1_duty:
002645 91e0 2891                 	lds ZL, pulse2_duty_macro
002647 91f0 2892                 	lds ZH, pulse2_duty_macro+1
002649 9630                      	adiw Z, 0
00264a f1b1                      	breq sound_driver_channel1_fx_routines //if no duty macro is in use, go to the next routine
00264b 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00264c 1fff                      	rol ZH
00264d 91a0 2893                 	lds r26, pulse2_duty_macro_offset
00264f 0fea                      	add ZL, r26
002650 1df2                      	adc ZH, zero
                                 
002651 91b0 2895                 	lds r27, pulse2_duty_macro_release
002653 17ba                      	cp r27, r26
002654 f429                      	brne sound_driver_instrument_routine_channel1_duty_increment //if the current offset is not equal to the release index, increment the offset
002655 91a0 2894                 	lds r26, pulse2_duty_macro_loop
002657 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002658 f010                      	brlo sound_driver_instrument_routine_channel1_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002659 c027                      	rjmp sound_driver_channel1_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel1_duty_increment:
00265a 95a3                      	inc r26 //increment the macro offset
00265b 93a0 2893                 	sts pulse2_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_duty_read:
00265d 91b4                      	lpm r27, Z //load pitch data into r27
00265e 3fbf                      	cpi r27, 0xFF //check for macro end flag
00265f f471                      	brne sound_driver_instrument_routine_channel1_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_release:
002660 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002661 93a0 2893                 	sts pulse2_duty_macro_offset, r26
002663 91b0 2895                 	lds r27, pulse2_duty_macro_release
002665 3fbf                      	cpi r27, 0xFF
002666 f4d1                      	brne sound_driver_channel1_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_loop:
002667 91b0 2894                 	lds r27, pulse2_duty_macro_loop //load the loop index
002669 3fbf                      	cpi r27, 0xFF //check if there is a loop index
00266a f0b1                      	breq sound_driver_channel1_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
00266b 93b0 2893                 	sts pulse2_duty_macro_offset, r27 //store the loop index into the offset
00266d cfd7                      	rjmp sound_driver_instrument_routine_channel1_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_load:
00266e efe6                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
00266f e5fb                      	ldi ZH, HIGH(sequences << 1)
002670 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
002671 1df2                      	adc ZH, zero
                                 
002672 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
002673 95b7                      	ror r27
002674 95b7                      	ror r27
002675 91a0 2808                 	lds r26, pulse2_param //load r26 with pulse2_param (register $4000)
002677 2fca                      	mov r28, r26 //store a copy of pulse2_param into r28
002678 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
002679 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
00267a c001                      	rjmp sound_driver_instrument_routine_channel1_duty_load_store
00267b c005                      	rjmp sound_driver_channel1_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel1_duty_load_store:
00267c 90d4                      	lpm pulse2_sequence, Z //store the sequence
                                 
00267d 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
00267e 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
00267f 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_routines:
                                 sound_driver_channel1_fx_1xx_routine:
002681 91e0 2898                 	lds ZL, pulse2_fx_1xx
002683 91f0 2899                 	lds ZH, pulse2_fx_1xx+1
002685 9630                      	adiw Z, 0
002686 f051                      	breq sound_driver_channel1_fx_2xx_routine
                                 
002687 91a0 289a                 	lds r26, pulse2_fx_1xx_total //load the rate to change the pitch by
002689 91b0 289b                 	lds r27, pulse2_fx_1xx_total+1
00268b 0fae                      	add r26, ZL //increase the total offset by the rate
00268c 1fbf                      	adc r27, ZH
00268d 93a0 289a                 	sts pulse2_fx_1xx_total, r26
00268f 93b0 289b                 	sts pulse2_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_2xx_routine:
002691 91e0 289c                 	lds ZL, pulse2_fx_2xx
002693 91f0 289d                 	lds ZH, pulse2_fx_2xx+1
002695 9630                      	adiw Z, 0
002696 f051                      	breq sound_driver_channel1_fx_3xx_routine
                                 
002697 91a0 289e                 	lds r26, pulse2_fx_2xx_total //load the rate to change the pitch by
002699 91b0 289f                 	lds r27, pulse2_fx_2xx_total+1
00269b 0fae                      	add r26, ZL //increase the total offset by the rate
00269c 1fbf                      	adc r27, ZH
00269d 93a0 289e                 	sts pulse2_fx_2xx_total, r26
00269f 93b0 289f                 	sts pulse2_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_3xx_routine:
0026a1 91e0 28a4                 	lds ZL, pulse2_fx_3xx_speed
0026a3 91f0 28a5                 	lds ZH, pulse2_fx_3xx_speed+1
0026a5 9630                      	adiw Z, 0
0026a6 f409                      	brne sound_driver_channel1_fx_3xx_routine_check_start
0026a7 c048                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_check_start:
0026a8 91a0 28a0                 	lds r26, pulse2_fx_3xx_start
0026aa 91b0 28a1                 	lds r27, pulse2_fx_3xx_start+1
0026ac 9610                      	adiw r26:r27, 0
0026ad f409                      	brne sound_driver_channel1_fx_3xx_routine_main
0026ae c041                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_main:
0026af 91c0 28a2                 	lds r28, pulse2_fx_3xx_target
0026b1 91d0 28a3                 	lds r29, pulse2_fx_3xx_target+1
                                 
0026b3 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
0026b4 07bd                      	cpc r27, r29
0026b5 f011                      	breq sound_driver_channel1_fx_3xx_routine_disable
0026b6 f030                      	brlo sound_driver_channel1_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
0026b7 c01f                      	rjmp sound_driver_channel1_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel1_fx_3xx_routine_disable:
0026b8 9220 28a0                 	sts pulse2_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
0026ba 9220 28a1                 	sts pulse2_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
0026bc c033                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_subtract:
0026bd 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
0026be 0bdb                      	sbc r29, r27
0026bf 91a0 28a6                 	lds r26, pulse2_fx_3xx_total_offset
0026c1 91b0 28a7                 	lds r27, pulse2_fx_3xx_total_offset+1
                                 
0026c3 0fae                      	add r26, ZL //add the speed to the total offset
0026c4 1fbf                      	adc r27, ZH
0026c5 1bca                      	sub r28, r26 //invert the total difference with the total offset
0026c6 0bdb                      	sbc r29, r27
0026c7 f380                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0026c8 93a0 28a6                 	sts pulse2_fx_3xx_total_offset, r26 //store the new total offset
0026ca 93b0 28a7                 	sts pulse2_fx_3xx_total_offset+1, r27
                                 
0026cc 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the current timer period
0026ce 91b0 0a9d                 	lds r27, TCB1_CCMPH
0026d0 1bac                      	sub r26, r28 //offset the current timer period with the total offset
0026d1 0bbd                      	sbc r27, r29
0026d2 93a0 0a9c                 	sts TCB1_CCMPL, r26
0026d4 93b0 0a9d                 	sts TCB1_CCMPH, r27
0026d6 c019                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_add:
0026d7 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
0026d8 0bbd                      	sbc r27, r29
0026d9 91c0 28a6                 	lds r28, pulse2_fx_3xx_total_offset
0026db 91d0 28a7                 	lds r29, pulse2_fx_3xx_total_offset+1
                                 
0026dd 0fce                      	add r28, ZL //add the speed to the total offset
0026de 1fdf                      	adc r29, ZH
0026df 1bac                      	sub r26, r28 //invert the total difference with the total offset
0026e0 0bbd                      	sbc r27, r29
0026e1 f2b0                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0026e2 93c0 28a6                 	sts pulse2_fx_3xx_total_offset, r28 //store the new total offset
0026e4 93d0 28a7                 	sts pulse2_fx_3xx_total_offset+1, r29
                                 
0026e6 91c0 0a9c                 	lds r28, TCB1_CCMPL //load the current timer period
0026e8 91d0 0a9d                 	lds r29, TCB1_CCMPH
0026ea 0fca                      	add r28, r26 //offset the current timer period with the total offset
0026eb 1fdb                      	adc r29, r27
0026ec 93c0 0a9c                 	sts TCB1_CCMPL, r28
0026ee 93d0 0a9d                 	sts TCB1_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel1_fx_4xy_routine:
0026f0 91a0 28a8                 	lds r26, pulse2_fx_4xy_speed
0026f2 15a2                      	cp r26, zero
0026f3 f409                      	brne sound_driver_channel1_fx_4xy_routine_continue
0026f4 c05c                      	rjmp sound_driver_channel1_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel1_fx_4xy_routine_continue:
0026f5 91b0 28a9                 	lds r27, pulse2_fx_4xy_depth
0026f7 91c0 28aa                 	lds r28, pulse2_fx_4xy_phase
0026f9 0fca                      	add r28, r26 //increase the phase by the speed
0026fa 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
0026fb f008                      	brlo sound_driver_channel1_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
0026fc e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase:
0026fd 93c0 28aa                 	sts pulse2_fx_4xy_phase, r28 //store the new phase
0026ff 31c0                      	cpi r28, 16
002700 f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_0
002701 32c0                      	cpi r28, 32
002702 f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_1
002703 33c0                      	cpi r28, 48
002704 f030                      	brlo sound_driver_channel1_fx_4xy_routine_phase_2
002705 c007                      	rjmp sound_driver_channel1_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_0:
002706 70cf                      	andi r28, 0x0F //mask for values 0-15
002707 c029                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_1:
002708 6fc0                      	ori r28, 0xF0
002709 95c0                      	com r28 //invert values 0-15
00270a c026                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_2:
00270b 70cf                      	andi r28, 0x0F //mask for values 0-15
00270c c003                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_3:
00270d 6fc0                      	ori r28, 0xF0
00270e 95c0                      	com r28 //invert values 0-15
00270f c000                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_add:
002710 95b2                      	swap r27 //multiply depth by 16
002711 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002712 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002713 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002714 0fec                      	add ZL, r28 //offset the table by the depth+phase
002715 1df2                      	adc ZH, zero
002716 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002717 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002718 937f                      	push r23
002719 2f6c                      	mov r22, r28 //store the vibrato value into r22
00271a eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00271b 9f67                      	mul r22, r23
00271c 917f                      	pop r23
00271d 916f                      	pop r22
                                 
00271e 9416                      	lsr r1 //shift out the fractional bits
00271f 9407                      	ror r0
002720 9416                      	lsr r1
002721 9407                      	ror r0
002722 9416                      	lsr r1
002723 9407                      	ror r0
002724 9416                      	lsr r1
002725 9407                      	ror r0
                                 	
002726 91a0 0a9c                 	lds r26, TCB1_CCMPL
002728 91b0 0a9d                 	lds r27, TCB1_CCMPH
00272a 0da0                      	add r26, r0
00272b 1db1                      	adc r27, r1
00272c 93a0 0a9c                 	sts TCB1_CCMPL, r26
00272e 93b0 0a9d                 	sts TCB1_CCMPH, r27
002730 c020                      	rjmp sound_driver_channel1_fx_7xy_routine
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_subtract:
002731 95b2                      	swap r27 //multiply depth by 16
002732 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002733 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002734 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002735 0fec                      	add ZL, r28 //offset the table by the depth+phase
002736 1df2                      	adc ZH, zero
002737 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002738 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002739 937f                      	push r23
00273a 2f6c                      	mov r22, r28 //store the vibrato value into r22
00273b eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00273c 9f67                      	mul r22, r23
00273d 917f                      	pop r23
00273e 916f                      	pop r22
                                 
00273f 9416                      	lsr r1 //shift out the fractional bits
002740 9407                      	ror r0
002741 9416                      	lsr r1
002742 9407                      	ror r0
002743 9416                      	lsr r1
002744 9407                      	ror r0
002745 9416                      	lsr r1
002746 9407                      	ror r0
                                 
002747 91a0 0a9c                 	lds r26, TCB1_CCMPL
002749 91b0 0a9d                 	lds r27, TCB1_CCMPH
00274b 19a0                      	sub r26, r0
00274c 09b1                      	sbc r27, r1
00274d 93a0 0a9c                 	sts TCB1_CCMPL, r26
00274f 93b0 0a9d                 	sts TCB1_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_7xy_routine:
002751 91a0 28ab                 	lds r26, pulse2_fx_7xy_speed
002753 15a2                      	cp r26, zero
002754 f0e9                      	breq sound_driver_channel1_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
002755 91b0 28ac                 	lds r27, pulse2_fx_7xy_depth
002757 91c0 28ad                 	lds r28, pulse2_fx_7xy_phase
002759 0fca                      	add r28, r26 //increase the phase by the speed
00275a 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
00275b f008                      	brlo sound_driver_channel1_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
00275c e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase:
00275d 93c0 28ad                 	sts pulse2_fx_7xy_phase, r28 //store the new phase
00275f 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
002760 ffc4                      	sbrs r28, 4
002761 c001                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_0
002762 c002                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel1_fx_7xy_routine_phase_0:
002763 70cf                      	andi r28, 0x0F //mask for values 0-15
002764 c003                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase_1:
002765 6fc0                      	ori r28, 0xF0
002766 95c0                      	com r28 //invert values 0-15
002767 c000                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_load:
002768 95b2                      	swap r27 //multiply depth by 16
002769 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
00276a e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00276b e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00276c 0fec                      	add ZL, r28 //offset the table by the depth+phase
00276d 1df2                      	adc ZH, zero
00276e 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
00276f 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
002770 93c0 28ae                 	sts pulse2_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Axy_routine:
002772 91b0 28af                 	lds r27, pulse2_fx_Axy
002774 15b2                      	cp r27, zero
002775 f0e9                      	breq sound_driver_channel1_fx_Qxy_routine //0 means that the effect is not in use
                                 	
002776 91a0 280d                 	lds r26, pulse2_fractional_volume //load fractional volume representation of the channel
002778 91c0 2808                 	lds r28, pulse2_param //load the integer volume representation of the channel
00277a 2fda                      	mov r29, r26 //copy fractional volume into r29
00277b 2fec                      	mov r30, r28 //copy the pulse2_param into r30
00277c 95e2                      	swap r30
00277d 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
00277e 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
00277f 17ed                      	cp r30, r29 //compare the fractional and integer volumes
002780 f009                      	breq sound_driver_channel1_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel1_fx_Axy_routine_reload:
002781 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate:
002782 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
002783 c004                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_addition:
002784 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002785 f428                      	brcc sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002786 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
002787 c003                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_subtraction:
002788 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002789 f008                      	brcs sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
00278a e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_store:
00278b 93a0 280d                 	sts pulse2_fractional_volume, r26 //store the new fractional volume
00278d 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
00278e 95a2                      	swap r26
00278f 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
002790 2bca                      	or r28, r26 //store the new volume back into pulse2_param
002791 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel1_fx_Qxy_routine:
002793 91e0 28b5                 	lds ZL, pulse2_fx_Qxy_target
002795 91f0 28b6                 	lds ZH, pulse2_fx_Qxy_target+1
002797 9630                      	adiw Z, 0
002798 f119                      	breq sound_driver_channel1_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002799 91a0 28b9                 	lds r26, pulse2_fx_Qxy_total_offset
00279b 91b0 28ba                 	lds r27, pulse2_fx_Qxy_total_offset+1
00279d 91c0 0a9c                 	lds r28, TCB1_CCMPL
00279f 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
0027a1 1bec                      	sub ZL, r28 //calculate the difference to the target
0027a2 0bfd                      	sbc ZH, r29
0027a3 f408                      	brsh sound_driver_channel1_fx_Qxy_routine_end //if the target has been reached (or passed)
0027a4 f068                      	brlo sound_driver_channel1_fx_Qxy_routine_add
                                 
                                 sound_driver_channel1_fx_Qxy_routine_end:
0027a5 9220 28b9                 	sts pulse2_fx_Qxy_total_offset, zero //turn off the effect
0027a7 9220 28ba                 	sts pulse2_fx_Qxy_total_offset+1, zero
0027a9 9220 28b5                 	sts pulse2_fx_Qxy_target, zero
0027ab 9220 28b6                 	sts pulse2_fx_Qxy_target+1, zero
0027ad 91b0 28b4                 	lds r27, pulse2_fx_Qxy_target_note
0027af 93b0 280f                 	sts pulse2_note, r27 //replace the note with the final target note
0027b1 c00a                      	rjmp sound_driver_channel1_fx_Rxy_routine
                                 
                                 sound_driver_channel1_fx_Qxy_routine_add:
0027b2 91c0 28b7                 	lds r28, pulse2_fx_Qxy_speed
0027b4 91d0 28b8                 	lds r29, pulse2_fx_Qxy_speed+1
0027b6 0fac                      	add r26, r28 //increase the total offset by the speed
0027b7 1fbd                      	adc r27, r29
0027b8 93a0 28b9                 	sts pulse2_fx_Qxy_total_offset, r26 //store the total offset
0027ba 93b0 28ba                 	sts pulse2_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Rxy_routine:
0027bc 91e0 28bc                 	lds ZL, pulse2_fx_Rxy_target
0027be 91f0 28bd                 	lds ZH, pulse2_fx_Rxy_target+1
0027c0 9630                      	adiw Z, 0
0027c1 f119                      	breq sound_driver_instrument_routine_channel2_volume //if the effect is not enabled, skip the routine
                                 
0027c2 91a0 28c0                 	lds r26, pulse2_fx_Rxy_total_offset
0027c4 91b0 28c1                 	lds r27, pulse2_fx_Rxy_total_offset+1
0027c6 91c0 0a9c                 	lds r28, TCB1_CCMPL
0027c8 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
0027ca 1bce                      	sub r28, ZL //calculate the difference to the target
0027cb 0bdf                      	sbc r29, ZH
0027cc f408                      	brsh sound_driver_channel1_fx_Rxy_routine_end //if the target has been reached (or passed)
0027cd f068                      	brlo sound_driver_channel1_fx_Rxy_routine_add
                                 
                                 sound_driver_channel1_fx_Rxy_routine_end:
0027ce 9220 28c0                 	sts pulse2_fx_Rxy_total_offset, zero //disable the effect
0027d0 9220 28c1                 	sts pulse2_fx_Rxy_total_offset+1, zero
0027d2 9220 28bc                 	sts pulse2_fx_Rxy_target, zero
0027d4 9220 28bd                 	sts pulse2_fx_Rxy_target+1, zero
0027d6 91b0 28bb                 	lds r27, pulse2_fx_Rxy_target_note
0027d8 93b0 280f                 	sts pulse2_note, r27 //replace the note with the final target note
0027da c00a                      	rjmp sound_driver_instrument_routine_channel2_volume
                                 
                                 sound_driver_channel1_fx_Rxy_routine_add:
0027db 91c0 28be                 	lds r28, pulse2_fx_Rxy_speed
0027dd 91d0 28bf                 	lds r29, pulse2_fx_Rxy_speed+1
0027df 0fac                      	add r26, r28 //increase the total offset by the speed
0027e0 1fbd                      	adc r27, r29
0027e1 93a0 28c0                 	sts pulse2_fx_Rxy_total_offset, r26 //store the total offset
0027e3 93b0 28c1                 	sts pulse2_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume:
0027e5 91e0 28ca                 	lds ZL, triangle_volume_macro
0027e7 91f0 28cb                 	lds ZH, triangle_volume_macro+1
0027e9 9630                      	adiw Z, 0
0027ea f199                      	breq sound_driver_instrument_routine_channel2_volume_default //if no volume macro is in use, do nothing
0027eb 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0027ec 1fff                      	rol ZH
0027ed 91a0 28cc                 	lds r26, triangle_volume_macro_offset
0027ef 0fea                      	add ZL, r26
0027f0 1df2                      	adc ZH, zero
                                 
0027f1 91b0 28ce                 	lds r27, triangle_volume_macro_release
0027f3 17ba                      	cp r27, r26
0027f4 f429                      	brne sound_driver_instrument_routine_channel2_volume_increment //if the current offset is not equal to the release index, increment the offset
0027f5 91a0 28cd                 	lds r26, triangle_volume_macro_loop
0027f7 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0027f8 f010                      	brlo sound_driver_instrument_routine_channel2_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0027f9 c003                      	rjmp sound_driver_instrument_routine_channel2_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_volume_increment:
0027fa 95a3                      	inc r26 //increment the macro offset
0027fb 93a0 28cc                 	sts triangle_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_volume_read:
0027fd 91b4                      	lpm r27, Z //load volume data into r27
0027fe 3fbf                      	cpi r27, 0xFF //check for macro end flag
0027ff f469                      	brne sound_driver_instrument_routine_channel2_volume_process //if the data was not the macro end flag
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_release:
002800 91b0 28ce                 	lds r27, triangle_volume_macro_release
002802 3fbf                      	cpi r27, 0xFF
002803 f429                      	brne sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_loop:
002804 91b0 28cd                 	lds r27, triangle_volume_macro_loop //load the loop index
002806 93b0 28cc                 	sts triangle_volume_macro_offset, r27 //store the loop index into the offset
002808 cfdc                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index:
002809 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
00280a 93a0 28cc                 	sts triangle_volume_macro_offset, r26
00280c cfd8                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_process:
00280d 15b2                      	cp r27, zero
00280e f041                      	breq sound_driver_instrument_routine_channel2_volume_process_disable
                                 sound_driver_instrument_routine_channel2_volume_process_enable:
00280f 91b0 0aa5                 	lds r27, TCB2_INTCTRL
002811 30b1                      	cpi r27, TCB_CAPT_bm
002812 f459                      	brne sound_driver_instrument_routine_channel2_volume_default //if the channel has already been muted, don't enable it again
002813 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
002814 93b0 0aa5                 	sts TCB2_INTCTRL, r27
002816 c007                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 sound_driver_instrument_routine_channel2_volume_process_disable:
002817 9220 0aa5                 	sts TCB2_INTCTRL, zero
002819 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
00281b 9220 0aad                 	sts TCB2_CCMPH, zero
00281d c000                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_volume_default:
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
00281e 91e0 28cf                 	lds ZL, triangle_arpeggio_macro
002820 91f0 28d0                 	lds ZH, triangle_arpeggio_macro+1
002822 9630                      	adiw Z, 0
002823 f1d9                      	breq sound_driver_instrument_routine_channel2_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002824 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002825 1fff                      	rol ZH
002826 91a0 28d1                 	lds r26, triangle_arpeggio_macro_offset
002828 0fea                      	add ZL, r26
002829 1df2                      	adc ZH, zero
                                 
00282a 91b0 28d3                 	lds r27, triangle_arpeggio_macro_release
00282c 17ba                      	cp r27, r26
00282d f429                      	brne sound_driver_instrument_routine_channel2_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
00282e 91a0 28d2                 	lds r26, triangle_arpeggio_macro_loop
002830 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002831 f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002832 c003                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_increment:
002833 95a3                      	inc r26 //increment the macro offset
002834 93a0 28d1                 	sts triangle_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_read:
002836 91b4                      	lpm r27, Z //load arpeggio data into r27
002837 38b0                      	cpi r27, 0x80 //check for macro end flag
002838 f009                      	breq sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag
002839 c041                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_check_mode:
00283a 50a1                      	subi r26, 1 //keep the offset at the end flag
00283b 93a0 28d1                 	sts triangle_arpeggio_macro_offset, r26
00283d 91b0 28d4                 	lds r27, triangle_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
00283f 30b1                      	cpi r27, 0x01
002840 f048                      	brlo sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_release:
002841 91b0 28d3                 	lds r27, triangle_arpeggio_macro_release
002843 3fbf                      	cpi r27, 0xFF
002844 f4d1                      	brne sound_driver_instrument_routine_channel2_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_loop:
002845 91b0 28d2                 	lds r27, triangle_arpeggio_macro_loop
002847 3fbf                      	cpi r27, 0xFF
002848 f499                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002849 c015                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute:
00284a 91b0 28d3                 	lds r27, triangle_arpeggio_macro_release
00284c 3fbf                      	cpi r27, 0xFF
00284d f421                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_check_loop:
00284e 91b0 28d2                 	lds r27, triangle_arpeggio_macro_loop //load the loop index
002850 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002851 f451                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop:
002852 91c0 28e7                 	lds r28, triangle_fx_0xy_sequence //check for 0xy effect
002854 91d0 28e8                 	lds r29, triangle_fx_0xy_sequence+1
002856 9620                      	adiw r29:r28, 0
002857 f469                      	brne sound_driver_instrument_routine_channel2_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002858 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002859 93a0 28d1                 	sts triangle_arpeggio_macro_offset, r26 //store the last valid index into the offset
00285b cfc2                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload:
00285c 93b0 28d1                 	sts triangle_arpeggio_macro_offset, r27 //store the loop index into the offset
00285e cfbf                      	rjmp sound_driver_instrument_routine_channel2_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_default:
00285f 91c0 28e7                 	lds r28, triangle_fx_0xy_sequence //load 0xy effect
002861 91d0 28e8                 	lds r29, triangle_fx_0xy_sequence+1
002863 9620                      	adiw r29:r28, 0 //check for 0xy effect
002864 f099                      	breq sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel2_arpeggio_default_0xy:
002865 95d6                      	lsr r29
002866 95c7                      	ror r28
002867 95d7                      	ror r29
002868 95c7                      	ror r28
002869 95d7                      	ror r29
00286a 95c7                      	ror r28
00286b 95d7                      	ror r29
00286c 95c7                      	ror r28
00286d 95d7                      	ror r29
00286e 95d2                      	swap r29
                                 
00286f 93c0 28e7                 	sts triangle_fx_0xy_sequence, r28 //store the rolled sequence
002871 93d0 28e8                 	sts triangle_fx_0xy_sequence+1, r29
002873 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002874 91a0 2812                 	lds r26, triangle_note //load the current note index
002876 0fac                      	add r26, r28 //add the note offset
002877 c02e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002878 91a0 2812                 	lds r26, triangle_note //load the current note index
00287a c02b                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process:
00287b 9220 28d5                 	sts triangle_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
00287d 9220 28d6                 	sts triangle_total_pitch_offset+1, zero
00287f 9220 28dc                 	sts triangle_total_hi_pitch_offset, zero
002881 91a0 28d4                 	lds r26, triangle_arpeggio_macro_mode
002883 30a1                      	cpi r26, 0x01 //absolute mode
002884 f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_absolute
002885 f069                      	breq sound_driver_instrument_routine_channel2_arpeggio_process_fixed
002886 c00e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute:
002887 91a0 2812                 	lds r26, triangle_note //load the current note index
002889 0fab                      	add r26, r27 //offset the note with the arpeggio data
00288a fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
00288b c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_add:
00288c 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
00288d f0c0                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
00288e e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
00288f c016                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract:
002890 fda7                      	sbrc r26, 7 //check if result is negative
002891 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002892 c013                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_fixed:
002893 2fab                      	mov r26, r27 //move the arpeggio data into r26
002894 c011                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative:
002895 91a0 2812                 	lds r26, triangle_note //load the current note index
002897 0fab                      	add r26, r27 //offset the note with the arpeggio data
002898 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002899 c008                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_add:
00289a 93a0 2812                 	sts triangle_note, r26 //NOTE: relative mode modifies the original note index
00289c 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
00289d f040                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
00289e e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
00289f 93a0 2812                 	sts triangle_note, r26
0028a1 c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract:
0028a2 fda7                      	sbrc r26, 7 //check if result is negative
0028a3 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0028a4 93a0 2812                 	sts triangle_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_load:
0028a6 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0028a7 e0f0                      	ldi ZH, HIGH(note_table << 1)
0028a8 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
0028a9 0fea                      	add ZL, r26 //add offset
0028aa 1df2                      	adc ZH, zero
0028ab 91a5                      	lpm r26, Z+ //load bytes
0028ac 91b4                      	lpm r27, Z
0028ad 93a0 0aac                 	sts TCB2_CCMPL, r26 //load the LOW bits for timer
0028af 93b0 0aad                 	sts TCB2_CCMPH, r27 //load the HIGH bits for timer
0028b1 93a0 28f3                 	sts triangle_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
0028b3 93b0 28f4                 	sts triangle_fx_3xx_target+1, r27
0028b5 c000                      	rjmp sound_driver_instrument_routine_channel2_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch:
0028b6 91e0 28d7                 	lds ZL, triangle_pitch_macro
0028b8 91f0 28d8                 	lds ZH, triangle_pitch_macro+1
0028ba 9630                      	adiw Z, 0
0028bb f409                      	brne sound_driver_instrument_routine_channel2_pitch_continue
0028bc c023                      	rjmp sound_driver_instrument_routine_channel2_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel2_pitch_continue:
0028bd 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0028be 1fff                      	rol ZH
0028bf 91a0 28d9                 	lds r26, triangle_pitch_macro_offset
0028c1 0fea                      	add ZL, r26
0028c2 1df2                      	adc ZH, zero
                                 
0028c3 91b0 28db                 	lds r27, triangle_pitch_macro_release
0028c5 17ba                      	cp r27, r26
0028c6 f429                      	brne sound_driver_instrument_routine_channel2_pitch_increment //if the current offset is not equal to the release index, increment the offset
0028c7 91a0 28da                 	lds r26, triangle_pitch_macro_loop
0028c9 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0028ca f010                      	brlo sound_driver_instrument_routine_channel2_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0028cb c003                      	rjmp sound_driver_instrument_routine_channel2_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_pitch_increment:
0028cc 95a3                      	inc r26 //increment the macro offset
0028cd 93a0 28d9                 	sts triangle_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_pitch_read:
0028cf 91b4                      	lpm r27, Z //load pitch data into r27
0028d0 38b0                      	cpi r27, 0x80 //check for macro end flag
0028d1 f479                      	brne sound_driver_instrument_routine_channel2_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_release:
0028d2 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0028d3 93a0 28d9                 	sts triangle_pitch_macro_offset, r26
0028d5 91b0 28db                 	lds r27, triangle_pitch_macro_release
0028d7 3fbf                      	cpi r27, 0xFF
0028d8 f439                      	brne sound_driver_instrument_routine_channel2_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_loop:
0028d9 91b0 28da                 	lds r27, triangle_pitch_macro_loop //load the loop index
0028db 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0028dc f019                      	breq sound_driver_instrument_routine_channel2_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
0028dd 93b0 28d9                 	sts triangle_pitch_macro_offset, r27 //store the loop index into the offset
0028df cfd6                      	rjmp sound_driver_instrument_routine_channel2_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_default:
0028e0 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel2_pitch_calculate:
0028e1 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0028e2 937f                      	push r23
0028e3 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
0028e4 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0028e5 0367                      	mulsu r22, r23
0028e6 917f                      	pop r23
0028e7 916f                      	pop r22
                                 
0028e8 9416                      	lsr r1 //shift out the fractional bits
0028e9 9407                      	ror r0
0028ea 9416                      	lsr r1
0028eb 9407                      	ror r0
0028ec 9416                      	lsr r1
0028ed 9407                      	ror r0
0028ee 9416                      	lsr r1
0028ef 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_check_negative:
0028f0 fe13                      	sbrs r1, 3 //check if result was a negative number
0028f1 c007                      	rjmp sound_driver_instrument_routine_channel2_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_negative:
0028f2 efc0                      	ldi r28, 0xF0
0028f3 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_check_divisible_8:
0028f4 70b7                      	andi r27, 0b00000111
0028f5 f019                      	breq sound_driver_instrument_routine_channel2_pitch_calculate_offset
                                 
0028f6 e0b1                      	ldi r27, 0x01
0028f7 0e0b                      	add r0, r27
0028f8 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_offset:
0028f9 91a0 28d5                 	lds r26, triangle_total_pitch_offset
0028fb 91b0 28d6                 	lds r27, triangle_total_pitch_offset+1
0028fd 0e0a                      	add r0, r26
0028fe 1e1b                      	adc r1, r27
0028ff 9200 28d5                 	sts triangle_total_pitch_offset, r0
002901 9210 28d6                 	sts triangle_total_pitch_offset+1, r1
002903 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
002905 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
002907 0da0                      	add r26, r0 //offset the timer values
002908 1db1                      	adc r27, r1
                                 	
002909 91c0 28eb                 	lds r28, triangle_fx_1xx_total
00290b 91d0 28ec                 	lds r29, triangle_fx_1xx_total+1
00290d 1bac                      	sub r26, r28
00290e 0bbd                      	sbc r27, r29
00290f 91c0 28ef                 	lds r28, triangle_fx_2xx_total
002911 91d0 28f0                 	lds r29, triangle_fx_2xx_total+1
002913 0fac                      	add r26, r28
002914 1fbd                      	adc r27, r29
002915 91c0 28fe                 	lds r28, triangle_fx_Pxx_total
002917 91d0 28ff                 	lds r29, triangle_fx_Pxx_total+1
002919 0fac                      	add r26, r28
00291a 1fbd                      	adc r27, r29
00291b 91c0 2905                 	lds r28, triangle_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
00291d 91d0 2906                 	lds r29, triangle_fx_Qxy_total_offset+1
00291f 1bac                      	sub r26, r28
002920 0bbd                      	sbc r27, r29
002921 91c0 290c                 	lds r28, triangle_fx_Rxy_total_offset
002923 91d0 290d                 	lds r29, triangle_fx_Rxy_total_offset+1
002925 0fac                      	add r26, r28
002926 1fbd                      	adc r27, r29
                                 
002927 e5c9                      	ldi r28, 0x59
002928 e0d0                      	ldi r29, 0x00
002929 17ac                      	cp r26, r28
00292a 07bd                      	cpc r27, r29
00292b f030                      	brlo sound_driver_instrument_routine_channel2_pitch_min
                                 
00292c e5ca                      	ldi r28, 0x5A
00292d e5d9                      	ldi r29, 0x59
00292e 17ac                      	cp r26, r28
00292f 07bd                      	cpc r27, r29
002930 f420                      	brsh sound_driver_instrument_routine_channel2_pitch_max
002931 c006                      	rjmp sound_driver_instrument_routine_channel2_pitch_store
                                 
                                 sound_driver_instrument_routine_channel2_pitch_min:
002932 e5c9                      	ldi r28, 0x59
002933 e0d0                      	ldi r29, 0x00
002934 c003                      	rjmp sound_driver_instrument_routine_channel2_pitch_store
                                 
                                 sound_driver_instrument_routine_channel2_pitch_max:
002935 e5c9                      	ldi r28, 0x59
002936 e5d9                      	ldi r29, 0x59
002937 c000                      	rjmp sound_driver_instrument_routine_channel2_pitch_store
                                 
                                 sound_driver_instrument_routine_channel2_pitch_store:
002938 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
00293a 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel2_hi_pitch:
00293c 91e0 28dd                 	lds ZL, triangle_hi_pitch_macro
00293e 91f0 28de                 	lds ZH, triangle_hi_pitch_macro+1
002940 9630                      	adiw Z, 0
002941 f409                      	brne sound_driver_instrument_routine_channel2_hi_pitch_continue
002942 c03c                      	rjmp sound_driver_instrument_routine_channel2_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel2_hi_pitch_continue:
002943 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002944 1fff                      	rol ZH
002945 91a0 28df                 	lds r26, triangle_hi_pitch_macro_offset
002947 0fea                      	add ZL, r26
002948 1df2                      	adc ZH, zero
                                 
002949 91b0 28e1                 	lds r27, triangle_hi_pitch_macro_release
00294b 17ba                      	cp r27, r26
00294c f429                      	brne sound_driver_instrument_routine_channel2_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
00294d 91a0 28e0                 	lds r26, triangle_hi_pitch_macro_loop
00294f 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002950 f010                      	brlo sound_driver_instrument_routine_channel2_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002951 c003                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_increment:
002952 95a3                      	inc r26 //increment the macro offset
002953 93a0 28df                 	sts triangle_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_hi_pitch_read:
002955 91b4                      	lpm r27, Z //load hi pitch data into r27
002956 38b0                      	cpi r27, 0x80 //check for macro end flag
002957 f489                      	brne sound_driver_instrument_routine_channel2_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_release:
002958 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002959 93a0 28df                 	sts triangle_hi_pitch_macro_offset, r26
00295b 91b0 28e1                 	lds r27, triangle_hi_pitch_macro_release
00295d 3fbf                      	cpi r27, 0xFF
00295e f439                      	brne sound_driver_instrument_routine_channel2_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_loop:
00295f 91b0 28e0                 	lds r27, triangle_hi_pitch_macro_loop //load the loop index
002961 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002962 f019                      	breq sound_driver_instrument_routine_channel2_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002963 93b0 28df                 	sts triangle_hi_pitch_macro_offset, r27 //store the loop index into the offset
002965 cfd6                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_default:
002966 91b0 28dc                 	lds r27, triangle_total_hi_pitch_offset
002968 c005                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate:
002969 91a0 28dc                 	lds r26, triangle_total_hi_pitch_offset //load the total hi pitch offset to change
00296b 0fba                      	add r27, r26
00296c 93b0 28dc                 	sts triangle_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply:
00296e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00296f 937f                      	push r23
002970 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002971 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002972 0367                      	mulsu r22, r23
002973 917f                      	pop r23
002974 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_offset:
002975 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
002977 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
002979 0da0                      	add r26, r0 //offset the timer values
00297a 1db1                      	adc r27, r1
00297b 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
00297d 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: The triangle channel does not have a duty cycle
                                 sound_driver_instrument_routine_channel2_duty:
                                 
                                 
                                 
                                 sound_driver_channel2_fx_routines:
                                 sound_driver_channel2_fx_1xx_routine:
00297f 91e0 28e9                 	lds ZL, triangle_fx_1xx
002981 91f0 28ea                 	lds ZH, triangle_fx_1xx+1
002983 9630                      	adiw Z, 0
002984 f051                      	breq sound_driver_channel2_fx_2xx_routine
                                 
002985 91a0 28eb                 	lds r26, triangle_fx_1xx_total //load the rate to change the pitch by
002987 91b0 28ec                 	lds r27, triangle_fx_1xx_total+1
002989 0fae                      	add r26, ZL //increase the total offset by the rate
00298a 1fbf                      	adc r27, ZH
00298b 93a0 28eb                 	sts triangle_fx_1xx_total, r26
00298d 93b0 28ec                 	sts triangle_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_2xx_routine:
00298f 91e0 28ed                 	lds ZL, triangle_fx_2xx
002991 91f0 28ee                 	lds ZH, triangle_fx_2xx+1
002993 9630                      	adiw Z, 0
002994 f051                      	breq sound_driver_channel2_fx_3xx_routine
                                 
002995 91a0 28ef                 	lds r26, triangle_fx_2xx_total //load the rate to change the pitch by
002997 91b0 28f0                 	lds r27, triangle_fx_2xx_total+1
002999 0fae                      	add r26, ZL //increase the total offset by the rate
00299a 1fbf                      	adc r27, ZH
00299b 93a0 28ef                 	sts triangle_fx_2xx_total, r26
00299d 93b0 28f0                 	sts triangle_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_3xx_routine:
00299f 91e0 28f5                 	lds ZL, triangle_fx_3xx_speed
0029a1 91f0 28f6                 	lds ZH, triangle_fx_3xx_speed+1
0029a3 9630                      	adiw Z, 0
0029a4 f409                      	brne sound_driver_channel2_fx_3xx_routine_check_start
0029a5 c048                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_check_start:
0029a6 91a0 28f1                 	lds r26, triangle_fx_3xx_start
0029a8 91b0 28f2                 	lds r27, triangle_fx_3xx_start+1
0029aa 9610                      	adiw r26:r27, 0
0029ab f409                      	brne sound_driver_channel2_fx_3xx_routine_main
0029ac c041                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_main:
0029ad 91c0 28f3                 	lds r28, triangle_fx_3xx_target
0029af 91d0 28f4                 	lds r29, triangle_fx_3xx_target+1
                                 
0029b1 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
0029b2 07bd                      	cpc r27, r29
0029b3 f011                      	breq sound_driver_channel2_fx_3xx_routine_disable
0029b4 f030                      	brlo sound_driver_channel2_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
0029b5 c01f                      	rjmp sound_driver_channel2_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel2_fx_3xx_routine_disable:
0029b6 9220 28f1                 	sts triangle_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
0029b8 9220 28f2                 	sts triangle_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
0029ba c033                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_subtract:
0029bb 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
0029bc 0bdb                      	sbc r29, r27
0029bd 91a0 28f7                 	lds r26, triangle_fx_3xx_total_offset
0029bf 91b0 28f8                 	lds r27, triangle_fx_3xx_total_offset+1
                                 
0029c1 0fae                      	add r26, ZL //add the speed to the total offset
0029c2 1fbf                      	adc r27, ZH
0029c3 1bca                      	sub r28, r26 //invert the total difference with the total offset
0029c4 0bdb                      	sbc r29, r27
0029c5 f380                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0029c6 93a0 28f7                 	sts triangle_fx_3xx_total_offset, r26 //store the new total offset
0029c8 93b0 28f8                 	sts triangle_fx_3xx_total_offset+1, r27
                                 
0029ca 91a0 0aac                 	lds r26, TCB2_CCMPL //load the current timer period
0029cc 91b0 0aad                 	lds r27, TCB2_CCMPH
0029ce 1bac                      	sub r26, r28 //offset the current timer period with the total offset
0029cf 0bbd                      	sbc r27, r29
0029d0 93a0 0aac                 	sts TCB2_CCMPL, r26
0029d2 93b0 0aad                 	sts TCB2_CCMPH, r27
0029d4 c019                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_add:
0029d5 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
0029d6 0bbd                      	sbc r27, r29
0029d7 91c0 28f7                 	lds r28, triangle_fx_3xx_total_offset
0029d9 91d0 28f8                 	lds r29, triangle_fx_3xx_total_offset+1
                                 
0029db 0fce                      	add r28, ZL //add the speed to the total offset
0029dc 1fdf                      	adc r29, ZH
0029dd 1bac                      	sub r26, r28 //invert the total difference with the total offset
0029de 0bbd                      	sbc r27, r29
0029df f2b0                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0029e0 93c0 28f7                 	sts triangle_fx_3xx_total_offset, r28 //store the new total offset
0029e2 93d0 28f8                 	sts triangle_fx_3xx_total_offset+1, r29
                                 
0029e4 91c0 0aac                 	lds r28, TCB2_CCMPL //load the current timer period
0029e6 91d0 0aad                 	lds r29, TCB2_CCMPH
0029e8 0fca                      	add r28, r26 //offset the current timer period with the total offset
0029e9 1fdb                      	adc r29, r27
0029ea 93c0 0aac                 	sts TCB2_CCMPL, r28
0029ec 93d0 0aad                 	sts TCB2_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel2_fx_4xy_routine:
0029ee 91a0 28f9                 	lds r26, triangle_fx_4xy_speed
0029f0 15a2                      	cp r26, zero
0029f1 f409                      	brne sound_driver_channel2_fx_4xy_routine_continue
0029f2 c05c                      	rjmp sound_driver_channel2_fx_Qxy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel2_fx_4xy_routine_continue:
0029f3 91b0 28fa                 	lds r27, triangle_fx_4xy_depth
0029f5 91c0 28fb                 	lds r28, triangle_fx_4xy_phase
0029f7 0fca                      	add r28, r26 //increase the phase by the speed
0029f8 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
0029f9 f008                      	brlo sound_driver_channel2_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
0029fa e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase:
0029fb 93c0 28fb                 	sts triangle_fx_4xy_phase, r28 //store the new phase
0029fd 31c0                      	cpi r28, 16
0029fe f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_0
0029ff 32c0                      	cpi r28, 32
002a00 f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_1
002a01 33c0                      	cpi r28, 48
002a02 f030                      	brlo sound_driver_channel2_fx_4xy_routine_phase_2
002a03 c007                      	rjmp sound_driver_channel2_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_0:
002a04 70cf                      	andi r28, 0x0F //mask for values 0-15
002a05 c029                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_1:
002a06 6fc0                      	ori r28, 0xF0
002a07 95c0                      	com r28 //invert values 0-15
002a08 c026                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_2:
002a09 70cf                      	andi r28, 0x0F //mask for values 0-15
002a0a c003                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_3:
002a0b 6fc0                      	ori r28, 0xF0
002a0c 95c0                      	com r28 //invert values 0-15
002a0d c000                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_add:
002a0e 95b2                      	swap r27 //multiply depth by 16
002a0f 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002a10 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002a11 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002a12 0fec                      	add ZL, r28 //offset the table by the depth+phase
002a13 1df2                      	adc ZH, zero
002a14 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002a15 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002a16 937f                      	push r23
002a17 2f6c                      	mov r22, r28 //store the vibrato value into r22
002a18 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002a19 9f67                      	mul r22, r23
002a1a 917f                      	pop r23
002a1b 916f                      	pop r22
                                 
002a1c 9416                      	lsr r1 //shift out the fractional bits
002a1d 9407                      	ror r0
002a1e 9416                      	lsr r1
002a1f 9407                      	ror r0
002a20 9416                      	lsr r1
002a21 9407                      	ror r0
002a22 9416                      	lsr r1
002a23 9407                      	ror r0
                                 	
002a24 91a0 0aac                 	lds r26, TCB2_CCMPL
002a26 91b0 0aad                 	lds r27, TCB2_CCMPH
002a28 0da0                      	add r26, r0
002a29 1db1                      	adc r27, r1
002a2a 93a0 0aac                 	sts TCB2_CCMPL, r26
002a2c 93b0 0aad                 	sts TCB2_CCMPH, r27
002a2e c020                      	rjmp sound_driver_channel2_fx_Qxy_routine
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_subtract:
002a2f 95b2                      	swap r27 //multiply depth by 16
002a30 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002a31 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002a32 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002a33 0fec                      	add ZL, r28 //offset the table by the depth+phase
002a34 1df2                      	adc ZH, zero
002a35 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002a36 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002a37 937f                      	push r23
002a38 2f6c                      	mov r22, r28 //store the vibrato value into r22
002a39 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002a3a 9f67                      	mul r22, r23
002a3b 917f                      	pop r23
002a3c 916f                      	pop r22
                                 
002a3d 9416                      	lsr r1 //shift out the fractional bits
002a3e 9407                      	ror r0
002a3f 9416                      	lsr r1
002a40 9407                      	ror r0
002a41 9416                      	lsr r1
002a42 9407                      	ror r0
002a43 9416                      	lsr r1
002a44 9407                      	ror r0
                                 
002a45 91a0 0aac                 	lds r26, TCB2_CCMPL
002a47 91b0 0aad                 	lds r27, TCB2_CCMPH
002a49 19a0                      	sub r26, r0
002a4a 09b1                      	sbc r27, r1
002a4b 93a0 0aac                 	sts TCB2_CCMPL, r26
002a4d 93b0 0aad                 	sts TCB2_CCMPH, r27
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel2_fx_Qxy_routine:
002a4f 91e0 2901                 	lds ZL, triangle_fx_Qxy_target
002a51 91f0 2902                 	lds ZH, triangle_fx_Qxy_target+1
002a53 9630                      	adiw Z, 0
002a54 f119                      	breq sound_driver_channel2_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002a55 91a0 2905                 	lds r26, triangle_fx_Qxy_total_offset
002a57 91b0 2906                 	lds r27, triangle_fx_Qxy_total_offset+1
002a59 91c0 0aac                 	lds r28, TCB2_CCMPL
002a5b 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
002a5d 1bec                      	sub ZL, r28 //calculate the difference to the target
002a5e 0bfd                      	sbc ZH, r29
002a5f f408                      	brsh sound_driver_channel2_fx_Qxy_routine_end //if the target has been reached (or passed)
002a60 f068                      	brlo sound_driver_channel2_fx_Qxy_routine_add
                                 
                                 sound_driver_channel2_fx_Qxy_routine_end:
002a61 9220 2905                 	sts triangle_fx_Qxy_total_offset, zero //turn off the effect
002a63 9220 2906                 	sts triangle_fx_Qxy_total_offset+1, zero
002a65 9220 2901                 	sts triangle_fx_Qxy_target, zero
002a67 9220 2902                 	sts triangle_fx_Qxy_target+1, zero
002a69 91b0 2900                 	lds r27, triangle_fx_Qxy_target_note
002a6b 93b0 2812                 	sts triangle_note, r27 //replace the note with the final target note
002a6d c00a                      	rjmp sound_driver_channel2_fx_Rxy_routine
                                 
                                 sound_driver_channel2_fx_Qxy_routine_add:
002a6e 91c0 2903                 	lds r28, triangle_fx_Qxy_speed
002a70 91d0 2904                 	lds r29, triangle_fx_Qxy_speed+1
002a72 0fac                      	add r26, r28 //increase the total offset by the speed
002a73 1fbd                      	adc r27, r29
002a74 93a0 2905                 	sts triangle_fx_Qxy_total_offset, r26 //store the total offset
002a76 93b0 2906                 	sts triangle_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_Rxy_routine:
002a78 91e0 2908                 	lds ZL, triangle_fx_Rxy_target
002a7a 91f0 2909                 	lds ZH, triangle_fx_Rxy_target+1
002a7c 9630                      	adiw Z, 0
002a7d f119                      	breq sound_driver_instrument_routine_channel3_volume //if the effect is not enabled, skip the routine
                                 
002a7e 91a0 290c                 	lds r26, triangle_fx_Rxy_total_offset
002a80 91b0 290d                 	lds r27, triangle_fx_Rxy_total_offset+1
002a82 91c0 0aac                 	lds r28, TCB2_CCMPL
002a84 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
002a86 1bce                      	sub r28, ZL //calculate the difference to the target
002a87 0bdf                      	sbc r29, ZH
002a88 f408                      	brsh sound_driver_channel2_fx_Rxy_routine_end //if the target has been reached (or passed)
002a89 f068                      	brlo sound_driver_channel2_fx_Rxy_routine_add
                                 
                                 sound_driver_channel2_fx_Rxy_routine_end:
002a8a 9220 290c                 	sts triangle_fx_Rxy_total_offset, zero //disable the effect
002a8c 9220 290d                 	sts triangle_fx_Rxy_total_offset+1, zero
002a8e 9220 2908                 	sts triangle_fx_Rxy_target, zero
002a90 9220 2909                 	sts triangle_fx_Rxy_target+1, zero
002a92 91b0 2907                 	lds r27, triangle_fx_Rxy_target_note
002a94 93b0 2812                 	sts triangle_note, r27 //replace the note with the final target note
002a96 c00a                      	rjmp sound_driver_instrument_routine_channel3_volume
                                 
                                 sound_driver_channel2_fx_Rxy_routine_add:
002a97 91c0 290a                 	lds r28, triangle_fx_Rxy_speed
002a99 91d0 290b                 	lds r29, triangle_fx_Rxy_speed+1
002a9b 0fac                      	add r26, r28 //increase the total offset by the speed
002a9c 1fbd                      	adc r27, r29
002a9d 93a0 290c                 	sts triangle_fx_Rxy_total_offset, r26 //store the total offset
002a9f 93b0 290d                 	sts triangle_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume:
002aa1 91e0 2916                 	lds ZL, noise_volume_macro
002aa3 91f0 2917                 	lds ZH, noise_volume_macro+1
002aa5 9630                      	adiw Z, 0
002aa6 f1a1                      	breq sound_driver_instrument_routine_channel3_volume_default //if no volume macro is in use, use default multiplier of F
002aa7 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002aa8 1fff                      	rol ZH
002aa9 91a0 2918                 	lds r26, noise_volume_macro_offset
002aab 0fea                      	add ZL, r26
002aac 1df2                      	adc ZH, zero
                                 
002aad 91b0 291a                 	lds r27, noise_volume_macro_release
002aaf 17ba                      	cp r27, r26
002ab0 f429                      	brne sound_driver_instrument_routine_channel3_volume_increment //if the current offset is not equal to the release index, increment the offset
002ab1 91a0 2919                 	lds r26, noise_volume_macro_loop
002ab3 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002ab4 f010                      	brlo sound_driver_instrument_routine_channel3_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002ab5 c003                      	rjmp sound_driver_instrument_routine_channel3_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_volume_increment:
002ab6 95a3                      	inc r26 //increment the macro offset
002ab7 93a0 2918                 	sts noise_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_volume_read:
002ab9 91b4                      	lpm r27, Z //load volume data into r27
002aba 3fbf                      	cpi r27, 0xFF //check for macro end flag
002abb f469                      	brne sound_driver_instrument_routine_channel3_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_check_release:
002abc 91b0 291a                 	lds r27, noise_volume_macro_release
002abe 3fbf                      	cpi r27, 0xFF
002abf f429                      	brne sound_driver_instrument_routine_channel3_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_check_loop:
002ac0 91b0 2919                 	lds r27, noise_volume_macro_loop //load the loop index
002ac2 93b0 2918                 	sts noise_volume_macro_offset, r27 //store the loop index into the offset
002ac4 cfdc                      	rjmp sound_driver_instrument_routine_channel3_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_last_index:
002ac5 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002ac6 93a0 2918                 	sts noise_volume_macro_offset, r26
002ac8 cfd8                      	rjmp sound_driver_instrument_routine_channel3_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume_calculate:
002ac9 ecea                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
002aca e5fc                      	ldi ZH, HIGH(volumes << 1)
002acb 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
002acc 0feb                      	add ZL, r27 //add offset to the table
002acd 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel3_volume_load:
002ace 91b0 2813                 	lds r27, noise_param //load main volume
002ad0 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002ad1 91a0 294b                 	lds r26, noise_fx_7xy_value
002ad3 30a0                      	cpi r26, 0x00
002ad4 f481                      	brne sound_driver_instrument_routine_channel3_volume_load_7xy
                                 
002ad5 0feb                      	add ZL, r27 //offset the volume table by the main volume
002ad6 1df2                      	adc ZH, zero
002ad7 91b4                      	lpm r27, Z
002ad8 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002ada c023                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_default:
002adb 91b0 2813                 	lds r27, noise_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
002add 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002ade 91a0 294b                 	lds r26, noise_fx_7xy_value
002ae0 30a0                      	cpi r26, 0x00
002ae1 f499                      	brne sound_driver_instrument_routine_channel3_volume_default_7xy
002ae2 93b0 2816                 	sts noise_output_volume, r27
002ae4 c019                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_load_7xy:
002ae5 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002ae6 f038                      	brcs sound_driver_instrument_routine_channel3_volume_load_7xy_overflow
002ae7 f031                      	breq sound_driver_instrument_routine_channel3_volume_load_7xy_overflow
                                 
002ae8 0feb                      	add ZL, r27 //offset the volume table by the main volume
002ae9 1df2                      	adc ZH, zero
002aea 91b4                      	lpm r27, Z
002aeb 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002aed c010                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_load_7xy_overflow:
002aee e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002aef 0feb                      	add ZL, r27 //offset the volume table by the main volume
002af0 1df2                      	adc ZH, zero
002af1 91b4                      	lpm r27, Z
002af2 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002af4 c009                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_default_7xy:
002af5 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002af6 f020                      	brcs sound_driver_instrument_routine_channel3_volume_default_7xy_overflow
002af7 f019                      	breq sound_driver_instrument_routine_channel3_volume_default_7xy_overflow
002af8 93b0 2816                 	sts noise_output_volume, r27
002afa c003                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel3_volume_default_7xy_overflow:
002afb e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002afc 93b0 2816                 	sts noise_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002afe 91e0 291b                 	lds ZL, noise_arpeggio_macro
002b00 91f0 291c                 	lds ZH, noise_arpeggio_macro+1
002b02 9630                      	adiw Z, 0
002b03 f1d9                      	breq sound_driver_instrument_routine_channel3_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002b04 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002b05 1fff                      	rol ZH
002b06 91a0 291d                 	lds r26, noise_arpeggio_macro_offset
002b08 0fea                      	add ZL, r26
002b09 1df2                      	adc ZH, zero
                                 
002b0a 91b0 291f                 	lds r27, noise_arpeggio_macro_release
002b0c 17ba                      	cp r27, r26
002b0d f429                      	brne sound_driver_instrument_routine_channel3_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002b0e 91a0 291e                 	lds r26, noise_arpeggio_macro_loop
002b10 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002b11 f010                      	brlo sound_driver_instrument_routine_channel3_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002b12 c003                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_increment:
002b13 95a3                      	inc r26 //increment the macro offset
002b14 93a0 291d                 	sts noise_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_arpeggio_read:
002b16 91b4                      	lpm r27, Z //load arpeggio data into r27
002b17 38b0                      	cpi r27, 0x80 //check for macro end flag
002b18 f009                      	breq sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag
002b19 c041                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_check_mode:
002b1a 50a1                      	subi r26, 1 //keep the offset at the end flag
002b1b 93a0 291d                 	sts noise_arpeggio_macro_offset, r26
002b1d 91b0 2920                 	lds r27, noise_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002b1f 30b1                      	cpi r27, 0x01
002b20 f048                      	brlo sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_fixed_relative_check_release:
002b21 91b0 291f                 	lds r27, noise_arpeggio_macro_release
002b23 3fbf                      	cpi r27, 0xFF
002b24 f4d1                      	brne sound_driver_instrument_routine_channel3_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_fixed_relative_check_loop:
002b25 91b0 291e                 	lds r27, noise_arpeggio_macro_loop
002b27 3fbf                      	cpi r27, 0xFF
002b28 f499                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002b29 c015                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute:
002b2a 91b0 291f                 	lds r27, noise_arpeggio_macro_release
002b2c 3fbf                      	cpi r27, 0xFF
002b2d f421                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_check_loop:
002b2e 91b0 291e                 	lds r27, noise_arpeggio_macro_loop //load the loop index
002b30 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002b31 f451                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_no_loop:
002b32 91c0 2933                 	lds r28, noise_fx_0xy_sequence //check for 0xy effect
002b34 91d0 2934                 	lds r29, noise_fx_0xy_sequence+1
002b36 9620                      	adiw r29:r28, 0
002b37 f469                      	brne sound_driver_instrument_routine_channel3_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002b38 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002b39 93a0 291d                 	sts noise_arpeggio_macro_offset, r26 //store the last valid index into the offset
002b3b cfc2                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload:
002b3c 93b0 291d                 	sts noise_arpeggio_macro_offset, r27 //store the loop index into the offset
002b3e cfbf                      	rjmp sound_driver_instrument_routine_channel3_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_default:
002b3f 91c0 2933                 	lds r28, noise_fx_0xy_sequence //load 0xy effect
002b41 91d0 2934                 	lds r29, noise_fx_0xy_sequence+1
002b43 9620                      	adiw r29:r28, 0 //check for 0xy effect
002b44 f099                      	breq sound_driver_instrument_routine_channel3_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel3_arpeggio_default_0xy:
002b45 95d6                      	lsr r29
002b46 95c7                      	ror r28
002b47 95d7                      	ror r29
002b48 95c7                      	ror r28
002b49 95d7                      	ror r29
002b4a 95c7                      	ror r28
002b4b 95d7                      	ror r29
002b4c 95c7                      	ror r28
002b4d 95d7                      	ror r29
002b4e 95d2                      	swap r29
                                 
002b4f 93c0 2933                 	sts noise_fx_0xy_sequence, r28 //store the rolled sequence
002b51 93d0 2934                 	sts noise_fx_0xy_sequence+1, r29
002b53 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002b54 91a0 2817                 	lds r26, noise_note //load the current note index
002b56 0fac                      	add r26, r28 //add the note offset
002b57 c02e                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel3_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002b58 91a0 2817                 	lds r26, noise_note //load the current note index
002b5a c02b                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process:
002b5b 9220 2921                 	sts noise_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002b5d 9220 2922                 	sts noise_total_pitch_offset+1, zero
002b5f 9220 2928                 	sts noise_total_hi_pitch_offset, zero
002b61 91a0 2920                 	lds r26, noise_arpeggio_macro_mode
002b63 30a1                      	cpi r26, 0x01 //absolute mode
002b64 f010                      	brlo sound_driver_instrument_routine_channel3_arpeggio_process_absolute
002b65 f069                      	breq sound_driver_instrument_routine_channel3_arpeggio_process_fixed
002b66 c00e                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_absolute:
002b67 91a0 2817                 	lds r26, noise_note //load the current note index
002b69 0fab                      	add r26, r27 //offset the note with the arpeggio data
002b6a fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002b6b c004                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_absolute_add:
002b6c 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002b6d f0c0                      	brlo sound_driver_instrument_routine_channel3_arpeggio_process_load //if the result is valid, go load the new note
002b6e e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002b6f c016                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_absolute_subtract:
002b70 fda7                      	sbrc r26, 7 //check if result is negative
002b71 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002b72 c013                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_fixed:
002b73 2fab                      	mov r26, r27 //move the arpeggio data into r26
002b74 c011                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_relative:
002b75 91a0 2817                 	lds r26, noise_note //load the current note index
002b77 0fab                      	add r26, r27 //offset the note with the arpeggio data
002b78 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002b79 c008                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_relative_add:
002b7a 93a0 2817                 	sts noise_note, r26 //NOTE: relative mode modifies the original note index
002b7c 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002b7d f040                      	brlo sound_driver_instrument_routine_channel3_arpeggio_process_load //if the result is valid, go load the new note
002b7e e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002b7f 93a0 2817                 	sts noise_note, r26
002b81 c004                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_relative_subtract:
002b82 fda7                      	sbrc r26, 7 //check if result is negative
002b83 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002b84 93a0 2817                 	sts noise_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_load:
002b86 e4e2                      	ldi ZL, LOW(noise_period_table << 1) //load in note table
002b87 e0f1                      	ldi ZH, HIGH(noise_period_table << 1)
002b88 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002b89 0fea                      	add ZL, r26 //add offset
002b8a 1df2                      	adc ZH, zero
002b8b 91a5                      	lpm r26, Z+ //load bytes
002b8c 91b4                      	lpm r27, Z
002b8d 93a0 0abc                 	sts TCB3_CCMPL, r26 //load the LOW bits for timer
002b8f 93b0 0abd                 	sts TCB3_CCMPH, r27 //load the HIGH bits for timer
002b91 93a0 293f                 	sts noise_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002b93 93b0 2940                 	sts noise_fx_3xx_target+1, r27
002b95 c000                      	rjmp sound_driver_instrument_routine_channel3_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch:
002b96 91e0 2923                 	lds ZL, noise_pitch_macro
002b98 91f0 2924                 	lds ZH, noise_pitch_macro+1
002b9a 9630                      	adiw Z, 0
002b9b f409                      	brne sound_driver_instrument_routine_channel3_pitch_continue
002b9c c023                      	rjmp sound_driver_instrument_routine_channel3_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel3_pitch_continue:
002b9d 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002b9e 1fff                      	rol ZH
002b9f 91a0 2925                 	lds r26, noise_pitch_macro_offset
002ba1 0fea                      	add ZL, r26
002ba2 1df2                      	adc ZH, zero
                                 
002ba3 91b0 2927                 	lds r27, noise_pitch_macro_release
002ba5 17ba                      	cp r27, r26
002ba6 f429                      	brne sound_driver_instrument_routine_channel3_pitch_increment //if the current offset is not equal to the release index, increment the offset
002ba7 91a0 2926                 	lds r26, noise_pitch_macro_loop
002ba9 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002baa f010                      	brlo sound_driver_instrument_routine_channel3_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002bab c003                      	rjmp sound_driver_instrument_routine_channel3_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_pitch_increment:
002bac 95a3                      	inc r26 //increment the macro offset
002bad 93a0 2925                 	sts noise_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_pitch_read:
002baf 91b4                      	lpm r27, Z //load pitch data into r27
002bb0 38b0                      	cpi r27, 0x80 //check for macro end flag
002bb1 f479                      	brne sound_driver_instrument_routine_channel3_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag_check_release:
002bb2 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002bb3 93a0 2925                 	sts noise_pitch_macro_offset, r26
002bb5 91b0 2927                 	lds r27, noise_pitch_macro_release
002bb7 3fbf                      	cpi r27, 0xFF
002bb8 f439                      	brne sound_driver_instrument_routine_channel3_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag_check_loop:
002bb9 91b0 2926                 	lds r27, noise_pitch_macro_loop //load the loop index
002bbb 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002bbc f019                      	breq sound_driver_instrument_routine_channel3_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002bbd 93b0 2925                 	sts noise_pitch_macro_offset, r27 //store the loop index into the offset
002bbf cfd6                      	rjmp sound_driver_instrument_routine_channel3_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch_default:
002bc0 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel3_pitch_calculate:
002bc1 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002bc2 937f                      	push r23
002bc3 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
002bc4 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002bc5 0367                      	mulsu r22, r23
002bc6 917f                      	pop r23
002bc7 916f                      	pop r22
                                 
002bc8 9416                      	lsr r1 //shift out the fractional bits
002bc9 9407                      	ror r0
002bca 9416                      	lsr r1
002bcb 9407                      	ror r0
002bcc 9416                      	lsr r1
002bcd 9407                      	ror r0
002bce 9416                      	lsr r1
002bcf 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel3_pitch_calculate_check_negative:
002bd0 fe13                      	sbrs r1, 3 //check if result was a negative number
002bd1 c007                      	rjmp sound_driver_instrument_routine_channel3_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel3_pitch_calculate_negative:
002bd2 efc0                      	ldi r28, 0xF0
002bd3 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel3_pitch_calculate_check_divisible_8:
002bd4 70b7                      	andi r27, 0b00000111
002bd5 f019                      	breq sound_driver_instrument_routine_channel3_pitch_calculate_offset
                                 
002bd6 e0b1                      	ldi r27, 0x01
002bd7 0e0b                      	add r0, r27
002bd8 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel3_pitch_calculate_offset:
002bd9 91a0 2921                 	lds r26, noise_total_pitch_offset
002bdb 91b0 2922                 	lds r27, noise_total_pitch_offset+1
002bdd 0e0a                      	add r0, r26
002bde 1e1b                      	adc r1, r27
002bdf 9200 2921                 	sts noise_total_pitch_offset, r0
002be1 9210 2922                 	sts noise_total_pitch_offset+1, r1
002be3 91a0 0abc                 	lds r26, TCB3_CCMPL //load the low bits for timer
002be5 91b0 0abd                 	lds r27, TCB3_CCMPH //load the high bits for timer
002be7 0da0                      	add r26, r0 //offset the timer values
002be8 1db1                      	adc r27, r1
                                 	
002be9 91c0 2937                 	lds r28, noise_fx_1xx_total
002beb 91d0 2938                 	lds r29, noise_fx_1xx_total+1
002bed 1bac                      	sub r26, r28
002bee 0bbd                      	sbc r27, r29
002bef 91c0 293b                 	lds r28, noise_fx_2xx_total
002bf1 91d0 293c                 	lds r29, noise_fx_2xx_total+1
002bf3 0fac                      	add r26, r28
002bf4 1fbd                      	adc r27, r29
002bf5 91c0 294f                 	lds r28, noise_fx_Pxx_total
002bf7 91d0 2950                 	lds r29, noise_fx_Pxx_total+1
002bf9 0fac                      	add r26, r28
002bfa 1fbd                      	adc r27, r29
002bfb 91c0 2956                 	lds r28, noise_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
002bfd 91d0 2957                 	lds r29, noise_fx_Qxy_total_offset+1
002bff 1bac                      	sub r26, r28
002c00 0bbd                      	sbc r27, r29
002c01 91c0 295d                 	lds r28, noise_fx_Rxy_total_offset
002c03 91d0 295e                 	lds r29, noise_fx_Rxy_total_offset+1
002c05 0fac                      	add r26, r28
002c06 1fbd                      	adc r27, r29
                                 
002c07 93a0 0abc                 	sts TCB3_CCMPL, r26 //store the new low bits for timer
002c09 93b0 0abd                 	sts TCB3_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel3_hi_pitch:
002c0b 91e0 2929                 	lds ZL, noise_hi_pitch_macro
002c0d 91f0 292a                 	lds ZH, noise_hi_pitch_macro+1
002c0f 9630                      	adiw Z, 0
002c10 f409                      	brne sound_driver_instrument_routine_channel3_hi_pitch_continue
002c11 c03c                      	rjmp sound_driver_instrument_routine_channel3_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel3_hi_pitch_continue:
002c12 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002c13 1fff                      	rol ZH
002c14 91a0 292b                 	lds r26, noise_hi_pitch_macro_offset
002c16 0fea                      	add ZL, r26
002c17 1df2                      	adc ZH, zero
                                 
002c18 91b0 292d                 	lds r27, noise_hi_pitch_macro_release
002c1a 17ba                      	cp r27, r26
002c1b f429                      	brne sound_driver_instrument_routine_channel3_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002c1c 91a0 292c                 	lds r26, noise_hi_pitch_macro_loop
002c1e 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002c1f f010                      	brlo sound_driver_instrument_routine_channel3_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002c20 c003                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_increment:
002c21 95a3                      	inc r26 //increment the macro offset
002c22 93a0 292b                 	sts noise_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_hi_pitch_read:
002c24 91b4                      	lpm r27, Z //load hi pitch data into r27
002c25 38b0                      	cpi r27, 0x80 //check for macro end flag
002c26 f489                      	brne sound_driver_instrument_routine_channel3_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag_check_release:
002c27 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002c28 93a0 292b                 	sts noise_hi_pitch_macro_offset, r26
002c2a 91b0 292d                 	lds r27, noise_hi_pitch_macro_release
002c2c 3fbf                      	cpi r27, 0xFF
002c2d f439                      	brne sound_driver_instrument_routine_channel3_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag_check_loop:
002c2e 91b0 292c                 	lds r27, noise_hi_pitch_macro_loop //load the loop index
002c30 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002c31 f019                      	breq sound_driver_instrument_routine_channel3_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002c32 93b0 292b                 	sts noise_hi_pitch_macro_offset, r27 //store the loop index into the offset
002c34 cfd6                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_default:
002c35 91b0 2928                 	lds r27, noise_total_hi_pitch_offset
002c37 c005                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate:
002c38 91a0 2928                 	lds r26, noise_total_hi_pitch_offset //load the total hi pitch offset to change
002c3a 0fba                      	add r27, r26
002c3b 93b0 2928                 	sts noise_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate_multiply:
002c3d 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002c3e 937f                      	push r23
002c3f 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002c40 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002c41 0367                      	mulsu r22, r23
002c42 917f                      	pop r23
002c43 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate_offset:
002c44 91a0 0abc                 	lds r26, TCB3_CCMPL //load the low bits for timer
002c46 91b0 0abd                 	lds r27, TCB3_CCMPH //load the high bits for timer
002c48 0da0                      	add r26, r0 //offset the timer values
002c49 1db1                      	adc r27, r1
002c4a 93a0 0abc                 	sts TCB3_CCMPL, r26 //store the new low bits for timer
002c4c 93b0 0abd                 	sts TCB3_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty:
002c4e 91e0 292e                 	lds ZL, noise_duty_macro
002c50 91f0 292f                 	lds ZH, noise_duty_macro+1
002c52 9630                      	adiw Z, 0
002c53 f169                      	breq sound_driver_channel3_fx_routines //if no duty macro is in use, go to the next routine
002c54 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002c55 1fff                      	rol ZH
002c56 91a0 2930                 	lds r26, noise_duty_macro_offset
002c58 0fea                      	add ZL, r26
002c59 1df2                      	adc ZH, zero
                                 
002c5a 91b0 2932                 	lds r27, noise_duty_macro_release
002c5c 17ba                      	cp r27, r26
002c5d f429                      	brne sound_driver_instrument_routine_channel3_duty_increment //if the current offset is not equal to the release index, increment the offset
002c5e 91a0 2931                 	lds r26, noise_duty_macro_loop
002c60 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002c61 f010                      	brlo sound_driver_instrument_routine_channel3_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002c62 c01e                      	rjmp sound_driver_channel3_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel3_duty_increment:
002c63 95a3                      	inc r26 //increment the macro offset
002c64 93a0 2930                 	sts noise_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_duty_read:
002c66 91b4                      	lpm r27, Z //load pitch data into r27
002c67 3fbf                      	cpi r27, 0xFF //check for macro end flag
002c68 f471                      	brne sound_driver_instrument_routine_channel3_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag_check_release:
002c69 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002c6a 93a0 2930                 	sts noise_duty_macro_offset, r26
002c6c 91b0 2932                 	lds r27, noise_duty_macro_release
002c6e 3fbf                      	cpi r27, 0xFF
002c6f f489                      	brne sound_driver_channel3_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag_check_loop:
002c70 91b0 2931                 	lds r27, noise_duty_macro_loop //load the loop index
002c72 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002c73 f069                      	breq sound_driver_channel3_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
002c74 93b0 2930                 	sts noise_duty_macro_offset, r27 //store the loop index into the offset
002c76 cfd7                      	rjmp sound_driver_instrument_routine_channel3_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty_load:
002c77 95b6                      	lsr r27
002c78 95b7                      	ror r27 //move mode bit to bit 7
002c79 91c0 2814                 	lds r28, noise_period
002c7b 77cf                      	andi r28, 0b01111111
002c7c 2bcb                      	or r28, r27 //store the new noise mode
002c7d 93c0 2813                 	sts noise_param, r28
                                 
002c7f 776f                      	andi noise_sequence_HIGH, 0b01111111
002c80 2b6b                      	or noise_sequence_HIGH, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_routines:
                                 sound_driver_channel3_fx_1xx_routine:
002c81 91e0 2935                 	lds ZL, noise_fx_1xx
002c83 91f0 2936                 	lds ZH, noise_fx_1xx+1
002c85 9630                      	adiw Z, 0
002c86 f051                      	breq sound_driver_channel3_fx_2xx_routine
                                 
002c87 91a0 2937                 	lds r26, noise_fx_1xx_total //load the rate to change the pitch by
002c89 91b0 2938                 	lds r27, noise_fx_1xx_total+1
002c8b 0fae                      	add r26, ZL //increase the total offset by the rate
002c8c 1fbf                      	adc r27, ZH
002c8d 93a0 2937                 	sts noise_fx_1xx_total, r26
002c8f 93b0 2938                 	sts noise_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_2xx_routine:
002c91 91e0 2939                 	lds ZL, noise_fx_2xx
002c93 91f0 293a                 	lds ZH, noise_fx_2xx+1
002c95 9630                      	adiw Z, 0
002c96 f051                      	breq sound_driver_channel3_fx_3xx_routine
                                 
002c97 91a0 293b                 	lds r26, noise_fx_2xx_total //load the rate to change the pitch by
002c99 91b0 293c                 	lds r27, noise_fx_2xx_total+1
002c9b 0fae                      	add r26, ZL //increase the total offset by the rate
002c9c 1fbf                      	adc r27, ZH
002c9d 93a0 293b                 	sts noise_fx_2xx_total, r26
002c9f 93b0 293c                 	sts noise_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_3xx_routine:
002ca1 91e0 2941                 	lds ZL, noise_fx_3xx_speed
002ca3 91f0 2942                 	lds ZH, noise_fx_3xx_speed+1
002ca5 9630                      	adiw Z, 0
002ca6 f409                      	brne sound_driver_channel3_fx_3xx_routine_check_start
002ca7 c048                      	rjmp sound_driver_channel3_fx_4xy_routine
                                 
                                 sound_driver_channel3_fx_3xx_routine_check_start:
002ca8 91a0 293d                 	lds r26, noise_fx_3xx_start
002caa 91b0 293e                 	lds r27, noise_fx_3xx_start+1
002cac 9610                      	adiw r26:r27, 0
002cad f409                      	brne sound_driver_channel3_fx_3xx_routine_main
002cae c041                      	rjmp sound_driver_channel3_fx_4xy_routine
                                 
                                 sound_driver_channel3_fx_3xx_routine_main:
002caf 91c0 293f                 	lds r28, noise_fx_3xx_target
002cb1 91d0 2940                 	lds r29, noise_fx_3xx_target+1
                                 
002cb3 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
002cb4 07bd                      	cpc r27, r29
002cb5 f011                      	breq sound_driver_channel3_fx_3xx_routine_disable
002cb6 f030                      	brlo sound_driver_channel3_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002cb7 c01f                      	rjmp sound_driver_channel3_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel3_fx_3xx_routine_disable:
002cb8 9220 293d                 	sts noise_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002cba 9220 293e                 	sts noise_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002cbc c033                      	rjmp sound_driver_channel3_fx_4xy_routine
                                 
                                 sound_driver_channel3_fx_3xx_routine_subtract:
002cbd 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002cbe 0bdb                      	sbc r29, r27
002cbf 91a0 2943                 	lds r26, noise_fx_3xx_total_offset
002cc1 91b0 2944                 	lds r27, noise_fx_3xx_total_offset+1
                                 
002cc3 0fae                      	add r26, ZL //add the speed to the total offset
002cc4 1fbf                      	adc r27, ZH
002cc5 1bca                      	sub r28, r26 //invert the total difference with the total offset
002cc6 0bdb                      	sbc r29, r27
002cc7 f380                      	brlo sound_driver_channel3_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002cc8 93a0 2943                 	sts noise_fx_3xx_total_offset, r26 //store the new total offset
002cca 93b0 2944                 	sts noise_fx_3xx_total_offset+1, r27
                                 
002ccc 91a0 0abc                 	lds r26, TCB3_CCMPL //load the current timer period
002cce 91b0 0abd                 	lds r27, TCB3_CCMPH
002cd0 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002cd1 0bbd                      	sbc r27, r29
002cd2 93a0 0abc                 	sts TCB3_CCMPL, r26
002cd4 93b0 0abd                 	sts TCB3_CCMPH, r27
002cd6 c019                      	rjmp sound_driver_channel3_fx_4xy_routine
                                 
                                 sound_driver_channel3_fx_3xx_routine_add:
002cd7 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002cd8 0bbd                      	sbc r27, r29
002cd9 91c0 2943                 	lds r28, noise_fx_3xx_total_offset
002cdb 91d0 2944                 	lds r29, noise_fx_3xx_total_offset+1
                                 
002cdd 0fce                      	add r28, ZL //add the speed to the total offset
002cde 1fdf                      	adc r29, ZH
002cdf 1bac                      	sub r26, r28 //invert the total difference with the total offset
002ce0 0bbd                      	sbc r27, r29
002ce1 f2b0                      	brlo sound_driver_channel3_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002ce2 93c0 2943                 	sts noise_fx_3xx_total_offset, r28 //store the new total offset
002ce4 93d0 2944                 	sts noise_fx_3xx_total_offset+1, r29
                                 
002ce6 91c0 0abc                 	lds r28, TCB3_CCMPL //load the current timer period
002ce8 91d0 0abd                 	lds r29, TCB3_CCMPH
002cea 0fca                      	add r28, r26 //offset the current timer period with the total offset
002ceb 1fdb                      	adc r29, r27
002cec 93c0 0abc                 	sts TCB3_CCMPL, r28
002cee 93d0 0abd                 	sts TCB3_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel3_fx_4xy_routine:
002cf0 91a0 2945                 	lds r26, noise_fx_4xy_speed
002cf2 15a2                      	cp r26, zero
002cf3 f409                      	brne sound_driver_channel3_fx_4xy_routine_continue
002cf4 c05c                      	rjmp sound_driver_channel3_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel3_fx_4xy_routine_continue:
002cf5 91b0 2946                 	lds r27, noise_fx_4xy_depth
002cf7 91c0 2947                 	lds r28, noise_fx_4xy_phase
002cf9 0fca                      	add r28, r26 //increase the phase by the speed
002cfa 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002cfb f008                      	brlo sound_driver_channel3_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002cfc e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase:
002cfd 93c0 2947                 	sts noise_fx_4xy_phase, r28 //store the new phase
002cff 31c0                      	cpi r28, 16
002d00 f028                      	brlo sound_driver_channel3_fx_4xy_routine_phase_0
002d01 32c0                      	cpi r28, 32
002d02 f028                      	brlo sound_driver_channel3_fx_4xy_routine_phase_1
002d03 33c0                      	cpi r28, 48
002d04 f030                      	brlo sound_driver_channel3_fx_4xy_routine_phase_2
002d05 c007                      	rjmp sound_driver_channel3_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_0:
002d06 70cf                      	andi r28, 0x0F //mask for values 0-15
002d07 c029                      	rjmp sound_driver_channel3_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_1:
002d08 6fc0                      	ori r28, 0xF0
002d09 95c0                      	com r28 //invert values 0-15
002d0a c026                      	rjmp sound_driver_channel3_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_2:
002d0b 70cf                      	andi r28, 0x0F //mask for values 0-15
002d0c c003                      	rjmp sound_driver_channel3_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_3:
002d0d 6fc0                      	ori r28, 0xF0
002d0e 95c0                      	com r28 //invert values 0-15
002d0f c000                      	rjmp sound_driver_channel3_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel3_fx_4xy_routine_load_add:
002d10 95b2                      	swap r27 //multiply depth by 16
002d11 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002d12 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002d13 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002d14 0fec                      	add ZL, r28 //offset the table by the depth+phase
002d15 1df2                      	adc ZH, zero
002d16 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002d17 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002d18 937f                      	push r23
002d19 2f6c                      	mov r22, r28 //store the vibrato value into r22
002d1a eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002d1b 9f67                      	mul r22, r23
002d1c 917f                      	pop r23
002d1d 916f                      	pop r22
                                 
002d1e 9416                      	lsr r1 //shift out the fractional bits
002d1f 9407                      	ror r0
002d20 9416                      	lsr r1
002d21 9407                      	ror r0
002d22 9416                      	lsr r1
002d23 9407                      	ror r0
002d24 9416                      	lsr r1
002d25 9407                      	ror r0
                                 	
002d26 91a0 0abc                 	lds r26, TCB3_CCMPL
002d28 91b0 0abd                 	lds r27, TCB3_CCMPH
002d2a 0da0                      	add r26, r0
002d2b 1db1                      	adc r27, r1
002d2c 93a0 0abc                 	sts TCB3_CCMPL, r26
002d2e 93b0 0abd                 	sts TCB3_CCMPH, r27
002d30 c020                      	rjmp sound_driver_channel3_fx_7xy_routine
                                 
                                 sound_driver_channel3_fx_4xy_routine_load_subtract:
002d31 95b2                      	swap r27 //multiply depth by 16
002d32 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002d33 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002d34 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002d35 0fec                      	add ZL, r28 //offset the table by the depth+phase
002d36 1df2                      	adc ZH, zero
002d37 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002d38 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002d39 937f                      	push r23
002d3a 2f6c                      	mov r22, r28 //store the vibrato value into r22
002d3b eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002d3c 9f67                      	mul r22, r23
002d3d 917f                      	pop r23
002d3e 916f                      	pop r22
                                 
002d3f 9416                      	lsr r1 //shift out the fractional bits
002d40 9407                      	ror r0
002d41 9416                      	lsr r1
002d42 9407                      	ror r0
002d43 9416                      	lsr r1
002d44 9407                      	ror r0
002d45 9416                      	lsr r1
002d46 9407                      	ror r0
                                 
002d47 91a0 0abc                 	lds r26, TCB3_CCMPL
002d49 91b0 0abd                 	lds r27, TCB3_CCMPH
002d4b 19a0                      	sub r26, r0
002d4c 09b1                      	sbc r27, r1
002d4d 93a0 0abc                 	sts TCB3_CCMPL, r26
002d4f 93b0 0abd                 	sts TCB3_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_7xy_routine:
002d51 91a0 2948                 	lds r26, noise_fx_7xy_speed
002d53 15a2                      	cp r26, zero
002d54 f0e9                      	breq sound_driver_channel3_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
002d55 91b0 2949                 	lds r27, noise_fx_7xy_depth
002d57 91c0 294a                 	lds r28, noise_fx_7xy_phase
002d59 0fca                      	add r28, r26 //increase the phase by the speed
002d5a 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002d5b f008                      	brlo sound_driver_channel3_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
002d5c e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel3_fx_7xy_routine_phase:
002d5d 93c0 294a                 	sts noise_fx_7xy_phase, r28 //store the new phase
002d5f 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
002d60 ffc4                      	sbrs r28, 4
002d61 c001                      	rjmp sound_driver_channel3_fx_7xy_routine_phase_0
002d62 c002                      	rjmp sound_driver_channel3_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel3_fx_7xy_routine_phase_0:
002d63 70cf                      	andi r28, 0x0F //mask for values 0-15
002d64 c003                      	rjmp sound_driver_channel3_fx_7xy_routine_load
                                 
                                 sound_driver_channel3_fx_7xy_routine_phase_1:
002d65 6fc0                      	ori r28, 0xF0
002d66 95c0                      	com r28 //invert values 0-15
002d67 c000                      	rjmp sound_driver_channel3_fx_7xy_routine_load
                                 
                                 sound_driver_channel3_fx_7xy_routine_load:
002d68 95b2                      	swap r27 //multiply depth by 16
002d69 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002d6a e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002d6b e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002d6c 0fec                      	add ZL, r28 //offset the table by the depth+phase
002d6d 1df2                      	adc ZH, zero
002d6e 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002d6f 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
002d70 93c0 294b                 	sts noise_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Axy_routine:
002d72 91b0 294c                 	lds r27, noise_fx_Axy
002d74 15b2                      	cp r27, zero
002d75 f0e9                      	breq sound_driver_channel3_fx_Qxy_routine //0 means that the effect is not in use
                                 	
002d76 91a0 2815                 	lds r26, noise_fractional_volume //load fractional volume representation of the channel
002d78 91c0 2813                 	lds r28, noise_param //load the integer volume representation of the channel
002d7a 2fda                      	mov r29, r26 //copy fractional volume into r29
002d7b 2fec                      	mov r30, r28 //copy the noise_param into r30
002d7c 95e2                      	swap r30
002d7d 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
002d7e 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
002d7f 17ed                      	cp r30, r29 //compare the fractional and integer volumes
002d80 f009                      	breq sound_driver_channel3_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel3_fx_Axy_routine_reload:
002d81 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate:
002d82 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
002d83 c004                      	rjmp sound_driver_channel3_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_addition:
002d84 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002d85 f428                      	brcc sound_driver_channel3_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002d86 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
002d87 c003                      	rjmp sound_driver_channel3_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_subtraction:
002d88 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002d89 f008                      	brcs sound_driver_channel3_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002d8a e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_store:
002d8b 93a0 2815                 	sts noise_fractional_volume, r26 //store the new fractional volume
002d8d 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
002d8e 95a2                      	swap r26
002d8f 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
002d90 2bca                      	or r28, r26 //store the new volume back into noise_param
002d91 93c0 2813                 	sts noise_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel3_fx_Qxy_routine:
002d93 91e0 2952                 	lds ZL, noise_fx_Qxy_target
002d95 91f0 2953                 	lds ZH, noise_fx_Qxy_target+1
002d97 9630                      	adiw Z, 0
002d98 f119                      	breq sound_driver_channel3_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002d99 91a0 2956                 	lds r26, noise_fx_Qxy_total_offset
002d9b 91b0 2957                 	lds r27, noise_fx_Qxy_total_offset+1
002d9d 91c0 0abc                 	lds r28, TCB3_CCMPL
002d9f 91d0 0abd                 	lds r29, TCB3_CCMPH
                                 
002da1 1bec                      	sub ZL, r28 //calculate the difference to the target
002da2 0bfd                      	sbc ZH, r29
002da3 f408                      	brsh sound_driver_channel3_fx_Qxy_routine_end //if the target has been reached (or passed)
002da4 f068                      	brlo sound_driver_channel3_fx_Qxy_routine_add
                                 
                                 sound_driver_channel3_fx_Qxy_routine_end:
002da5 9220 2956                 	sts noise_fx_Qxy_total_offset, zero //turn off the effect
002da7 9220 2957                 	sts noise_fx_Qxy_total_offset+1, zero
002da9 9220 2952                 	sts noise_fx_Qxy_target, zero
002dab 9220 2953                 	sts noise_fx_Qxy_target+1, zero
002dad 91b0 2951                 	lds r27, noise_fx_Qxy_target_note
002daf 93b0 2817                 	sts noise_note, r27 //replace the note with the final target note
002db1 c00a                      	rjmp sound_driver_channel3_fx_Rxy_routine
                                 
                                 sound_driver_channel3_fx_Qxy_routine_add:
002db2 91c0 2954                 	lds r28, noise_fx_Qxy_speed
002db4 91d0 2955                 	lds r29, noise_fx_Qxy_speed+1
002db6 0fac                      	add r26, r28 //increase the total offset by the speed
002db7 1fbd                      	adc r27, r29
002db8 93a0 2956                 	sts noise_fx_Qxy_total_offset, r26 //store the total offset
002dba 93b0 2957                 	sts noise_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Rxy_routine:
002dbc 91e0 2959                 	lds ZL, noise_fx_Rxy_target
002dbe 91f0 295a                 	lds ZH, noise_fx_Rxy_target+1
002dc0 9630                      	adiw Z, 0
002dc1 f119                      	breq sound_driver_instrument_routine_channel4_volume //if the effect is not enabled, skip the routine
                                 
002dc2 91a0 295d                 	lds r26, noise_fx_Rxy_total_offset
002dc4 91b0 295e                 	lds r27, noise_fx_Rxy_total_offset+1
002dc6 91c0 0abc                 	lds r28, TCB3_CCMPL
002dc8 91d0 0abd                 	lds r29, TCB3_CCMPH
                                 
002dca 1bce                      	sub r28, ZL //calculate the difference to the target
002dcb 0bdf                      	sbc r29, ZH
002dcc f408                      	brsh sound_driver_channel3_fx_Rxy_routine_end //if the target has been reached (or passed)
002dcd f068                      	brlo sound_driver_channel3_fx_Rxy_routine_add
                                 
                                 sound_driver_channel3_fx_Rxy_routine_end:
002dce 9220 295d                 	sts noise_fx_Rxy_total_offset, zero //disable the effect
002dd0 9220 295e                 	sts noise_fx_Rxy_total_offset+1, zero
002dd2 9220 2959                 	sts noise_fx_Rxy_target, zero
002dd4 9220 295a                 	sts noise_fx_Rxy_target+1, zero
002dd6 91b0 2958                 	lds r27, noise_fx_Rxy_target_note
002dd8 93b0 2817                 	sts noise_note, r27 //replace the note with the final target note
002dda c00a                      	rjmp sound_driver_instrument_routine_channel4_volume
                                 
                                 sound_driver_channel3_fx_Rxy_routine_add:
002ddb 91c0 295b                 	lds r28, noise_fx_Rxy_speed
002ddd 91d0 295c                 	lds r29, noise_fx_Rxy_speed+1
002ddf 0fac                      	add r26, r28 //increase the total offset by the speed
002de0 1fbd                      	adc r27, r29
002de1 93a0 295d                 	sts noise_fx_Rxy_total_offset, r26 //store the total offset
002de3 93b0 295e                 	sts noise_fx_Rxy_total_offset+1, r27
                                 
                                 sound_driver_instrument_routine_channel4_volume:
                                 
                                 sound_driver_exit:
002de5 91ff                      	pop r31
002de6 91ef                      	pop r30
002de7 91df                      	pop r29
002de8 91cf                      	pop r28
002de9 940c 1293                 	jmp sequence_1_3 + 3 //+3 is to skip the stack instructions since we already pushed them
                                 
                                 
                                 
                                 //TABLES
002deb 7f05
002dec 010a
002ded 0214
002dee 0328
002def 0450
002df0 051e
002df1 0607
002df2 070d
002df3 0806
002df4 090c
002df5 0a18
002df6 0b30
002df7 0c60
002df8 0d24
002df9 0e08
002dfa 0f10                      length: .db $05, $7F, $0A, $01, $14, $02, $28, $03, $50, $04, $1E, $05, $07, $06, $0D, $07, $06, $08, $0C, $09, $18, $0A, $30, $0B, $60, $0C, $24, $0D, $08, $0E, $10, $0F
                                 
                                 //pulse sequences: 12.5%, 25%, 50%, 75%
002dfb 0301
002dfc fc0f                      sequences: .db 0b00000001, 0b00000011, 0b00001111, 0b11111100
                                 
                                 //list of famitracker fx: http://famitracker.com/wiki/index.php?title=Effect_list
                                 channel0_fx:
002dfd 14cf
002dfe 14d4
002dff 14f0
002e00 150c
002e01 152f                      	.dw sound_driver_channel0_fx_0xy, sound_driver_channel0_fx_1xx, sound_driver_channel0_fx_2xx, sound_driver_channel0_fx_3xx, sound_driver_channel0_fx_4xy
002e02 153a
002e03 1547
002e04 154a
002e05 154d
002e06 1550                      	.dw sound_driver_channel0_fx_7xy, sound_driver_channel0_fx_Axy, sound_driver_channel0_fx_Bxx, sound_driver_channel0_fx_Cxx, sound_driver_channel0_fx_Dxx
002e07 1553
002e08 155b
002e09 155e
002e0a 156b
002e0b 156c                      	.dw sound_driver_channel0_fx_Exx, sound_driver_channel0_fx_Fxx, sound_driver_channel0_fx_Gxx, sound_driver_channel0_fx_Hxy, sound_driver_channel0_fx_Ixy
002e0c 156d
002e0d 156e
002e0e 156f
002e0f 1587
002e10 15c9                      	.dw sound_driver_channel0_fx_Hxx, sound_driver_channel0_fx_Ixx, sound_driver_channel0_fx_Pxx, sound_driver_channel0_fx_Qxy, sound_driver_channel0_fx_Rxy
002e11 160a
002e12 1617
002e13 162b
002e14 162c
002e15 162d                      	.dw sound_driver_channel0_fx_Sxx, sound_driver_channel0_fx_Vxx, sound_driver_channel0_fx_Wxx, sound_driver_channel0_fx_Xxx, sound_driver_channel0_fx_Yxx
002e16 162e                      	.dw sound_driver_channel0_fx_Zxx
                                 
                                 channel1_fx:
002e17 17bd
002e18 17c2
002e19 17de
002e1a 17fa
002e1b 181d                      	.dw sound_driver_channel1_fx_0xy, sound_driver_channel1_fx_1xx, sound_driver_channel1_fx_2xx, sound_driver_channel1_fx_3xx, sound_driver_channel1_fx_4xy
002e1c 1828
002e1d 1835
002e1e 1838
002e1f 183b
002e20 183e                      	.dw sound_driver_channel1_fx_7xy, sound_driver_channel1_fx_Axy, sound_driver_channel1_fx_Bxx, sound_driver_channel1_fx_Cxx, sound_driver_channel1_fx_Dxx
002e21 1841
002e22 1849
002e23 184c
002e24 1859
002e25 185a                      	.dw sound_driver_channel1_fx_Exx, sound_driver_channel1_fx_Fxx, sound_driver_channel1_fx_Gxx, sound_driver_channel1_fx_Hxy, sound_driver_channel1_fx_Ixy
002e26 185b
002e27 185c
002e28 185d
002e29 1875
002e2a 18b7                      	.dw sound_driver_channel1_fx_Hxx, sound_driver_channel1_fx_Ixx, sound_driver_channel1_fx_Pxx, sound_driver_channel1_fx_Qxy, sound_driver_channel1_fx_Rxy
002e2b 18f8
002e2c 1905
002e2d 1919
002e2e 191a
002e2f 191b                      	.dw sound_driver_channel1_fx_Sxx, sound_driver_channel1_fx_Vxx, sound_driver_channel1_fx_Wxx, sound_driver_channel1_fx_Xxx, sound_driver_channel1_fx_Yxx
002e30 191c                      	.dw sound_driver_channel1_fx_Zxx
                                 
                                 channel2_fx:
002e31 1a9e
002e32 1aa3
002e33 1abf
002e34 1adb
002e35 1afe                      	.dw sound_driver_channel2_fx_0xy, sound_driver_channel2_fx_1xx, sound_driver_channel2_fx_2xx, sound_driver_channel2_fx_3xx, sound_driver_channel2_fx_4xy
002e36 1b09
002e37 1b0a
002e38 1b0b
002e39 1b0e
002e3a 1b11                      	.dw sound_driver_channel2_fx_7xy, sound_driver_channel2_fx_Axy, sound_driver_channel2_fx_Bxx, sound_driver_channel2_fx_Cxx, sound_driver_channel2_fx_Dxx
002e3b 1b14
002e3c 1b21
002e3d 1b24
002e3e 1b31
002e3f 1b32                      	.dw sound_driver_channel2_fx_Exx, sound_driver_channel2_fx_Fxx, sound_driver_channel2_fx_Gxx, sound_driver_channel2_fx_Hxy, sound_driver_channel2_fx_Ixy
002e40 1b33
002e41 1b34
002e42 1b35
002e43 1b4d
002e44 1b8f                      	.dw sound_driver_channel2_fx_Hxx, sound_driver_channel2_fx_Ixx, sound_driver_channel2_fx_Pxx, sound_driver_channel2_fx_Qxy, sound_driver_channel2_fx_Rxy
002e45 1bd0
002e46 1bdd
002e47 1bde
002e48 1bdf
002e49 1be0                      	.dw sound_driver_channel2_fx_Sxx, sound_driver_channel2_fx_Vxx, sound_driver_channel2_fx_Wxx, sound_driver_channel2_fx_Xxx, sound_driver_channel2_fx_Yxx
002e4a 1be1                      	.dw sound_driver_channel2_fx_Zxx
                                 
                                 channel3_fx:
002e4b 1d67
002e4c 1d6c
002e4d 1d88
002e4e 1da4
002e4f 1dc7                      	.dw sound_driver_channel3_fx_0xy, sound_driver_channel3_fx_1xx, sound_driver_channel3_fx_2xx, sound_driver_channel3_fx_3xx, sound_driver_channel3_fx_4xy
002e50 1dd2
002e51 1ddf
002e52 1de2
002e53 1de5
002e54 1de8                      	.dw sound_driver_channel3_fx_7xy, sound_driver_channel3_fx_Axy, sound_driver_channel3_fx_Bxx, sound_driver_channel3_fx_Cxx, sound_driver_channel3_fx_Dxx
002e55 1deb
002e56 1df2
002e57 1df5
002e58 1e02
002e59 1e03                      	.dw sound_driver_channel3_fx_Exx, sound_driver_channel3_fx_Fxx, sound_driver_channel3_fx_Gxx, sound_driver_channel3_fx_Hxy, sound_driver_channel3_fx_Ixy
002e5a 1e04
002e5b 1e05
002e5c 1e06
002e5d 1e1e
002e5e 1e60                      	.dw sound_driver_channel3_fx_Hxx, sound_driver_channel3_fx_Ixx, sound_driver_channel3_fx_Pxx, sound_driver_channel3_fx_Qxy, sound_driver_channel3_fx_Rxy
002e5f 1ea1
002e60 1eae
002e61 1eb9
002e62 1eba
002e63 1ebb                      	.dw sound_driver_channel3_fx_Sxx, sound_driver_channel3_fx_Vxx, sound_driver_channel3_fx_Wxx, sound_driver_channel3_fx_Xxx, sound_driver_channel3_fx_Yxx
002e64 1ebc                      	.dw sound_driver_channel3_fx_Zxx
                                 
                                 //famitracker volumes table: http://famitracker.com/wiki/index.php?title=Volume
                                 volumes:
002e65 0000
002e66 0000
002e67 0000
002e68 0000
002e69 0000
002e6a 0000
002e6b 0000
002e6c 0000                      	.db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
002e6d 0100
002e6e 0101
002e6f 0101
002e70 0101
002e71 0101
002e72 0101
002e73 0101
002e74 0101                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
002e75 0100
002e76 0101
002e77 0101
002e78 0101
002e79 0101
002e7a 0101
002e7b 0101
002e7c 0201                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02
002e7d 0100
002e7e 0101
002e7f 0101
002e80 0101
002e81 0101
002e82 0202
002e83 0202
002e84 0302                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03
002e85 0100
002e86 0101
002e87 0101
002e88 0101
002e89 0202
002e8a 0202
002e8b 0303
002e8c 0403                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04
002e8d 0100
002e8e 0101
002e8f 0101
002e90 0202
002e91 0302
002e92 0303
002e93 0404
002e94 0504                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05
002e95 0100
002e96 0101
002e97 0201
002e98 0202
002e99 0303
002e9a 0404
002e9b 0504
002e9c 0605                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x06
002e9d 0100
002e9e 0101
002e9f 0201
002ea0 0302
002ea1 0403
002ea2 0504
002ea3 0605
002ea4 0706                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07
002ea5 0100
002ea6 0101
002ea7 0202
002ea8 0303
002ea9 0404
002eaa 0505
002eab 0606
002eac 0807                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07, 0x08
002ead 0100
002eae 0101
002eaf 0302
002eb0 0403
002eb1 0504
002eb2 0606
002eb3 0707
002eb4 0908                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09
002eb5 0100
002eb6 0201
002eb7 0302
002eb8 0404
002eb9 0605
002eba 0706
002ebb 0808
002ebc 0a09                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A
002ebd 0100
002ebe 0201
002ebf 0302
002ec0 0504
002ec1 0605
002ec2 0807
002ec3 0908
002ec4 0b0a                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B
002ec5 0100
002ec6 0201
002ec7 0403
002ec8 0504
002ec9 0706
002eca 0808
002ecb 0a09
002ecc 0c0b                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B, 0x0C
002ecd 0100
002ece 0201
002ecf 0403
002ed0 0605
002ed1 0706
002ed2 0908
002ed3 0b0a
002ed4 0d0c                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D
002ed5 0100
002ed6 0201
002ed7 0403
002ed8 0605
002ed9 0807
002eda 0a09
002edb 0c0b
002edc 0e0d                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E
002edd 0100
002ede 0302
002edf 0504
002ee0 0706
002ee1 0908
002ee2 0b0a
002ee3 0d0c


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega4809" register use summary:
x  :   0 y  :   0 z  : 248 r0 : 196 r1 : 212 r2 : 709 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   6 r11:   4 r12:   9 
r13:   6 r14:   4 r15:   9 r16:   7 r17:   6 r18:   7 r19:   6 r20:   4 
r21:   9 r22: 174 r23: 160 r24:   0 r25:  24 r26: 961 r27:1203 r28: 705 
r29: 374 r30: 374 r31: 333 
Registers used: 25 out of 35 (71.4%)

"ATmega4809" instruction use summary:
.lds  :   0 .sts  :   0 adc   : 144 add   : 191 adiw  : 106 and   :   0 
andi  :  99 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   7 brcs  :  13 break :   0 breq  : 173 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  84 brlt  :   0 brmi  :   0 
brne  : 121 brpl  :   0 brsh  :  34 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :   0 cbr   :   5 
clc   :   0 clh   :   0 cli   :   8 cln   :   0 clr   :   5 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :  16 cp    : 107 cpc   :  16 
cpi   : 168 cpse  :  20 dec   :  35 des   :   0 eor   :   2 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   4 in    :   7 inc   :  48 
jmp   :  11 ld    :   0 ldd   :   0 ldi   : 318 lds   : 719 lpm   : 260 
lsl   :  79 lsr   : 171 mov   : 139 movw  :   0 mul   :  28 muls  :   0 
mulsu :  12 neg   :   0 nop   :   0 or    :  26 ori   :  12 out   :   9 
pop   : 115 push  : 109 rcall :  50 ret   :  32 reti  :   7 rjmp  : 527 
rol   :  53 ror   : 192 sbc   :  40 sbci  :   0 sbi   :   0 sbic  :   0 
sbis  :   0 sbiw  :   0 sbr   :  12 sbrc  :  29 sbrs  :  20 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   :1413 sub   :  58 subi  :  45 swap  :  46 tst   :   0 wdr   :   0 

Instructions used: 52 out of 114 (45.6%)

"ATmega4809" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x005dca  15988   7910  23898   49152  48.6%
[.dseg] 0x002800 0x002962      0    354    354    6144   5.8%
[.eseg] 0x000000 0x000000      0      0      0     256   0.0%

Assembly complete, 0 errors, 55 warnings
