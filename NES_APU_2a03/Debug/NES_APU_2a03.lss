
AVRASM ver. 2.2.8  C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm Wed May 19 23:55:30 2021

C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
                                 
                                 
                                 ; NES_APU_2a03.asm
                                 ;
                                 ; Created: 11/29/2020 1:44:10 AM
                                 ; Author : Tennyson Cheng
                                 ;
                                 
                                 .list
                                 
                                 .dseg
002800                           pulse1_param: .byte 1 //$4000 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002801                           pulse1_sweep_param: .byte 1 //$4001 EPPP.NSSS = Enable, Period, Negate, Shift
                                 //NOTE: In order to account for multiplier, we use 16 instead of 11 bits for the timer
002802                           pulse1_timerL: .byte 1 //$4002 LLLL.LLLL = Low 8 bits for timer
002803                           pulse1_timerH: .byte 1 //$4002 HHHH.HHHH = High 8 bits for timer
002804                           pulse1_length: .byte 1 //$4003 000l.llll = Length counter load
002805                           pulse1_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002806                           pulse1_output_volume: .byte 1 //this is the final output volume of pulse 1
002807                           pulse1_note: .byte 1 //the current note index in the note table
                                 
002808                           pulse2_param: .byte 1 //$4004 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002809                           pulse2_sweep_param: .byte 1 //$4005 EPPP.NSSS = Enable, Period, Negate, Shift
00280a                           pulse2_timerL: .byte 1 //$4006 LLLL.LLLL = Low 8 bits for timer
00280b                           pulse2_timerH: .byte 1 //$4006 HHHH.HHHH = High 8 bits for timer
00280c                           pulse2_length: .byte 1 //$4007 000l.llll = Length counter load
00280d                           pulse2_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
00280e                           pulse2_output_volume: .byte 1 //this is the final output volume of pulse 2
00280f                           pulse2_note: .byte 1 //the current note index in the note table
                                 
002810                           triangle_timerL: .byte 1 //$400A LLLL.LLLL = Low 8 bits for timer
002811                           triangle_timerH: .byte 1 //$400A HHHH.HHHH = High 8 bits for time
002812                           triangle_note: .byte 1 //the current note index in the note table
                                 
002813                           noise_param: .byte 1 //$400C 00lc.vvvv = Length counter halt/Loop flag, Constant volume flag, Volume
002814                           noise_period: .byte 1 //$400E M000.PPPP = Mode, Period
002815                           noise_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002816                           noise_output_volume: .byte 1 //this is the final output volume of pulse 2
002817                           noise_note: .byte 1 //the current note index in the period table
002818                           noise_adjusted_note: .byte 1 //the resultant note index after the arpeggio macro
                                 
002819                           song_frames: .byte 2
00281b                           song_frame_offset: .byte 2
00281d                           song_size: .byte 2
00281f                           song_speed: .byte 1
                                 //song_channel_delay_reload: .byte 1 //bit 0-4 represents channels 0-4. a set bit means that there is a delay that needs to be calculated for that channel.
002820                           song_fx_Bxx: .byte 1
002821                           song_fx_Cxx: .byte 1
002822                           song_fx_Dxx: .byte 1
                                 
                                 //PULSE 1
002823                           pulse1_pattern: .byte 2
002825                           pulse1_pattern_delay_rows: .byte 1
002826                           pulse1_pattern_delay_frames: .byte 1
002827                           pulse1_pattern_offset: .byte 2
                                 
002829                           pulse1_volume_macro: .byte 2
00282b                           pulse1_volume_macro_offset: .byte 1
00282c                           pulse1_volume_macro_loop: .byte 1
00282d                           pulse1_volume_macro_release: .byte 1
                                 
00282e                           pulse1_arpeggio_macro: .byte 2
002830                           pulse1_arpeggio_macro_offset: .byte 1
002831                           pulse1_arpeggio_macro_loop: .byte 1
002832                           pulse1_arpeggio_macro_release: .byte 1
002833                           pulse1_arpeggio_macro_mode: .byte 1
                                 
002834                           pulse1_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002836                           pulse1_pitch_macro: .byte 2
002838                           pulse1_pitch_macro_offset: .byte 1
002839                           pulse1_pitch_macro_loop: .byte 1
00283a                           pulse1_pitch_macro_release: .byte 1
                                 
00283b                           pulse1_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00283c                           pulse1_hi_pitch_macro: .byte 2
00283e                           pulse1_hi_pitch_macro_offset: .byte 1
00283f                           pulse1_hi_pitch_macro_loop: .byte 1
002840                           pulse1_hi_pitch_macro_release: .byte 1
                                 
002841                           pulse1_duty_macro: .byte 2
002843                           pulse1_duty_macro_offset: .byte 1
002844                           pulse1_duty_macro_loop: .byte 1
002845                           pulse1_duty_macro_release: .byte 1
                                 
002846                           pulse1_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002848                           pulse1_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
00284a                           pulse1_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00284c                           pulse1_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
00284e                           pulse1_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
002850                           pulse1_fx_3xx_start: .byte 2 //the starting note period
002852                           pulse1_fx_3xx_target: .byte 2 //target note period
002854                           pulse1_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
002856                           pulse1_fx_3xx_total_offset: .byte 2
002858                           pulse1_fx_4xy_speed: .byte 1
002859                           pulse1_fx_4xy_depth: .byte 1
00285a                           pulse1_fx_4xy_phase: .byte 1
00285b                           pulse1_fx_7xy_speed: .byte 1
00285c                           pulse1_fx_7xy_depth: .byte 1
00285d                           pulse1_fx_7xy_phase: .byte 1
00285e                           pulse1_fx_7xy_value: .byte 1 //value to offset the volume
00285f                           pulse1_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
002860                           pulse1_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002861                           pulse1_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002862                           pulse1_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
002864                           pulse1_fx_Qxy_target_note: .byte 1 //target note index
002865                           pulse1_fx_Qxy_target: .byte 2 //target note period
002867                           pulse1_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002869                           pulse1_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
00286b                           pulse1_fx_Rxy_target_note: .byte 1 //target note index
00286c                           pulse1_fx_Rxy_target: .byte 2 //target note period
00286e                           pulse1_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
002870                           pulse1_fx_Rxy_total_offset: .byte 2
002872                           pulse1_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002873                           pulse1_fx_Sxx_post: .byte 1
                                 
                                 //PULSE 2
002874                           pulse2_pattern: .byte 2
002876                           pulse2_pattern_delay_rows: .byte 1
002877                           pulse2_pattern_delay_frames: .byte 1
002878                           pulse2_pattern_offset: .byte 2
                                 
00287a                           pulse2_volume_macro: .byte 2
00287c                           pulse2_volume_macro_offset: .byte 1
00287d                           pulse2_volume_macro_loop: .byte 1
00287e                           pulse2_volume_macro_release: .byte 1
                                 
00287f                           pulse2_arpeggio_macro: .byte 2
002881                           pulse2_arpeggio_macro_offset: .byte 1
002882                           pulse2_arpeggio_macro_loop: .byte 1
002883                           pulse2_arpeggio_macro_release: .byte 1
002884                           pulse2_arpeggio_macro_mode: .byte 1
                                 
002885                           pulse2_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002887                           pulse2_pitch_macro: .byte 2
002889                           pulse2_pitch_macro_offset: .byte 1
00288a                           pulse2_pitch_macro_loop: .byte 1
00288b                           pulse2_pitch_macro_release: .byte 1
                                 
00288c                           pulse2_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00288d                           pulse2_hi_pitch_macro: .byte 2
00288f                           pulse2_hi_pitch_macro_offset: .byte 1
002890                           pulse2_hi_pitch_macro_loop: .byte 1
002891                           pulse2_hi_pitch_macro_release: .byte 1
                                 
002892                           pulse2_duty_macro: .byte 2
002894                           pulse2_duty_macro_offset: .byte 1
002895                           pulse2_duty_macro_loop: .byte 1
002896                           pulse2_duty_macro_release: .byte 1
                                 
002897                           pulse2_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002899                           pulse2_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
00289b                           pulse2_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00289d                           pulse2_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
00289f                           pulse2_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
0028a1                           pulse2_fx_3xx_start: .byte 2 //the starting note period
0028a3                           pulse2_fx_3xx_target: .byte 2 //target note period
0028a5                           pulse2_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028a7                           pulse2_fx_3xx_total_offset: .byte 2
0028a9                           pulse2_fx_4xy_speed: .byte 1
0028aa                           pulse2_fx_4xy_depth: .byte 1
0028ab                           pulse2_fx_4xy_phase: .byte 1
0028ac                           pulse2_fx_7xy_speed: .byte 1
0028ad                           pulse2_fx_7xy_depth: .byte 1
0028ae                           pulse2_fx_7xy_phase: .byte 1
0028af                           pulse2_fx_7xy_value: .byte 1 //value to offset the volume
0028b0                           pulse2_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
0028b1                           pulse2_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028b2                           pulse2_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028b3                           pulse2_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
0028b5                           pulse2_fx_Qxy_target_note: .byte 1 //target note index
0028b6                           pulse2_fx_Qxy_target: .byte 2 //target note period
0028b8                           pulse2_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
0028ba                           pulse2_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
0028bc                           pulse2_fx_Rxy_target_note: .byte 1 //target note index
0028bd                           pulse2_fx_Rxy_target: .byte 2 //target note period
0028bf                           pulse2_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
0028c1                           pulse2_fx_Rxy_total_offset: .byte 2
0028c3                           pulse2_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
0028c4                           pulse2_fx_Sxx_post: .byte 1
                                 
                                 //TRIANGLE
0028c5                           triangle_pattern: .byte 2
0028c7                           triangle_pattern_delay_rows: .byte 1
0028c8                           triangle_pattern_delay_frames: .byte 1
0028c9                           triangle_pattern_offset: .byte 2
                                 
0028cb                           triangle_volume_macro: .byte 2
0028cd                           triangle_volume_macro_offset: .byte 1
0028ce                           triangle_volume_macro_loop: .byte 1
0028cf                           triangle_volume_macro_release: .byte 1
                                 
0028d0                           triangle_arpeggio_macro: .byte 2
0028d2                           triangle_arpeggio_macro_offset: .byte 1
0028d3                           triangle_arpeggio_macro_loop: .byte 1
0028d4                           triangle_arpeggio_macro_release: .byte 1
0028d5                           triangle_arpeggio_macro_mode: .byte 1
                                 
0028d6                           triangle_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
0028d8                           triangle_pitch_macro: .byte 2
0028da                           triangle_pitch_macro_offset: .byte 1
0028db                           triangle_pitch_macro_loop: .byte 1
0028dc                           triangle_pitch_macro_release: .byte 1
                                 
0028dd                           triangle_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
0028de                           triangle_hi_pitch_macro: .byte 2
0028e0                           triangle_hi_pitch_macro_offset: .byte 1
0028e1                           triangle_hi_pitch_macro_loop: .byte 1
0028e2                           triangle_hi_pitch_macro_release: .byte 1
                                 
0028e3                           triangle_duty_macro: .byte 2
0028e5                           triangle_duty_macro_offset: .byte 1
0028e6                           triangle_duty_macro_loop: .byte 1
0028e7                           triangle_duty_macro_release: .byte 1
                                 
0028e8                           triangle_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
0028ea                           triangle_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
0028ec                           triangle_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
0028ee                           triangle_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
0028f0                           triangle_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
0028f2                           triangle_fx_3xx_start: .byte 2 //the starting note period
0028f4                           triangle_fx_3xx_target: .byte 2 //target note period
0028f6                           triangle_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028f8                           triangle_fx_3xx_total_offset: .byte 2
0028fa                           triangle_fx_4xy_speed: .byte 1
0028fb                           triangle_fx_4xy_depth: .byte 1
0028fc                           triangle_fx_4xy_phase: .byte 1
0028fd                           triangle_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028fe                           triangle_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028ff                           triangle_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
002901                           triangle_fx_Qxy_target_note: .byte 1 //target note index
002902                           triangle_fx_Qxy_target: .byte 2 //target note period
002904                           triangle_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002906                           triangle_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002908                           triangle_fx_Rxy_target_note: .byte 1 //target note index
002909                           triangle_fx_Rxy_target: .byte 2 //target note period
00290b                           triangle_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
00290d                           triangle_fx_Rxy_total_offset: .byte 2
00290f                           triangle_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002910                           triangle_fx_Sxx_post: .byte 1
                                 
                                 //NOISE
002911                           noise_pattern: .byte 2
002913                           noise_pattern_delay_rows: .byte 1
002914                           noise_pattern_delay_frames: .byte 1
002915                           noise_pattern_offset: .byte 2
                                 
002917                           noise_volume_macro: .byte 2
002919                           noise_volume_macro_offset: .byte 1
00291a                           noise_volume_macro_loop: .byte 1
00291b                           noise_volume_macro_release: .byte 1
                                 
00291c                           noise_arpeggio_macro: .byte 2
00291e                           noise_arpeggio_macro_offset: .byte 1
00291f                           noise_arpeggio_macro_loop: .byte 1
002920                           noise_arpeggio_macro_release: .byte 1
002921                           noise_arpeggio_macro_mode: .byte 1
                                 
002922                           noise_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002924                           noise_pitch_macro: .byte 2
002926                           noise_pitch_macro_offset: .byte 1
002927                           noise_pitch_macro_loop: .byte 1
002928                           noise_pitch_macro_release: .byte 1
                                 
002929                           noise_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00292a                           noise_hi_pitch_macro: .byte 2
00292c                           noise_hi_pitch_macro_offset: .byte 1
00292d                           noise_hi_pitch_macro_loop: .byte 1
00292e                           noise_hi_pitch_macro_release: .byte 1
                                 
00292f                           noise_duty_macro: .byte 2
002931                           noise_duty_macro_offset: .byte 1
002932                           noise_duty_macro_loop: .byte 1
002933                           noise_duty_macro_release: .byte 1
                                 
002934                           noise_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002936                           noise_fx_1xx: .byte 1 //refers to the rate in which to subtract the pitch from by the 1xx
002937                           noise_fx_1xx_total: .byte 1 //the total pitch offset for 1xx
002938                           noise_fx_2xx: .byte 1 //refers to the rate in which to add to the pitch by the 2xx
002939                           noise_fx_2xx_total: .byte 1 //the total pitch offset for 2xx
00293a                           noise_fx_4xy_speed: .byte 1
00293b                           noise_fx_4xy_depth: .byte 1
00293c                           noise_fx_4xy_phase: .byte 1
00293d                           noise_fx_4xy_offset: .byte 1
00293e                           noise_fx_7xy_speed: .byte 1
00293f                           noise_fx_7xy_depth: .byte 1
002940                           noise_fx_7xy_phase: .byte 1
002941                           noise_fx_7xy_value: .byte 1 //value to offset the volume
002942                           noise_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
002943                           noise_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002944                           noise_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002945                           noise_fx_Pxx_total: .byte 1 //refers to the fine pitch offset set by the Pxx effect
002946                           noise_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002947                           noise_fx_Sxx_post: .byte 1
                                 
                                 //DPCM
002948                           dpcm_pattern: .byte 2
00294a                           dpcm_pattern_delay_rows: .byte 1
00294b                           dpcm_pattern_delay_frames: .byte 1
00294c                           dpcm_pattern_offset: .byte 2
                                 
00294e                           dpcm_sample: .byte 2
002950                           dpcm_sample_offset: .byte 2
                                 
002952                           dpcm_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002953                           dpcm_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002954                           dpcm_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002955                           dpcm_fx_Sxx_post: .byte 1
                                 
                                 .cseg
                                 
                                 //NOTE: zero is defined in order to use the cp instruction without the need to load 0x00 into a register beforehand
                                 //NOTE: same idea with one
                                 .def zero = r2
                                 .def one = r3
                                 .def frame_sequence = r4
                                 .def pulse_channel_flags = r25 //[pulse1.pulse2] RSlc.RSlc = Reload, Start, Length halt/Loop, Constant volume
                                 .def pulse1_sequence = r7
                                 .def pulse1_length_counter = r8
                                 .def pulse1_sweep = r9 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse1_volume_divider = r16 //0000.PPPP = Period divider
                                 .def pulse1_volume_decay = r17 //0000.dddd = Decay
                                 .def pulse2_sequence = r10
                                 .def pulse2_length_counter = r11
                                 .def pulse2_sweep = r12 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse2_volume_divider = r18 //0000.PPPP = Period divider
                                 .def pulse2_volume_decay = r19 //0000.dddd = Decay
                                 .def triangle_sequence = r20
                                 .def noise_sequence_LOW = r21
                                 .def noise_sequence_HIGH = r22
                                 .def dpcm_shift = r13
                                 .def dpcm_bit_counter = r14
                                 .def dpcm_period = r15
                                 .def dpcm_length_LOW = r23
                                 .def dpcm_length_HIGH = r24
                                 
                                 
                                 reset:
000000 940c 135b                 	jmp init
                                 
                                 .org RTC_CNT_vect
000006 940c 16ff                 	jmp frame_counter_routine
                                 
                                 .org TCB0_INT_vect
000018 940c 1727                 	jmp pulse1_sequence_routine
                                 
                                 .org TCB1_INT_vect
00001a 940c 1774                 	jmp pulse2_sequence_routine
                                 
                                 .org TCB2_INT_vect
000032 940c 17c1                 	jmp triangle_sequence_routine
                                 
                                 .org TCB3_INT_vect
000048 940c 17cc                 	jmp noise_sequence_routine
                                 
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(33): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(48): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(87): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(88): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(89): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(90): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(91): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(92): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(93): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(94): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(95): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(96): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(97): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(98): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(99): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(100): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(101): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(102): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(104): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(105): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(107): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(108): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(109): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(111): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(112): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(113): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(115): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(116): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(117): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(118): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(121): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(122): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(123): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(126): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(128): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(129): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(130): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(135): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(137): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(138): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(139): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(144): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(147): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(149): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(150): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(151): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(152): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(153): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(154): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(155): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(156): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(157): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(160): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(161): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(162): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(168): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(169): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(171): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(173): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(174): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(176): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(177): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(179): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(180): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(181): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(185): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(186): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(300): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(301): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(302): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(304): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(309): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(310): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(311): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(312): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(313): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(314): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(315): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(316): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(317): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(319): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(323): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(324): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(325): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(326): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(328): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(329): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(331): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(335): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(339): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(340): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(341): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(342): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(344): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(345): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(346): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(349): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(350): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(353): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(354): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(356): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(363): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(364): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
                                 .list
                                 
                                 init:
                                 	//MAIN CLOCK
00135b edc8                      	ldi r28, CPU_CCP_IOREG_gc //protected write
00135c 93c0 0034                 	sts CPU_CCP, r28
00135e e0c0                      	ldi r28, 0 << CLKCTRL_PEN_bp //disable prescaler for 20 MHz on main clock
00135f 93c0 0061                 	sts CLKCTRL_MCLKCTRLB, r28
                                 
                                 	//ZERO
001361 2422                      	clr zero
                                 	//ONE
001362 e0c1                      	ldi r28, 1
001363 2e3c                      	mov one, r28
                                 	//FRAME SEQUENCE
001364 2c42                      	mov frame_sequence, zero
                                 
                                 	//MEMORY
001365 e3c0                      	ldi r28, 0b00110000
001366 93c0 2800                 	sts pulse1_param, r28
001368 e8c0                      	ldi r28, 0b10000000
001369 93c0 2801                 	sts pulse1_sweep_param, r28
00136b efcf                      	ldi r28, 0xFF
00136c 93c0 2802                 	sts pulse1_timerL, r28
00136e 93c0 2803                 	sts pulse1_timerH, r28
001370 93c0 2804                 	sts pulse1_length, r28
                                 
001372 e3c0                      	ldi r28, 0b00110000
001373 93c0 2808                 	sts pulse2_param, r28
001375 e8c0                      	ldi r28, 0b10000000
001376 93c0 2809                 	sts pulse2_sweep_param, r28
001378 efcf                      	ldi r28, 0xFF
001379 93c0 280a                 	sts pulse2_timerL, r28
00137b 93c0 280b                 	sts pulse2_timerH, r28
00137d 93c0 280c                 	sts pulse2_length, r28
                                 
00137f efcf                      	ldi r28, 0xFF
001380 93c0 2810                 	sts triangle_timerL, r28
001382 93c0 2811                 	sts triangle_timerH, r28
                                 
001384 e3c0                      	ldi r28, 0b00110000
001385 93c0 2813                 	sts noise_param, r28
001387 e0cf                      	ldi r28, 0b00001111
001388 93c0 2814                 	sts noise_period, r28
                                 
00138a e0c2                      	ldi r28, 0x02
00138b 93c0 281b                 	sts song_frame_offset, r28
00138d 9220 281c                 	sts song_frame_offset+1, zero
00138f efcf                      	ldi r28, 0xFF
001390 93c0 2820                 	sts song_fx_Bxx, r28
001392 9220 2821                 	sts song_fx_Cxx, zero
001394 9220 2822                 	sts song_fx_Dxx, zero
001396 e4ee                      	ldi ZL, LOW(song0_frames << 1)
001397 e0f3                      	ldi ZH, HIGH(song0_frames << 1)
001398 93e0 2819                 	sts song_frames, ZL
00139a 93f0 281a                 	sts song_frames+1, ZH
00139c 91c5                      	lpm r28, Z+ //load the song size
00139d 91d5                      	lpm r29, Z+
00139e 93c0 281d                 	sts song_size, r28
0013a0 93d0 281e                 	sts song_size+1, r29
0013a2 9220 281f                 	sts song_speed, zero
                                 
                                 	//CHANNEL 0
0013a4 91c5                      	lpm r28, Z+
0013a5 91d5                      	lpm r29, Z+
0013a6 0fcc                      	lsl r28
0013a7 1fdd                      	rol r29
0013a8 93c0 2823                 	sts pulse1_pattern, r28
0013aa 93d0 2824                 	sts pulse1_pattern+1, r29
0013ac 9220 2825                 	sts pulse1_pattern_delay_rows, zero
0013ae 9220 2826                 	sts pulse1_pattern_delay_frames, zero
0013b0 9220 2827                 	sts pulse1_pattern_offset, zero
0013b2 9220 2828                 	sts pulse1_pattern_offset+1, zero
                                 
                                 	//CHANNEL 1
0013b4 91c5                      	lpm r28, Z+
0013b5 91d5                      	lpm r29, Z+
0013b6 0fcc                      	lsl r28
0013b7 1fdd                      	rol r29
0013b8 93c0 2874                 	sts pulse2_pattern, r28
0013ba 93d0 2875                 	sts pulse2_pattern+1, r29
0013bc 9220 2876                 	sts pulse2_pattern_delay_rows, zero
0013be 9220 2877                 	sts pulse2_pattern_delay_frames, zero
0013c0 9220 2878                 	sts pulse2_pattern_offset, zero
0013c2 9220 2879                 	sts pulse2_pattern_offset+1, zero
                                 
                                 	//CHANNEL 2
0013c4 91c5                      	lpm r28, Z+
0013c5 91d5                      	lpm r29, Z+
0013c6 0fcc                      	lsl r28
0013c7 1fdd                      	rol r29
0013c8 93c0 28c5                 	sts triangle_pattern, r28
0013ca 93d0 28c6                 	sts triangle_pattern+1, r29
0013cc 9220 28c7                 	sts triangle_pattern_delay_rows, zero
0013ce 9220 28c8                 	sts triangle_pattern_delay_frames, zero
0013d0 9220 28c9                 	sts triangle_pattern_offset, zero
0013d2 9220 28ca                 	sts triangle_pattern_offset+1, zero
                                 
                                 	//CHANNEL 3
0013d4 91c5                      	lpm r28, Z+
0013d5 91d5                      	lpm r29, Z+
0013d6 0fcc                      	lsl r28
0013d7 1fdd                      	rol r29
0013d8 93c0 2911                 	sts noise_pattern, r28
0013da 93d0 2912                 	sts noise_pattern+1, r29
0013dc 9220 2913                 	sts noise_pattern_delay_rows, zero
0013de 9220 2914                 	sts noise_pattern_delay_frames, zero
0013e0 9220 2915                 	sts noise_pattern_offset, zero
0013e2 9220 2916                 	sts noise_pattern_offset+1, zero
                                 
                                 	//CHANNEL 4
0013e4 91c5                      	lpm r28, Z+
0013e5 91d5                      	lpm r29, Z+
0013e6 0fcc                      	lsl r28
0013e7 1fdd                      	rol r29
0013e8 93c0 2948                 	sts dpcm_pattern, r28
0013ea 93d0 2949                 	sts dpcm_pattern+1, r29
0013ec 9220 294a                 	sts dpcm_pattern_delay_rows, zero
0013ee 9220 294b                 	sts dpcm_pattern_delay_frames, zero
0013f0 9220 294c                 	sts dpcm_pattern_offset, zero
0013f2 9220 294d                 	sts dpcm_pattern_offset+1, zero
                                 
                                 	//CHANNEL 0 instrument macros
0013f4 efcf                      	ldi r28, 0xFF
0013f5 9220 282b                 	sts pulse1_volume_macro_offset, zero
0013f7 93c0 282c                 	sts pulse1_volume_macro_loop, r28
0013f9 93c0 282d                 	sts pulse1_volume_macro_release, r28
0013fb 9220 2830                 	sts pulse1_arpeggio_macro_offset, zero
0013fd 93c0 2831                 	sts pulse1_arpeggio_macro_loop, r28
0013ff 93c0 2832                 	sts pulse1_arpeggio_macro_release, r28
001401 93c0 2833                 	sts pulse1_arpeggio_macro_mode, r28
001403 9220 2838                 	sts pulse1_pitch_macro_offset, zero
001405 93c0 2839                 	sts pulse1_pitch_macro_loop, r28
001407 93c0 283a                 	sts pulse1_pitch_macro_release, r28
001409 9220 283e                 	sts pulse1_hi_pitch_macro_offset, zero
00140b 93c0 283f                 	sts pulse1_hi_pitch_macro_loop, r28
00140d 93c0 2840                 	sts pulse1_hi_pitch_macro_release, r28
00140f 9220 2843                 	sts pulse1_duty_macro_offset, zero
001411 93c0 2844                 	sts pulse1_duty_macro_loop, r28
001413 93c0 2845                 	sts pulse1_duty_macro_release, r28
                                 
001415 9220 2829                 	sts pulse1_volume_macro, zero
001417 9220 282a                 	sts pulse1_volume_macro+1, zero
001419 9220 282e                 	sts pulse1_arpeggio_macro, zero
00141b 9220 282f                 	sts pulse1_arpeggio_macro+1, zero
00141d 9220 2834                 	sts pulse1_total_pitch_offset, zero
00141f 9220 2835                 	sts pulse1_total_pitch_offset+1, zero
001421 9220 2836                 	sts pulse1_pitch_macro, zero
001423 9220 2837                 	sts pulse1_pitch_macro+1, zero
001425 9220 283b                 	sts pulse1_total_hi_pitch_offset, zero
001427 9220 283c                 	sts pulse1_hi_pitch_macro, zero
001429 9220 283d                 	sts pulse1_hi_pitch_macro+1, zero
00142b 9220 2841                 	sts pulse1_duty_macro, zero
00142d 9220 2842                 	sts pulse1_duty_macro+1, zero
                                 
                                 	//CHANNEL 0 ENVELOPE
00142f e00f                      	ldi pulse1_volume_divider, 0x0F
001430 9110 2800                 	lds pulse1_volume_decay, pulse1_param
001432 701f                      	andi pulse1_volume_decay, 0x0F //mask for VVVV bits
001433 9190 2800                 	lds pulse_channel_flags, pulse1_param
001435 7390                      	andi pulse_channel_flags, 0b00110000
001436 6490                      	sbr pulse_channel_flags, 0b01000000 //set start flag
001437 9220 2806                 	sts pulse1_output_volume, zero
001439 93c0 2805                 	sts pulse1_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 0 LENGTH
00143b 2e8c                      	mov pulse1_length_counter, r28
                                 
                                 	//CHANNEL 0 SEQUENCE
00143c e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
00143d 2e7c                      	mov pulse1_sequence, r28
                                 
                                 	//CHANNEL 0 SWEEP
00143e 9090 2801                 	lds pulse1_sweep, pulse1_sweep_param
001440 9492                      	swap pulse1_sweep //swap data from high byte and low byte
001441 6890                      	sbr pulse_channel_flags, 0b10000000 //set reload flag
                                 
                                 	//CHANNEL 0 FX
001442 efcf                      	ldi r28, 0xFF
001443 9220 2846                 	sts pulse1_fx_0xy_sequence, zero
001445 9220 2847                 	sts pulse1_fx_0xy_sequence+1, zero
001447 9220 2848                 	sts pulse1_fx_1xx, zero
001449 9220 2849                 	sts pulse1_fx_1xx+1, zero
00144b 9220 284a                 	sts pulse1_fx_1xx_total, zero
00144d 9220 284b                 	sts pulse1_fx_1xx_total+1, zero
00144f 9220 284c                 	sts pulse1_fx_2xx, zero
001451 9220 284d                 	sts pulse1_fx_2xx+1, zero
001453 9220 284e                 	sts pulse1_fx_2xx_total, zero
001455 9220 284f                 	sts pulse1_fx_2xx_total+1, zero
001457 9220 2850                 	sts pulse1_fx_3xx_start, zero
001459 9220 2851                 	sts pulse1_fx_3xx_start+1, zero
00145b 9220 2852                 	sts pulse1_fx_3xx_target, zero
00145d 9220 2853                 	sts pulse1_fx_3xx_target+1, zero
00145f 9220 2854                 	sts pulse1_fx_3xx_speed, zero
001461 9220 2855                 	sts pulse1_fx_3xx_speed+1, zero
001463 9220 2856                 	sts pulse1_fx_3xx_total_offset, zero
001465 9220 2857                 	sts pulse1_fx_3xx_total_offset+1, zero
001467 9220 2858                 	sts pulse1_fx_4xy_speed, zero
001469 9220 2859                 	sts pulse1_fx_4xy_depth, zero
00146b 9220 285a                 	sts pulse1_fx_4xy_phase, zero
00146d 9220 285b                 	sts pulse1_fx_7xy_speed, zero
00146f 9220 285c                 	sts pulse1_fx_7xy_depth, zero
001471 9220 285d                 	sts pulse1_fx_7xy_phase, zero
001473 9220 285e                 	sts pulse1_fx_7xy_value, zero
001475 9220 285f                 	sts pulse1_fx_Axy, zero
001477 93c0 2860                 	sts pulse1_fx_Gxx_pre, r28
001479 93c0 2861                 	sts pulse1_fx_Gxx_post, r28
00147b 9220 2862                 	sts pulse1_fx_Pxx_total, zero
00147d 9220 2863                 	sts pulse1_fx_Pxx_total+1, zero
00147f 9220 2864                 	sts pulse1_fx_Qxy_target_note, zero
001481 9220 2865                 	sts pulse1_fx_Qxy_target, zero
001483 9220 2866                 	sts pulse1_fx_Qxy_target+1, zero
001485 9220 2867                 	sts pulse1_fx_Qxy_speed, zero
001487 9220 2868                 	sts pulse1_fx_Qxy_speed+1, zero
001489 9220 2869                 	sts pulse1_fx_Qxy_total_offset, zero
00148b 9220 286a                 	sts pulse1_fx_Qxy_total_offset+1, zero
00148d 9220 286b                 	sts pulse1_fx_Rxy_target_note, zero
00148f 9220 286c                 	sts pulse1_fx_Rxy_target, zero
001491 9220 286d                 	sts pulse1_fx_Rxy_target+1, zero
001493 9220 286e                 	sts pulse1_fx_Rxy_speed, zero
001495 9220 286f                 	sts pulse1_fx_Rxy_speed+1, zero
001497 9220 2870                 	sts pulse1_fx_Rxy_total_offset, zero
001499 9220 2871                 	sts pulse1_fx_Rxy_total_offset+1, zero
00149b 93c0 2872                 	sts pulse1_fx_Sxx_pre, r28
00149d 93c0 2873                 	sts pulse1_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 1 instrument macros
00149f efcf                      	ldi r28, 0xFF
0014a0 9220 287c                 	sts pulse2_volume_macro_offset, zero
0014a2 93c0 287d                 	sts pulse2_volume_macro_loop, r28
0014a4 93c0 287e                 	sts pulse2_volume_macro_release, r28
0014a6 9220 2881                 	sts pulse2_arpeggio_macro_offset, zero
0014a8 93c0 2882                 	sts pulse2_arpeggio_macro_loop, r28
0014aa 93c0 2883                 	sts pulse2_arpeggio_macro_release, r28
0014ac 93c0 2884                 	sts pulse2_arpeggio_macro_mode, r28
0014ae 9220 2889                 	sts pulse2_pitch_macro_offset, zero
0014b0 93c0 288a                 	sts pulse2_pitch_macro_loop, r28
0014b2 93c0 288b                 	sts pulse2_pitch_macro_release, r28
0014b4 9220 288f                 	sts pulse2_hi_pitch_macro_offset, zero
0014b6 93c0 2890                 	sts pulse2_hi_pitch_macro_loop, r28
0014b8 93c0 2891                 	sts pulse2_hi_pitch_macro_release, r28
0014ba 9220 2894                 	sts pulse2_duty_macro_offset, zero
0014bc 93c0 2895                 	sts pulse2_duty_macro_loop, r28
0014be 93c0 2896                 	sts pulse2_duty_macro_release, r28
                                 
0014c0 9220 287a                 	sts pulse2_volume_macro, zero
0014c2 9220 287b                 	sts pulse2_volume_macro+1, zero
0014c4 9220 287f                 	sts pulse2_arpeggio_macro, zero
0014c6 9220 2880                 	sts pulse2_arpeggio_macro+1, zero
0014c8 9220 2885                 	sts pulse2_total_pitch_offset, zero
0014ca 9220 2886                 	sts pulse2_total_pitch_offset+1, zero
0014cc 9220 2887                 	sts pulse2_pitch_macro, zero
0014ce 9220 2888                 	sts pulse2_pitch_macro+1, zero
0014d0 9220 288c                 	sts pulse2_total_hi_pitch_offset, zero
0014d2 9220 288d                 	sts pulse2_hi_pitch_macro, zero
0014d4 9220 288e                 	sts pulse2_hi_pitch_macro+1, zero
0014d6 9220 2892                 	sts pulse2_duty_macro, zero
0014d8 9220 2893                 	sts pulse2_duty_macro+1, zero
                                 
                                 	//CHANNEL 1 ENVELOPE
0014da e02f                      	ldi pulse2_volume_divider, 0x0F
0014db 9130 2808                 	lds pulse2_volume_decay, pulse2_param
0014dd 703f                      	andi pulse2_volume_decay, 0x0F //mask for VVVV bits
0014de 91d0 2808                 	lds r29, pulse2_param
0014e0 73d0                      	andi r29, 0b00110000
0014e1 62d0                      	sbr r29, 0b0100000 //set start flag
0014e2 95d2                      	swap r29
0014e3 2b9d                      	or pulse_channel_flags, r29
0014e4 9220 280e                 	sts pulse2_output_volume, zero
0014e6 93c0 280d                 	sts pulse2_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 1 LENGTH
0014e8 2ebc                      	mov pulse2_length_counter, r28
                                 
                                 	//CHANNEL 1 SEQUENCE
0014e9 e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
0014ea 2eac                      	mov pulse2_sequence, r28
                                 
                                 	//CHANNEL 1 SWEEP
0014eb 90c0 2809                 	lds pulse2_sweep, pulse2_sweep_param
0014ed 94c2                      	swap pulse2_sweep //swap data from high byte and low byte
0014ee 6098                      	sbr pulse_channel_flags, 0b00001000 //set reload flag
                                 
                                 	//CHANNEL 1 FX
0014ef efcf                      	ldi r28, 0xFF
0014f0 9220 2897                 	sts pulse2_fx_0xy_sequence, zero
0014f2 9220 2898                 	sts pulse2_fx_0xy_sequence+1, zero
0014f4 9220 2899                 	sts pulse2_fx_1xx, zero
0014f6 9220 289a                 	sts pulse2_fx_1xx+1, zero
0014f8 9220 289b                 	sts pulse2_fx_1xx_total, zero
0014fa 9220 289c                 	sts pulse2_fx_1xx_total+1, zero
0014fc 9220 289d                 	sts pulse2_fx_2xx, zero
0014fe 9220 289e                 	sts pulse2_fx_2xx+1, zero
001500 9220 289f                 	sts pulse2_fx_2xx_total, zero
001502 9220 28a0                 	sts pulse2_fx_2xx_total+1, zero
001504 9220 28a1                 	sts pulse2_fx_3xx_start, zero
001506 9220 28a2                 	sts pulse2_fx_3xx_start+1, zero
001508 9220 28a3                 	sts pulse2_fx_3xx_target, zero
00150a 9220 28a4                 	sts pulse2_fx_3xx_target+1, zero
00150c 9220 28a5                 	sts pulse2_fx_3xx_speed, zero
00150e 9220 28a6                 	sts pulse2_fx_3xx_speed+1, zero
001510 9220 28a7                 	sts pulse2_fx_3xx_total_offset, zero
001512 9220 28a8                 	sts pulse2_fx_3xx_total_offset+1, zero
001514 9220 28a9                 	sts pulse2_fx_4xy_speed, zero
001516 9220 28aa                 	sts pulse2_fx_4xy_depth, zero
001518 9220 28ab                 	sts pulse2_fx_4xy_phase, zero
00151a 9220 28ac                 	sts pulse2_fx_7xy_speed, zero
00151c 9220 28ad                 	sts pulse2_fx_7xy_depth, zero
00151e 9220 28ae                 	sts pulse2_fx_7xy_phase, zero
001520 9220 28af                 	sts pulse2_fx_7xy_value, zero
001522 9220 28b0                 	sts pulse2_fx_Axy, zero
001524 93c0 28b1                 	sts pulse2_fx_Gxx_pre, r28
001526 93c0 28b2                 	sts pulse2_fx_Gxx_post, r28
001528 9220 28b3                 	sts pulse2_fx_Pxx_total, zero
00152a 9220 28b4                 	sts pulse2_fx_Pxx_total+1, zero
00152c 9220 28b5                 	sts pulse2_fx_Qxy_target_note, zero
00152e 9220 28b6                 	sts pulse2_fx_Qxy_target, zero
001530 9220 28b7                 	sts pulse2_fx_Qxy_target+1, zero
001532 9220 28b8                 	sts pulse2_fx_Qxy_speed, zero
001534 9220 28b9                 	sts pulse2_fx_Qxy_speed+1, zero
001536 9220 28ba                 	sts pulse2_fx_Qxy_total_offset, zero
001538 9220 28bb                 	sts pulse2_fx_Qxy_total_offset+1, zero
00153a 9220 28bc                 	sts pulse2_fx_Rxy_target_note, zero
00153c 9220 28bd                 	sts pulse2_fx_Rxy_target, zero
00153e 9220 28be                 	sts pulse2_fx_Rxy_target+1, zero
001540 9220 28bf                 	sts pulse2_fx_Rxy_speed, zero
001542 9220 28c0                 	sts pulse2_fx_Rxy_speed+1, zero
001544 9220 28c1                 	sts pulse2_fx_Rxy_total_offset, zero
001546 9220 28c2                 	sts pulse2_fx_Rxy_total_offset+1, zero
001548 93c0 28c3                 	sts pulse2_fx_Sxx_pre, r28
00154a 93c0 28c4                 	sts pulse2_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 2 instrument macros
00154c efcf                      	ldi r28, 0xFF
00154d 9220 28cd                 	sts triangle_volume_macro_offset, zero
00154f 93c0 28ce                 	sts triangle_volume_macro_loop, r28
001551 93c0 28cf                 	sts triangle_volume_macro_release, r28
001553 9220 28d2                 	sts triangle_arpeggio_macro_offset, zero
001555 93c0 28d3                 	sts triangle_arpeggio_macro_loop, r28
001557 93c0 28d4                 	sts triangle_arpeggio_macro_release, r28
001559 93c0 28d5                 	sts triangle_arpeggio_macro_mode, r28
00155b 9220 28da                 	sts triangle_pitch_macro_offset, zero
00155d 93c0 28db                 	sts triangle_pitch_macro_loop, r28
00155f 93c0 28dc                 	sts triangle_pitch_macro_release, r28
001561 9220 28e0                 	sts triangle_hi_pitch_macro_offset, zero
001563 93c0 28e1                 	sts triangle_hi_pitch_macro_loop, r28
001565 93c0 28e2                 	sts triangle_hi_pitch_macro_release, r28
001567 9220 28e5                 	sts triangle_duty_macro_offset, zero
001569 93c0 28e6                 	sts triangle_duty_macro_loop, r28
00156b 93c0 28e7                 	sts triangle_duty_macro_release, r28
                                 
00156d 9220 28cb                 	sts triangle_volume_macro, zero
00156f 9220 28cc                 	sts triangle_volume_macro+1, zero
001571 9220 28d0                 	sts triangle_arpeggio_macro, zero
001573 9220 28d1                 	sts triangle_arpeggio_macro+1, zero
001575 9220 28d6                 	sts triangle_total_pitch_offset, zero
001577 9220 28d7                 	sts triangle_total_pitch_offset+1, zero
001579 9220 28d8                 	sts triangle_pitch_macro, zero
00157b 9220 28d9                 	sts triangle_pitch_macro+1, zero
00157d 9220 28dd                 	sts triangle_total_hi_pitch_offset, zero
00157f 9220 28de                 	sts triangle_hi_pitch_macro, zero
001581 9220 28df                 	sts triangle_hi_pitch_macro+1, zero
001583 9220 28e3                 	sts triangle_duty_macro, zero
001585 9220 28e4                 	sts triangle_duty_macro+1, zero
                                 
                                 	//CHANNEL 2 SEQUENCE
001587 e0c0                      	ldi r28, 0b00000000 //reset sequence to 0
001588 2f4c                      	mov triangle_sequence, r28
                                 
                                 	//CHANNEL 2 FX
001589 efcf                      	ldi r28, 0xFF
00158a 9220 28e8                 	sts triangle_fx_0xy_sequence, zero
00158c 9220 28e9                 	sts triangle_fx_0xy_sequence+1, zero
00158e 9220 28ea                 	sts triangle_fx_1xx, zero
001590 9220 28eb                 	sts triangle_fx_1xx+1, zero
001592 9220 28ec                 	sts triangle_fx_1xx_total, zero
001594 9220 28ed                 	sts triangle_fx_1xx_total+1, zero
001596 9220 28ee                 	sts triangle_fx_2xx, zero
001598 9220 28ef                 	sts triangle_fx_2xx+1, zero
00159a 9220 28f0                 	sts triangle_fx_2xx_total, zero
00159c 9220 28f1                 	sts triangle_fx_2xx_total+1, zero
00159e 9220 28f2                 	sts triangle_fx_3xx_start, zero
0015a0 9220 28f3                 	sts triangle_fx_3xx_start+1, zero
0015a2 9220 28f4                 	sts triangle_fx_3xx_target, zero
0015a4 9220 28f5                 	sts triangle_fx_3xx_target+1, zero
0015a6 9220 28f6                 	sts triangle_fx_3xx_speed, zero
0015a8 9220 28f7                 	sts triangle_fx_3xx_speed+1, zero
0015aa 9220 28f8                 	sts triangle_fx_3xx_total_offset, zero
0015ac 9220 28f9                 	sts triangle_fx_3xx_total_offset+1, zero
0015ae 9220 28fa                 	sts triangle_fx_4xy_speed, zero
0015b0 9220 28fb                 	sts triangle_fx_4xy_depth, zero
0015b2 9220 28fc                 	sts triangle_fx_4xy_phase, zero
0015b4 93c0 28fd                 	sts triangle_fx_Gxx_pre, r28
0015b6 93c0 28fe                 	sts triangle_fx_Gxx_post, r28
0015b8 9220 28ff                 	sts triangle_fx_Pxx_total, zero
0015ba 9220 2900                 	sts triangle_fx_Pxx_total+1, zero
0015bc 9220 2901                 	sts triangle_fx_Qxy_target_note, zero
0015be 9220 2902                 	sts triangle_fx_Qxy_target, zero
0015c0 9220 2903                 	sts triangle_fx_Qxy_target+1, zero
0015c2 9220 2904                 	sts triangle_fx_Qxy_speed, zero
0015c4 9220 2905                 	sts triangle_fx_Qxy_speed+1, zero
0015c6 9220 2906                 	sts triangle_fx_Qxy_total_offset, zero
0015c8 9220 2907                 	sts triangle_fx_Qxy_total_offset+1, zero
0015ca 9220 2908                 	sts triangle_fx_Rxy_target_note, zero
0015cc 9220 2909                 	sts triangle_fx_Rxy_target, zero
0015ce 9220 290a                 	sts triangle_fx_Rxy_target+1, zero
0015d0 9220 290b                 	sts triangle_fx_Rxy_speed, zero
0015d2 9220 290c                 	sts triangle_fx_Rxy_speed+1, zero
0015d4 9220 290d                 	sts triangle_fx_Rxy_total_offset, zero
0015d6 9220 290e                 	sts triangle_fx_Rxy_total_offset+1, zero
0015d8 93c0 290f                 	sts triangle_fx_Sxx_pre, r28
0015da 93c0 2910                 	sts triangle_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 3 instrument macros
0015dc efcf                      	ldi r28, 0xFF
0015dd 9220 2919                 	sts noise_volume_macro_offset, zero
0015df 93c0 291a                 	sts noise_volume_macro_loop, r28
0015e1 93c0 291b                 	sts noise_volume_macro_release, r28
0015e3 9220 291e                 	sts noise_arpeggio_macro_offset, zero
0015e5 93c0 291f                 	sts noise_arpeggio_macro_loop, r28
0015e7 93c0 2920                 	sts noise_arpeggio_macro_release, r28
0015e9 93c0 2921                 	sts noise_arpeggio_macro_mode, r28
0015eb 9220 2926                 	sts noise_pitch_macro_offset, zero
0015ed 93c0 2927                 	sts noise_pitch_macro_loop, r28
0015ef 93c0 2928                 	sts noise_pitch_macro_release, r28
0015f1 9220 292c                 	sts noise_hi_pitch_macro_offset, zero
0015f3 93c0 292d                 	sts noise_hi_pitch_macro_loop, r28
0015f5 93c0 292e                 	sts noise_hi_pitch_macro_release, r28
0015f7 9220 2931                 	sts noise_duty_macro_offset, zero
0015f9 93c0 2932                 	sts noise_duty_macro_loop, r28
0015fb 93c0 2933                 	sts noise_duty_macro_release, r28
                                 
0015fd 9220 2917                 	sts noise_volume_macro, zero
0015ff 9220 2918                 	sts noise_volume_macro+1, zero
001601 9220 291c                 	sts noise_arpeggio_macro, zero
001603 9220 291d                 	sts noise_arpeggio_macro+1, zero
001605 9220 2922                 	sts noise_total_pitch_offset, zero
001607 9220 2923                 	sts noise_total_pitch_offset+1, zero
001609 9220 2924                 	sts noise_pitch_macro, zero
00160b 9220 2925                 	sts noise_pitch_macro+1, zero
00160d 9220 2929                 	sts noise_total_hi_pitch_offset, zero
00160f 9220 292a                 	sts noise_hi_pitch_macro, zero
001611 9220 292b                 	sts noise_hi_pitch_macro+1, zero
001613 9220 292f                 	sts noise_duty_macro, zero
001615 9220 2930                 	sts noise_duty_macro+1, zero
                                 
                                 	//CHANNEL 3 VOLUME
001617 9220 2816                 	sts noise_output_volume, zero
001619 93c0 2815                 	sts noise_fractional_volume, r28 //initialize fractional volume to max value
                                 
                                 	//CHANNEL 3 SEQUENCE
00161b e0c1                      	ldi r28, 0b00000001 //noise sequence is reset to 0x0001
00161c 2f5c                      	mov noise_sequence_LOW, r28
00161d 2d62                      	mov noise_sequence_HIGH, zero
                                 
                                 	//CHANNEL 3 FX
00161e efcf                      	ldi r28, 0xFF
00161f 9220 2934                 	sts noise_fx_0xy_sequence, zero
001621 9220 2935                 	sts noise_fx_0xy_sequence+1, zero
001623 9220 2936                 	sts noise_fx_1xx, zero
001625 9220 2937                 	sts noise_fx_1xx_total, zero
001627 9220 2938                 	sts noise_fx_2xx, zero
001629 9220 2939                 	sts noise_fx_2xx_total, zero
00162b 9220 293a                 	sts noise_fx_4xy_speed, zero
00162d 9220 293b                 	sts noise_fx_4xy_depth, zero
00162f 9220 293c                 	sts noise_fx_4xy_phase, zero
001631 9220 293d                 	sts noise_fx_4xy_offset, zero
001633 9220 293e                 	sts noise_fx_7xy_speed, zero
001635 9220 293f                 	sts noise_fx_7xy_depth, zero
001637 9220 2940                 	sts noise_fx_7xy_phase, zero
001639 9220 2941                 	sts noise_fx_7xy_value, zero
00163b 9220 2942                 	sts noise_fx_Axy, zero
00163d 93c0 2943                 	sts noise_fx_Gxx_pre, r28
00163f 93c0 2944                 	sts noise_fx_Gxx_post, r28
001641 9220 2945                 	sts noise_fx_Pxx_total, zero
001643 93c0 2946                 	sts noise_fx_Sxx_pre, r28
001645 93c0 2947                 	sts noise_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 4 SAMPLE
001647 9220 294e                 	sts dpcm_sample, zero
001649 9220 294f                 	sts dpcm_sample+1, zero
00164b 9220 2950                 	sts dpcm_sample_offset, zero
00164d 9220 2951                 	sts dpcm_sample_offset+1, zero
00164f 2cd2                      	mov dpcm_shift, zero
001650 2ce2                      	mov dpcm_bit_counter, zero
001651 2cf2                      	mov dpcm_period, zero
001652 2d72                      	mov dpcm_length_LOW, zero
001653 2d82                      	mov dpcm_length_HIGH, zero
                                 
                                 	//CHANNEL 4 FX
001654 93c0 2943                 	sts noise_fx_Gxx_pre, r28
001656 93c0 2944                 	sts noise_fx_Gxx_post, r28
001658 93c0 2946                 	sts noise_fx_Sxx_pre, r28
00165a 93c0 2947                 	sts noise_fx_Sxx_post, r28
                                 
                                 	//PINS
00165c efcf                      	ldi r28, 0xFF
00165d b9c0                      	out VPORTA_DIR, r28 //set all pins in VPORTA to output
                                 
                                 	//TIMERS
                                 
                                 	//NOTE: Channel Timers are clocked (20/2)/(0.8948865) = 11.1746014718 times faster than the NES APU
                                 	//Because of this, we multiply all the NES timer values by 11.1746014718 beforehand
                                 	//Since we rotate the sequence when the timer goes from t-(t-1) to 0, instead of 0 to t like the NES, we add 1 to the NES timers before multiplying
                                 	//The ATmega4809 is configured to run at 20 MHz
                                 	//The /2 comes from the prescaler divider used
                                 	//0.8948865 MHz is the speed of the NTSC NES APU
                                 	//NOTE: This means that any offset to the pitch for the NES timers would be multiplied by 11.1746014718 aswell.
                                 	//Pulse 1
00165e e0c0                      	ldi r28, TCB_CNTMODE_INT_gc //interrupt mode
00165f 93c0 0a81                 	sts TCB0_CTRLB, r28
001661 e0c1                      	ldi r28, TCB_CAPT_bm //enable interrupts
001662 93c0 0a85                 	sts TCB0_INTCTRL, r28
001664 91c0 2802                 	lds r28, pulse1_timerL //load the LOW bits for timer
001666 93c0 0a8c                 	sts TCB0_CCMPL, r28
001668 91c0 2803                 	lds r28, pulse1_timerH //load the HIGH bits for timer
00166a 93c0 0a8d                 	sts TCB0_CCMPH, r28
00166c e0c3                      	ldi r28, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
00166d 93c0 0a80                 	sts TCB0_CTRLA, r28
                                 
                                 	//PULSE 2
00166f e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
001670 93b0 0a91                 	sts TCB1_CTRLB, r27
001672 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001673 93b0 0a95                 	sts TCB1_INTCTRL, r27
001675 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
001677 93b0 0a9c                 	sts TCB1_CCMPL, r27
001679 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
00167b 93b0 0a9d                 	sts TCB1_CCMPH, r27
00167d e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
00167e 93b0 0a90                 	sts TCB1_CTRLA, r27
                                 
                                 	//NOTE: The triangle timer is clocked at the same speed as the NES CPU, aka twice the NES APU.
                                 	//Therefore, we won't be using a /2 clock divider like we did with the pulse timers.
                                 	//TRIANGLE
001680 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
001681 93b0 0aa1                 	sts TCB2_CTRLB, r27
001683 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
                                 	//sts TCB2_INTCTRL, r27 //keep interrupts disabled to mute channel since triangle doesn't have volume bits
001684 91b0 2810                 	lds r27, triangle_timerL //load the LOW bits for timer
001686 93b0 0aac                 	sts TCB2_CCMPL, r27
001688 91b0 2811                 	lds r27, triangle_timerH //load the HIGH bits for timer
00168a 93b0 0aad                 	sts TCB2_CCMPH, r27
00168c e0b1                      	ldi r27, TCB_CLKSEL_CLKDIV1_gc | TCB_ENABLE_bm //use prescaler divider of 1 and enable timer
00168d 93b0 0aa0                 	sts TCB2_CTRLA, r27
00168f 9478                      	sei //global interrupt enable
                                 
                                 	//NOISE
001690 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
001691 93b0 0ab1                 	sts TCB3_CTRLB, r27
001693 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001694 93b0 0ab5                 	sts TCB3_INTCTRL, r27
001696 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
001698 93b0 0abc                 	sts TCB3_CCMPL, r27
00169a 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
00169c 93b0 0abd                 	sts TCB3_CCMPH, r27
00169e e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
00169f 93b0 0ab0                 	sts TCB3_CTRLA, r27
                                 
                                 	//DPCM
                                 /*	ldi r28, TCA_SINGLE_CMP0EN_bm | TCA_SINGLE_CMP1EN_bm | TCA_SINGLE_CMP2EN_bm | TCA_SINGLE_WGMODE_NORMAL_gc //interrupt mode
                                 	sts TCA0_SINGLE_CTRLB, r28
                                 	ldi r28, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP1_bm | TCA_SINGLE_CMP2_bm | TCA_SINGLE_OVF_bm //enable overflow and compare interrupts
                                 	sts TCA0_SINGLE_INTCTRL, r28
                                 	ldi r28, 0x15 //set the period for CMP0
                                 	sts TCA0_SINGLE_CMP0, r28
                                 	ldi r28, 0x05
                                 	sts TCA0_SINGLE_CMP0 + 1, r28
                                 	ldi r28, 0x2B //set the period for CMP1
                                 	sts TCA0_SINGLE_CMP1, r28
                                 	ldi r28, 0x0A
                                 	sts TCA0_SINGLE_CMP1 + 1, r28
                                 	ldi r28, 0x41 //set the period for CMP2
                                 	sts TCA0_SINGLE_CMP2, r28
                                 	ldi r28, 0x0F
                                 	sts TCA0_SINGLE_CMP2 + 1, r28
                                 	ldi r28, 0x57 //set the period for OVF
                                 	sts TCA0_SINGLE_PER, r28
                                 	ldi r28, 0x14
                                 	sts TCA0_SINGLE_PER + 1, r28
                                 	ldi r28, TCA_SINGLE_CLKSEL_DIV64_gc | TCA_SINGLE_ENABLE_bm //use prescale divider of 64 and enable timer
                                 	sts TCA0_SINGLE_CTRLA, r28*/
                                 
                                 	//RTC
                                 	//Frame Counter
                                 	//NOTE:The frame counter will be defaulted to NTSC mode (60 Hz, 120 Hz, 240 Hz)
                                 	//Interrupts will be setup to interrupt every 240 Hz clock
                                 	//The 4th consecutive interrupt will clock the sound driver every 60Hz, in which new audio data is read and written to the registers
                                 	//1st and 2nd interrupt will execute sequence 0 and 2. 3rd and 4th interrupt will execute sequence 1 and 3.
                                 	//Timer period Calculation: (0.00416666666 * 32768/8)-1 = 16.0666666394 = 0x0010
                                 	//The RTC timer is clocked at 32768 Hz
                                 	//0.00416666666 seconds is the period for 240 Hz
                                 	//The /8 comes from the prescaler divider used
0016a1 e0b0                      	ldi r27, RTC_CLKSEL_INT32K_gc //internal 32kHz oscillator
0016a2 93b0 0147                 	sts RTC_CLKSEL, r27
0016a4 e1b0                      	ldi r27, 0x10
0016a5 e0c0                      	ldi r28, 0x00
0016a6 93b0 014a                 	sts RTC_PER, r27
0016a8 93c0 014b                 	sts RTC_PER + 1, r28
0016aa e0b1                      	ldi r27, RTC_OVF_bm //overflow interrupts
0016ab 93b0 0142                 	sts RTC_INTCTRL, r27
0016ad e1b9                      	ldi r27, RTC_PRESCALER_DIV8_gc | RTC_PITEN_bm //use prescaler divider of 2 and enable RTC
0016ae 93b0 0140                 	sts RTC_CTRLA, r27
                                 
                                 
                                 
                                 //https://wiki.nesdev.com/w/index.php/APU_Mixer
                                 volume_mixer:
0016b0 91c0 2806                 	lds r28, pulse1_output_volume
0016b2 91d0 280e                 	lds r29, pulse2_output_volume
                                 
                                 volume_mixer_pulse1:
0016b4 fe70                      	sbrs pulse1_sequence, 0 //if the sequence output is zero, return
0016b5 c015                      	rjmp volume_mixer_pulse1_off
                                 
0016b6 1482                      	cp pulse1_length_counter, zero //if length is zero, return
0016b7 f099                      	breq volume_mixer_pulse1_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
0016b8 91e0 0a8c                 	lds r30, TCB0_CCMPL
0016ba e5f9                      	ldi r31, 0x59
0016bb 17ef                      	cp r30, r31
0016bc 91e0 0a8d                 	lds r30, TCB0_CCMPH
0016be e0f0                      	ldi r31, 0x00
0016bf 07ef                      	cpc r30, r31
0016c0 f050                      	brlo volume_mixer_pulse1_off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $595A
0016c1 91e0 0a8c                 	lds r30, TCB0_CCMPL
0016c3 e5fa                      	ldi r31, 0x5A
0016c4 17ef                      	cp r30, r31
0016c5 91e0 0a8d                 	lds r30, TCB0_CCMPH
0016c7 e5f9                      	ldi r31, 0x59
0016c8 07ef                      	cpc r30, r31
0016c9 f408                      	brsh volume_mixer_pulse1_off
0016ca c001                      	rjmp volume_mixer_pulse2 //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse1_off:
0016cb 27cc                      	clr r28
                                 
                                 volume_mixer_pulse2:
0016cc fea0                      	sbrs pulse2_sequence, 0 //if the sequence output is zero, return
0016cd c015                      	rjmp volume_mixer_pulse2_off
                                 
0016ce 14b2                      	cp pulse2_length_counter, zero //if length is zero, return
0016cf f099                      	breq volume_mixer_pulse2_off
                                 
0016d0 91e0 0a9c                 	lds r30, TCB1_CCMPL
0016d2 e5f9                      	ldi r31, 0x59
0016d3 17ef                      	cp r30, r31
0016d4 91e0 0a9d                 	lds r30, TCB1_CCMPH
0016d6 e0f0                      	ldi r31, 0x00
0016d7 07ef                      	cpc r30, r31
0016d8 f050                      	brlo volume_mixer_pulse2_off
                                 
0016d9 91e0 0a9c                 	lds r30, TCB1_CCMPL
0016db e5fa                      	ldi r31, 0x5A
0016dc 17ef                      	cp r30, r31
0016dd 91e0 0a9d                 	lds r30, TCB1_CCMPH
0016df e5f9                      	ldi r31, 0x59
0016e0 07ef                      	cpc r30, r31
0016e1 f408                      	brsh volume_mixer_pulse2_off
0016e2 c001                      	rjmp volume_mixer_pulse_out //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse2_off:
0016e3 27dd                      	clr r29
                                 
                                 volume_mixer_pulse_out:
0016e4 0fcd                      	add r28, r29
0016e5 e6e2                      	ldi ZL, LOW(pulse_volume_table << 1)
0016e6 e0f2                      	ldi ZH, HIGH(pulse_volume_table << 1)
0016e7 0fec                      	add ZL, r28
0016e8 1df2                      	adc ZH, zero
0016e9 91c4                      	lpm r28, Z
                                 
                                 volume_mixer_tnd_triangle:
0016ea 2fd4                      	mov r29, triangle_sequence
0016eb fdd4                      	sbrc r29, 4 //check 5th bit
0016ec 95d0                      	com r29
0016ed 70df                      	andi r29, 0x0F
0016ee 2fed                      	mov r30, r29
0016ef 0fde                      	add r29, r30 //multiply the triangle volume by 3
0016f0 0fde                      	add r29, r30
                                 
                                 volume_mixer_tnd_noise:
0016f1 ff50                      	sbrs noise_sequence_LOW, 0 //check 0th bit, skip if set
0016f2 c004                      	rjmp volume_mixer_tnd_out
0016f3 91e0 2816                 	lds r30, noise_output_volume
0016f5 0fee                      	lsl r30 //multiply noise volume by 2
0016f6 0fde                      	add r29, r30
                                 
                                 volume_mixer_tnd_out:
0016f7 e8e2                      	ldi ZL, LOW(tnd_volume_table << 1)
0016f8 e0f2                      	ldi ZH, HIGH(tnd_volume_table << 1)
0016f9 0fed                      	add ZL, r29
0016fa 1df2                      	adc ZH, zero
0016fb 91d4                      	lpm r29, Z
                                 
                                 volume_mixer_output:
0016fc 0fcd                      	add r28, r29
0016fd b9c1                      	out VPORTA_OUT, r28
0016fe cfb1                      	rjmp volume_mixer
                                 
                                 
                                 
                                 //FRAME COUNTER/AUDIO SAMPLE ISR
                                 frame_counter_routine:
0016ff b7bf                      	in r27, CPU_SREG
001700 93bf                      	push r27
001701 94f8                      	cli
                                 
001702 2da4                      	mov r26, frame_sequence
001703 0c43                      	add frame_sequence, one
001704 30a0                      	cpi r26, 0x00
001705 f029                      	breq sequence_0_2
001706 30a1                      	cpi r26, 0x01
001707 f059                      	breq sequence_1_3
001708 30a2                      	cpi r26, 0x02
001709 f009                      	breq sequence_0_2
00170a c0f3                      	rjmp sound_driver
                                 
                                 sequence_0_2:
                                 	//ENVELOPE
00170b d050                      	rcall pulse1_envelope_routine
00170c d09c                      	rcall pulse2_envelope_routine
                                 
00170d e0b3                      	ldi r27, RTC_CMP_bm | RTC_OVF_bm //clear OVF flag
00170e 93b0 0143                 	sts RTC_INTFLAGS, r27
001710 91bf                      	pop r27
001711 bfbf                      	out CPU_SREG, r27
001712 9518                      	reti
                                 
                                 sequence_1_3:
                                 	//ENVELOPE
001713 d048                      	rcall pulse1_envelope_routine
001714 d094                      	rcall pulse2_envelope_routine
                                 
                                 	//SWEEP
001715 fc93                      	sbrc pulse1_sweep, 3 //check if the sweep enable bit is cleared
001716 d01b                      	rcall pulse1_sweep_routine
001717 fcc3                      	sbrc pulse2_sweep, 3
001718 d066                      	rcall pulse2_sweep_routine
                                 
                                 	//LENGTH
                                 	//NOTE: The length routine is relatively simple, so we will not be using clocks to rjmp and ret to a seperate lable
                                 sequence_1_3_pulse1_length:
001719 fd95                      	sbrc pulse_channel_flags, 5 //check if the length counter halt bit is cleared
00171a c002                      	rjmp sequence_1_3_pulse2_length
00171b 1082                      	cpse pulse1_length_counter, zero //if length counter is already 0, don't decrement
00171c 948a                      	dec pulse1_length_counter
                                 sequence_1_3_pulse2_length:
00171d fd91                      	sbrc pulse_channel_flags, 1 //check if the length counter halt bit is cleared
00171e c002                      	rjmp sequence_1_3_exit
00171f 10b2                      	cpse pulse2_length_counter, zero //if length counter is already 0, don't decrement
001720 94ba                      	dec pulse2_length_counter
                                 
                                 sequence_1_3_exit:
001721 e0b1                      	ldi r27, RTC_OVF_bm //clear OVF flag
001722 93b0 0143                 	sts RTC_INTFLAGS, r27
001724 91bf                      	pop r27
001725 bfbf                      	out CPU_SREG, r27
001726 9518                      	reti
                                 
                                 //PULSE 1 ROUTINES
                                 pulse1_sequence_routine:
001727 b7bf                      	in r27, CPU_SREG
001728 93bf                      	push r27
001729 94f8                      	cli
                                 
00172a 0c77                      	lsl pulse1_sequence //shifts sequence to the left
00172b 1c72                      	adc pulse1_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
00172c e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
00172d 93b0 0a86                 	sts TCB0_INTFLAGS, r27
00172f 91bf                      	pop r27
001730 bfbf                      	out CPU_SREG, r27
001731 9518                      	reti
                                 
                                 pulse1_sweep_routine:
001732 2db9                      	mov r27, pulse1_sweep
001733 70b7                      	andi r27, 0x07 //mask for period divider bits
001734 f4f9                      	brne pulse1_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse1_sweep_routine_action: //if the divider is == 0, update the pulse timer period
001735 93df                      	push r29
001736 2dd9                      	mov r29, pulse1_sweep
001737 95d2                      	swap r29
001738 70d7                      	andi r29, 0x07 //mask for shift bits
001739 f411                      	brne pulse1_sweep_routine_action_main //shift != 0
00173a 91df                      	pop r29
00173b c019                      	rjmp pulse1_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse1_sweep_routine_action_main:
00173c 91a0 0a8c                 	lds r26, TCB0_CCMPL
00173e 91b0 0a8d                 	lds r27, TCB0_CCMPH
                                 pulse1_sweep_routine_action_main_loop:
001740 95b6                      	lsr r27
001741 95a7                      	ror r26
001742 95da                      	dec r29
001743 f7e1                      	brne pulse1_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
001744 fe97                      	sbrs pulse1_sweep, 7 //check the negate flag
001745 c002                      	rjmp pulse1_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
001746 95a0                      	com r26 //pulse1 uses one's complement if the negate flag is set
001747 95b0                      	com r27
                                 
                                 pulse1_sweep_routine_action_main_add:
001748 91d0 0a8c                 	lds r29, TCB0_CCMPL //perform addition to get new timer period
00174a 0fad                      	add r26, r29
00174b 91d0 0a8d                 	lds r29, TCB0_CCMPH
00174d 1fbd                      	adc r27, r29
                                 
00174e 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new LOW bits for timer
001750 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new HIGH bits for timer
                                 	
001752 91df                      	pop r29
001753 c001                      	rjmp pulse1_sweep_routine_check_reload
                                 
                                 pulse1_sweep_routine_decrement_divider:
001754 949a                      	dec pulse1_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse1_sweep_routine_check_reload:
001755 ff97                      	sbrs pulse_channel_flags, 7 //if the reload flag is set, reload the sweep divider
001756 9508                      	ret
                                 
                                 pulse1_sweep_reload:
001757 9090 2801                 	lds pulse1_sweep, pulse1_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
001759 9492                      	swap pulse1_sweep //bring data from high byte to low byte
00175a 779f                      	cbr pulse_channel_flags, 0b10000000 //clear reload flag
00175b 9508                      	ret
                                 
                                 
                                 
                                 pulse1_envelope_routine:
00175c fd96                      	sbrc pulse_channel_flags, 6 //check if start flag is cleared
00175d c010                      	rjmp pulse1_envelope_routine_clear_start
                                 
00175e 3000                      	cpi pulse1_volume_divider, 0x00 //check if the divider is 0
00175f f011                      	breq PC+3 //if the divider == 0, check loop flag
001760 950a                      	dec pulse1_volume_divider //if the divider != 0, decrement and return
001761 9508                      	ret
                                 
001762 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the divider == 0, reset the divider period
001764 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
001765 ff95                      	sbrs pulse_channel_flags, 5 //check if the loop flag is set
001766 c002                      	rjmp pulse1_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
001767 e01f                      	ldi pulse1_volume_decay, 0x0F //if the loop flag is set, reset decay and return
001768 9508                      	ret
                                 
                                 pulse1_envelope_routine_decrement_decay:
001769 3010                      	cpi pulse1_volume_decay, 0x00 //check if the decay is 0
00176a f409                      	brne PC+2 //if decay != 0, go decrement
00176b 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
00176c 951a                      	dec pulse1_volume_decay
00176d 9508                      	ret
                                 
                                 pulse1_envelope_routine_clear_start:
00176e 7b9f                      	cbr pulse_channel_flags, 0b01000000 //if the start flag is set, clear it
00176f 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the start flag is set, reset the divider period
001771 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
001772 e01f                      	ldi pulse1_volume_decay, 0x0F //if the start flag is set, reset decay
001773 9508                      	ret
                                 
                                 //PULSE 2 ROUTINES
                                 pulse2_sequence_routine:
001774 b7bf                      	in r27, CPU_SREG
001775 93bf                      	push r27
001776 94f8                      	cli
                                 
001777 0caa                      	lsl pulse2_sequence //shifts sequence to the left
001778 1ca2                      	adc pulse2_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
001779 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
00177a 93b0 0a96                 	sts TCB1_INTFLAGS, r27
00177c 91bf                      	pop r27
00177d bfbf                      	out CPU_SREG, r27
00177e 9518                      	reti
                                 
                                 pulse2_sweep_routine:
00177f 2dbc                      	mov r27, pulse2_sweep
001780 70b7                      	andi r27, 0x07 //mask for period divider bits
001781 f4f9                      	brne pulse2_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse2_sweep_routine_action: //if the divider is == 0, update the pulse timer period
001782 93df                      	push r29
001783 2ddc                      	mov r29, pulse2_sweep
001784 95d2                      	swap r29
001785 70d7                      	andi r29, 0x07 //mask for shift bits
001786 f411                      	brne pulse2_sweep_routine_action_main //shift != 0
001787 91df                      	pop r29
001788 c019                      	rjmp pulse2_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse2_sweep_routine_action_main:
001789 91a0 0a9c                 	lds r26, TCB1_CCMPL
00178b 91b0 0a9d                 	lds r27, TCB1_CCMPH
                                 pulse2_sweep_routine_action_main_loop:
00178d 95b6                      	lsr r27
00178e 95a7                      	ror r26
00178f 95da                      	dec r29
001790 f7e1                      	brne pulse2_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
001791 fec7                      	sbrs pulse2_sweep, 7 //check the negate flag
001792 c002                      	rjmp pulse2_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
001793 95a0                      	com r26 //pulse2 uses one's complement if the negate flag is set
001794 95b0                      	com r27
                                 
                                 pulse2_sweep_routine_action_main_add:
001795 91d0 0a9c                 	lds r29, TCB1_CCMPL //perform addition to get new timer period
001797 0fad                      	add r26, r29
001798 91d0 0a9d                 	lds r29, TCB1_CCMPH
00179a 1fbd                      	adc r27, r29
                                 
00179b 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new LOW bits for timer
00179d 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new HIGH bits for timer
                                 	
00179f 91df                      	pop r29
0017a0 c001                      	rjmp pulse2_sweep_routine_check_reload
                                 
                                 pulse2_sweep_routine_decrement_divider:
0017a1 94ca                      	dec pulse2_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse2_sweep_routine_check_reload:
0017a2 ff93                      	sbrs pulse_channel_flags, 3 //if the reload flag is set, reload the sweep divider
0017a3 9508                      	ret
                                 
                                 pulse2_sweep_reload:
0017a4 90c0 2809                 	lds pulse2_sweep, pulse2_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
0017a6 94c2                      	swap pulse2_sweep //bring data from high byte to low byte
0017a7 7f97                      	cbr pulse_channel_flags, 0b00001000 //clear reload flag
0017a8 9508                      	ret
                                 
                                 
                                 
                                 pulse2_envelope_routine:
0017a9 fd92                      	sbrc pulse_channel_flags, 2 //check if start flag is cleared
0017aa c010                      	rjmp pulse2_envelope_routine_clear_start
                                 
0017ab 3020                      	cpi pulse2_volume_divider, 0x00 //check if the divider is 0
0017ac f011                      	breq PC+3 //if the divider == 0, check loop flag
0017ad 952a                      	dec pulse2_volume_divider //if the divider != 0, decrement and return
0017ae 9508                      	ret
                                 
0017af 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the divider == 0, reset the divider period
0017b1 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
0017b2 ff91                      	sbrs pulse_channel_flags, 1 //check if the loop flag is set
0017b3 c002                      	rjmp pulse2_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
0017b4 e03f                      	ldi pulse2_volume_decay, 0x0F //if the loop flag is set, reset decay and return
0017b5 9508                      	ret
                                 
                                 pulse2_envelope_routine_decrement_decay:
0017b6 3030                      	cpi pulse2_volume_decay, 0x00 //check if the decay is 0
0017b7 f409                      	brne PC+2 //if decay != 0, go decrement
0017b8 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
0017b9 953a                      	dec pulse2_volume_decay
0017ba 9508                      	ret
                                 
                                 pulse2_envelope_routine_clear_start:
0017bb 7f9b                      	cbr pulse_channel_flags, 0b00000100 //if the start flag is set, clear it
0017bc 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the start flag is set, reset the divider period
0017be 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
0017bf e03f                      	ldi pulse2_volume_decay, 0x0F //if the start flag is set, reset decay
0017c0 9508                      	ret
                                 
                                 //TRIANGLE ROUTINES
                                 triangle_sequence_routine:
0017c1 b7bf                      	in r27, CPU_SREG
0017c2 93bf                      	push r27
0017c3 94f8                      	cli
                                 
0017c4 5f4f                      	subi triangle_sequence, -1 //increment sequence by 1
0017c5 714f                      	andi triangle_sequence, 0b00011111 //mask out bits 5, 6 and 7 NOTE: the sequence only needs bits 0-4.
                                 
0017c6 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
0017c7 93b0 0aa6                 	sts TCB2_INTFLAGS, r27
0017c9 91bf                      	pop r27
0017ca bfbf                      	out CPU_SREG, r27
0017cb 9518                      	reti
                                 
                                 //NOISE ROUTINES
                                 noise_sequence_routine:
0017cc b7bf                      	in r27, CPU_SREG
0017cd 93bf                      	push r27
0017ce 94f8                      	cli
                                 
0017cf 2fa5                      	mov r26, noise_sequence_LOW
0017d0 fd67                      	sbrc noise_sequence_HIGH, 7 //skip if MODE bit is clear
0017d1 c00b                      	rjmp noise_sequence_routine_mode_set
                                 
                                 noise_sequence_routine_mode_clear:
0017d2 95a6                      	lsr r26 //move the 1th bit to the 0th bit place
0017d3 27a5                      	eor r26, noise_sequence_LOW
0017d4 fda0                      	sbrc r26, 0 //skip if the EOR of bit 0 and 1 is clear
0017d5 c003                      	rjmp noise_sequence_routine_mode_clear_EOR_set
                                 
                                 noise_sequence_routine_mode_clear_EOR_clear:
0017d6 9566                      	lsr noise_sequence_HIGH
0017d7 9557                      	ror noise_sequence_LOW
0017d8 c013                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_clear_EOR_set:
0017d9 9566                      	lsr noise_sequence_HIGH
0017da 9557                      	ror noise_sequence_LOW
0017db 6460                      	ori noise_sequence_HIGH, 0b01000000 //set the 14th bit
0017dc c00f                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_set:
0017dd 0faa                      	lsl r26
0017de 1faa                      	rol r26
0017df 1faa                      	rol r26 //move the 6th bit to the 0th bit place
0017e0 27a5                      	eor r26, noise_sequence_LOW
0017e1 fda0                      	sbrc r26, 0 //skip if the EOR of bit 0 and 1 is clear
0017e2 c005                      	rjmp noise_sequence_routine_mode_set_EOR_set
                                 
                                 noise_sequence_routine_mode_set_EOR_clear:
0017e3 776f                      	cbr noise_sequence_HIGH, 0b10000000 //clear the MODE flag
0017e4 9566                      	lsr noise_sequence_HIGH
0017e5 9557                      	ror noise_sequence_LOW
0017e6 6860                      	sbr noise_sequence_HIGH, 0b10000000 //set the MODE flag
0017e7 c004                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_set_EOR_set:
0017e8 9566                      	lsr noise_sequence_HIGH
0017e9 9557                      	ror noise_sequence_LOW
0017ea 6860                      	sbr noise_sequence_HIGH, 0b10000000 //set the MODE flag
0017eb c000                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_exit:
0017ec e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
0017ed 93b0 0ab6                 	sts TCB3_INTFLAGS, r27
0017ef 91bf                      	pop r27
0017f0 bfbf                      	out CPU_SREG, r27
0017f1 9518                      	reti
                                 
                                 //CONVERTERS
                                 //converts and loads 5 bit length to corresponding 8 bit length value into r29
                                 length_converter:
0017f2 e8e2                      	ldi ZL, LOW(length << 1)
0017f3 e6f2                      	ldi ZH, HIGH(length << 1)
0017f4 0fed                      	add ZL, r29
0017f5 1df2                      	adc ZH, zero
0017f6 91d4                      	lpm r29, Z
0017f7 9508                      	ret
                                 
                                 //loads pulse sequence into r29
                                 duty_cycle_sequences:
0017f8 eae2                      	ldi ZL, LOW(sequences << 1)
0017f9 e6f2                      	ldi ZH, HIGH(sequences << 1)
0017fa 0fed                      	add ZL, r29
0017fb 1df2                      	adc ZH, zero
0017fc 91d4                      	lpm r29, Z
0017fd 9508                      	ret
                                 
                                 
                                 
                                 //SOUND DRIVER
                                 sound_driver:
0017fe 2c42                      	mov frame_sequence, zero
0017ff 93cf                      	push r28
001800 93df                      	push r29
001801 93ef                      	push r30
001802 93ff                      	push r31
                                 
                                 	//SOUND DRIVER
001803 91a0 2820                 	lds r26, song_fx_Bxx
001805 3faf                      	cpi r26, 0xFF //0xFF means that the flag is disabled
001806 f4a9                      	brne sound_driver_fx_Bxx_routine
001807 91a0 2821                 	lds r26, song_fx_Cxx
001809 11a2                      	cpse r26, zero
00180a c08b                      	rjmp sound_driver_fx_Cxx_routine
00180b 91a0 2822                 	lds r26, song_fx_Dxx
00180d 11a2                      	cpse r26, zero
00180e c096                      	rjmp sound_driver_fx_Dxx_routine
                                 
00180f 91a0 281b                 	lds r26, song_frame_offset
001811 91b0 281c                 	lds r27, song_frame_offset+1
001813 91c0 281d                 	lds r28, song_size
001815 91d0 281e                 	lds r29, song_size+1
001817 17ac                      	cp r26, r28
001818 07bd                      	cpc r27, r29
001819 f408                      	brsh sound_driver_fx_song_loop
00181a c101                      	rjmp sound_driver_channel0
                                 
                                 
                                 sound_driver_fx_song_loop:
00181b e0a0                      	ldi r26, 0x00
                                 sound_driver_fx_Bxx_routine:
00181c 91e0 2819                 	lds ZL, song_frames
00181e 91f0 281a                 	lds ZH, song_frames+1
001820 27cc                      	clr r28 //initialize r29:r28 to 0
001821 27dd                      	clr r29
001822 95a3                      	inc r26 //increment xx parameter by 1
                                 sound_driver_fx_Bxx_routine_loop:
001823 95aa                      	dec r26
001824 f011                      	breq sound_driver_fx_Bxx_routine_loop_exit //once r26 == 0, r29:r28 will hold Bxx*(5*2).
001825 962a                      	adiw r29:r28, 10 //increment the offset by 10 because 5 channels, and each address takes 2 bytes (5*2 = 10)
001826 cffc                      	rjmp sound_driver_fx_Bxx_routine_loop
                                 
                                 sound_driver_fx_Bxx_routine_loop_exit:
001827 9622                      	adiw r29:r28, 2 //add 2 to skip the first 2 bytes (first 2 bytes is the song size)
001828 93c0 281b                 	sts song_frame_offset, r28
00182a 93d0 281c                 	sts song_frame_offset+1, r29
00182c 0fec                      	add ZL, r28
00182d 1ffd                      	adc ZH, r29
                                 
00182e 91a5                      	lpm r26, Z+ //load the address of the frame(pattern)
00182f 91b5                      	lpm r27, Z+
001830 0faa                      	lsl r26
001831 1fbb                      	rol r27
001832 93a0 2823                 	sts pulse1_pattern, r26
001834 93b0 2824                 	sts pulse1_pattern+1, r27
001836 91a5                      	lpm r26, Z+
001837 91b5                      	lpm r27, Z+
001838 0faa                      	lsl r26
001839 1fbb                      	rol r27
00183a 93a0 2874                 	sts pulse2_pattern, r26
00183c 93b0 2875                 	sts pulse2_pattern+1, r27
00183e 91a5                      	lpm r26, Z+
00183f 91b5                      	lpm r27, Z+
001840 0faa                      	lsl r26
001841 1fbb                      	rol r27
001842 93a0 28c5                 	sts triangle_pattern, r26
001844 93b0 28c6                 	sts triangle_pattern+1, r27
001846 91a5                      	lpm r26, Z+
001847 91b5                      	lpm r27, Z+
001848 0faa                      	lsl r26
001849 1fbb                      	rol r27
00184a 93a0 2911                 	sts noise_pattern, r26
00184c 93b0 2912                 	sts noise_pattern+1, r27
                                 
00184e 9220 2827                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001850 9220 2828                 	sts pulse1_pattern_offset+1, zero
001852 9220 2825                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
001854 9220 2826                 	sts pulse1_pattern_delay_frames, zero
001856 9220 2878                 	sts pulse2_pattern_offset, zero
001858 9220 2879                 	sts pulse2_pattern_offset+1, zero
00185a 9220 2876                 	sts pulse2_pattern_delay_rows, zero
00185c 9220 2877                 	sts pulse2_pattern_delay_frames, zero
00185e 9220 28c9                 	sts triangle_pattern_offset, zero
001860 9220 28ca                 	sts triangle_pattern_offset+1, zero
001862 9220 28c7                 	sts triangle_pattern_delay_rows, zero
001864 9220 28c8                 	sts triangle_pattern_delay_frames, zero
001866 9220 2915                 	sts noise_pattern_offset, zero
001868 9220 2916                 	sts noise_pattern_offset+1, zero
00186a 9220 2913                 	sts noise_pattern_delay_rows, zero
00186c 9220 2914                 	sts noise_pattern_delay_frames, zero
                                 
00186e efaf                      	ldi r26, 0xFF
00186f 93a0 2860                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
001871 93a0 2861                 	sts pulse1_fx_Gxx_post, r26
001873 93a0 2872                 	sts pulse1_fx_Sxx_pre, r26
001875 93a0 2873                 	sts pulse1_fx_Sxx_post, r26
001877 93a0 28b1                 	sts pulse2_fx_Gxx_pre, r26
001879 93a0 28b2                 	sts pulse2_fx_Gxx_post, r26
00187b 93a0 28c3                 	sts pulse2_fx_Sxx_pre, r26
00187d 93a0 28c4                 	sts pulse2_fx_Sxx_post, r26
00187f 93a0 28fd                 	sts triangle_fx_Gxx_pre, r26
001881 93a0 28fe                 	sts triangle_fx_Gxx_post, r26
001883 93a0 290f                 	sts triangle_fx_Sxx_pre, r26
001885 93a0 2910                 	sts triangle_fx_Sxx_post, r26
001887 93a0 2943                 	sts noise_fx_Gxx_pre, r26
001889 93a0 2944                 	sts noise_fx_Gxx_post, r26
00188b 93a0 2946                 	sts noise_fx_Sxx_pre, r26
00188d 93a0 2947                 	sts noise_fx_Sxx_post, r26
                                 
00188f 93a0 2820                 	sts song_fx_Bxx, r26 //reset all song effects
001891 9220 2821                 	sts song_fx_Cxx, zero
001893 9220 2822                 	sts song_fx_Dxx, zero
001895 c086                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_fx_Cxx_routine:
001896 91ff                      	pop r31
001897 91ef                      	pop r30
001898 91df                      	pop r29
001899 91cf                      	pop r28
00189a 91bf                      	pop r27
00189b bfbf                      	out CPU_SREG, r27
00189c 94f8                      	cli //disable global interrupts
                                 		
00189d efaf                      	ldi r26, 0xFF
00189e 93a0 2820                 	sts song_fx_Bxx, r26 //reset all song effects
0018a0 9220 2821                 	sts song_fx_Cxx, zero
0018a2 9220 2822                 	sts song_fx_Dxx, zero
0018a4 9518                      	reti
                                 
                                 sound_driver_fx_Dxx_routine:
0018a5 91e0 2819                 	lds ZL, song_frames
0018a7 91f0 281a                 	lds ZH, song_frames+1
0018a9 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
0018ab 91b0 281c                 	lds r27, song_frame_offset+1
0018ad 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
0018ae 93a0 281b                 	sts song_frame_offset, r26
0018b0 93b0 281c                 	sts song_frame_offset+1, r27
0018b2 0fea                      	add ZL, r26
0018b3 1ffb                      	adc ZH, r27
                                 
0018b4 91a5                      	lpm r26, Z+ //load the address of the next pattern
0018b5 91b5                      	lpm r27, Z+
0018b6 0faa                      	lsl r26
0018b7 1fbb                      	rol r27
0018b8 93a0 2823                 	sts pulse1_pattern, r26
0018ba 93b0 2824                 	sts pulse1_pattern+1, r27
0018bc 91a5                      	lpm r26, Z+
0018bd 91b5                      	lpm r27, Z+
0018be 0faa                      	lsl r26
0018bf 1fbb                      	rol r27
0018c0 93a0 2874                 	sts pulse2_pattern, r26
0018c2 93b0 2875                 	sts pulse2_pattern+1, r27
0018c4 91a5                      	lpm r26, Z+
0018c5 91b5                      	lpm r27, Z+
0018c6 0faa                      	lsl r26
0018c7 1fbb                      	rol r27
0018c8 93a0 28c5                 	sts triangle_pattern, r26
0018ca 93b0 28c6                 	sts triangle_pattern+1, r27
0018cc 91a5                      	lpm r26, Z+
0018cd 91b5                      	lpm r27, Z+
0018ce 0faa                      	lsl r26
0018cf 1fbb                      	rol r27
0018d0 93a0 2911                 	sts noise_pattern, r26
0018d2 93b0 2912                 	sts noise_pattern+1, r27
                                 
0018d4 9220 2827                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
0018d6 9220 2828                 	sts pulse1_pattern_offset+1, zero
0018d8 9220 2825                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
0018da 9220 2826                 	sts pulse1_pattern_delay_frames, zero
0018dc 9220 2878                 	sts pulse2_pattern_offset, zero
0018de 9220 2879                 	sts pulse2_pattern_offset+1, zero
0018e0 9220 2876                 	sts pulse2_pattern_delay_rows, zero
0018e2 9220 2877                 	sts pulse2_pattern_delay_frames, zero
0018e4 9220 28c9                 	sts triangle_pattern_offset, zero
0018e6 9220 28ca                 	sts triangle_pattern_offset+1, zero
0018e8 9220 28c7                 	sts triangle_pattern_delay_rows, zero
0018ea 9220 28c8                 	sts triangle_pattern_delay_frames, zero
0018ec 9220 2915                 	sts noise_pattern_offset, zero
0018ee 9220 2916                 	sts noise_pattern_offset+1, zero
0018f0 9220 2913                 	sts noise_pattern_delay_rows, zero
0018f2 9220 2914                 	sts noise_pattern_delay_frames, zero
                                 
0018f4 efaf                      	ldi r26, 0xFF
0018f5 93a0 2860                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
0018f7 93a0 2861                 	sts pulse1_fx_Gxx_post, r26
0018f9 93a0 2872                 	sts pulse1_fx_Sxx_pre, r26
0018fb 93a0 2873                 	sts pulse1_fx_Sxx_post, r26
0018fd 93a0 28b1                 	sts pulse2_fx_Gxx_pre, r26
0018ff 93a0 28b2                 	sts pulse2_fx_Gxx_post, r26
001901 93a0 28c3                 	sts pulse2_fx_Sxx_pre, r26
001903 93a0 28c4                 	sts pulse2_fx_Sxx_post, r26
001905 93a0 28fd                 	sts triangle_fx_Gxx_pre, r26
001907 93a0 28fe                 	sts triangle_fx_Gxx_post, r26
001909 93a0 290f                 	sts triangle_fx_Sxx_pre, r26
00190b 93a0 2910                 	sts triangle_fx_Sxx_post, r26
00190d 93a0 2943                 	sts noise_fx_Gxx_pre, r26
00190f 93a0 2944                 	sts noise_fx_Gxx_post, r26
001911 93a0 2946                 	sts noise_fx_Sxx_pre, r26
001913 93a0 2947                 	sts noise_fx_Sxx_post, r26
                                 
001915 93a0 2820                 	sts song_fx_Bxx, r26 //reset all song effects
001917 9220 2821                 	sts song_fx_Cxx, zero
001919 9220 2822                 	sts song_fx_Dxx, zero
00191b c000                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0:
00191c 91a0 2825                 	lds r26, pulse1_pattern_delay_rows
00191e 91b0 2826                 	lds r27, pulse1_pattern_delay_frames
001920 9610                      	adiw r27:r26, 0
001921 f009                      	breq sound_driver_channel0_main //if the pattern delay is 0, proceed with sound driver procedures
001922 c2e4                      	rjmp sound_driver_channel0_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel0_main:
001923 91e0 2823                 	lds ZL, pulse1_pattern //current pattern for pulse 1
001925 91f0 2824                 	lds ZH, pulse1_pattern+1
001927 91a0 2827                 	lds r26, pulse1_pattern_offset //current offset in the pattern for pulse 1
001929 91b0 2828                 	lds r27, pulse1_pattern_offset+1
00192b 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
00192c 1ffb                      	adc ZH, r27
00192d 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel0_check_if_note: //check if data is a note (0x00 - 0x56)
00192e 35b7                      	cpi r27, 0x57
00192f f408                      	brsh sound_driver_channel0_check_if_volume
001930 c17c                      	rjmp sound_driver_channel0_note
                                 sound_driver_channel0_check_if_volume: //check if data is volume (0x57-0x66)
001931 36b7                      	cpi r27, 0x67
001932 f408                      	brsh sound_driver_channel0_check_if_delay
001933 c1ba                      	rjmp sound_driver_channel0_volume
                                 sound_driver_channel0_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001934 3eb3                      	cpi r27, 0xE3
001935 f408                      	brsh sound_driver_channel0_check_if_instrument
001936 c1c1                      	rjmp sound_driver_channel0_delay
                                 sound_driver_channel0_check_if_instrument: //check for instrument flag (0xE3)
001937 f409                      	brne sound_driver_channel0_check_if_release
001938 c1c4                      	rjmp sound_driver_channel0_instrument_change 
                                 sound_driver_channel0_check_if_release: //check for note release flag (0xE4)
001939 3eb4                      	cpi r27, 0xE4
00193a f409                      	brne sound_driver_channel0_check_if_end
00193b c26d                      	rjmp sound_driver_channel0_release
                                 sound_driver_channel0_check_if_end:
00193c 3fbf                      	cpi r27, 0xFF
00193d f409                      	brne sound_driver_channel0_check_if_fx
00193e c28f                      	rjmp sound_driver_channel0_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel0_check_if_fx: //fx flags (0xE5 - 0xFE)
00193f 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001940 91a4                      	lpm r26, Z //load the fx data into r26
001941 d2bb                      	rcall sound_driver_channel0_increment_offset_twice
                                 
001942 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001943 eae6                      	ldi ZL, LOW(channel0_fx << 1) //load in note table
001944 e6f2                      	ldi ZH, HIGH(channel0_fx << 1)
001945 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001946 0feb                      	add ZL, r27 //add offset
001947 1df2                      	adc ZH, zero
001948 91c5                      	lpm r28, Z+ //load address bytes
001949 91d4                      	lpm r29, Z
00194a 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
00194b 2ffd                      	mov ZH, r29
00194c 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel0_fx_0xy:
00194d 93a0 2846                 	sts pulse1_fx_0xy_sequence, r26
00194f 9220 2847                 	sts pulse1_fx_0xy_sequence+1, zero
001951 cfd1                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel0_fx_1xx:
001952 9220 284c                 	sts pulse1_fx_2xx, zero //turn off any 2xx pitch slide down
001954 9220 284d                 	sts pulse1_fx_2xx+1, zero
001956 9220 2846                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
001958 9220 2847                 	sts pulse1_fx_0xy_sequence+1, zero
00195a 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00195b 937f                      	push r23
00195c 2f6a                      	mov r22, r26 //store the rate into r22
00195d eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00195e 9f67                      	mul r22, r23
00195f 917f                      	pop r23
001960 916f                      	pop r22
                                 
001961 9416                      	lsr r1 //shift out the fractional bits
001962 9407                      	ror r0
001963 9416                      	lsr r1
001964 9407                      	ror r0
001965 9416                      	lsr r1
001966 9407                      	ror r0
001967 9416                      	lsr r1
001968 9407                      	ror r0
001969 9200 2848                 	sts pulse1_fx_1xx, r0
00196b 9210 2849                 	sts pulse1_fx_1xx+1, r1
00196d cfb5                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel0_fx_2xx:
00196e 9220 2848                 	sts pulse1_fx_1xx, zero //turn off any 1xx pitch slide down
001970 9220 2849                 	sts pulse1_fx_1xx+1, zero
001972 9220 2846                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
001974 9220 2847                 	sts pulse1_fx_0xy_sequence+1, zero
001976 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001977 937f                      	push r23
001978 2f6a                      	mov r22, r26 //store the rate into r22
001979 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00197a 9f67                      	mul r22, r23
00197b 917f                      	pop r23
00197c 916f                      	pop r22
                                 
00197d 9416                      	lsr r1 //shift out the fractional bits
00197e 9407                      	ror r0
00197f 9416                      	lsr r1
001980 9407                      	ror r0
001981 9416                      	lsr r1
001982 9407                      	ror r0
001983 9416                      	lsr r1
001984 9407                      	ror r0
001985 9200 284c                 	sts pulse1_fx_2xx, r0
001987 9210 284d                 	sts pulse1_fx_2xx+1, r1
001989 cf99                      	rjmp sound_driver_channel0_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel0_fx_3xx:
00198a 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00198b 937f                      	push r23
00198c 2f6a                      	mov r22, r26 //store the rate into r22
00198d eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00198e 9f67                      	mul r22, r23
00198f 917f                      	pop r23
001990 916f                      	pop r22
                                 
001991 9416                      	lsr r1 //shift out the fractional bits
001992 9407                      	ror r0
001993 9416                      	lsr r1
001994 9407                      	ror r0
001995 9416                      	lsr r1
001996 9407                      	ror r0
001997 9416                      	lsr r1
001998 9407                      	ror r0
001999 9200 2854                 	sts pulse1_fx_3xx_speed, r0
00199b 9210 2855                 	sts pulse1_fx_3xx_speed+1, r1
                                 
00199d 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
00199e c001                      	rjmp sound_driver_channel0_fx_3xx_enabled
00199f cf83                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_3xx_enabled:
0019a0 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
0019a2 91b0 0a8d                 	lds r27, TCB0_CCMPH
0019a4 93a0 2850                 	sts pulse1_fx_3xx_start, r26
0019a6 93b0 2851                 	sts pulse1_fx_3xx_start+1, r27
                                 
0019a8 9220 2856                 	sts pulse1_fx_3xx_total_offset, zero
0019aa 9220 2857                 	sts pulse1_fx_3xx_total_offset+1, zero
0019ac cf76                      	rjmp sound_driver_channel0_main
                                 
                                 //VIBRATO
                                 sound_driver_channel0_fx_4xy:
0019ad 2fba                      	mov r27, r26
0019ae 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
0019af 95a2                      	swap r26
0019b0 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0019b1 93a0 2858                 	sts pulse1_fx_4xy_speed, r26
0019b3 93b0 2859                 	sts pulse1_fx_4xy_depth, r27
0019b5 9220 285a                 	sts pulse1_fx_4xy_phase, zero //reset the phase to 0
0019b7 cf6b                      	rjmp sound_driver_channel0_main
                                 
                                 //TREMELO
                                 sound_driver_channel0_fx_7xy:
0019b8 2fba                      	mov r27, r26
0019b9 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
0019ba 95a2                      	swap r26
0019bb 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0019bc 93a0 285b                 	sts pulse1_fx_7xy_speed, r26
0019be 93b0 285c                 	sts pulse1_fx_7xy_depth, r27
0019c0 9220 285d                 	sts pulse1_fx_7xy_phase, zero //reset the phase to 0
0019c2 9220 285e                 	sts pulse1_fx_7xy_value, zero //reset the tremelo value
0019c4 cf5e                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel0_fx_Axy:
0019c5 93a0 285f                 	sts pulse1_fx_Axy, r26
0019c7 cf5b                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel0_fx_Bxx:
0019c8 93a0 2820                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
0019ca cf58                      	rjmp sound_driver_channel0_main
                                 
                                 //HALT
                                 sound_driver_channel0_fx_Cxx:
0019cb 93b0 2821                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
0019cd cf55                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel0_fx_Dxx:
0019ce 93b0 2822                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
0019d0 cf52                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME
                                 sound_driver_channel0_fx_Exx:
0019d1 91b0 2800                 	lds r27, pulse1_param
0019d3 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
0019d4 2bba                      	or r27, r26 //move new VVVV bits into pulse1_param
0019d5 93b0 2800                 	sts pulse1_param, r27
0019d7 6096                      	sbr pulse_channel_flags, 6
0019d8 cf4a                      	rjmp sound_driver_channel0_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel0_fx_Fxx:
0019d9 93a0 281f                 	sts song_speed, r26 //NOTE: only changes to speed are supported
0019db cf47                      	rjmp sound_driver_channel0_main
                                 
                                 //DELAY
                                 sound_driver_channel0_fx_Gxx:
0019dc 15a2                      	cp r26, zero
0019dd f051                      	breq sound_driver_channel0_fx_Gxx_invalid
0019de 91b0 281f                 	lds r27, song_speed
0019e0 17ab                      	cp r26, r27
0019e1 f430                      	brsh sound_driver_channel0_fx_Gxx_invalid
0019e2 93a0 2860                 	sts pulse1_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
0019e4 e0b1                      	ldi r27, 0x01
0019e5 93b0 2825                 	sts pulse1_pattern_delay_rows, r27
0019e7 c222                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Gxx_invalid:
0019e8 cf3a                      	rjmp sound_driver_channel0_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel0_fx_Hxy: //hardware sweep up
0019e9 cf39                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixy: //hardware sweep down
0019ea cf38                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Hxx: //FDS modulation depth
0019eb cf37                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixx: //FDS modulation speed
0019ec cf36                      	rjmp sound_driver_channel0_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel0_fx_Pxx:
0019ed 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0019ee 937f                      	push r23
0019ef 2f6a                      	mov r22, r26
0019f0 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0019f1 0367                      	mulsu r22, r23
0019f2 917f                      	pop r23
0019f3 916f                      	pop r22
0019f4 9416                      	lsr r1 //shift out the fractional bits
0019f5 9407                      	ror r0
0019f6 9416                      	lsr r1
0019f7 9407                      	ror r0
0019f8 9416                      	lsr r1
0019f9 9407                      	ror r0
0019fa 9416                      	lsr r1
0019fb 9407                      	ror r0
0019fc fe13                      	sbrs r1, 3 //check if result was a negative number
0019fd c002                      	rjmp sound_driver_channel0_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel0_fx_Pxx_negative:
0019fe efb0                      	ldi r27, 0xF0
0019ff 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel0_fx_Pxx_store:
001a00 9200 2862                 	sts pulse1_fx_Pxx_total, r0
001a02 9210 2863                 	sts pulse1_fx_Pxx_total+1, r1
001a04 cf1e                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel0_fx_Qxy:
                                 sound_driver_channel0_fx_Qxy_check_arpeggio_macro:
001a05 91e0 282e                 	lds ZL, pulse1_arpeggio_macro
001a07 91f0 282f                 	lds ZH, pulse1_arpeggio_macro+1
001a09 9630                      	adiw Z, 0
001a0a f009                      	breq sound_driver_channel0_fx_Qxy_check_pitch_macro
001a0b cf17                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_pitch_macro:
001a0c 91e0 2836                 	lds ZL, pulse1_pitch_macro
001a0e 91f0 2837                 	lds ZH, pulse1_pitch_macro+1
001a10 9630                      	adiw Z, 0
001a11 f009                      	breq sound_driver_channel0_fx_Qxy_check_hi_pitch_macro
001a12 cf10                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_hi_pitch_macro:
001a13 91e0 283c                 	lds ZL, pulse1_hi_pitch_macro
001a15 91f0 283d                 	lds ZH, pulse1_hi_pitch_macro+1
001a17 9630                      	adiw Z, 0
001a18 f009                      	breq sound_driver_channel0_fx_Qxy_process
001a19 cf09                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_process:
001a1a 2fba                      	mov r27, r26 //copy fx parameters into r27
001a1b 70bf                      	andi r27, 0x0F //mask note index offset
001a1c 91c0 2864                 	lds r28, pulse1_fx_Qxy_target_note //load current note index
001a1e 0fbc                      	add r27, r28
001a1f 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001a20 f008                      	brlo sound_driver_channel0_fx_Qxy_process_continue
001a21 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel0_fx_Qxy_process_continue:
001a22 93b0 2864                 	sts pulse1_fx_Qxy_target_note, r27
001a24 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001a25 e0f0                      	ldi ZH, HIGH(note_table << 1)
001a26 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001a27 0feb                      	add ZL, r27 //add offset
001a28 1df2                      	adc ZH, zero
001a29 91c5                      	lpm r28, Z+ //load bytes
001a2a 91d4                      	lpm r29, Z
001a2b 93c0 2865                 	sts pulse1_fx_Qxy_target, r28 //load the LOW bits for the target period
001a2d 93d0 2866                 	sts pulse1_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel0_fx_Qxy_process_speed:
001a2f 95a2                      	swap r26
001a30 70af                      	andi r26, 0x0F //mask effect speed
001a31 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001a32 95a3                      	inc r26 //increment the speed by 1
                                 
001a33 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001a34 937f                      	push r23
001a35 2f6a                      	mov r22, r26 //store the speed data into r27
001a36 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001a37 9f67                      	mul r22, r23
001a38 917f                      	pop r23
001a39 916f                      	pop r22
                                 
001a3a 9416                      	lsr r1 //shift out the fractional bits
001a3b 9407                      	ror r0
001a3c 9416                      	lsr r1
001a3d 9407                      	ror r0
001a3e 9416                      	lsr r1
001a3f 9407                      	ror r0
001a40 9416                      	lsr r1
001a41 9407                      	ror r0
                                 
001a42 9200 2867                 	sts pulse1_fx_Qxy_speed, r0 //store the effect speed
001a44 9210 2868                 	sts pulse1_fx_Qxy_speed+1, r1
001a46 cedc                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel0_fx_Rxy:
                                 sound_driver_channel0_fx_Rxy_check_arpeggio_macro:
001a47 91e0 282e                 	lds ZL, pulse1_arpeggio_macro
001a49 91f0 282f                 	lds ZH, pulse1_arpeggio_macro+1
001a4b 9630                      	adiw Z, 0
001a4c f009                      	breq sound_driver_channel0_fx_Rxy_check_pitch_macro
001a4d ced5                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_pitch_macro:
001a4e 91e0 2836                 	lds ZL, pulse1_pitch_macro
001a50 91f0 2837                 	lds ZH, pulse1_pitch_macro+1
001a52 9630                      	adiw Z, 0
001a53 f009                      	breq sound_driver_channel0_fx_Rxy_check_hi_pitch_macro
001a54 cece                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_hi_pitch_macro:
001a55 91e0 283c                 	lds ZL, pulse1_hi_pitch_macro
001a57 91f0 283d                 	lds ZH, pulse1_hi_pitch_macro+1
001a59 9630                      	adiw Z, 0
001a5a f009                      	breq sound_driver_channel0_fx_Rxy_process
001a5b cec7                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_process:
001a5c 2fba                      	mov r27, r26 //copy fx parameters into r27
001a5d 70bf                      	andi r27, 0x0F //mask note index offset
001a5e 91c0 286b                 	lds r28, pulse1_fx_Rxy_target_note //load current note index
001a60 1bcb                      	sub r28, r27
001a61 f408                      	brcc sound_driver_channel0_fx_Rxy_process_continue
001a62 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel0_fx_Rxy_process_continue:
001a63 93c0 286b                 	sts pulse1_fx_Rxy_target_note, r28
001a65 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001a66 e0f0                      	ldi ZH, HIGH(note_table << 1)
001a67 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001a68 0fec                      	add ZL, r28 //add offset
001a69 1df2                      	adc ZH, zero
001a6a 91c5                      	lpm r28, Z+ //load bytes
001a6b 91d4                      	lpm r29, Z
001a6c 93c0 286c                 	sts pulse1_fx_Rxy_target, r28 //load the LOW bits for the target period
001a6e 93d0 286d                 	sts pulse1_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel0_fx_Rxy_process_speed:
001a70 95a2                      	swap r26
001a71 70af                      	andi r26, 0x0F //mask effect speed
001a72 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001a73 95a3                      	inc r26 //increment the speed by 1
                                 
001a74 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001a75 937f                      	push r23
001a76 2f6a                      	mov r22, r26 //store the speed data into r27
001a77 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001a78 9f67                      	mul r22, r23
001a79 917f                      	pop r23
001a7a 916f                      	pop r22
                                 
001a7b 9416                      	lsr r1 //shift out the fractional bits
001a7c 9407                      	ror r0
001a7d 9416                      	lsr r1
001a7e 9407                      	ror r0
001a7f 9416                      	lsr r1
001a80 9407                      	ror r0
001a81 9416                      	lsr r1
001a82 9407                      	ror r0
                                 
001a83 9200 286e                 	sts pulse1_fx_Rxy_speed, r0 //store the effect speed
001a85 9210 286f                 	sts pulse1_fx_Rxy_speed+1, r1
001a87 ce9b                      	rjmp sound_driver_channel0_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel0_fx_Sxx:
001a88 15a2                      	cp r26, zero
001a89 f051                      	breq sound_driver_channel0_fx_Sxx_invalid
001a8a 91b0 281f                 	lds r27, song_speed
001a8c 17ab                      	cp r26, r27
001a8d f430                      	brsh sound_driver_channel0_fx_Sxx_invalid
001a8e 93a0 2872                 	sts pulse1_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001a90 e0b1                      	ldi r27, 0x01
001a91 93b0 2825                 	sts pulse1_pattern_delay_rows, r27
001a93 c176                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Sxx_invalid:
001a94 ce8e                      	rjmp sound_driver_channel0_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel0_fx_Vxx:
001a95 eae2                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
001a96 e6f2                      	ldi ZH, HIGH(sequences << 1)
001a97 0fea                      	add ZL, r26 //offset the pointer
001a98 1df2                      	adc ZH, zero
                                 
001a99 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
001a9a 95a7                      	ror r26
001a9b 95a7                      	ror r26
001a9c 91b0 2800                 	lds r27, pulse1_param //load r27 with pulse1_param (register $4000)
001a9e 2fcb                      	mov r28, r27 //store a copy of pulse1_param into r28
001a9f 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
001aa0 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
001aa1 c001                      	rjmp sound_driver_channel0_fx_Vxx_store
001aa2 ce80                      	rjmp sound_driver_channel0_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel0_fx_Vxx_store:
001aa3 9074                      	lpm pulse1_sequence, Z //store the sequence
                                 
001aa4 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
001aa5 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
001aa6 93c0 2800                 	sts pulse1_param, r28
001aa8 ce7a                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_Wxx: //DPCM sample speed
001aa9 ce79                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Xxx: //DPCM sample retrigger
001aaa ce78                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Yxx: //DPCM sample offset
001aab ce77                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Zxx: //DPCM sample delta counter
001aac ce76                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 sound_driver_channel0_note:
001aad 93b0 2807                 	sts pulse1_note, r27 //store the note index
001aaf 93b0 2864                 	sts pulse1_fx_Qxy_target_note, r27
001ab1 93b0 286b                 	sts pulse1_fx_Rxy_target_note, r27
001ab3 e0a3                      	ldi r26, 0x03
001ab4 e0b2                      	ldi r27, 0x02
001ab5 93b0 282b                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
001ab7 93a0 2830                 	sts pulse1_arpeggio_macro_offset, r26
001ab9 93b0 2838                 	sts pulse1_pitch_macro_offset, r27
001abb 93b0 283e                 	sts pulse1_hi_pitch_macro_offset, r27
001abd 93b0 2843                 	sts pulse1_duty_macro_offset, r27
001abf 9220 2834                 	sts pulse1_total_pitch_offset, zero //reset the pitch and hi pitch offset
001ac1 9220 2835                 	sts pulse1_total_pitch_offset+1, zero
001ac3 9220 283b                 	sts pulse1_total_hi_pitch_offset, zero
001ac5 9220 284a                 	sts pulse1_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001ac7 9220 284b                 	sts pulse1_fx_1xx_total+1, zero
001ac9 9220 284e                 	sts pulse1_fx_2xx_total, zero
001acb 9220 284f                 	sts pulse1_fx_2xx_total+1, zero
001acd 9220 2856                 	sts pulse1_fx_3xx_total_offset, zero //reset 3xx offset
001acf 9220 2857                 	sts pulse1_fx_3xx_total_offset+1, zero
001ad1 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001ad3 91b0 0a8d                 	lds r27, TCB0_CCMPH
001ad5 93a0 2850                 	sts pulse1_fx_3xx_start, r26
001ad7 93b0 2851                 	sts pulse1_fx_3xx_start+1, r27
001ad9 9220 2801                 	sts pulse1_sweep_param, zero //reset any sweep effect
001adb 6097                      	sbr pulse_channel_flags, 7 //set reload flag
001adc 9220 2865                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001ade 9220 2866                 	sts pulse1_fx_Qxy_target+1, zero
001ae0 9220 2869                 	sts pulse1_fx_Qxy_total_offset, zero
001ae2 9220 286a                 	sts pulse1_fx_Qxy_total_offset+1, zero
001ae4 9220 286c                 	sts pulse1_fx_Rxy_target, zero
001ae6 9220 286d                 	sts pulse1_fx_Rxy_target+1, zero
001ae8 9220 2870                 	sts pulse1_fx_Rxy_total_offset, zero
001aea 9220 2871                 	sts pulse1_fx_Rxy_total_offset+1, zero
001aec d106                      	rcall sound_driver_channel0_increment_offset
001aed ce35                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_volume:
001aee 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001aef 91a0 2800                 	lds r26, pulse1_param
001af1 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001af2 2bab                      	or r26, r27 //move new VVVV bits into pulse1_param
001af3 93a0 2800                 	sts pulse1_param, r26
001af5 6096                      	sbr pulse_channel_flags, 6
001af6 d0fc                      	rcall sound_driver_channel0_increment_offset
001af7 ce2b                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_delay:
001af8 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001af9 93b0 2825                 	sts pulse1_pattern_delay_rows, r27
001afb d0f7                      	rcall sound_driver_channel0_increment_offset
001afc c10d                      	rjmp sound_driver_channel1
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change:
001afd 9220 2829                 	sts pulse1_volume_macro, zero //reset all macro addresses
001aff 9220 282a                 	sts pulse1_volume_macro+1, zero
001b01 9220 282e                 	sts pulse1_arpeggio_macro, zero
001b03 9220 282f                 	sts pulse1_arpeggio_macro+1, zero
001b05 9220 2836                 	sts pulse1_pitch_macro, zero
001b07 9220 2837                 	sts pulse1_pitch_macro+1, zero
001b09 9220 283c                 	sts pulse1_hi_pitch_macro, zero
001b0b 9220 283d                 	sts pulse1_hi_pitch_macro+1, zero
001b0d 9220 2841                 	sts pulse1_duty_macro, zero
001b0f 9220 2842                 	sts pulse1_duty_macro+1, zero
001b11 9220 2834                 	sts pulse1_total_pitch_offset, zero //reset the pitch offset
001b13 9220 2835                 	sts pulse1_total_pitch_offset+1, zero
001b15 9220 283b                 	sts pulse1_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001b17 9631                      	adiw Z, 1 //point to the byte next to the flag
001b18 91b4                      	lpm r27, Z //store the instrument offset into r27
001b19 e3eb                      	ldi ZL, LOW(instruments) //point Z to instruments table
001b1a e1f1                      	ldi ZH, HIGH(instruments)
001b1b 0feb                      	add ZL, r27 //point Z to offsetted instrument
001b1c 1df2                      	adc ZH, zero
001b1d 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001b1e 1fff                      	rol ZH
001b1f 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001b20 91b4                      	lpm r27, Z
                                 
001b21 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001b22 1fbb                      	rol r27
001b23 2fea                      	mov ZL, r26
001b24 2ffb                      	mov ZH, r27
001b25 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001b26 9632                      	adiw Z, 2 //point Z to the address of the macro
001b27 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel0_instrument_change_macro_loop:
001b28 95aa                      	dec r26
001b29 f019                      	breq sound_driver_channel0_instrument_change_exit
001b2a 95b6                      	lsr r27
001b2b f078                      	brcs sound_driver_channel0_instrument_change_load_macro
001b2c cffb                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_exit:
001b2d e0a3                      	ldi r26, 0x03
001b2e e0b2                      	ldi r27, 0x02
001b2f 93b0 282b                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
001b31 93a0 2830                 	sts pulse1_arpeggio_macro_offset, r26
001b33 93b0 2838                 	sts pulse1_pitch_macro_offset, r27
001b35 93b0 283e                 	sts pulse1_hi_pitch_macro_offset, r27
001b37 93b0 2843                 	sts pulse1_duty_macro_offset, r27
001b39 d0c3                      	rcall sound_driver_channel0_increment_offset_twice
001b3a cde8                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_load_macro:
001b3b 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001b3c 91d5                      	lpm r29, Z+
                                 
001b3d 30a5                      	cpi r26, 5
001b3e f039                      	breq sound_driver_channel0_instrument_change_load_macro_volume
001b3f 30a4                      	cpi r26, 4
001b40 f079                      	breq sound_driver_channel0_instrument_change_load_macro_arpeggio
001b41 30a3                      	cpi r26, 3
001b42 f0d9                      	breq sound_driver_channel0_instrument_change_load_macro_pitch
001b43 30a2                      	cpi r26, 2
001b44 f159                      	breq sound_driver_channel0_instrument_change_load_macro_hi_pitch
001b45 c03c                      	rjmp sound_driver_channel0_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel0_instrument_change_load_macro_volume:
001b46 93c0 2829                 	sts pulse1_volume_macro, r28
001b48 93d0 282a                 	sts pulse1_volume_macro+1, r29
001b4a d041                      	rcall sound_driver_channel0_instrument_change_read_header
001b4b 93c0 282d                 	sts pulse1_volume_macro_release, r28
001b4d 93d0 282c                 	sts pulse1_volume_macro_loop, r29
001b4f cfd8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 	
                                 sound_driver_channel0_instrument_change_load_macro_arpeggio:
001b50 93c0 282e                 	sts pulse1_arpeggio_macro, r28
001b52 93d0 282f                 	sts pulse1_arpeggio_macro+1, r29
001b54 9220 2865                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001b56 9220 2866                 	sts pulse1_fx_Qxy_target+1, zero
001b58 9220 286c                 	sts pulse1_fx_Rxy_target, zero
001b5a 9220 286d                 	sts pulse1_fx_Rxy_target+1, zero
001b5c d03a                      	rcall sound_driver_channel0_instrument_change_read_header_arpeggio
001b5d cfca                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_pitch:
001b5e 93c0 2836                 	sts pulse1_pitch_macro, r28
001b60 93d0 2837                 	sts pulse1_pitch_macro+1, r29
001b62 9220 2865                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001b64 9220 2866                 	sts pulse1_fx_Qxy_target+1, zero
001b66 9220 286c                 	sts pulse1_fx_Rxy_target, zero
001b68 9220 286d                 	sts pulse1_fx_Rxy_target+1, zero
001b6a d021                      	rcall sound_driver_channel0_instrument_change_read_header
001b6b 93c0 283a                 	sts pulse1_pitch_macro_release, r28
001b6d 93d0 2839                 	sts pulse1_pitch_macro_loop, r29
001b6f cfb8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_hi_pitch:
001b70 93c0 283c                 	sts pulse1_hi_pitch_macro, r28
001b72 93d0 283d                 	sts pulse1_hi_pitch_macro+1, r29
001b74 9220 2865                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001b76 9220 2866                 	sts pulse1_fx_Qxy_target+1, zero
001b78 9220 286c                 	sts pulse1_fx_Rxy_target, zero
001b7a 9220 286d                 	sts pulse1_fx_Rxy_target+1, zero
001b7c d00f                      	rcall sound_driver_channel0_instrument_change_read_header
001b7d 93c0 2840                 	sts pulse1_hi_pitch_macro_release, r28
001b7f 93d0 283f                 	sts pulse1_hi_pitch_macro_loop, r29
001b81 cfa6                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_duty:
001b82 93c0 2841                 	sts pulse1_duty_macro, r28
001b84 93d0 2842                 	sts pulse1_duty_macro+1, r29
001b86 d005                      	rcall sound_driver_channel0_instrument_change_read_header
001b87 93c0 2845                 	sts pulse1_duty_macro_release, r28
001b89 93d0 2844                 	sts pulse1_duty_macro_loop, r29
001b8b cf9c                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_read_header:
001b8c 93ef                      	push ZL
001b8d 93ff                      	push ZH
001b8e 2fec                      	mov ZL, r28
001b8f 2ffd                      	mov ZH, r29
001b90 0fee                      	lsl ZL
001b91 1fff                      	rol ZH
001b92 91c5                      	lpm r28, Z+
001b93 91d4                      	lpm r29, Z
001b94 91ff                      	pop ZH
001b95 91ef                      	pop ZL
001b96 9508                      	ret
                                 
                                 sound_driver_channel0_instrument_change_read_header_arpeggio:
001b97 93ef                      	push ZL
001b98 93ff                      	push ZH
001b99 2fec                      	mov ZL, r28
001b9a 2ffd                      	mov ZH, r29
001b9b 0fee                      	lsl ZL
001b9c 1fff                      	rol ZH
001b9d 91c5                      	lpm r28, Z+
001b9e 91d5                      	lpm r29, Z+
001b9f 93c0 2832                 	sts pulse1_arpeggio_macro_release, r28
001ba1 93d0 2831                 	sts pulse1_arpeggio_macro_loop, r29
001ba3 91c4                      	lpm r28, Z
001ba4 93c0 2833                 	sts pulse1_arpeggio_macro_mode, r28
001ba6 91ff                      	pop ZH
001ba7 91ef                      	pop ZL
001ba8 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel0_release:
                                 sound_driver_channel0_release_volume:
001ba9 91b0 282d                 	lds r27, pulse1_volume_macro_release
001bab 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001bac f019                      	breq sound_driver_channel0_release_arpeggio //if the macro has no release flag, check the next macro
001bad 95b3                      	inc r27
001bae 93b0 282b                 	sts pulse1_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel0_release_arpeggio:
001bb0 91b0 2832                 	lds r27, pulse1_arpeggio_macro_release
001bb2 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001bb3 f019                      	breq sound_driver_channel0_release_pitch
001bb4 95b3                      	inc r27
001bb5 93b0 2830                 	sts pulse1_arpeggio_macro_offset, r27
                                 sound_driver_channel0_release_pitch:
001bb7 91b0 283a                 	lds r27, pulse1_pitch_macro_release
001bb9 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001bba f019                      	breq sound_driver_channel0_release_hi_pitch
001bbb 95b3                      	inc r27
001bbc 93b0 2838                 	sts pulse1_pitch_macro_offset, r27
                                 sound_driver_channel0_release_hi_pitch:
001bbe 91b0 2840                 	lds r27, pulse1_hi_pitch_macro_release
001bc0 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001bc1 f019                      	breq sound_driver_channel0_release_duty
001bc2 95b3                      	inc r27
001bc3 93b0 283e                 	sts pulse1_hi_pitch_macro_offset, r27
                                 sound_driver_channel0_release_duty:
001bc5 91b0 2845                 	lds r27, pulse1_duty_macro_release
001bc7 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001bc8 f019                      	breq sound_driver_channel0_release_exit
001bc9 95b3                      	inc r27
001bca 93b0 2843                 	sts pulse1_duty_macro_offset, r27
                                 sound_driver_channel0_release_exit:
001bcc d026                      	rcall sound_driver_channel0_increment_offset
001bcd cd55                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_next_pattern:
001bce 91e0 2819                 	lds ZL, song_frames
001bd0 91f0 281a                 	lds ZH, song_frames+1
001bd2 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001bd4 91b0 281c                 	lds r27, song_frame_offset+1
001bd6 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
001bd7 93a0 281b                 	sts song_frame_offset, r26
001bd9 93b0 281c                 	sts song_frame_offset+1, r27
                                 
001bdb 91c0 281d                 	lds r28, song_size
001bdd 91d0 281e                 	lds r29, song_size+1
001bdf 17ac                      	cp r26, r28
001be0 07bd                      	cpc r27, r29
001be1 f010                      	brlo sound_driver_channel0_next_pattern_exists
001be2 940c 313b                 	jmp sound_driver_exit
                                 
                                 sound_driver_channel0_next_pattern_exists:
001be4 0fea                      	add ZL, r26
001be5 1ffb                      	adc ZH, r27
                                 
001be6 91a5                      	lpm r26, Z+ //load the address of the next pattern
001be7 91b4                      	lpm r27, Z
001be8 0faa                      	lsl r26
001be9 1fbb                      	rol r27
001bea 93a0 2823                 	sts pulse1_pattern, r26
001bec 93b0 2824                 	sts pulse1_pattern+1, r27
                                 
001bee 9220 2827                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001bf0 9220 2828                 	sts pulse1_pattern_offset+1, zero
001bf2 cd30                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_increment_offset:
001bf3 91e0 2827                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
001bf5 91f0 2828                 	lds ZH, pulse1_pattern_offset+1
001bf7 9631                      	adiw Z, 1
001bf8 93e0 2827                 	sts pulse1_pattern_offset, ZL
001bfa 93f0 2828                 	sts pulse1_pattern_offset+1, ZH
001bfc 9508                      	ret
                                 
                                 sound_driver_channel0_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001bfd 91e0 2827                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
001bff 91f0 2828                 	lds ZH, pulse1_pattern_offset+1
001c01 9632                      	adiw Z, 2 //increment the pointer twice
001c02 93e0 2827                 	sts pulse1_pattern_offset, ZL
001c04 93f0 2828                 	sts pulse1_pattern_offset+1, ZH
001c06 9508                      	ret
                                 
                                 sound_driver_channel0_decrement_frame_delay:
001c07 95ba                      	dec r27
001c08 93b0 2826                 	sts pulse1_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel1:
001c0a 91a0 2876                 	lds r26, pulse2_pattern_delay_rows
001c0c 91b0 2877                 	lds r27, pulse2_pattern_delay_frames
001c0e 9610                      	adiw r27:r26, 0
001c0f f009                      	breq sound_driver_channel1_main //if the pattern delay is 0, proceed with sound driver procedures
001c10 c2d7                      	rjmp sound_driver_channel1_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel1_main:
001c11 91e0 2874                 	lds ZL, pulse2_pattern //current pattern for pulse 2
001c13 91f0 2875                 	lds ZH, pulse2_pattern+1
001c15 91a0 2878                 	lds r26, pulse2_pattern_offset //current offset in the pattern for pulse 2
001c17 91b0 2879                 	lds r27, pulse2_pattern_offset+1
001c19 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001c1a 1ffb                      	adc ZH, r27
001c1b 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel1_check_if_note: //check if data is a note (0x00 - 0x56)
001c1c 35b7                      	cpi r27, 0x57
001c1d f408                      	brsh sound_driver_channel1_check_if_volume
001c1e c17c                      	rjmp sound_driver_channel1_note
                                 sound_driver_channel1_check_if_volume: //check if data is volume (0x57-0x66)
001c1f 36b7                      	cpi r27, 0x67
001c20 f408                      	brsh sound_driver_channel1_check_if_delay
001c21 c1ba                      	rjmp sound_driver_channel1_volume
                                 sound_driver_channel1_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001c22 3eb3                      	cpi r27, 0xE3
001c23 f408                      	brsh sound_driver_channel1_check_if_instrument
001c24 c1c1                      	rjmp sound_driver_channel1_delay
                                 sound_driver_channel1_check_if_instrument: //check for instrument flag (0xE3)
001c25 f409                      	brne sound_driver_channel1_check_if_release
001c26 c1c4                      	rjmp sound_driver_channel1_instrument_change 
                                 sound_driver_channel1_check_if_release: //check for note release flag (0xE4)
001c27 3eb4                      	cpi r27, 0xE4
001c28 f409                      	brne sound_driver_channel1_check_if_end
001c29 c26d                      	rjmp sound_driver_channel1_release
                                 sound_driver_channel1_check_if_end:
001c2a 3fbf                      	cpi r27, 0xFF
001c2b f409                      	brne sound_driver_channel1_check_if_fx
001c2c c28f                      	rjmp sound_driver_channel1_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel1_check_if_fx: //fx flags (0xE5 - 0xFE)
001c2d 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001c2e 91a4                      	lpm r26, Z //load the fx data into r26
001c2f d2ae                      	rcall sound_driver_channel1_increment_offset_twice
                                 
001c30 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001c31 edea                      	ldi ZL, LOW(channel1_fx << 1) //load in note table
001c32 e6f2                      	ldi ZH, HIGH(channel1_fx << 1)
001c33 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001c34 0feb                      	add ZL, r27 //add offset
001c35 1df2                      	adc ZH, zero
001c36 91c5                      	lpm r28, Z+ //load address bytes
001c37 91d4                      	lpm r29, Z
001c38 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001c39 2ffd                      	mov ZH, r29
001c3a 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel1_fx_0xy:
001c3b 93a0 2897                 	sts pulse2_fx_0xy_sequence, r26
001c3d 9220 2898                 	sts pulse2_fx_0xy_sequence+1, zero
001c3f cfd1                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel1_fx_1xx:
001c40 9220 289d                 	sts pulse2_fx_2xx, zero //turn off any 2xx pitch slide down
001c42 9220 289e                 	sts pulse2_fx_2xx+1, zero
001c44 9220 2897                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
001c46 9220 2898                 	sts pulse2_fx_0xy_sequence+1, zero
001c48 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001c49 937f                      	push r23
001c4a 2f6a                      	mov r22, r26 //store the rate into r22
001c4b eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001c4c 9f67                      	mul r22, r23
001c4d 917f                      	pop r23
001c4e 916f                      	pop r22
                                 
001c4f 9416                      	lsr r1 //shift out the fractional bits
001c50 9407                      	ror r0
001c51 9416                      	lsr r1
001c52 9407                      	ror r0
001c53 9416                      	lsr r1
001c54 9407                      	ror r0
001c55 9416                      	lsr r1
001c56 9407                      	ror r0
001c57 9200 2899                 	sts pulse2_fx_1xx, r0
001c59 9210 289a                 	sts pulse2_fx_1xx+1, r1
001c5b cfb5                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel1_fx_2xx:
001c5c 9220 2899                 	sts pulse2_fx_1xx, zero //turn off any 1xx pitch slide down
001c5e 9220 289a                 	sts pulse2_fx_1xx+1, zero
001c60 9220 2897                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
001c62 9220 2898                 	sts pulse2_fx_0xy_sequence+1, zero
001c64 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001c65 937f                      	push r23
001c66 2f6a                      	mov r22, r26 //store the rate into r22
001c67 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001c68 9f67                      	mul r22, r23
001c69 917f                      	pop r23
001c6a 916f                      	pop r22
                                 
001c6b 9416                      	lsr r1 //shift out the fractional bits
001c6c 9407                      	ror r0
001c6d 9416                      	lsr r1
001c6e 9407                      	ror r0
001c6f 9416                      	lsr r1
001c70 9407                      	ror r0
001c71 9416                      	lsr r1
001c72 9407                      	ror r0
001c73 9200 289d                 	sts pulse2_fx_2xx, r0
001c75 9210 289e                 	sts pulse2_fx_2xx+1, r1
001c77 cf99                      	rjmp sound_driver_channel1_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel1_fx_3xx:
001c78 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001c79 937f                      	push r23
001c7a 2f6a                      	mov r22, r26 //store the rate into r22
001c7b eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001c7c 9f67                      	mul r22, r23
001c7d 917f                      	pop r23
001c7e 916f                      	pop r22
                                 
001c7f 9416                      	lsr r1 //shift out the fractional bits
001c80 9407                      	ror r0
001c81 9416                      	lsr r1
001c82 9407                      	ror r0
001c83 9416                      	lsr r1
001c84 9407                      	ror r0
001c85 9416                      	lsr r1
001c86 9407                      	ror r0
001c87 9200 28a5                 	sts pulse2_fx_3xx_speed, r0
001c89 9210 28a6                 	sts pulse2_fx_3xx_speed+1, r1
                                 
001c8b 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001c8c c001                      	rjmp sound_driver_channel1_fx_3xx_enabled
001c8d cf83                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_3xx_enabled:
001c8e 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001c90 91b0 0a9d                 	lds r27, TCB1_CCMPH
001c92 93a0 28a1                 	sts pulse2_fx_3xx_start, r26
001c94 93b0 28a2                 	sts pulse2_fx_3xx_start+1, r27
                                 
001c96 9220 28a7                 	sts pulse2_fx_3xx_total_offset, zero
001c98 9220 28a8                 	sts pulse2_fx_3xx_total_offset+1, zero
001c9a cf76                      	rjmp sound_driver_channel1_main
                                 
                                 //VIBRATO
                                 sound_driver_channel1_fx_4xy:
001c9b 2fba                      	mov r27, r26
001c9c 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001c9d 95a2                      	swap r26
001c9e 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001c9f 93a0 28a9                 	sts pulse2_fx_4xy_speed, r26
001ca1 93b0 28aa                 	sts pulse2_fx_4xy_depth, r27
001ca3 9220 28ab                 	sts pulse2_fx_4xy_phase, zero //reset the phase to 0
001ca5 cf6b                      	rjmp sound_driver_channel1_main
                                 
                                 //TREMELO
                                 sound_driver_channel1_fx_7xy:
001ca6 2fba                      	mov r27, r26
001ca7 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001ca8 95a2                      	swap r26
001ca9 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001caa 93a0 28ac                 	sts pulse2_fx_7xy_speed, r26
001cac 93b0 28ad                 	sts pulse2_fx_7xy_depth, r27
001cae 9220 28ae                 	sts pulse2_fx_7xy_phase, zero //reset the phase to 0
001cb0 9220 28af                 	sts pulse2_fx_7xy_value, zero //reset the tremelo value
001cb2 cf5e                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel1_fx_Axy:
001cb3 93a0 28b0                 	sts pulse2_fx_Axy, r26
001cb5 cf5b                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel1_fx_Bxx:
001cb6 93a0 2820                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001cb8 cf58                      	rjmp sound_driver_channel1_main
                                 
                                 //HALT
                                 sound_driver_channel1_fx_Cxx:
001cb9 93b0 2821                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001cbb cf55                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel1_fx_Dxx:
001cbc 93b0 2822                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001cbe cf52                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME
                                 sound_driver_channel1_fx_Exx:
001cbf 91b0 2808                 	lds r27, pulse2_param
001cc1 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
001cc2 2bba                      	or r27, r26 //move new VVVV bits into pulse2_param
001cc3 93b0 2808                 	sts pulse2_param, r27
001cc5 6092                      	sbr pulse_channel_flags, 2
001cc6 cf4a                      	rjmp sound_driver_channel1_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel1_fx_Fxx:
001cc7 93a0 281f                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001cc9 cf47                      	rjmp sound_driver_channel1_main
                                 
                                 //DELAY
                                 sound_driver_channel1_fx_Gxx:
001cca 15a2                      	cp r26, zero
001ccb f051                      	breq sound_driver_channel1_fx_Gxx_invalid
001ccc 91b0 281f                 	lds r27, song_speed
001cce 17ab                      	cp r26, r27
001ccf f430                      	brsh sound_driver_channel1_fx_Gxx_invalid
001cd0 93a0 28b1                 	sts pulse2_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001cd2 e0b1                      	ldi r27, 0x01
001cd3 93b0 2876                 	sts pulse2_pattern_delay_rows, r27
001cd5 c215                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Gxx_invalid:
001cd6 cf3a                      	rjmp sound_driver_channel1_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel1_fx_Hxy: //hardware sweep up
001cd7 cf39                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixy: //hardware sweep down
001cd8 cf38                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Hxx: //FDS modulation depth
001cd9 cf37                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixx: //FDS modulation speed
001cda cf36                      	rjmp sound_driver_channel1_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel1_fx_Pxx:
001cdb 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001cdc 937f                      	push r23
001cdd 2f6a                      	mov r22, r26
001cde eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001cdf 0367                      	mulsu r22, r23
001ce0 917f                      	pop r23
001ce1 916f                      	pop r22
001ce2 9416                      	lsr r1 //shift out the fractional bits
001ce3 9407                      	ror r0
001ce4 9416                      	lsr r1
001ce5 9407                      	ror r0
001ce6 9416                      	lsr r1
001ce7 9407                      	ror r0
001ce8 9416                      	lsr r1
001ce9 9407                      	ror r0
001cea fe13                      	sbrs r1, 3 //check if result was a negative number
001ceb c002                      	rjmp sound_driver_channel1_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel1_fx_Pxx_negative:
001cec efb0                      	ldi r27, 0xF0
001ced 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel1_fx_Pxx_store:
001cee 9200 28b3                 	sts pulse2_fx_Pxx_total, r0
001cf0 9210 28b4                 	sts pulse2_fx_Pxx_total+1, r1
001cf2 cf1e                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel1_fx_Qxy:
                                 sound_driver_channel1_fx_Qxy_check_arpeggio_macro:
001cf3 91e0 287f                 	lds ZL, pulse2_arpeggio_macro
001cf5 91f0 2880                 	lds ZH, pulse2_arpeggio_macro+1
001cf7 9630                      	adiw Z, 0
001cf8 f009                      	breq sound_driver_channel1_fx_Qxy_check_pitch_macro
001cf9 cf17                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_pitch_macro:
001cfa 91e0 2887                 	lds ZL, pulse2_pitch_macro
001cfc 91f0 2888                 	lds ZH, pulse2_pitch_macro+1
001cfe 9630                      	adiw Z, 0
001cff f009                      	breq sound_driver_channel1_fx_Qxy_check_hi_pitch_macro
001d00 cf10                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_hi_pitch_macro:
001d01 91e0 288d                 	lds ZL, pulse2_hi_pitch_macro
001d03 91f0 288e                 	lds ZH, pulse2_hi_pitch_macro+1
001d05 9630                      	adiw Z, 0
001d06 f009                      	breq sound_driver_channel1_fx_Qxy_process
001d07 cf09                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_process:
001d08 2fba                      	mov r27, r26 //copy fx parameters into r27
001d09 70bf                      	andi r27, 0x0F //mask note index offset
001d0a 91c0 28b5                 	lds r28, pulse2_fx_Qxy_target_note //load current note index
001d0c 0fbc                      	add r27, r28
001d0d 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001d0e f008                      	brlo sound_driver_channel1_fx_Qxy_process_continue
001d0f e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel1_fx_Qxy_process_continue:
001d10 93b0 28b5                 	sts pulse2_fx_Qxy_target_note, r27
001d12 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001d13 e0f0                      	ldi ZH, HIGH(note_table << 1)
001d14 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001d15 0feb                      	add ZL, r27 //add offset
001d16 1df2                      	adc ZH, zero
001d17 91c5                      	lpm r28, Z+ //load bytes
001d18 91d4                      	lpm r29, Z
001d19 93c0 28b6                 	sts pulse2_fx_Qxy_target, r28 //load the LOW bits for the target period
001d1b 93d0 28b7                 	sts pulse2_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel1_fx_Qxy_process_speed:
001d1d 95a2                      	swap r26
001d1e 70af                      	andi r26, 0x0F //mask effect speed
001d1f 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001d20 95a3                      	inc r26 //increment the speed by 1
                                 
001d21 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001d22 937f                      	push r23
001d23 2f6a                      	mov r22, r26 //store the speed data into r27
001d24 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001d25 9f67                      	mul r22, r23
001d26 917f                      	pop r23
001d27 916f                      	pop r22
                                 
001d28 9416                      	lsr r1 //shift out the fractional bits
001d29 9407                      	ror r0
001d2a 9416                      	lsr r1
001d2b 9407                      	ror r0
001d2c 9416                      	lsr r1
001d2d 9407                      	ror r0
001d2e 9416                      	lsr r1
001d2f 9407                      	ror r0
                                 
001d30 9200 28b8                 	sts pulse2_fx_Qxy_speed, r0 //store the effect speed
001d32 9210 28b9                 	sts pulse2_fx_Qxy_speed+1, r1
001d34 cedc                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel1_fx_Rxy:
                                 sound_driver_channel1_fx_Rxy_check_arpeggio_macro:
001d35 91e0 287f                 	lds ZL, pulse2_arpeggio_macro
001d37 91f0 2880                 	lds ZH, pulse2_arpeggio_macro+1
001d39 9630                      	adiw Z, 0
001d3a f009                      	breq sound_driver_channel1_fx_Rxy_check_pitch_macro
001d3b ced5                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_pitch_macro:
001d3c 91e0 2887                 	lds ZL, pulse2_pitch_macro
001d3e 91f0 2888                 	lds ZH, pulse2_pitch_macro+1
001d40 9630                      	adiw Z, 0
001d41 f009                      	breq sound_driver_channel1_fx_Rxy_check_hi_pitch_macro
001d42 cece                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_hi_pitch_macro:
001d43 91e0 288d                 	lds ZL, pulse2_hi_pitch_macro
001d45 91f0 288e                 	lds ZH, pulse2_hi_pitch_macro+1
001d47 9630                      	adiw Z, 0
001d48 f009                      	breq sound_driver_channel1_fx_Rxy_process
001d49 cec7                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_process:
001d4a 2fba                      	mov r27, r26 //copy fx parameters into r27
001d4b 70bf                      	andi r27, 0x0F //mask note index offset
001d4c 91c0 28bc                 	lds r28, pulse2_fx_Rxy_target_note //load current note index
001d4e 1bcb                      	sub r28, r27
001d4f f408                      	brcc sound_driver_channel1_fx_Rxy_process_continue
001d50 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel1_fx_Rxy_process_continue:
001d51 93c0 28bc                 	sts pulse2_fx_Rxy_target_note, r28
001d53 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001d54 e0f0                      	ldi ZH, HIGH(note_table << 1)
001d55 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001d56 0fec                      	add ZL, r28 //add offset
001d57 1df2                      	adc ZH, zero
001d58 91c5                      	lpm r28, Z+ //load bytes
001d59 91d4                      	lpm r29, Z
001d5a 93c0 28bd                 	sts pulse2_fx_Rxy_target, r28 //load the LOW bits for the target period
001d5c 93d0 28be                 	sts pulse2_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel1_fx_Rxy_process_speed:
001d5e 95a2                      	swap r26
001d5f 70af                      	andi r26, 0x0F //mask effect speed
001d60 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001d61 95a3                      	inc r26 //increment the speed by 1
                                 
001d62 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001d63 937f                      	push r23
001d64 2f6a                      	mov r22, r26 //store the speed data into r27
001d65 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001d66 9f67                      	mul r22, r23
001d67 917f                      	pop r23
001d68 916f                      	pop r22
                                 
001d69 9416                      	lsr r1 //shift out the fractional bits
001d6a 9407                      	ror r0
001d6b 9416                      	lsr r1
001d6c 9407                      	ror r0
001d6d 9416                      	lsr r1
001d6e 9407                      	ror r0
001d6f 9416                      	lsr r1
001d70 9407                      	ror r0
                                 
001d71 9200 28bf                 	sts pulse2_fx_Rxy_speed, r0 //store the effect speed
001d73 9210 28c0                 	sts pulse2_fx_Rxy_speed+1, r1
001d75 ce9b                      	rjmp sound_driver_channel1_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel1_fx_Sxx:
001d76 15a2                      	cp r26, zero
001d77 f051                      	breq sound_driver_channel1_fx_Sxx_invalid
001d78 91b0 281f                 	lds r27, song_speed
001d7a 17ab                      	cp r26, r27
001d7b f430                      	brsh sound_driver_channel1_fx_Sxx_invalid
001d7c 93a0 28c3                 	sts pulse2_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001d7e e0b1                      	ldi r27, 0x01
001d7f 93b0 2876                 	sts pulse2_pattern_delay_rows, r27
001d81 c169                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Sxx_invalid:
001d82 ce8e                      	rjmp sound_driver_channel1_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel1_fx_Vxx:
001d83 eae2                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
001d84 e6f2                      	ldi ZH, HIGH(sequences << 1)
001d85 0fea                      	add ZL, r26 //offset the pointer
001d86 1df2                      	adc ZH, zero
                                 
001d87 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
001d88 95a7                      	ror r26
001d89 95a7                      	ror r26
001d8a 91b0 2808                 	lds r27, pulse2_param //load r27 with pulse2_param (register $4000)
001d8c 2fcb                      	mov r28, r27 //store a copy of pulse2_param into r28
001d8d 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
001d8e 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
001d8f c001                      	rjmp sound_driver_channel1_fx_Vxx_store
001d90 ce80                      	rjmp sound_driver_channel1_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel1_fx_Vxx_store:
001d91 90a4                      	lpm pulse2_sequence, Z //store the sequence
                                 
001d92 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
001d93 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
001d94 93c0 2808                 	sts pulse2_param, r28
001d96 ce7a                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_Wxx: //DPCM sample speed
001d97 ce79                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Xxx: //DPCM sample retrigger
001d98 ce78                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Yxx: //DPCM sample offset
001d99 ce77                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Zxx: //DPCM sample delta counter
001d9a ce76                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 sound_driver_channel1_note:
001d9b 93b0 280f                 	sts pulse2_note, r27 //store the note index
001d9d 93b0 28b5                 	sts pulse2_fx_Qxy_target_note, r27
001d9f 93b0 28bc                 	sts pulse2_fx_Rxy_target_note, r27
001da1 e0a3                      	ldi r26, 0x03
001da2 e0b2                      	ldi r27, 0x02
001da3 93b0 287c                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
001da5 93a0 2881                 	sts pulse2_arpeggio_macro_offset, r26
001da7 93b0 2889                 	sts pulse2_pitch_macro_offset, r27
001da9 93b0 288f                 	sts pulse2_hi_pitch_macro_offset, r27
001dab 93b0 2894                 	sts pulse2_duty_macro_offset, r27
001dad 9220 2885                 	sts pulse2_total_pitch_offset, zero //reset the pitch and hi pitch offset
001daf 9220 2886                 	sts pulse2_total_pitch_offset+1, zero
001db1 9220 288c                 	sts pulse2_total_hi_pitch_offset, zero
001db3 9220 289b                 	sts pulse2_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001db5 9220 289c                 	sts pulse2_fx_1xx_total+1, zero
001db7 9220 289f                 	sts pulse2_fx_2xx_total, zero
001db9 9220 28a0                 	sts pulse2_fx_2xx_total+1, zero
001dbb 9220 28a7                 	sts pulse2_fx_3xx_total_offset, zero //reset 3xx offset
001dbd 9220 28a8                 	sts pulse2_fx_3xx_total_offset+1, zero
001dbf 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001dc1 91b0 0a9d                 	lds r27, TCB1_CCMPH
001dc3 93a0 28a1                 	sts pulse2_fx_3xx_start, r26
001dc5 93b0 28a2                 	sts pulse2_fx_3xx_start+1, r27
001dc7 9220 2809                 	sts pulse2_sweep_param, zero //reset any sweep effect
001dc9 6093                      	sbr pulse_channel_flags, 3 //set reload flag
001dca 9220 28b6                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001dcc 9220 28b7                 	sts pulse2_fx_Qxy_target+1, zero
001dce 9220 28ba                 	sts pulse2_fx_Qxy_total_offset, zero
001dd0 9220 28bb                 	sts pulse2_fx_Qxy_total_offset+1, zero
001dd2 9220 28bd                 	sts pulse2_fx_Rxy_target, zero
001dd4 9220 28be                 	sts pulse2_fx_Rxy_target+1, zero
001dd6 9220 28c1                 	sts pulse2_fx_Rxy_total_offset, zero
001dd8 9220 28c2                 	sts pulse2_fx_Rxy_total_offset+1, zero
001dda d0f9                      	rcall sound_driver_channel1_increment_offset
001ddb ce35                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_volume:
001ddc 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001ddd 91a0 2808                 	lds r26, pulse2_param
001ddf 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001de0 2bab                      	or r26, r27 //move new VVVV bits into pulse2_param
001de1 93a0 2808                 	sts pulse2_param, r26
001de3 6092                      	sbr pulse_channel_flags, 2
001de4 d0ef                      	rcall sound_driver_channel1_increment_offset
001de5 ce2b                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_delay:
001de6 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001de7 93b0 2876                 	sts pulse2_pattern_delay_rows, r27
001de9 d0ea                      	rcall sound_driver_channel1_increment_offset
001dea c100                      	rjmp sound_driver_channel2
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change:
001deb 9220 287a                 	sts pulse2_volume_macro, zero //reset all macro addresses
001ded 9220 287b                 	sts pulse2_volume_macro+1, zero
001def 9220 287f                 	sts pulse2_arpeggio_macro, zero
001df1 9220 2880                 	sts pulse2_arpeggio_macro+1, zero
001df3 9220 2887                 	sts pulse2_pitch_macro, zero
001df5 9220 2888                 	sts pulse2_pitch_macro+1, zero
001df7 9220 288d                 	sts pulse2_hi_pitch_macro, zero
001df9 9220 288e                 	sts pulse2_hi_pitch_macro+1, zero
001dfb 9220 2892                 	sts pulse2_duty_macro, zero
001dfd 9220 2893                 	sts pulse2_duty_macro+1, zero
001dff 9220 2885                 	sts pulse2_total_pitch_offset, zero //reset the pitch offset
001e01 9220 2886                 	sts pulse2_total_pitch_offset+1, zero
001e03 9220 288c                 	sts pulse2_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001e05 9631                      	adiw Z, 1 //point to the byte next to the flag
001e06 91b4                      	lpm r27, Z //store the instrument offset into r27
001e07 e3eb                      	ldi ZL, LOW(instruments) //point Z to instruments table
001e08 e1f1                      	ldi ZH, HIGH(instruments)
001e09 0feb                      	add ZL, r27 //point Z to offsetted instrument
001e0a 1df2                      	adc ZH, zero
001e0b 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001e0c 1fff                      	rol ZH
001e0d 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001e0e 91b4                      	lpm r27, Z
                                 
001e0f 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001e10 1fbb                      	rol r27
001e11 2fea                      	mov ZL, r26
001e12 2ffb                      	mov ZH, r27
001e13 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001e14 9632                      	adiw Z, 2 //point Z to the address of the macro
001e15 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel1_instrument_change_macro_loop:
001e16 95aa                      	dec r26
001e17 f019                      	breq sound_driver_channel1_instrument_change_exit
001e18 95b6                      	lsr r27
001e19 f078                      	brcs sound_driver_channel1_instrument_change_load_macro
001e1a cffb                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_exit:
001e1b e0a3                      	ldi r26, 0x03
001e1c e0b2                      	ldi r27, 0x02
001e1d 93b0 287c                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
001e1f 93a0 2881                 	sts pulse2_arpeggio_macro_offset, r26
001e21 93b0 2889                 	sts pulse2_pitch_macro_offset, r27
001e23 93b0 288f                 	sts pulse2_hi_pitch_macro_offset, r27
001e25 93b0 2894                 	sts pulse2_duty_macro_offset, r27
001e27 d0b6                      	rcall sound_driver_channel1_increment_offset_twice
001e28 cde8                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_load_macro:
001e29 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001e2a 91d5                      	lpm r29, Z+
                                 
001e2b 30a5                      	cpi r26, 5
001e2c f039                      	breq sound_driver_channel1_instrument_change_load_macro_volume
001e2d 30a4                      	cpi r26, 4
001e2e f079                      	breq sound_driver_channel1_instrument_change_load_macro_arpeggio
001e2f 30a3                      	cpi r26, 3
001e30 f0d9                      	breq sound_driver_channel1_instrument_change_load_macro_pitch
001e31 30a2                      	cpi r26, 2
001e32 f159                      	breq sound_driver_channel1_instrument_change_load_macro_hi_pitch
001e33 c03c                      	rjmp sound_driver_channel1_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel1_instrument_change_load_macro_volume:
001e34 93c0 287a                 	sts pulse2_volume_macro, r28
001e36 93d0 287b                 	sts pulse2_volume_macro+1, r29
001e38 d041                      	rcall sound_driver_channel1_instrument_change_read_header
001e39 93c0 287e                 	sts pulse2_volume_macro_release, r28
001e3b 93d0 287d                 	sts pulse2_volume_macro_loop, r29
001e3d cfd8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 	
                                 sound_driver_channel1_instrument_change_load_macro_arpeggio:
001e3e 93c0 287f                 	sts pulse2_arpeggio_macro, r28
001e40 93d0 2880                 	sts pulse2_arpeggio_macro+1, r29
001e42 9220 28b6                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001e44 9220 28b7                 	sts pulse2_fx_Qxy_target+1, zero
001e46 9220 28bd                 	sts pulse2_fx_Rxy_target, zero
001e48 9220 28be                 	sts pulse2_fx_Rxy_target+1, zero
001e4a d03a                      	rcall sound_driver_channel1_instrument_change_read_header_arpeggio
001e4b cfca                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_pitch:
001e4c 93c0 2887                 	sts pulse2_pitch_macro, r28
001e4e 93d0 2888                 	sts pulse2_pitch_macro+1, r29
001e50 9220 28b6                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001e52 9220 28b7                 	sts pulse2_fx_Qxy_target+1, zero
001e54 9220 28bd                 	sts pulse2_fx_Rxy_target, zero
001e56 9220 28be                 	sts pulse2_fx_Rxy_target+1, zero
001e58 d021                      	rcall sound_driver_channel1_instrument_change_read_header
001e59 93c0 288b                 	sts pulse2_pitch_macro_release, r28
001e5b 93d0 288a                 	sts pulse2_pitch_macro_loop, r29
001e5d cfb8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_hi_pitch:
001e5e 93c0 288d                 	sts pulse2_hi_pitch_macro, r28
001e60 93d0 288e                 	sts pulse2_hi_pitch_macro+1, r29
001e62 9220 28b6                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001e64 9220 28b7                 	sts pulse2_fx_Qxy_target+1, zero
001e66 9220 28bd                 	sts pulse2_fx_Rxy_target, zero
001e68 9220 28be                 	sts pulse2_fx_Rxy_target+1, zero
001e6a d00f                      	rcall sound_driver_channel1_instrument_change_read_header
001e6b 93c0 2891                 	sts pulse2_hi_pitch_macro_release, r28
001e6d 93d0 2890                 	sts pulse2_hi_pitch_macro_loop, r29
001e6f cfa6                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_duty:
001e70 93c0 2892                 	sts pulse2_duty_macro, r28
001e72 93d0 2893                 	sts pulse2_duty_macro+1, r29
001e74 d005                      	rcall sound_driver_channel1_instrument_change_read_header
001e75 93c0 2896                 	sts pulse2_duty_macro_release, r28
001e77 93d0 2895                 	sts pulse2_duty_macro_loop, r29
001e79 cf9c                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_read_header:
001e7a 93ef                      	push ZL
001e7b 93ff                      	push ZH
001e7c 2fec                      	mov ZL, r28
001e7d 2ffd                      	mov ZH, r29
001e7e 0fee                      	lsl ZL
001e7f 1fff                      	rol ZH
001e80 91c5                      	lpm r28, Z+
001e81 91d4                      	lpm r29, Z
001e82 91ff                      	pop ZH
001e83 91ef                      	pop ZL
001e84 9508                      	ret
                                 
                                 sound_driver_channel1_instrument_change_read_header_arpeggio:
001e85 93ef                      	push ZL
001e86 93ff                      	push ZH
001e87 2fec                      	mov ZL, r28
001e88 2ffd                      	mov ZH, r29
001e89 0fee                      	lsl ZL
001e8a 1fff                      	rol ZH
001e8b 91c5                      	lpm r28, Z+
001e8c 91d5                      	lpm r29, Z+
001e8d 93c0 2883                 	sts pulse2_arpeggio_macro_release, r28
001e8f 93d0 2882                 	sts pulse2_arpeggio_macro_loop, r29
001e91 91c4                      	lpm r28, Z
001e92 93c0 2884                 	sts pulse2_arpeggio_macro_mode, r28
001e94 91ff                      	pop ZH
001e95 91ef                      	pop ZL
001e96 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel1_release:
                                 sound_driver_channel1_release_volume:
001e97 91b0 287e                 	lds r27, pulse2_volume_macro_release
001e99 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001e9a f019                      	breq sound_driver_channel1_release_arpeggio //if the macro has no release flag, check the next macro
001e9b 95b3                      	inc r27
001e9c 93b0 287c                 	sts pulse2_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel1_release_arpeggio:
001e9e 91b0 2883                 	lds r27, pulse2_arpeggio_macro_release
001ea0 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001ea1 f019                      	breq sound_driver_channel1_release_pitch
001ea2 95b3                      	inc r27
001ea3 93b0 2881                 	sts pulse2_arpeggio_macro_offset, r27
                                 sound_driver_channel1_release_pitch:
001ea5 91b0 288b                 	lds r27, pulse2_pitch_macro_release
001ea7 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001ea8 f019                      	breq sound_driver_channel1_release_hi_pitch
001ea9 95b3                      	inc r27
001eaa 93b0 2889                 	sts pulse2_pitch_macro_offset, r27
                                 sound_driver_channel1_release_hi_pitch:
001eac 91b0 2891                 	lds r27, pulse2_hi_pitch_macro_release
001eae 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001eaf f019                      	breq sound_driver_channel1_release_duty
001eb0 95b3                      	inc r27
001eb1 93b0 288f                 	sts pulse2_hi_pitch_macro_offset, r27
                                 sound_driver_channel1_release_duty:
001eb3 91b0 2896                 	lds r27, pulse2_duty_macro_release
001eb5 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001eb6 f019                      	breq sound_driver_channel1_release_exit
001eb7 95b3                      	inc r27
001eb8 93b0 2894                 	sts pulse2_duty_macro_offset, r27
                                 sound_driver_channel1_release_exit:
001eba d019                      	rcall sound_driver_channel1_increment_offset
001ebb cd55                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_next_pattern:
001ebc 91e0 2819                 	lds ZL, song_frames
001ebe 91f0 281a                 	lds ZH, song_frames+1
001ec0 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001ec2 91b0 281c                 	lds r27, song_frame_offset+1
001ec4 9612                      	adiw r27:r26, 2 //offset for channel 1
001ec5 0fea                      	add ZL, r26
001ec6 1ffb                      	adc ZH, r27
                                 
001ec7 91a5                      	lpm r26, Z+ //load the address of the next pattern
001ec8 91b4                      	lpm r27, Z
001ec9 0faa                      	lsl r26
001eca 1fbb                      	rol r27
001ecb 93a0 2874                 	sts pulse2_pattern, r26
001ecd 93b0 2875                 	sts pulse2_pattern+1, r27
                                 
001ecf 9220 2878                 	sts pulse2_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001ed1 9220 2879                 	sts pulse2_pattern_offset+1, zero
001ed3 cd3d                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_increment_offset:
001ed4 91e0 2878                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001ed6 91f0 2879                 	lds ZH, pulse2_pattern_offset+1
001ed8 9631                      	adiw Z, 1
001ed9 93e0 2878                 	sts pulse2_pattern_offset, ZL
001edb 93f0 2879                 	sts pulse2_pattern_offset+1, ZH
001edd 9508                      	ret
                                 
                                 sound_driver_channel1_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001ede 91e0 2878                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001ee0 91f0 2879                 	lds ZH, pulse2_pattern_offset+1
001ee2 9632                      	adiw Z, 2 //increment the pointer twice
001ee3 93e0 2878                 	sts pulse2_pattern_offset, ZL
001ee5 93f0 2879                 	sts pulse2_pattern_offset+1, ZH
001ee7 9508                      	ret
                                 
                                 sound_driver_channel1_decrement_frame_delay:
001ee8 95ba                      	dec r27
001ee9 93b0 2877                 	sts pulse2_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel2:
001eeb 91a0 28c7                 	lds r26, triangle_pattern_delay_rows
001eed 91b0 28c8                 	lds r27, triangle_pattern_delay_frames
001eef 9610                      	adiw r27:r26, 0
001ef0 f009                      	breq sound_driver_channel2_main //if the pattern delay is 0, proceed with sound driver procedures
001ef1 c2bf                      	rjmp sound_driver_channel2_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel2_main:
001ef2 91e0 28c5                 	lds ZL, triangle_pattern //current pattern for triangle
001ef4 91f0 28c6                 	lds ZH, triangle_pattern+1
001ef6 91a0 28c9                 	lds r26, triangle_pattern_offset //current offset in the pattern for triangle
001ef8 91b0 28ca                 	lds r27, triangle_pattern_offset+1
001efa 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001efb 1ffb                      	adc ZH, r27
001efc 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel2_check_if_note: //check if data is a note (0x00 - 0x56)
001efd 35b7                      	cpi r27, 0x57
001efe f408                      	brsh sound_driver_channel2_check_if_volume
001eff c160                      	rjmp sound_driver_channel2_note
                                 sound_driver_channel2_check_if_volume: //check if data is volume (0x57-0x66)
001f00 36b7                      	cpi r27, 0x67
001f01 f408                      	brsh sound_driver_channel2_check_if_delay
001f02 c19e                      	rjmp sound_driver_channel2_volume
                                 sound_driver_channel2_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001f03 3eb3                      	cpi r27, 0xE3
001f04 f408                      	brsh sound_driver_channel2_check_if_instrument
001f05 c1a9                      	rjmp sound_driver_channel2_delay
                                 sound_driver_channel2_check_if_instrument: //check for instrument flag (0xE3)
001f06 f409                      	brne sound_driver_channel2_check_if_release
001f07 c1ac                      	rjmp sound_driver_channel2_instrument_change 
                                 sound_driver_channel2_check_if_release: //check for note release flag (0xE4)
001f08 3eb4                      	cpi r27, 0xE4
001f09 f409                      	brne sound_driver_channel2_check_if_end
001f0a c255                      	rjmp sound_driver_channel2_release
                                 sound_driver_channel2_check_if_end:
001f0b 3fbf                      	cpi r27, 0xFF
001f0c f409                      	brne sound_driver_channel2_check_if_fx
001f0d c277                      	rjmp sound_driver_channel2_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel2_check_if_fx: //fx flags (0xE5 - 0xFE)
001f0e 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001f0f 91a4                      	lpm r26, Z //load the fx data into r26
001f10 d296                      	rcall sound_driver_channel2_increment_offset_twice
                                 
001f11 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001f12 e0ee                      	ldi ZL, LOW(channel2_fx << 1) //load in note table
001f13 e6f3                      	ldi ZH, HIGH(channel2_fx << 1)
001f14 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001f15 0feb                      	add ZL, r27 //add offset
001f16 1df2                      	adc ZH, zero
001f17 91c5                      	lpm r28, Z+ //load address bytes
001f18 91d4                      	lpm r29, Z
001f19 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001f1a 2ffd                      	mov ZH, r29
001f1b 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel2_fx_0xy:
001f1c 93a0 28e8                 	sts triangle_fx_0xy_sequence, r26
001f1e 9220 28e9                 	sts triangle_fx_0xy_sequence+1, zero
001f20 cfd1                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel2_fx_1xx:
001f21 9220 28ee                 	sts triangle_fx_2xx, zero //turn off any 2xx pitch slide down
001f23 9220 28ef                 	sts triangle_fx_2xx+1, zero
001f25 9220 28e8                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001f27 9220 28e9                 	sts triangle_fx_0xy_sequence+1, zero
001f29 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001f2a 937f                      	push r23
001f2b 2f6a                      	mov r22, r26 //store the rate into r22
001f2c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001f2d 9f67                      	mul r22, r23
001f2e 917f                      	pop r23
001f2f 916f                      	pop r22
                                 
001f30 9416                      	lsr r1 //shift out the fractional bits
001f31 9407                      	ror r0
001f32 9416                      	lsr r1
001f33 9407                      	ror r0
001f34 9416                      	lsr r1
001f35 9407                      	ror r0
001f36 9416                      	lsr r1
001f37 9407                      	ror r0
001f38 9200 28ea                 	sts triangle_fx_1xx, r0
001f3a 9210 28eb                 	sts triangle_fx_1xx+1, r1
001f3c cfb5                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel2_fx_2xx:
001f3d 9220 28ea                 	sts triangle_fx_1xx, zero //turn off any 1xx pitch slide down
001f3f 9220 28eb                 	sts triangle_fx_1xx+1, zero
001f41 9220 28e8                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001f43 9220 28e9                 	sts triangle_fx_0xy_sequence+1, zero
001f45 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001f46 937f                      	push r23
001f47 2f6a                      	mov r22, r26 //store the rate into r22
001f48 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001f49 9f67                      	mul r22, r23
001f4a 917f                      	pop r23
001f4b 916f                      	pop r22
                                 
001f4c 9416                      	lsr r1 //shift out the fractional bits
001f4d 9407                      	ror r0
001f4e 9416                      	lsr r1
001f4f 9407                      	ror r0
001f50 9416                      	lsr r1
001f51 9407                      	ror r0
001f52 9416                      	lsr r1
001f53 9407                      	ror r0
001f54 9200 28ee                 	sts triangle_fx_2xx, r0
001f56 9210 28ef                 	sts triangle_fx_2xx+1, r1
001f58 cf99                      	rjmp sound_driver_channel2_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel2_fx_3xx:
001f59 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001f5a 937f                      	push r23
001f5b 2f6a                      	mov r22, r26 //store the rate into r22
001f5c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001f5d 9f67                      	mul r22, r23
001f5e 917f                      	pop r23
001f5f 916f                      	pop r22
                                 
001f60 9416                      	lsr r1 //shift out the fractional bits
001f61 9407                      	ror r0
001f62 9416                      	lsr r1
001f63 9407                      	ror r0
001f64 9416                      	lsr r1
001f65 9407                      	ror r0
001f66 9416                      	lsr r1
001f67 9407                      	ror r0
001f68 9200 28f6                 	sts triangle_fx_3xx_speed, r0
001f6a 9210 28f7                 	sts triangle_fx_3xx_speed+1, r1
                                 
001f6c 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001f6d c001                      	rjmp sound_driver_channel2_fx_3xx_enabled
001f6e cf83                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_3xx_enabled:
001f6f 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001f71 91b0 0aad                 	lds r27, TCB2_CCMPH
001f73 93a0 28f2                 	sts triangle_fx_3xx_start, r26
001f75 93b0 28f3                 	sts triangle_fx_3xx_start+1, r27
                                 
001f77 9220 28f8                 	sts triangle_fx_3xx_total_offset, zero
001f79 9220 28f9                 	sts triangle_fx_3xx_total_offset+1, zero
001f7b cf76                      	rjmp sound_driver_channel2_main
                                 
                                 //VIBRATO
                                 sound_driver_channel2_fx_4xy:
001f7c 2fba                      	mov r27, r26
001f7d 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001f7e 95a2                      	swap r26
001f7f 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001f80 93a0 28fa                 	sts triangle_fx_4xy_speed, r26
001f82 93b0 28fb                 	sts triangle_fx_4xy_depth, r27
001f84 9220 28fc                 	sts triangle_fx_4xy_phase, zero //reset the phase to 0
001f86 cf6b                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_7xy: //tremelo
001f87 cf6a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Axy: //volume slide
001f88 cf69                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel2_fx_Bxx:
001f89 93a0 2820                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001f8b cf66                      	rjmp sound_driver_channel2_main
                                 
                                 //HALT
                                 sound_driver_channel2_fx_Cxx:
001f8c 93b0 2821                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001f8e cf63                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel2_fx_Dxx:
001f8f 93b0 2822                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001f91 cf60                      	rjmp sound_driver_channel2_main
                                 
                                 //VOLUME
                                 sound_driver_channel2_fx_Exx:
001f92 15a2                      	cp r26, zero
001f93 f021                      	breq sound_driver_channel2_fx_Exx_disable
                                 sound_driver_channel2_fx_Exx_enable:
001f94 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001f95 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001f97 cf5a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Exx_disable:
001f98 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
001f9a 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
001f9c 9220 0aad                 	sts TCB2_CCMPH, zero
001f9e cf53                      	rjmp sound_driver_channel2_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel2_fx_Fxx:
001f9f 93a0 281f                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001fa1 cf50                      	rjmp sound_driver_channel2_main
                                 
                                 //DELAY
                                 sound_driver_channel2_fx_Gxx:
001fa2 15a2                      	cp r26, zero
001fa3 f051                      	breq sound_driver_channel2_fx_Gxx_invalid
001fa4 91b0 281f                 	lds r27, song_speed
001fa6 17ab                      	cp r26, r27
001fa7 f430                      	brsh sound_driver_channel2_fx_Gxx_invalid
001fa8 93a0 28fd                 	sts triangle_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001faa e0b1                      	ldi r27, 0x01
001fab 93b0 28c7                 	sts triangle_pattern_delay_rows, r27
001fad c206                      	rjmp sound_driver_channel3
                                 sound_driver_channel2_fx_Gxx_invalid:
001fae cf43                      	rjmp sound_driver_channel2_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Hxy: //hardware sweep up
001faf cf42                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixy: //hardware sweep down
001fb0 cf41                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Hxx: //FDS modulation depth
001fb1 cf40                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixx: //FDS modulation speed
001fb2 cf3f                      	rjmp sound_driver_channel2_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel2_fx_Pxx:
001fb3 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001fb4 937f                      	push r23
001fb5 2f6a                      	mov r22, r26
001fb6 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001fb7 0367                      	mulsu r22, r23
001fb8 917f                      	pop r23
001fb9 916f                      	pop r22
001fba 9416                      	lsr r1 //shift out the fractional bits
001fbb 9407                      	ror r0
001fbc 9416                      	lsr r1
001fbd 9407                      	ror r0
001fbe 9416                      	lsr r1
001fbf 9407                      	ror r0
001fc0 9416                      	lsr r1
001fc1 9407                      	ror r0
001fc2 fe13                      	sbrs r1, 3 //check if result was a negative number
001fc3 c002                      	rjmp sound_driver_channel2_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel2_fx_Pxx_negative:
001fc4 efb0                      	ldi r27, 0xF0
001fc5 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel2_fx_Pxx_store:
001fc6 9200 28ff                 	sts triangle_fx_Pxx_total, r0
001fc8 9210 2900                 	sts triangle_fx_Pxx_total+1, r1
001fca cf27                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel2_fx_Qxy:
                                 sound_driver_channel2_fx_Qxy_check_arpeggio_macro:
001fcb 91e0 28d0                 	lds ZL, triangle_arpeggio_macro
001fcd 91f0 28d1                 	lds ZH, triangle_arpeggio_macro+1
001fcf 9630                      	adiw Z, 0
001fd0 f009                      	breq sound_driver_channel2_fx_Qxy_check_pitch_macro
001fd1 cf20                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_pitch_macro:
001fd2 91e0 28d8                 	lds ZL, triangle_pitch_macro
001fd4 91f0 28d9                 	lds ZH, triangle_pitch_macro+1
001fd6 9630                      	adiw Z, 0
001fd7 f009                      	breq sound_driver_channel2_fx_Qxy_check_hi_pitch_macro
001fd8 cf19                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_hi_pitch_macro:
001fd9 91e0 28de                 	lds ZL, triangle_hi_pitch_macro
001fdb 91f0 28df                 	lds ZH, triangle_hi_pitch_macro+1
001fdd 9630                      	adiw Z, 0
001fde f009                      	breq sound_driver_channel2_fx_Qxy_process
001fdf cf12                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_process:
001fe0 2fba                      	mov r27, r26 //copy fx parameters into r27
001fe1 70bf                      	andi r27, 0x0F //mask note index offset
001fe2 91c0 2901                 	lds r28, triangle_fx_Qxy_target_note //load current note index
001fe4 0fbc                      	add r27, r28
001fe5 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001fe6 f008                      	brlo sound_driver_channel2_fx_Qxy_process_continue
001fe7 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel2_fx_Qxy_process_continue:
001fe8 93b0 2901                 	sts triangle_fx_Qxy_target_note, r27
001fea e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001feb e0f0                      	ldi ZH, HIGH(note_table << 1)
001fec 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001fed 0feb                      	add ZL, r27 //add offset
001fee 1df2                      	adc ZH, zero
001fef 91c5                      	lpm r28, Z+ //load bytes
001ff0 91d4                      	lpm r29, Z
001ff1 93c0 2902                 	sts triangle_fx_Qxy_target, r28 //load the LOW bits for the target period
001ff3 93d0 2903                 	sts triangle_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel2_fx_Qxy_process_speed:
001ff5 95a2                      	swap r26
001ff6 70af                      	andi r26, 0x0F //mask effect speed
001ff7 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001ff8 95a3                      	inc r26 //increment the speed by 1
                                 
001ff9 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001ffa 937f                      	push r23
001ffb 2f6a                      	mov r22, r26 //store the speed data into r27
001ffc eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001ffd 9f67                      	mul r22, r23
001ffe 917f                      	pop r23
001fff 916f                      	pop r22
                                 
002000 9416                      	lsr r1 //shift out the fractional bits
002001 9407                      	ror r0
002002 9416                      	lsr r1
002003 9407                      	ror r0
002004 9416                      	lsr r1
002005 9407                      	ror r0
002006 9416                      	lsr r1
002007 9407                      	ror r0
                                 
002008 9200 2904                 	sts triangle_fx_Qxy_speed, r0 //store the effect speed
00200a 9210 2905                 	sts triangle_fx_Qxy_speed+1, r1
00200c cee5                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel2_fx_Rxy:
                                 sound_driver_channel2_fx_Rxy_check_arpeggio_macro:
00200d 91e0 28d0                 	lds ZL, triangle_arpeggio_macro
00200f 91f0 28d1                 	lds ZH, triangle_arpeggio_macro+1
002011 9630                      	adiw Z, 0
002012 f009                      	breq sound_driver_channel2_fx_Rxy_check_pitch_macro
002013 cede                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_pitch_macro:
002014 91e0 28d8                 	lds ZL, triangle_pitch_macro
002016 91f0 28d9                 	lds ZH, triangle_pitch_macro+1
002018 9630                      	adiw Z, 0
002019 f009                      	breq sound_driver_channel2_fx_Rxy_check_hi_pitch_macro
00201a ced7                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_hi_pitch_macro:
00201b 91e0 28de                 	lds ZL, triangle_hi_pitch_macro
00201d 91f0 28df                 	lds ZH, triangle_hi_pitch_macro+1
00201f 9630                      	adiw Z, 0
002020 f009                      	breq sound_driver_channel2_fx_Rxy_process
002021 ced0                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_process:
002022 2fba                      	mov r27, r26 //copy fx parameters into r27
002023 70bf                      	andi r27, 0x0F //mask note index offset
002024 91c0 2908                 	lds r28, triangle_fx_Rxy_target_note //load current note index
002026 1bcb                      	sub r28, r27
002027 f408                      	brcc sound_driver_channel2_fx_Rxy_process_continue
002028 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel2_fx_Rxy_process_continue:
002029 93c0 2908                 	sts triangle_fx_Rxy_target_note, r28
00202b e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
00202c e0f0                      	ldi ZH, HIGH(note_table << 1)
00202d 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
00202e 0fec                      	add ZL, r28 //add offset
00202f 1df2                      	adc ZH, zero
002030 91c5                      	lpm r28, Z+ //load bytes
002031 91d4                      	lpm r29, Z
002032 93c0 2909                 	sts triangle_fx_Rxy_target, r28 //load the LOW bits for the target period
002034 93d0 290a                 	sts triangle_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel2_fx_Rxy_process_speed:
002036 95a2                      	swap r26
002037 70af                      	andi r26, 0x0F //mask effect speed
002038 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
002039 95a3                      	inc r26 //increment the speed by 1
                                 
00203a 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00203b 937f                      	push r23
00203c 2f6a                      	mov r22, r26 //store the speed data into r27
00203d eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00203e 9f67                      	mul r22, r23
00203f 917f                      	pop r23
002040 916f                      	pop r22
                                 
002041 9416                      	lsr r1 //shift out the fractional bits
002042 9407                      	ror r0
002043 9416                      	lsr r1
002044 9407                      	ror r0
002045 9416                      	lsr r1
002046 9407                      	ror r0
002047 9416                      	lsr r1
002048 9407                      	ror r0
                                 
002049 9200 290b                 	sts triangle_fx_Rxy_speed, r0 //store the effect speed
00204b 9210 290c                 	sts triangle_fx_Rxy_speed+1, r1
00204d cea4                      	rjmp sound_driver_channel2_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel2_fx_Sxx:
00204e 15a2                      	cp r26, zero
00204f f051                      	breq sound_driver_channel2_fx_Sxx_invalid
002050 91b0 281f                 	lds r27, song_speed
002052 17ab                      	cp r26, r27
002053 f430                      	brsh sound_driver_channel2_fx_Sxx_invalid
002054 93a0 290f                 	sts triangle_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
002056 e0b1                      	ldi r27, 0x01
002057 93b0 28c7                 	sts triangle_pattern_delay_rows, r27
002059 c15a                      	rjmp sound_driver_channel3
                                 sound_driver_channel2_fx_Sxx_invalid:
00205a ce97                      	rjmp sound_driver_channel2_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Vxx: //duty
00205b ce96                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Wxx: //DPCM sample speed
00205c ce95                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Xxx: //DPCM sample retrigger
00205d ce94                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Yxx: //DPCM sample offset
00205e ce93                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Zxx: //DPCM sample delta counter
00205f ce92                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 sound_driver_channel2_note:
002060 93b0 2812                 	sts triangle_note, r27 //store the note index
002062 93b0 2901                 	sts triangle_fx_Qxy_target_note, r27
002064 93b0 2908                 	sts triangle_fx_Rxy_target_note, r27
002066 e0a3                      	ldi r26, 0x03
002067 e0b2                      	ldi r27, 0x02
002068 93b0 28cd                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
00206a 93a0 28d2                 	sts triangle_arpeggio_macro_offset, r26
00206c 93b0 28da                 	sts triangle_pitch_macro_offset, r27
00206e 93b0 28e0                 	sts triangle_hi_pitch_macro_offset, r27
002070 93b0 28e5                 	sts triangle_duty_macro_offset, r27
002072 9220 28d6                 	sts triangle_total_pitch_offset, zero //reset the pitch and hi pitch offset
002074 9220 28d7                 	sts triangle_total_pitch_offset+1, zero
002076 9220 28dd                 	sts triangle_total_hi_pitch_offset, zero
002078 9220 28ec                 	sts triangle_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
00207a 9220 28ed                 	sts triangle_fx_1xx_total+1, zero
00207c 9220 28f0                 	sts triangle_fx_2xx_total, zero
00207e 9220 28f1                 	sts triangle_fx_2xx_total+1, zero
002080 9220 28f8                 	sts triangle_fx_3xx_total_offset, zero //reset 3xx offset
002082 9220 28f9                 	sts triangle_fx_3xx_total_offset+1, zero
002084 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
002086 91b0 0aad                 	lds r27, TCB2_CCMPH
002088 93a0 28f2                 	sts triangle_fx_3xx_start, r26
00208a 93b0 28f3                 	sts triangle_fx_3xx_start+1, r27
00208c 9220 2902                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00208e 9220 2903                 	sts triangle_fx_Qxy_target+1, zero
002090 9220 2906                 	sts triangle_fx_Qxy_total_offset, zero
002092 9220 2907                 	sts triangle_fx_Qxy_total_offset+1, zero
002094 9220 2909                 	sts triangle_fx_Rxy_target, zero
002096 9220 290a                 	sts triangle_fx_Rxy_target+1, zero
002098 9220 290d                 	sts triangle_fx_Rxy_total_offset, zero
00209a 9220 290e                 	sts triangle_fx_Rxy_total_offset+1, zero
00209c e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
00209d 93b0 0aa5                 	sts TCB2_INTCTRL, r27
00209f d0fd                      	rcall sound_driver_channel2_increment_offset
0020a0 ce51                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_volume:
0020a1 d0fb                      	rcall sound_driver_channel2_increment_offset
0020a2 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
0020a3 f021                      	breq sound_driver_channel2_volume_disable
                                 sound_driver_channel2_volume_enable:
0020a4 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
0020a5 93b0 0aa5                 	sts TCB2_INTCTRL, r27
0020a7 ce4a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_volume_disable:
0020a8 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
0020aa 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
0020ac 9220 0aad                 	sts TCB2_CCMPH, zero
0020ae ce43                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_delay:
0020af 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
0020b0 93b0 28c7                 	sts triangle_pattern_delay_rows, r27
0020b2 d0ea                      	rcall sound_driver_channel2_increment_offset
0020b3 c100                      	rjmp sound_driver_channel3
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change:
0020b4 9220 28cb                 	sts triangle_volume_macro, zero //reset all macro addresses
0020b6 9220 28cc                 	sts triangle_volume_macro+1, zero
0020b8 9220 28d0                 	sts triangle_arpeggio_macro, zero
0020ba 9220 28d1                 	sts triangle_arpeggio_macro+1, zero
0020bc 9220 28d8                 	sts triangle_pitch_macro, zero
0020be 9220 28d9                 	sts triangle_pitch_macro+1, zero
0020c0 9220 28de                 	sts triangle_hi_pitch_macro, zero
0020c2 9220 28df                 	sts triangle_hi_pitch_macro+1, zero
0020c4 9220 28e3                 	sts triangle_duty_macro, zero
0020c6 9220 28e4                 	sts triangle_duty_macro+1, zero
0020c8 9220 28d6                 	sts triangle_total_pitch_offset, zero //reset the pitch offset
0020ca 9220 28d7                 	sts triangle_total_pitch_offset+1, zero
0020cc 9220 28dd                 	sts triangle_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
0020ce 9631                      	adiw Z, 1 //point to the byte next to the flag
0020cf 91b4                      	lpm r27, Z //store the instrument offset into r27
0020d0 e3eb                      	ldi ZL, LOW(instruments) //point Z to instruments table
0020d1 e1f1                      	ldi ZH, HIGH(instruments)
0020d2 0feb                      	add ZL, r27 //point Z to offsetted instrument
0020d3 1df2                      	adc ZH, zero
0020d4 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
0020d5 1fff                      	rol ZH
0020d6 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
0020d7 91b4                      	lpm r27, Z
                                 
0020d8 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
0020d9 1fbb                      	rol r27
0020da 2fea                      	mov ZL, r26
0020db 2ffb                      	mov ZH, r27
0020dc 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
0020dd 9632                      	adiw Z, 2 //point Z to the address of the macro
0020de e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel2_instrument_change_macro_loop:
0020df 95aa                      	dec r26
0020e0 f019                      	breq sound_driver_channel2_instrument_change_exit
0020e1 95b6                      	lsr r27
0020e2 f078                      	brcs sound_driver_channel2_instrument_change_load_macro
0020e3 cffb                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_exit:
0020e4 e0a3                      	ldi r26, 0x03
0020e5 e0b2                      	ldi r27, 0x02
0020e6 93b0 28cd                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
0020e8 93a0 28d2                 	sts triangle_arpeggio_macro_offset, r26
0020ea 93b0 28da                 	sts triangle_pitch_macro_offset, r27
0020ec 93b0 28e0                 	sts triangle_hi_pitch_macro_offset, r27
0020ee 93b0 28e5                 	sts triangle_duty_macro_offset, r27
0020f0 d0b6                      	rcall sound_driver_channel2_increment_offset_twice
0020f1 ce00                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_load_macro:
0020f2 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
0020f3 91d5                      	lpm r29, Z+
                                 
0020f4 30a5                      	cpi r26, 5
0020f5 f039                      	breq sound_driver_channel2_instrument_change_load_macro_volume
0020f6 30a4                      	cpi r26, 4
0020f7 f079                      	breq sound_driver_channel2_instrument_change_load_macro_arpeggio
0020f8 30a3                      	cpi r26, 3
0020f9 f0d9                      	breq sound_driver_channel2_instrument_change_load_macro_pitch
0020fa 30a2                      	cpi r26, 2
0020fb f159                      	breq sound_driver_channel2_instrument_change_load_macro_hi_pitch
0020fc c03c                      	rjmp sound_driver_channel2_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel2_instrument_change_load_macro_volume:
0020fd 93c0 28cb                 	sts triangle_volume_macro, r28
0020ff 93d0 28cc                 	sts triangle_volume_macro+1, r29
002101 d041                      	rcall sound_driver_channel2_instrument_change_read_header
002102 93c0 28cf                 	sts triangle_volume_macro_release, r28
002104 93d0 28ce                 	sts triangle_volume_macro_loop, r29
002106 cfd8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 	
                                 sound_driver_channel2_instrument_change_load_macro_arpeggio:
002107 93c0 28d0                 	sts triangle_arpeggio_macro, r28
002109 93d0 28d1                 	sts triangle_arpeggio_macro+1, r29
00210b 9220 2902                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00210d 9220 2903                 	sts triangle_fx_Qxy_target+1, zero
00210f 9220 2909                 	sts triangle_fx_Rxy_target, zero
002111 9220 290a                 	sts triangle_fx_Rxy_target+1, zero
002113 d03a                      	rcall sound_driver_channel2_instrument_change_read_header_arpeggio
002114 cfca                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_pitch:
002115 93c0 28d8                 	sts triangle_pitch_macro, r28
002117 93d0 28d9                 	sts triangle_pitch_macro+1, r29
002119 9220 2902                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00211b 9220 2903                 	sts triangle_fx_Qxy_target+1, zero
00211d 9220 2909                 	sts triangle_fx_Rxy_target, zero
00211f 9220 290a                 	sts triangle_fx_Rxy_target+1, zero
002121 d021                      	rcall sound_driver_channel2_instrument_change_read_header
002122 93c0 28dc                 	sts triangle_pitch_macro_release, r28
002124 93d0 28db                 	sts triangle_pitch_macro_loop, r29
002126 cfb8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_hi_pitch:
002127 93c0 28de                 	sts triangle_hi_pitch_macro, r28
002129 93d0 28df                 	sts triangle_hi_pitch_macro+1, r29
00212b 9220 2902                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00212d 9220 2903                 	sts triangle_fx_Qxy_target+1, zero
00212f 9220 2909                 	sts triangle_fx_Rxy_target, zero
002131 9220 290a                 	sts triangle_fx_Rxy_target+1, zero
002133 d00f                      	rcall sound_driver_channel2_instrument_change_read_header
002134 93c0 28e2                 	sts triangle_hi_pitch_macro_release, r28
002136 93d0 28e1                 	sts triangle_hi_pitch_macro_loop, r29
002138 cfa6                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_duty:
002139 93c0 28e3                 	sts triangle_duty_macro, r28
00213b 93d0 28e4                 	sts triangle_duty_macro+1, r29
00213d d005                      	rcall sound_driver_channel2_instrument_change_read_header
00213e 93c0 28e7                 	sts triangle_duty_macro_release, r28
002140 93d0 28e6                 	sts triangle_duty_macro_loop, r29
002142 cf9c                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_read_header:
002143 93ef                      	push ZL
002144 93ff                      	push ZH
002145 2fec                      	mov ZL, r28
002146 2ffd                      	mov ZH, r29
002147 0fee                      	lsl ZL
002148 1fff                      	rol ZH
002149 91c5                      	lpm r28, Z+
00214a 91d4                      	lpm r29, Z
00214b 91ff                      	pop ZH
00214c 91ef                      	pop ZL
00214d 9508                      	ret
                                 
                                 sound_driver_channel2_instrument_change_read_header_arpeggio:
00214e 93ef                      	push ZL
00214f 93ff                      	push ZH
002150 2fec                      	mov ZL, r28
002151 2ffd                      	mov ZH, r29
002152 0fee                      	lsl ZL
002153 1fff                      	rol ZH
002154 91c5                      	lpm r28, Z+
002155 91d5                      	lpm r29, Z+
002156 93c0 28d4                 	sts triangle_arpeggio_macro_release, r28
002158 93d0 28d3                 	sts triangle_arpeggio_macro_loop, r29
00215a 91c4                      	lpm r28, Z
00215b 93c0 28d5                 	sts triangle_arpeggio_macro_mode, r28
00215d 91ff                      	pop ZH
00215e 91ef                      	pop ZL
00215f 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel2_release:
                                 sound_driver_channel2_release_volume:
002160 91b0 28cf                 	lds r27, triangle_volume_macro_release
002162 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
002163 f019                      	breq sound_driver_channel2_release_arpeggio //if the macro has no release flag, check the next macro
002164 95b3                      	inc r27
002165 93b0 28cd                 	sts triangle_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel2_release_arpeggio:
002167 91b0 28d4                 	lds r27, triangle_arpeggio_macro_release
002169 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
00216a f019                      	breq sound_driver_channel2_release_pitch
00216b 95b3                      	inc r27
00216c 93b0 28d2                 	sts triangle_arpeggio_macro_offset, r27
                                 sound_driver_channel2_release_pitch:
00216e 91b0 28dc                 	lds r27, triangle_pitch_macro_release
002170 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
002171 f019                      	breq sound_driver_channel2_release_hi_pitch
002172 95b3                      	inc r27
002173 93b0 28da                 	sts triangle_pitch_macro_offset, r27
                                 sound_driver_channel2_release_hi_pitch:
002175 91b0 28e2                 	lds r27, triangle_hi_pitch_macro_release
002177 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
002178 f019                      	breq sound_driver_channel2_release_duty
002179 95b3                      	inc r27
00217a 93b0 28e0                 	sts triangle_hi_pitch_macro_offset, r27
                                 sound_driver_channel2_release_duty:
00217c 91b0 28e7                 	lds r27, triangle_duty_macro_release
00217e 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
00217f f019                      	breq sound_driver_channel2_release_exit
002180 95b3                      	inc r27
002181 93b0 28e5                 	sts triangle_duty_macro_offset, r27
                                 sound_driver_channel2_release_exit:
002183 d019                      	rcall sound_driver_channel2_increment_offset
002184 cd6d                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_next_pattern:
002185 91e0 2819                 	lds ZL, song_frames
002187 91f0 281a                 	lds ZH, song_frames+1
002189 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
00218b 91b0 281c                 	lds r27, song_frame_offset+1
00218d 9614                      	adiw r27:r26, 4 //offset for channel 2
00218e 0fea                      	add ZL, r26
00218f 1ffb                      	adc ZH, r27
                                 
002190 91a5                      	lpm r26, Z+ //load the address of the next pattern
002191 91b4                      	lpm r27, Z
002192 0faa                      	lsl r26
002193 1fbb                      	rol r27
002194 93a0 28c5                 	sts triangle_pattern, r26
002196 93b0 28c6                 	sts triangle_pattern+1, r27
                                 
002198 9220 28c9                 	sts triangle_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
00219a 9220 28ca                 	sts triangle_pattern_offset+1, zero
00219c cd55                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_increment_offset:
00219d 91e0 28c9                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
00219f 91f0 28ca                 	lds ZH, triangle_pattern_offset+1
0021a1 9631                      	adiw Z, 1
0021a2 93e0 28c9                 	sts triangle_pattern_offset, ZL
0021a4 93f0 28ca                 	sts triangle_pattern_offset+1, ZH
0021a6 9508                      	ret
                                 
                                 sound_driver_channel2_increment_offset_twice: //used for data that takes up 2 bytes worth of space
0021a7 91e0 28c9                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
0021a9 91f0 28ca                 	lds ZH, triangle_pattern_offset+1
0021ab 9632                      	adiw Z, 2 //increment the pointer twice
0021ac 93e0 28c9                 	sts triangle_pattern_offset, ZL
0021ae 93f0 28ca                 	sts triangle_pattern_offset+1, ZH
0021b0 9508                      	ret
                                 
                                 sound_driver_channel2_decrement_frame_delay:
0021b1 95ba                      	dec r27
0021b2 93b0 28c8                 	sts triangle_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel3:
0021b4 91a0 2913                 	lds r26, noise_pattern_delay_rows
0021b6 91b0 2914                 	lds r27, noise_pattern_delay_frames
0021b8 9610                      	adiw r27:r26, 0
0021b9 f009                      	breq sound_driver_channel3_main //if the pattern delay is 0, proceed with sound driver procedures
0021ba c1b9                      	rjmp sound_driver_channel3_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel3_main:
0021bb 91e0 2911                 	lds ZL, noise_pattern //current pattern for noise
0021bd 91f0 2912                 	lds ZH, noise_pattern+1
0021bf 91a0 2915                 	lds r26, noise_pattern_offset //current offset in the pattern for noise
0021c1 91b0 2916                 	lds r27, noise_pattern_offset+1
0021c3 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
0021c4 1ffb                      	adc ZH, r27
0021c5 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel3_check_if_note: //check if data is a note (0x00 - 0x56)
0021c6 35b7                      	cpi r27, 0x57
0021c7 f408                      	brsh sound_driver_channel3_check_if_volume
0021c8 c096                      	rjmp sound_driver_channel3_note
                                 sound_driver_channel3_check_if_volume: //check if data is volume (0x57-0x66)
0021c9 36b7                      	cpi r27, 0x67
0021ca f408                      	brsh sound_driver_channel3_check_if_delay
0021cb c0b1                      	rjmp sound_driver_channel3_volume
                                 sound_driver_channel3_check_if_delay: //check if data is a delay (0x67 - 0xE2)
0021cc 3eb3                      	cpi r27, 0xE3
0021cd f408                      	brsh sound_driver_channel3_check_if_instrument
0021ce c0b7                      	rjmp sound_driver_channel3_delay
                                 sound_driver_channel3_check_if_instrument: //check for instrument flag (0xE3)
0021cf f409                      	brne sound_driver_channel3_check_if_release
0021d0 c0ba                      	rjmp sound_driver_channel3_instrument_change 
                                 sound_driver_channel3_check_if_release: //check for note release flag (0xE4)
0021d1 3eb4                      	cpi r27, 0xE4
0021d2 f409                      	brne sound_driver_channel3_check_if_end
0021d3 c14b                      	rjmp sound_driver_channel3_release
                                 sound_driver_channel3_check_if_end:
0021d4 3fbf                      	cpi r27, 0xFF
0021d5 f409                      	brne sound_driver_channel3_check_if_fx
0021d6 c16d                      	rjmp sound_driver_channel3_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel3_check_if_fx: //fx flags (0xE5 - 0xFE)
0021d7 9631                      	adiw Z, 1 //point Z to the byte next to the flag
0021d8 91a4                      	lpm r26, Z //load the fx data into r26
0021d9 d190                      	rcall sound_driver_channel3_increment_offset_twice
                                 
0021da 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
0021db e4e2                      	ldi ZL, LOW(channel3_fx << 1) //load in note table
0021dc e6f3                      	ldi ZH, HIGH(channel3_fx << 1)
0021dd 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
0021de 0feb                      	add ZL, r27 //add offset
0021df 1df2                      	adc ZH, zero
0021e0 91c5                      	lpm r28, Z+ //load address bytes
0021e1 91d4                      	lpm r29, Z
0021e2 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
0021e3 2ffd                      	mov ZH, r29
0021e4 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel3_fx_0xy:
0021e5 93a0 2934                 	sts noise_fx_0xy_sequence, r26
0021e7 9220 2935                 	sts noise_fx_0xy_sequence+1, zero
0021e9 cfd1                      	rjmp sound_driver_channel3_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel3_fx_1xx:
0021ea 9220 2938                 	sts noise_fx_2xx, zero //turn off any 2xx pitch slide down
0021ec 9220 2934                 	sts noise_fx_0xy_sequence, zero //disable any 0xy effect
0021ee 9220 2935                 	sts noise_fx_0xy_sequence+1, zero
0021f0 93a0 2936                 	sts noise_fx_1xx, r26
0021f2 cfc8                      	rjmp sound_driver_channel3_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel3_fx_2xx:
0021f3 9220 2936                 	sts noise_fx_1xx, zero //turn off any 1xx pitch slide down
0021f5 9220 2934                 	sts noise_fx_0xy_sequence, zero //disable any 0xy effect
0021f7 9220 2935                 	sts noise_fx_0xy_sequence+1, zero
0021f9 93a0 2938                 	sts noise_fx_2xx, r26
0021fb cfbf                      	rjmp sound_driver_channel3_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel3_fx_3xx:
0021fc cfbe                      	rjmp sound_driver_channel3_main
                                 
                                 //VIBRATO
                                 sound_driver_channel3_fx_4xy:
0021fd 2fba                      	mov r27, r26
0021fe 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
0021ff 95a2                      	swap r26
002200 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
002201 93a0 293a                 	sts noise_fx_4xy_speed, r26
002203 93b0 293b                 	sts noise_fx_4xy_depth, r27
002205 9220 293c                 	sts noise_fx_4xy_phase, zero //reset the phase to 0
002207 9220 293d                 	sts noise_fx_4xy_offset, zero
002209 cfb1                      	rjmp sound_driver_channel3_main
                                 
                                 //TREMELO
                                 sound_driver_channel3_fx_7xy:
00220a 2fba                      	mov r27, r26
00220b 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
00220c 95a2                      	swap r26
00220d 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
00220e 93a0 293e                 	sts noise_fx_7xy_speed, r26
002210 93b0 293f                 	sts noise_fx_7xy_depth, r27
002212 9220 2940                 	sts noise_fx_7xy_phase, zero //reset the phase to 0
002214 9220 2941                 	sts noise_fx_7xy_value, zero //reset the tremelo value
002216 cfa4                      	rjmp sound_driver_channel3_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel3_fx_Axy:
002217 93a0 2942                 	sts noise_fx_Axy, r26
002219 cfa1                      	rjmp sound_driver_channel3_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel3_fx_Bxx:
00221a 93a0 2820                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
00221c cf9e                      	rjmp sound_driver_channel3_main
                                 
                                 //HALT
                                 sound_driver_channel3_fx_Cxx:
00221d 93b0 2821                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
00221f cf9b                      	rjmp sound_driver_channel3_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel3_fx_Dxx:
002220 93b0 2822                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
002222 cf98                      	rjmp sound_driver_channel3_main
                                 
                                 //VOLUME
                                 sound_driver_channel3_fx_Exx:
002223 91b0 2813                 	lds r27, noise_param
002225 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
002226 2bba                      	or r27, r26 //move new VVVV bits into noise_param
002227 93b0 2813                 	sts noise_param, r27
002229 cf91                      	rjmp sound_driver_channel3_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel3_fx_Fxx:
00222a 93a0 281f                 	sts song_speed, r26 //NOTE: only changes to speed are supported
00222c cf8e                      	rjmp sound_driver_channel3_main
                                 
                                 //DELAY
                                 sound_driver_channel3_fx_Gxx:
00222d 15a2                      	cp r26, zero
00222e f051                      	breq sound_driver_channel3_fx_Gxx_invalid
00222f 91b0 281f                 	lds r27, song_speed
002231 17ab                      	cp r26, r27
002232 f430                      	brsh sound_driver_channel3_fx_Gxx_invalid
002233 93a0 2943                 	sts noise_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
002235 e0b1                      	ldi r27, 0x01
002236 93b0 2913                 	sts noise_pattern_delay_rows, r27
002238 c13e                      	rjmp sound_driver_channel4
                                 sound_driver_channel3_fx_Gxx_invalid:
002239 cf81                      	rjmp sound_driver_channel3_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel3_fx_Hxy: //hardware sweep up
00223a cf80                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Ixy: //hardware sweep down
00223b cf7f                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Hxx: //FDS modulation depth
00223c cf7e                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Ixx: //FDS modulation speed
00223d cf7d                      	rjmp sound_driver_channel3_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel3_fx_Pxx:
00223e 93a0 2945                 	sts noise_fx_Pxx_total, r26
002240 cf7a                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_Qxy: //note slide up
002241 cf79                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Rxy: //note slide down
002242 cf78                      	rjmp sound_driver_channel3_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel3_fx_Sxx:
002243 15a2                      	cp r26, zero
002244 f051                      	breq sound_driver_channel3_fx_Sxx_invalid
002245 91b0 281f                 	lds r27, song_speed
002247 17ab                      	cp r26, r27
002248 f430                      	brsh sound_driver_channel3_fx_Sxx_invalid
002249 93a0 2946                 	sts noise_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
00224b e0b1                      	ldi r27, 0x01
00224c 93b0 2913                 	sts noise_pattern_delay_rows, r27
00224e c128                      	rjmp sound_driver_channel4
                                 sound_driver_channel3_fx_Sxx_invalid:
00224f cf6b                      	rjmp sound_driver_channel3_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel3_fx_Vxx:
002250 95a6                      	lsr r26
002251 95a7                      	ror r26 //move mode bit to bit 7
002252 91b0 2814                 	lds r27, noise_period
002254 77bf                      	andi r27, 0b01111111
002255 2bba                      	or r27, r26 //store the new noise mode
002256 93b0 2813                 	sts noise_param, r27
                                 
002258 776f                      	andi noise_sequence_HIGH, 0b01111111
002259 2b6a                      	or noise_sequence_HIGH, r26
00225a cf60                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_Wxx: //DPCM sample speed
00225b cf5f                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Xxx: //DPCM sample retrigger
00225c cf5e                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Yxx: //DPCM sample offset
00225d cf5d                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Zxx: //DPCM sample delta counter
00225e cf5c                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 sound_driver_channel3_note:
00225f 93b0 2817                 	sts noise_note, r27
002261 93b0 2818                 	sts noise_adjusted_note, r27
002263 e0a3                      	ldi r26, 0x03
002264 e0b2                      	ldi r27, 0x02
002265 93b0 2919                 	sts noise_volume_macro_offset, r27 //reset all macro offsets
002267 93a0 291e                 	sts noise_arpeggio_macro_offset, r26
002269 93b0 2926                 	sts noise_pitch_macro_offset, r27
00226b 93b0 292c                 	sts noise_hi_pitch_macro_offset, r27
00226d 93b0 2931                 	sts noise_duty_macro_offset, r27
00226f 9220 2922                 	sts noise_total_pitch_offset, zero //reset the pitch and hi pitch offset
002271 9220 2923                 	sts noise_total_pitch_offset+1, zero
002273 9220 2929                 	sts noise_total_hi_pitch_offset, zero
002275 9220 2937                 	sts noise_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
002277 9220 2939                 	sts noise_fx_2xx_total, zero
002279 9220 293d                 	sts noise_fx_4xy_offset, zero
00227b d0e4                      	rcall sound_driver_channel3_increment_offset
00227c cf3e                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_volume:
00227d 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
00227e 91a0 2813                 	lds r26, noise_param
002280 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
002281 2bab                      	or r26, r27 //move new VVVV bits into noise_param
002282 93a0 2813                 	sts noise_param, r26
002284 d0db                      	rcall sound_driver_channel3_increment_offset
002285 cf35                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_delay:
002286 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
002287 93b0 2913                 	sts noise_pattern_delay_rows, r27
002289 d0d6                      	rcall sound_driver_channel3_increment_offset
00228a c0ec                      	rjmp sound_driver_channel4
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change:
00228b 9220 2917                 	sts noise_volume_macro, zero //reset all macro addresses
00228d 9220 2918                 	sts noise_volume_macro+1, zero
00228f 9220 291c                 	sts noise_arpeggio_macro, zero
002291 9220 291d                 	sts noise_arpeggio_macro+1, zero
002293 9220 2924                 	sts noise_pitch_macro, zero
002295 9220 2925                 	sts noise_pitch_macro+1, zero
002297 9220 292a                 	sts noise_hi_pitch_macro, zero
002299 9220 292b                 	sts noise_hi_pitch_macro+1, zero
00229b 9220 292f                 	sts noise_duty_macro, zero
00229d 9220 2930                 	sts noise_duty_macro+1, zero
00229f 9220 2922                 	sts noise_total_pitch_offset, zero //reset the pitch offset
0022a1 9220 2923                 	sts noise_total_pitch_offset+1, zero
0022a3 9220 2929                 	sts noise_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
0022a5 9631                      	adiw Z, 1 //point to the byte next to the flag
0022a6 91b4                      	lpm r27, Z //store the instrument offset into r27
0022a7 e3eb                      	ldi ZL, LOW(instruments) //point Z to instruments table
0022a8 e1f1                      	ldi ZH, HIGH(instruments)
0022a9 0feb                      	add ZL, r27 //point Z to offsetted instrument
0022aa 1df2                      	adc ZH, zero
0022ab 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
0022ac 1fff                      	rol ZH
0022ad 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
0022ae 91b4                      	lpm r27, Z
                                 
0022af 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
0022b0 1fbb                      	rol r27
0022b1 2fea                      	mov ZL, r26
0022b2 2ffb                      	mov ZH, r27
0022b3 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
0022b4 9632                      	adiw Z, 2 //point Z to the address of the macro
0022b5 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel3_instrument_change_macro_loop:
0022b6 95aa                      	dec r26
0022b7 f019                      	breq sound_driver_channel3_instrument_change_exit
0022b8 95b6                      	lsr r27
0022b9 f078                      	brcs sound_driver_channel3_instrument_change_load_macro
0022ba cffb                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_exit:
0022bb e0a3                      	ldi r26, 0x03
0022bc e0b2                      	ldi r27, 0x02
0022bd 93b0 2919                 	sts noise_volume_macro_offset, r27 //reset all macro offsets
0022bf 93a0 291e                 	sts noise_arpeggio_macro_offset, r26
0022c1 93b0 2926                 	sts noise_pitch_macro_offset, r27
0022c3 93b0 292c                 	sts noise_hi_pitch_macro_offset, r27
0022c5 93b0 2931                 	sts noise_duty_macro_offset, r27
0022c7 d0a2                      	rcall sound_driver_channel3_increment_offset_twice
0022c8 cef2                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_load_macro:
0022c9 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
0022ca 91d5                      	lpm r29, Z+
                                 
0022cb 30a5                      	cpi r26, 5
0022cc f039                      	breq sound_driver_channel3_instrument_change_load_macro_volume
0022cd 30a4                      	cpi r26, 4
0022ce f079                      	breq sound_driver_channel3_instrument_change_load_macro_arpeggio
0022cf 30a3                      	cpi r26, 3
0022d0 f099                      	breq sound_driver_channel3_instrument_change_load_macro_pitch
0022d1 30a2                      	cpi r26, 2
0022d2 f0d9                      	breq sound_driver_channel3_instrument_change_load_macro_hi_pitch
0022d3 c024                      	rjmp sound_driver_channel3_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel3_instrument_change_load_macro_volume:
0022d4 93c0 2917                 	sts noise_volume_macro, r28
0022d6 93d0 2918                 	sts noise_volume_macro+1, r29
0022d8 d029                      	rcall sound_driver_channel3_instrument_change_read_header
0022d9 93c0 291b                 	sts noise_volume_macro_release, r28
0022db 93d0 291a                 	sts noise_volume_macro_loop, r29
0022dd cfd8                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 	
                                 sound_driver_channel3_instrument_change_load_macro_arpeggio:
0022de 93c0 291c                 	sts noise_arpeggio_macro, r28
0022e0 93d0 291d                 	sts noise_arpeggio_macro+1, r29
0022e2 d02a                      	rcall sound_driver_channel3_instrument_change_read_header_arpeggio
0022e3 cfd2                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_pitch:
0022e4 93c0 2924                 	sts noise_pitch_macro, r28
0022e6 93d0 2925                 	sts noise_pitch_macro+1, r29
0022e8 d019                      	rcall sound_driver_channel3_instrument_change_read_header
0022e9 93c0 2928                 	sts noise_pitch_macro_release, r28
0022eb 93d0 2927                 	sts noise_pitch_macro_loop, r29
0022ed cfc8                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_hi_pitch:
0022ee 93c0 292a                 	sts noise_hi_pitch_macro, r28
0022f0 93d0 292b                 	sts noise_hi_pitch_macro+1, r29
0022f2 d00f                      	rcall sound_driver_channel3_instrument_change_read_header
0022f3 93c0 292e                 	sts noise_hi_pitch_macro_release, r28
0022f5 93d0 292d                 	sts noise_hi_pitch_macro_loop, r29
0022f7 cfbe                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_duty:
0022f8 93c0 292f                 	sts noise_duty_macro, r28
0022fa 93d0 2930                 	sts noise_duty_macro+1, r29
0022fc d005                      	rcall sound_driver_channel3_instrument_change_read_header
0022fd 93c0 2933                 	sts noise_duty_macro_release, r28
0022ff 93d0 2932                 	sts noise_duty_macro_loop, r29
002301 cfb4                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_read_header:
002302 93ef                      	push ZL
002303 93ff                      	push ZH
002304 2fec                      	mov ZL, r28
002305 2ffd                      	mov ZH, r29
002306 0fee                      	lsl ZL
002307 1fff                      	rol ZH
002308 91c5                      	lpm r28, Z+
002309 91d4                      	lpm r29, Z
00230a 91ff                      	pop ZH
00230b 91ef                      	pop ZL
00230c 9508                      	ret
                                 
                                 sound_driver_channel3_instrument_change_read_header_arpeggio:
00230d 93ef                      	push ZL
00230e 93ff                      	push ZH
00230f 2fec                      	mov ZL, r28
002310 2ffd                      	mov ZH, r29
002311 0fee                      	lsl ZL
002312 1fff                      	rol ZH
002313 91c5                      	lpm r28, Z+
002314 91d5                      	lpm r29, Z+
002315 93c0 2920                 	sts noise_arpeggio_macro_release, r28
002317 93d0 291f                 	sts noise_arpeggio_macro_loop, r29
002319 91c4                      	lpm r28, Z
00231a 93c0 2921                 	sts noise_arpeggio_macro_mode, r28
00231c 91ff                      	pop ZH
00231d 91ef                      	pop ZL
00231e 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel3_release:
                                 sound_driver_channel3_release_volume:
00231f 91b0 291b                 	lds r27, noise_volume_macro_release
002321 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
002322 f019                      	breq sound_driver_channel3_release_arpeggio //if the macro has no release flag, check the next macro
002323 95b3                      	inc r27
002324 93b0 2919                 	sts noise_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel3_release_arpeggio:
002326 91b0 2920                 	lds r27, noise_arpeggio_macro_release
002328 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
002329 f019                      	breq sound_driver_channel3_release_pitch
00232a 95b3                      	inc r27
00232b 93b0 291e                 	sts noise_arpeggio_macro_offset, r27
                                 sound_driver_channel3_release_pitch:
00232d 91b0 2928                 	lds r27, noise_pitch_macro_release
00232f 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
002330 f019                      	breq sound_driver_channel3_release_hi_pitch
002331 95b3                      	inc r27
002332 93b0 2926                 	sts noise_pitch_macro_offset, r27
                                 sound_driver_channel3_release_hi_pitch:
002334 91b0 292e                 	lds r27, noise_hi_pitch_macro_release
002336 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
002337 f019                      	breq sound_driver_channel3_release_duty
002338 95b3                      	inc r27
002339 93b0 292c                 	sts noise_hi_pitch_macro_offset, r27
                                 sound_driver_channel3_release_duty:
00233b 91b0 2933                 	lds r27, noise_duty_macro_release
00233d 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
00233e f019                      	breq sound_driver_channel3_release_exit
00233f 95b3                      	inc r27
002340 93b0 2931                 	sts noise_duty_macro_offset, r27
                                 sound_driver_channel3_release_exit:
002342 d01d                      	rcall sound_driver_channel3_increment_offset
002343 ce77                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_next_pattern:
002344 91e0 2819                 	lds ZL, song_frames
002346 91f0 281a                 	lds ZH, song_frames+1
002348 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
00234a 91b0 281c                 	lds r27, song_frame_offset+1
00234c 93a0 281b                 	sts song_frame_offset, r26
00234e 93b0 281c                 	sts song_frame_offset+1, r27
002350 9616                      	adiw r27:r26, 6 //offset for channel 3
002351 0fea                      	add ZL, r26
002352 1ffb                      	adc ZH, r27
                                 
002353 91a5                      	lpm r26, Z+ //load the address of the next pattern
002354 91b4                      	lpm r27, Z
002355 0faa                      	lsl r26
002356 1fbb                      	rol r27
002357 93a0 2911                 	sts noise_pattern, r26
002359 93b0 2912                 	sts noise_pattern+1, r27
                                 
00235b 9220 2915                 	sts noise_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
00235d 9220 2916                 	sts noise_pattern_offset+1, zero
00235f ce5b                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_increment_offset:
002360 91e0 2915                 	lds ZL, noise_pattern_offset //current offset in the pattern for noise
002362 91f0 2916                 	lds ZH, noise_pattern_offset+1
002364 9631                      	adiw Z, 1
002365 93e0 2915                 	sts noise_pattern_offset, ZL
002367 93f0 2916                 	sts noise_pattern_offset+1, ZH
002369 9508                      	ret
                                 
                                 sound_driver_channel3_increment_offset_twice: //used for data that takes up 2 bytes worth of space
00236a 91e0 2915                 	lds ZL, noise_pattern_offset //current offset in the pattern for noise
00236c 91f0 2916                 	lds ZH, noise_pattern_offset+1
00236e 9632                      	adiw Z, 2 //increment the pointer twice
00236f 93e0 2915                 	sts noise_pattern_offset, ZL
002371 93f0 2916                 	sts noise_pattern_offset+1, ZH
002373 9508                      	ret
                                 
                                 sound_driver_channel3_decrement_frame_delay:
002374 95ba                      	dec r27
002375 93b0 2914                 	sts noise_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel4:
002377 91a0 294a                 	lds r26, dpcm_pattern_delay_rows
002379 91b0 294b                 	lds r27, dpcm_pattern_delay_frames
00237b 9610                      	adiw r27:r26, 0
00237c f009                      	breq sound_driver_channel4_main //if the pattern delay is 0, proceed with sound driver procedures
00237d c0bd                      	rjmp sound_driver_channel4_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel4_main:
00237e 91e0 2948                 	lds ZL, dpcm_pattern //current pattern for dpcm
002380 91f0 2949                 	lds ZH, dpcm_pattern+1
002382 91a0 294c                 	lds r26, dpcm_pattern_offset //current offset in the pattern for dpcm
002384 91b0 294d                 	lds r27, dpcm_pattern_offset+1
002386 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
002387 1ffb                      	adc ZH, r27
002388 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel4_check_if_note: //check if data is a note (0x00 - 0x56)
002389 35b7                      	cpi r27, 0x57
00238a f408                      	brsh sound_driver_channel4_check_if_volume
00238b c056                      	rjmp sound_driver_channel4_note
                                 sound_driver_channel4_check_if_volume: //check if data is volume (0x57-0x66)
00238c 36b7                      	cpi r27, 0x67
00238d f408                      	brsh sound_driver_channel4_check_if_delay
00238e c071                      	rjmp sound_driver_channel4_volume
                                 sound_driver_channel4_check_if_delay: //check if data is a delay (0x67 - 0xE2)
00238f 3eb3                      	cpi r27, 0xE3
002390 f408                      	brsh sound_driver_channel4_check_if_instrument
002391 c070                      	rjmp sound_driver_channel4_delay
                                 sound_driver_channel4_check_if_instrument: //check for instrument flag (0xE3)
002392 f409                      	brne sound_driver_channel4_check_if_release
002393 c073                      	rjmp sound_driver_channel4_instrument_change 
                                 sound_driver_channel4_check_if_release: //check for note release flag (0xE4)
002394 3eb4                      	cpi r27, 0xE4
002395 f409                      	brne sound_driver_channel4_check_if_end
002396 c072                      	rjmp sound_driver_channel4_release
                                 sound_driver_channel4_check_if_end:
002397 3fbf                      	cpi r27, 0xFF
002398 f409                      	brne sound_driver_channel4_check_if_fx
002399 c071                      	rjmp sound_driver_channel4_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel4_check_if_fx: //fx flags (0xE5 - 0xFE)
00239a 9631                      	adiw Z, 1 //point Z to the byte next to the flag
00239b 91a4                      	lpm r26, Z //load the fx data into r26
00239c d094                      	rcall sound_driver_channel4_increment_offset_twice
                                 
00239d 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
00239e e7e6                      	ldi ZL, LOW(channel4_fx << 1) //load in note table
00239f e6f3                      	ldi ZH, HIGH(channel4_fx << 1)
0023a0 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
0023a1 0feb                      	add ZL, r27 //add offset
0023a2 1df2                      	adc ZH, zero
0023a3 91c5                      	lpm r28, Z+ //load address bytes
0023a4 91d4                      	lpm r29, Z
0023a5 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
0023a6 2ffd                      	mov ZH, r29
0023a7 9409                      	ijmp
                                 
                                 
                                 
                                 sound_driver_channel4_fx_0xy: //arpeggio
0023a8 cfd5                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_1xx: //pitch slide up
0023a9 cfd4                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_2xx: //pitch slide down
0023aa cfd3                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_3xx: //automatic portamento
0023ab cfd2                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_4xy: //vibrato
0023ac cfd1                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_7xy: //tremelo
0023ad cfd0                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Axy: //volume slide
0023ae cfcf                      	rjmp sound_driver_channel4_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel4_fx_Bxx:
0023af 93a0 2820                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
0023b1 cfcc                      	rjmp sound_driver_channel4_main
                                 
                                 //HALT
                                 sound_driver_channel4_fx_Cxx:
0023b2 93b0 2821                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
0023b4 cfc9                      	rjmp sound_driver_channel4_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel4_fx_Dxx:
0023b5 93b0 2822                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
0023b7 cfc6                      	rjmp sound_driver_channel4_main
                                 
                                 sound_driver_channel4_fx_Exx: //volume
0023b8 cfc5                      	rjmp sound_driver_channel4_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel4_fx_Fxx:
0023b9 93a0 281f                 	sts song_speed, r26 //NOTE: only changes to speed are supported
0023bb cfc2                      	rjmp sound_driver_channel4_main
                                 
                                 //DELAY
                                 sound_driver_channel4_fx_Gxx:
0023bc 15a2                      	cp r26, zero
0023bd f051                      	breq sound_driver_channel4_fx_Gxx_invalid
0023be 91b0 281f                 	lds r27, song_speed
0023c0 17ab                      	cp r26, r27
0023c1 f430                      	brsh sound_driver_channel4_fx_Gxx_invalid
0023c2 93a0 2952                 	sts dpcm_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
0023c4 e0b1                      	ldi r27, 0x01
0023c5 93b0 294a                 	sts dpcm_pattern_delay_rows, r27
0023c7 c076                      	rjmp sound_driver_calculate_delays
                                 sound_driver_channel4_fx_Gxx_invalid:
0023c8 cfb5                      	rjmp sound_driver_channel4_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel4_fx_Hxy: //hardware sweep up
0023c9 cfb4                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Ixy: //hardware sweep down
0023ca cfb3                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Hxx: //FDS modulation depth
0023cb cfb2                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Ixx: //FDS modulation speed
0023cc cfb1                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Pxx: //fine pitch
0023cd cfb0                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Qxy: //note slide up
0023ce cfaf                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Rxy: //note slide down
0023cf cfae                      	rjmp sound_driver_channel4_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel4_fx_Sxx:
0023d0 15a2                      	cp r26, zero
0023d1 f051                      	breq sound_driver_channel4_fx_Sxx_invalid
0023d2 91b0 281f                 	lds r27, song_speed
0023d4 17ab                      	cp r26, r27
0023d5 f430                      	brsh sound_driver_channel4_fx_Sxx_invalid
0023d6 93a0 2954                 	sts dpcm_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
0023d8 e0b1                      	ldi r27, 0x01
0023d9 93b0 294a                 	sts dpcm_pattern_delay_rows, r27
0023db c062                      	rjmp sound_driver_calculate_delays
                                 sound_driver_channel4_fx_Sxx_invalid:
0023dc cfa1                      	rjmp sound_driver_channel4_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel4_fx_Vxx: //duty
0023dd cfa0                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Wxx: //DPCM sample speed
0023de cf9f                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Xxx: //DPCM sample retrigger
0023df cf9e                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Yxx: //DPCM sample offset
0023e0 cf9d                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Zxx: //DPCM sample delta counter
0023e1 cf9c                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_note:
0023e2 9631                      	adiw Z, 1 //point to the byte next to the flag
0023e3 90f4                      	lpm dpcm_period, Z //store the DPCM sample rate
0023e4 e3eb                      	ldi ZL, LOW(dpcm_samples) //point Z to dpcm_samples table
0023e5 e1f1                      	ldi ZH, HIGH(dpcm_samples)
0023e6 0feb                      	add ZL, r27 //point Z to offsetted sample
0023e7 1df2                      	adc ZH, zero
0023e8 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the samples's address
0023e9 1fff                      	rol ZH
0023ea 91a5                      	lpm r26, Z+ //r26:r27 now points to the sample
0023eb 91b4                      	lpm r27, Z
                                 
0023ec 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the sample's data
0023ed 1fbb                      	rol r27
0023ee 2fea                      	mov ZL, r26
0023ef 2ffb                      	mov ZH, r27
0023f0 91b4                      	lpm r27, Z //get sample length
0023f1 ef70                      	ldi dpcm_length_LOW, 0b11110000
0023f2 e08f                      	ldi dpcm_length_HIGH, 0b00001111
0023f3 95b2                      	swap r27
0023f4 237b                      	and dpcm_length_LOW, r27
0023f5 238b                      	and dpcm_length_HIGH, r27
                                 
0023f6 93e0 294e                 	sts dpcm_sample, ZL //store address to sample
0023f8 93f0 294f                 	sts dpcm_sample+1, ZH
0023fa 9230 2950                 	sts dpcm_sample_offset, one //start sample offset at 1 (0th byte was used for sample length)
0023fc 9220 2951                 	sts dpcm_sample_offset+1, zero
                                 
0023fe d032                      	rcall sound_driver_channel4_increment_offset_twice
0023ff cf7e                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_volume:
002400 d026                      	rcall sound_driver_channel4_increment_offset
002401 cf7c                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_delay:
002402 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
002403 93b0 294a                 	sts dpcm_pattern_delay_rows, r27
002405 d021                      	rcall sound_driver_channel4_increment_offset
002406 c037                      	rjmp sound_driver_calculate_delays
                                 
                                 
                                 
                                 sound_driver_channel4_instrument_change:
002407 d029                      	rcall sound_driver_channel4_increment_offset_twice
002408 cf75                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_release:
002409 d01d                      	rcall sound_driver_channel4_increment_offset
00240a cf73                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_next_pattern:
00240b 91e0 2819                 	lds ZL, song_frames
00240d 91f0 281a                 	lds ZH, song_frames+1
00240f 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
002411 91b0 281c                 	lds r27, song_frame_offset+1
002413 93a0 281b                 	sts song_frame_offset, r26
002415 93b0 281c                 	sts song_frame_offset+1, r27
002417 9618                      	adiw r27:r26, 8 //offset for channel 4
002418 0fea                      	add ZL, r26
002419 1ffb                      	adc ZH, r27
                                 
00241a 91a5                      	lpm r26, Z+ //load the address of the next pattern
00241b 91b4                      	lpm r27, Z
00241c 0faa                      	lsl r26
00241d 1fbb                      	rol r27
00241e 93a0 2948                 	sts dpcm_pattern, r26
002420 93b0 2949                 	sts dpcm_pattern+1, r27
                                 
002422 9220 294c                 	sts dpcm_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
002424 9220 294d                 	sts dpcm_pattern_offset+1, zero
002426 cf57                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_increment_offset:
002427 91e0 294c                 	lds ZL, dpcm_pattern_offset //current offset in the pattern for dpcm
002429 91f0 294d                 	lds ZH, dpcm_pattern_offset+1
00242b 9631                      	adiw Z, 1
00242c 93e0 294c                 	sts dpcm_pattern_offset, ZL
00242e 93f0 294d                 	sts dpcm_pattern_offset+1, ZH
002430 9508                      	ret
                                 
                                 sound_driver_channel4_increment_offset_twice: //used for data that takes up 2 bytes worth of space
002431 91e0 294c                 	lds ZL, dpcm_pattern_offset //current offset in the pattern for dpcm
002433 91f0 294d                 	lds ZH, dpcm_pattern_offset+1
002435 9632                      	adiw Z, 2 //increment the pointer twice
002436 93e0 294c                 	sts dpcm_pattern_offset, ZL
002438 93f0 294d                 	sts dpcm_pattern_offset+1, ZH
00243a 9508                      	ret
                                 
                                 sound_driver_channel4_decrement_frame_delay:
00243b 95ba                      	dec r27
00243c 93b0 294b                 	sts dpcm_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_calculate_delays:
00243e 91f0 281f                 	lds r31, song_speed
002440 2fef                      	mov r30, r31
002441 50e1                      	subi r30, 1
                                 sound_driver_calculate_delays_pulse1:
002442 91a0 2826                 	lds r26, pulse1_pattern_delay_frames
002444 11a2                      	cpse r26, zero
002445 c042                      	rjmp sound_driver_calculate_delays_pulse2
002446 c000                      	rjmp sound_driver_calculate_delays_pulse1_main
                                 
                                 sound_driver_calculate_delays_pulse1_main:
002447 2faf                      	mov r26, r31 //move the speed to r26
002448 91b0 2825                 	lds r27, pulse1_pattern_delay_rows //decrement the delay rows
00244a 15b2                      	cp r27, zero
00244b f409                      	brne PC+2
00244c c03b                      	rjmp sound_driver_calculate_delays_pulse2
00244d 95ba                      	dec r27
00244e 93b0 2825                 	sts pulse1_pattern_delay_rows, r27
002450 11b2                      	cpse r27, zero
002451 c034                      	rjmp sound_driver_calculate_delays_pulse1_store
002452 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx:
002453 efbf                      	ldi r27, 0xFF
002454 91c0 2872                 	lds r28, pulse1_fx_Sxx_pre
002456 91d0 2873                 	lds r29, pulse1_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse1_Sxx_check_pre:
002458 17cb                      	cp r28, r27
002459 f009                      	breq sound_driver_calculate_delays_pulse1_Sxx_check_post
00245a c00d                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_pre
                                 sound_driver_calculate_delays_pulse1_Sxx_check_post:
00245b 17db                      	cp r29, r27
00245c f009                      	breq sound_driver_calculate_delays_pulse1_Gxx
00245d c015                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx:
00245e 91c0 2860                 	lds r28, pulse1_fx_Gxx_pre
002460 91d0 2861                 	lds r29, pulse1_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse1_Gxx_check_pre:
002462 17cb                      	cp r28, r27
002463 f009                      	breq sound_driver_calculate_delays_pulse1_Gxx_check_post
002464 c012                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_pre
                                 sound_driver_calculate_delays_pulse1_Gxx_check_post:
002465 17db                      	cp r29, r27
002466 f0f9                      	breq sound_driver_calculate_delays_pulse1_store
002467 c01a                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_pre:
002468 93b0 2872                 	sts pulse1_fx_Sxx_pre, r27
00246a 1bec                      	sub r30, r28 //(song speed)-1-Sxx
00246b 93e0 2873                 	sts pulse1_fx_Sxx_post, r30
00246d 95ca                      	dec r28
00246e 93c0 2826                 	sts pulse1_pattern_delay_frames, r28
002470 2fef                      	mov r30, r31
002471 50e1                      	subi r30, 1
002472 c015                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_post:
002473 93b0 2873                 	sts pulse1_fx_Sxx_post, r27
002475 2fad                      	mov r26, r29
002476 c00f                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx_pre:
002477 93b0 2860                 	sts pulse1_fx_Gxx_pre, r27
002479 1bec                      	sub r30, r28 //(song speed)-1-Sxx
00247a 93e0 2861                 	sts pulse1_fx_Gxx_post, r30
00247c 95ca                      	dec r28
00247d 93c0 2826                 	sts pulse1_pattern_delay_frames, r28
00247f 2fef                      	mov r30, r31
002480 50e1                      	subi r30, 1
002481 c006                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse1_Gxx_post:
002482 93b0 2861                 	sts pulse1_fx_Gxx_post, r27
002484 2fad                      	mov r26, r29
002485 c000                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_store:
002486 93a0 2826                 	sts pulse1_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_pulse2:
002488 91a0 2877                 	lds r26, pulse2_pattern_delay_frames
00248a 11a2                      	cpse r26, zero
00248b c042                      	rjmp sound_driver_calculate_delays_triangle
00248c c000                      	rjmp sound_driver_calculate_delays_pulse2_main
                                 
                                 sound_driver_calculate_delays_pulse2_main:
00248d 2faf                      	mov r26, r31 //move the speed to r26
00248e 91b0 2876                 	lds r27, pulse2_pattern_delay_rows //decrement the delay rows
002490 15b2                      	cp r27, zero
002491 f409                      	brne PC+2
002492 c03b                      	rjmp sound_driver_calculate_delays_triangle
002493 95ba                      	dec r27
002494 93b0 2876                 	sts pulse2_pattern_delay_rows, r27
002496 11b2                      	cpse r27, zero
002497 c034                      	rjmp sound_driver_calculate_delays_pulse2_store
002498 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx:
002499 efbf                      	ldi r27, 0xFF
00249a 91c0 28c3                 	lds r28, pulse2_fx_Sxx_pre
00249c 91d0 28c4                 	lds r29, pulse2_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse2_Sxx_check_pre:
00249e 17cb                      	cp r28, r27
00249f f009                      	breq sound_driver_calculate_delays_pulse2_Sxx_check_post
0024a0 c00d                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_pre
                                 sound_driver_calculate_delays_pulse2_Sxx_check_post:
0024a1 17db                      	cp r29, r27
0024a2 f009                      	breq sound_driver_calculate_delays_pulse2_Gxx
0024a3 c015                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx:
0024a4 91c0 28b1                 	lds r28, pulse2_fx_Gxx_pre
0024a6 91d0 28b2                 	lds r29, pulse2_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse2_Gxx_check_pre:
0024a8 17cb                      	cp r28, r27
0024a9 f009                      	breq sound_driver_calculate_delays_pulse2_Gxx_check_post
0024aa c012                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_pre
                                 sound_driver_calculate_delays_pulse2_Gxx_check_post:
0024ab 17db                      	cp r29, r27
0024ac f0f9                      	breq sound_driver_calculate_delays_pulse2_store
0024ad c01a                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_pre:
0024ae 93b0 28c3                 	sts pulse2_fx_Sxx_pre, r27
0024b0 1bec                      	sub r30, r28 //(song speed)-1-Sxx
0024b1 93e0 28c4                 	sts pulse2_fx_Sxx_post, r30
0024b3 95ca                      	dec r28
0024b4 93c0 2877                 	sts pulse2_pattern_delay_frames, r28
0024b6 2fef                      	mov r30, r31
0024b7 50e1                      	subi r30, 1
0024b8 cfcf                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_post:
0024b9 93b0 28c4                 	sts pulse2_fx_Sxx_post, r27
0024bb 2fad                      	mov r26, r29
0024bc c00f                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx_pre:
0024bd 93b0 28b1                 	sts pulse2_fx_Gxx_pre, r27
0024bf 1bec                      	sub r30, r28 //(song speed)-1-Sxx
0024c0 93e0 28b2                 	sts pulse2_fx_Gxx_post, r30
0024c2 95ca                      	dec r28
0024c3 93c0 2877                 	sts pulse2_pattern_delay_frames, r28
0024c5 2fef                      	mov r30, r31
0024c6 50e1                      	subi r30, 1
0024c7 cfc0                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse2_Gxx_post:
0024c8 93b0 28b2                 	sts pulse2_fx_Gxx_post, r27
0024ca 2fad                      	mov r26, r29
0024cb c000                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_store:
0024cc 93a0 2877                 	sts pulse2_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_triangle:
0024ce 91a0 28c8                 	lds r26, triangle_pattern_delay_frames
0024d0 11a2                      	cpse r26, zero
0024d1 c042                      	rjmp sound_driver_calculate_delays_noise
0024d2 c000                      	rjmp sound_driver_calculate_delays_triangle_main
                                 
                                 sound_driver_calculate_delays_triangle_main:
0024d3 2faf                      	mov r26, r31 //move the speed to r26
0024d4 91b0 28c7                 	lds r27, triangle_pattern_delay_rows //decrement the delay rows
0024d6 15b2                      	cp r27, zero
0024d7 f409                      	brne PC+2
0024d8 c03b                      	rjmp sound_driver_calculate_delays_noise
0024d9 95ba                      	dec r27
0024da 93b0 28c7                 	sts triangle_pattern_delay_rows, r27
0024dc 11b2                      	cpse r27, zero
0024dd c034                      	rjmp sound_driver_calculate_delays_triangle_store
0024de 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_triangle_Sxx:
0024df efbf                      	ldi r27, 0xFF
0024e0 91c0 290f                 	lds r28, triangle_fx_Sxx_pre
0024e2 91d0 2910                 	lds r29, triangle_fx_Sxx_post
                                 sound_driver_calculate_delays_triangle_Sxx_check_pre:
0024e4 17cb                      	cp r28, r27
0024e5 f009                      	breq sound_driver_calculate_delays_triangle_Sxx_check_post
0024e6 c00d                      	rjmp sound_driver_calculate_delays_triangle_Sxx_pre
                                 sound_driver_calculate_delays_triangle_Sxx_check_post:
0024e7 17db                      	cp r29, r27
0024e8 f009                      	breq sound_driver_calculate_delays_triangle_Gxx
0024e9 c015                      	rjmp sound_driver_calculate_delays_triangle_Sxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Gxx:
0024ea 91c0 28fd                 	lds r28, triangle_fx_Gxx_pre
0024ec 91d0 28fe                 	lds r29, triangle_fx_Gxx_post
                                 sound_driver_calculate_delays_triangle_Gxx_check_pre:
0024ee 17cb                      	cp r28, r27
0024ef f009                      	breq sound_driver_calculate_delays_triangle_Gxx_check_post
0024f0 c012                      	rjmp sound_driver_calculate_delays_triangle_Gxx_pre
                                 sound_driver_calculate_delays_triangle_Gxx_check_post:
0024f1 17db                      	cp r29, r27
0024f2 f0f9                      	breq sound_driver_calculate_delays_triangle_store
0024f3 c01a                      	rjmp sound_driver_calculate_delays_triangle_Gxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_pre:
0024f4 93b0 290f                 	sts triangle_fx_Sxx_pre, r27
0024f6 1bec                      	sub r30, r28 //(song speed)-1-Sxx
0024f7 93e0 2910                 	sts triangle_fx_Sxx_post, r30
0024f9 95ca                      	dec r28
0024fa 93c0 28c8                 	sts triangle_pattern_delay_frames, r28
0024fc 2fef                      	mov r30, r31
0024fd 50e1                      	subi r30, 1
0024fe c015                      	rjmp sound_driver_calculate_delays_noise
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_post:
0024ff 93b0 2910                 	sts triangle_fx_Sxx_post, r27
002501 2fad                      	mov r26, r29
002502 c00f                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_Gxx_pre:
002503 93b0 28fd                 	sts triangle_fx_Gxx_pre, r27
002505 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002506 93e0 28fe                 	sts triangle_fx_Gxx_post, r30
002508 95ca                      	dec r28
002509 93c0 28c8                 	sts triangle_pattern_delay_frames, r28
00250b 2fef                      	mov r30, r31
00250c 50e1                      	subi r30, 1
00250d c006                      	rjmp sound_driver_calculate_delays_noise
                                 	
                                 sound_driver_calculate_delays_triangle_Gxx_post:
00250e 93b0 28fe                 	sts triangle_fx_Gxx_post, r27
002510 2fad                      	mov r26, r29
002511 c000                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_store:
002512 93a0 28c8                 	sts triangle_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_noise:
002514 91a0 2914                 	lds r26, noise_pattern_delay_frames
002516 11a2                      	cpse r26, zero
002517 c042                      	rjmp sound_driver_calculate_delays_dpcm
002518 c000                      	rjmp sound_driver_calculate_delays_noise_main
                                 
                                 sound_driver_calculate_delays_noise_main:
002519 2faf                      	mov r26, r31 //move the speed to r26
00251a 91b0 2913                 	lds r27, noise_pattern_delay_rows //decrement the delay rows
00251c 15b2                      	cp r27, zero
00251d f409                      	brne PC+2
00251e c03b                      	rjmp sound_driver_calculate_delays_dpcm
00251f 95ba                      	dec r27
002520 93b0 2913                 	sts noise_pattern_delay_rows, r27
002522 11b2                      	cpse r27, zero
002523 c034                      	rjmp sound_driver_calculate_delays_noise_store
002524 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_noise_Sxx:
002525 efbf                      	ldi r27, 0xFF
002526 91c0 2946                 	lds r28, noise_fx_Sxx_pre
002528 91d0 2947                 	lds r29, noise_fx_Sxx_post
                                 sound_driver_calculate_delays_noise_Sxx_check_pre:
00252a 17cb                      	cp r28, r27
00252b f009                      	breq sound_driver_calculate_delays_noise_Sxx_check_post
00252c c00d                      	rjmp sound_driver_calculate_delays_noise_Sxx_pre
                                 sound_driver_calculate_delays_noise_Sxx_check_post:
00252d 17db                      	cp r29, r27
00252e f009                      	breq sound_driver_calculate_delays_noise_Gxx
00252f c015                      	rjmp sound_driver_calculate_delays_noise_Sxx_post
                                 
                                 sound_driver_calculate_delays_noise_Gxx:
002530 91c0 2943                 	lds r28, noise_fx_Gxx_pre
002532 91d0 2944                 	lds r29, noise_fx_Gxx_post
                                 sound_driver_calculate_delays_noise_Gxx_check_pre:
002534 17cb                      	cp r28, r27
002535 f009                      	breq sound_driver_calculate_delays_noise_Gxx_check_post
002536 c012                      	rjmp sound_driver_calculate_delays_noise_Gxx_pre
                                 sound_driver_calculate_delays_noise_Gxx_check_post:
002537 17db                      	cp r29, r27
002538 f0f9                      	breq sound_driver_calculate_delays_noise_store
002539 c01a                      	rjmp sound_driver_calculate_delays_noise_Gxx_post
                                 
                                 sound_driver_calculate_delays_noise_Sxx_pre:
00253a 93b0 2946                 	sts noise_fx_Sxx_pre, r27
00253c 1bec                      	sub r30, r28 //(song speed)-1-Sxx
00253d 93e0 2947                 	sts noise_fx_Sxx_post, r30
00253f 95ca                      	dec r28
002540 93c0 2914                 	sts noise_pattern_delay_frames, r28
002542 2fef                      	mov r30, r31
002543 50e1                      	subi r30, 1
002544 c015                      	rjmp sound_driver_calculate_delays_dpcm
                                 
                                 sound_driver_calculate_delays_noise_Sxx_post:
002545 93b0 2947                 	sts noise_fx_Sxx_post, r27
002547 2fad                      	mov r26, r29
002548 c00f                      	rjmp sound_driver_calculate_delays_noise_store
                                 
                                 sound_driver_calculate_delays_noise_Gxx_pre:
002549 93b0 2943                 	sts noise_fx_Gxx_pre, r27
00254b 1bec                      	sub r30, r28 //(song speed)-1-Sxx
00254c 93e0 2944                 	sts noise_fx_Gxx_post, r30
00254e 95ca                      	dec r28
00254f 93c0 2914                 	sts noise_pattern_delay_frames, r28
002551 2fef                      	mov r30, r31
002552 50e1                      	subi r30, 1
002553 c006                      	rjmp sound_driver_calculate_delays_dpcm
                                 	
                                 sound_driver_calculate_delays_noise_Gxx_post:
002554 93b0 2944                 	sts noise_fx_Gxx_post, r27
002556 2fad                      	mov r26, r29
002557 c000                      	rjmp sound_driver_calculate_delays_noise_store
                                 
                                 sound_driver_calculate_delays_noise_store:
002558 93a0 2914                 	sts noise_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_dpcm:
00255a 91a0 294b                 	lds r26, dpcm_pattern_delay_frames
00255c 11a2                      	cpse r26, zero
00255d c042                      	rjmp sound_driver_instrument_fx_routine
00255e c000                      	rjmp sound_driver_calculate_delays_dpcm_main
                                 
                                 sound_driver_calculate_delays_dpcm_main:
00255f 2faf                      	mov r26, r31 //move the speed to r26
002560 91b0 294a                 	lds r27, dpcm_pattern_delay_rows //decrement the delay rows
002562 15b2                      	cp r27, zero
002563 f409                      	brne PC+2
002564 c03b                      	rjmp sound_driver_instrument_fx_routine
002565 95ba                      	dec r27
002566 93b0 294a                 	sts dpcm_pattern_delay_rows, r27
002568 11b2                      	cpse r27, zero
002569 c034                      	rjmp sound_driver_calculate_delays_dpcm_store
00256a 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_dpcm_Sxx:
00256b efbf                      	ldi r27, 0xFF
00256c 91c0 2954                 	lds r28, dpcm_fx_Sxx_pre
00256e 91d0 2955                 	lds r29, dpcm_fx_Sxx_post
                                 sound_driver_calculate_delays_dpcm_Sxx_check_pre:
002570 17cb                      	cp r28, r27
002571 f009                      	breq sound_driver_calculate_delays_dpcm_Sxx_check_post
002572 c00d                      	rjmp sound_driver_calculate_delays_dpcm_Sxx_pre
                                 sound_driver_calculate_delays_dpcm_Sxx_check_post:
002573 17db                      	cp r29, r27
002574 f009                      	breq sound_driver_calculate_delays_dpcm_Gxx
002575 c015                      	rjmp sound_driver_calculate_delays_dpcm_Sxx_post
                                 
                                 sound_driver_calculate_delays_dpcm_Gxx:
002576 91c0 2952                 	lds r28, dpcm_fx_Gxx_pre
002578 91d0 2953                 	lds r29, dpcm_fx_Gxx_post
                                 sound_driver_calculate_delays_dpcm_Gxx_check_pre:
00257a 17cb                      	cp r28, r27
00257b f009                      	breq sound_driver_calculate_delays_dpcm_Gxx_check_post
00257c c012                      	rjmp sound_driver_calculate_delays_dpcm_Gxx_pre
                                 sound_driver_calculate_delays_dpcm_Gxx_check_post:
00257d 17db                      	cp r29, r27
00257e f0f9                      	breq sound_driver_calculate_delays_dpcm_store
00257f c01a                      	rjmp sound_driver_calculate_delays_dpcm_Gxx_post
                                 
                                 sound_driver_calculate_delays_dpcm_Sxx_pre:
002580 93b0 2954                 	sts dpcm_fx_Sxx_pre, r27
002582 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002583 93e0 2955                 	sts dpcm_fx_Sxx_post, r30
002585 95ca                      	dec r28
002586 93c0 294b                 	sts dpcm_pattern_delay_frames, r28
002588 2fef                      	mov r30, r31
002589 50e1                      	subi r30, 1
00258a c015                      	rjmp sound_driver_instrument_fx_routine
                                 
                                 sound_driver_calculate_delays_dpcm_Sxx_post:
00258b 93b0 2955                 	sts dpcm_fx_Sxx_post, r27
00258d 2fad                      	mov r26, r29
00258e c00f                      	rjmp sound_driver_calculate_delays_dpcm_store
                                 
                                 sound_driver_calculate_delays_dpcm_Gxx_pre:
00258f 93b0 2952                 	sts dpcm_fx_Gxx_pre, r27
002591 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002592 93e0 2953                 	sts dpcm_fx_Gxx_post, r30
002594 95ca                      	dec r28
002595 93c0 294b                 	sts dpcm_pattern_delay_frames, r28
002597 2fef                      	mov r30, r31
002598 50e1                      	subi r30, 1
002599 c006                      	rjmp sound_driver_instrument_fx_routine
                                 	
                                 sound_driver_calculate_delays_dpcm_Gxx_post:
00259a 93b0 2953                 	sts dpcm_fx_Gxx_post, r27
00259c 2fad                      	mov r26, r29
00259d c000                      	rjmp sound_driver_calculate_delays_dpcm_store
                                 
                                 sound_driver_calculate_delays_dpcm_store:
00259e 93a0 294b                 	sts dpcm_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_instrument_fx_routine:
                                 sound_driver_instrument_routine_channel0_volume:
0025a0 91e0 2829                 	lds ZL, pulse1_volume_macro
0025a2 91f0 282a                 	lds ZH, pulse1_volume_macro+1
0025a4 9630                      	adiw Z, 0
0025a5 f1a1                      	breq sound_driver_instrument_routine_channel0_volume_default //if no volume macro is in use, use default multiplier of F
0025a6 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0025a7 1fff                      	rol ZH
0025a8 91a0 282b                 	lds r26, pulse1_volume_macro_offset
0025aa 0fea                      	add ZL, r26
0025ab 1df2                      	adc ZH, zero
                                 
0025ac 91b0 282d                 	lds r27, pulse1_volume_macro_release
0025ae 17ba                      	cp r27, r26
0025af f429                      	brne sound_driver_instrument_routine_channel0_volume_increment //if the current offset is not equal to the release index, increment the offset
0025b0 91a0 282c                 	lds r26, pulse1_volume_macro_loop
0025b2 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0025b3 f010                      	brlo sound_driver_instrument_routine_channel0_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0025b4 c003                      	rjmp sound_driver_instrument_routine_channel0_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_volume_increment:
0025b5 95a3                      	inc r26 //increment the macro offset
0025b6 93a0 282b                 	sts pulse1_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_volume_read:
0025b8 91b4                      	lpm r27, Z //load volume data into r27
0025b9 3fbf                      	cpi r27, 0xFF //check for macro end flag
0025ba f469                      	brne sound_driver_instrument_routine_channel0_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_release:
0025bb 91b0 282d                 	lds r27, pulse1_volume_macro_release
0025bd 3fbf                      	cpi r27, 0xFF
0025be f429                      	brne sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_loop:
0025bf 91b0 282c                 	lds r27, pulse1_volume_macro_loop //load the loop index
0025c1 93b0 282b                 	sts pulse1_volume_macro_offset, r27 //store the loop index into the offset
0025c3 cfdc                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index:
0025c4 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
0025c5 93a0 282b                 	sts pulse1_volume_macro_offset, r26
0025c7 cfd8                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_calculate:
0025c8 eaea                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
0025c9 e6f3                      	ldi ZH, HIGH(volumes << 1)
0025ca 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
0025cb 0feb                      	add ZL, r27 //add offset to the table
0025cc 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel0_volume_load:
0025cd 91b0 2800                 	lds r27, pulse1_param //load main volume
0025cf 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
0025d0 91a0 285e                 	lds r26, pulse1_fx_7xy_value
0025d2 30a0                      	cpi r26, 0x00
0025d3 f481                      	brne sound_driver_instrument_routine_channel0_volume_load_7xy
                                 
0025d4 0feb                      	add ZL, r27 //offset the volume table by the main volume
0025d5 1df2                      	adc ZH, zero
0025d6 91b4                      	lpm r27, Z
0025d7 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
0025d9 c023                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default:
0025da 91b0 2800                 	lds r27, pulse1_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
0025dc 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
0025dd 91a0 285e                 	lds r26, pulse1_fx_7xy_value
0025df 30a0                      	cpi r26, 0x00
0025e0 f499                      	brne sound_driver_instrument_routine_channel0_volume_default_7xy
0025e1 93b0 2806                 	sts pulse1_output_volume, r27
0025e3 c019                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy:
0025e4 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
0025e5 f038                      	brcs sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
0025e6 f031                      	breq sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
                                 
0025e7 0feb                      	add ZL, r27 //offset the volume table by the main volume
0025e8 1df2                      	adc ZH, zero
0025e9 91b4                      	lpm r27, Z
0025ea 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
0025ec c010                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy_overflow:
0025ed e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
0025ee 0feb                      	add ZL, r27 //offset the volume table by the main volume
0025ef 1df2                      	adc ZH, zero
0025f0 91b4                      	lpm r27, Z
0025f1 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
0025f3 c009                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default_7xy:
0025f4 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
0025f5 f020                      	brcs sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
0025f6 f019                      	breq sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
0025f7 93b0 2806                 	sts pulse1_output_volume, r27
0025f9 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel0_volume_default_7xy_overflow:
0025fa e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
0025fb 93b0 2806                 	sts pulse1_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
0025fd 91e0 282e                 	lds ZL, pulse1_arpeggio_macro
0025ff 91f0 282f                 	lds ZH, pulse1_arpeggio_macro+1
002601 9630                      	adiw Z, 0
002602 f1d9                      	breq sound_driver_instrument_routine_channel0_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002603 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002604 1fff                      	rol ZH
002605 91a0 2830                 	lds r26, pulse1_arpeggio_macro_offset
002607 0fea                      	add ZL, r26
002608 1df2                      	adc ZH, zero
                                 
002609 91b0 2832                 	lds r27, pulse1_arpeggio_macro_release
00260b 17ba                      	cp r27, r26
00260c f429                      	brne sound_driver_instrument_routine_channel0_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
00260d 91a0 2831                 	lds r26, pulse1_arpeggio_macro_loop
00260f 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002610 f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002611 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_increment:
002612 95a3                      	inc r26 //increment the macro offset
002613 93a0 2830                 	sts pulse1_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_read:
002615 91b4                      	lpm r27, Z //load arpeggio data into r27
002616 38b0                      	cpi r27, 0x80 //check for macro end flag
002617 f009                      	breq sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag
002618 c041                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_check_mode:
002619 50a1                      	subi r26, 1 //keep the offset at the end flag
00261a 93a0 2830                 	sts pulse1_arpeggio_macro_offset, r26
00261c 91b0 2833                 	lds r27, pulse1_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
00261e 30b1                      	cpi r27, 0x01
00261f f048                      	brlo sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_release:
002620 91b0 2832                 	lds r27, pulse1_arpeggio_macro_release
002622 3fbf                      	cpi r27, 0xFF
002623 f4d1                      	brne sound_driver_instrument_routine_channel0_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_loop:
002624 91b0 2831                 	lds r27, pulse1_arpeggio_macro_loop
002626 3fbf                      	cpi r27, 0xFF
002627 f499                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002628 c015                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute:
002629 91b0 2832                 	lds r27, pulse1_arpeggio_macro_release
00262b 3fbf                      	cpi r27, 0xFF
00262c f421                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_check_loop:
00262d 91b0 2831                 	lds r27, pulse1_arpeggio_macro_loop //load the loop index
00262f 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002630 f451                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop:
002631 91c0 2846                 	lds r28, pulse1_fx_0xy_sequence //check for 0xy effect
002633 91d0 2847                 	lds r29, pulse1_fx_0xy_sequence+1
002635 9620                      	adiw r29:r28, 0
002636 f469                      	brne sound_driver_instrument_routine_channel0_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002637 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002638 93a0 2830                 	sts pulse1_arpeggio_macro_offset, r26 //store the last valid index into the offset
00263a cfc2                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload:
00263b 93b0 2830                 	sts pulse1_arpeggio_macro_offset, r27 //store the loop index into the offset
00263d cfbf                      	rjmp sound_driver_instrument_routine_channel0_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_default:
00263e 91c0 2846                 	lds r28, pulse1_fx_0xy_sequence //load 0xy effect
002640 91d0 2847                 	lds r29, pulse1_fx_0xy_sequence+1
002642 9620                      	adiw r29:r28, 0 //check for 0xy effect
002643 f099                      	breq sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel0_arpeggio_default_0xy:
002644 95d6                      	lsr r29
002645 95c7                      	ror r28
002646 95d7                      	ror r29
002647 95c7                      	ror r28
002648 95d7                      	ror r29
002649 95c7                      	ror r28
00264a 95d7                      	ror r29
00264b 95c7                      	ror r28
00264c 95d7                      	ror r29
00264d 95d2                      	swap r29
                                 
00264e 93c0 2846                 	sts pulse1_fx_0xy_sequence, r28 //store the rolled sequence
002650 93d0 2847                 	sts pulse1_fx_0xy_sequence+1, r29
002652 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002653 91a0 2807                 	lds r26, pulse1_note //load the current note index
002655 0fac                      	add r26, r28 //add the note offset
002656 c02e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002657 91a0 2807                 	lds r26, pulse1_note //load the current note index
002659 c02b                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process:
00265a 9220 2834                 	sts pulse1_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
00265c 9220 2835                 	sts pulse1_total_pitch_offset+1, zero
00265e 9220 283b                 	sts pulse1_total_hi_pitch_offset, zero
002660 91a0 2833                 	lds r26, pulse1_arpeggio_macro_mode
002662 30a1                      	cpi r26, 0x01 //absolute mode
002663 f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_absolute
002664 f069                      	breq sound_driver_instrument_routine_channel0_arpeggio_process_fixed
002665 c00e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute:
002666 91a0 2807                 	lds r26, pulse1_note //load the current note index
002668 0fab                      	add r26, r27 //offset the note with the arpeggio data
002669 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
00266a c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_add:
00266b 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
00266c f0c0                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
00266d e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
00266e c016                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract:
00266f fda7                      	sbrc r26, 7 //check if result is negative
002670 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002671 c013                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_fixed:
002672 2fab                      	mov r26, r27 //move the arpeggio data into r26
002673 c011                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative:
002674 91a0 2807                 	lds r26, pulse1_note //load the current note index
002676 0fab                      	add r26, r27 //offset the note with the arpeggio data
002677 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002678 c008                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_add:
002679 93a0 2807                 	sts pulse1_note, r26 //NOTE: relative mode modifies the original note index
00267b 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
00267c f040                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
00267d e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
00267e 93a0 2807                 	sts pulse1_note, r26
002680 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract:
002681 fda7                      	sbrc r26, 7 //check if result is negative
002682 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002683 93a0 2807                 	sts pulse1_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_load:
002685 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
002686 e0f0                      	ldi ZH, HIGH(note_table << 1)
002687 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002688 0fea                      	add ZL, r26 //add offset
002689 1df2                      	adc ZH, zero
00268a 91a5                      	lpm r26, Z+ //load bytes
00268b 91b4                      	lpm r27, Z
00268c 93a0 0a8c                 	sts TCB0_CCMPL, r26 //load the LOW bits for timer
00268e 93b0 0a8d                 	sts TCB0_CCMPH, r27 //load the HIGH bits for timer
002690 93a0 2852                 	sts pulse1_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002692 93b0 2853                 	sts pulse1_fx_3xx_target+1, r27
002694 c000                      	rjmp sound_driver_instrument_routine_channel0_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch:
002695 91e0 2836                 	lds ZL, pulse1_pitch_macro
002697 91f0 2837                 	lds ZH, pulse1_pitch_macro+1
002699 9630                      	adiw Z, 0
00269a f409                      	brne sound_driver_instrument_routine_channel0_pitch_continue
00269b c023                      	rjmp sound_driver_instrument_routine_channel0_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel0_pitch_continue:
00269c 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00269d 1fff                      	rol ZH
00269e 91a0 2838                 	lds r26, pulse1_pitch_macro_offset
0026a0 0fea                      	add ZL, r26
0026a1 1df2                      	adc ZH, zero
                                 
0026a2 91b0 283a                 	lds r27, pulse1_pitch_macro_release
0026a4 17ba                      	cp r27, r26
0026a5 f429                      	brne sound_driver_instrument_routine_channel0_pitch_increment //if the current offset is not equal to the release index, increment the offset
0026a6 91a0 2839                 	lds r26, pulse1_pitch_macro_loop
0026a8 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0026a9 f010                      	brlo sound_driver_instrument_routine_channel0_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0026aa c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_pitch_increment:
0026ab 95a3                      	inc r26 //increment the macro offset
0026ac 93a0 2838                 	sts pulse1_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_pitch_read:
0026ae 91b4                      	lpm r27, Z //load pitch data into r27
0026af 38b0                      	cpi r27, 0x80 //check for macro end flag
0026b0 f479                      	brne sound_driver_instrument_routine_channel0_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_release:
0026b1 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0026b2 93a0 2838                 	sts pulse1_pitch_macro_offset, r26
0026b4 91b0 283a                 	lds r27, pulse1_pitch_macro_release
0026b6 3fbf                      	cpi r27, 0xFF
0026b7 f439                      	brne sound_driver_instrument_routine_channel0_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_loop:
0026b8 91b0 2839                 	lds r27, pulse1_pitch_macro_loop //load the loop index
0026ba 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0026bb f019                      	breq sound_driver_instrument_routine_channel0_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
0026bc 93b0 2838                 	sts pulse1_pitch_macro_offset, r27 //store the loop index into the offset
0026be cfd6                      	rjmp sound_driver_instrument_routine_channel0_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_default:
0026bf e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel0_pitch_calculate:
0026c0 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0026c1 937f                      	push r23
0026c2 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
0026c3 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0026c4 0367                      	mulsu r22, r23
0026c5 917f                      	pop r23
0026c6 916f                      	pop r22
                                 
0026c7 9416                      	lsr r1 //shift out the fractional bits
0026c8 9407                      	ror r0
0026c9 9416                      	lsr r1
0026ca 9407                      	ror r0
0026cb 9416                      	lsr r1
0026cc 9407                      	ror r0
0026cd 9416                      	lsr r1
0026ce 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_check_negative:
0026cf fe13                      	sbrs r1, 3 //check if result was a negative number
0026d0 c007                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_negative:
0026d1 efc0                      	ldi r28, 0xF0
0026d2 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_check_divisible_8:
0026d3 70b7                      	andi r27, 0b00000111
0026d4 f019                      	breq sound_driver_instrument_routine_channel0_pitch_calculate_offset
                                 
0026d5 e0b1                      	ldi r27, 0x01
0026d6 0e0b                      	add r0, r27
0026d7 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_offset:
0026d8 91a0 2834                 	lds r26, pulse1_total_pitch_offset
0026da 91b0 2835                 	lds r27, pulse1_total_pitch_offset+1
0026dc 0e0a                      	add r0, r26
0026dd 1e1b                      	adc r1, r27
0026de 9200 2834                 	sts pulse1_total_pitch_offset, r0
0026e0 9210 2835                 	sts pulse1_total_pitch_offset+1, r1
0026e2 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
0026e4 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
0026e6 0da0                      	add r26, r0 //offset the timer values
0026e7 1db1                      	adc r27, r1
                                 	
0026e8 91c0 284a                 	lds r28, pulse1_fx_1xx_total
0026ea 91d0 284b                 	lds r29, pulse1_fx_1xx_total+1
0026ec 1bac                      	sub r26, r28
0026ed 0bbd                      	sbc r27, r29
0026ee 91c0 284e                 	lds r28, pulse1_fx_2xx_total
0026f0 91d0 284f                 	lds r29, pulse1_fx_2xx_total+1
0026f2 0fac                      	add r26, r28
0026f3 1fbd                      	adc r27, r29
0026f4 91c0 2862                 	lds r28, pulse1_fx_Pxx_total
0026f6 91d0 2863                 	lds r29, pulse1_fx_Pxx_total+1
0026f8 0fac                      	add r26, r28
0026f9 1fbd                      	adc r27, r29
0026fa 91c0 2869                 	lds r28, pulse1_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
0026fc 91d0 286a                 	lds r29, pulse1_fx_Qxy_total_offset+1
0026fe 1bac                      	sub r26, r28
0026ff 0bbd                      	sbc r27, r29
002700 91c0 2870                 	lds r28, pulse1_fx_Rxy_total_offset
002702 91d0 2871                 	lds r29, pulse1_fx_Rxy_total_offset+1
002704 0fac                      	add r26, r28
002705 1fbd                      	adc r27, r29
                                 
002706 e5c9                      	ldi r28, 0x59
002707 e0d0                      	ldi r29, 0x00
002708 17ac                      	cp r26, r28
002709 07bd                      	cpc r27, r29
00270a f030                      	brlo sound_driver_instrument_routine_channel0_pitch_min
                                 
00270b e5ca                      	ldi r28, 0x5A
00270c e5d9                      	ldi r29, 0x59
00270d 17ac                      	cp r26, r28
00270e 07bd                      	cpc r27, r29
00270f f420                      	brsh sound_driver_instrument_routine_channel0_pitch_max
002710 c006                      	rjmp sound_driver_instrument_routine_channel0_pitch_store
                                 
                                 sound_driver_instrument_routine_channel0_pitch_min:
002711 e5c9                      	ldi r28, 0x59
002712 e0d0                      	ldi r29, 0x00
002713 c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_store
                                 
                                 sound_driver_instrument_routine_channel0_pitch_max:
002714 e5c9                      	ldi r28, 0x59
002715 e5d9                      	ldi r29, 0x59
002716 c000                      	rjmp sound_driver_instrument_routine_channel0_pitch_store
                                 
                                 sound_driver_instrument_routine_channel0_pitch_store:
002717 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
002719 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel0_hi_pitch:
00271b 91e0 283c                 	lds ZL, pulse1_hi_pitch_macro
00271d 91f0 283d                 	lds ZH, pulse1_hi_pitch_macro+1
00271f 9630                      	adiw Z, 0
002720 f409                      	brne sound_driver_instrument_routine_channel0_hi_pitch_continue
002721 c03c                      	rjmp sound_driver_instrument_routine_channel0_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel0_hi_pitch_continue:
002722 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002723 1fff                      	rol ZH
002724 91a0 283e                 	lds r26, pulse1_hi_pitch_macro_offset
002726 0fea                      	add ZL, r26
002727 1df2                      	adc ZH, zero
                                 
002728 91b0 2840                 	lds r27, pulse1_hi_pitch_macro_release
00272a 17ba                      	cp r27, r26
00272b f429                      	brne sound_driver_instrument_routine_channel0_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
00272c 91a0 283f                 	lds r26, pulse1_hi_pitch_macro_loop
00272e 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00272f f010                      	brlo sound_driver_instrument_routine_channel0_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002730 c003                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_increment:
002731 95a3                      	inc r26 //increment the macro offset
002732 93a0 283e                 	sts pulse1_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_hi_pitch_read:
002734 91b4                      	lpm r27, Z //load hi pitch data into r27
002735 38b0                      	cpi r27, 0x80 //check for macro end flag
002736 f489                      	brne sound_driver_instrument_routine_channel0_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_release:
002737 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002738 93a0 283e                 	sts pulse1_hi_pitch_macro_offset, r26
00273a 91b0 2840                 	lds r27, pulse1_hi_pitch_macro_release
00273c 3fbf                      	cpi r27, 0xFF
00273d f439                      	brne sound_driver_instrument_routine_channel0_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_loop:
00273e 91b0 283f                 	lds r27, pulse1_hi_pitch_macro_loop //load the loop index
002740 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002741 f019                      	breq sound_driver_instrument_routine_channel0_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002742 93b0 283e                 	sts pulse1_hi_pitch_macro_offset, r27 //store the loop index into the offset
002744 cfd6                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_default:
002745 91b0 283b                 	lds r27, pulse1_total_hi_pitch_offset
002747 c005                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate:
002748 91a0 283b                 	lds r26, pulse1_total_hi_pitch_offset //load the total hi pitch offset to change
00274a 0fba                      	add r27, r26
00274b 93b0 283b                 	sts pulse1_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply:
00274d 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00274e 937f                      	push r23
00274f 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002750 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002751 0367                      	mulsu r22, r23
002752 917f                      	pop r23
002753 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_offset:
002754 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
002756 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
002758 0da0                      	add r26, r0 //offset the timer values
002759 1db1                      	adc r27, r1
00275a 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
00275c 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel0_duty:
00275e 91e0 2841                 	lds ZL, pulse1_duty_macro
002760 91f0 2842                 	lds ZH, pulse1_duty_macro+1
002762 9630                      	adiw Z, 0
002763 f1b1                      	breq sound_driver_channel0_fx_routines //if no duty macro is in use, go to the next routine
002764 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002765 1fff                      	rol ZH
002766 91a0 2843                 	lds r26, pulse1_duty_macro_offset
002768 0fea                      	add ZL, r26
002769 1df2                      	adc ZH, zero
                                 
00276a 91b0 2845                 	lds r27, pulse1_duty_macro_release
00276c 17ba                      	cp r27, r26
00276d f429                      	brne sound_driver_instrument_routine_channel0_duty_increment //if the current offset is not equal to the release index, increment the offset
00276e 91a0 2844                 	lds r26, pulse1_duty_macro_loop
002770 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002771 f010                      	brlo sound_driver_instrument_routine_channel0_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002772 c027                      	rjmp sound_driver_channel0_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel0_duty_increment:
002773 95a3                      	inc r26 //increment the macro offset
002774 93a0 2843                 	sts pulse1_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_duty_read:
002776 91b4                      	lpm r27, Z //load pitch data into r27
002777 3fbf                      	cpi r27, 0xFF //check for macro end flag
002778 f471                      	brne sound_driver_instrument_routine_channel0_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_release:
002779 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00277a 93a0 2843                 	sts pulse1_duty_macro_offset, r26
00277c 91b0 2845                 	lds r27, pulse1_duty_macro_release
00277e 3fbf                      	cpi r27, 0xFF
00277f f4d1                      	brne sound_driver_channel0_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_loop:
002780 91b0 2844                 	lds r27, pulse1_duty_macro_loop //load the loop index
002782 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002783 f0b1                      	breq sound_driver_channel0_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
002784 93b0 2843                 	sts pulse1_duty_macro_offset, r27 //store the loop index into the offset
002786 cfd7                      	rjmp sound_driver_instrument_routine_channel0_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_load:
002787 eae2                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
002788 e6f2                      	ldi ZH, HIGH(sequences << 1)
002789 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
00278a 1df2                      	adc ZH, zero
                                 
00278b 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
00278c 95b7                      	ror r27
00278d 95b7                      	ror r27
00278e 91a0 2800                 	lds r26, pulse1_param //load r26 with pulse1_param (register $4000)
002790 2fca                      	mov r28, r26 //store a copy of pulse1_param into r28
002791 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
002792 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
002793 c001                      	rjmp sound_driver_instrument_routine_channel0_duty_load_store
002794 c005                      	rjmp sound_driver_channel0_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel0_duty_load_store:
002795 9074                      	lpm pulse1_sequence, Z //store the sequence
                                 
002796 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
002797 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
002798 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_routines:
                                 sound_driver_channel0_fx_1xx_routine:
00279a 91e0 2848                 	lds ZL, pulse1_fx_1xx
00279c 91f0 2849                 	lds ZH, pulse1_fx_1xx+1
00279e 9630                      	adiw Z, 0
00279f f051                      	breq sound_driver_channel0_fx_2xx_routine
                                 
0027a0 91a0 284a                 	lds r26, pulse1_fx_1xx_total //load the rate to change the pitch by
0027a2 91b0 284b                 	lds r27, pulse1_fx_1xx_total+1
0027a4 0fae                      	add r26, ZL //increase the total offset by the rate
0027a5 1fbf                      	adc r27, ZH
0027a6 93a0 284a                 	sts pulse1_fx_1xx_total, r26
0027a8 93b0 284b                 	sts pulse1_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_2xx_routine:
0027aa 91e0 284c                 	lds ZL, pulse1_fx_2xx
0027ac 91f0 284d                 	lds ZH, pulse1_fx_2xx+1
0027ae 9630                      	adiw Z, 0
0027af f051                      	breq sound_driver_channel0_fx_3xx_routine
                                 
0027b0 91a0 284e                 	lds r26, pulse1_fx_2xx_total //load the rate to change the pitch by
0027b2 91b0 284f                 	lds r27, pulse1_fx_2xx_total+1
0027b4 0fae                      	add r26, ZL //increase the total offset by the rate
0027b5 1fbf                      	adc r27, ZH
0027b6 93a0 284e                 	sts pulse1_fx_2xx_total, r26
0027b8 93b0 284f                 	sts pulse1_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_3xx_routine:
0027ba 91e0 2854                 	lds ZL, pulse1_fx_3xx_speed
0027bc 91f0 2855                 	lds ZH, pulse1_fx_3xx_speed+1
0027be 9630                      	adiw Z, 0
0027bf f409                      	brne sound_driver_channel0_fx_3xx_routine_check_start
0027c0 c048                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_check_start:
0027c1 91a0 2850                 	lds r26, pulse1_fx_3xx_start
0027c3 91b0 2851                 	lds r27, pulse1_fx_3xx_start+1
0027c5 9610                      	adiw r26:r27, 0
0027c6 f409                      	brne sound_driver_channel0_fx_3xx_routine_main
0027c7 c041                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_main:
0027c8 91c0 2852                 	lds r28, pulse1_fx_3xx_target
0027ca 91d0 2853                 	lds r29, pulse1_fx_3xx_target+1
                                 
0027cc 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
0027cd 07bd                      	cpc r27, r29
0027ce f011                      	breq sound_driver_channel0_fx_3xx_routine_disable
0027cf f030                      	brlo sound_driver_channel0_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
0027d0 c01f                      	rjmp sound_driver_channel0_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel0_fx_3xx_routine_disable:
0027d1 9220 2850                 	sts pulse1_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
0027d3 9220 2851                 	sts pulse1_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
0027d5 c033                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_subtract:
0027d6 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
0027d7 0bdb                      	sbc r29, r27
0027d8 91a0 2856                 	lds r26, pulse1_fx_3xx_total_offset
0027da 91b0 2857                 	lds r27, pulse1_fx_3xx_total_offset+1
                                 
0027dc 0fae                      	add r26, ZL //add the speed to the total offset
0027dd 1fbf                      	adc r27, ZH
0027de 1bca                      	sub r28, r26 //invert the total difference with the total offset
0027df 0bdb                      	sbc r29, r27
0027e0 f380                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0027e1 93a0 2856                 	sts pulse1_fx_3xx_total_offset, r26 //store the new total offset
0027e3 93b0 2857                 	sts pulse1_fx_3xx_total_offset+1, r27
                                 
0027e5 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the current timer period
0027e7 91b0 0a8d                 	lds r27, TCB0_CCMPH
0027e9 1bac                      	sub r26, r28 //offset the current timer period with the total offset
0027ea 0bbd                      	sbc r27, r29
0027eb 93a0 0a8c                 	sts TCB0_CCMPL, r26
0027ed 93b0 0a8d                 	sts TCB0_CCMPH, r27
0027ef c019                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_add:
0027f0 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
0027f1 0bbd                      	sbc r27, r29
0027f2 91c0 2856                 	lds r28, pulse1_fx_3xx_total_offset
0027f4 91d0 2857                 	lds r29, pulse1_fx_3xx_total_offset+1
                                 
0027f6 0fce                      	add r28, ZL //add the speed to the total offset
0027f7 1fdf                      	adc r29, ZH
0027f8 1bac                      	sub r26, r28 //invert the total difference with the total offset
0027f9 0bbd                      	sbc r27, r29
0027fa f2b0                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0027fb 93c0 2856                 	sts pulse1_fx_3xx_total_offset, r28 //store the new total offset
0027fd 93d0 2857                 	sts pulse1_fx_3xx_total_offset+1, r29
                                 
0027ff 91c0 0a8c                 	lds r28, TCB0_CCMPL //load the current timer period
002801 91d0 0a8d                 	lds r29, TCB0_CCMPH
002803 0fca                      	add r28, r26 //offset the current timer period with the total offset
002804 1fdb                      	adc r29, r27
002805 93c0 0a8c                 	sts TCB0_CCMPL, r28
002807 93d0 0a8d                 	sts TCB0_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel0_fx_4xy_routine:
002809 91a0 2858                 	lds r26, pulse1_fx_4xy_speed
00280b 15a2                      	cp r26, zero
00280c f409                      	brne sound_driver_channel0_fx_4xy_routine_continue
00280d c05c                      	rjmp sound_driver_channel0_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel0_fx_4xy_routine_continue:
00280e 91b0 2859                 	lds r27, pulse1_fx_4xy_depth
002810 91c0 285a                 	lds r28, pulse1_fx_4xy_phase
002812 0fca                      	add r28, r26 //increase the phase by the speed
002813 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002814 f008                      	brlo sound_driver_channel0_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002815 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase:
002816 93c0 285a                 	sts pulse1_fx_4xy_phase, r28 //store the new phase
002818 31c0                      	cpi r28, 16
002819 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_0
00281a 32c0                      	cpi r28, 32
00281b f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_1
00281c 33c0                      	cpi r28, 48
00281d f030                      	brlo sound_driver_channel0_fx_4xy_routine_phase_2
00281e c007                      	rjmp sound_driver_channel0_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_0:
00281f 70cf                      	andi r28, 0x0F //mask for values 0-15
002820 c029                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_1:
002821 6fc0                      	ori r28, 0xF0
002822 95c0                      	com r28 //invert values 0-15
002823 c026                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_2:
002824 70cf                      	andi r28, 0x0F //mask for values 0-15
002825 c003                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_3:
002826 6fc0                      	ori r28, 0xF0
002827 95c0                      	com r28 //invert values 0-15
002828 c000                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_add:
002829 95b2                      	swap r27 //multiply depth by 16
00282a 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
00282b e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00282c e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00282d 0fec                      	add ZL, r28 //offset the table by the depth+phase
00282e 1df2                      	adc ZH, zero
00282f 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002830 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002831 937f                      	push r23
002832 2f6c                      	mov r22, r28 //store the vibrato value into r22
002833 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002834 9f67                      	mul r22, r23
002835 917f                      	pop r23
002836 916f                      	pop r22
                                 
002837 9416                      	lsr r1 //shift out the fractional bits
002838 9407                      	ror r0
002839 9416                      	lsr r1
00283a 9407                      	ror r0
00283b 9416                      	lsr r1
00283c 9407                      	ror r0
00283d 9416                      	lsr r1
00283e 9407                      	ror r0
                                 	
00283f 91a0 0a8c                 	lds r26, TCB0_CCMPL
002841 91b0 0a8d                 	lds r27, TCB0_CCMPH
002843 0da0                      	add r26, r0
002844 1db1                      	adc r27, r1
002845 93a0 0a8c                 	sts TCB0_CCMPL, r26
002847 93b0 0a8d                 	sts TCB0_CCMPH, r27
002849 c020                      	rjmp sound_driver_channel0_fx_7xy_routine
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_subtract:
00284a 95b2                      	swap r27 //multiply depth by 16
00284b 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
00284c e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00284d e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00284e 0fec                      	add ZL, r28 //offset the table by the depth+phase
00284f 1df2                      	adc ZH, zero
002850 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002851 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002852 937f                      	push r23
002853 2f6c                      	mov r22, r28 //store the vibrato value into r22
002854 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002855 9f67                      	mul r22, r23
002856 917f                      	pop r23
002857 916f                      	pop r22
                                 
002858 9416                      	lsr r1 //shift out the fractional bits
002859 9407                      	ror r0
00285a 9416                      	lsr r1
00285b 9407                      	ror r0
00285c 9416                      	lsr r1
00285d 9407                      	ror r0
00285e 9416                      	lsr r1
00285f 9407                      	ror r0
                                 
002860 91a0 0a8c                 	lds r26, TCB0_CCMPL
002862 91b0 0a8d                 	lds r27, TCB0_CCMPH
002864 19a0                      	sub r26, r0
002865 09b1                      	sbc r27, r1
002866 93a0 0a8c                 	sts TCB0_CCMPL, r26
002868 93b0 0a8d                 	sts TCB0_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_7xy_routine:
00286a 91a0 285b                 	lds r26, pulse1_fx_7xy_speed
00286c 15a2                      	cp r26, zero
00286d f0e9                      	breq sound_driver_channel0_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
00286e 91b0 285c                 	lds r27, pulse1_fx_7xy_depth
002870 91c0 285d                 	lds r28, pulse1_fx_7xy_phase
002872 0fca                      	add r28, r26 //increase the phase by the speed
002873 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002874 f008                      	brlo sound_driver_channel0_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
002875 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase:
002876 93c0 285d                 	sts pulse1_fx_7xy_phase, r28 //store the new phase
002878 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
002879 ffc4                      	sbrs r28, 4
00287a c001                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_0
00287b c002                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel0_fx_7xy_routine_phase_0:
00287c 70cf                      	andi r28, 0x0F //mask for values 0-15
00287d c003                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase_1:
00287e 6fc0                      	ori r28, 0xF0
00287f 95c0                      	com r28 //invert values 0-15
002880 c000                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_load:
002881 95b2                      	swap r27 //multiply depth by 16
002882 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002883 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002884 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002885 0fec                      	add ZL, r28 //offset the table by the depth+phase
002886 1df2                      	adc ZH, zero
002887 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002888 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
002889 93c0 285e                 	sts pulse1_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Axy_routine:
00288b 91b0 285f                 	lds r27, pulse1_fx_Axy
00288d 15b2                      	cp r27, zero
00288e f0e9                      	breq sound_driver_channel0_fx_Qxy_routine //0 means that the effect is not in use
                                 	
00288f 91a0 2805                 	lds r26, pulse1_fractional_volume //load fractional volume representation of the channel
002891 91c0 2800                 	lds r28, pulse1_param //load the integer volume representation of the channel
002893 2fda                      	mov r29, r26 //copy fractional volume into r29
002894 2fec                      	mov r30, r28 //copy the pulse1_param into r30
002895 95e2                      	swap r30
002896 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
002897 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
002898 17ed                      	cp r30, r29 //compare the fractional and integer volumes
002899 f009                      	breq sound_driver_channel0_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel0_fx_Axy_routine_reload:
00289a 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate:
00289b fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
00289c c004                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_addition:
00289d 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
00289e f428                      	brcc sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
00289f efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
0028a0 c003                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_subtraction:
0028a1 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0028a2 f008                      	brcs sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0028a3 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_store:
0028a4 93a0 2805                 	sts pulse1_fractional_volume, r26 //store the new fractional volume
0028a6 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
0028a7 95a2                      	swap r26
0028a8 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
0028a9 2bca                      	or r28, r26 //store the new volume back into pulse1_param
0028aa 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel0_fx_Qxy_routine:
0028ac 91e0 2865                 	lds ZL, pulse1_fx_Qxy_target
0028ae 91f0 2866                 	lds ZH, pulse1_fx_Qxy_target+1
0028b0 9630                      	adiw Z, 0
0028b1 f119                      	breq sound_driver_channel0_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
0028b2 91a0 2869                 	lds r26, pulse1_fx_Qxy_total_offset
0028b4 91b0 286a                 	lds r27, pulse1_fx_Qxy_total_offset+1
0028b6 91c0 0a8c                 	lds r28, TCB0_CCMPL
0028b8 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
0028ba 1bec                      	sub ZL, r28 //calculate the difference to the target
0028bb 0bfd                      	sbc ZH, r29
0028bc f408                      	brsh sound_driver_channel0_fx_Qxy_routine_end //if the target has been reached (or passed)
0028bd f068                      	brlo sound_driver_channel0_fx_Qxy_routine_add
                                 
                                 sound_driver_channel0_fx_Qxy_routine_end:
0028be 9220 2869                 	sts pulse1_fx_Qxy_total_offset, zero //turn off the effect
0028c0 9220 286a                 	sts pulse1_fx_Qxy_total_offset+1, zero
0028c2 9220 2865                 	sts pulse1_fx_Qxy_target, zero
0028c4 9220 2866                 	sts pulse1_fx_Qxy_target+1, zero
0028c6 91b0 2864                 	lds r27, pulse1_fx_Qxy_target_note
0028c8 93b0 2807                 	sts pulse1_note, r27 //replace the note with the final target note
0028ca c00a                      	rjmp sound_driver_channel0_fx_Rxy_routine
                                 
                                 sound_driver_channel0_fx_Qxy_routine_add:
0028cb 91c0 2867                 	lds r28, pulse1_fx_Qxy_speed
0028cd 91d0 2868                 	lds r29, pulse1_fx_Qxy_speed+1
0028cf 0fac                      	add r26, r28 //increase the total offset by the speed
0028d0 1fbd                      	adc r27, r29
0028d1 93a0 2869                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
0028d3 93b0 286a                 	sts pulse1_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Rxy_routine:
0028d5 91e0 286c                 	lds ZL, pulse1_fx_Rxy_target
0028d7 91f0 286d                 	lds ZH, pulse1_fx_Rxy_target+1
0028d9 9630                      	adiw Z, 0
0028da f119                      	breq sound_driver_instrument_routine_channel1_volume //if the effect is not enabled, skip the routine
                                 
0028db 91a0 2870                 	lds r26, pulse1_fx_Rxy_total_offset
0028dd 91b0 2871                 	lds r27, pulse1_fx_Rxy_total_offset+1
0028df 91c0 0a8c                 	lds r28, TCB0_CCMPL
0028e1 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
0028e3 1bce                      	sub r28, ZL //calculate the difference to the target
0028e4 0bdf                      	sbc r29, ZH
0028e5 f408                      	brsh sound_driver_channel0_fx_Rxy_routine_end //if the target has been reached (or passed)
0028e6 f068                      	brlo sound_driver_channel0_fx_Rxy_routine_add
                                 
                                 sound_driver_channel0_fx_Rxy_routine_end:
0028e7 9220 2870                 	sts pulse1_fx_Rxy_total_offset, zero //disable the effect
0028e9 9220 2871                 	sts pulse1_fx_Rxy_total_offset+1, zero
0028eb 9220 286c                 	sts pulse1_fx_Rxy_target, zero
0028ed 9220 286d                 	sts pulse1_fx_Rxy_target+1, zero
0028ef 91b0 286b                 	lds r27, pulse1_fx_Rxy_target_note
0028f1 93b0 2807                 	sts pulse1_note, r27 //replace the note with the final target note
0028f3 c00a                      	rjmp sound_driver_instrument_routine_channel1_volume
                                 
                                 sound_driver_channel0_fx_Rxy_routine_add:
0028f4 91c0 286e                 	lds r28, pulse1_fx_Rxy_speed
0028f6 91d0 286f                 	lds r29, pulse1_fx_Rxy_speed+1
0028f8 0fac                      	add r26, r28 //increase the total offset by the speed
0028f9 1fbd                      	adc r27, r29
0028fa 93a0 2870                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
0028fc 93b0 2871                 	sts pulse1_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume:
0028fe 91e0 287a                 	lds ZL, pulse2_volume_macro
002900 91f0 287b                 	lds ZH, pulse2_volume_macro+1
002902 9630                      	adiw Z, 0
002903 f1a1                      	breq sound_driver_instrument_routine_channel1_volume_default //if no volume macro is in use, use default multiplier of F
002904 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002905 1fff                      	rol ZH
002906 91a0 287c                 	lds r26, pulse2_volume_macro_offset
002908 0fea                      	add ZL, r26
002909 1df2                      	adc ZH, zero
                                 
00290a 91b0 287e                 	lds r27, pulse2_volume_macro_release
00290c 17ba                      	cp r27, r26
00290d f429                      	brne sound_driver_instrument_routine_channel1_volume_increment //if the current offset is not equal to the release index, increment the offset
00290e 91a0 287d                 	lds r26, pulse2_volume_macro_loop
002910 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002911 f010                      	brlo sound_driver_instrument_routine_channel1_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002912 c003                      	rjmp sound_driver_instrument_routine_channel1_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_volume_increment:
002913 95a3                      	inc r26 //increment the macro offset
002914 93a0 287c                 	sts pulse2_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_volume_read:
002916 91b4                      	lpm r27, Z //load volume data into r27
002917 3fbf                      	cpi r27, 0xFF //check for macro end flag
002918 f469                      	brne sound_driver_instrument_routine_channel1_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_release:
002919 91b0 287e                 	lds r27, pulse2_volume_macro_release
00291b 3fbf                      	cpi r27, 0xFF
00291c f429                      	brne sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_loop:
00291d 91b0 287d                 	lds r27, pulse2_volume_macro_loop //load the loop index
00291f 93b0 287c                 	sts pulse2_volume_macro_offset, r27 //store the loop index into the offset
002921 cfdc                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index:
002922 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002923 93a0 287c                 	sts pulse2_volume_macro_offset, r26
002925 cfd8                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_calculate:
002926 eaea                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
002927 e6f3                      	ldi ZH, HIGH(volumes << 1)
002928 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
002929 0feb                      	add ZL, r27 //add offset to the table
00292a 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel1_volume_load:
00292b 91b0 2808                 	lds r27, pulse2_param //load main volume
00292d 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
00292e 91a0 28af                 	lds r26, pulse2_fx_7xy_value
002930 30a0                      	cpi r26, 0x00
002931 f481                      	brne sound_driver_instrument_routine_channel1_volume_load_7xy
                                 
002932 0feb                      	add ZL, r27 //offset the volume table by the main volume
002933 1df2                      	adc ZH, zero
002934 91b4                      	lpm r27, Z
002935 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
002937 c023                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default:
002938 91b0 2808                 	lds r27, pulse2_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
00293a 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
00293b 91a0 28af                 	lds r26, pulse2_fx_7xy_value
00293d 30a0                      	cpi r26, 0x00
00293e f499                      	brne sound_driver_instrument_routine_channel1_volume_default_7xy
00293f 93b0 280e                 	sts pulse2_output_volume, r27
002941 c019                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy:
002942 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002943 f038                      	brcs sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
002944 f031                      	breq sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
                                 
002945 0feb                      	add ZL, r27 //offset the volume table by the main volume
002946 1df2                      	adc ZH, zero
002947 91b4                      	lpm r27, Z
002948 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
00294a c010                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy_overflow:
00294b e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
00294c 0feb                      	add ZL, r27 //offset the volume table by the main volume
00294d 1df2                      	adc ZH, zero
00294e 91b4                      	lpm r27, Z
00294f 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
002951 c009                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default_7xy:
002952 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002953 f020                      	brcs sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
002954 f019                      	breq sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
002955 93b0 280e                 	sts pulse2_output_volume, r27
002957 c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel1_volume_default_7xy_overflow:
002958 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002959 93b0 280e                 	sts pulse2_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
00295b 91e0 287f                 	lds ZL, pulse2_arpeggio_macro
00295d 91f0 2880                 	lds ZH, pulse2_arpeggio_macro+1
00295f 9630                      	adiw Z, 0
002960 f1d9                      	breq sound_driver_instrument_routine_channel1_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002961 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002962 1fff                      	rol ZH
002963 91a0 2881                 	lds r26, pulse2_arpeggio_macro_offset
002965 0fea                      	add ZL, r26
002966 1df2                      	adc ZH, zero
                                 
002967 91b0 2883                 	lds r27, pulse2_arpeggio_macro_release
002969 17ba                      	cp r27, r26
00296a f429                      	brne sound_driver_instrument_routine_channel1_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
00296b 91a0 2882                 	lds r26, pulse2_arpeggio_macro_loop
00296d 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00296e f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
00296f c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_increment:
002970 95a3                      	inc r26 //increment the macro offset
002971 93a0 2881                 	sts pulse2_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_read:
002973 91b4                      	lpm r27, Z //load arpeggio data into r27
002974 38b0                      	cpi r27, 0x80 //check for macro end flag
002975 f009                      	breq sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag
002976 c041                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_check_mode:
002977 50a1                      	subi r26, 1 //keep the offset at the end flag
002978 93a0 2881                 	sts pulse2_arpeggio_macro_offset, r26
00297a 91b0 2884                 	lds r27, pulse2_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
00297c 30b1                      	cpi r27, 0x01
00297d f048                      	brlo sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_release:
00297e 91b0 2883                 	lds r27, pulse2_arpeggio_macro_release
002980 3fbf                      	cpi r27, 0xFF
002981 f4d1                      	brne sound_driver_instrument_routine_channel1_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_loop:
002982 91b0 2882                 	lds r27, pulse2_arpeggio_macro_loop
002984 3fbf                      	cpi r27, 0xFF
002985 f499                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002986 c015                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute:
002987 91b0 2883                 	lds r27, pulse2_arpeggio_macro_release
002989 3fbf                      	cpi r27, 0xFF
00298a f421                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_check_loop:
00298b 91b0 2882                 	lds r27, pulse2_arpeggio_macro_loop //load the loop index
00298d 3fbf                      	cpi r27, 0xFF //check if loop flag exists
00298e f451                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop:
00298f 91c0 2897                 	lds r28, pulse2_fx_0xy_sequence //check for 0xy effect
002991 91d0 2898                 	lds r29, pulse2_fx_0xy_sequence+1
002993 9620                      	adiw r29:r28, 0
002994 f469                      	brne sound_driver_instrument_routine_channel1_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002995 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002996 93a0 2881                 	sts pulse2_arpeggio_macro_offset, r26 //store the last valid index into the offset
002998 cfc2                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload:
002999 93b0 2881                 	sts pulse2_arpeggio_macro_offset, r27 //store the loop index into the offset
00299b cfbf                      	rjmp sound_driver_instrument_routine_channel1_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_default:
00299c 91c0 2897                 	lds r28, pulse2_fx_0xy_sequence //load 0xy effect
00299e 91d0 2898                 	lds r29, pulse2_fx_0xy_sequence+1
0029a0 9620                      	adiw r29:r28, 0 //check for 0xy effect
0029a1 f099                      	breq sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel1_arpeggio_default_0xy:
0029a2 95d6                      	lsr r29
0029a3 95c7                      	ror r28
0029a4 95d7                      	ror r29
0029a5 95c7                      	ror r28
0029a6 95d7                      	ror r29
0029a7 95c7                      	ror r28
0029a8 95d7                      	ror r29
0029a9 95c7                      	ror r28
0029aa 95d7                      	ror r29
0029ab 95d2                      	swap r29
                                 
0029ac 93c0 2897                 	sts pulse2_fx_0xy_sequence, r28 //store the rolled sequence
0029ae 93d0 2898                 	sts pulse2_fx_0xy_sequence+1, r29
0029b0 70cf                      	andi r28, 0x0F //mask out the 4 LSB
0029b1 91a0 280f                 	lds r26, pulse2_note //load the current note index
0029b3 0fac                      	add r26, r28 //add the note offset
0029b4 c02e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
0029b5 91a0 280f                 	lds r26, pulse2_note //load the current note index
0029b7 c02b                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process:
0029b8 9220 2885                 	sts pulse2_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
0029ba 9220 2886                 	sts pulse2_total_pitch_offset+1, zero
0029bc 9220 288c                 	sts pulse2_total_hi_pitch_offset, zero
0029be 91a0 2884                 	lds r26, pulse2_arpeggio_macro_mode
0029c0 30a1                      	cpi r26, 0x01 //absolute mode
0029c1 f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_absolute
0029c2 f069                      	breq sound_driver_instrument_routine_channel1_arpeggio_process_fixed
0029c3 c00e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute:
0029c4 91a0 280f                 	lds r26, pulse2_note //load the current note index
0029c6 0fab                      	add r26, r27 //offset the note with the arpeggio data
0029c7 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0029c8 c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_add:
0029c9 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0029ca f0c0                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
0029cb e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0029cc c016                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract:
0029cd fda7                      	sbrc r26, 7 //check if result is negative
0029ce e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0029cf c013                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_fixed:
0029d0 2fab                      	mov r26, r27 //move the arpeggio data into r26
0029d1 c011                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative:
0029d2 91a0 280f                 	lds r26, pulse2_note //load the current note index
0029d4 0fab                      	add r26, r27 //offset the note with the arpeggio data
0029d5 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0029d6 c008                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_add:
0029d7 93a0 280f                 	sts pulse2_note, r26 //NOTE: relative mode modifies the original note index
0029d9 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0029da f040                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
0029db e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0029dc 93a0 280f                 	sts pulse2_note, r26
0029de c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract:
0029df fda7                      	sbrc r26, 7 //check if result is negative
0029e0 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0029e1 93a0 280f                 	sts pulse2_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_load:
0029e3 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0029e4 e0f0                      	ldi ZH, HIGH(note_table << 1)
0029e5 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
0029e6 0fea                      	add ZL, r26 //add offset
0029e7 1df2                      	adc ZH, zero
0029e8 91a5                      	lpm r26, Z+ //load bytes
0029e9 91b4                      	lpm r27, Z
0029ea 93a0 0a9c                 	sts TCB1_CCMPL, r26 //load the LOW bits for timer
0029ec 93b0 0a9d                 	sts TCB1_CCMPH, r27 //load the HIGH bits for timer
0029ee 93a0 28a3                 	sts pulse2_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
0029f0 93b0 28a4                 	sts pulse2_fx_3xx_target+1, r27
0029f2 c000                      	rjmp sound_driver_instrument_routine_channel1_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch:
0029f3 91e0 2887                 	lds ZL, pulse2_pitch_macro
0029f5 91f0 2888                 	lds ZH, pulse2_pitch_macro+1
0029f7 9630                      	adiw Z, 0
0029f8 f409                      	brne sound_driver_instrument_routine_channel1_pitch_continue
0029f9 c023                      	rjmp sound_driver_instrument_routine_channel1_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel1_pitch_continue:
0029fa 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0029fb 1fff                      	rol ZH
0029fc 91a0 2889                 	lds r26, pulse2_pitch_macro_offset
0029fe 0fea                      	add ZL, r26
0029ff 1df2                      	adc ZH, zero
                                 
002a00 91b0 288b                 	lds r27, pulse2_pitch_macro_release
002a02 17ba                      	cp r27, r26
002a03 f429                      	brne sound_driver_instrument_routine_channel1_pitch_increment //if the current offset is not equal to the release index, increment the offset
002a04 91a0 288a                 	lds r26, pulse2_pitch_macro_loop
002a06 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002a07 f010                      	brlo sound_driver_instrument_routine_channel1_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002a08 c003                      	rjmp sound_driver_instrument_routine_channel1_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_pitch_increment:
002a09 95a3                      	inc r26 //increment the macro offset
002a0a 93a0 2889                 	sts pulse2_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_pitch_read:
002a0c 91b4                      	lpm r27, Z //load pitch data into r27
002a0d 38b0                      	cpi r27, 0x80 //check for macro end flag
002a0e f479                      	brne sound_driver_instrument_routine_channel1_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_release:
002a0f 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002a10 93a0 2889                 	sts pulse2_pitch_macro_offset, r26
002a12 91b0 288b                 	lds r27, pulse2_pitch_macro_release
002a14 3fbf                      	cpi r27, 0xFF
002a15 f439                      	brne sound_driver_instrument_routine_channel1_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_loop:
002a16 91b0 288a                 	lds r27, pulse2_pitch_macro_loop //load the loop index
002a18 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002a19 f019                      	breq sound_driver_instrument_routine_channel1_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002a1a 93b0 2889                 	sts pulse2_pitch_macro_offset, r27 //store the loop index into the offset
002a1c cfd6                      	rjmp sound_driver_instrument_routine_channel1_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_default:
002a1d e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel1_pitch_calculate:
002a1e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002a1f 937f                      	push r23
002a20 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
002a21 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002a22 0367                      	mulsu r22, r23
002a23 917f                      	pop r23
002a24 916f                      	pop r22
                                 
002a25 9416                      	lsr r1 //shift out the fractional bits
002a26 9407                      	ror r0
002a27 9416                      	lsr r1
002a28 9407                      	ror r0
002a29 9416                      	lsr r1
002a2a 9407                      	ror r0
002a2b 9416                      	lsr r1
002a2c 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_check_negative:
002a2d fe13                      	sbrs r1, 3 //check if result was a negative number
002a2e c007                      	rjmp sound_driver_instrument_routine_channel1_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_negative:
002a2f efc0                      	ldi r28, 0xF0
002a30 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_check_divisible_8:
002a31 70b7                      	andi r27, 0b00000111
002a32 f019                      	breq sound_driver_instrument_routine_channel1_pitch_calculate_offset
                                 
002a33 e0b1                      	ldi r27, 0x01
002a34 0e0b                      	add r0, r27
002a35 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_offset:
002a36 91a0 2885                 	lds r26, pulse2_total_pitch_offset
002a38 91b0 2886                 	lds r27, pulse2_total_pitch_offset+1
002a3a 0e0a                      	add r0, r26
002a3b 1e1b                      	adc r1, r27
002a3c 9200 2885                 	sts pulse2_total_pitch_offset, r0
002a3e 9210 2886                 	sts pulse2_total_pitch_offset+1, r1
002a40 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
002a42 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
002a44 0da0                      	add r26, r0 //offset the timer values
002a45 1db1                      	adc r27, r1
                                 	
002a46 91c0 289b                 	lds r28, pulse2_fx_1xx_total
002a48 91d0 289c                 	lds r29, pulse2_fx_1xx_total+1
002a4a 1bac                      	sub r26, r28
002a4b 0bbd                      	sbc r27, r29
002a4c 91c0 289f                 	lds r28, pulse2_fx_2xx_total
002a4e 91d0 28a0                 	lds r29, pulse2_fx_2xx_total+1
002a50 0fac                      	add r26, r28
002a51 1fbd                      	adc r27, r29
002a52 91c0 28b3                 	lds r28, pulse2_fx_Pxx_total
002a54 91d0 28b4                 	lds r29, pulse2_fx_Pxx_total+1
002a56 0fac                      	add r26, r28
002a57 1fbd                      	adc r27, r29
002a58 91c0 28ba                 	lds r28, pulse2_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
002a5a 91d0 28bb                 	lds r29, pulse2_fx_Qxy_total_offset+1
002a5c 1bac                      	sub r26, r28
002a5d 0bbd                      	sbc r27, r29
002a5e 91c0 28c1                 	lds r28, pulse2_fx_Rxy_total_offset
002a60 91d0 28c2                 	lds r29, pulse2_fx_Rxy_total_offset+1
002a62 0fac                      	add r26, r28
002a63 1fbd                      	adc r27, r29
                                 
002a64 e5c9                      	ldi r28, 0x59
002a65 e0d0                      	ldi r29, 0x00
002a66 17ac                      	cp r26, r28
002a67 07bd                      	cpc r27, r29
002a68 f030                      	brlo sound_driver_instrument_routine_channel1_pitch_min
                                 
002a69 e5ca                      	ldi r28, 0x5A
002a6a e5d9                      	ldi r29, 0x59
002a6b 17ac                      	cp r26, r28
002a6c 07bd                      	cpc r27, r29
002a6d f420                      	brsh sound_driver_instrument_routine_channel1_pitch_max
002a6e c006                      	rjmp sound_driver_instrument_routine_channel1_pitch_store
                                 
                                 sound_driver_instrument_routine_channel1_pitch_min:
002a6f e5c9                      	ldi r28, 0x59
002a70 e0d0                      	ldi r29, 0x00
002a71 c003                      	rjmp sound_driver_instrument_routine_channel1_pitch_store
                                 
                                 sound_driver_instrument_routine_channel1_pitch_max:
002a72 e5c9                      	ldi r28, 0x59
002a73 e5d9                      	ldi r29, 0x59
002a74 c000                      	rjmp sound_driver_instrument_routine_channel1_pitch_store
                                 
                                 sound_driver_instrument_routine_channel1_pitch_store:
002a75 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
002a77 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel1_hi_pitch:
002a79 91e0 288d                 	lds ZL, pulse2_hi_pitch_macro
002a7b 91f0 288e                 	lds ZH, pulse2_hi_pitch_macro+1
002a7d 9630                      	adiw Z, 0
002a7e f409                      	brne sound_driver_instrument_routine_channel1_hi_pitch_continue
002a7f c03c                      	rjmp sound_driver_instrument_routine_channel1_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel1_hi_pitch_continue:
002a80 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002a81 1fff                      	rol ZH
002a82 91a0 288f                 	lds r26, pulse2_hi_pitch_macro_offset
002a84 0fea                      	add ZL, r26
002a85 1df2                      	adc ZH, zero
                                 
002a86 91b0 2891                 	lds r27, pulse2_hi_pitch_macro_release
002a88 17ba                      	cp r27, r26
002a89 f429                      	brne sound_driver_instrument_routine_channel1_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002a8a 91a0 2890                 	lds r26, pulse2_hi_pitch_macro_loop
002a8c 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002a8d f010                      	brlo sound_driver_instrument_routine_channel1_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002a8e c003                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_increment:
002a8f 95a3                      	inc r26 //increment the macro offset
002a90 93a0 288f                 	sts pulse2_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_hi_pitch_read:
002a92 91b4                      	lpm r27, Z //load hi pitch data into r27
002a93 38b0                      	cpi r27, 0x80 //check for macro end flag
002a94 f489                      	brne sound_driver_instrument_routine_channel1_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_release:
002a95 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002a96 93a0 288f                 	sts pulse2_hi_pitch_macro_offset, r26
002a98 91b0 2891                 	lds r27, pulse2_hi_pitch_macro_release
002a9a 3fbf                      	cpi r27, 0xFF
002a9b f439                      	brne sound_driver_instrument_routine_channel1_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_loop:
002a9c 91b0 2890                 	lds r27, pulse2_hi_pitch_macro_loop //load the loop index
002a9e 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002a9f f019                      	breq sound_driver_instrument_routine_channel1_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002aa0 93b0 288f                 	sts pulse2_hi_pitch_macro_offset, r27 //store the loop index into the offset
002aa2 cfd6                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_default:
002aa3 91b0 288c                 	lds r27, pulse2_total_hi_pitch_offset
002aa5 c005                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate:
002aa6 91a0 288c                 	lds r26, pulse2_total_hi_pitch_offset //load the total hi pitch offset to change
002aa8 0fba                      	add r27, r26
002aa9 93b0 288c                 	sts pulse2_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply:
002aab 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002aac 937f                      	push r23
002aad 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002aae eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002aaf 0367                      	mulsu r22, r23
002ab0 917f                      	pop r23
002ab1 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_offset:
002ab2 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
002ab4 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
002ab6 0da0                      	add r26, r0 //offset the timer values
002ab7 1db1                      	adc r27, r1
002ab8 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
002aba 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel1_duty:
002abc 91e0 2892                 	lds ZL, pulse2_duty_macro
002abe 91f0 2893                 	lds ZH, pulse2_duty_macro+1
002ac0 9630                      	adiw Z, 0
002ac1 f1b1                      	breq sound_driver_channel1_fx_routines //if no duty macro is in use, go to the next routine
002ac2 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002ac3 1fff                      	rol ZH
002ac4 91a0 2894                 	lds r26, pulse2_duty_macro_offset
002ac6 0fea                      	add ZL, r26
002ac7 1df2                      	adc ZH, zero
                                 
002ac8 91b0 2896                 	lds r27, pulse2_duty_macro_release
002aca 17ba                      	cp r27, r26
002acb f429                      	brne sound_driver_instrument_routine_channel1_duty_increment //if the current offset is not equal to the release index, increment the offset
002acc 91a0 2895                 	lds r26, pulse2_duty_macro_loop
002ace 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002acf f010                      	brlo sound_driver_instrument_routine_channel1_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002ad0 c027                      	rjmp sound_driver_channel1_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel1_duty_increment:
002ad1 95a3                      	inc r26 //increment the macro offset
002ad2 93a0 2894                 	sts pulse2_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_duty_read:
002ad4 91b4                      	lpm r27, Z //load pitch data into r27
002ad5 3fbf                      	cpi r27, 0xFF //check for macro end flag
002ad6 f471                      	brne sound_driver_instrument_routine_channel1_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_release:
002ad7 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002ad8 93a0 2894                 	sts pulse2_duty_macro_offset, r26
002ada 91b0 2896                 	lds r27, pulse2_duty_macro_release
002adc 3fbf                      	cpi r27, 0xFF
002add f4d1                      	brne sound_driver_channel1_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_loop:
002ade 91b0 2895                 	lds r27, pulse2_duty_macro_loop //load the loop index
002ae0 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002ae1 f0b1                      	breq sound_driver_channel1_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
002ae2 93b0 2894                 	sts pulse2_duty_macro_offset, r27 //store the loop index into the offset
002ae4 cfd7                      	rjmp sound_driver_instrument_routine_channel1_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_load:
002ae5 eae2                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
002ae6 e6f2                      	ldi ZH, HIGH(sequences << 1)
002ae7 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
002ae8 1df2                      	adc ZH, zero
                                 
002ae9 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
002aea 95b7                      	ror r27
002aeb 95b7                      	ror r27
002aec 91a0 2808                 	lds r26, pulse2_param //load r26 with pulse2_param (register $4000)
002aee 2fca                      	mov r28, r26 //store a copy of pulse2_param into r28
002aef 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
002af0 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
002af1 c001                      	rjmp sound_driver_instrument_routine_channel1_duty_load_store
002af2 c005                      	rjmp sound_driver_channel1_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel1_duty_load_store:
002af3 90a4                      	lpm pulse2_sequence, Z //store the sequence
                                 
002af4 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
002af5 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
002af6 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_routines:
                                 sound_driver_channel1_fx_1xx_routine:
002af8 91e0 2899                 	lds ZL, pulse2_fx_1xx
002afa 91f0 289a                 	lds ZH, pulse2_fx_1xx+1
002afc 9630                      	adiw Z, 0
002afd f051                      	breq sound_driver_channel1_fx_2xx_routine
                                 
002afe 91a0 289b                 	lds r26, pulse2_fx_1xx_total //load the rate to change the pitch by
002b00 91b0 289c                 	lds r27, pulse2_fx_1xx_total+1
002b02 0fae                      	add r26, ZL //increase the total offset by the rate
002b03 1fbf                      	adc r27, ZH
002b04 93a0 289b                 	sts pulse2_fx_1xx_total, r26
002b06 93b0 289c                 	sts pulse2_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_2xx_routine:
002b08 91e0 289d                 	lds ZL, pulse2_fx_2xx
002b0a 91f0 289e                 	lds ZH, pulse2_fx_2xx+1
002b0c 9630                      	adiw Z, 0
002b0d f051                      	breq sound_driver_channel1_fx_3xx_routine
                                 
002b0e 91a0 289f                 	lds r26, pulse2_fx_2xx_total //load the rate to change the pitch by
002b10 91b0 28a0                 	lds r27, pulse2_fx_2xx_total+1
002b12 0fae                      	add r26, ZL //increase the total offset by the rate
002b13 1fbf                      	adc r27, ZH
002b14 93a0 289f                 	sts pulse2_fx_2xx_total, r26
002b16 93b0 28a0                 	sts pulse2_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_3xx_routine:
002b18 91e0 28a5                 	lds ZL, pulse2_fx_3xx_speed
002b1a 91f0 28a6                 	lds ZH, pulse2_fx_3xx_speed+1
002b1c 9630                      	adiw Z, 0
002b1d f409                      	brne sound_driver_channel1_fx_3xx_routine_check_start
002b1e c048                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_check_start:
002b1f 91a0 28a1                 	lds r26, pulse2_fx_3xx_start
002b21 91b0 28a2                 	lds r27, pulse2_fx_3xx_start+1
002b23 9610                      	adiw r26:r27, 0
002b24 f409                      	brne sound_driver_channel1_fx_3xx_routine_main
002b25 c041                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_main:
002b26 91c0 28a3                 	lds r28, pulse2_fx_3xx_target
002b28 91d0 28a4                 	lds r29, pulse2_fx_3xx_target+1
                                 
002b2a 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
002b2b 07bd                      	cpc r27, r29
002b2c f011                      	breq sound_driver_channel1_fx_3xx_routine_disable
002b2d f030                      	brlo sound_driver_channel1_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002b2e c01f                      	rjmp sound_driver_channel1_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel1_fx_3xx_routine_disable:
002b2f 9220 28a1                 	sts pulse2_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002b31 9220 28a2                 	sts pulse2_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002b33 c033                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_subtract:
002b34 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002b35 0bdb                      	sbc r29, r27
002b36 91a0 28a7                 	lds r26, pulse2_fx_3xx_total_offset
002b38 91b0 28a8                 	lds r27, pulse2_fx_3xx_total_offset+1
                                 
002b3a 0fae                      	add r26, ZL //add the speed to the total offset
002b3b 1fbf                      	adc r27, ZH
002b3c 1bca                      	sub r28, r26 //invert the total difference with the total offset
002b3d 0bdb                      	sbc r29, r27
002b3e f380                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002b3f 93a0 28a7                 	sts pulse2_fx_3xx_total_offset, r26 //store the new total offset
002b41 93b0 28a8                 	sts pulse2_fx_3xx_total_offset+1, r27
                                 
002b43 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the current timer period
002b45 91b0 0a9d                 	lds r27, TCB1_CCMPH
002b47 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002b48 0bbd                      	sbc r27, r29
002b49 93a0 0a9c                 	sts TCB1_CCMPL, r26
002b4b 93b0 0a9d                 	sts TCB1_CCMPH, r27
002b4d c019                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_add:
002b4e 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002b4f 0bbd                      	sbc r27, r29
002b50 91c0 28a7                 	lds r28, pulse2_fx_3xx_total_offset
002b52 91d0 28a8                 	lds r29, pulse2_fx_3xx_total_offset+1
                                 
002b54 0fce                      	add r28, ZL //add the speed to the total offset
002b55 1fdf                      	adc r29, ZH
002b56 1bac                      	sub r26, r28 //invert the total difference with the total offset
002b57 0bbd                      	sbc r27, r29
002b58 f2b0                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002b59 93c0 28a7                 	sts pulse2_fx_3xx_total_offset, r28 //store the new total offset
002b5b 93d0 28a8                 	sts pulse2_fx_3xx_total_offset+1, r29
                                 
002b5d 91c0 0a9c                 	lds r28, TCB1_CCMPL //load the current timer period
002b5f 91d0 0a9d                 	lds r29, TCB1_CCMPH
002b61 0fca                      	add r28, r26 //offset the current timer period with the total offset
002b62 1fdb                      	adc r29, r27
002b63 93c0 0a9c                 	sts TCB1_CCMPL, r28
002b65 93d0 0a9d                 	sts TCB1_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel1_fx_4xy_routine:
002b67 91a0 28a9                 	lds r26, pulse2_fx_4xy_speed
002b69 15a2                      	cp r26, zero
002b6a f409                      	brne sound_driver_channel1_fx_4xy_routine_continue
002b6b c05c                      	rjmp sound_driver_channel1_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel1_fx_4xy_routine_continue:
002b6c 91b0 28aa                 	lds r27, pulse2_fx_4xy_depth
002b6e 91c0 28ab                 	lds r28, pulse2_fx_4xy_phase
002b70 0fca                      	add r28, r26 //increase the phase by the speed
002b71 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002b72 f008                      	brlo sound_driver_channel1_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002b73 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase:
002b74 93c0 28ab                 	sts pulse2_fx_4xy_phase, r28 //store the new phase
002b76 31c0                      	cpi r28, 16
002b77 f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_0
002b78 32c0                      	cpi r28, 32
002b79 f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_1
002b7a 33c0                      	cpi r28, 48
002b7b f030                      	brlo sound_driver_channel1_fx_4xy_routine_phase_2
002b7c c007                      	rjmp sound_driver_channel1_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_0:
002b7d 70cf                      	andi r28, 0x0F //mask for values 0-15
002b7e c029                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_1:
002b7f 6fc0                      	ori r28, 0xF0
002b80 95c0                      	com r28 //invert values 0-15
002b81 c026                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_2:
002b82 70cf                      	andi r28, 0x0F //mask for values 0-15
002b83 c003                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_3:
002b84 6fc0                      	ori r28, 0xF0
002b85 95c0                      	com r28 //invert values 0-15
002b86 c000                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_add:
002b87 95b2                      	swap r27 //multiply depth by 16
002b88 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002b89 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002b8a e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002b8b 0fec                      	add ZL, r28 //offset the table by the depth+phase
002b8c 1df2                      	adc ZH, zero
002b8d 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002b8e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002b8f 937f                      	push r23
002b90 2f6c                      	mov r22, r28 //store the vibrato value into r22
002b91 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002b92 9f67                      	mul r22, r23
002b93 917f                      	pop r23
002b94 916f                      	pop r22
                                 
002b95 9416                      	lsr r1 //shift out the fractional bits
002b96 9407                      	ror r0
002b97 9416                      	lsr r1
002b98 9407                      	ror r0
002b99 9416                      	lsr r1
002b9a 9407                      	ror r0
002b9b 9416                      	lsr r1
002b9c 9407                      	ror r0
                                 	
002b9d 91a0 0a9c                 	lds r26, TCB1_CCMPL
002b9f 91b0 0a9d                 	lds r27, TCB1_CCMPH
002ba1 0da0                      	add r26, r0
002ba2 1db1                      	adc r27, r1
002ba3 93a0 0a9c                 	sts TCB1_CCMPL, r26
002ba5 93b0 0a9d                 	sts TCB1_CCMPH, r27
002ba7 c020                      	rjmp sound_driver_channel1_fx_7xy_routine
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_subtract:
002ba8 95b2                      	swap r27 //multiply depth by 16
002ba9 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002baa e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002bab e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002bac 0fec                      	add ZL, r28 //offset the table by the depth+phase
002bad 1df2                      	adc ZH, zero
002bae 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002baf 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002bb0 937f                      	push r23
002bb1 2f6c                      	mov r22, r28 //store the vibrato value into r22
002bb2 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002bb3 9f67                      	mul r22, r23
002bb4 917f                      	pop r23
002bb5 916f                      	pop r22
                                 
002bb6 9416                      	lsr r1 //shift out the fractional bits
002bb7 9407                      	ror r0
002bb8 9416                      	lsr r1
002bb9 9407                      	ror r0
002bba 9416                      	lsr r1
002bbb 9407                      	ror r0
002bbc 9416                      	lsr r1
002bbd 9407                      	ror r0
                                 
002bbe 91a0 0a9c                 	lds r26, TCB1_CCMPL
002bc0 91b0 0a9d                 	lds r27, TCB1_CCMPH
002bc2 19a0                      	sub r26, r0
002bc3 09b1                      	sbc r27, r1
002bc4 93a0 0a9c                 	sts TCB1_CCMPL, r26
002bc6 93b0 0a9d                 	sts TCB1_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_7xy_routine:
002bc8 91a0 28ac                 	lds r26, pulse2_fx_7xy_speed
002bca 15a2                      	cp r26, zero
002bcb f0e9                      	breq sound_driver_channel1_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
002bcc 91b0 28ad                 	lds r27, pulse2_fx_7xy_depth
002bce 91c0 28ae                 	lds r28, pulse2_fx_7xy_phase
002bd0 0fca                      	add r28, r26 //increase the phase by the speed
002bd1 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002bd2 f008                      	brlo sound_driver_channel1_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
002bd3 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase:
002bd4 93c0 28ae                 	sts pulse2_fx_7xy_phase, r28 //store the new phase
002bd6 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
002bd7 ffc4                      	sbrs r28, 4
002bd8 c001                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_0
002bd9 c002                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel1_fx_7xy_routine_phase_0:
002bda 70cf                      	andi r28, 0x0F //mask for values 0-15
002bdb c003                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase_1:
002bdc 6fc0                      	ori r28, 0xF0
002bdd 95c0                      	com r28 //invert values 0-15
002bde c000                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_load:
002bdf 95b2                      	swap r27 //multiply depth by 16
002be0 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002be1 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002be2 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002be3 0fec                      	add ZL, r28 //offset the table by the depth+phase
002be4 1df2                      	adc ZH, zero
002be5 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002be6 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
002be7 93c0 28af                 	sts pulse2_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Axy_routine:
002be9 91b0 28b0                 	lds r27, pulse2_fx_Axy
002beb 15b2                      	cp r27, zero
002bec f0e9                      	breq sound_driver_channel1_fx_Qxy_routine //0 means that the effect is not in use
                                 	
002bed 91a0 280d                 	lds r26, pulse2_fractional_volume //load fractional volume representation of the channel
002bef 91c0 2808                 	lds r28, pulse2_param //load the integer volume representation of the channel
002bf1 2fda                      	mov r29, r26 //copy fractional volume into r29
002bf2 2fec                      	mov r30, r28 //copy the pulse2_param into r30
002bf3 95e2                      	swap r30
002bf4 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
002bf5 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
002bf6 17ed                      	cp r30, r29 //compare the fractional and integer volumes
002bf7 f009                      	breq sound_driver_channel1_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel1_fx_Axy_routine_reload:
002bf8 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate:
002bf9 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
002bfa c004                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_addition:
002bfb 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002bfc f428                      	brcc sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002bfd efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
002bfe c003                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_subtraction:
002bff 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002c00 f008                      	brcs sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002c01 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_store:
002c02 93a0 280d                 	sts pulse2_fractional_volume, r26 //store the new fractional volume
002c04 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
002c05 95a2                      	swap r26
002c06 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
002c07 2bca                      	or r28, r26 //store the new volume back into pulse2_param
002c08 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel1_fx_Qxy_routine:
002c0a 91e0 28b6                 	lds ZL, pulse2_fx_Qxy_target
002c0c 91f0 28b7                 	lds ZH, pulse2_fx_Qxy_target+1
002c0e 9630                      	adiw Z, 0
002c0f f119                      	breq sound_driver_channel1_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002c10 91a0 28ba                 	lds r26, pulse2_fx_Qxy_total_offset
002c12 91b0 28bb                 	lds r27, pulse2_fx_Qxy_total_offset+1
002c14 91c0 0a9c                 	lds r28, TCB1_CCMPL
002c16 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
002c18 1bec                      	sub ZL, r28 //calculate the difference to the target
002c19 0bfd                      	sbc ZH, r29
002c1a f408                      	brsh sound_driver_channel1_fx_Qxy_routine_end //if the target has been reached (or passed)
002c1b f068                      	brlo sound_driver_channel1_fx_Qxy_routine_add
                                 
                                 sound_driver_channel1_fx_Qxy_routine_end:
002c1c 9220 28ba                 	sts pulse2_fx_Qxy_total_offset, zero //turn off the effect
002c1e 9220 28bb                 	sts pulse2_fx_Qxy_total_offset+1, zero
002c20 9220 28b6                 	sts pulse2_fx_Qxy_target, zero
002c22 9220 28b7                 	sts pulse2_fx_Qxy_target+1, zero
002c24 91b0 28b5                 	lds r27, pulse2_fx_Qxy_target_note
002c26 93b0 280f                 	sts pulse2_note, r27 //replace the note with the final target note
002c28 c00a                      	rjmp sound_driver_channel1_fx_Rxy_routine
                                 
                                 sound_driver_channel1_fx_Qxy_routine_add:
002c29 91c0 28b8                 	lds r28, pulse2_fx_Qxy_speed
002c2b 91d0 28b9                 	lds r29, pulse2_fx_Qxy_speed+1
002c2d 0fac                      	add r26, r28 //increase the total offset by the speed
002c2e 1fbd                      	adc r27, r29
002c2f 93a0 28ba                 	sts pulse2_fx_Qxy_total_offset, r26 //store the total offset
002c31 93b0 28bb                 	sts pulse2_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Rxy_routine:
002c33 91e0 28bd                 	lds ZL, pulse2_fx_Rxy_target
002c35 91f0 28be                 	lds ZH, pulse2_fx_Rxy_target+1
002c37 9630                      	adiw Z, 0
002c38 f119                      	breq sound_driver_instrument_routine_channel2_volume //if the effect is not enabled, skip the routine
                                 
002c39 91a0 28c1                 	lds r26, pulse2_fx_Rxy_total_offset
002c3b 91b0 28c2                 	lds r27, pulse2_fx_Rxy_total_offset+1
002c3d 91c0 0a9c                 	lds r28, TCB1_CCMPL
002c3f 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
002c41 1bce                      	sub r28, ZL //calculate the difference to the target
002c42 0bdf                      	sbc r29, ZH
002c43 f408                      	brsh sound_driver_channel1_fx_Rxy_routine_end //if the target has been reached (or passed)
002c44 f068                      	brlo sound_driver_channel1_fx_Rxy_routine_add
                                 
                                 sound_driver_channel1_fx_Rxy_routine_end:
002c45 9220 28c1                 	sts pulse2_fx_Rxy_total_offset, zero //disable the effect
002c47 9220 28c2                 	sts pulse2_fx_Rxy_total_offset+1, zero
002c49 9220 28bd                 	sts pulse2_fx_Rxy_target, zero
002c4b 9220 28be                 	sts pulse2_fx_Rxy_target+1, zero
002c4d 91b0 28bc                 	lds r27, pulse2_fx_Rxy_target_note
002c4f 93b0 280f                 	sts pulse2_note, r27 //replace the note with the final target note
002c51 c00a                      	rjmp sound_driver_instrument_routine_channel2_volume
                                 
                                 sound_driver_channel1_fx_Rxy_routine_add:
002c52 91c0 28bf                 	lds r28, pulse2_fx_Rxy_speed
002c54 91d0 28c0                 	lds r29, pulse2_fx_Rxy_speed+1
002c56 0fac                      	add r26, r28 //increase the total offset by the speed
002c57 1fbd                      	adc r27, r29
002c58 93a0 28c1                 	sts pulse2_fx_Rxy_total_offset, r26 //store the total offset
002c5a 93b0 28c2                 	sts pulse2_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume:
002c5c 91e0 28cb                 	lds ZL, triangle_volume_macro
002c5e 91f0 28cc                 	lds ZH, triangle_volume_macro+1
002c60 9630                      	adiw Z, 0
002c61 f199                      	breq sound_driver_instrument_routine_channel2_volume_default //if no volume macro is in use, do nothing
002c62 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002c63 1fff                      	rol ZH
002c64 91a0 28cd                 	lds r26, triangle_volume_macro_offset
002c66 0fea                      	add ZL, r26
002c67 1df2                      	adc ZH, zero
                                 
002c68 91b0 28cf                 	lds r27, triangle_volume_macro_release
002c6a 17ba                      	cp r27, r26
002c6b f429                      	brne sound_driver_instrument_routine_channel2_volume_increment //if the current offset is not equal to the release index, increment the offset
002c6c 91a0 28ce                 	lds r26, triangle_volume_macro_loop
002c6e 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002c6f f010                      	brlo sound_driver_instrument_routine_channel2_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002c70 c003                      	rjmp sound_driver_instrument_routine_channel2_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_volume_increment:
002c71 95a3                      	inc r26 //increment the macro offset
002c72 93a0 28cd                 	sts triangle_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_volume_read:
002c74 91b4                      	lpm r27, Z //load volume data into r27
002c75 3fbf                      	cpi r27, 0xFF //check for macro end flag
002c76 f469                      	brne sound_driver_instrument_routine_channel2_volume_process //if the data was not the macro end flag
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_release:
002c77 91b0 28cf                 	lds r27, triangle_volume_macro_release
002c79 3fbf                      	cpi r27, 0xFF
002c7a f429                      	brne sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_loop:
002c7b 91b0 28ce                 	lds r27, triangle_volume_macro_loop //load the loop index
002c7d 93b0 28cd                 	sts triangle_volume_macro_offset, r27 //store the loop index into the offset
002c7f cfdc                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index:
002c80 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002c81 93a0 28cd                 	sts triangle_volume_macro_offset, r26
002c83 cfd8                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_process:
002c84 15b2                      	cp r27, zero
002c85 f041                      	breq sound_driver_instrument_routine_channel2_volume_process_disable
                                 sound_driver_instrument_routine_channel2_volume_process_enable:
002c86 91b0 0aa5                 	lds r27, TCB2_INTCTRL
002c88 30b1                      	cpi r27, TCB_CAPT_bm
002c89 f459                      	brne sound_driver_instrument_routine_channel2_volume_default //if the channel has already been muted, don't enable it again
002c8a e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
002c8b 93b0 0aa5                 	sts TCB2_INTCTRL, r27
002c8d c007                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 sound_driver_instrument_routine_channel2_volume_process_disable:
002c8e 9220 0aa5                 	sts TCB2_INTCTRL, zero
002c90 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
002c92 9220 0aad                 	sts TCB2_CCMPH, zero
002c94 c000                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_volume_default:
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002c95 91e0 28d0                 	lds ZL, triangle_arpeggio_macro
002c97 91f0 28d1                 	lds ZH, triangle_arpeggio_macro+1
002c99 9630                      	adiw Z, 0
002c9a f1d9                      	breq sound_driver_instrument_routine_channel2_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002c9b 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002c9c 1fff                      	rol ZH
002c9d 91a0 28d2                 	lds r26, triangle_arpeggio_macro_offset
002c9f 0fea                      	add ZL, r26
002ca0 1df2                      	adc ZH, zero
                                 
002ca1 91b0 28d4                 	lds r27, triangle_arpeggio_macro_release
002ca3 17ba                      	cp r27, r26
002ca4 f429                      	brne sound_driver_instrument_routine_channel2_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002ca5 91a0 28d3                 	lds r26, triangle_arpeggio_macro_loop
002ca7 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002ca8 f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002ca9 c003                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_increment:
002caa 95a3                      	inc r26 //increment the macro offset
002cab 93a0 28d2                 	sts triangle_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_read:
002cad 91b4                      	lpm r27, Z //load arpeggio data into r27
002cae 38b0                      	cpi r27, 0x80 //check for macro end flag
002caf f009                      	breq sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag
002cb0 c041                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_check_mode:
002cb1 50a1                      	subi r26, 1 //keep the offset at the end flag
002cb2 93a0 28d2                 	sts triangle_arpeggio_macro_offset, r26
002cb4 91b0 28d5                 	lds r27, triangle_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002cb6 30b1                      	cpi r27, 0x01
002cb7 f048                      	brlo sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_release:
002cb8 91b0 28d4                 	lds r27, triangle_arpeggio_macro_release
002cba 3fbf                      	cpi r27, 0xFF
002cbb f4d1                      	brne sound_driver_instrument_routine_channel2_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_loop:
002cbc 91b0 28d3                 	lds r27, triangle_arpeggio_macro_loop
002cbe 3fbf                      	cpi r27, 0xFF
002cbf f499                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002cc0 c015                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute:
002cc1 91b0 28d4                 	lds r27, triangle_arpeggio_macro_release
002cc3 3fbf                      	cpi r27, 0xFF
002cc4 f421                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_check_loop:
002cc5 91b0 28d3                 	lds r27, triangle_arpeggio_macro_loop //load the loop index
002cc7 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002cc8 f451                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop:
002cc9 91c0 28e8                 	lds r28, triangle_fx_0xy_sequence //check for 0xy effect
002ccb 91d0 28e9                 	lds r29, triangle_fx_0xy_sequence+1
002ccd 9620                      	adiw r29:r28, 0
002cce f469                      	brne sound_driver_instrument_routine_channel2_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002ccf 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002cd0 93a0 28d2                 	sts triangle_arpeggio_macro_offset, r26 //store the last valid index into the offset
002cd2 cfc2                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload:
002cd3 93b0 28d2                 	sts triangle_arpeggio_macro_offset, r27 //store the loop index into the offset
002cd5 cfbf                      	rjmp sound_driver_instrument_routine_channel2_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_default:
002cd6 91c0 28e8                 	lds r28, triangle_fx_0xy_sequence //load 0xy effect
002cd8 91d0 28e9                 	lds r29, triangle_fx_0xy_sequence+1
002cda 9620                      	adiw r29:r28, 0 //check for 0xy effect
002cdb f099                      	breq sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel2_arpeggio_default_0xy:
002cdc 95d6                      	lsr r29
002cdd 95c7                      	ror r28
002cde 95d7                      	ror r29
002cdf 95c7                      	ror r28
002ce0 95d7                      	ror r29
002ce1 95c7                      	ror r28
002ce2 95d7                      	ror r29
002ce3 95c7                      	ror r28
002ce4 95d7                      	ror r29
002ce5 95d2                      	swap r29
                                 
002ce6 93c0 28e8                 	sts triangle_fx_0xy_sequence, r28 //store the rolled sequence
002ce8 93d0 28e9                 	sts triangle_fx_0xy_sequence+1, r29
002cea 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002ceb 91a0 2812                 	lds r26, triangle_note //load the current note index
002ced 0fac                      	add r26, r28 //add the note offset
002cee c02e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002cef 91a0 2812                 	lds r26, triangle_note //load the current note index
002cf1 c02b                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process:
002cf2 9220 28d6                 	sts triangle_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002cf4 9220 28d7                 	sts triangle_total_pitch_offset+1, zero
002cf6 9220 28dd                 	sts triangle_total_hi_pitch_offset, zero
002cf8 91a0 28d5                 	lds r26, triangle_arpeggio_macro_mode
002cfa 30a1                      	cpi r26, 0x01 //absolute mode
002cfb f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_absolute
002cfc f069                      	breq sound_driver_instrument_routine_channel2_arpeggio_process_fixed
002cfd c00e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute:
002cfe 91a0 2812                 	lds r26, triangle_note //load the current note index
002d00 0fab                      	add r26, r27 //offset the note with the arpeggio data
002d01 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002d02 c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_add:
002d03 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002d04 f0c0                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
002d05 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002d06 c016                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract:
002d07 fda7                      	sbrc r26, 7 //check if result is negative
002d08 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002d09 c013                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_fixed:
002d0a 2fab                      	mov r26, r27 //move the arpeggio data into r26
002d0b c011                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative:
002d0c 91a0 2812                 	lds r26, triangle_note //load the current note index
002d0e 0fab                      	add r26, r27 //offset the note with the arpeggio data
002d0f fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002d10 c008                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_add:
002d11 93a0 2812                 	sts triangle_note, r26 //NOTE: relative mode modifies the original note index
002d13 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002d14 f040                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
002d15 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002d16 93a0 2812                 	sts triangle_note, r26
002d18 c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract:
002d19 fda7                      	sbrc r26, 7 //check if result is negative
002d1a e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002d1b 93a0 2812                 	sts triangle_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_load:
002d1d e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
002d1e e0f0                      	ldi ZH, HIGH(note_table << 1)
002d1f 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002d20 0fea                      	add ZL, r26 //add offset
002d21 1df2                      	adc ZH, zero
002d22 91a5                      	lpm r26, Z+ //load bytes
002d23 91b4                      	lpm r27, Z
002d24 93a0 0aac                 	sts TCB2_CCMPL, r26 //load the LOW bits for timer
002d26 93b0 0aad                 	sts TCB2_CCMPH, r27 //load the HIGH bits for timer
002d28 93a0 28f4                 	sts triangle_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002d2a 93b0 28f5                 	sts triangle_fx_3xx_target+1, r27
002d2c c000                      	rjmp sound_driver_instrument_routine_channel2_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch:
002d2d 91e0 28d8                 	lds ZL, triangle_pitch_macro
002d2f 91f0 28d9                 	lds ZH, triangle_pitch_macro+1
002d31 9630                      	adiw Z, 0
002d32 f409                      	brne sound_driver_instrument_routine_channel2_pitch_continue
002d33 c023                      	rjmp sound_driver_instrument_routine_channel2_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel2_pitch_continue:
002d34 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002d35 1fff                      	rol ZH
002d36 91a0 28da                 	lds r26, triangle_pitch_macro_offset
002d38 0fea                      	add ZL, r26
002d39 1df2                      	adc ZH, zero
                                 
002d3a 91b0 28dc                 	lds r27, triangle_pitch_macro_release
002d3c 17ba                      	cp r27, r26
002d3d f429                      	brne sound_driver_instrument_routine_channel2_pitch_increment //if the current offset is not equal to the release index, increment the offset
002d3e 91a0 28db                 	lds r26, triangle_pitch_macro_loop
002d40 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002d41 f010                      	brlo sound_driver_instrument_routine_channel2_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002d42 c003                      	rjmp sound_driver_instrument_routine_channel2_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_pitch_increment:
002d43 95a3                      	inc r26 //increment the macro offset
002d44 93a0 28da                 	sts triangle_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_pitch_read:
002d46 91b4                      	lpm r27, Z //load pitch data into r27
002d47 38b0                      	cpi r27, 0x80 //check for macro end flag
002d48 f479                      	brne sound_driver_instrument_routine_channel2_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_release:
002d49 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002d4a 93a0 28da                 	sts triangle_pitch_macro_offset, r26
002d4c 91b0 28dc                 	lds r27, triangle_pitch_macro_release
002d4e 3fbf                      	cpi r27, 0xFF
002d4f f439                      	brne sound_driver_instrument_routine_channel2_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_loop:
002d50 91b0 28db                 	lds r27, triangle_pitch_macro_loop //load the loop index
002d52 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002d53 f019                      	breq sound_driver_instrument_routine_channel2_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002d54 93b0 28da                 	sts triangle_pitch_macro_offset, r27 //store the loop index into the offset
002d56 cfd6                      	rjmp sound_driver_instrument_routine_channel2_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_default:
002d57 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel2_pitch_calculate:
002d58 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002d59 937f                      	push r23
002d5a 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
002d5b eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002d5c 0367                      	mulsu r22, r23
002d5d 917f                      	pop r23
002d5e 916f                      	pop r22
                                 
002d5f 9416                      	lsr r1 //shift out the fractional bits
002d60 9407                      	ror r0
002d61 9416                      	lsr r1
002d62 9407                      	ror r0
002d63 9416                      	lsr r1
002d64 9407                      	ror r0
002d65 9416                      	lsr r1
002d66 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_check_negative:
002d67 fe13                      	sbrs r1, 3 //check if result was a negative number
002d68 c007                      	rjmp sound_driver_instrument_routine_channel2_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_negative:
002d69 efc0                      	ldi r28, 0xF0
002d6a 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_check_divisible_8:
002d6b 70b7                      	andi r27, 0b00000111
002d6c f019                      	breq sound_driver_instrument_routine_channel2_pitch_calculate_offset
                                 
002d6d e0b1                      	ldi r27, 0x01
002d6e 0e0b                      	add r0, r27
002d6f 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_offset:
002d70 91a0 28d6                 	lds r26, triangle_total_pitch_offset
002d72 91b0 28d7                 	lds r27, triangle_total_pitch_offset+1
002d74 0e0a                      	add r0, r26
002d75 1e1b                      	adc r1, r27
002d76 9200 28d6                 	sts triangle_total_pitch_offset, r0
002d78 9210 28d7                 	sts triangle_total_pitch_offset+1, r1
002d7a 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
002d7c 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
002d7e 0da0                      	add r26, r0 //offset the timer values
002d7f 1db1                      	adc r27, r1
                                 	
002d80 91c0 28ec                 	lds r28, triangle_fx_1xx_total
002d82 91d0 28ed                 	lds r29, triangle_fx_1xx_total+1
002d84 1bac                      	sub r26, r28
002d85 0bbd                      	sbc r27, r29
002d86 91c0 28f0                 	lds r28, triangle_fx_2xx_total
002d88 91d0 28f1                 	lds r29, triangle_fx_2xx_total+1
002d8a 0fac                      	add r26, r28
002d8b 1fbd                      	adc r27, r29
002d8c 91c0 28ff                 	lds r28, triangle_fx_Pxx_total
002d8e 91d0 2900                 	lds r29, triangle_fx_Pxx_total+1
002d90 0fac                      	add r26, r28
002d91 1fbd                      	adc r27, r29
002d92 91c0 2906                 	lds r28, triangle_fx_Qxy_total_offset
002d94 91d0 2907                 	lds r29, triangle_fx_Qxy_total_offset+1
002d96 1bac                      	sub r26, r28
002d97 0bbd                      	sbc r27, r29
002d98 91c0 290d                 	lds r28, triangle_fx_Rxy_total_offset
002d9a 91d0 290e                 	lds r29, triangle_fx_Rxy_total_offset+1
002d9c 0fac                      	add r26, r28
002d9d 1fbd                      	adc r27, r29
                                 
002d9e e5c9                      	ldi r28, 0x59
002d9f e0d0                      	ldi r29, 0x00
002da0 17ac                      	cp r26, r28
002da1 07bd                      	cpc r27, r29
002da2 f030                      	brlo sound_driver_instrument_routine_channel2_pitch_min
                                 
002da3 e5ca                      	ldi r28, 0x5A
002da4 e5d9                      	ldi r29, 0x59
002da5 17ac                      	cp r26, r28
002da6 07bd                      	cpc r27, r29
002da7 f420                      	brsh sound_driver_instrument_routine_channel2_pitch_max
002da8 c006                      	rjmp sound_driver_instrument_routine_channel2_pitch_store
                                 
                                 sound_driver_instrument_routine_channel2_pitch_min:
002da9 e5c9                      	ldi r28, 0x59
002daa e0d0                      	ldi r29, 0x00
002dab c003                      	rjmp sound_driver_instrument_routine_channel2_pitch_store
                                 
                                 sound_driver_instrument_routine_channel2_pitch_max:
002dac e5c9                      	ldi r28, 0x59
002dad e5d9                      	ldi r29, 0x59
002dae c000                      	rjmp sound_driver_instrument_routine_channel2_pitch_store
                                 
                                 sound_driver_instrument_routine_channel2_pitch_store:
002daf 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
002db1 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel2_hi_pitch:
002db3 91e0 28de                 	lds ZL, triangle_hi_pitch_macro
002db5 91f0 28df                 	lds ZH, triangle_hi_pitch_macro+1
002db7 9630                      	adiw Z, 0
002db8 f409                      	brne sound_driver_instrument_routine_channel2_hi_pitch_continue
002db9 c03c                      	rjmp sound_driver_instrument_routine_channel2_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel2_hi_pitch_continue:
002dba 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002dbb 1fff                      	rol ZH
002dbc 91a0 28e0                 	lds r26, triangle_hi_pitch_macro_offset
002dbe 0fea                      	add ZL, r26
002dbf 1df2                      	adc ZH, zero
                                 
002dc0 91b0 28e2                 	lds r27, triangle_hi_pitch_macro_release
002dc2 17ba                      	cp r27, r26
002dc3 f429                      	brne sound_driver_instrument_routine_channel2_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002dc4 91a0 28e1                 	lds r26, triangle_hi_pitch_macro_loop
002dc6 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002dc7 f010                      	brlo sound_driver_instrument_routine_channel2_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002dc8 c003                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_increment:
002dc9 95a3                      	inc r26 //increment the macro offset
002dca 93a0 28e0                 	sts triangle_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_hi_pitch_read:
002dcc 91b4                      	lpm r27, Z //load hi pitch data into r27
002dcd 38b0                      	cpi r27, 0x80 //check for macro end flag
002dce f489                      	brne sound_driver_instrument_routine_channel2_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_release:
002dcf 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002dd0 93a0 28e0                 	sts triangle_hi_pitch_macro_offset, r26
002dd2 91b0 28e2                 	lds r27, triangle_hi_pitch_macro_release
002dd4 3fbf                      	cpi r27, 0xFF
002dd5 f439                      	brne sound_driver_instrument_routine_channel2_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_loop:
002dd6 91b0 28e1                 	lds r27, triangle_hi_pitch_macro_loop //load the loop index
002dd8 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002dd9 f019                      	breq sound_driver_instrument_routine_channel2_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002dda 93b0 28e0                 	sts triangle_hi_pitch_macro_offset, r27 //store the loop index into the offset
002ddc cfd6                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_default:
002ddd 91b0 28dd                 	lds r27, triangle_total_hi_pitch_offset
002ddf c005                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate:
002de0 91a0 28dd                 	lds r26, triangle_total_hi_pitch_offset //load the total hi pitch offset to change
002de2 0fba                      	add r27, r26
002de3 93b0 28dd                 	sts triangle_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply:
002de5 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002de6 937f                      	push r23
002de7 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002de8 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002de9 0367                      	mulsu r22, r23
002dea 917f                      	pop r23
002deb 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_offset:
002dec 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
002dee 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
002df0 0da0                      	add r26, r0 //offset the timer values
002df1 1db1                      	adc r27, r1
002df2 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
002df4 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: The triangle channel does not have a duty cycle
                                 sound_driver_instrument_routine_channel2_duty:
                                 
                                 
                                 
                                 sound_driver_channel2_fx_routines:
                                 sound_driver_channel2_fx_1xx_routine:
002df6 91e0 28ea                 	lds ZL, triangle_fx_1xx
002df8 91f0 28eb                 	lds ZH, triangle_fx_1xx+1
002dfa 9630                      	adiw Z, 0
002dfb f051                      	breq sound_driver_channel2_fx_2xx_routine
                                 
002dfc 91a0 28ec                 	lds r26, triangle_fx_1xx_total //load the rate to change the pitch by
002dfe 91b0 28ed                 	lds r27, triangle_fx_1xx_total+1
002e00 0fae                      	add r26, ZL //increase the total offset by the rate
002e01 1fbf                      	adc r27, ZH
002e02 93a0 28ec                 	sts triangle_fx_1xx_total, r26
002e04 93b0 28ed                 	sts triangle_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_2xx_routine:
002e06 91e0 28ee                 	lds ZL, triangle_fx_2xx
002e08 91f0 28ef                 	lds ZH, triangle_fx_2xx+1
002e0a 9630                      	adiw Z, 0
002e0b f051                      	breq sound_driver_channel2_fx_3xx_routine
                                 
002e0c 91a0 28f0                 	lds r26, triangle_fx_2xx_total //load the rate to change the pitch by
002e0e 91b0 28f1                 	lds r27, triangle_fx_2xx_total+1
002e10 0fae                      	add r26, ZL //increase the total offset by the rate
002e11 1fbf                      	adc r27, ZH
002e12 93a0 28f0                 	sts triangle_fx_2xx_total, r26
002e14 93b0 28f1                 	sts triangle_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_3xx_routine:
002e16 91e0 28f6                 	lds ZL, triangle_fx_3xx_speed
002e18 91f0 28f7                 	lds ZH, triangle_fx_3xx_speed+1
002e1a 9630                      	adiw Z, 0
002e1b f409                      	brne sound_driver_channel2_fx_3xx_routine_check_start
002e1c c048                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_check_start:
002e1d 91a0 28f2                 	lds r26, triangle_fx_3xx_start
002e1f 91b0 28f3                 	lds r27, triangle_fx_3xx_start+1
002e21 9610                      	adiw r26:r27, 0
002e22 f409                      	brne sound_driver_channel2_fx_3xx_routine_main
002e23 c041                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_main:
002e24 91c0 28f4                 	lds r28, triangle_fx_3xx_target
002e26 91d0 28f5                 	lds r29, triangle_fx_3xx_target+1
                                 
002e28 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
002e29 07bd                      	cpc r27, r29
002e2a f011                      	breq sound_driver_channel2_fx_3xx_routine_disable
002e2b f030                      	brlo sound_driver_channel2_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002e2c c01f                      	rjmp sound_driver_channel2_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel2_fx_3xx_routine_disable:
002e2d 9220 28f2                 	sts triangle_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002e2f 9220 28f3                 	sts triangle_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002e31 c033                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_subtract:
002e32 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002e33 0bdb                      	sbc r29, r27
002e34 91a0 28f8                 	lds r26, triangle_fx_3xx_total_offset
002e36 91b0 28f9                 	lds r27, triangle_fx_3xx_total_offset+1
                                 
002e38 0fae                      	add r26, ZL //add the speed to the total offset
002e39 1fbf                      	adc r27, ZH
002e3a 1bca                      	sub r28, r26 //invert the total difference with the total offset
002e3b 0bdb                      	sbc r29, r27
002e3c f380                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002e3d 93a0 28f8                 	sts triangle_fx_3xx_total_offset, r26 //store the new total offset
002e3f 93b0 28f9                 	sts triangle_fx_3xx_total_offset+1, r27
                                 
002e41 91a0 0aac                 	lds r26, TCB2_CCMPL //load the current timer period
002e43 91b0 0aad                 	lds r27, TCB2_CCMPH
002e45 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002e46 0bbd                      	sbc r27, r29
002e47 93a0 0aac                 	sts TCB2_CCMPL, r26
002e49 93b0 0aad                 	sts TCB2_CCMPH, r27
002e4b c019                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_add:
002e4c 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002e4d 0bbd                      	sbc r27, r29
002e4e 91c0 28f8                 	lds r28, triangle_fx_3xx_total_offset
002e50 91d0 28f9                 	lds r29, triangle_fx_3xx_total_offset+1
                                 
002e52 0fce                      	add r28, ZL //add the speed to the total offset
002e53 1fdf                      	adc r29, ZH
002e54 1bac                      	sub r26, r28 //invert the total difference with the total offset
002e55 0bbd                      	sbc r27, r29
002e56 f2b0                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002e57 93c0 28f8                 	sts triangle_fx_3xx_total_offset, r28 //store the new total offset
002e59 93d0 28f9                 	sts triangle_fx_3xx_total_offset+1, r29
                                 
002e5b 91c0 0aac                 	lds r28, TCB2_CCMPL //load the current timer period
002e5d 91d0 0aad                 	lds r29, TCB2_CCMPH
002e5f 0fca                      	add r28, r26 //offset the current timer period with the total offset
002e60 1fdb                      	adc r29, r27
002e61 93c0 0aac                 	sts TCB2_CCMPL, r28
002e63 93d0 0aad                 	sts TCB2_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel2_fx_4xy_routine:
002e65 91a0 28fa                 	lds r26, triangle_fx_4xy_speed
002e67 15a2                      	cp r26, zero
002e68 f409                      	brne sound_driver_channel2_fx_4xy_routine_continue
002e69 c05c                      	rjmp sound_driver_channel2_fx_Qxy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel2_fx_4xy_routine_continue:
002e6a 91b0 28fb                 	lds r27, triangle_fx_4xy_depth
002e6c 91c0 28fc                 	lds r28, triangle_fx_4xy_phase
002e6e 0fca                      	add r28, r26 //increase the phase by the speed
002e6f 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002e70 f008                      	brlo sound_driver_channel2_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002e71 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase:
002e72 93c0 28fc                 	sts triangle_fx_4xy_phase, r28 //store the new phase
002e74 31c0                      	cpi r28, 16
002e75 f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_0
002e76 32c0                      	cpi r28, 32
002e77 f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_1
002e78 33c0                      	cpi r28, 48
002e79 f030                      	brlo sound_driver_channel2_fx_4xy_routine_phase_2
002e7a c007                      	rjmp sound_driver_channel2_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_0:
002e7b 70cf                      	andi r28, 0x0F //mask for values 0-15
002e7c c029                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_1:
002e7d 6fc0                      	ori r28, 0xF0
002e7e 95c0                      	com r28 //invert values 0-15
002e7f c026                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_2:
002e80 70cf                      	andi r28, 0x0F //mask for values 0-15
002e81 c003                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_3:
002e82 6fc0                      	ori r28, 0xF0
002e83 95c0                      	com r28 //invert values 0-15
002e84 c000                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_add:
002e85 95b2                      	swap r27 //multiply depth by 16
002e86 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002e87 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002e88 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002e89 0fec                      	add ZL, r28 //offset the table by the depth+phase
002e8a 1df2                      	adc ZH, zero
002e8b 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002e8c 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002e8d 937f                      	push r23
002e8e 2f6c                      	mov r22, r28 //store the vibrato value into r22
002e8f eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002e90 9f67                      	mul r22, r23
002e91 917f                      	pop r23
002e92 916f                      	pop r22
                                 
002e93 9416                      	lsr r1 //shift out the fractional bits
002e94 9407                      	ror r0
002e95 9416                      	lsr r1
002e96 9407                      	ror r0
002e97 9416                      	lsr r1
002e98 9407                      	ror r0
002e99 9416                      	lsr r1
002e9a 9407                      	ror r0
                                 	
002e9b 91a0 0aac                 	lds r26, TCB2_CCMPL
002e9d 91b0 0aad                 	lds r27, TCB2_CCMPH
002e9f 0da0                      	add r26, r0
002ea0 1db1                      	adc r27, r1
002ea1 93a0 0aac                 	sts TCB2_CCMPL, r26
002ea3 93b0 0aad                 	sts TCB2_CCMPH, r27
002ea5 c020                      	rjmp sound_driver_channel2_fx_Qxy_routine
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_subtract:
002ea6 95b2                      	swap r27 //multiply depth by 16
002ea7 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002ea8 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002ea9 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002eaa 0fec                      	add ZL, r28 //offset the table by the depth+phase
002eab 1df2                      	adc ZH, zero
002eac 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002ead 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002eae 937f                      	push r23
002eaf 2f6c                      	mov r22, r28 //store the vibrato value into r22
002eb0 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002eb1 9f67                      	mul r22, r23
002eb2 917f                      	pop r23
002eb3 916f                      	pop r22
                                 
002eb4 9416                      	lsr r1 //shift out the fractional bits
002eb5 9407                      	ror r0
002eb6 9416                      	lsr r1
002eb7 9407                      	ror r0
002eb8 9416                      	lsr r1
002eb9 9407                      	ror r0
002eba 9416                      	lsr r1
002ebb 9407                      	ror r0
                                 
002ebc 91a0 0aac                 	lds r26, TCB2_CCMPL
002ebe 91b0 0aad                 	lds r27, TCB2_CCMPH
002ec0 19a0                      	sub r26, r0
002ec1 09b1                      	sbc r27, r1
002ec2 93a0 0aac                 	sts TCB2_CCMPL, r26
002ec4 93b0 0aad                 	sts TCB2_CCMPH, r27
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel2_fx_Qxy_routine:
002ec6 91e0 2902                 	lds ZL, triangle_fx_Qxy_target
002ec8 91f0 2903                 	lds ZH, triangle_fx_Qxy_target+1
002eca 9630                      	adiw Z, 0
002ecb f119                      	breq sound_driver_channel2_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002ecc 91a0 2906                 	lds r26, triangle_fx_Qxy_total_offset
002ece 91b0 2907                 	lds r27, triangle_fx_Qxy_total_offset+1
002ed0 91c0 0aac                 	lds r28, TCB2_CCMPL
002ed2 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
002ed4 1bec                      	sub ZL, r28 //calculate the difference to the target
002ed5 0bfd                      	sbc ZH, r29
002ed6 f408                      	brsh sound_driver_channel2_fx_Qxy_routine_end //if the target has been reached (or passed)
002ed7 f068                      	brlo sound_driver_channel2_fx_Qxy_routine_add
                                 
                                 sound_driver_channel2_fx_Qxy_routine_end:
002ed8 9220 2906                 	sts triangle_fx_Qxy_total_offset, zero //turn off the effect
002eda 9220 2907                 	sts triangle_fx_Qxy_total_offset+1, zero
002edc 9220 2902                 	sts triangle_fx_Qxy_target, zero
002ede 9220 2903                 	sts triangle_fx_Qxy_target+1, zero
002ee0 91b0 2901                 	lds r27, triangle_fx_Qxy_target_note
002ee2 93b0 2812                 	sts triangle_note, r27 //replace the note with the final target note
002ee4 c00a                      	rjmp sound_driver_channel2_fx_Rxy_routine
                                 
                                 sound_driver_channel2_fx_Qxy_routine_add:
002ee5 91c0 2904                 	lds r28, triangle_fx_Qxy_speed
002ee7 91d0 2905                 	lds r29, triangle_fx_Qxy_speed+1
002ee9 0fac                      	add r26, r28 //increase the total offset by the speed
002eea 1fbd                      	adc r27, r29
002eeb 93a0 2906                 	sts triangle_fx_Qxy_total_offset, r26 //store the total offset
002eed 93b0 2907                 	sts triangle_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_Rxy_routine:
002eef 91e0 2909                 	lds ZL, triangle_fx_Rxy_target
002ef1 91f0 290a                 	lds ZH, triangle_fx_Rxy_target+1
002ef3 9630                      	adiw Z, 0
002ef4 f119                      	breq sound_driver_instrument_routine_channel3_volume //if the effect is not enabled, skip the routine
                                 
002ef5 91a0 290d                 	lds r26, triangle_fx_Rxy_total_offset
002ef7 91b0 290e                 	lds r27, triangle_fx_Rxy_total_offset+1
002ef9 91c0 0aac                 	lds r28, TCB2_CCMPL
002efb 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
002efd 1bce                      	sub r28, ZL //calculate the difference to the target
002efe 0bdf                      	sbc r29, ZH
002eff f408                      	brsh sound_driver_channel2_fx_Rxy_routine_end //if the target has been reached (or passed)
002f00 f068                      	brlo sound_driver_channel2_fx_Rxy_routine_add
                                 
                                 sound_driver_channel2_fx_Rxy_routine_end:
002f01 9220 290d                 	sts triangle_fx_Rxy_total_offset, zero //disable the effect
002f03 9220 290e                 	sts triangle_fx_Rxy_total_offset+1, zero
002f05 9220 2909                 	sts triangle_fx_Rxy_target, zero
002f07 9220 290a                 	sts triangle_fx_Rxy_target+1, zero
002f09 91b0 2908                 	lds r27, triangle_fx_Rxy_target_note
002f0b 93b0 2812                 	sts triangle_note, r27 //replace the note with the final target note
002f0d c00a                      	rjmp sound_driver_instrument_routine_channel3_volume
                                 
                                 sound_driver_channel2_fx_Rxy_routine_add:
002f0e 91c0 290b                 	lds r28, triangle_fx_Rxy_speed
002f10 91d0 290c                 	lds r29, triangle_fx_Rxy_speed+1
002f12 0fac                      	add r26, r28 //increase the total offset by the speed
002f13 1fbd                      	adc r27, r29
002f14 93a0 290d                 	sts triangle_fx_Rxy_total_offset, r26 //store the total offset
002f16 93b0 290e                 	sts triangle_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume:
002f18 91e0 2917                 	lds ZL, noise_volume_macro
002f1a 91f0 2918                 	lds ZH, noise_volume_macro+1
002f1c 9630                      	adiw Z, 0
002f1d f1a1                      	breq sound_driver_instrument_routine_channel3_volume_default //if no volume macro is in use, use default multiplier of F
002f1e 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002f1f 1fff                      	rol ZH
002f20 91a0 2919                 	lds r26, noise_volume_macro_offset
002f22 0fea                      	add ZL, r26
002f23 1df2                      	adc ZH, zero
                                 
002f24 91b0 291b                 	lds r27, noise_volume_macro_release
002f26 17ba                      	cp r27, r26
002f27 f429                      	brne sound_driver_instrument_routine_channel3_volume_increment //if the current offset is not equal to the release index, increment the offset
002f28 91a0 291a                 	lds r26, noise_volume_macro_loop
002f2a 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002f2b f010                      	brlo sound_driver_instrument_routine_channel3_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002f2c c003                      	rjmp sound_driver_instrument_routine_channel3_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_volume_increment:
002f2d 95a3                      	inc r26 //increment the macro offset
002f2e 93a0 2919                 	sts noise_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_volume_read:
002f30 91b4                      	lpm r27, Z //load volume data into r27
002f31 3fbf                      	cpi r27, 0xFF //check for macro end flag
002f32 f469                      	brne sound_driver_instrument_routine_channel3_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_check_release:
002f33 91b0 291b                 	lds r27, noise_volume_macro_release
002f35 3fbf                      	cpi r27, 0xFF
002f36 f429                      	brne sound_driver_instrument_routine_channel3_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_check_loop:
002f37 91b0 291a                 	lds r27, noise_volume_macro_loop //load the loop index
002f39 93b0 2919                 	sts noise_volume_macro_offset, r27 //store the loop index into the offset
002f3b cfdc                      	rjmp sound_driver_instrument_routine_channel3_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_last_index:
002f3c 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002f3d 93a0 2919                 	sts noise_volume_macro_offset, r26
002f3f cfd8                      	rjmp sound_driver_instrument_routine_channel3_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume_calculate:
002f40 eaea                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
002f41 e6f3                      	ldi ZH, HIGH(volumes << 1)
002f42 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
002f43 0feb                      	add ZL, r27 //add offset to the table
002f44 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel3_volume_load:
002f45 91b0 2813                 	lds r27, noise_param //load main volume
002f47 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002f48 91a0 2941                 	lds r26, noise_fx_7xy_value
002f4a 30a0                      	cpi r26, 0x00
002f4b f481                      	brne sound_driver_instrument_routine_channel3_volume_load_7xy
                                 
002f4c 0feb                      	add ZL, r27 //offset the volume table by the main volume
002f4d 1df2                      	adc ZH, zero
002f4e 91b4                      	lpm r27, Z
002f4f 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002f51 c023                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_default:
002f52 91b0 2813                 	lds r27, noise_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
002f54 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002f55 91a0 2941                 	lds r26, noise_fx_7xy_value
002f57 30a0                      	cpi r26, 0x00
002f58 f499                      	brne sound_driver_instrument_routine_channel3_volume_default_7xy
002f59 93b0 2816                 	sts noise_output_volume, r27
002f5b c019                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_load_7xy:
002f5c 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002f5d f038                      	brcs sound_driver_instrument_routine_channel3_volume_load_7xy_overflow
002f5e f031                      	breq sound_driver_instrument_routine_channel3_volume_load_7xy_overflow
                                 
002f5f 0feb                      	add ZL, r27 //offset the volume table by the main volume
002f60 1df2                      	adc ZH, zero
002f61 91b4                      	lpm r27, Z
002f62 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002f64 c010                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_load_7xy_overflow:
002f65 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002f66 0feb                      	add ZL, r27 //offset the volume table by the main volume
002f67 1df2                      	adc ZH, zero
002f68 91b4                      	lpm r27, Z
002f69 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002f6b c009                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_default_7xy:
002f6c 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002f6d f020                      	brcs sound_driver_instrument_routine_channel3_volume_default_7xy_overflow
002f6e f019                      	breq sound_driver_instrument_routine_channel3_volume_default_7xy_overflow
002f6f 93b0 2816                 	sts noise_output_volume, r27
002f71 c003                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel3_volume_default_7xy_overflow:
002f72 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002f73 93b0 2816                 	sts noise_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002f75 91e0 291c                 	lds ZL, noise_arpeggio_macro
002f77 91f0 291d                 	lds ZH, noise_arpeggio_macro+1
002f79 9630                      	adiw Z, 0
002f7a f1d9                      	breq sound_driver_instrument_routine_channel3_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002f7b 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002f7c 1fff                      	rol ZH
002f7d 91a0 291e                 	lds r26, noise_arpeggio_macro_offset
002f7f 0fea                      	add ZL, r26
002f80 1df2                      	adc ZH, zero
                                 
002f81 91b0 2920                 	lds r27, noise_arpeggio_macro_release
002f83 17ba                      	cp r27, r26
002f84 f429                      	brne sound_driver_instrument_routine_channel3_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002f85 91a0 291f                 	lds r26, noise_arpeggio_macro_loop
002f87 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002f88 f010                      	brlo sound_driver_instrument_routine_channel3_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002f89 c003                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_increment:
002f8a 95a3                      	inc r26 //increment the macro offset
002f8b 93a0 291e                 	sts noise_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_arpeggio_read:
002f8d 91b4                      	lpm r27, Z //load arpeggio data into r27
002f8e 38b0                      	cpi r27, 0x80 //check for macro end flag
002f8f f009                      	breq sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag
002f90 c041                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_check_mode:
002f91 50a1                      	subi r26, 1 //keep the offset at the end flag
002f92 93a0 291e                 	sts noise_arpeggio_macro_offset, r26
002f94 91b0 2921                 	lds r27, noise_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002f96 30b1                      	cpi r27, 0x01
002f97 f048                      	brlo sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_fixed_relative_check_release:
002f98 91b0 2920                 	lds r27, noise_arpeggio_macro_release
002f9a 3fbf                      	cpi r27, 0xFF
002f9b f4d1                      	brne sound_driver_instrument_routine_channel3_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_fixed_relative_check_loop:
002f9c 91b0 291f                 	lds r27, noise_arpeggio_macro_loop
002f9e 3fbf                      	cpi r27, 0xFF
002f9f f499                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002fa0 c015                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute:
002fa1 91b0 2920                 	lds r27, noise_arpeggio_macro_release
002fa3 3fbf                      	cpi r27, 0xFF
002fa4 f421                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_check_loop:
002fa5 91b0 291f                 	lds r27, noise_arpeggio_macro_loop //load the loop index
002fa7 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002fa8 f451                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_no_loop:
002fa9 91c0 2934                 	lds r28, noise_fx_0xy_sequence //check for 0xy effect
002fab 91d0 2935                 	lds r29, noise_fx_0xy_sequence+1
002fad 9620                      	adiw r29:r28, 0
002fae f469                      	brne sound_driver_instrument_routine_channel3_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002faf 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002fb0 93a0 291e                 	sts noise_arpeggio_macro_offset, r26 //store the last valid index into the offset
002fb2 cfc2                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload:
002fb3 93b0 291e                 	sts noise_arpeggio_macro_offset, r27 //store the loop index into the offset
002fb5 cfbf                      	rjmp sound_driver_instrument_routine_channel3_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_default:
002fb6 91c0 2934                 	lds r28, noise_fx_0xy_sequence //load 0xy effect
002fb8 91d0 2935                 	lds r29, noise_fx_0xy_sequence+1
002fba 9620                      	adiw r29:r28, 0 //check for 0xy effect
002fbb f099                      	breq sound_driver_instrument_routine_channel3_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel3_arpeggio_default_0xy:
002fbc 95d6                      	lsr r29
002fbd 95c7                      	ror r28
002fbe 95d7                      	ror r29
002fbf 95c7                      	ror r28
002fc0 95d7                      	ror r29
002fc1 95c7                      	ror r28
002fc2 95d7                      	ror r29
002fc3 95c7                      	ror r28
002fc4 95d7                      	ror r29
002fc5 95d2                      	swap r29
                                 
002fc6 93c0 2934                 	sts noise_fx_0xy_sequence, r28 //store the rolled sequence
002fc8 93d0 2935                 	sts noise_fx_0xy_sequence+1, r29
002fca 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002fcb 91a0 2817                 	lds r26, noise_note //load the current note index
002fcd 0fac                      	add r26, r28 //add the note offset
002fce c01c                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel3_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002fcf 91a0 2817                 	lds r26, noise_note //load the current note index
002fd1 c019                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process:
002fd2 9220 2922                 	sts noise_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002fd4 9220 2923                 	sts noise_total_pitch_offset+1, zero
002fd6 9220 2929                 	sts noise_total_hi_pitch_offset, zero
002fd8 91a0 2921                 	lds r26, noise_arpeggio_macro_mode
002fda 30a1                      	cpi r26, 0x01 //absolute mode
002fdb f010                      	brlo sound_driver_instrument_routine_channel3_arpeggio_process_absolute
002fdc f031                      	breq sound_driver_instrument_routine_channel3_arpeggio_process_fixed
002fdd c007                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_absolute:
002fde 91a0 2817                 	lds r26, noise_note //load the current note index
002fe0 0fab                      	add r26, r27 //offset the note with the arpeggio data
002fe1 70af                      	andi r26, 0x0F //keep only bits 0-3 in case there was overflow
002fe2 c008                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_fixed:
002fe3 2fab                      	mov r26, r27 //move the arpeggio data into r26
002fe4 c006                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_relative:
002fe5 91a0 2817                 	lds r26, noise_note //load the current note index
002fe7 0fab                      	add r26, r27 //offset the note with the arpeggio data
002fe8 70af                      	andi r26, 0x0F //keep only bits 0-3 in case there was overflow
002fe9 93a0 2817                 	sts noise_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_load:
002feb 93a0 2818                 	sts noise_adjusted_note, r26
002fed c000                      	rjmp sound_driver_instrument_routine_channel3_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch:
002fee 91e0 2924                 	lds ZL, noise_pitch_macro
002ff0 91f0 2925                 	lds ZH, noise_pitch_macro+1
002ff2 9630                      	adiw Z, 0
002ff3 f409                      	brne sound_driver_instrument_routine_channel3_pitch_continue
002ff4 c023                      	rjmp sound_driver_instrument_routine_channel3_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel3_pitch_continue:
002ff5 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002ff6 1fff                      	rol ZH
002ff7 91a0 2926                 	lds r26, noise_pitch_macro_offset
002ff9 0fea                      	add ZL, r26
002ffa 1df2                      	adc ZH, zero
                                 
002ffb 91b0 2928                 	lds r27, noise_pitch_macro_release
002ffd 17ba                      	cp r27, r26
002ffe f429                      	brne sound_driver_instrument_routine_channel3_pitch_increment //if the current offset is not equal to the release index, increment the offset
002fff 91a0 2927                 	lds r26, noise_pitch_macro_loop
003001 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
003002 f010                      	brlo sound_driver_instrument_routine_channel3_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
003003 c003                      	rjmp sound_driver_instrument_routine_channel3_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_pitch_increment:
003004 95a3                      	inc r26 //increment the macro offset
003005 93a0 2926                 	sts noise_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_pitch_read:
003007 91b4                      	lpm r27, Z //load pitch data into r27
003008 38b0                      	cpi r27, 0x80 //check for macro end flag
003009 f479                      	brne sound_driver_instrument_routine_channel3_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag_check_release:
00300a 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00300b 93a0 2926                 	sts noise_pitch_macro_offset, r26
00300d 91b0 2928                 	lds r27, noise_pitch_macro_release
00300f 3fbf                      	cpi r27, 0xFF
003010 f439                      	brne sound_driver_instrument_routine_channel3_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag_check_loop:
003011 91b0 2927                 	lds r27, noise_pitch_macro_loop //load the loop index
003013 3fbf                      	cpi r27, 0xFF //check if there is a loop index
003014 f019                      	breq sound_driver_instrument_routine_channel3_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
003015 93b0 2926                 	sts noise_pitch_macro_offset, r27 //store the loop index into the offset
003017 cfd6                      	rjmp sound_driver_instrument_routine_channel3_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch_default:
003018 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel3_pitch_calculate:
                                 sound_driver_instrument_routine_channel3_pitch_calculate_offset:
003019 91a0 2922                 	lds r26, noise_total_pitch_offset
00301b 0fba                      	add r27, r26
00301c 93b0 2922                 	sts noise_total_pitch_offset, r27
00301e 91a0 2818                 	lds r26, noise_adjusted_note
003020 1bab                      	sub r26, r27
                                 	
003021 91b0 2937                 	lds r27, noise_fx_1xx_total
003023 0fab                      	add r26, r27
003024 91b0 2939                 	lds r27, noise_fx_2xx_total
003026 1bab                      	sub r26, r27
003027 91b0 293d                 	lds r27, noise_fx_4xy_offset
003029 1bab                      	sub r26, r27
00302a 91b0 2945                 	lds r27, noise_fx_Pxx_total
00302c 1bab                      	sub r26, r27
                                 
00302d 70af                      	andi r26, 0x0F
                                 
00302e e4e2                      	ldi ZL, LOW(noise_period_table << 1) //load in note table
00302f e0f1                      	ldi ZH, HIGH(noise_period_table << 1)
003030 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
003031 0fea                      	add ZL, r26 //add offset
003032 1df2                      	adc ZH, zero
003033 91a5                      	lpm r26, Z+ //load bytes
003034 91b4                      	lpm r27, Z
003035 93a0 0abc                 	sts TCB3_CCMPL, r26 //load the LOW bits for timer
003037 93b0 0abd                 	sts TCB3_CCMPH, r27 //load the HIGH bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel3_hi_pitch:
003039 91e0 292a                 	lds ZL, noise_hi_pitch_macro
00303b 91f0 292b                 	lds ZH, noise_hi_pitch_macro+1
00303d 9630                      	adiw Z, 0
00303e f409                      	brne sound_driver_instrument_routine_channel3_hi_pitch_continue
00303f c03c                      	rjmp sound_driver_instrument_routine_channel3_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel3_hi_pitch_continue:
003040 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
003041 1fff                      	rol ZH
003042 91a0 292c                 	lds r26, noise_hi_pitch_macro_offset
003044 0fea                      	add ZL, r26
003045 1df2                      	adc ZH, zero
                                 
003046 91b0 292e                 	lds r27, noise_hi_pitch_macro_release
003048 17ba                      	cp r27, r26
003049 f429                      	brne sound_driver_instrument_routine_channel3_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
00304a 91a0 292d                 	lds r26, noise_hi_pitch_macro_loop
00304c 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00304d f010                      	brlo sound_driver_instrument_routine_channel3_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00304e c003                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_increment:
00304f 95a3                      	inc r26 //increment the macro offset
003050 93a0 292c                 	sts noise_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_hi_pitch_read:
003052 91b4                      	lpm r27, Z //load hi pitch data into r27
003053 38b0                      	cpi r27, 0x80 //check for macro end flag
003054 f489                      	brne sound_driver_instrument_routine_channel3_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag_check_release:
003055 50a1                      	subi r26, 1 //keep the macro offset at the end flag
003056 93a0 292c                 	sts noise_hi_pitch_macro_offset, r26
003058 91b0 292e                 	lds r27, noise_hi_pitch_macro_release
00305a 3fbf                      	cpi r27, 0xFF
00305b f439                      	brne sound_driver_instrument_routine_channel3_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag_check_loop:
00305c 91b0 292d                 	lds r27, noise_hi_pitch_macro_loop //load the loop index
00305e 3fbf                      	cpi r27, 0xFF //check if there is a loop index
00305f f019                      	breq sound_driver_instrument_routine_channel3_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
003060 93b0 292c                 	sts noise_hi_pitch_macro_offset, r27 //store the loop index into the offset
003062 cfd6                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_default:
003063 91b0 2929                 	lds r27, noise_total_hi_pitch_offset
003065 c005                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate:
003066 91a0 2929                 	lds r26, noise_total_hi_pitch_offset //load the total hi pitch offset to change
003068 0fba                      	add r27, r26
003069 93b0 2929                 	sts noise_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate_multiply:
00306b 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00306c 937f                      	push r23
00306d 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
00306e eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00306f 0367                      	mulsu r22, r23
003070 917f                      	pop r23
003071 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate_offset:
003072 91a0 0abc                 	lds r26, TCB3_CCMPL //load the low bits for timer
003074 91b0 0abd                 	lds r27, TCB3_CCMPH //load the high bits for timer
003076 0da0                      	add r26, r0 //offset the timer values
003077 1db1                      	adc r27, r1
003078 93a0 0abc                 	sts TCB3_CCMPL, r26 //store the new low bits for timer
00307a 93b0 0abd                 	sts TCB3_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty:
00307c 91e0 292f                 	lds ZL, noise_duty_macro
00307e 91f0 2930                 	lds ZH, noise_duty_macro+1
003080 9630                      	adiw Z, 0
003081 f169                      	breq sound_driver_channel3_fx_routines //if no duty macro is in use, go to the next routine
003082 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
003083 1fff                      	rol ZH
003084 91a0 2931                 	lds r26, noise_duty_macro_offset
003086 0fea                      	add ZL, r26
003087 1df2                      	adc ZH, zero
                                 
003088 91b0 2933                 	lds r27, noise_duty_macro_release
00308a 17ba                      	cp r27, r26
00308b f429                      	brne sound_driver_instrument_routine_channel3_duty_increment //if the current offset is not equal to the release index, increment the offset
00308c 91a0 2932                 	lds r26, noise_duty_macro_loop
00308e 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00308f f010                      	brlo sound_driver_instrument_routine_channel3_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
003090 c01e                      	rjmp sound_driver_channel3_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel3_duty_increment:
003091 95a3                      	inc r26 //increment the macro offset
003092 93a0 2931                 	sts noise_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_duty_read:
003094 91b4                      	lpm r27, Z //load pitch data into r27
003095 3fbf                      	cpi r27, 0xFF //check for macro end flag
003096 f471                      	brne sound_driver_instrument_routine_channel3_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag_check_release:
003097 50a1                      	subi r26, 1 //keep the macro offset at the end flag
003098 93a0 2931                 	sts noise_duty_macro_offset, r26
00309a 91b0 2933                 	lds r27, noise_duty_macro_release
00309c 3fbf                      	cpi r27, 0xFF
00309d f489                      	brne sound_driver_channel3_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag_check_loop:
00309e 91b0 2932                 	lds r27, noise_duty_macro_loop //load the loop index
0030a0 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0030a1 f069                      	breq sound_driver_channel3_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
0030a2 93b0 2931                 	sts noise_duty_macro_offset, r27 //store the loop index into the offset
0030a4 cfd7                      	rjmp sound_driver_instrument_routine_channel3_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty_load:
0030a5 95b6                      	lsr r27
0030a6 95b7                      	ror r27 //move mode bit to bit 7
0030a7 91c0 2814                 	lds r28, noise_period
0030a9 77cf                      	andi r28, 0b01111111
0030aa 2bcb                      	or r28, r27 //store the new noise mode
0030ab 93c0 2813                 	sts noise_param, r28
                                 
0030ad 776f                      	andi noise_sequence_HIGH, 0b01111111
0030ae 2b6b                      	or noise_sequence_HIGH, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_routines:
                                 sound_driver_channel3_fx_1xx_routine:
0030af 91e0 2936                 	lds ZL, noise_fx_1xx
0030b1 30e0                      	cpi ZL, 0
0030b2 f029                      	breq sound_driver_channel3_fx_2xx_routine
                                 
0030b3 91a0 2937                 	lds r26, noise_fx_1xx_total //load the rate to change the pitch by
0030b5 0fae                      	add r26, ZL //increase the total offset by the rate
0030b6 93a0 2937                 	sts noise_fx_1xx_total, r26
                                 
                                 
                                 
                                 sound_driver_channel3_fx_2xx_routine:
0030b8 91e0 2938                 	lds ZL, noise_fx_2xx
0030ba 30e0                      	cpi ZL, 0
0030bb f029                      	breq sound_driver_channel3_fx_3xx_routine
                                 
0030bc 91a0 2939                 	lds r26, noise_fx_2xx_total //load the rate to change the pitch by
0030be 0fae                      	add r26, ZL //increase the total offset by the rate
0030bf 93a0 2939                 	sts noise_fx_2xx_total, r26
                                 
                                 
                                 
                                 sound_driver_channel3_fx_3xx_routine:
                                 
                                 
                                 
                                 sound_driver_channel3_fx_4xy_routine:
0030c1 91a0 293a                 	lds r26, noise_fx_4xy_speed
0030c3 15a2                      	cp r26, zero
0030c4 f409                      	brne sound_driver_channel3_fx_4xy_routine_continue
0030c5 c033                      	rjmp sound_driver_channel3_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel3_fx_4xy_routine_continue:
0030c6 91b0 293b                 	lds r27, noise_fx_4xy_depth
0030c8 91c0 293c                 	lds r28, noise_fx_4xy_phase
0030ca 0fca                      	add r28, r26 //increase the phase by the speed
0030cb 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
0030cc f008                      	brlo sound_driver_channel3_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
0030cd e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase:
0030ce 93c0 293c                 	sts noise_fx_4xy_phase, r28 //store the new phase
0030d0 31c0                      	cpi r28, 16
0030d1 f028                      	brlo sound_driver_channel3_fx_4xy_routine_phase_0
0030d2 32c0                      	cpi r28, 32
0030d3 f028                      	brlo sound_driver_channel3_fx_4xy_routine_phase_1
0030d4 33c0                      	cpi r28, 48
0030d5 f030                      	brlo sound_driver_channel3_fx_4xy_routine_phase_2
0030d6 c007                      	rjmp sound_driver_channel3_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_0:
0030d7 70cf                      	andi r28, 0x0F //mask for values 0-15
0030d8 c014                      	rjmp sound_driver_channel3_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_1:
0030d9 6fc0                      	ori r28, 0xF0
0030da 95c0                      	com r28 //invert values 0-15
0030db c011                      	rjmp sound_driver_channel3_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_2:
0030dc 70cf                      	andi r28, 0x0F //mask for values 0-15
0030dd c003                      	rjmp sound_driver_channel3_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_3:
0030de 6fc0                      	ori r28, 0xF0
0030df 95c0                      	com r28 //invert values 0-15
0030e0 c000                      	rjmp sound_driver_channel3_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel3_fx_4xy_routine_load_add:
0030e1 95b2                      	swap r27 //multiply depth by 16
0030e2 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0030e3 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0030e4 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0030e5 0fec                      	add ZL, r28 //offset the table by the depth+phase
0030e6 1df2                      	adc ZH, zero
0030e7 91c4                      	lpm r28, Z //load the tremelo value into r28
0030e8 95c2                      	swap r28
0030e9 70cf                      	andi r28, 0x0F
                                 
0030ea 93c0 293d                 	sts noise_fx_4xy_offset, r28
0030ec c00c                      	rjmp sound_driver_channel3_fx_7xy_routine
                                 
                                 sound_driver_channel3_fx_4xy_routine_load_subtract:
0030ed 95b2                      	swap r27 //multiply depth by 16
0030ee 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
0030ef e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0030f0 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0030f1 0fec                      	add ZL, r28 //offset the table by the depth+phase
0030f2 1df2                      	adc ZH, zero
0030f3 91c4                      	lpm r28, Z //load the vibrato value into r28
0030f4 95c2                      	swap r28
0030f5 70cf                      	andi r28, 0x0F
                                 
0030f6 95c1                      	neg r28
0030f7 93c0 293d                 	sts noise_fx_4xy_offset, r28
                                 
                                 
                                 
                                 sound_driver_channel3_fx_7xy_routine:
0030f9 91a0 293e                 	lds r26, noise_fx_7xy_speed
0030fb 15a2                      	cp r26, zero
0030fc f0e9                      	breq sound_driver_channel3_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
0030fd 91b0 293f                 	lds r27, noise_fx_7xy_depth
0030ff 91c0 2940                 	lds r28, noise_fx_7xy_phase
003101 0fca                      	add r28, r26 //increase the phase by the speed
003102 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
003103 f008                      	brlo sound_driver_channel3_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
003104 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel3_fx_7xy_routine_phase:
003105 93c0 2940                 	sts noise_fx_7xy_phase, r28 //store the new phase
003107 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
003108 ffc4                      	sbrs r28, 4
003109 c001                      	rjmp sound_driver_channel3_fx_7xy_routine_phase_0
00310a c002                      	rjmp sound_driver_channel3_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel3_fx_7xy_routine_phase_0:
00310b 70cf                      	andi r28, 0x0F //mask for values 0-15
00310c c003                      	rjmp sound_driver_channel3_fx_7xy_routine_load
                                 
                                 sound_driver_channel3_fx_7xy_routine_phase_1:
00310d 6fc0                      	ori r28, 0xF0
00310e 95c0                      	com r28 //invert values 0-15
00310f c000                      	rjmp sound_driver_channel3_fx_7xy_routine_load
                                 
                                 sound_driver_channel3_fx_7xy_routine_load:
003110 95b2                      	swap r27 //multiply depth by 16
003111 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
003112 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
003113 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
003114 0fec                      	add ZL, r28 //offset the table by the depth+phase
003115 1df2                      	adc ZH, zero
003116 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
003117 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
003118 93c0 2941                 	sts noise_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Axy_routine:
00311a 91b0 2942                 	lds r27, noise_fx_Axy
00311c 15b2                      	cp r27, zero
00311d f0e9                      	breq sound_driver_channel3_fx_Qxy_routine //0 means that the effect is not in use
                                 	
00311e 91a0 2815                 	lds r26, noise_fractional_volume //load fractional volume representation of the channel
003120 91c0 2813                 	lds r28, noise_param //load the integer volume representation of the channel
003122 2fda                      	mov r29, r26 //copy fractional volume into r29
003123 2fec                      	mov r30, r28 //copy the noise_param into r30
003124 95e2                      	swap r30
003125 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
003126 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
003127 17ed                      	cp r30, r29 //compare the fractional and integer volumes
003128 f009                      	breq sound_driver_channel3_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel3_fx_Axy_routine_reload:
003129 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate:
00312a fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
00312b c004                      	rjmp sound_driver_channel3_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_addition:
00312c 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
00312d f428                      	brcc sound_driver_channel3_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
00312e efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
00312f c003                      	rjmp sound_driver_channel3_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_subtraction:
003130 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
003131 f008                      	brcs sound_driver_channel3_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
003132 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_store:
003133 93a0 2815                 	sts noise_fractional_volume, r26 //store the new fractional volume
003135 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
003136 95a2                      	swap r26
003137 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
003138 2bca                      	or r28, r26 //store the new volume back into noise_param
003139 93c0 2813                 	sts noise_param, r28
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Qxy_routine:
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Rxy_routine:
                                 
                                 
                                 
                                 sound_driver_exit:
00313b 91ff                      	pop r31
00313c 91ef                      	pop r30
00313d 91df                      	pop r29
00313e 91cf                      	pop r28
00313f 940c 1716                 	jmp sequence_1_3 + 3 //+3 is to skip the stack instructions since we already pushed them
                                 
                                 
                                 
                                 //TABLES
003141 7f05
003142 010a
003143 0214
003144 0328
003145 0450
003146 051e
003147 0607
003148 070d
003149 0806
00314a 090c
00314b 0a18
00314c 0b30
00314d 0c60
00314e 0d24
00314f 0e08
003150 0f10                      length: .db $05, $7F, $0A, $01, $14, $02, $28, $03, $50, $04, $1E, $05, $07, $06, $0D, $07, $06, $08, $0C, $09, $18, $0A, $30, $0B, $60, $0C, $24, $0D, $08, $0E, $10, $0F
                                 
                                 //pulse sequences: 12.5%, 25%, 50%, 75%
003151 0301
003152 fc0f                      sequences: .db 0b00000001, 0b00000011, 0b00001111, 0b11111100
                                 
                                 //list of famitracker fx: http://famitracker.com/wiki/index.php?title=Effect_list
                                 channel0_fx:
003153 194d
003154 1952
003155 196e
003156 198a
003157 19ad                      	.dw sound_driver_channel0_fx_0xy, sound_driver_channel0_fx_1xx, sound_driver_channel0_fx_2xx, sound_driver_channel0_fx_3xx, sound_driver_channel0_fx_4xy
003158 19b8
003159 19c5
00315a 19c8
00315b 19cb
00315c 19ce                      	.dw sound_driver_channel0_fx_7xy, sound_driver_channel0_fx_Axy, sound_driver_channel0_fx_Bxx, sound_driver_channel0_fx_Cxx, sound_driver_channel0_fx_Dxx
00315d 19d1
00315e 19d9
00315f 19dc
003160 19e9
003161 19ea                      	.dw sound_driver_channel0_fx_Exx, sound_driver_channel0_fx_Fxx, sound_driver_channel0_fx_Gxx, sound_driver_channel0_fx_Hxy, sound_driver_channel0_fx_Ixy
003162 19eb
003163 19ec
003164 19ed
003165 1a05
003166 1a47                      	.dw sound_driver_channel0_fx_Hxx, sound_driver_channel0_fx_Ixx, sound_driver_channel0_fx_Pxx, sound_driver_channel0_fx_Qxy, sound_driver_channel0_fx_Rxy
003167 1a88
003168 1a95
003169 1aa9
00316a 1aaa
00316b 1aab                      	.dw sound_driver_channel0_fx_Sxx, sound_driver_channel0_fx_Vxx, sound_driver_channel0_fx_Wxx, sound_driver_channel0_fx_Xxx, sound_driver_channel0_fx_Yxx
00316c 1aac                      	.dw sound_driver_channel0_fx_Zxx
                                 
                                 channel1_fx:
00316d 1c3b
00316e 1c40
00316f 1c5c
003170 1c78
003171 1c9b                      	.dw sound_driver_channel1_fx_0xy, sound_driver_channel1_fx_1xx, sound_driver_channel1_fx_2xx, sound_driver_channel1_fx_3xx, sound_driver_channel1_fx_4xy
003172 1ca6
003173 1cb3
003174 1cb6
003175 1cb9
003176 1cbc                      	.dw sound_driver_channel1_fx_7xy, sound_driver_channel1_fx_Axy, sound_driver_channel1_fx_Bxx, sound_driver_channel1_fx_Cxx, sound_driver_channel1_fx_Dxx
003177 1cbf
003178 1cc7
003179 1cca
00317a 1cd7
00317b 1cd8                      	.dw sound_driver_channel1_fx_Exx, sound_driver_channel1_fx_Fxx, sound_driver_channel1_fx_Gxx, sound_driver_channel1_fx_Hxy, sound_driver_channel1_fx_Ixy
00317c 1cd9
00317d 1cda
00317e 1cdb
00317f 1cf3
003180 1d35                      	.dw sound_driver_channel1_fx_Hxx, sound_driver_channel1_fx_Ixx, sound_driver_channel1_fx_Pxx, sound_driver_channel1_fx_Qxy, sound_driver_channel1_fx_Rxy
003181 1d76
003182 1d83
003183 1d97
003184 1d98
003185 1d99                      	.dw sound_driver_channel1_fx_Sxx, sound_driver_channel1_fx_Vxx, sound_driver_channel1_fx_Wxx, sound_driver_channel1_fx_Xxx, sound_driver_channel1_fx_Yxx
003186 1d9a                      	.dw sound_driver_channel1_fx_Zxx
                                 
                                 channel2_fx:
003187 1f1c
003188 1f21
003189 1f3d
00318a 1f59
00318b 1f7c                      	.dw sound_driver_channel2_fx_0xy, sound_driver_channel2_fx_1xx, sound_driver_channel2_fx_2xx, sound_driver_channel2_fx_3xx, sound_driver_channel2_fx_4xy
00318c 1f87
00318d 1f88
00318e 1f89
00318f 1f8c
003190 1f8f                      	.dw sound_driver_channel2_fx_7xy, sound_driver_channel2_fx_Axy, sound_driver_channel2_fx_Bxx, sound_driver_channel2_fx_Cxx, sound_driver_channel2_fx_Dxx
003191 1f92
003192 1f9f
003193 1fa2
003194 1faf
003195 1fb0                      	.dw sound_driver_channel2_fx_Exx, sound_driver_channel2_fx_Fxx, sound_driver_channel2_fx_Gxx, sound_driver_channel2_fx_Hxy, sound_driver_channel2_fx_Ixy
003196 1fb1
003197 1fb2
003198 1fb3
003199 1fcb
00319a 200d                      	.dw sound_driver_channel2_fx_Hxx, sound_driver_channel2_fx_Ixx, sound_driver_channel2_fx_Pxx, sound_driver_channel2_fx_Qxy, sound_driver_channel2_fx_Rxy
00319b 204e
00319c 205b
00319d 205c
00319e 205d
00319f 205e                      	.dw sound_driver_channel2_fx_Sxx, sound_driver_channel2_fx_Vxx, sound_driver_channel2_fx_Wxx, sound_driver_channel2_fx_Xxx, sound_driver_channel2_fx_Yxx
0031a0 205f                      	.dw sound_driver_channel2_fx_Zxx
                                 
                                 channel3_fx:
0031a1 21e5
0031a2 21ea
0031a3 21f3
0031a4 21fc
0031a5 21fd                      	.dw sound_driver_channel3_fx_0xy, sound_driver_channel3_fx_1xx, sound_driver_channel3_fx_2xx, sound_driver_channel3_fx_3xx, sound_driver_channel3_fx_4xy
0031a6 220a
0031a7 2217
0031a8 221a
0031a9 221d
0031aa 2220                      	.dw sound_driver_channel3_fx_7xy, sound_driver_channel3_fx_Axy, sound_driver_channel3_fx_Bxx, sound_driver_channel3_fx_Cxx, sound_driver_channel3_fx_Dxx
0031ab 2223
0031ac 222a
0031ad 222d
0031ae 223a
0031af 223b                      	.dw sound_driver_channel3_fx_Exx, sound_driver_channel3_fx_Fxx, sound_driver_channel3_fx_Gxx, sound_driver_channel3_fx_Hxy, sound_driver_channel3_fx_Ixy
0031b0 223c
0031b1 223d
0031b2 223e
0031b3 2241
0031b4 2242                      	.dw sound_driver_channel3_fx_Hxx, sound_driver_channel3_fx_Ixx, sound_driver_channel3_fx_Pxx, sound_driver_channel3_fx_Qxy, sound_driver_channel3_fx_Rxy
0031b5 2243
0031b6 2250
0031b7 225b
0031b8 225c
0031b9 225d                      	.dw sound_driver_channel3_fx_Sxx, sound_driver_channel3_fx_Vxx, sound_driver_channel3_fx_Wxx, sound_driver_channel3_fx_Xxx, sound_driver_channel3_fx_Yxx
0031ba 225e                      	.dw sound_driver_channel3_fx_Zxx
                                 
                                 channel4_fx:
0031bb 23a8
0031bc 23a9
0031bd 23aa
0031be 23ab
0031bf 23ac                      	.dw sound_driver_channel4_fx_0xy, sound_driver_channel4_fx_1xx, sound_driver_channel4_fx_2xx, sound_driver_channel4_fx_3xx, sound_driver_channel4_fx_4xy
0031c0 23ad
0031c1 23ae
0031c2 23af
0031c3 23b2
0031c4 23b5                      	.dw sound_driver_channel4_fx_7xy, sound_driver_channel4_fx_Axy, sound_driver_channel4_fx_Bxx, sound_driver_channel4_fx_Cxx, sound_driver_channel4_fx_Dxx
0031c5 23b8
0031c6 23b9
0031c7 23bc
0031c8 23c9
0031c9 23ca                      	.dw sound_driver_channel4_fx_Exx, sound_driver_channel4_fx_Fxx, sound_driver_channel4_fx_Gxx, sound_driver_channel4_fx_Hxy, sound_driver_channel4_fx_Ixy
0031ca 23cb
0031cb 23cc
0031cc 23cd
0031cd 23ce
0031ce 23cf                      	.dw sound_driver_channel4_fx_Hxx, sound_driver_channel4_fx_Ixx, sound_driver_channel4_fx_Pxx, sound_driver_channel4_fx_Qxy, sound_driver_channel4_fx_Rxy
0031cf 23d0
0031d0 23dd
0031d1 23de
0031d2 23df
0031d3 23e0                      	.dw sound_driver_channel4_fx_Sxx, sound_driver_channel4_fx_Vxx, sound_driver_channel4_fx_Wxx, sound_driver_channel4_fx_Xxx, sound_driver_channel4_fx_Yxx
0031d4 23e1                      	.dw sound_driver_channel4_fx_Zxx
                                 
                                 //famitracker volumes table: http://famitracker.com/wiki/index.php?title=Volume
                                 volumes:
0031d5 0000
0031d6 0000
0031d7 0000
0031d8 0000
0031d9 0000
0031da 0000
0031db 0000
0031dc 0000                      	.db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
0031dd 0100
0031de 0101
0031df 0101
0031e0 0101
0031e1 0101
0031e2 0101
0031e3 0101
0031e4 0101                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
0031e5 0100
0031e6 0101
0031e7 0101
0031e8 0101
0031e9 0101
0031ea 0101
0031eb 0101
0031ec 0201                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02
0031ed 0100
0031ee 0101
0031ef 0101
0031f0 0101
0031f1 0101
0031f2 0202
0031f3 0202
0031f4 0302                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03
0031f5 0100
0031f6 0101
0031f7 0101
0031f8 0101
0031f9 0202
0031fa 0202
0031fb 0303
0031fc 0403                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04
0031fd 0100
0031fe 0101
0031ff 0101
003200 0202
003201 0302
003202 0303
003203 0404
003204 0504                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05
003205 0100
003206 0101
003207 0201
003208 0202
003209 0303
00320a 0404
00320b 0504
00320c 0605                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x06
00320d 0100
00320e 0101
00320f 0201
003210 0302
003211 0403
003212 0504
003213 0605
003214 0706                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07
003215 0100
003216 0101
003217 0202
003218 0303
003219 0404
00321a 0505
00321b 0606
00321c 0807                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07, 0x08
00321d 0100
00321e 0101
00321f 0302
003220 0403
003221 0504
003222 0606
003223 0707
003224 0908                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09
003225 0100
003226 0201
003227 0302
003228 0404
003229 0605
00322a 0706
00322b 0808
00322c 0a09                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A
00322d 0100
00322e 0201
00322f 0302
003230 0504
003231 0605
003232 0807
003233 0908
003234 0b0a                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B
003235 0100
003236 0201
003237 0403
003238 0504
003239 0706
00323a 0808
00323b 0a09
00323c 0c0b                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B, 0x0C
00323d 0100
00323e 0201
00323f 0403
003240 0605
003241 0706
003242 0908
003243 0b0a
003244 0d0c                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D
003245 0100
003246 0201
003247 0403
003248 0605
003249 0807
00324a 0a09
00324b 0c0b
00324c 0e0d                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E
00324d 0100
00324e 0302
00324f 0504
003250 0706
003251 0908
003252 0b0a
003253 0d0c


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega4809" register use summary:
x  :   0 y  :   0 z  : 249 r0 : 148 r1 : 160 r2 : 668 r3 :   3 r4 :   4 
r5 :   0 r6 :   0 r7 :   6 r8 :   4 r9 :   9 r10:   6 r11:   4 r12:   9 
r13:   1 r14:   1 r15:   2 r16:   7 r17:   6 r18:   7 r19:   6 r20:   4 
r21:   9 r22: 138 r23: 127 r24:   3 r25:  24 r26: 942 r27:1203 r28: 666 
r29: 350 r30: 383 r31: 331 
Registers used: 31 out of 35 (88.6%)

"ATmega4809" instruction use summary:
.lds  :   0 .sts  :   0 adc   : 132 add   : 183 adiw  : 100 and   :   2 
andi  :  99 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   6 brcs  :  13 break :   0 breq  : 173 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  76 brlt  :   0 brmi  :   0 
brne  : 123 brpl  :   0 brsh  :  37 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :   0 cbr   :   5 
clc   :   0 clh   :   0 cli   :   6 cln   :   0 clr   :   5 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :  16 cp    : 115 cpc   :  15 
cpi   : 175 cpse  :  21 dec   :  40 des   :   0 eor   :   2 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   5 in    :   5 inc   :  46 
jmp   :   8 ld    :   0 ldd   :   0 ldi   : 300 lds   : 675 lpm   : 273 
lsl   :  80 lsr   : 135 mov   : 146 movw  :   0 mul   :  21 muls  :   0 
mulsu :  10 neg   :   1 nop   :   0 or    :  24 ori   :  12 out   :   9 
pop   :  97 push  :  89 rcall :  56 ret   :  34 reti  :   7 rjmp  : 560 
rol   :  57 ror   : 156 sbc   :  30 sbci  :   0 sbi   :   0 sbic  :   0 
sbis  :   0 sbiw  :   0 sbr   :  12 sbrc  :  25 sbrs  :  18 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   :1349 sub   :  53 subi  :  49 swap  :  47 tst   :   0 wdr   :   0 

Instructions used: 54 out of 114 (47.4%)

"ATmega4809" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x0064aa  15332  10314  25646   49152  52.2%
[.dseg] 0x002800 0x002956      0    342    342    6144   5.6%
[.eseg] 0x000000 0x000000      0      0      0     256   0.0%

Assembly complete, 0 errors, 103 warnings
